<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Traits in Cairo - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch08-02-traits-in-cairo.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("id");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch08-02-traits-in-cairo.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch08-02-traits-in-cairo.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="traits-in-cairo"><a class="header" href="#traits-in-cairo">Traits in Cairo</a></h1>
<p>A trait defines a set of methods that can be implemented by a type. These
methods can be called on instances of the type when this trait is implemented. A
trait combined with a generic type defines functionality a particular type has
and can share with other types. We can use traits to define shared behavior in
an abstract way. We can use <em>trait bounds</em> to specify that a generic type can be
any type that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called interfaces in other
languages, although with some differences.</p>
</blockquote>
<p>While traits can be written to not accept generic types, they are most useful
when used with generic types. We already covered generics in the <a href="./ch08-01-generic-data-types.html">previous
chapter</a>, and we will use them in this chapter to demonstrate how
traits can be used to define shared behavior for generic types.</p>
<h2 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a Trait</a></h2>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to define
a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have a struct <code>NewsArticle</code> that holds a news story in
a particular location. We can define a trait <code>Summary</code> that describes the
behavior of something that can summarize the <code>NewsArticle</code> type.</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[derive(Drop, Clone)]
</span><span class="boring">struct NewsArticle {
</span><span class="boring">    headline: ByteArray,
</span><span class="boring">    location: ByteArray,
</span><span class="boring">    author: ByteArray,
</span><span class="boring">    content: ByteArray,
</span><span class="boring">}
</span><span class="boring">
</span>pub trait Summary {
    fn summarize(self: @NewsArticle) -&gt; ByteArray;
}
<span class="boring">
</span><span class="boring">impl NewsArticleSummary of Summary {
</span><span class="boring">    fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">        format!("{:?} by {:?} ({:?})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>8-1: A <code>Summary</code> trait that consists of the behavior
provided by a <code>summarize</code> method</span></p>
<p>In Listing 8-1, we declare a trait using the <code>trait</code>
keyword and then the trait’s name, which is <code>Summary</code> in this case. We’ve also
declared the trait as <code>pub</code> so that crates depending on this crate can make use
of this trait too, as we’ll see in a few examples.</p>
<p>Inside the curly brackets, we declare the method signatures that describe the
behaviors of the types that implement this trait, which in this case is
<code>fn summarize(self: @NewsArticle) -&gt; ByteArray;</code>. After the method signature,
instead of providing an implementation within curly brackets, we use a
semicolon.</p>
<blockquote>
<p>Note: the <code>ByteArray</code> type is the type used to represent strings in Cairo.</p>
</blockquote>
<p>As the trait is not generic, the <code>self</code> parameter is not generic either and is
of type <code>@NewsArticle</code>. This means that the <code>summarize</code> method can only be
called on instances of <code>NewsArticle</code>.</p>
<p>Now, consider that we want to make a media aggregator library crate named
<em>aggregator</em> that can display summaries of data that might be stored in a
<code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we need a summary from each type,
and we’ll request that summary by calling a summarize method on an instance of
that type. By defining the <code>Summary</code> trait on generic type <code>T</code>, we can implement
the <code>summarize</code> method on any type we want to be able to summarize.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>8-2: A <code>Summary</code> trait that consists of the behavior
provided by a <code>summarize</code> method for a generic type</span></p>
<p>Each type implementing this trait must provide its own custom behavior for the
body of the method. The compiler will enforce that any type that implements the
<code>Summary</code> trait will have the method <code>summarize</code> defined with this signature
exactly.</p>
<p>A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.</p>
<h2 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></h2>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods,
we can implement it on the types in our media aggregator. The following code
shows an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that
uses the headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the tweet, assuming that tweet content is already
limited to 280 characters.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
        fn summarize(self: @NewsArticle) -&gt; ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize(self: @Tweet) -&gt; ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Implementation of the <code>Summary</code> trait on <code>NewsArticle</code> and <code>Tweet</code></span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put a name for the implementation, then use
the <code>of</code> keyword, and then specify the name of the trait we are writing the
implementation for. If the implementation is for a generic type, we place the
generic type name in the angle brackets after the trait name.</p>
<p>Note that for the trait method to be accessible, there must be an implementation
of that trait visible from the scope where the method is called. If the trait is
<code>pub</code> and the implementation is not, and the implementation is not visible in
the scope where the trait method is called, this will cause a compilation error.</p>
<p>Within the <code>impl</code> block, we put the method signatures that the trait definition
has defined. Instead of adding a semicolon after each signature, we use curly
brackets and fill in the method body with the specific behavior that we want the
methods of the trait to have for the particular type.</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and
<code>Tweet</code>, users of the crate can call the trait methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods. The only
difference is that the user must bring the trait into scope as well as the
types. Here’s an example of how a crate could use our <code>aggregator</code> crate:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary, Tweet};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints the following:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_15_traits
New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
New tweet! EliBenSasson: Crypto is full of short-term maximizing projects. 
 @Starknet and @StarkWareLtd are about long-term vision maximization.


</code></pre>
<p>Other crates that depend on the <em>aggregator</em> crate can also bring the <code>Summary</code>
trait into scope to implement <code>Summary</code> on their own types.</p>
<h2 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h2>
<p>Sometimes it’s useful to have default behavior for some or all of the methods in
a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.</p>
<p>In Listing 8-5 we specify a default string for the <code>summarize</code>
method of the <code>Summary</code> trait instead of only defining the method signature, as
we did in Listing 8-2.</p>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray {
            "(Read more...)"
        }
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Defining a <code>Summary</code> trait with a default implementation of the <code>summarize</code>
method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code>, we
specify an empty <code>impl</code> block with
<code>impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}</code>.</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code>
directly, we’ve provided a default implementation and specified that
<code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call the
<code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray {
</span><span class="boring">            "(Read more...)"
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation doesn’t require us to change anything about
the previous implementation of <code>Summary</code> on <code>Tweet</code>. The reason is that the
syntax for overriding a default implementation is the same as the syntax for
implementing a trait method that doesn’t have a default implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify a
small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, and then define a
<code>summarize</code> method that has a default implementation that calls the
<code>summarize_author</code> method:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(
            self: @T,
        ) -&gt; ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code> when
we implement the trait on a type:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span>    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize_author(self: @Tweet) -&gt; ByteArray {
            format!("@{}", self.username)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code.</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{Summary, Tweet};

#[executable]
fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>1 new tweet: (Read more from @EliBenSasson...)</code>.</p>
<p>Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.</p>
<!-- TODO: NOT AVAILABLE IN CAIRO FOR NOW move traits as parameters here -->
<!-- ## Traits as parameters

Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types. We'll use the
`Summary` trait we implemented on the `NewsArticle` and `Tweet` types to define a `notify` function that calls the `summarize` method
on its `item` parameter, which is of some type that implements the `Summary` trait. To do this, we use the `impl Trait` syntax.

Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`. -->
<!-- TODO NOT AVAILABLE IN CAIRO FOR NOW Using trait bounds to conditionally implement methods -->
<h2 id="managing-and-using-external-trait"><a class="header" href="#managing-and-using-external-trait">Managing and Using External Trait</a></h2>
<p>To use traits methods, you need to make sure the correct
traits/implementation(s) are imported. In some cases you might need to import
not only the trait but also the implementation if they are declared in separate
modules. If <code>CircleGeometry</code> implementation was in a separate module/file named
<em>circle</em>, then to define <code>boundary</code> method on <code>Circle</code> struct, we'd need to
import <code>ShapeGeometry</code> trait in the <em>circle</em> module.</p>
<p>If the code were to be organized into modules like in Listing
8-6 where the implementation of a trait is defined in a
different module than the trait itself, explicitly importing the relevant trait
or implementation would be required.</p>
<pre><code class="language-cairo noplayground">// Here T is an alias type which will be provided during implementation
pub trait ShapeGeometry&lt;T&gt; {
    fn boundary(self: T) -&gt; u64;
    fn area(self: T) -&gt; u64;
}

mod rectangle {
    // Importing ShapeGeometry is required to implement this trait for Rectangle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Rectangle {
        pub height: u64,
        pub width: u64,
    }

    // Implementation RectangleGeometry passes in &lt;Rectangle&gt;
    // to implement the trait for that type
    impl RectangleGeometry of ShapeGeometry&lt;Rectangle&gt; {
        fn boundary(self: Rectangle) -&gt; u64 {
            2 * (self.height + self.width)
        }
        fn area(self: Rectangle) -&gt; u64 {
            self.height * self.width
        }
    }
}

mod circle {
    // Importing ShapeGeometry is required to implement this trait for Circle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Circle {
        pub radius: u64,
    }

    // Implementation CircleGeometry passes in &lt;Circle&gt;
    // to implement the imported trait for that type
    impl CircleGeometry of ShapeGeometry&lt;Circle&gt; {
        fn boundary(self: Circle) -&gt; u64 {
            (2 * 314 * self.radius) / 100
        }
        fn area(self: Circle) -&gt; u64 {
            (314 * self.radius * self.radius) / 100
        }
    }
}
use circle::Circle;
use rectangle::Rectangle;

#[executable]
fn main() {
    let rect = Rectangle { height: 5, width: 7 };
    println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
    println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24

    let circ = Circle { radius: 5 };
    println!("Circle area: {}", ShapeGeometry::area(circ)); //78
    println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
}
</code></pre>
<p>8-6: Implementing an external trait</span></p>
<p>Note that in Listing 8-6, <code>CircleGeometry</code> and
<code>RectangleGeometry</code> implementations don't need to be declared as <code>pub</code>. Indeed,
<code>ShapeGeometry</code> trait, which is public, is used to print the result in the
<code>main</code> function. The compiler will find the appropriate implementation for the
<code>ShapeGeometry</code> public trait, regardless of the implementation visibility.</p>
<h2 id="impl-aliases"><a class="header" href="#impl-aliases">Impl Aliases</a></h2>
<p>Implementations can be aliased when imported. This is most useful when you want
to instantiate generic implementations with concrete types. For example, let's
say we define a trait <code>Two</code> that is used to return the value <code>2</code> for a type <code>T</code>.
We can write a trivial generic implementation of <code>Two</code> for all types that
implement the <code>One</code> trait, simply by adding twice the value of <code>one</code> and
returning it. However, in our public API, we may only want to expose the <code>Two</code>
implementation for the <code>u8</code> and <code>u128</code> types.</p>
<pre><code class="language-cairo noplayground">trait Two&lt;T&gt; {
    fn two() -&gt; T;
}

mod one_based {
    pub impl TwoImpl&lt;
        T, +Copy&lt;T&gt;, +Drop&lt;T&gt;, +Add&lt;T&gt;, impl One: core::num::traits::One&lt;T&gt;,
    &gt; of super::Two&lt;T&gt; {
        fn two() -&gt; T {
            One::one() + One::one()
        }
    }
}

pub impl U8Two = one_based::TwoImpl&lt;u8&gt;;
pub impl U128Two = one_based::TwoImpl&lt;u128&gt;;
</code></pre>
<p>Using impl aliases to instantiate generic impls with concrete types</span></p>
<p>We can define the generic implementation in a private module, use an impl alias
to instantiate the generic implementation for these two concrete types, and make
these two implementations public, while keeping the generic implementation
private and unexposed. This way, we can avoid code duplication using the generic
implementation, while keeping the public API clean and simple.</p>
<h2 id="negative-impls"><a class="header" href="#negative-impls">Negative Impls</a></h2>
<blockquote>
<p>Note: This is still an experimental feature and can only be used if
<code>experimental-features = ["negative_impls"]</code> is enabled in your <em>Scarb.toml</em>
file, under the <code>[package]</code> section.</p>
</blockquote>
<p>Negative implementations, also known as negative traits or negative bounds, are
a mechanism that allows you to express that a type does not implement a certain
trait when defining the implementation of a trait over a generic type. Negative
impls enable you to write implementations that are applicable only when another
implementation does not exist in the current scope.</p>
<p>For example, let's say we have a trait <code>Producer</code> and a trait <code>Consumer</code>, and we
want to define a generic behavior where all types implement the <code>Consumer</code> trait
by default. However, we want to ensure that no type can be both a <code>Consumer</code> and
a <code>Producer</code>. We can use negative impls to express this restriction.</p>
<p>In Listing 8-8, we define a <code>ProducerType</code> that implements
the <code>Producer</code> trait, and two other types, <code>AnotherType</code> and <code>AThirdType</code>, which
do not implement the <code>Producer</code> trait. We then use negative impls to create a
default implementation of the <code>Consumer</code> trait for all types that do not
implement the <code>Producer</code> trait.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct ProducerType {}

#[derive(Drop, Debug)]
struct AnotherType {}

#[derive(Drop, Debug)]
struct AThirdType {}

trait Producer&lt;T&gt; {
    fn produce(self: T) -&gt; u32;
}

trait Consumer&lt;T&gt; {
    fn consume(self: T, input: u32);
}

impl ProducerImpl of Producer&lt;ProducerType&gt; {
    fn produce(self: ProducerType) -&gt; u32 {
        42
    }
}

impl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {
    fn consume(self: T, input: u32) {
        println!("{:?} consumed value: {}", self, input);
    }
}

#[executable]
fn main() {
    let producer = ProducerType {};
    let another_type = AnotherType {};
    let third_type = AThirdType {};
    let production = producer.produce();

    // producer.consume(production); Invalid: ProducerType does not implement Consumer
    another_type.consume(production);
    third_type.consume(production);
}
</code></pre>
<p>8-8: Using negative impls to enforce that a type cannot
implement both <code>Producer</code> and <code>Consumer</code> traits simultaneously</span></p>
<p>In the <code>main</code> function, we create instances of <code>ProducerType</code>, <code>AnotherType</code>,
and <code>AThirdType</code>. We then call the <code>produce</code> method on the <code>producer</code> instance
and pass the result to the <code>consume</code> method on the <code>another_type</code> and
<code>third_type</code> instances. Finally, we try to call the <code>consume</code> method on the
<code>producer</code> instance, which results in a compile-time error because
<code>ProducerType</code> does not implement the <code>Consumer</code> trait.</p>
<h2 id="constraint-traits-on-associated-items"><a class="header" href="#constraint-traits-on-associated-items">Constraint traits on associated items</a></h2>
<blockquote>
<p>Currently, associated items are considered an experimental feature. In order
to use them, you need to add the following to your <code>Scarb.toml</code> under the
<code>[package]</code> section:
<code>experimental-features = ["associated_item_constraints"]</code>.</p>
</blockquote>
<p>In some cases, you may want to constrain the <a href="./ch12-10-associated-items.html">associated items</a> of a trait based
on the type of the generic parameter. You can do this using the
<code>[AssociatedItem: ConstrainedValue]</code> syntax after a trait bound.</p>
<p>Let's say you want to implement an <code>extend</code> method for collections. This method
takes an iterator and add its elements to the collection. To ensure type safety,
we want the iterator's elements to match the collection's element type. We can
achieve this by constraining the <code>Iterator::Item</code> associated type to match the
collection's type.</p>
<p>In Listing 8-9, we implement this by defining
a trait <code>Extend&lt;T, A&gt;</code> and use <code>[Item: A]</code> as a constraint on the <code>extend</code>
function's trait bound. Additionally, we use the <code>Destruct</code> trait to ensure that
the iterator is consumed, and show an example implementation for
<code>Extend&lt;Array&lt;T&gt;, T&gt;</code>.</p>
<pre><code class="language-cairo">trait Extend&lt;T, A&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: A], +Destruct&lt;I&gt;&gt;(ref self: T, iterator: I);
}

impl ArrayExtend&lt;T, +Drop&lt;T&gt;&gt; of Extend&lt;Array&lt;T&gt;, T&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: T], +Destruct&lt;I&gt;&gt;(ref self: Array&lt;T&gt;, iterator: I) {
        for item in iterator {
            self.append(item);
        }
    }
}
</code></pre>
<p>8-9: Using associated items constraints to
ensure that a type matches the associated type of another type</span></p>
<h2 id="typeequal-trait-for-type-equality-constraints"><a class="header" href="#typeequal-trait-for-type-equality-constraints"><code>TypeEqual</code> Trait for type equality constraints</a></h2>
<p>The <code>TypeEqual</code> trait from the <code>core::metaprogramming</code> module lets you create
constraints based on type equality. In most of the cases, you don't need
<code>+TypeEqual</code> and you can achieve the same using only generic arguments and
associated type constraints, but <code>TypeEqual</code> can be useful in some advanced
scenarios.</p>
<p>The first use case is implementing a trait for all types that match certain
conditions, except for specific types. We do this using a negative
implementation on the <code>TypeEqual</code> trait.</p>
<p>In Listing 8-10, we create a <code>SafeDefault</code>
trait and implement it for any type <code>T</code> that implements <code>Default</code>. However, we
exclude the <code>SensitiveData</code> type using <code>-TypeEqual&lt;T, SensitiveData&gt;</code>.</p>
<pre><code class="language-cairo">trait SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T;
}

#[derive(Drop, Default)]
struct SensitiveData {
    secret: felt252,
}

// Implement SafeDefault for all types EXCEPT SensitiveData
impl SafeDefaultImpl&lt;
    T, +Default&lt;T&gt;, -core::metaprogramming::TypeEqual&lt;T, SensitiveData&gt;,
&gt; of SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T {
        Default::default()
    }
}

#[executable]
fn main() {
    let _safe: u8 = SafeDefault::safe_default();
    let _unsafe: SensitiveData = Default::default(); // Allowed
    // This would cause a compile error:
// let _dangerous: SensitiveData = SafeDefault::safe_default();
}
</code></pre>
<p>8-10: Using the <code>TypeEqual</code> trait to exclude
a specific type from an implementation</span></p>
<p>The second use case is ensuring that two types are equal, particularly useful
when working with <a href="./ch12-10-associated-items.html#associated-types">associated types</a>.</p>
<p>In Listing 8-11, we show this with a <code>StateMachine</code>
trait that has an associated type <code>State</code>. We create two types, <code>TA</code> and <code>TB</code>,
both using <code>StateCounter</code> as their <code>State</code>. Then we implement a <code>combine</code>
function that works only when both state machines have the same state type,
using the bound <code>TypeEqual&lt;A::State, B::State&gt;</code>.</p>
<pre><code class="language-cairo">trait StateMachine {
    type State;
    fn transition(ref state: Self::State);
}

#[derive(Copy, Drop)]
struct StateCounter {
    counter: u8,
}

impl TA of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter += 1;
    }
}

impl TB of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter *= 2;
    }
}

fn combine&lt;
    impl A: StateMachine,
    impl B: StateMachine,
    +core::metaprogramming::TypeEqual&lt;A::State, B::State&gt;,
&gt;(
    ref self: A::State,
) {
    A::transition(ref self);
    B::transition(ref self);
}

#[executable]
fn main() {
    let mut initial = StateCounter { counter: 0 };
    combine::&lt;TA, TB&gt;(ref initial);
}
</code></pre>
<p>8-11: Using the <code>TypeEqual</code> trait to ensure two types
have matching associated types</span></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch08-02-traits&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The `MakeNoise` trait is not implemented for the `Cat` type.\nTo make use of the default implementation for `Cat`, we would need to add `impl MakeNoiseImpl of MakeNoise&lt;Cat&gt; {}`.\nThe empty implementation block `{}` tells Cairo to use the default implementation from the trait\n&quot;,&quot;id&quot;:&quot;4120c3cf-a86a-4d30-b307-4a50b2e9d627&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub trait MakeNoise&lt;T&gt; {\n    fn make_noise(self: @T) {\n        println!(\&quot;noise\&quot;);\n    }\n}\n\npub mod dog {\n    use super::MakeNoise;\n\n    #[derive(Drop)]\n    pub struct Dog {}\n\n    impl Barking of MakeNoise&lt;Dog&gt; {\n        fn make_noise(self: @Dog) {\n            println!(\&quot;bark\&quot;);\n        }\n    }\n}\n\npub mod cat {\n    use super::MakeNoise;\n\n    #[derive(Drop)]\n    pub struct Cat {}\n}\n\n#[executable]\nfn main() {\n    let dog = dog::Dog {};\n    dog.make_noise();\n\n    let cat = cat::Cat {};\n    cat.make_noise();\n}\n&quot;}},{&quot;context&quot;:&quot;The `draw` method is a method implemented for the `Shape` type, so it should be called on the `my_shape` object.\nIt is also possible to call the method on the snapshot of the object by using the `@` operator, for example `Drawable::draw(@my_shape)`.\n&quot;,&quot;id&quot;:&quot;af789385-e4e4-4405-8fb7-049b9a51bc3b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`my_shape.draw();`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`draw(my_shape);`&quot;,&quot;`draw(@my_shape);`&quot;],&quot;prompt&quot;:&quot;What line of code is correct to draw the shape `my_shape` in the `main` function ?\n```\n#[derive(Drop)]\nstruct Shape {}\n\ntrait Drawable&lt;T&gt; {\n    fn draw(self: @T);\n}\n\nimpl DrawableShape of Drawable&lt;Shape&gt; {\n    fn draw(self: @Shape){\n        println!(\&quot;Drawing a shape!\&quot;);\n    }\n}\n\n#[executable]\nfn main() {\n    let my_shape = Shape{};\n    // the line goes here\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The code doesn't compile because there are two implementations of the trait `Consumer&lt;T&gt;` for the type `AThirdType`.\nThe implementation `TConsumerImpl` is a negative implementation of the trait `Producer&lt;T&gt;`, implementing the trait `Consumer&lt;T&gt;` for all types `T` that don't implement the trait `Producer&lt;T&gt;`.\nThe implementation `ThirdConsumerImpl` is thus redundant.\n&quot;,&quot;id&quot;:&quot;26b22cf1-9a7f-4a2d-98f3-34dab7a6dfcd&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct ProducerType {}\n\n#[derive(Drop, Debug)]\nstruct AnotherType {}\n\n#[derive(Drop, Debug)]\nstruct AThirdType {}\n\ntrait Producer&lt;T&gt; {\n    fn produce(self: T) -&gt; u32;\n}\n\ntrait Consumer&lt;T&gt; {\n    fn consume(self: T, input: u32);\n}\n\nimpl ProducerImpl of Producer&lt;ProducerType&gt; {\n    fn produce(self: ProducerType) -&gt; u32 {\n        42\n    }\n}\n\nimpl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {\n    fn consume(self: T, input: u32) {\n        println!(\&quot;{:?} consumed value: {}\&quot;, self, input);\n    }\n}\n\nimpl ThirdConsumerImpl of Consumer&lt;AThirdType&gt; {\n    fn consume(self: AThirdType, input: u32) {\n        println!(\&quot;{:?} consumed value: {}\&quot;, self, input);\n    }\n}\n\n#[executable]\nfn main() {\n    let producer = ProducerType {};\n    let another_type = AnotherType {};\n    let third_type = AThirdType {};\n    let production = producer.produce();\n    another_type.consume(production);\n    third_type.consume(production);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch08-01-generic-data-types.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch09-00-error-handling.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch08-01-generic-data-types.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch09-00-error-handling.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
