<!DOCTYPE HTML>
<html lang="tr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Contract Functions - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch101-02-contract-functions.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch104-02-01-unit-testing.html"><strong aria-hidden="true">18.2.1.</strong> Unit Testing</a></li><li class="chapter-item "><a href="ch104-02-02-integration-testing.html"><strong aria-hidden="true">18.2.2.</strong> Integration Testing</a></li><li class="chapter-item "><a href="ch104-02-03-fuzz-testing.html"><strong aria-hidden="true">18.2.3.</strong> Property-Based Testing</a></li><li class="chapter-item "><a href="ch104-02-04-fork-testing.html"><strong aria-hidden="true">18.2.4.</strong> Fork Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("tr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch101-02-contract-functions.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch101-02-contract-functions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contract-functions"><a class="header" href="#contract-functions">Contract Functions</a></h1>
<p>In this section, we are going to be looking at the different types of functions
you could encounter in Starknet smart contracts.</p>
<p>Functions can access the contract's state easily via the <code>self: ContractState</code>
object, which abstracts away the complexity of underlying system calls
(<code>storage_read_syscall</code> and <code>storage_write_syscall</code>). The compiler provides two
modifiers: <code>ref</code> and <code>@</code> to decorate <code>self</code>, which intends to distinguish view
and external functions.</p>
<p>Let's consider the <code>NameRegistry</code> contract in Listing
15-4 that we'll be using throughout this chapter:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry&lt;TContractState&gt; {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
}

#[starknet::contract]
mod NameRegistry {
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        names: Map&lt;ContractAddress, felt252&gt;,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        self.total_names.__base_address__
    }
}
</code></pre>
<p>15-4: Our reference contract for this chapter</span></p>
<h2 id="1-constructors"><a class="header" href="#1-constructors">1. Constructors</a></h2>
<p>Constructors are a special type of function that only runs once when deploying a
contract, and can be used to initialize the state of a contract.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }
<span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>Some important rules to note:</p>
<ol>
<li>A contract can't have more than one constructor.</li>
<li>The constructor function must be named <code>constructor</code>, and must be annotated
with the <code>#[constructor]</code> attribute.</li>
</ol>
<p>The <code>constructor</code> function might take arguments, which are passed when deploying
the contract. In our example, we pass some value corresponding to a <code>Person</code>
type as argument in order to store the <code>owner</code> information (address and name) in
the contract.</p>
<p>Note that the <code>constructor</code> function <strong>must</strong> take <code>self</code> as a first argument,
corresponding to the state of the contract, generally passed by reference with
the <code>ref</code> keyword to be able to modify the contract's state. We will explain
<code>self</code> and its type shortly.</p>
<h2 id="2-public-functions"><a class="header" href="#2-public-functions">2. Public Functions</a></h2>
<p>As stated previously, public functions are accessible from outside of the
contract. They are usually defined inside an implementation block annotated with
the <code>#[abi(embed_v0)]</code> attribute, but might also be defined independently under
the <code>#[external(v0)]</code> attribute.</p>
<p>The <code>#[abi(embed_v0)]</code> attribute means that all functions embedded inside it are
implementations of the Starknet interface of the contract, and therefore
potential entry points.</p>
<p>Annotating an impl block with the <code>#[abi(embed_v0)]</code> attribute only affects the
visibility (i.e., public vs private/internal) of the functions it contains, but
it doesn't inform us on the ability of these functions to modify the state of
the contract.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span>    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
    }
<span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Similarly to the <code>constructor</code> function, all public functions, either
standalone functions annotated with the <code>#[external(v0)]</code> or functions within
an impl block annotated with the <code>#[abi(embed_v0)]</code> attribute, <strong>must</strong> take
<code>self</code> as a first argument. This is not the case for private functions.</p>
</blockquote>
<h3 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h3>
<p>External functions are <em>public</em> functions where the <code>self: ContractState</code>
argument is passed by reference with the <code>ref</code> keyword, which exposes both the
<code>read</code> and <code>write</code> access to storage variables. This allows modifying the state
of the contract via <code>self</code> directly.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span>        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }
<span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h3 id="view-functions"><a class="header" href="#view-functions">View Functions</a></h3>
<p>View functions are <em>public</em> functions where the <code>self: ContractState</code> argument
is passed as snapshot, which only allows the <code>read</code> access to storage variables,
and restricts writes to storage made via <code>self</code> by causing compilation errors.
The compiler will mark their <em>state_mutability</em> to <code>view</code>, preventing any state
modification through <code>self</code> directly.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span>        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h3 id="state-mutability-of-public-functions"><a class="header" href="#state-mutability-of-public-functions">State Mutability of Public Functions</a></h3>
<p>However, as you may have noticed, passing <code>self</code> as a snapshot only restricts
the storage write access via <code>self</code> at compile time. It does not prevent state
modification via direct system calls, nor calling another contract that would
modify the state.</p>
<p>The read-only property of view functions is not enforced on Starknet, and
sending a transaction targeting a view function <em>could</em> change the state.</p>
<!-- TODO: add an example of a view function that could modify the state using low-level syscalls -->
<p>In conclusion, even though external and view functions are distinguished by the
Cairo compiler, <strong>all public functions</strong> can be called through an invoke
transaction and can potentially modify the Starknet state. Moreover, all public
functions can be called with the <code>starknet_call</code> RPC method, which will not
create a transaction and hence will not change the state.</p>
<blockquote>
<p><strong>Warning:</strong> This is different from the EVM where a <code>staticcall</code> opcode is
provided, which prevents storage modifications in the current context and
subcontexts. Hence developers <strong>should not</strong> have the assumption that calling
a view function on another contract cannot modify the state.</p>
</blockquote>
<h3 id="standalone-public-functions"><a class="header" href="#standalone-public-functions">Standalone Public Functions</a></h3>
<p>It is also possible to define public functions outside of an implementation of a
trait, using the <code>#[external(v0)]</code> attribute. Doing this will automatically
generate an entry in the contract ABI, allowing these standalone public
functions to be callable by anyone from outside. These functions can also be
called from within the contract just like any function in Starknet contracts.
The first parameter must be <code>self</code>.</p>
<p>Here, we define a standalone <code>get_contract_name</code> function outside of an impl
block:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }
<span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h2 id="3-private-functions"><a class="header" href="#3-private-functions">3. Private Functions</a></h2>
<p>Functions that are not defined with the <code>#[external(v0)]</code> attribute or inside a
block annotated with the <code>#[abi(embed_v0)]</code> attribute are private functions
(also called internal functions). They can only be called from within the
contract.</p>
<p>They can be grouped in a dedicated impl block (e.g., in components, to easily
import internal functions all at once in the embedding contracts) or just be
added as free functions inside the contract module. Note that these 2 methods
are equivalent. Just choose the one that makes your code more readable and easy
to use.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span>    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        self.total_names.__base_address__
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Wait, what is this <code>#[generate_trait]</code> attribute? Where is the trait
definition for this implementation? Well, the <code>#[generate_trait]</code> attribute is
a special attribute that tells the compiler to generate a trait definition for
the implementation block. This allows you to get rid of the boilerplate code
of defining a trait with generic parameters and implementing it for the
implementation block. With this attribute, we can simply define the
implementation block directly, without any generic parameter, and use
<code>self: ContractState</code> in our functions.</p>
</blockquote>
<p>The <code>#[generate_trait]</code> attribute is mostly used to define private impl blocks.
It might also be used in addition to <code>#[abi(per_item)]</code> to define the various
entrypoints of a contract (see <a href="./ch101-02-contract-functions.html#abiper_item-attribute">next section</a>).</p>
<blockquote>
<p>Note: using <code>#[generate_trait]</code> in addition to the <code>#[abi(embed_v0)]</code>
attribute for a public impl block is not recommended, as it will result in a
failure to generate the corresponding ABI. Public functions should only be
defined in an impl block annotated with <code>#[generate_trait]</code> if this block is
also annotated with the <code>#[abi(per_item)]</code> attribute.</p>
</blockquote>
<h2 id="abiper_item-attribute"><a class="header" href="#abiper_item-attribute"><code>[abi(per_item)]</code> Attribute</a></h2>
<p>You can also define the entrypoint type of functions individually inside an impl
block using the<code>#[abi(per_item)]</code> attribute on top of your impl. It is often
used with the <code>#[generate_trait]</code> attribute, as it allows you to define
entrypoints without an explicit interface. In this case, the functions will not
be grouped under an impl in the ABI. Note that when using <code>#[abi(per_item)]</code>
attribute, public functions need to be annotated with the <code>#[external(v0)]</code>
attribute - otherwise, they will not be exposed and will be considered as
private functions.</p>
<p>Here is a short example:</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod ContractExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl SomeImpl of SomeTrait {
        #[constructor]
        // this is a constructor function
        fn constructor(ref self: ContractState) {}

        #[external(v0)]
        // this is a public function
        fn external_function(ref self: ContractState, arg1: felt252) {}

        #[l1_handler]
        // this is a l1_handler function
        fn handle_message(ref self: ContractState, from_address: felt252, arg: felt252) {}

        // this is an internal function
        fn internal_function(self: @ContractState) {}
    }
}
</code></pre>
<p>In the case of <code>#[abi(per_item)]</code> attribute usage without <code>#[generate_trait]</code>,
it will only be possible to include <code>constructor</code>, <code>l1-handler</code> and <code>internal</code>
functions in the trait implementation. Indeed, <code>#[abi(per_item)]</code> only works
with a trait that is not defined as a Starknet interface. Hence, it will be
mandatory to create another trait defined as interface to implement public
functions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch101-01-02-storage-vecs.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch101-03-contract-events.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch101-01-02-storage-vecs.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch101-03-contract-events.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
