<!DOCTYPE HTML>
<html lang="tr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Property-Based Testing - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch104-02-03-fuzz-testing.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch104-02-01-unit-testing.html"><strong aria-hidden="true">18.2.1.</strong> Unit Testing</a></li><li class="chapter-item "><a href="ch104-02-02-integration-testing.html"><strong aria-hidden="true">18.2.2.</strong> Integration Testing</a></li><li class="chapter-item "><a href="ch104-02-03-fuzz-testing.html"><strong aria-hidden="true">18.2.3.</strong> Property-Based Testing</a></li><li class="chapter-item "><a href="ch104-02-04-fork-testing.html"><strong aria-hidden="true">18.2.4.</strong> Fork Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("tr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch104-02-03-fuzz-testing.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-02-03-fuzz-testing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="property-based-testing-with-fuzzing"><a class="header" href="#property-based-testing-with-fuzzing">Property-Based Testing with Fuzzing</a></h1>
<p>Example-based tests verify that your code works for inputs you thought of.
Property-based testing verifies that your code works for inputs you didn't think
of.</p>
<p>When you write <code>test_transfer(100)</code>, you're testing one scenario. But what about
<code>transfer(0)</code>? What about <code>transfer(u256::MAX)</code>? What about the exact balance
amount? Property-based testing with <em>fuzzing</em> automatically generates hundreds
or thousands of inputs to find edge cases that manual testing would miss.</p>
<p>Google's OSS-Fuzz project has found over 25,000 bugs that traditional testing
missed. In the smart contract space, fuzzing has detected hundreds of
vulnerabilities across deployed contracts.</p>
<h2 id="thinking-in-properties-not-examples"><a class="header" href="#thinking-in-properties-not-examples">Thinking in Properties, Not Examples</a></h2>
<p>The shift: instead of "test with this specific input," you ask "does this
property hold for any input?"</p>
<h3 id="what-is-a-property"><a class="header" href="#what-is-a-property">What is a Property?</a></h3>
<p>A <em>property</em> is a statement that should always be true about your code,
regardless of the input. "Total supply never changes during a transfer." "A
user's balance is never negative." "Only the owner can call this function."</p>
<h3 id="what-is-an-invariant"><a class="header" href="#what-is-an-invariant">What is an Invariant?</a></h3>
<p>An <em>invariant</em> is a specific type of property: a condition that must hold before
and after every operation. Smart contracts often have important invariants:</p>
<div class="table-wrapper"><table><thead><tr><th>Invariant Type</th><th>Example</th></tr></thead><tbody>
<tr><td>Balance Preservation</td><td><code>totalSupply == sum(all_balances)</code></td></tr>
<tr><td>Access Control</td><td>Only owner can call privileged functions</td></tr>
<tr><td>State Machine</td><td>Cannot transition from "closed" to "pending"</td></tr>
<tr><td>Arithmetic Safety</td><td>Balances cannot underflow to create tokens</td></tr>
</tbody></table>
</div>
<h2 id="example-based-vs-property-based-testing"><a class="header" href="#example-based-vs-property-based-testing">Example-Based vs Property-Based Testing</a></h2>
<p>Let's compare approaches using a token transfer:</p>
<h3 id="example-based-test"><a class="header" href="#example-based-test">Example-Based Test</a></h3>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::simple_token::{ISimpleTokenDispatcher, ISimpleTokenDispatcherTrait};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token(initial_supply: u256) -&gt; ISimpleTokenDispatcher {
</span><span class="boring">    let contract = declare("SimpleToken").unwrap().contract_class();
</span><span class="boring">    let owner = owner();
</span><span class="boring">    let constructor_calldata = array![
</span><span class="boring">        owner.into(), initial_supply.low.into(), initial_supply.high.into(),
</span><span class="boring">    ];
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">    ISimpleTokenDispatcher { contract_address }
</span><span class="boring">}
</span><span class="boring">
</span>// A simple example-based test
#[test]
fn test_transfer_updates_balances() {
    let token = deploy_token(1000);
    let recipient = contract_address_const::&lt;'recipient'&gt;();

    start_cheat_caller_address(token.contract_address, owner());
    token.transfer(recipient, 100);
    stop_cheat_caller_address(token.contract_address);

    assert_eq!(token.balance_of(owner()), 900);
    assert_eq!(token.balance_of(recipient), 100);
}
<span class="boring">
</span><span class="boring">/// Invariant: Transfer preserves total supply
</span><span class="boring">/// For any valid transfer, total_supply before == total_supply after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 12345)]
</span><span class="boring">fn test_fuzz_transfer_preserves_total_supply(amount: u64) {
</span><span class="boring">    // Setup: deploy with enough balance for any fuzzed amount
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF; // max u64 as u256
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let supply_before = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // Transfer a fuzzed amount
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let supply_after = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // INVARIANT: total supply must not change
</span><span class="boring">    assert_eq!(supply_before, supply_after, "Total supply changed after transfer!");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Invariant: Transfer conserves balances
</span><span class="boring">/// sender_balance_before + recipient_balance_before ==
</span><span class="boring">/// sender_balance_after + recipient_balance_after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 54321)]
</span><span class="boring">fn test_fuzz_transfer_conserves_balances(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let sender_before = token.balance_of(owner());
</span><span class="boring">    let recipient_before = token.balance_of(recipient);
</span><span class="boring">    let sum_before = sender_before + recipient_before;
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let sender_after = token.balance_of(owner());
</span><span class="boring">    let recipient_after = token.balance_of(recipient);
</span><span class="boring">    let sum_after = sender_after + recipient_after;
</span><span class="boring">
</span><span class="boring">    // INVARIANT: sum of involved balances must not change
</span><span class="boring">    assert_eq!(sum_before, sum_after, "Balance conservation violated!");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Property: Transfer round-trip
</span><span class="boring">/// If A transfers X to B, and B transfers X back to A, balances return to original
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 11111)]
</span><span class="boring">fn test_fuzz_transfer_roundtrip(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let alice = owner();
</span><span class="boring">    let bob = contract_address_const::&lt;'bob'&gt;();
</span><span class="boring">
</span><span class="boring">    let alice_initial = token.balance_of(alice);
</span><span class="boring">    let bob_initial = token.balance_of(bob);
</span><span class="boring">
</span><span class="boring">    // Alice -&gt; Bob
</span><span class="boring">    start_cheat_caller_address(token.contract_address, alice);
</span><span class="boring">    token.transfer(bob, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Bob -&gt; Alice
</span><span class="boring">    start_cheat_caller_address(token.contract_address, bob);
</span><span class="boring">    token.transfer(alice, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // PROPERTY: Balances should return to original
</span><span class="boring">    assert_eq!(token.balance_of(alice), alice_initial, "Alice balance not restored");
</span><span class="boring">    assert_eq!(token.balance_of(bob), bob_initial, "Bob balance not restored");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This test verifies that transferring 100 tokens works. But it doesn't test
transferring 0 tokens, transferring the exact balance, transferring more than
the balance, transferring to yourself, or large amounts near <code>u256::MAX</code>.</p>
<h3 id="property-based-test"><a class="header" href="#property-based-test">Property-Based Test</a></h3>
<p>Instead of testing one amount, we test a <em>property</em> that should hold for <em>any</em>
amount:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::simple_token::{ISimpleTokenDispatcher, ISimpleTokenDispatcherTrait};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token(initial_supply: u256) -&gt; ISimpleTokenDispatcher {
</span><span class="boring">    let contract = declare("SimpleToken").unwrap().contract_class();
</span><span class="boring">    let owner = owner();
</span><span class="boring">    let constructor_calldata = array![
</span><span class="boring">        owner.into(), initial_supply.low.into(), initial_supply.high.into(),
</span><span class="boring">    ];
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">    ISimpleTokenDispatcher { contract_address }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// A simple example-based test
</span><span class="boring">#[test]
</span><span class="boring">fn test_transfer_updates_balances() {
</span><span class="boring">    let token = deploy_token(1000);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, 100);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(token.balance_of(owner()), 900);
</span><span class="boring">    assert_eq!(token.balance_of(recipient), 100);
</span><span class="boring">}
</span><span class="boring">
</span>/// Invariant: Transfer preserves total supply
/// For any valid transfer, total_supply before == total_supply after
#[test]
#[fuzzer(runs: 100, seed: 12345)]
fn test_fuzz_transfer_preserves_total_supply(amount: u64) {
    // Setup: deploy with enough balance for any fuzzed amount
    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF; // max u64 as u256
    let token = deploy_token(initial_supply);
    let recipient = contract_address_const::&lt;'recipient'&gt;();

    let supply_before = token.total_supply();

    // Transfer a fuzzed amount
    start_cheat_caller_address(token.contract_address, owner());
    token.transfer(recipient, amount.into());
    stop_cheat_caller_address(token.contract_address);

    let supply_after = token.total_supply();

    // INVARIANT: total supply must not change
    assert_eq!(supply_before, supply_after, "Total supply changed after transfer!");
}
<span class="boring">
</span><span class="boring">/// Invariant: Transfer conserves balances
</span><span class="boring">/// sender_balance_before + recipient_balance_before ==
</span><span class="boring">/// sender_balance_after + recipient_balance_after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 54321)]
</span><span class="boring">fn test_fuzz_transfer_conserves_balances(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let sender_before = token.balance_of(owner());
</span><span class="boring">    let recipient_before = token.balance_of(recipient);
</span><span class="boring">    let sum_before = sender_before + recipient_before;
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let sender_after = token.balance_of(owner());
</span><span class="boring">    let recipient_after = token.balance_of(recipient);
</span><span class="boring">    let sum_after = sender_after + recipient_after;
</span><span class="boring">
</span><span class="boring">    // INVARIANT: sum of involved balances must not change
</span><span class="boring">    assert_eq!(sum_before, sum_after, "Balance conservation violated!");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Property: Transfer round-trip
</span><span class="boring">/// If A transfers X to B, and B transfers X back to A, balances return to original
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 11111)]
</span><span class="boring">fn test_fuzz_transfer_roundtrip(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let alice = owner();
</span><span class="boring">    let bob = contract_address_const::&lt;'bob'&gt;();
</span><span class="boring">
</span><span class="boring">    let alice_initial = token.balance_of(alice);
</span><span class="boring">    let bob_initial = token.balance_of(bob);
</span><span class="boring">
</span><span class="boring">    // Alice -&gt; Bob
</span><span class="boring">    start_cheat_caller_address(token.contract_address, alice);
</span><span class="boring">    token.transfer(bob, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Bob -&gt; Alice
</span><span class="boring">    start_cheat_caller_address(token.contract_address, bob);
</span><span class="boring">    token.transfer(alice, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // PROPERTY: Balances should return to original
</span><span class="boring">    assert_eq!(token.balance_of(alice), alice_initial, "Alice balance not restored");
</span><span class="boring">    assert_eq!(token.balance_of(bob), bob_initial, "Bob balance not restored");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-7: A fuzz test verifying the
total supply invariant</span></p>
<p>The <code>#[fuzzer(runs: 100, seed: 12345)]</code> attribute tells Starknet Foundry to run
this test 100 times with different random <code>amount</code> values, using seed <code>12345</code>
for reproducibility. If any of those 100 runs violates the invariant, the test
fails and reports the failing input.</p>
<h2 id="writing-effective-fuzz-tests"><a class="header" href="#writing-effective-fuzz-tests">Writing Effective Fuzz Tests</a></h2>
<h3 id="identify-your-invariants"><a class="header" href="#identify-your-invariants">Identify Your Invariants</a></h3>
<p>Before writing fuzz tests, list what must always be true.</p>
<p>For a token contract: total supply is constant (transfers don't create or
destroy tokens), the sum of all balances equals total supply, balance of any
account is non-negative, and only the minter can increase total supply.</p>
<p>For an auction: highest bid only increases, you cannot bid after the auction
ends, and the winner is the highest bidder.</p>
<h3 id="design-for-fuzzability"><a class="header" href="#design-for-fuzzability">Design for Fuzzability</a></h3>
<p>Structure tests so the fuzzer can explore interesting cases:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::simple_token::{ISimpleTokenDispatcher, ISimpleTokenDispatcherTrait};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token(initial_supply: u256) -&gt; ISimpleTokenDispatcher {
</span><span class="boring">    let contract = declare("SimpleToken").unwrap().contract_class();
</span><span class="boring">    let owner = owner();
</span><span class="boring">    let constructor_calldata = array![
</span><span class="boring">        owner.into(), initial_supply.low.into(), initial_supply.high.into(),
</span><span class="boring">    ];
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">    ISimpleTokenDispatcher { contract_address }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// A simple example-based test
</span><span class="boring">#[test]
</span><span class="boring">fn test_transfer_updates_balances() {
</span><span class="boring">    let token = deploy_token(1000);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, 100);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(token.balance_of(owner()), 900);
</span><span class="boring">    assert_eq!(token.balance_of(recipient), 100);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Invariant: Transfer preserves total supply
</span><span class="boring">/// For any valid transfer, total_supply before == total_supply after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 12345)]
</span><span class="boring">fn test_fuzz_transfer_preserves_total_supply(amount: u64) {
</span><span class="boring">    // Setup: deploy with enough balance for any fuzzed amount
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF; // max u64 as u256
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let supply_before = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // Transfer a fuzzed amount
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let supply_after = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // INVARIANT: total supply must not change
</span><span class="boring">    assert_eq!(supply_before, supply_after, "Total supply changed after transfer!");
</span><span class="boring">}
</span><span class="boring">
</span>/// Invariant: Transfer conserves balances
/// sender_balance_before + recipient_balance_before ==
/// sender_balance_after + recipient_balance_after
#[test]
#[fuzzer(runs: 100, seed: 54321)]
fn test_fuzz_transfer_conserves_balances(amount: u64) {
    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
    let token = deploy_token(initial_supply);
    let recipient = contract_address_const::&lt;'recipient'&gt;();

    let sender_before = token.balance_of(owner());
    let recipient_before = token.balance_of(recipient);
    let sum_before = sender_before + recipient_before;

    start_cheat_caller_address(token.contract_address, owner());
    token.transfer(recipient, amount.into());
    stop_cheat_caller_address(token.contract_address);

    let sender_after = token.balance_of(owner());
    let recipient_after = token.balance_of(recipient);
    let sum_after = sender_after + recipient_after;

    // INVARIANT: sum of involved balances must not change
    assert_eq!(sum_before, sum_after, "Balance conservation violated!");
}
<span class="boring">
</span><span class="boring">/// Property: Transfer round-trip
</span><span class="boring">/// If A transfers X to B, and B transfers X back to A, balances return to original
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 11111)]
</span><span class="boring">fn test_fuzz_transfer_roundtrip(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let alice = owner();
</span><span class="boring">    let bob = contract_address_const::&lt;'bob'&gt;();
</span><span class="boring">
</span><span class="boring">    let alice_initial = token.balance_of(alice);
</span><span class="boring">    let bob_initial = token.balance_of(bob);
</span><span class="boring">
</span><span class="boring">    // Alice -&gt; Bob
</span><span class="boring">    start_cheat_caller_address(token.contract_address, alice);
</span><span class="boring">    token.transfer(bob, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Bob -&gt; Alice
</span><span class="boring">    start_cheat_caller_address(token.contract_address, bob);
</span><span class="boring">    token.transfer(alice, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // PROPERTY: Balances should return to original
</span><span class="boring">    assert_eq!(token.balance_of(alice), alice_initial, "Alice balance not restored");
</span><span class="boring">    assert_eq!(token.balance_of(bob), bob_initial, "Bob balance not restored");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-8: Testing balance
conservation across transfers</span></p>
<p>We deploy with maximum <code>u64</code> supply so any fuzzed <code>u64</code> amount is valid. Then we
capture state before and after, and check that the sum of balances stayed the
same.</p>
<h3 id="test-round-trip-properties"><a class="header" href="#test-round-trip-properties">Test Round-Trip Properties</a></h3>
<p>Round-trip properties verify that operations can be "undone":</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::simple_token::{ISimpleTokenDispatcher, ISimpleTokenDispatcherTrait};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token(initial_supply: u256) -&gt; ISimpleTokenDispatcher {
</span><span class="boring">    let contract = declare("SimpleToken").unwrap().contract_class();
</span><span class="boring">    let owner = owner();
</span><span class="boring">    let constructor_calldata = array![
</span><span class="boring">        owner.into(), initial_supply.low.into(), initial_supply.high.into(),
</span><span class="boring">    ];
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">    ISimpleTokenDispatcher { contract_address }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// A simple example-based test
</span><span class="boring">#[test]
</span><span class="boring">fn test_transfer_updates_balances() {
</span><span class="boring">    let token = deploy_token(1000);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, 100);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(token.balance_of(owner()), 900);
</span><span class="boring">    assert_eq!(token.balance_of(recipient), 100);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Invariant: Transfer preserves total supply
</span><span class="boring">/// For any valid transfer, total_supply before == total_supply after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 12345)]
</span><span class="boring">fn test_fuzz_transfer_preserves_total_supply(amount: u64) {
</span><span class="boring">    // Setup: deploy with enough balance for any fuzzed amount
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF; // max u64 as u256
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let supply_before = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // Transfer a fuzzed amount
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let supply_after = token.total_supply();
</span><span class="boring">
</span><span class="boring">    // INVARIANT: total supply must not change
</span><span class="boring">    assert_eq!(supply_before, supply_after, "Total supply changed after transfer!");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Invariant: Transfer conserves balances
</span><span class="boring">/// sender_balance_before + recipient_balance_before ==
</span><span class="boring">/// sender_balance_after + recipient_balance_after
</span><span class="boring">#[test]
</span><span class="boring">#[fuzzer(runs: 100, seed: 54321)]
</span><span class="boring">fn test_fuzz_transfer_conserves_balances(amount: u64) {
</span><span class="boring">    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
</span><span class="boring">    let token = deploy_token(initial_supply);
</span><span class="boring">    let recipient = contract_address_const::&lt;'recipient'&gt;();
</span><span class="boring">
</span><span class="boring">    let sender_before = token.balance_of(owner());
</span><span class="boring">    let recipient_before = token.balance_of(recipient);
</span><span class="boring">    let sum_before = sender_before + recipient_before;
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.transfer(recipient, amount.into());
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    let sender_after = token.balance_of(owner());
</span><span class="boring">    let recipient_after = token.balance_of(recipient);
</span><span class="boring">    let sum_after = sender_after + recipient_after;
</span><span class="boring">
</span><span class="boring">    // INVARIANT: sum of involved balances must not change
</span><span class="boring">    assert_eq!(sum_before, sum_after, "Balance conservation violated!");
</span><span class="boring">}
</span><span class="boring">
</span>/// Property: Transfer round-trip
/// If A transfers X to B, and B transfers X back to A, balances return to original
#[test]
#[fuzzer(runs: 100, seed: 11111)]
fn test_fuzz_transfer_roundtrip(amount: u64) {
    let initial_supply: u256 = 0xFFFFFFFFFFFFFFFF;
    let token = deploy_token(initial_supply);
    let alice = owner();
    let bob = contract_address_const::&lt;'bob'&gt;();

    let alice_initial = token.balance_of(alice);
    let bob_initial = token.balance_of(bob);

    // Alice -&gt; Bob
    start_cheat_caller_address(token.contract_address, alice);
    token.transfer(bob, amount.into());
    stop_cheat_caller_address(token.contract_address);

    // Bob -&gt; Alice
    start_cheat_caller_address(token.contract_address, bob);
    token.transfer(alice, amount.into());
    stop_cheat_caller_address(token.contract_address);

    // PROPERTY: Balances should return to original
    assert_eq!(token.balance_of(alice), alice_initial, "Alice balance not restored");
    assert_eq!(token.balance_of(bob), bob_initial, "Bob balance not restored");
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-9: Testing the transfer
round-trip property</span></p>
<h2 id="common-property-patterns"><a class="header" href="#common-property-patterns">Common Property Patterns</a></h2>
<h3 id="invariants-always-true"><a class="header" href="#invariants-always-true">Invariants (Always True)</a></h3>
<pre><code class="language-cairo noplayground">// After ANY operation, this should hold
assert!(contract.total_supply() == expected_total);
</code></pre>
<h3 id="symmetrycommutativity"><a class="header" href="#symmetrycommutativity">Symmetry/Commutativity</a></h3>
<pre><code class="language-cairo noplayground">// Order shouldn't matter
let result_ab = calculate(a, b);
let result_ba = calculate(b, a);
assert_eq!(result_ab, result_ba);
</code></pre>
<h3 id="idempotence"><a class="header" href="#idempotence">Idempotence</a></h3>
<pre><code class="language-cairo noplayground">// Doing it twice is same as doing it once
contract.pause();
contract.pause(); // Should not fail or change state
assert!(contract.is_paused());
</code></pre>
<h3 id="no-invalid-state-transitions"><a class="header" href="#no-invalid-state-transitions">No Invalid State Transitions</a></h3>
<pre><code class="language-cairo noplayground">// From "completed" state, cannot go back to "pending"
#[test]
#[should_panic]
fn test_cannot_transition_completed_to_pending(random_input: felt252) {
    // Setup completed state
    // Attempt transition - should fail
}
</code></pre>
<h2 id="configuring-the-fuzzer"><a class="header" href="#configuring-the-fuzzer">Configuring the Fuzzer</a></h2>
<p>Configure fuzzing in your <code>Scarb.toml</code>:</p>
<pre><code class="language-toml">[tool.snforge]
fuzzer_runs = 256      # Number of iterations per fuzz test
fuzzer_seed = 12345    # Seed for reproducibility
</code></pre>
<p>Or per-test with the attribute:</p>
<pre><code class="language-cairo noplayground">#[test]
#[fuzzer(runs: 1000, seed: 42)]
fn test_with_custom_config(x: u128) { /* ... */ }
</code></pre>
<h3 id="choosing-fuzzer-runs"><a class="header" href="#choosing-fuzzer-runs">Choosing Fuzzer Runs</a></h3>
<p>During development, 50-100 runs give you fast iteration. In CI, 256-500 runs
provide good coverage. Before audits, run 1000+ for thorough testing.</p>
<h2 id="when-to-fuzz"><a class="header" href="#when-to-fuzz">When to Fuzz</a></h2>
<p>Fuzzing pays off most for:</p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Why Fuzz</th></tr></thead><tbody>
<tr><td>Financial calculations</td><td>Edge cases in math can cause loss of funds</td></tr>
<tr><td>Access control</td><td>Ensure no input bypasses authorization</td></tr>
<tr><td>State machines</td><td>Find invalid state transitions</td></tr>
<tr><td>Parsing/serialization</td><td>Malformed input handling</td></tr>
</tbody></table>
</div>
<p>Fuzzing may be overkill for simple getters with no logic, functions with no
parameters, and already well-tested pure functions.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Starknet Foundry's fuzzer is random, not coverage-guided. It generates random
inputs rather than learning which inputs explore new code paths. This means it
may miss specific edge cases that require precise inputs. More runs generally
find more bugs, but with diminishing returns. Use fuzzing to complement
thoughtful example tests, not replace them.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Property-based testing asks "does this property hold for any input?" instead of
"does this pass for the inputs I thought of?" The workflow is straightforward:
identify invariants (what must always be true?), write fuzz tests to check them,
and use more runs in CI than during development.</p>
<p>Combined with unit and integration tests, fuzzing catches edge cases that manual
testing misses. For contracts handling real value, it's worth the setup.</p>
<p>For detailed fuzzer options, see the
<a href="https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/fuzz-testing.html">Starknet Foundry fuzz testing documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch104-02-02-integration-testing.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch104-02-04-fork-testing.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch104-02-02-integration-testing.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch104-02-04-fork-testing.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
