<!DOCTYPE HTML>
<html lang="tr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Arithmetic Circuits - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch12-10-arithmetic-circuits.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2');
            gtag('config', 'G-WY42TERK5P')
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("tr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch12-10-arithmetic-circuits.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-10-arithmetic-circuits.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="arithmetic-circuits"><a class="header" href="#arithmetic-circuits">Arithmetic Circuits</a></h1>
<p>Arithmetic circuits are mathematical models used to represent polynomial computations. They are defined over a field (typically a finite field \(F_p\) where \(p\) is prime) and consist of:</p>
<ul>
<li>Input signals (values in the range \([0, p-1]\))</li>
<li>Arithmetic operations (addition and multiplication gates)</li>
<li>Output signals</li>
</ul>
<p>Cairo supports emulated arithmetic circuits with modulo up to 384 bits.</p>
<p>This is especially useful for:</p>
<ul>
<li>Implementing verification for other proof systems</li>
<li>Implementing cryptographic primitives</li>
<li>Creating more low-level programs, with potential reduced overhead compared to standard Cairo constructs</li>
</ul>
<h2 id="implementing-arithmetic-circuits-in-cairo"><a class="header" href="#implementing-arithmetic-circuits-in-cairo">Implementing Arithmetic Circuits in Cairo</a></h2>
<p>Cairo's circuit constructs are available in the <code>core::circuit</code> module of the corelib.</p>
<p>Arithmetic circuits consist of:</p>
<ul>
<li>Addition modulo \(p\): <code>AddMod</code> builtin</li>
<li>Multiplication modulo \(p\): <code>MulMod</code> builtin</li>
</ul>
<p>Because of the modulo properties, we can build four basic arithmetic gates:</p>
<ul>
<li>Addition: <code>AddModGate</code></li>
<li>Subtraction: <code>SubModGate</code></li>
<li>Multiplication: <code>MulModGate</code></li>
<li>Inverse: <code>InvModGate</code></li>
</ul>
<p>Let's create a circuit that computes \(a \cdot (a + b)\) over the BN254 prime field.</p>
<p>We start from the empty struct <code>CircuitElement&lt;T&gt;</code>.</p>
<p>The inputs of our circuit are defined as <code>CircuitInput</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span>    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
<span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>We can combine circuit inputs and gates: <code>CircuitElement&lt;a&gt;</code> and <code>CircuitElement&lt;b&gt;</code> combined with an addition gate gives <code>CircuitElement&lt;AddModGate&lt;a, b&gt;&gt;</code>.</p>
<p>We can use <code>circuit_add</code>, <code>circuit_sub</code>, <code>circuit_mul</code> and <code>circuit_inverse</code> to directly combine circuit elements.
For \(a * (a + b)\), the description of our circuit is:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span>    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);
<span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>Note that <code>a</code>, <code>b</code> and <code>add</code> are intermediate circuit elements and not specifically inputs or gates, which is why we need the distinction between the empty struct <code>CircuitElement&lt;T&gt;</code> and the circuit description specified by the type <code>T</code>.</p>
<p>The outputs of the circuits are defined as a tuple of circuit elements. It's possible to add any intermediate gates of our circuit, but we must add all gates with degree 0 (gates where the output signal is not used as input of any other gate).
In our case, we will only add the last gate <code>mul</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span>    let output = (mul,);
<span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>We now have a complete description of our circuit and its outputs.
We now need to assign a value to each input.
As circuits are defined with 384-bit modulus, a single <code>u384</code> value can be represented as a fixed array of four <code>u96</code>.
We can initialize \(a\) and \(b\) to respectively \(10\) and \(20\):</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span>    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();
<span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>As the number of inputs can vary, Cairo use an accumulator and the <code>new_inputs</code> and <code>next</code> functions return a variant of the <code>AddInputResult</code> enum.</p>
<pre><code class="language-cairo  noplayground">pub enum AddInputResult&lt;C&gt; {
    /// All inputs have been filled.
    Done: CircuitData&lt;C&gt;,
    /// More inputs are needed to fill the circuit instance's data.
    More: CircuitInputAccumulator&lt;C&gt;,
}
</code></pre>
<p>We have to assign a value to every input, by calling <code>next</code> on each <code>CircuitInputAccumulator</code> variant.
After the inputs initialization, by calling the <code>done</code> function we get the complete circuit <code>CircuitData&lt;C&gt;</code>, where <code>C</code> is a long type that encodes the entire circuit instance.</p>
<p>We then need to define what modulus our circuit is using (up to 384-bit modulus), by defining a <code>CircuitModulus</code>. We want to use BN254 prime field modulus:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span>    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();
<span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>The last part is the evaluation of the circuit, i.e. the actual process of passing the input signals correctly through each gate described by our circuit and getting the values of each output gate.
We can evaluate and get the results for a given modulus as follows:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span>    let res = instance.eval(bn254_modulus).unwrap();
<span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>To retrieve the value of a specific output, we can use the <code>get_output</code> function on our results with the <code>CircuitElement</code> instance of the output gate we want. We can also retrieve any intermediate gate value as well.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span>    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
<span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>To recap, we did the following steps:</p>
<ul>
<li>Define Circuit Inputs</li>
<li>Describe the circuit</li>
<li>Specify the outputs</li>
<li>Assign values to the inputs</li>
<li>Define the modulus</li>
<li>Evaluate the circuit</li>
<li>Get the output values</li>
</ul>
<p>And the full code is:</p>
<pre><code class="language-cairo  noplayground">use core::circuit::{
    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -&gt; (u384, u384) {
    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");

    (add_output, circuit_output)
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<h2 id="arithmetic-circuits-in-zero-knowledge-proof-systems"><a class="header" href="#arithmetic-circuits-in-zero-knowledge-proof-systems">Arithmetic Circuits in Zero-Knowledge Proof Systems</a></h2>
<p>In zero-knowledge proof systems, a prover creates a proof of computational statements, which a verifier can check without performing the full computation. However, these statements must first be converted into a suitable representation for the proof system.</p>
<h3 id="zk-snarks-approach"><a class="header" href="#zk-snarks-approach">zk-SNARKs Approach</a></h3>
<p>Some proof systems, like zk-SNARKs, use arithmetic circuits over a finite field \(F_p\). These circuits include constraints at specific gates, represented as equations:</p>
<p>\[
(a_1 \cdot s_1 + ... + a_n \cdot s_n) \cdot (b_1 \cdot s_1 + ... + b_n \cdot s_n) + (c_1 \cdot s_1 + ... + c_n \cdot s_n) = 0 \mod p
\]
Where \(s_1, ..., s_n\) are signals, and \(a_i, b_i, c_i\) are coefficients.</p>
<p>A witness is an assignment of signals that satisfies all constraints in a circuit. zk-SNARK proofs use these properties to prove knowledge of a witness without revealing private input signals, ensuring the prover's honesty while preserving privacy.</p>
<p>Some work has already been done, such as <a href="https://felt.gitbook.io/garaga/deploy-your-snark-verifier-on-starknet/groth16/generate-and-deploy-your-verifier-contract">Garaga Groth16 verifier</a></p>
<h3 id="zk-starks-approach"><a class="header" href="#zk-starks-approach">zk-STARKs Approach</a></h3>
<p>STARKs (which Cairo uses) use an Algebraic Intermediate Representation (AIR) instead of arithmetic circuits. AIR describes computations as a set of polynomial constraints.</p>
<p>By allowing emulated arithmetic circuits, Cairo can be used to implement zk-SNARKs proof verification inside STARK proofs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch12-08-printing.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch12-11-offloading-computations-with-oracles.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch12-08-printing.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch12-11-offloading-computations-with-oracles.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function (i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date(); a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

                ga('create', 'G-WY42TERK5P', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
