<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>The Cairo Programming Language</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../theme/css/last-changed.css">
    <link rel="stylesheet" href="../theme/css/chat.css">
    <link rel="stylesheet" href="../theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2');
            gtag('config', 'G-WY42TERK5P')
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("en");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "print.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cairo-book"><a class="header" href="#the-cairo-book">The Cairo Book</a></h1>
<p><em>By the Cairo Community and its <a href="https://github.com/cairo-book/cairo-book.github.io">contributors</a>. Special thanks to <a href="https://starkware.co/">StarkWare</a> through <a href="https://www.onlydust.xyz/">OnlyDust</a>, and <a href="https://voyager.online/">Voyager</a> for supporting the creation of this book.</em></p>
<p>This version of the text assumes you’re using <a href="https://github.com/starkware-libs/cairo">Cairo</a> <a href="https://github.com/starkware-libs/cairo/releases">version 2.11.4</a> and <a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a> <a href="https://github.com/foundry-rs/starknet-foundry/releases">version 0.39.0</a>. See the <a href="ch01-01-installation.html">Installation</a> section of Chapter 1 to install or update Cairo and Starknet Foundry.</p>
<p>This book is open source. Find a typo or want to contribute? Check out the book's <a href="https://github.com/cairo-book/cairo-book">GitHub repository</a>.</p>
<p>Additional resources for mastering Cairo:</p>
<ul>
<li>
<p><a href="https://www.cairo-lang.org/cairovm/">The Cairo Playground</a>: A browser-based playground for Cairo, enabling to explore and experiment with Cairo by writing, compiling, debugging, and proving Cairo code without any setup</p>
<blockquote>
<p>Note: You can use the Cairo Playground to experiment with the book's code snippets and see how they compile into Sierra (Intermediate Representation) and Casm (Cairo Assembly).</p>
</blockquote>
</li>
<li>
<p><a href="https://docs.cairo-lang.org/core?_=60">The Cairo Core Library Docs</a>: The documentation for Cairo's Core library, the standard set of types, traits, and utilities built into the language which provides essential building blocks basic used throughout the Cairo ecosystem and is automatically available in every Cairo project</p>
</li>
<li>
<p><a href="https://scarbs.xyz/">The Cairo Package Registry</a>: The host for Cairo's growing collection of reusable libraries, including <a href="https://github.com/keep-starknet-strange/alexandria">Alexandria</a>, <a href="https://docs.openzeppelin.com/contracts-cairo/1.0.0/">Open Zeppelin Contracts for Cairo</a>, all of which can be easily integrated via Scarb, streamlining development and dependency management</p>
</li>
<li>
<p><a href="https://docs.swmansion.com/scarb/docs.html">The Scarb documentation</a>: The official documentation for Cairo’s package manager and build tool, covering how to create and manage packages, use dependencies, run builds, and configure projects</p>
</li>
<li>
<p><a href="https://eprint.iacr.org/2021/1063.pdf">The Cairo whitepaper</a>: The original paper introducing Cairo by StarkWare, which explains Cairo as a language for writing provable programs, details its architecture, and shows how it enables scalable, verifiable computation without relying on trusted setups</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.</p>
<p>However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.</p>
<p>This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.</p>
<p>Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code their smart contracts. This allows the Starknet OS to generate execution traces for transactions to be proved by a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet.</p>
<p>However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.</p>
<p>This book is designed for developers with a basic understanding of programming concepts. It is a friendly and approachable text intended to help you level up your knowledge of Cairo, but also help you develop your programming skills in general. So, dive in and get ready to learn all there is to know about Cairo!</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!</p>
<p>We would like to thank the Rust community for the <a href="https://doc.rust-lang.org/book/">Rust Book</a>, which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-cairo"><a class="header" href="#what-is-cairo">What is Cairo?</a></h2>
<p>Cairo is a programming language designed to leverage the power of mathematical proofs for computational integrity. Just as C.S. Lewis defined integrity as "doing the right thing, even when no one is watching," Cairo enables programs to prove they've done the right computation, even when executed on untrusted machines.</p>
<p>The language is built on STARK technology, a modern evolution of PCP (Probabilistically Checkable Proofs) that transforms computational claims into constraint systems. While Cairo's ultimate purpose is to generate these mathematical proofs that can be verified efficiently and with absolute certainty.</p>
<h2 id="what-can-you-do-with-it"><a class="header" href="#what-can-you-do-with-it">What Can You Do with It?</a></h2>
<p>Cairo enables a paradigm shift in how we think about trusted computation. Its primary application today is Starknet, a Layer 2 scaling solution for Ethereum that addresses one of blockchain's fundamental challenges: scalability without sacrificing security.</p>
<p>In the traditional blockchain model, every participant must verify every computation. Starknet changes this by using Cairo's proof system: computations are executed off-chain by a prover who generates a STARK proof, which is then verified by an Ethereum smart contract. This verification requires significantly less computational power than re-executing the computations, enabling massive scalability while maintaining security.</p>
<p>However, Cairo's potential extends beyond blockchain. Any scenario where computational integrity needs to be verified efficiently can benefit from Cairo's verifiable computation capabilities.</p>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who Is This Book For?</a></h2>
<p>This book caters to three main audiences, each with their own learning path:</p>
<ol>
<li>
<p><strong>General-Purpose Developers</strong>: If you're interested in Cairo for its verifiable computation capabilities outside of blockchain, you'll want to focus on chapters 1-12. These chapters cover the core language features and programming concepts without diving deep into smart contract specifics.</p>
</li>
<li>
<p><strong>New Smart Contract Developers</strong>: If you're new to both Cairo and smart contracts, we recommend reading the book front to back. This will give you a solid foundation in both the language fundamentals and smart contract development principles.</p>
</li>
<li>
<p><strong>Experienced Smart Contract Developers</strong>: If you're already familiar with smart contract development in other languages, or Rust, you might want to follow this focused path:</p>
<ul>
<li>Chapters 1-3 for Cairo basics</li>
<li>Chapter 8 for Cairo's trait and generics system</li>
<li>Skip to Chapter 15 for smart contract development</li>
<li>Reference other chapters as needed</li>
</ul>
</li>
</ol>
<p>Regardless of your background, this book assumes basic programming knowledge such as variables, functions, and common data structures. While prior experience with Rust can be helpful (as Cairo shares many similarities), it's not required.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Cairo CPU Architecture: <a href="https://eprint.iacr.org/2021/1063">https://eprint.iacr.org/2021/1063</a></li>
<li>Cairo, Sierra and Casm: <a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5</a></li>
<li>State of non determinism: <a href="https://twitter.com/PapiniShahar/status/1638203716535713798">https://twitter.com/PapiniShahar/status/1638203716535713798</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s start your Cairo journey! There’s a lot to learn, but every journey starts somewhere. In this chapter, we’ll discuss:</p>
<ul>
<li>Installing Scarb, which is Cairo's build toolchain and package manager, on Linux, macOS, and Windows.</li>
<li>Installing Starknet Foundry, which is the default test runnner when creating a Cairo project.</li>
<li>Writing a program that prints <code>Hello, world!</code>.</li>
<li>Using basic Scarb commands to create a project and execute a program.</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you have any questions about Starknet or Cairo, you can ask them in the <a href="https://discord.gg/starknet-community">Starknet Discord server</a>. The community is friendly and always willing to help.</p>
<h2 id="interacting-with-the-starknet-ai-agent"><a class="header" href="#interacting-with-the-starknet-ai-agent">Interacting with the Starknet AI Agent</a></h2>
<p>Starknet proposes its own AI agent designed to assist with Cairo and Starknet-related questions. This AI agent is trained on the Cairo book and the Starknet documentation, using Retrieval-Augmented Generation (RAG) to efficiently retrieve information and provide accurate assistance.</p>
<p>You can find the Starknet Agent on the <a href="https://agent.starknet.id/">Starknet Agent</a> website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The first step is to install Cairo. We'll download Cairo through <a href="https://github.com/software-mansion/starkup">starkup</a>, a command line tool for managing Cairo versions and associated tools. You'll need an internet connection for the download.</p>
<p>The following steps install the latest stable version of the Cairo compiler through a binary called <a href="https://docs.swmansion.com/scarb/docs">Scarb</a>. Scarb bundles the Cairo compiler and the Cairo language server together in an easy-to-install package so that you can start writing Cairo code right away.</p>
<p>Scarb is also Cairo's package manager and is heavily inspired by <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, Rust's build system and package manager.</p>
<p>Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries, and provides LSP support for the VSCode Cairo 1 extension.</p>
<p>As you write more complex Cairo programs, you might add dependencies, and if you start a project using Scarb, managing external code and dependencies will be a lot easier to do.</p>
<p><a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a> is a toolchain for Cairo programs and Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.</p>
<p>Let's start by installing starkup, which will help us manage Cairo, Scarb, and Starknet Foundry.</p>
<h2 id="installing-starkup-on-linux-or-macos"><a class="header" href="#installing-starkup-on-linux-or-macos">Installing <code>starkup</code> on Linux or MacOs</a></h2>
<p>If you're using Linux or macOS, open a terminal and enter the following command:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.starkup.dev | sh
</code></pre>
<p>The command downloads a script and starts the installation of the starkup tool, which installs the latest stable version of Cairo and related toolings. You might be prompted for your password. If the install is successful, the following line will appear:</p>
<pre><code class="language-bash">starkup: Installation complete.
</code></pre>
<p>After installation, starkup will automatically install the latest stable versions of Cairo, Scarb, and Starknet Foundry. You can verify the installations by running the following commands in a new terminal session:</p>
<pre><code class="language-bash">$ scarb --version
scarb 2.11.4 (c0ef5ec6a 2025-04-09)
cairo: 2.11.4 (https://crates.io/crates/cairo-lang-compiler/2.11.4)
sierra: 1.7.0

$ snforge --version
snforge 0.39.0
</code></pre>
<p>We'll describe Starknet Foundry in more detail in <a href="./ch10-01-how-to-write-tests.html">Chapter 10</a> for Cairo programs testing and in <a href="./ch104-02-testing-smart-contracts.html#testing-smart-contracts-with-starknet-foundry">Chapter 18</a> when discussing Starknet smart contract testing and security in the second part of the book.</p>
<h2 id="installing-the-vscode-extension"><a class="header" href="#installing-the-vscode-extension">Installing the VSCode Extension</a></h2>
<p>Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You can install it from the <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">VSCode Marketplace</a>.
Once installed, go into the extension settings, and make sure to tick the <code>Enable Language Server</code> and <code>Enable Scarb</code> options.</p>
<p>{{#quiz ../quizzes/ch01-01-installation.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>Now that you’ve installed Cairo through Scarb, it’s time to write your first Cairo program.
It’s traditional when learning a new language to write a little program that
prints the text <code>Hello, world!</code> to the screen, so we’ll do the same here!</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Cairo makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. The Cairo team has developed
a VSCode extension for the Cairo language that you can use to get the features from
the language server and code highlighting. See <a href="./appendix-06-useful-development-tools.html">Appendix F</a>
for more details.</p>
</blockquote>
<h2 id="creating-a-project-directory"><a class="header" href="#creating-a-project-directory">Creating a Project Directory</a></h2>
<p>You’ll start by making a directory to store your Cairo code. It doesn’t matter
to Cairo where your code lives, but for the exercises and projects in this book,
we suggest making a <em>cairo_projects</em> directory in your home directory and keeping all
your projects there.</p>
<p>Open a terminal and enter the following commands to make a <em>cairo_projects</em> directory.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<pre><code class="language-shell">mkdir ~/cairo_projects
cd ~/cairo_projects
</code></pre>
<p>For Windows CMD, enter this:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\cairo_projects"
&gt; cd /d "%USERPROFILE%\cairo_projects"
</code></pre>
<blockquote>
<p>Note: From now on, for each example shown in the book, we assume that
you will be working from a Scarb project directory. If you are not using Scarb, and try to run the examples from a different directory, you might need to adjust the commands accordingly or create a Scarb project.</p>
</blockquote>
<h2 id="creating-a-project-with-scarb"><a class="header" href="#creating-a-project-with-scarb">Creating a Project with Scarb</a></h2>
<p>Let’s create a new project using Scarb.</p>
<p>Navigate to your <em>cairo_projects</em> directory (or wherever you decided to store your code). Then run the following:</p>
<pre><code class="language-bash">scarb new hello_world
</code></pre>
<p>Scarb will ask you about the dependencies you want to add.
You will be given two options :</p>
<pre><code class="language-text">? Which test runner do you want to set up? ›
❯ Starknet Foundry (default)
  Cairo Test
</code></pre>
<p>In general, we'll prefer using the first one <code>❯ Starknet Foundry (default)</code>.</p>
<p>This creates a new directory and project called <em>hello_world</em>. We’ve named our project <em>hello_world</em>, and Scarb creates its files in a directory of the same name.</p>
<p>Go into the <em>hello_world</em> directory with the command <code>cd hello_world</code>. You’ll see that Scarb has generated three files and two directory for us: a <em>Scarb.toml</em> file, a <em>src</em> directory with a <em>lib.cairo</em> file inside and a <em>tests</em> directory containing a <em>test_contract.cairo</em> file. For now, we can remove this <em>tests</em> directory.</p>
<p>It has also initialized a new Git repository along with a <code>.gitignore</code> file</p>
<blockquote>
<p>Note: Git is a common version control system. You can stop using version control system by using the <code>--no-vcs</code> flag.
Run <code>scarb new --help</code> to see the available options.</p>
</blockquote>
<p>Open <em>Scarb.toml</em> in your text editor of choice. It should look similar to the code in Listing 1-1.</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.11.4"

[dev-dependencies]
snforge_std = "0.46.0"
assert_macros = "2.11.4"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...
</code></pre>
<p><span class="caption">Listing 1-1: Contents of <em>Scarb.toml</em> generated by <code>scarb new</code></span></p>
<p>This file is in the <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) format, which is Scarb’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections.</p>
<p>The next three lines set the configuration information Scarb needs to compile your program: the name of the package and the version of Scarb to use, and the edition of the prelude to use. The prelude is the collection of the most commonly used items that are automatically imported into every Cairo program. You can learn more about the prelude in <a href="./appendix-04-cairo-prelude.html">Appendix D</a>.</p>
<p>The <code>[dependencies]</code> section, is the start of a section for you to list any of your project’s dependencies. In Cairo, packages of code are referred to as crates. We won’t need any other crates for this project.</p>
<p>The <code>[dev-dependencies]</code> section is about dependencies that are required for development, but are not needed for the actual production build of the project. <code>snforge_std</code> and <code>assert_macros</code> are two examples of such dependencies. If you want to test your project without using Starknet Foundry, you can use <code>cairo_test</code>.</p>
<p>The <code>[[target.starknet-contract]]</code> section allows to build Starknet smart contracts. We can remove it for now.</p>
<p>The <code>[script]</code> section allows to define custom scripts. By default, there is one script for running tests using <code>snforge</code> with the <code>scarb test</code> command. We can also remove it for now.</p>
<p>Starknet Foundry also have more options, check out <a href="https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html">Starknet Foundry documentation</a> for more information.</p>
<p>By default, using Starknet Foundry adds the <code>starknet</code> dependency and the <code>[[target.starknet-contract]]</code> section, so that you can build contracts for Starknet out of the box. We will start with only Cairo programs, so you can edit your <em>Scarb.toml</em> file to the following:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.11.4"


[[target.executable]]
name = "hello_world_main"
function = "hello_world::hello_world::main"
</code></pre>
<p><span class="caption">Listing 1-2: Contents of modified <em>Scarb.toml</em></span></p>
<p>The other file created by Scarb is <em>src/lib.cairo</em>, let's delete all the content and put in the following content, we will explain the reason later.</p>
<pre><code class="language-cairo noplayground">mod hello_world;
</code></pre>
<p>Then create a new file called <em>src/hello_world.cairo</em> and put the following code in it:</p>
<p><span class="filename">Filename: src/hello_world.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    println!("Hello, World!");
}
</code></pre>
<p>We have just created a file called <em>lib.cairo</em>, which contains a module declaration referencing another module named <code>hello_world</code>, as well as the file <em>hello_world.cairo</em>, containing the implementation details of the <code>hello_world</code> module.</p>
<p>Scarb requires your source files to be located within the <em>src</em> directory.</p>
<p>The top-level project directory is reserved for <em>README</em> files, license information, configuration files, and any other non-code-related content.
Scarb ensures a designated location for all project components, maintaining a structured organization.</p>
<p>If you started a project that doesn’t use Scarb, you can convert it to a project that does use Scarb. Move the project code into the <em>src</em> directory and create an appropriate <em>Scarb.toml</em> file. You can also use <code>scarb init</code> command to generate the <em>src</em> folder and the <em>Scarb.toml</em> it contains.</p>
<pre><code class="language-txt">├── Scarb.toml
├── src
│   ├── lib.cairo
│   └── hello_world.cairo
</code></pre>
<p><span class="caption"> A sample Scarb project structure</span></p>
<h2 id="building-a-scarb-project"><a class="header" href="#building-a-scarb-project">Building a Scarb Project</a></h2>
<p>From your <em>hello_world</em> directory, build your project by entering the following command:</p>
<pre><code class="language-bash">$ scarb build
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds

</code></pre>
<p>This command creates a <code>hello_world.sierra.json</code> file in <em>target/dev</em>, let's ignore the <code>sierra</code> file for now.</p>
<p>If you have installed Cairo correctly, you should be able to run the <code>main</code> function of your program with the <code>scarb execute</code> command and see the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing hello_world
Hello, World!


</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should be printed to
the terminal.</p>
<p>If <code>Hello, world!</code> did print, congratulations! You’ve officially written a Cairo
program. That makes you a Cairo programmer — welcome!</p>
<h2 id="anatomy-of-a-cairo-program"><a class="header" href="#anatomy-of-a-cairo-program">Anatomy of a Cairo Program</a></h2>
<p>Let’s review this “Hello, world!” program in detail. Here’s the first piece of
the puzzle:</p>
<pre><code class="language-cairo noplayground">fn main() {

}
</code></pre>
<p>These lines define a function named <code>main</code>. The <code>main</code> function is special: it
is always the first code that runs in every executable Cairo program. Here, the
first line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses <code>()</code>.</p>
<p>The function body is wrapped in <code>{}</code>. Cairo requires curly brackets around all
function bodies. It’s good style to place the opening curly bracket on the same
line as the function declaration, adding one space in between.</p>
<blockquote>
<p>Note: If you want to stick to a standard style across Cairo projects, you can
use the automatic formatter tool available with <code>scarb fmt</code> to format your code in a
particular style (more on <code>scarb fmt</code> in
<a href="./appendix-06-useful-development-tools.html">Appendix F</a>). The Cairo team has included this tool
with the standard Cairo distribution, as <code>cairo-run</code> is, so it should already be
installed on your computer!</p>
</blockquote>
<p>The body of the <code>main</code> function holds the following code:</p>
<pre><code class="language-cairo noplayground">    println!("Hello, World!");
</code></pre>
<p>This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.</p>
<p>First, Cairo style is to indent with four spaces, not a tab.</p>
<p>Second, <code>println!</code> calls a Cairo macro. If it had called a function instead, it would be entered as <code>println</code> (without the <code>!</code>).
We’ll discuss Cairo macros in more detail in the <a href="./ch12-05-macros.html">"Macros"</a> chapter. For now, you just need to know that using a <code>!</code> means that you’re calling a macro instead of a normal function and that macros don’t always follow the same rules as functions.</p>
<p>Third, you see the <code>"Hello, world!"</code> string. We pass this string as an argument to <code>println!</code>, and the string is printed to the screen.</p>
<p>Fourth, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Cairo code
end with a semicolon.</p>
<p>{{#quiz ../quizzes/ch01-02-hello-world.toml}}</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>Let’s recap what we’ve learned so far about Scarb:</p>
<ul>
<li>We can install one or multiple Scarb versions, either the latest stable or a specific one, using asdf.</li>
<li>We can create a project using <code>scarb new</code>.</li>
<li>We can build a project using <code>scarb build</code> to generate the compiled Sierra code.</li>
<li>We can execute a Cairo program using the <code>scarb execute</code> command.</li>
</ul>
<p>An additional advantage of using Scarb is that the commands are the same no matter which operating system you’re working on. So, at this point, we’ll no longer provide specific instructions for Linux and macOS versus Windows.</p>
<p>You’re already off to a great start on your Cairo journey! This is a great time to build a more substantial program to get used to reading and writing Cairo code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proving-that-a-number-is-prime"><a class="header" href="#proving-that-a-number-is-prime">Proving That A Number Is Prime</a></h1>
<p>Let’s dive into Cairo by working through a hands-on project together! This section introduces you to key Cairo concepts and the process of generating zero-knowledge proofs locally, a powerful feature enabled by Cairo in combination with the <a href="https://github.com/starkware-libs/stwo">Stwo prover</a>. You’ll learn about functions, control flow, executable targets, Scarb workflows, and how to prove a statement — all while practicing the fundamentals of Cairo programming. In later chapters, we’ll explore these ideas in more depth.</p>
<p>For this project, we’ll implement a classic mathematical problem suited for zero-knowledge proofs: proving that a number is prime. This is the ideal project to introduce you to the concept of zero-knowledge proofs in Cairo, because while <em>finding</em> prime numbers is a complex task, <em>proving</em> that a number is prime is straightforward.</p>
<p>Here’s how it works: the program will take an input number from the user and check whether it’s prime using a trial division algorithm. Then, we’ll use Scarb to execute the program and generate a proof that the primality check was performed correctly, so that anyone can verify your proof to trust that you found a prime number. The user will input a number, and we’ll output whether it’s prime, followed by generating and verifying a proof.</p>
<h2 id="setting-up-a-new-project"><a class="header" href="#setting-up-a-new-project">Setting Up a New Project</a></h2>
<p>To get started, ensure you have Scarb 2.11.4 or later installed (see <a href="./ch01-01-installation.html">Installation</a> for details). We’ll use Scarb to create and manage our Cairo project.</p>
<p>Open a terminal in your projects directory and create a new Scarb project:</p>
<pre><code class="language-bash">scarb new prime_prover
cd prime_prover
</code></pre>
<p>The scarb new command creates a new directory called <code>prime_prover</code> with a basic project structure. Let’s examine the generated Scarb.toml file:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[dependencies]

[dev-dependencies]
cairo_test = "2.11.4"
</code></pre>
<p>This is a minimal manifest file for a Cairo project. However, since we want to create an executable program that we can prove, we need to modify it. Update Scarb.toml to define an executable target and include the <code>cairo_execute</code> plugin:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.11.4"


[[target.executable]]
name = "main"
function = "prime_prover::main"
</code></pre>
<p>Here’s what we’ve added:</p>
<ul>
<li><code>[[target.executable]]</code> specifies that this package compiles to a Cairo executable (not a library or Starknet contract).</li>
<li><code>[cairo] enable-gas = false</code> disables gas tracking, which is required for executable targets since gas is specific to Starknet contracts.
<code>[dependencies] cairo_execute = "2.11.4"</code> adds the plugin needed to execute and prove our program.</li>
</ul>
<p>Now, check the generated <code>src/lib.cairo</code>, which is a simple placeholder. Since we’re building an executable, we’ll replace this with a function annotated with <code>#[executable]</code> to define our entry point.</p>
<h2 id="writing-the-prime-checking-logic"><a class="header" href="#writing-the-prime-checking-logic">Writing the Prime-Checking Logic</a></h2>
<p>Let’s write a program to check if a number is prime. A number is prime if it’s greater than 1 and divisible only by 1 and itself. We’ll implement a simple trial division algorithm and mark it as executable. Replace the contents of <code>src/lib.cairo</code> with the following:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u32) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    let mut is_prime = true;
    loop {
        if i * i &gt; n {
            break;
        }
        if n % i == 0 {
            is_prime = false;
            break;
        }
        i += 2;
    }
    is_prime
}

// Executable entry point
#[executable]
fn main(input: u32) -&gt; bool {
    is_prime(input)
}
</code></pre>
<p>Let’s break this down:</p>
<p>The <code>is_prime</code> function:</p>
<ul>
<li>Takes a <code>u32</code> input (an unsigned 32-bit integer) and returns a <code>bool</code>.</li>
<li>Checks edge cases: numbers ≤ 1 are not prime, 2 is prime, even numbers &gt; 2 are not prime.</li>
<li>Uses a loop to test odd divisors up to the square root of <code>n</code>. If no divisors are found, the number is prime.</li>
</ul>
<p>The <code>main</code> function:</p>
<ul>
<li>Marked with <code>#[executable]</code>, indicating it’s the entry point for our program.</li>
<li>Takes a u32 input from the user and returns a bool indicating whether it’s prime.</li>
<li>Calls is_prime to perform the check.</li>
</ul>
<p>This is a straightforward implementation, but it’s perfect for demonstrating proving in Cairo.</p>
<h2 id="executing-the-program"><a class="header" href="#executing-the-program">Executing the Program</a></h2>
<p>Now let’s run the program with Scarb to test it. Use the scarb execute command and provide an input number as an argument:</p>
<pre><code class="language-bash">scarb execute -p prime_prover --print-program-output --arguments 17
</code></pre>
<ul>
<li><code>-p prime_prover</code> specifies the package name (matches Scarb.toml).</li>
<li><code>--print-program-output</code> displays the result.</li>
<li><code>--arguments 17</code> passes the number 17 as input.</li>
</ul>
<p>You should see output like this:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 17
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing prime_prover
Program output:
1


</code></pre>
<p>The output represents whether the program executed successfully and the result of the program. Here, <code>0</code> indicates success (no panic), and <code>1</code> represents true (17 is prime). Try a few more numbers:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 4
[0, 0]  # 4 is not prime
$ scarb execute -p prime_prover --print-program-output --arguments 23
[0, 1]  # 23 is prime
</code></pre>
<p>The execution creates a folder under <code>./target/execute/prime_prover/execution1/</code> containing files like <code>air_public_input.json</code>, <code>air_private_input.json</code>, <code>trace.bin</code>, and <code>memory.bin</code>. These are the artifacts needed for proving.</p>
<h2 id="generating-a-zero-knowledge-proof"><a class="header" href="#generating-a-zero-knowledge-proof">Generating a Zero-Knowledge Proof</a></h2>
<p>Now for the exciting part: proving that the primality check was computed correctly without revealing the input! Cairo 2.10 integrates the Stwo prover via Scarb, allowing us to generate a proof directly. Run:</p>
<pre><code class="language-bash">$ scarb prove --execution-id 1
     Proving prime_prover
warn: soundness of proof is not yet guaranteed by Stwo, use at your own risk
Saving proof to: target/execute/prime_prover/execution1/proof/proof.json

</code></pre>
<p><code>--execution_id 1</code> points to the first execution (from the <code>execution1</code> folder).</p>
<p>This command generates a <code>proof.json</code> file in <code>./target/execute/prime_prover/execution1/proof/</code>. The proof demonstrates that the program executed correctly for some input, producing a true or false output.</p>
<h2 id="verifying-the-proof"><a class="header" href="#verifying-the-proof">Verifying the Proof</a></h2>
<p>To ensure the proof is valid, verify it with:</p>
<pre><code class="language-bash">$ scarb verify --execution-id 1
   Verifying prime_prover
    Verified proof successfully

</code></pre>
<p>If successful, you’ll see a confirmation message. This verifies that the computation (primality check) was performed correctly, aligning with the public inputs, without needing to re-run the program.</p>
<h2 id="improving-the-program-handling-input-errors"><a class="header" href="#improving-the-program-handling-input-errors">Improving the Program: Handling Input Errors</a></h2>
<p>Currently, our program assumes the input is a valid <code>u32</code>. What if we want to handle larger numbers or invalid inputs? Cairo’s <code>u32</code> has a maximum value of <code>2^32 - 1 (4,294,967,295)</code>, and inputs must be provided as integers. Let’s modify the program to use <code>u128</code> and add a basic check. Update <code>src/lib.cairo</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u128) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    let mut is_prime = true;
    loop {
        if i * i &gt; n {
            break;
        }
        if n % i == 0 {
            is_prime = false;
            break;
        }
        i += 2;
    }
    is_prime
}

#[executable]
fn main(input: u128) -&gt; bool {
    if input &gt; 1000000 { // Arbitrary limit for demo purposes
        panic!("Input too large, must be &lt;= 1,000,000");
    }
    is_prime(input)
}
</code></pre>
<p>Changed <code>u32</code> to <code>u128</code> for a larger range (up to <code>2^128 - 1</code>).
Added a check to panic if the input exceeds 1,000,000 (for simplicity; adjust as needed).
Test it:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 1000001
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover2/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing prime_prover
error: Panicked with "Input too large, must be &lt;= 1,000,000".

</code></pre>
<p>If we pass a number greater than 1,000,000, the program will panic - and thus, no proof can be generated. As such, it's not possible to verify a proof for a panicked execution.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Congratulations! You’ve built a Cairo program to check primality, executed it with Scarb, and generated and verified a zero-knowledge proof using the Stwo prover. This project introduced you to:</p>
<ul>
<li>Defining executable targets in Scarb.toml.</li>
<li>Writing functions and control flow in Cairo.</li>
<li>Using <code>scarb execute</code> to run programs and generate execution traces.</li>
<li>Proving and verifying computations with <code>scarb prove</code> and <code>scarb verify</code>.</li>
</ul>
<p>In the next chapters, you’ll dive deeper into Cairo’s syntax (Chapter 2), ownership (Chapter 4), and other features. For now, experiment with different inputs or modify the primality check — can you optimize it further?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Cairo, but we’ll discuss them in the context of Cairo and explain the conventions around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give you a strong core to start from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-mutability"><a class="header" href="#variables-and-mutability">Variables and Mutability</a></h1>
<p>Cairo uses an immutable memory model, meaning that once a memory cell is written to,
it can't be overwritten but only read from. To reflect this immutable memory model,
variables in Cairo are immutable by default.
However, the language abstracts this model and gives you the option to make your
variables mutable. Let’s explore how and why Cairo enforces immutability, and how
you can make your variables mutable.</p>
<p>When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, generate a new project called <em>variables</em> in
your <em>cairo_projects</em> directory by using <code>scarb new variables</code>.</p>
<p>Then, in your new <em>variables</em> directory, open <em>src/lib.cairo</em> and replace its
code with the following code, which won’t compile just yet:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}

</code></pre>
<p>Save and run the program using <code>scarb execute</code>. You should receive an error message
regarding an immutability error, as shown in this output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_01_variables_are_immutable v0.1.0 (listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml)
error: Cannot assign to an immutable variable.
 --&gt; listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:7:5
    x = 6;
    ^^^^^

error: could not compile `no_listing_01_variables_are_immutable` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but they only mean your program
isn’t safely doing what you want it to do yet; they do <em>not</em> mean that you’re
not a good programmer! Experienced Caironautes still get compiler errors.</p>
<p>You received the error message <code>Cannot assign to an immutable variable.</code>
because you tried to assign a second value to the immutable <code>x</code> variable.</p>
<p>It’s important that we get compile-time errors when we attempt to change a
value that’s designated as immutable because this specific situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it’s possible
that the first part of the code won’t do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only <em>sometimes</em>.</p>
<p>Cairo, unlike most other languages, has immutable memory. This makes a
whole class of bugs impossible, because values will never change unexpectedly.
This makes code easier to reason about.</p>
<p>But mutability can be very useful, and can make code more convenient to write.
Although variables are immutable by default, you can make them mutable by
adding <code>mut</code> in front of the variable name. Adding <code>mut</code> also conveys
intent to future readers of the code by indicating that other parts of the code
will be changing the value associated to this variable.</p>
<!-- TODO: add an illustration of this -->
<p>However, you might be wondering at this point what exactly happens when a variable
is declared as <code>mut</code>, as we previously mentioned that Cairo's memory is immutable.
The answer is that the <em>value</em> is immutable, but the <em>variable</em> isn't. The value
associated to the variable can be changed. Assigning to a mutable variable in Cairo
is essentially equivalent to redeclaring it to refer to another value in another memory cell,
but the compiler handles that for you, and the keyword <code>mut</code> makes it explicit.
Upon examining the low-level Cairo Assembly code, it becomes clear that
variable mutation is implemented as syntactic sugar, which translates mutation operations
into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo
level, the variable is not redeclared so its type cannot change.</p>
<p>For example, let’s change <em>src/lib.cairo</em> to the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>When we run the program now, we get this:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_02_adding_mut v0.1.0 (listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_02_adding_mut
The value of x is: 5
The value of x is: 6


</code></pre>
<p>We’re allowed to change the value bound to <code>x</code> from <code>5</code> to <code>6</code> when <code>mut</code> is
used. Ultimately, deciding whether to use mutability or not is up to you and
depends on what you think is clearest in that particular situation.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Like immutable variables, <em>constants</em> are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.</p>
<p>First, you aren’t allowed to use <code>mut</code> with constants. Constants aren’t just
immutable by default—they’re always immutable. You declare constants using the
<code>const</code> keyword instead of the <code>let</code> keyword, and the type of the value <em>must</em>
be annotated. We’ll cover types and type annotations in the next section,
<a href="./ch02-02-data-types.html">“Data Types”</a>, so don’t worry about the details
right now. Just know that you must always annotate the type.</p>
<p>Constant variables can be declared with any usual data type, including structs, enums and fixed-size arrays.</p>
<p>Constants can only be declared in the global scope, which makes
them useful for values that many parts of code need to know about.</p>
<p>The last difference is that constants may natively be set only to a constant expression,
not the result of a value that could only be computed at runtime.</p>
<p>Here’s an example of constants declaration:</p>
<pre><code class="language-cairo noplayground">struct AnyStruct {
    a: u256,
    b: u32,
}

enum AnyEnum {
    A: felt252,
    B: (usize, u256),
}

const ONE_HOUR_IN_SECONDS: u32 = 3600;
const ONE_HOUR_IN_SECONDS_2: u32 = 60 * 60;
const STRUCT_INSTANCE: AnyStruct = AnyStruct { a: 0, b: 1 };
const ENUM_INSTANCE: AnyEnum = AnyEnum::A('any enum');
const BOOL_FIXED_SIZE_ARRAY: [bool; 2] = [true, false];
</code></pre>
<p>Cairo's naming convention for constants is to use all uppercase with underscores between words.</p>
<p>Constants are valid for the entire time a program runs, within the scope in
which they were declared. This property makes constants useful for values in
your application domain that multiple parts of the program might need to know
about, such as the maximum number of points any player of a game is allowed to
earn, or the speed of light.</p>
<p>Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Variable shadowing refers to the declaration of a
new variable with the same name as a previous variable. Caironautes say that the
first variable is <em>shadowed</em> by the second, which means that the second
variable is what the compiler will see when you use the name of the variable.
In effect, the second variable overshadows the first, taking any uses of the
variable name to itself until either it itself is shadowed or the scope ends.
We can shadow a variable by using the same variable’s name and repeating the
use of the <code>let</code> keyword as follows:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("Inner scope x value is: {}", x);
    }
    println!("Outer scope x value is: {}", x);
}
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it creates a new variable
<code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the
value of <code>x</code> is then <code>6</code>. Then, within an inner scope created with the curly
brackets, the third <code>let</code> statement also shadows <code>x</code> and creates a new
variable, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>.
When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code>.
When we run this program, it will output the following:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_03_shadowing
Inner scope x value is: 12
Outer scope x value is: 6


</code></pre>
<p>Shadowing is different from marking a variable as <code>mut</code> because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the <code>let</code> keyword. By using <code>let</code>, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.</p>
<p>Another distinction between <code>mut</code> and shadowing is that when we use the <code>let</code> keyword again,
we are effectively creating a new variable, which allows us to change the type of the
value while reusing the same name. As mentioned before, variable shadowing and mutable variables
are equivalent at the lower level.
The only difference is that by shadowing a variable, the compiler will not complain
if you change its type. For example, say our program performs a type conversion between the
<code>u64</code> and <code>felt252</code> types.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: u64 = 2;
    println!("The value of x is {} of type u64", x);
    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.
    println!("The value of x is {} of type felt252", x);
}
</code></pre>
<p>The first <code>x</code> variable has a <code>u64</code> type while the second <code>x</code> variable has a <code>felt252</code> type.
Shadowing thus spares us from having to come up with different names, such as <code>x_u64</code>
and <code>x_felt252</code>; instead, we can reuse the simpler <code>x</code> name. However, if we try to use
<code>mut</code> for this, as shown here, we’ll get a compile-time error:</p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let mut x: u64 = 2;
    println!("The value of x is: {}", x);
    x = 5_u8;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>The error says we were expecting a <code>u64</code> (the original type) but we got a different type:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_05_mut_cant_change_type v0.1.0 (listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml)
error: Unexpected argument type. Expected: "core::integer::u64", found: "core::integer::u8".
 --&gt; listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:7:9
    x = 5_u8;
        ^^^^

error: could not compile `no_listing_05_mut_cant_change_type` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}</p>
<p>Now that we’ve explored how variables work, let’s look at more data types they can have.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Every value in Cairo is of a certain <em>data type</em>, which tells Cairo what kind of
data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds.</p>
<p>Keep in mind that Cairo is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases when many types are possible, we can use a conversion method where we specify the desired output type.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: felt252 = 3;
    let y: u32 = x.try_into().unwrap();
}
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<h2 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h2>
<p>A <em>scalar</em> type represents a single value. Cairo has three primary scalar types:
felts, integers, and booleans. You may recognize
these from other programming languages. Let’s jump into how they work in Cairo.</p>
<h3 id="felt-type"><a class="header" href="#felt-type">Felt Type</a></h3>
<p>In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword <code>felt252</code>. In the context of Cairo, when we say “a field element” we mean an integer in the range \( 0 \leq x &lt; P \),
where \( P \) is a very large prime number currently equal to \( {2^{251}} + 17 \cdot {2^{192}} + 1 \). When adding, subtracting, or multiplying, if the result falls outside the specified range of the prime number, an overflow (or underflow) occurs, and an appropriate multiple of \( P \) is added or subtracted to bring the result back within the range (i.e., the result is computed \( \mod P \) ).</p>
<p>The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where
integer division \( \frac{x}{y} \) is defined as \( \left\lfloor \frac{x}{y} \right\rfloor \)
where the integer part of the quotient is returned (so you get \( \frac{7}{3} = 2 \)) and it may or may not satisfy the equation \( \frac{x}{y} \cdot y == x \),
depending on the divisibility of <code>x</code> by <code>y</code>.</p>
<p>In Cairo, the result of \( \frac{x}{y} \) is defined to always satisfy the equation \( \frac{x}{y} \cdot y == x \). If y divides x as integers, you will get the expected result in Cairo (for example \( \frac{6}{2} \) will indeed result in <code>3</code>).
But when y does not divide x, you may get a surprising result: for example, since \( 2 \cdot \frac{P + 1}{2} = P + 1 \equiv 1 \mod P \), the value of \( \frac{1}{2} \) in Cairo is \( \frac{P + 1}{2} \) (and not 0 or 0.5), as it satisfies the above equation.</p>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h3>
<p>The felt252 type is a fundamental type that serves as the basis for creating all types in the core library.
However, it is highly recommended for programmers to use the integer types instead of the <code>felt252</code> type whenever possible, as the <code>integer</code> types come with added security features that provide extra protection against potential vulnerabilities in the code, such as overflow and underflow checks. By using these integer types, programmers can ensure that their programs are more secure and less susceptible to attacks or other security threats.
An <code>integer</code> is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer.
Table 3-1 shows the built-in integer types in Cairo. We can use any of these variants to declare the type of an integer value.</p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>u128</code></td></tr>
<tr><td>256-bit</td><td><code>u256</code></td></tr>
<tr><td>32-bit</td><td><code>usize</code></td></tr>
</tbody></table>
</div><br>
<div align="center"><span class="caption">Table 3-1: Integer Types in Cairo.</span></div>
<p>Each variant has an explicit size. Note that for now, the <code>usize</code> type is just an alias for <code>u32</code>; however, it might be useful when in the future Cairo can be compiled to MLIR.
As variables are unsigned, they can't contain a negative number. This code will cause the program to panic:</p>
<pre><code class="language-cairo">fn sub_u8s(x: u8, y: u8) -&gt; u8 {
    x - y
}

#[executable]
fn main() {
    sub_u8s(1, 3);
}
</code></pre>
<p>All integer types previously mentioned fit into a <code>felt252</code>, except for <code>u256</code> which needs 4 more bits to be stored. Under the hood, <code>u256</code> is basically a struct with 2 fields: <code>u256 {low: u128, high: u128}</code>.</p>
<p>Cairo also provides support for signed integers, starting with the prefix <code>i</code>. These integers can represent both positive and negative values, with sizes ranging from <code>i8</code> to <code>i128</code>.
Each signed variant can store numbers from \( -({2^{n - 1}}) \) to \( {2^{n - 1}} - 1 \) inclusive, where <code>n</code> is the number of bits that variant uses. So an i8 can store numbers from \( -({2^7}) \) to \( {2^7} - 1 \), which equals <code>-128</code> to <code>127</code>.</p>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as <code>57_u8</code>, to designate the type.
It is also possible to use a visual separator <code>_</code> for number literals, in order to improve code readability.</p>
<div class="table-wrapper"><table><thead><tr><th>Numeric literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o04321</code></td></tr>
<tr><td>Binary</td><td><code>0b01</code></td></tr>
</tbody></table>
</div><br>
<div align="center"><span class="caption">Table 3-2: Integer Literals in Cairo.</span></div>
<p>So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size.
The primary situation in which you’d use <code>usize</code> is when indexing some sort of collection.</p>
<h3 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h3>
<p>Cairo supports the basic mathematical operations you’d expect for all the integer
types: addition, subtraction, multiplication, division, and remainder. Integer
division truncates toward zero to the nearest integer. The following code shows
how you’d use each numeric operation in a <code>let</code> statement:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}
</code></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable.</p>
<p><a href="./appendix-02-operators-and-symbols.html#operators">Appendix B</a> contains a list of all operators that Cairo provides.</p>
<h3 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h3>
<p>As in most other programming languages, a Boolean type in Cairo has two possible
values: <code>true</code> and <code>false</code>. Booleans are one <code>felt252</code> in size. The Boolean type in
Cairo is specified using <code>bool</code>. For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
<p>When declaring a <code>bool</code> variable, it is mandatory to use either <code>true</code> or <code>false</code> literals as value. Hence, it is not allowed to use integer literals (i.e. <code>0</code> instead of false) for <code>bool</code> declarations.</p>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Cairo in the <a href="./ch02-05-control-flow.html">"Control Flow"</a> section.</p>
<h3 id="string-types"><a class="header" href="#string-types">String Types</a></h3>
<p>Cairo doesn't have a native type for strings but provides two ways to handle them: short strings using simple quotes and ByteArray using double quotes.</p>
<h4 id="short-strings"><a class="header" href="#short-strings">Short strings</a></h4>
<p>A short string is an ASCII string where each character is encoded on one byte (see the <a href="https://www.asciitable.com/">ASCII table</a>). For example:</p>
<ul>
<li><code>'a'</code> is equivalent to <code>0x61</code></li>
<li><code>'b'</code> is equivalent to <code>0x62</code></li>
<li><code>'c'</code> is equivalent to <code>0x63</code></li>
<li><code>0x616263</code> is equivalent to <code>'abc'</code>.</li>
</ul>
<p>Cairo uses the <code>felt252</code> for short strings. As the <code>felt252</code> is on 251 bits, a short string is limited to 31 characters (31 * 8 = 248 bits, which is the maximum multiple of 8 that fits in 251 bits).</p>
<p>You can choose to represent your short string with an hexadecimal value like <code>0x616263</code> or by directly writing the string using simple quotes like <code>'abc'</code>, which is more convenient.</p>
<p>Here are some examples of declaring short strings in Cairo:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span>fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
<span class="boring">    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;
</span><span class="boring">
</span><span class="boring">    let long_string: ByteArray = "this is a string which has more than 31 characters";
</span><span class="boring">}
</span></code></pre>
<h4 id="byte-array-strings"><a class="header" href="#byte-array-strings">Byte Array Strings</a></h4>
<p>Cairo's Core Library provides a <code>ByteArray</code> type for handling strings and byte sequences longer than short strings. This type is particularly useful for longer strings or when you need to perform operations on the string data.</p>
<p>The <code>ByteArray</code> in Cairo is implemented as a combination of two parts:</p>
<ol>
<li>An array of <code>bytes31</code> words, where each word contains 31 bytes of data.</li>
<li>A pending <code>felt252</code> word that acts as a buffer for bytes that haven't yet filled a complete <code>bytes31</code> word.</li>
</ol>
<p>This design enables efficient handling of byte sequences while aligning with Cairo's memory model and basic types. Developers interact with <code>ByteArray</code> through its provided methods and operators, abstracting away the internal implementation details.</p>
<p>Unlike short strings, <code>ByteArray</code> strings can contain more than 31 characters and are written using double quotes:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let my_first_char = 'C';
</span><span class="boring">    let my_first_char_in_hex = 0x43;
</span><span class="boring">
</span><span class="boring">    let my_first_string = 'Hello world';
</span><span class="boring">    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;
</span>
<span class="boring">    let long_string: ByteArray = "this is a string which has more than 31 characters";
</span><span class="boring">}
</span></code></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h3>
<p>A <em>tuple</em> is a general way of grouping together a number of values with a
variety of types into one compound type. Tuples have a fixed length: once
declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup: (u32, u64, bool) = (10, 20, true);
}
</code></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        println!("y is 6!");
    }
}
</code></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em> because it breaks
the single tuple into three parts. Finally, the program prints <code>y is 6!</code> as the value of
<code>y</code> is <code>6</code>.</p>
<p>We can also declare the tuple with value and types, and destructure it at the same time.
For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let (x, y): (felt252, felt252) = (2, 3);
}
</code></pre>
<h4 id="the-unit-type-"><a class="header" href="#the-unit-type-">The Unit Type ()</a></h4>
<p>A <em>unit type</em> is a type which has only one value <code>()</code>.
It is represented by a tuple with no elements.
Its size is always zero, and it is guaranteed to not exist in the compiled code.</p>
<p>You might be wondering why you would even need a unit type? In Cairo, everything is an expression, and an expression that returns nothing actually returns <code>()</code> implicitly.</p>
<h3 id="the-fixed-size-array-type"><a class="header" href="#the-fixed-size-array-type">The Fixed Size Array Type</a></h3>
<p>Another way to have a collection of multiple values is with a <em>fixed size array</em>. Unlike a tuple, every element of a fixed size array must have the same type.</p>
<p>We write the values in a fixed-size array as a comma-separated list inside square brackets. The array’s type is written using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: [u64; 5] = [1, 2, 3, 4, 5];
}
</code></pre>
<p>In the type annotation <code>[u64; 5]</code>, <code>u64</code> specifies the type of each element, while <code>5</code> after the semicolon defines the array's length. This syntax ensures that the array always contains exactly 5 elements of type <code>u64</code>.</p>
<p>Fixed size arrays are useful when you want to hardcode a potentially long sequence of data directly in your program. This type of array must not be confused with the <a href="./ch03-01-arrays.html"><code>Array&lt;T&gt;</code> type</a>, which is a similar collection type provided by the core library that <em>is</em> allowed to grow in size. If you're unsure whether to use a fixed size array or the <code>Array&lt;T&gt;</code> type, chances are that you are looking for the <code>Array&lt;T&gt;</code> type.</p>
<p>Because their size is known at compile-time, fixed-size arrays don't require runtime memory management, which makes them more efficient than dynamically-sized arrays. Overall, they're more useful when you know the number of elements will not need to change. For example, they can be used to efficiently store lookup tables that won't change during runtime. If you were using the names of the month in a program, you would probably use a fixed size array rather than an <code>Array&lt;T&gt;</code> because you know it will always contain 12 elements:</p>
<pre><code class="language-cairo">    let months = [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December',
    ];

</code></pre>
<p>You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:</p>
<pre><code class="language-cairo">    let a = [3; 5];
</code></pre>
<p>The array named <code>a</code> will contain <code>5</code> elements that will all be set to the value <code>3</code> initially. This is the same as writing <code>let a = [3, 3, 3, 3, 3];</code> but in a more concise way.</p>
<h4 id="accessing-fixed-size-arrays-elements"><a class="header" href="#accessing-fixed-size-arrays-elements">Accessing Fixed Size Arrays Elements</a></h4>
<p>As a fixed-size array is a data structure known at compile time, it's content is represented as a sequence of values in the program bytecode. Accessing an element of that array will simply read that value from the program bytecode efficiently.</p>
<p>We have two different ways of accessing fixed size array elements:</p>
<ul>
<li>Deconstructing the array into multiple variables, as we did with tuples.</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by deconstruction
    let [a, b, c, _, _] = my_arr;
    println!("c: {}", c); // c: 3
}
</code></pre>
<ul>
<li>Converting the array to a <a href="./ch03-01-arrays.html#Span">Span</a>, that supports indexing. This operation is <em>free</em> and doesn't incur any runtime cost.</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by index
    let my_span = my_arr.span();
    println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
}
</code></pre>
<p>Note that if we plan to repeatedly access the array, then it makes sense to call <code>.span()</code> only once and keep it available throughout the accesses.</p>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<p>Cairo addresses conversion between types by using the <code>try_into</code> and <code>into</code> methods provided by the <code>TryInto</code> and <code>Into</code> traits from the core library. There are numerous implementations of these traits within the standard library for conversion between types, and they can be implemented for <a href="./ch05-02-an-example-program-using-structs.html#conversions-of-custom-types">custom types as well</a>.</p>
<h3 id="into"><a class="header" href="#into">Into</a></h3>
<p>The <code>Into</code> trait allows for a type to define how to convert itself into another type. It can be used for type conversion when success is guaranteed, such as when the source type is smaller than the destination type.</p>
<p>To perform the conversion, call <code>var.into()</code> on the source value to convert it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_u8: u8 = 10;
    let my_u16: u16 = my_u8.into();
    let my_u32: u32 = my_u16.into();
    let my_u64: u64 = my_u32.into();
    let my_u128: u128 = my_u64.into();

    let my_felt252 = 10;
    // As a felt252 is smaller than a u256, we can use the into() method
    let my_u256: u256 = my_felt252.into();
    let my_other_felt252: felt252 = my_u8.into();
    let my_third_felt252: felt252 = my_u16.into();
}
</code></pre>
<h3 id="tryinto"><a class="header" href="#tryinto">TryInto</a></h3>
<p>Similar to <code>Into</code>, <code>TryInto</code> is a generic trait for converting between types. Unlike <code>Into</code>, the <code>TryInto</code> trait is used for fallible conversions, and as such, returns <a href="./ch06-01-enums.html#the-option-enum-and-its-advantages">Option&lt;T&gt;</a>. An example of a fallible conversion is when the target type might not fit the source value.</p>
<p>Also similar to <code>Into</code> is the process to perform the conversion; just call <code>var.try_into()</code> on the source value to convert it to another type. The new variable's type also must be explicitly defined, as demonstrated in the example below.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_u256: u256 = 10;

    // Since a u256 might not fit in a felt252, we need to unwrap the Option&lt;T&gt; type
    let my_felt252: felt252 = my_u256.try_into().unwrap();
    let my_u128: u128 = my_felt252.try_into().unwrap();
    let my_u64: u64 = my_u128.try_into().unwrap();
    let my_u32: u32 = my_u64.try_into().unwrap();
    let my_u16: u16 = my_u32.try_into().unwrap();
    let my_u8: u8 = my_u16.try_into().unwrap();

    let my_large_u16: u16 = 2048;
    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
}
</code></pre>
<p>{{#quiz ../quizzes/ch02-02-data-types.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are prevalent in Cairo code. You’ve already seen one of the most
important functions in the language: the <code>main</code> function, which is the entry
point of many programs. You’ve also seen the <code>fn</code> keyword, which allows you to
declare new functions.</p>
<p>Cairo code uses <em>snake case</em> as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:</p>
<pre><code class="language-cairo">fn another_function() {
    println!("Another function.");
}

#[executable]
fn main() {
    println!("Hello, world!");
    another_function();
}
</code></pre>
<p>We define a function in Cairo by entering <code>fn</code> followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.</p>
<p>We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because <code>another_function</code> is defined in the program, it can be
called from inside the <code>main</code> function. Note that we defined <code>another_function</code>
<em>before</em> the <code>main</code> function in the source code; we could have defined it after
as well. Cairo doesn’t care where you define your functions, only that they’re
defined somewhere in a scope that can be seen by the caller.</p>
<p>Let’s start a new project with Scarb named <em>functions</em> to explore functions
further. Place the <code>another_function</code> example in <em>src/lib.cairo</em> and run it. You
should see the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_15_functions
Hello, world!
Another function.


</code></pre>
<p>The lines execute in the order in which they appear in the <code>main</code> function.
First the <code>Hello, world!</code> message prints, and then <code>another_function</code> is called
and its message is printed.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>We can define functions to have <em>parameters</em>, which are special variables that
are part of a function’s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called <em>arguments</em>, but in casual conversation, people tend to use
the words <em>parameter</em> and <em>argument</em> interchangeably for either the variables
in a function’s definition or the concrete values passed in when you call a
function.</p>
<p>In this version of <code>another_function</code> we add a parameter:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}
</code></pre>
<p>Try running this program; you should get the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_16_single_param
The value of x is: 5


</code></pre>
<p>The declaration of <code>another_function</code> has one parameter named <code>x</code>. The type of
<code>x</code> is specified as <code>felt252</code>. When we pass <code>5</code> in to <code>another_function</code>, the
<code>println!</code> macro puts <code>5</code> where the pair of curly brackets containing <code>x</code> was in the format string.</p>
<p>In function signatures, you <em>must</em> declare the type of each parameter. This is
a deliberate decision in Cairo’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean. The compiler is also able to give
more helpful error messages if it knows what types the function expects.</p>
<p>When defining multiple parameters, separate the parameter declarations with
commas, like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}
</code></pre>
<p>This example creates a function named <code>print_labeled_measurement</code> with two
parameters. The first parameter is named <code>value</code> and is a <code>u128</code>. The second is
named <code>unit_label</code> and is of type <code>ByteArray</code> - Cairo's internal type to represent string literals. The function then prints text containing both the <code>value</code> and the <code>unit_label</code>.</p>
<p>Let’s try running this code. Replace the program currently in your <em>functions</em>
project’s <em>src/lib.cairo</em> file with the preceding example and run it using <code>scarb execute</code>:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_17_multiple_params
The measurement is: 5h


</code></pre>
<p>Because we called the function with <code>5</code> as the value for value and <code>"h"</code> as the value for <code>unit_label</code>, the program output contains those values.</p>
<h3 id="named-parameters"><a class="header" href="#named-parameters">Named Parameters</a></h3>
<p>In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the function calls more readable and self-descriptive.
If you want to use named parameters, you need to specify the name of the parameter and the value you want to pass to it. The syntax is <code>parameter_name: value</code>. If you pass a variable that has the same name as the parameter, you can simply write <code>:parameter_name</code> instead of <code>parameter_name: variable_name</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo">fn foo(x: u8, y: u8) {}

#[executable]
fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}
</code></pre>
<h2 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h2>
<p>Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we’ve covered haven’t included an ending
expression, but you have seen an expression as part of a statement. Because
Cairo is an expression-based language, this is an important distinction to
understand. Other languages don’t have the same distinctions, so let’s look at
what statements and expressions are and how their differences affect the bodies
of functions.</p>
<ul>
<li><strong>Statements</strong> are instructions that perform some action and do not return
a value.</li>
<li><strong>Expressions</strong> evaluate to a resultant value. Let’s look at some examples.</li>
</ul>
<p>We’ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the <code>let</code> keyword is a statement. In Listing 2-1,
<code>let y = 6;</code> is a statement.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let y = 6;
}
</code></pre>
<p><span class="caption">Listing 2-1: A <code>main</code> function declaration containing one statement</span></p>
<p>Function definitions are also statements; the entire preceding example is a statement in itself.</p>
<p>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement
to another variable, as the following code tries to do; you’ll get an error:</p>
<pre><code class="language-cairo  noplayground">#[executable]
fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>When you run this program, the error you’ll get looks like this:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token ')'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>The <code>let y = 6</code> statement does not return a value, so there isn’t anything for
<code>x</code> to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value
<code>6</code>; that is not the case in Cairo.</p>
<p>Expressions evaluate to a value and make up most of the rest of the code that
you’ll write in Cairo. Consider a math operation, such as <code>5 + 6</code>, which is an
expression that evaluates to the value <code>11</code>. Expressions can be part of
statements: in Listing 2-1, the <code>6</code> in the statement <code>let y = 6;</code> is an
expression that evaluates to the value <code>6</code>.</p>
<p>Calling a function is an expression since it always evaluates to a value: the function's explicit return value, if specified, or the 'unit' type <code>()</code> otherwise.</p>
<p>A new scope block created with curly brackets is an expression, for example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
<p>This expression:</p>
<pre><code class="language-cairo  noplayground">    let y = {
        let x = 3;
        x + 1
    };
</code></pre>
<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code>
as part of the <code>let</code> statement. Note that the <code>x + 1</code> line doesn’t have a
semicolon at the end, which is unlike most of the lines you’ve seen so far.
Expressions do not include ending semicolons. If you add a semicolon to the end
of an expression, you turn it into a statement, and it will then not return a
value. Keep this in mind as you explore function return values and expressions
next.</p>
<h2 id="functions-with-return-values"><a class="header" href="#functions-with-return-values">Functions with Return Values</a></h2>
<p>Functions can return values to the code that calls them. We don’t name return
values, but we must declare their type after an arrow (<code>-&gt;</code>). In Cairo, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the <code>return</code> keyword and specifying a value, but most
functions return the last expression implicitly. Here’s an example of a
function that returns a value:</p>
<pre><code class="language-cairo">fn five() -&gt; u32 {
    5
}

#[executable]
fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
</code></pre>
<p>There are no function calls, or even <code>let</code> statements in the <code>five</code>
function—just the number <code>5</code> by itself. That’s a perfectly valid function in
Cairo. Note that the function’s return type is specified too, as <code>-&gt; u32</code>. Try
running this code; the output should look like this:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_20_function_return_values
The value of x is: 5


</code></pre>
<p>The <code>5</code> in <code>five</code> is the function’s return value, which is why the return type
is <code>u32</code>. Let’s examine this in more detail. There are two important bits:
first, the line <code>let x = five();</code> shows that we’re using the return value of a
function to initialize a variable. Because the function <code>five</code> returns a <code>5</code>,
that line is the same as the following:</p>
<pre><code class="language-cairo  noplayground">let x = 5;
</code></pre>
<p>Second, the <code>five</code> function has no parameters and defines the type of the
return value, but the body of the function is a lonely <code>5</code> with no semicolon
because it’s an expression whose value we want to return.
Let’s look at another example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1
}
</code></pre>
<p>Running this code will print <code>x = 6</code>. But if we place a
semicolon at the end of the line containing <code>x + 1</code>, changing it from an
expression to a statement, we’ll get an error:</p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1;
}
</code></pre>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --&gt; listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:10:24
fn plus_one(x: u32) -&gt; u32 {
                       ^^^

error: could not compile `no_listing_22_function_return_invalid` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>The main error message, <code>Unexpected return type</code>, reveals the core issue with this
code. The definition of the function <code>plus_one</code> says that it will return an
<code>u32</code>, but statements don’t evaluate to a value, which is expressed by <code>()</code>,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error.</p>
<h3 id="const-functions"><a class="header" href="#const-functions">Const Functions</a></h3>
<p>Functions that can be evaluated at compile time can be marked as <code>const</code> using the <code>const fn</code> syntax. This allows the function to be called from a constant context and interpreted by the compiler at compile time.</p>
<p>Declaring a function as <code>const</code> restricts the types that arguments and the return type may use, and limits the function body to constant expressions.</p>
<p>Several functions in the core library are marked as <code>const</code>. Here's an example from the core library showing the <code>pow</code> function implemented as a <code>const fn</code>:</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

const BYTE_MASK: u16 = 2_u16.pow(8) - 1;

#[executable]
fn main() {
    let my_value = 12345;
    let first_byte = my_value &amp; BYTE_MASK;
    println!("first_byte: {}", first_byte);
}
</code></pre>
<p>In this example, <code>pow</code> is a <code>const</code> function, allowing it to be used in a constant expression to define <code>mask</code> at compile time. Here's a snippet of how <code>pow</code> is defined in the core library using <code>const fn</code>:</p>
<p>Note that declaring a function as <code>const</code> has no effect on existing uses; it only imposes restrictions for constant contexts.</p>
<p>{{#quiz ../quizzes/ch02-03-functions.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave comments in their source code that the compiler will ignore but people reading the source code may find useful.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-cairo noplayground">// hello, world
</code></pre>
<p>In Cairo, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you’ll need to include <code>//</code> on each line, like this:</p>
<pre><code class="language-cairo noplayground">// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    1 + 4 // return the sum of 1 and 4
}
</code></pre>
<p>But you’ll more often see them used in this format, with the comment on a separate line above the code it’s annotating:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    // this function performs a simple addition
    1 + 4
}
</code></pre>
<h2 id="item-level-documentation"><a class="header" href="#item-level-documentation">Item-level Documentation</a></h2>
<p>Item-level documentation comments refer to specific items such as functions, implementations, traits, etc. They are prefixed with three slashes (<code>///</code>). These comments provide a detailed description of the item, examples of usage, and any conditions that might cause a panic. In case of functions, the comments may also include separate sections for parameter and return value descriptions.</p>
<pre><code class="language-cairo noplayground">/// Returns the sum of `arg1` and `arg2`.
/// `arg1` cannot be zero.
///
/// # Panics
///
/// This function will panic if `arg1` is `0`.
///
/// # Examples
///
/// ```
/// let a: felt252 = 2;
/// let b: felt252 = 3;
/// let c: felt252 = add(a, b);
/// assert!(c == a + b, "Should equal a + b");
/// ```
fn add(arg1: felt252, arg2: felt252) -&gt; felt252 {
    assert!(arg1 != 0, "Cannot be zero");
    arg1 + arg2
}
</code></pre>
<h2 id="module-documentation"><a class="header" href="#module-documentation">Module Documentation</a></h2>
<p>Module documentation comments provide an overview of the entire module, including its purpose and examples of use. These comments are meant to be placed above the module they're describing and are prefixed with <code>//!</code>. This type of documentation gives a broad understanding of what the module does and how it can be used.</p>
<pre><code class="language-cairo noplayground">//! # my_module and implementation
//!
//! This is an example description of my_module and some of its features.
//!
//! # Examples
//!
//! ```
//! mod my_other_module {
//!   use path::to::my_module;
//!
//!   fn foo() {
//!     my_module.bar();
//!   }
//! }
//! ```
mod my_module { // rest of implementation...
}
</code></pre>
<p>{{#quiz ../quizzes/ch02-04-comments.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops.</p>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> Expressions</a></h2>
<p>An if expression allows you to branch your code depending on conditions. You provide a condition and then state, “If this condition is met, run this block of code. If the condition is not met, do not run this block of code.”</p>
<p>Create a new project called <em>branches</em> in your <em>cairo_projects</em> directory to explore the <code>if</code> expression. In the <em>src/lib.cairo</em> file, input the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}
</code></pre>
<p>All <code>if</code> expressions start with the keyword <code>if</code>, followed by a condition. In this case, the condition checks whether or not the variable <code>number</code> has a value equal to 5. We place the block of code to execute if the condition is <code>true</code> immediately after the condition inside curly brackets.</p>
<p>Optionally, we can also include an <code>else</code> expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to <code>false</code>. If you don’t provide an <code>else</code> expression and the condition is <code>false</code>, the program will just skip the <code>if</code> block and move on to the next bit of code.</p>
<p>Try running this code; you should see the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_24_if
condition was false and number = 3


</code></pre>
<p>Let’s try changing the value of <code>number</code> to a value that makes the condition <code>true</code> to see what happens:</p>
<pre><code class="language-cairo  noplayground">    let number = 5;
</code></pre>
<pre><code class="language-shell">$ scarb execute
condition was true and number = 5
Run completed successfully, returning []
</code></pre>
<p>It’s also worth noting that the condition in this code must be a <code>bool</code>. If the condition isn’t a <code>bool</code>, we’ll get an error. For example, try running the following code:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
</code></pre>
<p>The <code>if</code> condition evaluates to a value of 3 this time, and Cairo throws an error:</p>
<pre><code class="language-shell">$ scarb build
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --&gt; listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:5:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to previous error

</code></pre>
<p>The error indicates that Cairo inferred the type of <code>number</code> to be a <code>bool</code>
based on its later use as a condition of the <code>if</code> statement. It tries to create
a <code>bool</code> from the value <code>3</code>, but Cairo doesn't support instantiating a <code>bool</code>
from a numeric literal anyway - you can only use <code>true</code> or <code>false</code> to create a
<code>bool</code>. Unlike languages such as Ruby and JavaScript, Cairo will not
automatically try to convert non-Boolean types to a Boolean. If we want the <code>if</code>
code block to run only when a number is not equal to 0, for example, we can
change the if expression to the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

</code></pre>
<p>Running this code will print <code>number was something other than zero</code>.</p>
<h2 id="handling-multiple-conditions-with-else-if"><a class="header" href="#handling-multiple-conditions-with-else-if">Handling Multiple Conditions with <code>else if</code></a></h2>
<p>You can use multiple conditions by combining <code>if</code> and <code>else</code> in an <code>else if</code> expression. For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}
</code></pre>
<p>This program has four possible paths it can take. After running it, you should see the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_25_else_if
number is 3


</code></pre>
<p>When this program executes, it checks each <code>if</code> expression in turn and executes the first body for which the condition evaluates to <code>true</code>. Note that even though <code>number - 2 == 1</code> is <code>true</code>, we don’t see the output <code>number minus 2 is 1</code> nor do we see the <code>number not found</code> text from the <code>else</code> block. That’s because Cairo only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest. Using too many <code>else if</code> expressions can clutter your code, so if you have more than one, you might want to refactor your code. <a href="./ch06-02-the-match-control-flow-construct.html">Chapter 6</a> describes a powerful Cairo branching construct called <code>match</code> for these cases.</p>
<h2 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> Statement</a></h2>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code> statement to assign the outcome to a variable.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}
</code></pre>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_26_if_let
condition was true and number is 5


</code></pre>
<p>The <code>number</code> variable will be bound to a value based on the outcome of the <code>if</code> expression, which will be 5 here.</p>
<h2 id="repetition-with-loops"><a class="header" href="#repetition-with-loops">Repetition with Loops</a></h2>
<p>It’s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, let’s create a new project called <em>loops</em>.</p>
<p>Cairo has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Let’s try each one.</p>
<h3 id="repeating-code-with-loop"><a class="header" href="#repeating-code-with-loop">Repeating Code with <code>loop</code></a></h3>
<p>The <code>loop</code> keyword tells Cairo to execute a block of code over and over again forever or until you explicitly tell it to stop.</p>
<p>As an example, change the <em>src/lib.cairo</em> file in your <em>loops</em> directory to look like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously until either the program runs out of gas or we stop the program manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try:</p>
<pre><code class="language-shell">$ scarb execute --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed ctrl-c. You may or may not see the word <code>again!</code> printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.</p>
<blockquote>
<p>Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the <code>--available-gas</code> flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In the previous case, we set the gas limit high enough for the program to run for quite some time.</p>
</blockquote>
<blockquote>
<p>It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network.
If you're writing a program that needs to run a loop, you will need to execute it with the <code>--available-gas</code> flag set to a value that is large enough to run the program.</p>
</blockquote>
<p>Now, try running the same program again, but this time with the <code>--available-gas</code> flag set to <code>200000</code> instead of <code>2000000000000</code>. You will see the program only prints <code>again!</code> 3 times before it stops, as it ran out of gas to keep executing the loop.</p>
<p>Fortunately, Cairo also provides a way to break out of a loop using code. You can place the <code>break</code> keyword within the loop to tell the program when to stop executing the loop.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p>The <code>continue</code> keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration.
Let's add a <code>continue</code> statement to our loop to skip the <code>println!</code> statement when <code>i</code> is equal to <code>5</code>.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p>Executing this program will not print the value of <code>i</code> when it is equal to <code>5</code>.</p>
<h3 id="returning-values-from-loops"><a class="header" href="#returning-values-from-loops">Returning Values from Loops</a></h3>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such
as checking whether an operation has succeeded. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the <code>break</code> expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}
</code></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to
<code>0</code>. Then we declare a variable named <code>result</code> to hold the value returned from
the loop. On every iteration of the loop, we check whether the <code>counter</code> is equal to <code>10</code>, and then add <code>1</code> to the <code>counter</code> variable.
When the condition is met, we use the <code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a
semicolon to end the statement that assigns the value to <code>result</code>. Finally, we
print the value in <code>result</code>, which in this case is <code>20</code>.</p>
<h3 id="conditional-loops-with-while"><a class="header" href="#conditional-loops-with-while">Conditional Loops with <code>while</code></a></h3>
<p>A program will often need to evaluate a condition within a loop.
While the condition is <code>true</code>, the loop runs.
When the condition ceases to be <code>true</code>, the program calls <code>break</code>, stopping the loop.
It’s possible to implement behavior like this using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could try that now in a program, if you’d like.
However, this pattern is so common that Cairo has a built-in language construct for it, called a <code>while</code> loop.</p>
<p>In Listing 2-2, we use <code>while</code> to loop the program three times, counting down each time after printing the value of <code>number</code>, and then, after the loop, print a message and exit.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
<p><span class="caption">Listing 2-2: Using a <code>while</code> loop to run code while a condition holds <code>true</code>.</span></p>
<p>This construct eliminates a lot of nesting that would be necessary if you used <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>, and it’s clearer.
While a condition evaluates to <code>true</code>, the code runs; otherwise, it exits the loop.</p>
<h3 id="looping-through-a-collection-with-for"><a class="header" href="#looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h3>
<p>You can also use the while construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 2-3 prints each element in the array <code>a</code>.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
</code></pre>
<p><span class="caption">Listing 2-3: Looping through each element of a collection using a <code>while</code> loop</span></p>
<p>Here, the code counts up through the elements in the array. It starts at index <code>0</code>, and then loops until it reaches the final index in the array (that is, when <code>index &lt; 5</code> is no longer <code>true</code>). Running this code will print every element in the array:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50


</code></pre>
<p>All five array values appear in the terminal, as expected. Even though <code>index</code> will reach a value of <code>5</code> at some point, the loop stops executing before trying to fetch a sixth value from the array.</p>
<p>However, this approach is error prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the <code>a</code> array to have four elements but forgot to update the condition to <code>while index &lt; 4</code>, the code would panic. It’s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.</p>
<p>As a more concise alternative, you can use a <code>for</code> loop and execute some code for each item in a collection. A <code>for</code> loop looks like the code in Listing 2-4.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}
</code></pre>
<p><span class="caption">Listing 2-4: Looping through each element of a collection using a <code>for</code> loop</span></p>
<p>When we run this code, we’ll see the same output as in Listing 2-3. More importantly, we’ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</p>
<p>Using the <code>for</code> loop, you wouldn’t need to remember to change any other code if you changed the number of values in the array, as you would with the method used in Listing 2-3.</p>
<p>The safety and conciseness of <code>for</code> loops make them the most commonly used loop construct in Cairo. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop in Listing 2-2. Another way to run code a certain number of times would be to use a <code>Range</code>, provided by the core library, which generates all numbers in sequence starting from one number and ending before another number.</p>
<p>Here’s how you can use a <code>Range</code> to count from 1 to 3:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    }
    println!("Go!!!");
}
</code></pre>
<p>This code is a bit nicer, isn’t it?</p>
<h2 id="equivalence-between-loops-and-recursive-functions"><a class="header" href="#equivalence-between-loops-and-recursive-functions">Equivalence Between Loops and Recursive Functions</a></h2>
<p>Loops and recursive functions are two common ways to repeat a block of code multiple times. The <code>loop</code> keyword is used to create an infinite loop that can be broken by using the <code>break</code> keyword.</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    }
    x
}
</code></pre>
<p>Loops can be transformed into recursive functions by calling the function within itself. Here is an example of a recursive function that mimics the behavior of the <code>loop</code> example above.</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -&gt; felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}
</code></pre>
<p>In both cases, the code block will run indefinitely until the condition <code>x == 2</code> is met, at which point the value of x will be displayed.</p>
<p>In Cairo, loops and recursions are not only conceptually equivalent: they are also compiled down to similar low-level representations. To understand this, we can compile both examples to Sierra, and analyze the Sierra Code generated by the Cairo compiler for both examples. Add the following in your <code>Scarb.toml</code> file:</p>
<pre><code class="language-toml">[lib]
sierra-text = true
</code></pre>
<p>Then, run <code>scarb build</code> to compile both examples. You will find that the Sierra code generated for both examples is extremely similar, as the loop is compiled to a recursive function in the Sierra statements.</p>
<blockquote>
<p>Note: For our example, our findings came from understanding the <strong>statements</strong> section in Sierra that shows the execution traces of the two programs. If you are curious to learn more about Sierra, check out <a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">Exploring Sierra</a>.</p>
</blockquote>
<p>{{#quiz ../quizzes/ch02-05-control-flow.toml}}</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>You made it! This was a sizable chapter: you learned about variables, data types, functions, comments,
<code>if</code> expressions and loops! To practice with the concepts discussed in this chapter,
try building programs to do the following:</p>
<ul>
<li>Generate the <em>n</em>-th Fibonacci number.</li>
<li>Compute the factorial of a number <em>n</em>.</li>
</ul>
<p>Now, we’ll review the common collection types in Cairo in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Cairo provides a set of common collection types that can be used to store and manipulate data. These collections are designed to be efficient, flexible, and easy to use. This section introduces the primary collection types available in Cairo: Arrays and Dictionaries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>An array is a collection of elements of the same type. You can create and use array methods by using the <code>ArrayTrait</code> trait from the core library.</p>
<p>An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified.
This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front.</p>
<h2 id="creating-an-array"><a class="header" href="#creating-an-array">Creating an Array</a></h2>
<p>Creating an array is done with the <code>ArrayTrait::new()</code> call. Here's an example of creating an array and appending 3 elements to it:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}
</code></pre>
<p>When required, you can pass the expected type of items inside the array when instantiating the array like this, or explicitly define the type of the variable.</p>
<pre><code class="language-cairo  noplayground">let mut arr = ArrayTrait::&lt;u128&gt;::new();
</code></pre>
<pre><code class="language-cairo  noplayground">let mut arr:Array&lt;u128&gt; = ArrayTrait::new();
</code></pre>
<h2 id="updating-an-array"><a class="header" href="#updating-an-array">Updating an Array</a></h2>
<h3 id="adding-elements"><a class="header" href="#adding-elements">Adding Elements</a></h3>
<p>To add an element to the end of an array, you can use the <code>append()</code> method:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut a = ArrayTrait::new();
</span><span class="boring">    a.append(0);
</span>    a.append(1);
<span class="boring">    a.append(2);
</span><span class="boring">}
</span></code></pre>
<h3 id="removing-elements"><a class="header" href="#removing-elements">Removing Elements</a></h3>
<p>You can only remove elements from the front of an array by using the <code>pop_front()</code> method.
This method returns an <code>Option</code> that can be unwrapped, containing the removed element, or <code>None</code> if the array is empty.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}
</code></pre>
<p>The above code will print <code>The first value is 10</code> as we remove the first element that was added.</p>
<p>In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once they've been added. You can only add elements to the end of an array and remove elements from the front of an array. These operations do not require memory mutation, as they involve updating pointers rather than directly modifying the memory cells.</p>
<h2 id="reading-elements-from-an-array"><a class="header" href="#reading-elements-from-an-array">Reading Elements from an Array</a></h2>
<p>To access array elements, you can use <code>get()</code> or <code>at()</code> array methods that return different types. Using <code>arr.at(index)</code> is equivalent to using the subscripting operator <code>arr[index]</code>.</p>
<h3 id="get-method"><a class="header" href="#get-method"><code>get()</code> Method</a></h3>
<p>The <code>get</code> function returns an <code>Option&lt;Box&lt;@T&gt;&gt;</code>, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, <code>get</code> returns <code>None</code>. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the <a href="./ch04-02-references-and-snapshots.html#snapshots">"References and Snapshots"</a> chapter.</p>
<p>Here is an example with the <code>get()</code> method:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; u128 {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Some(x) =&gt; {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        None =&gt; { panic!("out of bounds") },
    }
}
</code></pre>
<h3 id="at-method"><a class="header" href="#at-method"><code>at()</code> Method</a></h3>
<p>The <code>at</code> function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the <code>unbox()</code> operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use <code>at</code> when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}
</code></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>0</code> because that
is the value at index <code>0</code> in the array. The variable named <code>second</code> will get
the value <code>1</code> from index <code>1</code> in the array.</p>
<p>In summary, use <code>at</code> when you want to panic on out-of-bounds access attempts, and use <code>get</code> when you prefer to handle such cases gracefully without panicking.</p>
<h2 id="size-related-methods"><a class="header" href="#size-related-methods">Size-related Methods</a></h2>
<p>To determine the number of elements in an array, use the <code>len()</code> method. The return value is of type <code>usize</code>.</p>
<p>If you want to check if an array is empty or not, you can use the <code>is_empty()</code> method, which returns <code>true</code> if the array is empty and <code>false</code> otherwise.</p>
<h2 id="array-macro"><a class="header" href="#array-macro"><code>array!</code> Macro</a></h2>
<p>Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing that is redundant. You would first declare the array and then append each value one by one. <code>array!</code> is a simpler way of doing this task by combining the two steps.
At compile-time, the compiler will expand the macro to generate the code that appends the items sequentially.</p>
<p>Without <code>array!</code>:</p>
<pre><code class="language-cairo">    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);
</code></pre>
<p>With <code>array!</code>:</p>
<pre><code class="language-cairo">    let arr = array![1, 2, 3, 4, 5];
</code></pre>
<h2 id="storing-multiple-types-with-enums"><a class="header" href="#storing-multiple-types-with-enums">Storing Multiple Types with Enums</a></h2>
<p>If you want to store elements of different types in an array, you can use an <code>Enum</code> to define a custom data type that can hold multiple types. Enums will be explained in more detail in the <a href="./ch06-00-enums-and-pattern-matching.html">"Enums and Pattern Matching"</a> chapter.</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

#[executable]
fn main() {
    let mut messages: Array&lt;Data&gt; = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}
</code></pre>
<h2 id="span"><a class="header" href="#span">Span</a></h2>
<p><code>Span</code> is a struct that represents a snapshot of an <code>Array</code>. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in <a href="./ch04-02-references-and-snapshots.html">"References and Snapshots"</a>.</p>
<p>All methods provided by <code>Array</code> can also be used with <code>Span</code>, except for the <code>append()</code> method.</p>
<h3 id="turning-an-array-into-span"><a class="header" href="#turning-an-array-into-span">Turning an Array into Span</a></h3>
<p>To create a <code>Span</code> of an <code>Array</code>, call the <code>span()</code> method:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let mut array: Array&lt;u8&gt; = ArrayTrait::new();
<span class="boring">    array.span();
</span><span class="boring">}
</span></code></pre>
<p>{{#quiz ../quizzes/ch03-01-arrays.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dictionaries"><a class="header" href="#dictionaries">Dictionaries</a></h1>
<p>Cairo provides in its core library a dictionary-like type. The <code>Felt252Dict&lt;T&gt;</code> data type represents a collection of key-value pairs where each key is unique and associated with a corresponding value. This type of data structure is known differently across different programming languages such as maps, hash tables, associative arrays and many others.</p>
<p>The <code>Felt252Dict&lt;T&gt;</code> type is useful when you want to organize your data in a certain way for which using an <code>Array&lt;T&gt;</code> and indexing doesn't suffice. Cairo dictionaries also allow the programmer to easily simulate the existence of mutable memory when there is none.</p>
<h2 id="basic-use-of-dictionaries"><a class="header" href="#basic-use-of-dictionaries">Basic Use of Dictionaries</a></h2>
<p>It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to <code>felt252</code>, leaving only the possibility to specify the value data type, represented by <code>T</code> in <code>Felt252Dict&lt;T&gt;</code>.</p>
<p>The core functionality of a <code>Felt252Dict&lt;T&gt;</code> is implemented in the trait <code>Felt252DictTrait</code> which includes all basic operations. Among them we can find:</p>
<ol>
<li><code>insert(felt252, T) -&gt; ()</code> to write values to a dictionary instance and</li>
<li><code>get(felt252) -&gt; T</code> to read values from it.</li>
</ol>
<p>These functions allow us to manipulate dictionaries like in any other language. In the following example, we create a dictionary to represent a mapping between individuals and their balance:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}
</code></pre>
<p>We can create a new instance of <code>Felt252Dict&lt;u64&gt;</code> by using the <code>default</code> method of the <code>Default</code> trait and add two individuals, each one with their own balance, using the <code>insert</code> method. Finally, we check the balance of our users with the <code>get</code> method. These methods are defined in the <code>Felt252DictTrait</code> trait in the core library.</p>
<p>Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the <code>Felt252Dict&lt;T&gt;</code> type represents a way to overcome this obstacle. We will explain how this is implemented later on in <a href="./ch03-02-dictionaries.html#dictionaries-underneath">"Dictionaries Underneath"</a>.</p>
<p>Building upon our previous example, let us show a code example where the balance of the same user changes:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}
</code></pre>
<p>Notice how in this example we added the 'Alex' individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! <code>Felt252Dict&lt;T&gt;</code> effectively allows us to "rewrite" the stored value for any given key.</p>
<p>Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you instantiate a <code>Felt252Dict&lt;T&gt;</code>, behind the scenes all keys have their associated values initialized as zero. This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an error or an undefined value. This also means there is no way to delete data from a dictionary. Something to take into account when incorporating this structure into your code.</p>
<p>Until this point, we have seen all the basic features of <code>Felt252Dict&lt;T&gt;</code> and how it mimics the same behavior as the corresponding data structures in any other language, that is, externally of course. Cairo is at its core a non-deterministic Turing-complete programming language, very different from any other popular language in existence, which as a consequence means that dictionaries are implemented very differently as well!</p>
<p>In the following sections, we are going to give some insights about <code>Felt252Dict&lt;T&gt;</code> inner mechanisms and the compromises that were taken to make them work. After that, we are going to take a look at how to use dictionaries with other data structures as well as use the <code>entry</code> method as another way to interact with them.</p>
<h2 id="dictionaries-underneath"><a class="header" href="#dictionaries-underneath">Dictionaries Underneath</a></h2>
<p>One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order to simulate mutability, the language implements <code>Felt252Dict&lt;T&gt;</code> as a list of entries. Each of the entries represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three fields:</p>
<ol>
<li>A <code>key</code> field that identifies the key for this key-value pair of the dictionary.</li>
<li>A <code>previous_value</code> field that indicates which previous value was held at <code>key</code>.</li>
<li>A <code>new_value</code> field that indicates the new value that is held at <code>key</code>.</li>
</ol>
<p>If we try implementing <code>Felt252Dict&lt;T&gt;</code> using high-level structures we would internally define it as <code>Array&lt;Entry&lt;T&gt;&gt;</code> where each <code>Entry&lt;T&gt;</code> has information about what key-value pair it represents and the previous and new values it holds. The definition of <code>Entry&lt;T&gt;</code> would be:</p>
<pre><code class="language-cairo noplayground">struct Entry&lt;T&gt; {
    key: felt252,
    previous_value: T,
    new_value: T,
}
</code></pre>
<p>For each time we interact with a <code>Felt252Dict&lt;T&gt;</code>, a new <code>Entry&lt;T&gt;</code> will be registered:</p>
<ul>
<li>A <code>get</code> would register an entry where there is no change in state, and previous and new values are stored with the same value.</li>
<li>An <code>insert</code> would register a new <code>Entry&lt;T&gt;</code> where the <code>new_value</code> would be the element being inserted, and the <code>previous_value</code> the last element inserted before this. In case it is the first entry for a certain key, then the previous value will be zero.</li>
</ul>
<p>The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per <code>Felt252Dict&lt;T&gt;</code> interaction. Let's show an example of this using the <code>balances</code> dictionary from the previous section and inserting the users 'Alex' and 'Maria':</p>
<pre><code class="language-cairo"><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">
</span><span class="boring">struct Entry&lt;T&gt; {
</span><span class="boring">    key: felt252,
</span><span class="boring">    previous_value: T,
</span><span class="boring">    new_value: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();
</span>    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
<span class="boring">}
</span></code></pre>
<p>These instructions would then produce the following list of entries:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>50</td></tr>
<tr><td style="text-align: center">Alex</td><td>100</td><td>200</td></tr>
<tr><td style="text-align: center">Maria</td><td>50</td><td>50</td></tr>
</tbody></table>
</div>
<p>Notice that since 'Alex' was inserted twice, it appears twice and the <code>previous</code> and <code>current</code> values are set properly. Also reading from 'Maria' registered an entry with no change from previous to current values.</p>
<p>This approach to implementing <code>Felt252Dict&lt;T&gt;</code> means that for each read/write operation, there is a scan for the whole entry list in search of the last entry with the same <code>key</code>. Once the entry has been found, its <code>new_value</code> is extracted and used on the new entry to be added as the <code>previous_value</code>. This means that interacting with <code>Felt252Dict&lt;T&gt;</code> has a worst-case time complexity of <code>O(n)</code> where <code>n</code> is the number of entries in the list.</p>
<p>If you pour some thought into alternate ways of implementing <code>Felt252Dict&lt;T&gt;</code> you'd surely find them, probably even ditching completely the need for a <code>previous_value</code> field, nonetheless, since Cairo is not your normal language this won't work.
One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and inside the boundaries of Cairo restrictions. One of those boundary checks consists of "dictionary squashing" and that requires information on both previous and new values for every entry.</p>
<h2 id="squashing-dictionaries"><a class="header" href="#squashing-dictionaries">Squashing Dictionaries</a></h2>
<p>To verify that the proof generated by a Cairo program execution that used a <code>Felt252Dict&lt;T&gt;</code> is correct, we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called <code>squash_dict</code> that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution.</p>
<p>The process of squashing is as follows: given all entries with certain key <code>k</code>, taken in the same order as they were inserted, verify that the ith entry <code>new_value</code> is equal to the ith + 1 entry <code>previous_value</code>.</p>
<p>For example, given the following entry list:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>150</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
<tr><td style="text-align: center">Maria</td><td>100</td><td>250</td></tr>
<tr><td style="text-align: center">Alex</td><td>150</td><td>40</td></tr>
<tr><td style="text-align: center">Alex</td><td>40</td><td>300</td></tr>
<tr><td style="text-align: center">Maria</td><td>250</td><td>190</td></tr>
<tr><td style="text-align: center">Alex</td><td>300</td><td>90</td></tr>
</tbody></table>
</div>
<p>After squashing, the entry list would be reduced to:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>90</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>190</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
</tbody></table>
</div>
<p>In case of a change on any of the values of the first table, squashing would have failed during runtime.</p>
<h2 id="dictionary-destruction"><a class="header" href="#dictionary-destruction">Dictionary Destruction</a></h2>
<p>If you run the examples from <a href="./ch03-02-dictionaries.html#basic-use-of-dictionaries">"Basic Use of Dictionaries"</a> section, you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the <code>Felt252Dict&lt;T&gt;</code> implementation of the <code>Destruct&lt;T&gt;</code> trait. This call occurred just before the <code>balance</code> dictionary went out of scope.</p>
<p>The <code>Destruct&lt;T&gt;</code> trait represents another way of removing instances out of scope apart from <code>Drop&lt;T&gt;</code>. The main difference between these two is that <code>Drop&lt;T&gt;</code> is treated as a no-op operation, meaning it does not generate new CASM while <code>Destruct&lt;T&gt;</code> does not have this restriction. The only type which actively uses the <code>Destruct&lt;T&gt;</code> trait is <code>Felt252Dict&lt;T&gt;</code>, for every other type <code>Destruct&lt;T&gt;</code> and <code>Drop&lt;T&gt;</code> are synonyms. You can read more about these traits in <a href="./appendix-03-derivable-traits.html#drop-and-destruct">Drop and Destruct</a> section of Appendix C.</p>
<p>Later in <a href="./ch12-01-custom-data-structures.html#dictionaries-as-struct-members">"Dictionaries as Struct Members"</a> section, we will have a hands-on example where we implement the <code>Destruct&lt;T&gt;</code> trait for a custom type.</p>
<h2 id="more-dictionaries"><a class="header" href="#more-dictionaries">More Dictionaries</a></h2>
<p>Up to this point, we have given a comprehensive overview of the functionality of <code>Felt252Dict&lt;T&gt;</code> as well as how and why it is implemented in a certain way. If you haven't understood all of it, don't worry because in this section we will have some more examples using dictionaries.</p>
<p>We will start by explaining the <code>entry</code> method which is part of a dictionary basic functionality included in <code>Felt252DictTrait&lt;T&gt;</code> which we didn't mention at the beginning. Soon after, we will see examples of how to use <code>Felt252Dict&lt;T&gt;</code> with other <a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">complex types</a> such as <code>Array&lt;T&gt;</code>.</p>
<h2 id="entry-and-finalize"><a class="header" href="#entry-and-finalize">Entry and Finalize</a></h2>
<p>In the <a href="./ch03-02-dictionaries.html#dictionaries-underneath">"Dictionaries Underneath"</a> section, we explained how <code>Felt252Dict&lt;T&gt;</code> internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain <code>key</code> and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the <code>entry</code> and <code>finalize</code> methods.</p>
<p>The <code>entry</code> method comes as part of <code>Felt252DictTrait&lt;T&gt;</code> with the purpose of creating a new entry given a certain key. Once called, this method takes ownership of the dictionary and returns the entry to update. The method signature is as follows:</p>
<pre><code class="language-cairo noplayground">fn entry(self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; (Felt252DictEntry&lt;T&gt;, T) nopanic
</code></pre>
<p>The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a <code>Felt252DictEntry&lt;T&gt;</code>, which is the type used by Cairo to represent dictionary entries, and a <code>T</code> representing the value held previously.
The <code>nopanic</code> notation simply indicates that the function is guaranteed to never panic.</p>
<p>The next thing to do is to update the entry with the new value. For this, we use the <code>finalize</code> method which inserts the entry and returns ownership of the dictionary:</p>
<pre><code class="language-cairo noplayground">fn finalize(self: Felt252DictEntry&lt;T&gt;, new_value: T) -&gt; Felt252Dict&lt;T&gt;
</code></pre>
<p>This method receives the entry and the new value as parameters, and returns the updated dictionary.</p>
<p>Let us see an example using <code>entry</code> and <code>finalize</code>. Imagine we would like to implement our own version of the <code>get</code> method from a dictionary. We should then do the following:</p>
<ol>
<li>Create the new entry to add using the <code>entry</code> method.</li>
<li>Insert back the entry where the <code>new_value</code> equals the <code>previous_value</code>.</li>
<li>Return the value.</li>
</ol>
<p>Implementing our custom get would look like this:</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get&lt;T, +Felt252DictValue&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252,
) -&gt; T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}
</code></pre>
<p>The <code>ref</code> keyword means that the ownership of the variable will be given back at the end of
the function. This concept will be explained in more detail in the <a href="./ch04-02-references-and-snapshots.html">"References and Snapshots"</a> section.</p>
<p>Implementing the <code>insert</code> method would follow a similar workflow, except for inserting a new value when finalizing. If we were to implement it, it would look like the following:</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert&lt;T, +Felt252DictValue&lt;T&gt;, +Destruct&lt;T&gt;, +Drop&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}
</code></pre>
<p>As a finalizing note, these two methods are implemented in a similar way to how <code>insert</code> and <code>get</code> are implemented for <code>Felt252Dict&lt;T&gt;</code>. This code shows some example usage:</p>
<pre><code class="language-cairo"><span class="boring">use core::dict::{Felt252Dict, Felt252DictEntryTrait};
</span><span class="boring">
</span><span class="boring">fn custom_get&lt;T, +Felt252DictValue&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(
</span><span class="boring">    ref dict: Felt252Dict&lt;T&gt;, key: felt252,
</span><span class="boring">) -&gt; T {
</span><span class="boring">    // Get the new entry and the previous value held at `key`
</span><span class="boring">    let (entry, prev_value) = dict.entry(key);
</span><span class="boring">
</span><span class="boring">    // Store the value to return
</span><span class="boring">    let return_value = prev_value;
</span><span class="boring">
</span><span class="boring">    // Update the entry with `prev_value` and get back ownership of the dictionary
</span><span class="boring">    dict = entry.finalize(prev_value);
</span><span class="boring">
</span><span class="boring">    // Return the read value
</span><span class="boring">    return_value
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn custom_insert&lt;T, +Felt252DictValue&lt;T&gt;, +Destruct&lt;T&gt;, +Drop&lt;T&gt;&gt;(
</span><span class="boring">    ref dict: Felt252Dict&lt;T&gt;, key: felt252, value: T,
</span><span class="boring">) {
</span><span class="boring">    // Get the last entry associated with `key`
</span><span class="boring">    // Notice that if `key` does not exist, `_prev_value` will
</span><span class="boring">    // be the default value of T.
</span><span class="boring">    let (entry, _prev_value) = dict.entry(key);
</span><span class="boring">
</span><span class="boring">    // Insert `entry` back in the dictionary with the updated value,
</span><span class="boring">    // and receive ownership of the dictionary
</span><span class="boring">    dict = entry.finalize(value);
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let mut dict: Felt252Dict&lt;u64&gt; = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="dictionaries-of-types-not-supported-natively"><a class="header" href="#dictionaries-of-types-not-supported-natively">Dictionaries of Types not Supported Natively</a></h2>
<p>One restriction of <code>Felt252Dict&lt;T&gt;</code> that we haven't talked about is the trait <code>Felt252DictValue&lt;T&gt;</code>.
This trait defines the <code>zero_default</code> method which is the one that gets called when a value does not exist in the dictionary.
This is implemented by some common data types, such as most unsigned integers, <code>bool</code> and <code>felt252</code> - but it is not implemented for more complex types such as arrays, structs (including <code>u256</code>), and other types from the core library.
This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make the data type a valid dictionary value type.
To compensate this, you can wrap your type inside a <code>Nullable&lt;T&gt;</code>.</p>
<p><code>Nullable&lt;T&gt;</code> is a smart pointer type that can either point to a value or be <code>null</code> in the absence of value. It is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with <code>Option</code> is that the wrapped value is stored inside a <code>Box&lt;T&gt;</code> data type. The <code>Box&lt;T&gt;</code> type is a smart pointer that allows us to use a dedicated <code>boxed_segment</code> memory segment for our data, and access this segment using a pointer that can only be manipulated in one place at a time. See <a href="./ch12-02-smart-pointers.html">Smart Pointers Chapter</a> for more information.</p>
<p>Let's show using an example. We will try to store a <code>Span&lt;felt252&gt;</code> inside a dictionary. For that, we will use <code>Nullable&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>. Also, we are storing a <code>Span&lt;T&gt;</code> and not an <code>Array&lt;T&gt;</code> because the latter does not implement the <code>Copy&lt;T&gt;</code> trait which is required for reading from a dictionary.</p>
<pre><code class="language-cairo noplayground">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};

#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...
</code></pre>
<p>In this code snippet, the first thing we did was to create a new dictionary <code>d</code>. We want it to hold a <code>Nullable&lt;Span&gt;</code>. After that, we created an array and filled it with values.</p>
<p>The last step is inserting the array as a span inside the dictionary. Notice that we do this using the <code>new</code> function of the <code>NullableTrait</code>.</p>
<p>Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. The following code shows how to achieve that:</p>
<pre><code class="language-cairo noplayground">//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}
</code></pre>
<p>Here we:</p>
<ol>
<li>Read the value using <code>get</code>.</li>
<li>Verified it is non-null using the <code>match_nullable</code> function.</li>
<li>Unwrapped the value inside the box and asserted it was correct.</li>
</ol>
<p>The complete script would look like this:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};

#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

</code></pre>
<h2 id="using-arrays-inside-dictionaries"><a class="header" href="#using-arrays-inside-dictionaries">Using Arrays inside Dictionaries</a></h2>
<p>In the previous section, we explored how to store and retrieve complex types inside a dictionary using <code>Nullable&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>. Now, let's take a look at how to store an array inside a dictionary and dynamically modify its contents.</p>
<p>Storing arrays in dictionaries in Cairo is slightly different from storing other types. This is because arrays are more complex data structures that require special handling to avoid issues with memory copying and references.</p>
<p>First, let's look at how to create a dictionary and insert an array into it. This process is pretty straightforward and follows a similar pattern to inserting other types of data:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}
</code></pre>
<p>However, attempting to read an array from the dictionary using the <code>get</code> method will result in a compiler error. This is because <code>get</code> tries to copy the array in memory, which is not possible for arrays (as we've already mentioned in the <a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">previous section</a>, <code>Array&lt;T&gt;</code> does not implement the <code>Copy&lt;T&gt;</code> trait):</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, match_nullable};

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value!"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };
    arr.span()
}
</code></pre>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::&lt;core::nullable::Nullable::&lt;core::array::Array::&lt;core::integer::u8&gt;&gt;&gt;.
 --&gt; listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:14:20
    let val = dict.get(0); // This will cause a compiler error
                   ^^^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>To correctly read an array from the dictionary, we need to use dictionary entries. This allows us to get a reference to the array value without copying it:</p>
<pre><code class="language-cairo noplayground">fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}
</code></pre>
<blockquote>
<p>Note: We must convert the array to a <code>Span</code> before finalizing the entry, because calling <code>NullableTrait::new(arr)</code> moves the array, thus making it impossible to return it from the function.</p>
</blockquote>
<p>To modify the stored array, such as appending a new value, we can use a similar approach. The following <code>append_value</code> function demonstrates this:</p>
<pre><code class="language-cairo noplayground">fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}
</code></pre>
<p>In the <code>append_value</code> function, we access the dictionary entry, dereference the array, append the new value, and finalize the entry with the updated array.</p>
<blockquote>
<p>Note: Removing an item from a stored array can be implemented in a similar manner.</p>
</blockquote>
<p>Below is the complete example demonstrating the creation, insertion, reading, and modification of an array in a dictionary:</p>
<pre><code class="language-cairo">use core::dict::{Felt252Dict, Felt252DictEntryTrait};
use core::nullable::NullableTrait;

fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}
</code></pre>
<p>{{#quiz ../quizzes/ch03-02-dictionaries.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-cairos-ownership-system"><a class="header" href="#understanding-cairos-ownership-system">Understanding Cairo's Ownership system</a></h1>
<p>Cairo is a language built around a linear type system that allows us to
statically ensure that in every Cairo program, a value is used exactly once.
This linear type system helps prevent runtime errors by ensuring that operations that could cause such errors, such as writing twice to a memory cell, are detected at compile time.
This is achieved by implementing an ownership system
and forbidding copying and dropping values by default. In this chapter, we’ll
talk about Cairo's ownership system as well as references and snapshots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-using-a-linear-type-system"><a class="header" href="#ownership-using-a-linear-type-system">Ownership Using a Linear Type System</a></h1>
<p>Cairo uses a linear type system. In such a type system, any value (a basic type, a struct, an enum) must be used and must only be used once. 'Used' here means that the value is either <em>destroyed</em> or <em>moved</em>.</p>
<p><em>Destruction</em> can happen in several ways:</p>
<ul>
<li>a variable goes out of scope.</li>
<li>a struct is destructured.</li>
<li>explicit destruction using <code>destruct()</code>.</li>
</ul>
<p><em>Moving</em> a value simply means passing that value to another function.</p>
<p>This results in somewhat similar constraints to the Rust ownership model, but there are some differences.
In particular, the Rust ownership model exists (in part) to avoid data races and concurrent mutable access to a memory value. This is obviously impossible in Cairo since the memory is immutable.
Instead, Cairo leverages its linear type system for two main purposes:</p>
<ul>
<li>Ensuring that all code is provable and thus verifiable.</li>
<li>Abstracting away the immutable memory of the Cairo VM.</li>
</ul>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>In Cairo, ownership applies to <em>variables</em> and not to <em>values</em>. A value can safely be referred to by many different variables (even if they are mutable variables), as the value itself is always immutable.
Variables however can be mutable, so the compiler must ensure that constant variables aren't accidentally modified by the programmer.
This makes it possible to talk about ownership of a variable: the owner is the code that can read (and write if mutable) the variable.</p>
<p>This means that variables (not values) follow similar rules to Rust values:</p>
<ul>
<li>Each variable in Cairo has an owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the variable is destroyed.</li>
</ul>
<p>Now that we’re past basic Cairo syntax, we won’t include all the <code>fn main() {</code> code in examples, so if you’re following along, make sure to put the following examples inside a main function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</p>
<h2 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h2>
<p>As a first example of the linear type system, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:</p>
<pre><code class="language-cairo noplayground">let s = 'hello';
</code></pre>
<p>The variable <code>s</code> refers to a short string. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 4-1 shows a
program with comments annotating where the variable <code>s</code> would be valid.</p>
<pre><code class="language-cairo"><span class="boring">//TAG: ignore_fmt
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    { // s is not valid here, it’s not yet declared
        let s = 'hello'; // s is valid from this point forward
        // do stuff with s
    } // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 4-1: A variable and the scope in which it is valid</span></p>
<p>In other words, there are two important points in time here:</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we’ll build on top of this understanding by using the <code>Array</code> type we introduced in the previous <a href="./ch03-01-arrays.html">"Arrays"</a> section.</p>
<h3 id="moving-values"><a class="header" href="#moving-values">Moving values</a></h3>
<p>As said earlier, <em>moving</em> a value simply means passing that value to another function. When that happens, the variable referring to that value in the original scope is destroyed and can no longer be used, and a new variable is created to hold the same value.</p>
<p>Arrays are an example of a complex type that is moved when passing it to another function.
Here is a short reminder of what an array looks like:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span>fn main() {
    let mut arr: Array&lt;u128&gt; = array![];
    arr.append(1);
<span class="boring">    arr.append(2);
</span><span class="boring">}
</span></code></pre>
<p>How does the type system ensure that the Cairo program never tries to write to the same memory cell twice?
Consider the following code, where we try to remove the front of the array twice:</p>
<pre><code class="language-cairo does_not_compile">fn foo(mut arr: Array&lt;u128&gt;) {
    arr.pop_front();
}

#[executable]
fn main() {
    let arr: Array&lt;u128&gt; = array![];
    foo(arr);
    foo(arr);
}
</code></pre>
<p>In this case, we try to pass the same value (the array in the <code>arr</code> variable) to both function calls. This means our code tries to remove the first element twice, which would try to write to the same memory cell twice - which is forbidden by the Cairo VM, leading to a runtime error.
Thankfully, this code does not actually compile. Once we have passed the array to the <code>foo</code> function, the variable <code>arr</code> is no longer usable. We get this compile-time error, telling us that we would need Array to implement the Copy Trait:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_02_pass_array_by_value v0.1.0 (listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/Scarb.toml)
warn: Unhandled `#[must_use]` type `core::option::Option::&lt;core::integer::u128&gt;`
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:3:5
    arr.pop_front();
    ^^^^^^^^^^^^^^^

error: Variable was previously moved.
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:10:9
    foo(arr);
        ^^^
note: variable was previously used here:
  --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:9:9
    foo(arr);
        ^^^
note: Trait has no implementation in context: core::traits::Copy::&lt;core::array::Array::&lt;core::integer::u128&gt;&gt;.

error: could not compile `no_listing_02_pass_array_by_value` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<h2 id="the-copy-trait"><a class="header" href="#the-copy-trait">The <code>Copy</code> Trait</a></h2>
<p>The <code>Copy</code> trait allows simple types to be duplicated by copying felts, without allocating new memory segments. This contrasts with Cairo's default "move" semantics, which transfer ownership of values to ensure memory safety and prevent issues like multiple writes to the same memory cell. <code>Copy</code> is implemented for types where duplication is safe and efficient, bypassing the need for move semantics. Types like <code>Array</code> and <code>Felt252Dict</code> cannot implement <code>Copy</code>, as manipulating them in different scopes is forbidden by the type system.</p>
<p>All basic types previously described in <a href="./ch02-02-data-types.html">"Data Types"</a> implement by default the <code>Copy</code> trait.</p>
<p>While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be.
You can implement the <code>Copy</code> trait on your type by adding the <code>#[derive(Copy)]</code> annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the type itself or any of its components doesn't implement the Copy trait.</p>
<pre><code class="language-cairo ignore_format">#[derive(Copy, Drop)]
struct Point {
    x: u128,
    y: u128,
}

#[executable]
fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1);
}

fn foo(p: Point) { // do something with p
}
</code></pre>
<p>In this example, we can pass <code>p1</code> twice to the foo function because the <code>Point</code> type implements the <code>Copy</code> trait. This means that when we pass <code>p1</code> to <code>foo</code>, we are actually passing a copy of <code>p1</code>, so <code>p1</code> remains valid. In ownership terms, this means that the ownership of <code>p1</code> remains with the <code>main</code> function.
If you remove the <code>Copy</code> trait derivation from the <code>Point</code> type, you will get a compile-time error when trying to compile the code.</p>
<p><em>Don't worry about the <code>Struct</code> keyword. We will introduce this in <a href="./ch05-00-using-structs-to-structure-related-data.html">Chapter 5</a>.</em></p>
<h2 id="destroying-values---example-with-feltdict"><a class="header" href="#destroying-values---example-with-feltdict">Destroying Values - Example with FeltDict</a></h2>
<p>The other way linear types can be <em>used</em> is by being destroyed. Destruction must ensure that the 'resource' is now correctly released. In Rust, for example, this could be closing the access to a file, or locking a mutex.
In Cairo, one type that has such behaviour is <code>Felt252Dict</code>. For provability, dicts must be 'squashed' when they are destructed.
This would be very easy to forget, so it is enforced by the type system and the compiler.</p>
<h3 id="no-op-destruction-the-drop-trait"><a class="header" href="#no-op-destruction-the-drop-trait">No-op Destruction: the <code>Drop</code> Trait</a></h3>
<p>You may have noticed that the <code>Point</code> type in the previous example also implements the <code>Drop</code> trait.
For example, the following code will not compile, because the struct <code>A</code> is not moved or destroyed before it goes out of scope:</p>
<pre><code class="language-cairo does_not_compile">struct A {}

#[executable]
fn main() {
    A {}; // error: Variable not dropped.
}
</code></pre>
<p>However, types that implement the <code>Drop</code> trait are automatically destroyed when going out of scope. This destruction does nothing, it is a no-op - simply a hint to the compiler that this type can safely be destroyed once it's no longer useful. We call this "dropping" a value.</p>
<p>At the moment, the <code>Drop</code> implementation can be derived for all types, allowing them to be dropped when going out of scope, except for dictionaries (<code>Felt252Dict</code>) and types containing dictionaries.
For example, the following code compiles:</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    A {}; // Now there is no error.
}
</code></pre>
<h3 id="destruction-with-a-side-effect-the-destruct-trait"><a class="header" href="#destruction-with-a-side-effect-the-destruct-trait">Destruction with a Side-effect: the <code>Destruct</code> Trait</a></h3>
<p>When a value is destroyed, the compiler first tries to call the <code>drop</code> method on that type. If it doesn't exist, then the compiler tries to call <code>destruct</code> instead. This method is provided by the <code>Destruct</code> trait.</p>
<p>As said earlier, dictionaries in Cairo are types that must be "squashed" when destructed, so that the sequence of access can be proven. This is easy for developers to forget, so instead dictionaries implement the <code>Destruct</code> trait to ensure that all dictionaries are <em>squashed</em> when going out of scope.
As such, the following example will not compile:</p>
<pre><code class="language-cairo does_not_compile">use core::dict::Felt252Dict;

struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() };
}
</code></pre>
<p>If you try to run this code, you will get a compile-time error:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_06_no_destruct_compile_fails v0.1.0 (listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/Scarb.toml)
error: Variable not dropped.
 --&gt; listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo:10:5
    A { dict: Default::default() };
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: Trait has no implementation in context: core::traits::Drop::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.
note: Trait has no implementation in context: core::traits::Destruct::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.

error: could not compile `no_listing_06_no_destruct_compile_fails` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>When <code>A</code> goes out of scope, it can't be dropped as it implements neither the <code>Drop</code> (as it contains a dictionary and can't <code>derive(Drop)</code>) nor the <code>Destruct</code> trait. To fix this, we can derive the <code>Destruct</code> trait implementation for the <code>A</code> type:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[derive(Destruct)]
struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() }; // No error here
}
</code></pre>
<p>Now, when <code>A</code> goes out of scope, its dictionary will be automatically <code>squashed</code>, and the program will compile.</p>
<h2 id="copy-array-data-with-clone"><a class="header" href="#copy-array-data-with-clone">Copy Array Data with <code>clone</code></a></h2>
<p>If we <em>do</em> want to deeply copy the data of an <code>Array</code>, we can use a common method called <code>clone</code>. We’ll discuss method syntax in a dedicated section in <a href="./ch05-03-method-syntax.html">Chapter 5</a>, but because methods are a common feature in many programming languages, you’ve probably seen them before.</p>
<p>Here’s an example of the <code>clone</code> method in action.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];
    let arr2 = arr1.clone();
}
</code></pre>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.
In this case, the <em>value</em> <code>arr1</code> refers to is being copied, resulting in new memory cells being used, and a new <em>variable</em> <code>arr2</code> is created, referring to the new copied value.</p>
<h2 id="return-values-and-scope"><a class="header" href="#return-values-and-scope">Return Values and Scope</a></h2>
<p>Returning values is equivalent to <em>moving</em> them. Listing 4-2 shows an example of a
function that returns some value, with similar annotations as those in Listing 4-1.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    let a1 = gives_ownership();           // gives_ownership moves its return
                                          // value into a1

    let a2 = A {};                        // a2 comes into scope

    let a3 = takes_and_gives_back(a2);    // a2 is moved into
                                          // takes_and_gives_back, which also
                                          // moves its return value into a3

} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
  // happens. a1 goes out of scope and is dropped.

fn gives_ownership() -&gt; A {               // gives_ownership will move its
                                          // return value into the function
                                          // that calls it

    let some_a = A {};                    // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}

// This function takes an instance some_a of A and returns it
fn takes_and_gives_back(some_a: A) -&gt; A { // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}
</code></pre>
<p><span class="caption">Listing 4-2: Moving return values</span></p>
<p>While this works, moving into and out of every function is a bit tedious. What if we want to let a function use a value but not move the value? It’s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</p>
<p>Cairo does let us return multiple values using a tuple, as shown in Listing 4-3.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];

    let (arr2, len) = calculate_length(arr1);
}

fn calculate_length(arr: Array&lt;u128&gt;) -&gt; (Array&lt;u128&gt;, usize) {
    let length = arr.len(); // len() returns the length of an array

    (arr, length)
}
</code></pre>
<p><span class="caption">Listing 4-3: Returning many values</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Cairo has two features for passing a value without destroying or moving it, called <em>references</em> and <em>snapshots</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-and-snapshots"><a class="header" href="#references-and-snapshots">References and Snapshots</a></h1>
<p>The issue with the tuple code in previous Listing 4-3 is that we have to return the
<code>Array</code> to the calling function so we can still use the <code>Array</code> after the
call to <code>calculate_length</code>, because the <code>Array</code> was moved into
<code>calculate_length</code>.</p>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>In the previous chapter, we talked about how Cairo's ownership system prevents us from using a variable after we've moved it, protecting us from potentially writing twice to the same memory cell. However, it's not very convenient. Let's see how we can retain ownership of the variable in the calling function using snapshots.</p>
<p>In Cairo, a snapshot is an immutable view of a value at a certain point in the execution of the program. Recall that memory is immutable, so modifying a variable actually fills a new memory cell. The old memory cell still exists, and snapshots are variables that refer to that "old" value. In this sense, snapshots are a view "into the past".</p>
<p>Here is how you would define and use a <code>calculate_area</code> function that takes a snapshot of a <code>Rectangle</code> struct as a parameter instead of taking ownership of the underlying value. In this example, the <code>calculate_area</code> function returns the area of the <code>Rectangle</code> passed as a snapshot. Since we’re passing it as an immutable view, we can be sure that <code>calculate_area</code> will not mutate the <code>Rectangle</code>, and ownership remains in the <code>main</code> function.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    let first_snapshot = @rec; // Take a snapshot of `rec` at this point in time
    rec.height = 5; // Mutate `rec` by changing its height
    let first_area = calculate_area(first_snapshot); // Calculate the area of the snapshot
    let second_area = calculate_area(@rec); // Calculate the current area
    println!("The area of the rectangle when the snapshot was taken is {}", first_area);
    println!("The current area of the rectangle is {}", second_area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    *rec.height * *rec.width
}
</code></pre>
<blockquote>
<p>Note: Accessing fields of a snapshot (e.g., <code>rec.height</code>) yields snapshots of those fields, which we desnap with <code>*</code> to get the values. This works here because <code>u64</code> implements <code>Copy</code>. You’ll learn more about desnapping in the next section.</p>
</blockquote>
<p>The output of this program is:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_09_snapshots v0.1.0 (listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
   Executing no_listing_09_snapshots
The area of the rectangle when the snapshot was taken is 30
The current area of the rectangle is 50


</code></pre>
<p>First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note that we pass <code>@rec</code> into <code>calculate_area</code> and, in its definition, we take <code>@Rectangle</code> rather than <code>Rectangle</code>.</p>
<p>Let’s take a closer look at the function call here:</p>
<pre><code class="language-cairo">let second_length = calculate_length(@arr1); // Calculate the current length of the array
</code></pre>
<p>The <code>@rec</code> syntax lets us create a snapshot of the value in <code>rec</code>. Because a snapshot is an immutable view of a value at a specific point in execution, the usual rules of the linear type system are not enforced. In particular, snapshot variables always implement the <code>Drop</code> trait, never the <code>Destruct</code> trait, even dictionary snapshots.</p>
<p>It’s worth noting that <code>@T</code> is not a pointer—snapshots are passed by value to functions, just like regular variables. This means that the size of <code>@T</code> is the same as the size of <code>T</code>, and when you pass <code>@rec</code> to <code>calculate_area</code>, the entire struct (in this case, a <code>Rectangle</code> with two <code>u64</code> fields) is copied to the function’s stack. For large data structures, this copying can be avoided by using <code>Box&lt;T&gt;</code>—provided that there's no need to mutate the value, which we’ll explore in <a href="./ch12-02-smart-pointers.html">Chapter 12</a>, but for now, understand that snapshots rely on this by-value mechanism.</p>
<p>Similarly, the signature of the function uses <code>@</code> to indicate that the type of the parameter <code>arr</code> is a snapshot. Let’s add some explanatory annotations:</p>
<pre><code class="language-cairo  noplayground">fn calculate_area(
    rec_snapshot: @Rectangle // rec_snapshot is a snapshot of a Rectangle
) -&gt; u64 {
    *rec_snapshot.height * *rec_snapshot.width
} // Here, rec_snapshot goes out of scope and is dropped.
// However, because it is only a view of what the original `rec` contains, the original `rec` can still be used.
</code></pre>
<p>The scope in which the variable <code>rec_snapshot</code> is valid is the same as any function parameter’s scope, but the underlying value of the snapshot is not dropped when <code>rec_snapshot</code> stops being used. When functions have snapshots as parameters instead of the actual values, we won’t need to return the values in order to give back ownership of the original value, because we never had it.</p>
<h3 id="desnap-operator"><a class="header" href="#desnap-operator">Desnap Operator</a></h3>
<p>To convert a snapshot back into a regular variable, you can use the <code>desnap</code> operator <code>*</code>, which serves as the opposite of the <code>@</code> operator.</p>
<p>Only <code>Copy</code> types can be desnapped. However, in the general case, because the value is not modified, the new variable created by the <code>desnap</code> operator reuses the old value, and so desnapping is a completely free operation, just like <code>Copy</code>.</p>
<p>In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of the rectangle in the <code>calculate_area</code> function, because we might want to use the rectangle again after the function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the rectangle to the function, and then transform the snapshots back into values using the <code>desnap</code> operator <code>*</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    let area = calculate_area(@rec);
    println!("Area: {}", area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.
    // We need to transform the snapshots back into values using the desnap operator `*`.
    // This is only possible if the type is copyable, which is the case for u64.
    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.
    *rec.height * *rec.width
}
</code></pre>
<p>But, what happens if we try to modify something we’re passing as a snapshot? Try the code in
Listing 4-4. Spoiler alert: it doesn’t work!</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">#[derive(Copy, Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    flip(@rec);
}

fn flip(rec: @Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p><span class="caption">Listing 4-4: Attempting to modify a snapshot value</span></p>
<p>Here’s the error:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling listing_04_04 v0.1.0 (listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/Scarb.toml)
error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:16:5
    rec.height = rec.width;
    ^^^^^^^^^^

error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:17:5
    rec.width = temp;
    ^^^^^^^^^

error: could not compile `listing_04_04` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>The compiler prevents us from modifying values associated to snapshots.</p>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<p>We can achieve the behavior we want in Listing 4-4 by using a <em>mutable reference</em> instead of a snapshot. Mutable references are actually mutable values passed to a function that are implicitly returned at the end of the function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed while keeping ownership of it by returning it automatically at the end of the execution.
In Cairo, a parameter can be passed as <em>mutable reference</em> using the <code>ref</code> modifier.</p>
<blockquote>
<p><strong>Note</strong>: In Cairo, a parameter can only be passed as <em>mutable reference</em> using the <code>ref</code> modifier if the variable is declared as mutable with <code>mut</code>.</p>
</blockquote>
<p>In Listing 4-5, we use a mutable reference to modify the value of the <code>height</code> and <code>width</code> fields of the <code>Rectangle</code> instance in the <code>flip</code> function.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    flip(ref rec);
    println!("height: {}, width: {}", rec.height, rec.width);
}

fn flip(ref rec: Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p><span class="caption">Listing 4-5: Use of a mutable reference to modify a value</span></p>
<p>First, we change <code>rec</code> to be <code>mut</code>. Then we pass a mutable reference of <code>rec</code> into <code>flip</code> with <code>ref rec</code>, and update the function signature to accept a mutable reference with <code>ref rec: Rectangle</code>. This makes it very clear that the <code>flip</code> function will mutate the value of the <code>Rectangle</code> instance passed as parameter.</p>
<p>Unlike snapshots, mutable references allow mutation, but like snapshots, <code>ref</code> arguments are not pointers—they are also passed by value. When you pass <code>ref rec</code>, the entire <code>Rectangle</code> type is copied to the function’s stack, regardless of whether it implements <code>Copy</code>. This ensures the function operates on its own local version of the data, which is then implicitly returned to the caller. To avoid this copying for large types, Cairo provides the <code>Box&lt;T&gt;</code> type introduced in <a href="./ch12-02-smart-pointers.html">Chapter 12</a> as an alternative, but for this example, the <code>ref</code> modifier suits our needs perfectly.</p>
<p>The output of the program is:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling listing_04_05 v0.1.0 (listings/ch04-understanding-ownership/listing_05_mutable_reference/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing listing_04_05
height: 10, width: 3


</code></pre>
<p>As expected, the <code>height</code> and <code>width</code> fields of the <code>rec</code> variable have been swapped.</p>
<p>{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}</p>
<h2 id="small-recap"><a class="header" href="#small-recap">Small Recap</a></h2>
<p>Let’s recap what we’ve discussed about the linear type system, ownership, snapshots, and references:</p>
<ul>
<li>At any given time, a variable can only have one owner.</li>
<li>You can pass a variable by-value, by-snapshot, or by-reference to a function.</li>
<li>If you pass-by-value, ownership of the variable is transferred to the function.</li>
<li>If you want to keep ownership of the variable and know that your function won’t mutate it, you can pass it as a snapshot with <code>@</code>.</li>
<li>If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a mutable reference with <code>ref</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-structs-to-structure-related-data"><a class="header" href="#using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></h1>
<p>A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a struct is like an object’s data attributes. In this chapter, we’ll compare and contrast tuples with structs to build on what you already know and demonstrate when structs are a better way to group data.</p>
<p>We’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, especially the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (discussed in the <a href="ch06-01-enums.html">next chapter</a>) are the building blocks for creating new types in your program’s domain to take full advantage of Cairo's compile-time type checking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-and-instantiating-structs"><a class="header" href="#defining-and-instantiating-structs">Defining and Instantiating Structs</a></h1>
<p>Structs are similar to tuples, discussed in the <a href="ch02-02-data-types.html">Data Types</a> section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing 5-1 shows a struct that stores information about a user account.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}
</code></pre>
<p><span class="caption">Listing 5-1: A <code>User</code> struct definition</span></p>
<blockquote>
<p><strong>Note :</strong><br />
You can derive multiple traits on structs, such as <code>Drop</code>, <code>PartialEq</code> for comparison and <code>Debug</code> for debug-printing.<br />
See the <a href="./appendix-03-derivable-traits.html">Appendix on Derivable Traits</a> for a complete list and examples.</p>
</blockquote>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct by specifying concrete values for each of the fields.
We create an instance by stating the name of the struct and then add curly brackets containing <em>key: value</em> pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.</p>
<p>For example, we can declare two particular users as shown in Listing 5-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}

#[executable]
fn main() {
    let user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    let user2 = User {
        sign_in_count: 1, username: "someusername123", active: true, email: "someone@example.com",
    };
}

</code></pre>
<p><span class="caption">Listing 5-2: Creating two instances of the <code>User</code> struct</span></p>
<p>To get a specific value from a struct, we use dot notation. For example, to access <code>user1</code>'s email address, we use <code>user1.email</code>. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span>#[executable]
fn main() {
    let mut user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    user1.email = "anotheremail@example.com";
}
<span class="boring">
</span><span class="boring">fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username: username, email: email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username, email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-3: Changing the value in the email field of a <code>User</code> instance</span></p>
<p>Note that the entire instance must be mutable; Cairo doesn’t allow us to mark only certain fields as mutable.</p>
<p>As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with the given email and username. The <code>active</code> field gets the value of <code>true</code>, and the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">    user1.email = "anotheremail@example.com";
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username: username, email: email, sign_in_count: 1 }
}
<span class="boring">
</span><span class="boring">fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username, email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-4: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance.</span></p>
<p>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the <code>email</code> and <code>username</code> field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<h2 id="using-the-field-init-shorthand"><a class="header" href="#using-the-field-init-shorthand">Using the Field Init Shorthand</a></h2>
<p>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field init shorthand syntax to rewrite <code>build_user</code> so it behaves exactly the same but doesn’t have the repetition of <code>username</code> and <code>email</code>, as shown in Listing 5-5.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">    user1.email = "anotheremail@example.com";
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username: username, email: email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username, email, sign_in_count: 1 }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-5: A <code>build_user</code> function that uses field init shorthand because the <code>username</code> and <code>email</code> parameters have the same name as struct fields.</span></p>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the <code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather than <code>email: email</code>.</p>
<h2 id="creating-instances-from-other-instances-with-struct-update-syntax"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances from Other Instances with Struct Update Syntax</a></h2>
<p>It’s often useful to create a new instance of a struct that includes most of
the values from another instance, but changes some. You can do this using
<em>struct update syntax</em>.</p>
<p>First, in Listing 5-6 we show how to create a new <code>User</code> instance in <code>user2</code>
regularly, without the update syntax. We set a new value for <code>email</code> but
otherwise use the same values from <code>user1</code> that we created in Listing 5-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: "another@example.com",
        sign_in_count: user1.sign_in_count,
    };
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-6: Creating a new <code>User</code> instance using all but one of the values from <code>user1</code></span></p>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">use core::byte_array;
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User { email: "another@example.com", ..user1 };
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-7: Using struct update syntax to set a new
<code>email</code> value for a <code>User</code> instance but to use the rest of the values from <code>user1</code></span></p>
<p>The code in Listing 5-7 also creates an instance of <code>user2</code> that has a
different value for <code>email</code> but has the same values for the <code>username</code>,
<code>active</code>, and <code>sign_in_count</code> fields as <code>user1</code>. The <code>..user1</code> part must come last
to specify that any remaining fields should get their values from the
corresponding fields in <code>user1</code>, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.</p>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because it moves the data,
just as we saw in the <a href="ch04-01-what-is-ownership.html#moving-values">"Moving Values"</a><!-- ignore --> section. In this example, we can no
longer use <code>user1</code> as a whole after creating <code>user2</code> because the <code>ByteArray</code> in the
<code>username</code> field of <code>user1</code> was moved into <code>user2</code>. If we had given <code>user2</code> new
<code>ByteArray</code> values for both <code>email</code> and <code>username</code>, and thus only used the
<code>active</code> and <code>sign_in_count</code> values from <code>user1</code>, then <code>user1</code> would still be
valid after creating <code>user2</code>. Both <code>active</code> and <code>sign_in_count</code> are types that
implement the <code>Copy</code> trait, so the behavior we discussed in the <a href="ch04-01-what-is-ownership.html#the-copy-trait">"<code>Copy</code> Trait"</a><!-- ignore --> section would apply.</p>
<p>{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-program-using-structs"><a class="header" href="#an-example-program-using-structs">An Example Program Using Structs</a></h1>
<p>To understand when we might want to use structs, let’s write a program that calculates the area of a rectangle. We’ll start by using single variables, and then refactor the program until we’re using structs instead.</p>
<p>Let’s make a new project with Scarb called <em>rectangles</em> that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing exactly that in our project’s <em>src/lib.cairo</em>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let width = 30;
    let height = 10;
    let area = area(width, height);
    println!("Area is {}", area);
}

fn area(width: u64, height: u64) -&gt; u64 {
    width * height
}
</code></pre>
<p><span class="caption">Listing 5-8: Calculating the area of a rectangle specified by separate width and height variables.</span></p>
<p>Now run the program with <code>scarb execute</code>:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling listing_04_06_no_struct v0.1.0 (listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing listing_04_06_no_struct
Area is 300


</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the <code>area</code> function with each dimension, but we can do more to make this code clear and readable.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-cairo noplayground">fn area(width: u64, height: u64) -&gt; u64 {
</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and it’s not clear anywhere in our program that the parameters are related. It would be more readable and more manageable to group width and height together. We’ve already discussed one way we might do that in the <a href="./ch02-02-data-types.html#the-tuple-type">Tuple Section of Chapter 2</a>.</p>
<h2 id="refactoring-with-tuples"><a class="header" href="#refactoring-with-tuples">Refactoring with Tuples</a></h2>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let rectangle = (30, 10);
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(dimension: (u64, u64)) -&gt; u64 {
    let (x, y) = dimension;
    x * y
}
</code></pre>
<p><span class="caption">Listing 5-9: Specifying the width and height of the rectangle with a tuple.</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one argument. But in another way, this version is less clear: tuples don’t name their elements, so we have to index into the parts of the tuple, making our calculation less obvious.</p>
<p>Mixing up the width and height wouldn’t matter for the area calculation, but if we want to calculate the difference, it would matter! We would have to keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple index <code>1</code>. This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we haven’t conveyed the meaning of our data in our code, it’s now easier to introduce errors.</p>
<h2 id="refactoring-with-structs-adding-more-meaning"><a class="header" href="#refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</a></h2>
<p>We use structs to add meaning by labeling the data. We can transform the tuple we’re using into a struct with a name for the whole as well as names for the parts.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">struct Rectangle {
    width: u64,
    height: u64,
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 30, height: 10 };
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(rectangle: Rectangle) -&gt; u64 {
    rectangle.width * rectangle.height
}
</code></pre>
<p><span class="caption">Listing 5-10: Defining a <code>Rectangle</code> struct.</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have type <code>u64</code>. Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code> that has a width of <code>30</code> and a height of <code>10</code>. Our <code>area</code> function is now defined with one parameter, which we’ve named <code>rectangle</code> which is of type <code>Rectangle</code> struct. We can then access the fields of the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index values of <code>0</code> and <code>1</code>.</p>
<h2 id="conversions-of-custom-types"><a class="header" href="#conversions-of-custom-types">Conversions of Custom Types</a></h2>
<p>We've already described how to perform type conversion on in-built types, see <a href="./ch02-02-data-types.html#type-conversion">Data Types &gt; Type Conversion</a>. In this section, we will see how to define conversions for custom types.</p>
<blockquote>
<p>Note: conversion can be defined for compound types, e.g. tuples, too.</p>
</blockquote>
<h3 id="into-1"><a class="header" href="#into-1">Into</a></h3>
<p>Defining a conversion for a custom type using the <code>Into</code> trait will typically require specification of the type to convert into, as the compiler is unable to determine this most of the time. However this is a small trade-off considering we get the functionality for free.</p>
<pre><code class="language-cairo">#[derive(Drop, PartialEq)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop)]
struct Square {
    side_length: u64,
}

impl SquareIntoRectangle of Into&lt;Square, Rectangle&gt; {
    fn into(self: Square) -&gt; Rectangle {
        Rectangle { width: self.side_length, height: self.side_length }
    }
}

#[executable]
fn main() {
    let square = Square { side_length: 5 };
    // Compiler will complain if you remove the type annotation
    let result: Rectangle = square.into();
    let expected = Rectangle { width: 5, height: 5 };
    assert!(
        result == expected,
        "A square is always convertible to a rectangle with the same width and height!",
    );
}
</code></pre>
<h3 id="tryinto-1"><a class="header" href="#tryinto-1">TryInto</a></h3>
<p>Defining a conversion for <code>TryInto</code> is similar to defining it for <code>Into</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop, PartialEq)]
struct Square {
    side_length: u64,
}

impl RectangleIntoSquare of TryInto&lt;Rectangle, Square&gt; {
    fn try_into(self: Rectangle) -&gt; Option&lt;Square&gt; {
        if self.height == self.width {
            Some(Square { side_length: self.height })
        } else {
            None
        }
    }
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 8, height: 8 };
    let result: Square = rectangle.try_into().unwrap();
    let expected = Square { side_length: 8 };
    assert!(
        result == expected,
        "Rectangle with equal width and height should be convertible to a square.",
    );

    let rectangle = Rectangle { width: 5, height: 8 };
    let result: Option&lt;Square&gt; = rectangle.try_into();
    assert!(
        result.is_none(),
        "Rectangle with different width and height should not be convertible to a square.",
    );
}
</code></pre>
<p>{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h1>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum which we cover in <a href="./ch06-01-enums.html">Chapter 6</a>), and their first parameter is always <code>self</code>, which represents the instance of the type the method is being called on.</p>
<h2 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h2>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown in Listing 5-11</p>
<pre><code class="language-cairo  noplayground">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
</code></pre>
<p>Listing 5-11: Defining an <code>area</code> method on the <code>Rectangle</code> struct.</p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> (implementation) block for a trait <code>RectangleTrait</code> that defines the methods that can be called on a <code>Rectangle</code> instance. As impl blocks can only be defined for traits and not types, we need to define this trait first - but it's not meant to be used for anything else.</p>
<p>Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only) parameter to be <code>self</code> in the signature and everywhere within the body. In <code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>self: @Rectangle</code> instead of <code>rectangle: @Rectangle</code>.
Methods must have a parameter named <code>self</code>, for their first parameter, and the type of <code>self</code> indicates the type that method can be called on. Methods can take ownership of <code>self</code>, but <code>self</code> can also be passed by snapshot or by reference, just like any other parameter.</p>
<blockquote>
<p>There is no direct link between a type and a trait. Only the type of the <code>self</code> parameter of a method defines the type from which this method can be called. That means, it is technically possible to define methods on multiple types in a same trait (mixing <code>Rectangle</code> and <code>Circle</code> methods, for example). But <strong>this is not a recommended practice</strong> as it can lead to confusion.</p>
</blockquote>
<p>The main reason for using methods instead of functions, in addition to providing method syntax, is for organization. We’ve put all the things we can do with an instance of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in various places in the library we provide.</p>
<h2 id="the-generate_trait-attribute"><a class="header" href="#the-generate_trait-attribute">The <code>generate_trait</code> Attribute</a></h2>
<p>If you are familiar with Rust, you may find Cairo's approach confusing because methods cannot be defined directly on types. Instead, you must define a <a href="./ch08-02-traits-in-cairo.html">trait</a> and an implementation of this trait associated with the type for which the method is intended.
However, defining a trait and then implementing it to define methods on a specific type is verbose, and unnecessary: the trait itself will not be reused.</p>
<p>So, to avoid defining useless traits, Cairo provides the <code>#[generate_trait]</code> attribute to add above a trait implementation, which tells the compiler to generate the corresponding trait definition for you, and lets you focus on the implementation only. Both approaches are equivalent, but it's considered a best practice to not explicitly define traits in this case.</p>
<p>The previous example can also be written as follows:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
</code></pre>
<p>Let's use this <code>#[generate_trait]</code> in the following chapters to make our code cleaner.</p>
<h2 id="snapshots-and-references"><a class="header" href="#snapshots-and-references">Snapshots and References</a></h2>
<p>As the <code>area</code> method does not modify the calling instance, <code>self</code> is declared as a snapshot of a <code>Rectangle</code> instance with the <code>@</code> snapshot operator. But, of course, we can also define some methods receiving a mutable reference of this instance, to be able to modify it.</p>
<p>Let's write a new method <code>scale</code> which resizes a rectangle of a <code>factor</code> given as parameter:</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }
}

#[executable]
fn main() {
    let mut rect2 = Rectangle { width: 10, height: 20 };
    rect2.scale(2);
    println!("The new size is (width: {}, height: {})", rect2.width, rect2.height);
}
</code></pre>
<p>It is also possible to define a method which takes ownership of the instance by using just <code>self</code> as the first parameter but it is rare. This technique is usually used when the method transforms <code>self</code> into something else and you want to prevent the caller from using the original instance after the transformation.</p>
<p>Look at the <a href="ch04-00-understanding-ownership.html">Understanding Ownership</a> chapter for more details about these important notions.</p>
<h2 id="methods-with-several-parameters"><a class="header" href="#methods-with-several-parameters">Methods with Several Parameters</a></h2>
<p>Let’s practice using methods by implementing another method on the <code>Rectangle</code> struct. This time we want to write the method <code>can_hold</code> which accepts another instance of <code>Rectangle</code> and returns <code>true</code> if this rectangle can fit completely within self; otherwise, it should return false.</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(@rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(@rect3));
}
</code></pre>
<p>Here, we expect that <code>rect1</code> can hold <code>rect2</code> but not <code>rect3</code>.</p>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h2>
<p>We call <em>associated functions</em> all functions that are defined inside an <code>impl</code> block that are associated to a specific type. While this is not enforced by the compiler, it is a good practice to keep associated functions related to the same type in the same <code>impl</code> block - for example, all functions related to <code>Rectangle</code> will be grouped in the same <code>impl</code> block for <code>RectangleTrait</code>.</p>
<p>Methods are a special kind of associated function, but we can also define associated functions that don’t have <code>self</code> as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with, but are still associated with that type.</p>
<p>Associated functions that aren’t methods are often used for constructors that
will return a new instance of the type. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p>Let's create the function <code>new</code> which creates a <code>Rectangle</code> from a <code>width</code> and a <code>height</code>, <code>square</code> which creates a square <code>Rectangle</code> from a <code>size</code> and <code>avg</code> which computes the average of two <code>Rectangle</code> instances:</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }

    fn new(width: u64, height: u64) -&gt; Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }

    fn avg(lhs: @Rectangle, rhs: @Rectangle) -&gt; Rectangle {
        Rectangle {
            width: ((*lhs.width) + (*rhs.width)) / 2, height: ((*lhs.height) + (*rhs.height)) / 2,
        }
    }
}

#[executable]
fn main() {
    let rect1 = RectangleTrait::new(30, 50);
    let rect2 = RectangleTrait::square(10);

    println!(
        "The average Rectangle of {:?} and {:?} is {:?}",
        @rect1,
        @rect2,
        RectangleTrait::avg(@rect1, @rect2),
    );
}
</code></pre>
<p>To call the <code>square</code> associated function, we use the <code>::</code> syntax with the struct name;
<code>let sq = RectangleTrait::square(3);</code> is an example. This function is namespaced by
the trait: the <code>::</code> syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in <a href="./ch07-02-defining-modules-to-control-scope.html">Chapter
7</a>.</p>
<p>Note that the <code>avg</code> function could also be written as a method with <code>self</code> as the first rectangle. In this case, instead of using the method with <code>RectangleTrait::avg(@rect1, @rect2)</code>, it would be called with <code>rect1.avg(rect2)</code>.</p>
<h2 id="multiple-traits-and-impl-blocks"><a class="header" href="#multiple-traits-and-impl-blocks">Multiple Traits and <code>impl</code> Blocks</a></h2>
<p>Each struct is allowed to have multiple <code>trait</code> and <code>impl</code> blocks. For example,
the following code is equivalent to the code shown in the <em>Methods with several parameters</em> section, which has each method in its own <code>trait</code> and <code>impl</code> blocks.</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[generate_trait]
impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>There’s no strong reason to separate these methods into multiple <code>trait</code> and <code>impl</code>
blocks here, but this is valid syntax.</p>
<p>{{#quiz ../quizzes/ch05-03-method-syntax.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-pattern-matching"><a class="header" href="#enums-and-pattern-matching">Enums and Pattern Matching</a></h1>
<p>In this chapter, we’ll look at <em>enumerations</em>, also referred to as <em>enums</em>.
Enums allow you to define a type by enumerating its possible <em>variants</em>. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called <code>Option</code>, which
expresses that a value can be either something or nothing. Finally, we’ll look at
how pattern matching in the <code>match</code> expression makes it easy to run different
code for different values of an enum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Enums, short for "enumerations," are a way to define a custom data type that consists of a fixed set of named values, called <em>variants</em>. Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning.</p>
<h2 id="enum-variants-and-values"><a class="header" href="#enum-variants-and-values">Enum Variants and Values</a></h2>
<p>Here's a simple example of an enum:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}
</code></pre>
<p>In this example, we've defined an enum called <code>Direction</code> with four variants: <code>North</code>, <code>East</code>, <code>South</code>, and <code>West</code>. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the <code>Direction</code> type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Direction {
</span><span class="boring">    North,
</span><span class="boring">    East,
</span><span class="boring">    South,
</span><span class="boring">    West,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let direction = Direction::North;
<span class="boring">}
</span></code></pre>
<p>Now let's imagine that our variants have associated values, that store the exact degree of the direction. We can define a new <code>Direction</code> enum:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let direction = Direction::North(10);
</span><span class="boring">}
</span></code></pre>
<p>and instantiate it as follows:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Direction {
</span><span class="boring">    North: u128,
</span><span class="boring">    East: u128,
</span><span class="boring">    South: u128,
</span><span class="boring">    West: u128,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let direction = Direction::North(10);
<span class="boring">}
</span></code></pre>
<p>In this code, each variant is associated with a <code>u128</code> value, representing the direction in degrees. In the next example, we will see that it is also possible to associate different data types with each variant.</p>
<p>It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a direction. You can learn more about it in the <a href="./ch06-02-the-match-control-flow-construct.html">Match Control Flow Construct</a> section.</p>
<h2 id="enums-combined-with-custom-types"><a class="header" href="#enums-combined-with-custom-types">Enums Combined with Custom Types</a></h2>
<p>Enums can also be used to store more interesting custom data associated with each variant. For example:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}
</code></pre>
<p>In this example, the <code>Message</code> enum has three variants: <code>Quit</code>, <code>Echo</code>, and <code>Move</code>, all with different types:</p>
<ul>
<li><code>Quit</code> doesn't have any associated value.</li>
<li><code>Echo</code> is a single <code>felt252</code>.</li>
<li><code>Move</code> is a tuple of two <code>u128</code> values.</li>
</ul>
<p>You could even use a Struct or another enum you defined inside one of your enum variants.</p>
<h2 id="trait-implementations-for-enums"><a class="header" href="#trait-implementations-for-enums">Trait Implementations for Enums</a></h2>
<p>In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous <code>Message</code> enum:</p>
<pre><code class="language-cairo  noplayground">trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit =&gt; { println!("quitting") },
            Message::Echo(value) =&gt; { println!("echoing {}", value) },
            Message::Move((x, y)) =&gt; { println!("moving from {} to {}", x, y) },
        }
    }
}
</code></pre>
<p>In this example, we implemented the <code>Processing</code> trait for <code>Message</code>. Here is how it could be used to process a <code>Quit</code> message:</p>
<pre><code class="language-cairo"><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Echo: felt252,
</span><span class="boring">    Move: (u128, u128),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Processing {
</span><span class="boring">    fn process(self: Message);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ProcessingImpl of Processing {
</span><span class="boring">    fn process(self: Message) {
</span><span class="boring">        match self {
</span><span class="boring">            Message::Quit =&gt; { println!("quitting") },
</span><span class="boring">            Message::Echo(value) =&gt; { println!("echoing {}", value) },
</span><span class="boring">            Message::Move((x, y)) =&gt; { println!("moving from {} to {}", x, y) },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="the-option-enum-and-its-advantages"><a class="header" href="#the-option-enum-and-its-advantages">The <code>Option</code> Enum and Its Advantages</a></h2>
<p>The <code>Option</code> enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: <code>Some: T</code> and <code>None</code>. <code>Some: T</code> indicates that there's a value of type <code>T</code>, while <code>None</code> represents the absence of a value.</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p>The <code>Option</code> enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using <code>Option</code> can also help prevent bugs caused by using uninitialized or unexpected <code>null</code> values.</p>
<p>To give you an example, here is a function which returns the index of the first element of an array with a given value, or <code>None</code> if the element is not present.</p>
<p>We are demonstrating two approaches for the above function:</p>
<ul>
<li>Recursive approach with <code>find_value_recursive</code>.</li>
<li>Iterative approach with <code>find_value_iterative</code>.</li>
</ul>
<pre><code class="language-cairo noplayground">fn find_value_recursive(mut arr: Span&lt;felt252&gt;, value: felt252, index: usize) -&gt; Option&lt;usize&gt; {
    match arr.pop_front() {
        Some(index_value) =&gt; { if (*index_value == value) {
            return Some(index);
        } },
        None =&gt; { return None; },
    }

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span&lt;felt252&gt;, value: felt252) -&gt; Option&lt;usize&gt; {
    let mut result = None;
    let mut index = 0;

    while let Some(array_value) = arr.pop_front() {
        if (*array_value == value) {
            result = Some(index);
            break;
        }

        index += 1;
    }

    result
}
</code></pre>
<p>Enums can be useful in many situations, especially when using the <code>match</code> flow construct that we just used. We will describe it in the next section.</p>
<p>Other enums are used very often, such as the <code>Result</code> enum, allowing to handle errors gracefully. We will explain the <code>Result</code> enum in detail in the <a href="./ch09-02-recoverable-errors.html#the-result-enum">"Error Handling"</a> chapter.</p>
<p>{{#quiz ../quizzes/ch06-01-enums.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-match-control-flow-construct"><a class="header" href="#the-match-control-flow-construct">The Match Control Flow Construct</a></h1>
<p>Cairo has an extremely powerful control flow construct called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The power of <code>match</code> comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits”, the value falls into the associated code block to be used during execution.</p>
<p>Speaking of coins, let’s use them as an example using <code>match</code>! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, as shown in Listing 6-1.</p>
<pre><code class="language-cairo noplayground">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<p><span class="caption">Listing 6-1: An enum and a <code>match</code> expression that has the variants of the enum as its patterns</span></p>
<p>Let’s break down the <code>match</code> expression in the <code>value_in_cents</code> function. First, we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional expression used with the <code>if</code> statement, but there’s a big difference: with <code>if</code>, the condition needs to evaluate to a boolean value, but here it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum that we defined on the first line.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code> operator that separates the pattern and the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against the pattern of each arm, in the order they are given. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in the above example, our <code>match</code> has four arms.</p>
<p>The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression.</p>
<p>We don’t typically use curly brackets if the <code>match</code> arm code is short, as it is in our example where each arm just returns a value. If you want to run multiple lines of code in a <code>match</code> arm, you must use curly brackets, with a comma following the arm. For example, the following code prints “Lucky penny!” every time the method is called with a <code>Coin::Penny</code>, but still returns the last value of the block, <code>1</code>:</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<h2 id="patterns-that-bind-to-values"><a class="header" href="#patterns-that-bind-to-values">Patterns That Bind to Values</a></h2>
<p>Another useful feature of <code>match</code> arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored inside it, which we’ve done in Listing 6-2.</p>
<pre><code class="language-cairo noplayground">
#[derive(Drop, Debug)] // Debug so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
}

#[derive(Drop)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter: UsState,
}
</code></pre>
<p><span class="caption">Listing 6-2: A <code>Coin</code> enum in which the <code>Quarter</code> variant also holds a <code>UsState</code> value</span></p>
<p>Let’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we’ll also call out the name of the state associated with each quarter so that if it’s one our friend doesn’t have, they can add it to their collection.</p>
<p>In the <code>match</code> expression for this code, we add a variable called <code>state</code> to the pattern that matches values of the variant <code>Coin::Quarter</code>. When a <code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
</code></pre>
<p>Because <code>state</code> is an <code>UsState</code> enum which implements the <code>Debug</code> trait, we can print <code>state</code> value with <code>println!</code> macro.</p>
<blockquote>
<p>Note: <code>{:?}</code> is a special formatting syntax that allows to print a debug form of the parameter passed to the <code>println!</code> macro. You can find more information about it in <a href="./appendix-03-derivable-traits.html#debug-for-printing-and-debugging">Appendix C</a>.</p>
</blockquote>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code> would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can then use that binding in <code>println!</code> macro, thus getting the inner state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<h2 id="matching-with-optiont"><a class="header" href="#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h2>
<p>In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code> case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code>, as we did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the variants of <code>Option&lt;T&gt;</code>, but the way the <code>match</code> expression works remains the same.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;u8&gt;</code> and, if there’s a value inside, adds <code>1</code> to that value. If there is no value inside, the function should return the <code>None</code> value and not attempt to perform any operations.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like Listing 6-3.</p>
<pre><code class="language-cairo">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Some(val) =&gt; Some(val + 1),
        None =&gt; None,
    }
}

#[executable]
fn main() {
    let five: Option&lt;u8&gt; = Some(5);
    let six: Option&lt;u8&gt; = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<p><span class="caption">Listing 6-3: A function that uses a <code>match</code> expression on an <code>Option&lt;u8&gt;</code></span></p>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call <code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5)</code>. We then compare that against each <code>match</code> arm:</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p>Does <code>Some(5)</code> value match the pattern <code>Some(val)</code>? It does! We have the same variant. The <code>val</code> binds to the value contained in <code>Some</code>, so <code>val</code> takes the value <code>5</code>. The code in the <code>match</code> arm is then executed, so we add <code>1</code> to the value of <code>val</code> and create a new <code>Some</code> value with our total <code>6</code> inside. Because the first arm matched, no other arms are compared.</p>
<p>Now let’s consider the second call of <code>plus_one</code> in our main function, where <code>x</code> is <code>None</code>. We enter the <code>match</code> and compare to the first arm:</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p>The <code>Some(val)</code> value doesn’t match the pattern <code>None</code>, so we continue to the next arm:</p>
<pre><code class="language-cairo">        None =&gt; None,
</code></pre>
<p>It matches! There’s no value to add to, so the matching construct ends and returns the <code>None</code> value on the right side of <code>=&gt;</code>.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this pattern a lot in Cairo code: <code>match</code> against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite.</p>
<h2 id="matches-are-exhaustive"><a class="header" href="#matches-are-exhaustive">Matches Are Exhaustive</a></h2>
<p>There’s one other aspect of <code>match</code> we need to discuss: the arms’ patterns must cover all possibilities. Consider this version of our <code>plus_one</code> function, which has a bug and won’t compile:</p>
<pre><code class="language-cairo noplayground">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Some(val) =&gt; Some(val + 1),
    }
}
</code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug.
Luckily, it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll get this error:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_08_missing_match_arm v0.1.0 (listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml)
error: Missing match arm: `None` not covered.
 --&gt; listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:5:5-7:5
      match x {
 _____^
|         Some(val) =&gt; Some(val + 1),
|     }
|_____^

error: could not compile `no_listing_08_missing_match_arm` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>Cairo knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of <code>Option&lt;T&gt;</code>, when Cairo prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the <a href="https://en.wikipedia.org/wiki/Null_pointer#History">billion-dollar mistake</a> discussed earlier impossible.</p>
<h2 id="catch-all-with-the-_-placeholder"><a class="header" href="#catch-all-with-the-_-placeholder">Catch-all with the <code>_</code> Placeholder</a></h2>
<p>Using enums, we can also take special actions for a few particular values, but for all other values take one default action.
<code>_</code> is a special pattern that matches any value and does not bind to that value.
You can use it by simply adding a new arm with <code>_</code> as the pattern for the last arm of the <code>match</code> expression.</p>
<p>Imagine we have a vending machine that only accepts Dime coins.
We want to have a function that processes inserted coins and returns <code>true</code> only if the coin is accepted.</p>
<p>Here's a <code>vending_machine_accept</code> function that implements this logic:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<p>This example also meets the exhaustiveness requirement because we’re explicitly ignoring all other values in the last arm; we haven’t forgotten anything.</p>
<blockquote>
<p>There's no catch-all pattern in Cairo that allows you to use the value of the pattern.</p>
</blockquote>
<!--
  TODO move the following in a separate chapter when there's more pattern matching features in upcoming Cairo versions. cf rust book chapter 18
-->
<h2 id="multiple-patterns-with-the--operator"><a class="header" href="#multiple-patterns-with-the--operator">Multiple Patterns with the <code>|</code> Operator</a></h2>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax, which is the pattern <em>or</em> operator.</p>
<p>For example, in the following code we modified the <code>vending_machine_accept</code> function to accept both <code>Dime</code> and <code>Quarter</code> coins in a single arm:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime | Coin::Quarter =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="matching-tuples"><a class="header" href="#matching-tuples">Matching Tuples</a></h2>
<p>It is possible to match tuples.
Let's introduce a new <code>DayType</code> enum:</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum DayType {
    Week,
    Weekend,
    Holiday,
}
</code></pre>
<p>Now, let's suppose that our vending machine accepts any coin on weekdays, but only accepts quarters and dimes on weekends and holidays.
We can modify the <code>vending_machine_accept</code> function to accept a tuple of a <code>Coin</code> and a <code>Weekday</code> and return <code>true</code> only if the given coin is accepted on the specified day:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, _) =&gt; true,
        (_, Coin::Dime) | (_, Coin::Quarter) =&gt; true,
        (_, _) =&gt; false,
    }
}
</code></pre>
<p>Writing <code>(_, _)</code> for the last arm of a tuple matching pattern might feel superfluous. Hence, we can use the <code>_ =&gt;</code> syntax if we want, for example, that our vending machine only accepts quarters on weekdays:</p>
<pre><code class="language-cairo noplayground">fn vending_week_machine(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, Coin::Quarter) =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="matching-felt252-and-integer-variables"><a class="header" href="#matching-felt252-and-integer-variables">Matching <code>felt252</code> and Integer Variables</a></h2>
<p>You can also match <code>felt252</code> and integer variables. This is useful when you want to match against a range of values.
However, there are some restrictions:</p>
<ul>
<li>Only integers that fit into a single <code>felt252</code> are supported (i.e. <code>u256</code> is not supported).</li>
<li>The first arm must be 0.</li>
<li>Each arm must cover a sequential segment, contiguously with other arms.</li>
</ul>
<p>Imagine we’re implementing a game where you roll a six-sided die to get a number between 0 and 5.
If you have 0, 1 or 2 you win. If you have 3, you can roll again. For all other values you lose.</p>
<p>Here's a match that implements that logic:</p>
<pre><code class="language-cairo noplayground">fn roll(value: u8) {
    match value {
        0 | 1 | 2 =&gt; println!("you won!"),
        3 =&gt; println!("you can roll again!"),
        _ =&gt; println!("you lost..."),
    }
}
</code></pre>
<p>{{#quiz ../quizzes/ch06-02-match.toml}}</p>
<blockquote>
<p>These restrictions are planned to be relaxed in future versions of Cairo.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-control-flow-with-if-let-and-while-let"><a class="header" href="#concise-control-flow-with-if-let-and-while-let">Concise Control Flow with <code>if let</code> and <code>while let</code></a></h1>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-4 that matches on an <code>Some&lt;u8&gt;</code> value in the <code>config_max</code> variable but only wants to execute code if the value is <code>Some</code> variant.</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let config_max = Some(5);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {}", max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 6-4: A <code>match</code> that only cares about executing
code when the value is <code>Some</code></span></p>
<p>If the value is <code>Some</code>, we print out the value in the <code>Some</code> variant by binding
the value to the variable <code>max</code> in the pattern. We don’t want to do anything
with the <code>None</code> value. To satisfy the <code>match</code> expression, we have to add <code>_ =&gt; ()</code> after processing just one variant, which is annoying boilerplate code to
add.</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following
code behaves the same as the <code>match</code> in Listing 6-4:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let number = Some(5);
    if let Some(max) = number {
        println!("The maximum is configured to be {}", max);
    }
<span class="boring">}
</span></code></pre>
<p>The syntax <code>if let</code> takes a pattern and an expression separated by an equal
sign. It works the same way as a <code>match</code>, where the expression is given to the
<code>match</code> and the pattern is its first arm. In this case, the pattern is
<code>Some(max)</code>, and <code>max</code> binds to the value inside <code>Some</code>. We can then
use <code>max</code> in the body of the <code>if let</code> block in the same way we used <code>max</code> in
the corresponding <code>match</code> arm. The code in the <code>if let</code> block isn’t run if the
value doesn’t match the pattern.</p>
<p>Using <code>if let</code> means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that <code>match</code> enforces. Choosing
between <code>match</code> and <code>if let</code> depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.</p>
<p>In other words, you can think of <code>if let</code> as syntactic sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with <code>else</code>
is the same as the block of code that would go with the <code>_</code> case in the <code>match</code>
expression. Recall the <code>Coin</code> enum definition in Listing 6-2,
where the <code>Quarter</code> variant also held a <code>UsState</code> value. If we wanted to count
all non-quarter coins we see while also announcing the state of the quarters,
we could do that with a <code>match</code> expression, like this:</p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let coin = Coin::Quarter;
    let mut count = 0;
    match coin {
        Coin::Quarter =&gt; println!("You got a quarter!"),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression, like this:</p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let coin = Coin::Quarter;
    let mut count = 0;
    if let Coin::Quarter = coin {
        println!("You got a quarter!");
    } else {
        count += 1;
    }
<span class="boring">    println!("{}", count);
</span><span class="boring">}
</span></code></pre>
<p>If you have a situation in which your program has logic that is too verbose to
express using <code>match</code>, remember that <code>if let</code> is in your Cairo toolbox as well.</p>
<h2 id="while-let"><a class="header" href="#while-let"><code>while let</code></a></h2>
<p>The <code>while let</code> syntax is similar to the <code>if let</code> syntax, but it allows you to loop over a collection of values and execute a block of code for each value that matches a specified pattern. In the case below, the pattern is <code>Some(x)</code>, which matches any <code>Some</code> variant of the <code>Option</code> enum.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr = array![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut sum = 0;
    while let Some(value) = arr.pop_front() {
        sum += value;
    }
    println!("{}", sum);
}
</code></pre>
<p>Using <code>while let</code> provides a more concise and idiomatic way of writing this loop compared to a traditional <code>while</code> loop with explicit pattern matching or handling of the <code>Option</code> type. However, as with <code>if let</code>, you lose the exhaustive checking that a <code>match</code> expression provides, so you need to be careful to handle any remaining cases outside the <code>while let</code> loop if necessary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-cairo-projects-with-packages-crates-and-modules"><a class="header" href="#managing-cairo-projects-with-packages-crates-and-modules">Managing Cairo Projects with Packages, Crates and Modules</a></h1>
<p>As you write large programs, organizing your code will become increasingly
important. By grouping related functionality and separating code with distinct
features, you’ll clarify where to find code that implements a particular
feature and where to go to change how a feature works.</p>
<p>The programs we’ve written so far have been in one module in one file. As a
project grows, you should organize code by splitting it into multiple modules
and then multiple files. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques.</p>
<p>We’ll also discuss encapsulating implementation details, which lets you reuse
code at a higher level: once you’ve implemented an operation, other code can
call your code without having to know how the
implementation works.</p>
<p>A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope”. When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope.</p>
<p>Cairo has a number of features that allow you to manage your code’s
organization. These features, sometimes
collectively referred to as the <em>module system</em>, include:</p>
<ul>
<li><strong>Packages:</strong> A Scarb feature that lets you build, test, and share crates.</li>
<li><strong>Crates:</strong> A tree of modules that corresponds to a single compilation unit.
It has a root directory, and a root module defined at the <em>lib.cairo</em> file under this directory.</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization and scope of items.</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module.</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-and-crates"><a class="header" href="#packages-and-crates">Packages and Crates</a></h1>
<h2 id="what-is-a-crate"><a class="header" href="#what-is-a-crate">What is a Crate?</a></h2>
<p>A crate is a subset of a package that is used in the actual Cairo compilation. This includes:</p>
<ul>
<li>The package source code, identified by the package name and the crate root, which is the main entry point of the package.</li>
<li>A subset of the package metadata that identifies crate-level settings of the Cairo compiler, for example, the <code>edition</code> field in the <em>Scarb.toml</em> file.</li>
</ul>
<p>Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the subsequent sections.</p>
<h2 id="what-is-the-crate-root"><a class="header" href="#what-is-the-crate-root">What is the Crate Root?</a></h2>
<p>The crate root is the <em>lib.cairo</em> source file that the Cairo compiler starts from and makes up the root module of your crate. We’ll explain modules in depth in the <a href="./ch07-02-defining-modules-to-control-scope.html">"Defining Modules to Control Scope"</a> chapter.</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a Package?</a></h2>
<p>A Cairo package is a directory (or equivalent) containing:</p>
<ul>
<li>A <em>Scarb.toml</em> manifest file with a <code>[package]</code> section.</li>
<li>Associated source code.</li>
</ul>
<p>This definition implies that a package might contain other packages, with a corresponding <em>Scarb.toml</em> file for each package.</p>
<h2 id="creating-a-package-with-scarb"><a class="header" href="#creating-a-package-with-scarb">Creating a Package with Scarb</a></h2>
<p>You can create a new Cairo package using the Scarb command-line tool. To create a new package, run the following command:</p>
<pre><code class="language-bash">scarb new my_package
</code></pre>
<p>This command will generate a new package directory named <em>my_package</em> with the following structure:</p>
<pre><code>my_package/
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<ul>
<li><em>src/</em> is the main directory where all the Cairo source files for the package will be stored.</li>
<li><em>lib.cairo</em> is the default root module of the crate, which is also the main entry point of the package.</li>
<li><em>Scarb.toml</em> is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find documentation about it on the <a href="https://docs.swmansion.com/scarb/docs/reference/manifest.html">Scarb reference</a>.</li>
</ul>
<pre><code class="language-toml">[package]
name = "my_package"
version = "0.1.0"
edition = "2024_07"

[executable]

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.11.4"
</code></pre>
<p>As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional <em>.cairo</em> files within the <em>src</em> directory or its subdirectories.</p>
<p>{{#quiz ../quizzes/ch07-01-packages-crates.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-modules-to-control-scope"><a class="header" href="#defining-modules-to-control-scope">Defining Modules to Control Scope</a></h1>
<p>In this section, we’ll talk about modules and other parts of the module system,
namely <em>paths</em> that allow you to name items and the <code>use</code> keyword that brings a
path into scope.</p>
<p>First, we’re going to start with a list of rules for easy reference when you’re
organizing your code in the future. Then we’ll explain each of the rules in
detail.</p>
<h2 id="modules-cheat-sheet"><a class="header" href="#modules-cheat-sheet">Modules Cheat Sheet</a></h2>
<p>Here we provide a quick reference on how modules, paths and the <code>use</code> keyword
work in the compiler, and how most developers organize their
code. We’ll be going through examples of each of these rules throughout this
chapter, but this is a great place to refer to as a reminder of how modules
work. You can create a new Scarb project with <code>scarb new backyard</code> to follow along.</p>
<ul>
<li>
<p><strong>Start from the crate root</strong>: When compiling a crate, the compiler first
looks in the crate root file (<em>src/lib.cairo</em>) for code to compile.</p>
</li>
<li>
<p><strong>Declaring modules</strong>: In the crate root file, you can declare new modules;
say, you declare a “garden” module with <code>mod garden;</code>. The compiler will look
for the module’s code in these places:</p>
<ul>
<li>
<p>Inline, within curly brackets that replace the semicolon following <code>mod garden</code>.</p>
<pre><code class="language-cairo noplayground">  // crate root file (src/lib.cairo)
  mod garden {
      // code defining the garden module goes here
  }
</code></pre>
</li>
<li>
<p>In the file <em>src/garden.cairo</em>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Declaring submodules</strong>: In any file other than the crate root, you can
declare submodules. For example, you might declare <code>mod vegetables;</code> in
<em>src/garden.cairo</em>. The compiler will look for the submodule’s code within the
directory named for the parent module in these places:</p>
<ul>
<li>
<p>Inline, directly following <code>mod vegetables</code>, within curly brackets instead
of the semicolon.</p>
<pre><code class="language-cairo noplayground">// src/garden.cairo file
mod vegetables {
    // code defining the vegetables submodule goes here
}
</code></pre>
</li>
<li>
<p>In the file <em>src/garden/vegetables.cairo</em>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Paths to code in modules</strong>: Once a module is part of your crate, you can
refer to code in that module from anywhere else in that same crate, using the path
to the code. For example, an <code>Asparagus</code> type in the <code>vegetables</code> submodule would be found at
<code>crate::garden::vegetables::Asparagus</code>.</p>
</li>
<li>
<p><strong>Private vs public</strong>: Code within a module is private from its parent modules by default. This means that it may only be
accessed by the current module and its descendants. To make a module public, declare it with <code>pub mod</code> instead of <code>mod</code>. To make items within a public module public as well, use <code>pub</code> before their declarations. Cairo also provides the <code>pub(crate)</code> keyword, allowing an item or module to be only visible within the crate in which the definition is included.</p>
</li>
<li>
<p><strong>The <code>use</code> keyword</strong>: Within a scope, the <code>use</code> keyword creates shortcuts to
items to reduce repetition of long paths. In any scope that can refer to
<code>crate::garden::vegetables::Asparagus</code>, you can create a shortcut with
<code>use crate::garden::vegetables::Asparagus;</code> and from then on you only need to
write <code>Asparagus</code> to make use of that type in the scope.</p>
</li>
</ul>
<p>Here we create a crate named <code>backyard</code> that illustrates these rules. The
crate’s directory, also named <code>backyard</code>, contains these files and directories:</p>
<pre><code class="language-text">backyard/
├── Scarb.toml
└── src
    ├── garden
    │   └── vegetables.cairo
    ├── garden.cairo
    └── lib.cairo
</code></pre>
<p>The crate root file in this case is <em>src/lib.cairo</em>, and it contains:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">pub mod garden;
use crate::garden::vegetables::Asparagus;

#[executable]
fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
</code></pre>
<p>The <code>pub mod garden;</code> line imports the <code>garden</code> module. Using <code>pub</code> to make <code>garden</code> publicly accessible, or <code>pub(crate)</code> if you really want to make <code>garden</code> only available for your crate, is optional to run our program here, as the <code>main</code> function resides in the same module as <code>pub mod garden;</code> declaration. Nevertheless, not declaring <code>garden</code> as <code>pub</code> will make it not accessible from any other package.
This line tells the compiler to include the code it finds in <em>src/garden.cairo</em>, which is:</p>
<p><span class="filename">Filename: src/garden.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod vegetables;
</code></pre>
<p>Here, <code>pub mod vegetables;</code> means the code in <em>src/garden/vegetables.cairo</em> is included too. That code is:</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Debug)]
pub struct Asparagus {}
</code></pre>
<p>The line <code>use crate::garden::vegetables::Asparagus;</code> lets us bring the <code>Asparagus</code> type into scope,
so we can use it in the <code>main</code> function.</p>
<p>Now let’s get into the details of these rules and demonstrate them in action!</p>
<h2 id="grouping-related-code-in-modules"><a class="header" href="#grouping-related-code-in-modules">Grouping Related Code in Modules</a></h2>
<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.
Modules also allow us to control the privacy of items, because code within a module
is private by default. Private items are internal implementation details not
available for outside use. We can choose to make modules and the items within
them public, which exposes them to allow external code to use and depend on them.</p>
<p>As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than the
implementation of a restaurant.</p>
<p>In the restaurant industry, some parts of a restaurant are referred to as
<em>front of house</em> and others as <em>back of house</em>. Front of house is where
customers are; this encompasses where the hosts seat customers, servers take
orders and payment, and bartenders make drinks. Back of house is where the
chefs and cooks work in the kitchen, dishwashers clean up, and managers do
administrative work.</p>
<p>To structure our crate in this way, we can organize its functions into nested
modules. Create a new package named <em>restaurant</em> by running <code>scarb new restaurant</code>; then enter the code in Listing 7-1 into <em>src/lib.cairo</em> to
define some modules and function signatures. Here’s the front of house section:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p><span class="caption">Listing 7-1: A <code>front_of_house</code> module containing other modules that then contain functions</span></p>
<p>We define a module with the <code>mod</code> keyword followed by the name of the module
(in this case, <code>front_of_house</code>). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules <code>hosting</code> and <code>serving</code>. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and functions.</p>
<p>By using modules, we can group related definitions together and name why
they’re related. Programmers using this code can navigate the code based on the
groups rather than having to read through all the definitions, making it easier
to find the definitions relevant to them. Programmers adding new functionality
to this code would know where to place the code to keep the program organized.</p>
<p>Earlier, we mentioned that <em>src/lib.cairo</em> is called the crate
root. The reason for this name is that the content of this file forms a module named after the crate name at the root of the crate’s module structure, known as the <em>module tree</em>.</p>
<p>Listing 7-2 shows the module tree for the structure in Listing 7-1.</p>
<pre><code class="language-text">restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Listing 7-2: The module tree for the code in Listing 7-1</span></p>
<p>This tree shows how some of the modules nest inside one another; for example,
<code>hosting</code> nests inside <code>front_of_house</code>. The tree also shows that some modules
are <em>siblings</em> to each other, meaning they’re defined in the same module;
<code>hosting</code> and <code>serving</code> are siblings defined within <code>front_of_house</code>. If module
A is contained inside module B, we say that module A is the <em>child</em> of module B
and that module B is the <em>parent</em> of module A. Notice that the entire module
tree is rooted under the explicit name of the crate <em>restaurant</em>.</p>
<p>The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.</p>
<p>{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h1>
<p>To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> is the full path starting from a crate root. The absolute path begins with the crate name.</li>
<li>A <em>relative path</em> starts from the current module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers separated by double colons (<code>::</code>).</p>
<p>To illustrate this notion let's take back our example Listing 7-1 for the restaurant we used in the last chapter. We have a crate named <em>restaurant</em> in which we have a module named <code>front_of_house</code> that contains a module named <code>hosting</code>. The <code>hosting</code> module contains a function named <code>add_to_waitlist</code>. We want to call the <code>add_to_waitlist</code> function from the <code>eat_at_restaurant</code> function. We need to tell Cairo the path to the <code>add_to_waitlist</code> function so it can find it.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}


pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-3: Calling the <code>add_to_waitlist</code> function using absolute and relative paths</span></p>
<p>The <code>eat_at_restaurant</code> function is part of our library's public API, so we mark it with the <code>pub</code> keyword. We’ll go into more detail about <code>pub</code> in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Exposing Paths with the <code>pub</code> Keyword"</a> section.</p>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>,
we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>. In Cairo, absolute paths start from the crate root, which you need to refer to by using the crate name. You can imagine a filesystem with the same structure: we’d specify the path <em>/front_of_house/hosting/add_to_waitlist</em> to run the <em>add_to_waitlist</em> program; using the crate name to start from the crate root is like using a slash (<code>/</code>) to start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code>, we use a relative path. The path starts with <code>front_of_house</code>, the name of the module defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the filesystem equivalent would be using the path <em>./front_of_house/hosting/add_to_waitlist</em>. Starting with a module name means that the path is relative to the current module.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! We get the following error:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling listing_07_02 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/Scarb.toml)
error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:28
    crate::front_of_house::hosting::add_to_waitlist();
                           ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:37
    crate::front_of_house::hosting::add_to_waitlist();
                                    ^^^^^^^^^^^^^^^

error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:21
    front_of_house::hosting::add_to_waitlist();
                    ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:30
    front_of_house::hosting::add_to_waitlist();
                             ^^^^^^^^^^^^^^^

error: could not compile `listing_07_02` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>The error messages say that module <code>hosting</code> and the <code>add_to_waitlist</code> function are not visible. In other words, we have the correct paths for the <code>hosting</code> module and the <code>add_to_waitlist</code> function, but Cairo won’t let us use them because it doesn’t have access to them. In Cairo, all items (functions, methods, structs, enums, modules, and constants) are private to parent modules by default. If you want to make an item like a function or struct private, you put it in a module.</p>
<p>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. This is because child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined. To continue with our metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant they operate.</p>
<p>Cairo chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking outer code. However, Cairo does give you the option to expose inner parts of child modules’ code to outer ancestor modules by using the <code>pub</code> keyword to make an item public.</p>
<h2 id="exposing-paths-with-the-pub-keyword"><a class="header" href="#exposing-paths-with-the-pub-keyword">Exposing Paths with the <code>pub</code> Keyword</a></h2>
<p>Let’s return to the previous error that told us the <code>hosting</code> module and the <code>add_to_waitlist</code> function are not visible. We want the <code>eat_at_restaurant</code> function in the parent module to have access to the <code>add_to_waitlist</code> function in the child module, so we mark the <code>hosting</code> module with the <code>pub</code> keyword, as shown in Listing 7-4.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-4: Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code></span></p>
<p>Unfortunately, the code in Listing 7-4 still results in an error.</p>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting;</code> makes the module public. With this change, if we can access <code>front_of_house</code>, we can access <code>hosting</code>. But the contents of <code>hosting</code> are still private; making the module public doesn’t make its contents public. The <code>pub</code> keyword on a module only lets code in its ancestor modules refer to it, not access its inner code. Because modules are containers, there’s not much we can do by only making the module public; we need to go further and choose to make one or more of the items within the module public as well.</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code> keyword before its definition, as in Listing 7-5.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles

    // Relative path
    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles
}
</code></pre>
<p><span class="caption">Listing 7-5: Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code></span></p>
<p>Now the code will compile! To see why adding the <code>pub</code> keyword lets us use these paths in <code>add_to_waitlist</code> with respect to the privacy rules, let’s look at the absolute and the relative paths.</p>
<p>In the absolute path, we start with the crate root, the root of our crate’s module tree. The <code>front_of_house</code> module is defined in the crate root. While <code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is defined in the same module as <code>front_of_house</code> (that is, <code>front_of_house</code> and <code>eat_at_restaurant</code> are siblings), we can refer to <code>front_of_house</code> from <code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can access the parent module of <code>hosting</code>, so we can access <code>hosting</code> itself. Finally, the <code>add_to_waitlist</code> function is marked with <code>pub</code> and we can access its parent module, so this function call works!</p>
<p>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from <code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module as <code>eat_at_restaurant</code>, so the relative path starting from the module in which <code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and <code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this function call is valid!</p>
<p>{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}</p>
<h2 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h2>
<p>We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using <code>super</code> at the start of the path. This is like starting a filesystem path with the <code>..</code> syntax. Using <code>super</code> allows us to reference an item that we know is in the parent module, which can make rearranging the module tree easier when the module is closely related to the parent, but the parent might be moved elsewhere in the module tree someday.</p>
<p>Consider the code in Listing 7-6 that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function <code>fix_incorrect_order</code> defined in the <code>back_of_house</code> module calls the function <code>deliver_order</code> defined in the parent module by specifying the path to <code>deliver_order</code> starting with <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p><span class="caption">Listing 7-6: Calling a function using a relative path starting with <code>super</code></span></p>
<p>Here you can see directly that you access a parent's module easily using <code>super</code>, which wasn't the case previously.
Note that the <code>back_of_house</code> is kept private, as external users are not supposed to interact with the back of house directly.</p>
<h2 id="making-structs-and-enums-public"><a class="header" href="#making-structs-and-enums-public">Making Structs and Enums Public</a></h2>
<p>We can also use <code>pub</code> to designate structs and enums as public, but there are a few extra details to consider when using <code>pub</code> with structs and enums.</p>
<ul>
<li>If we use <code>pub</code> before a struct definition, we make the struct public, but the struct’s fields will still be private. We can make each field public or not on a case-by-case basis.</li>
<li>In contrast, if we make an enum public, all of its variants are then public. We only need the <code>pub</code> before the <code>enum</code> keyword.</li>
</ul>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that is our last module system feature: the <code>use</code> keyword. We’ll cover <code>use</code> by itself first, and then we’ll show how to combine <code>pub</code> and <code>use</code>.</p>
<p>{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h1>
<p>Having to write out the paths to call functions can feel inconvenient and repetitive. Fortunately, there’s a way to simplify this process: we can create a shortcut to a path with the <code>use</code> keyword once, and then use the shorter name everywhere else in the scope.</p>
<p>In Listing 7-7, we bring the <code>crate::front_of_house::hosting</code> module into the
scope of the <code>eat_at_restaurant</code> function so we only have to specify
<code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">// section "Defining Modules to Control Scope"

mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist(); // ✅ Shorter path
}
</code></pre>
<p><span class="caption">Listing 7-7: Bringing a module into scope with <code>use</code></span></p>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in the filesystem. By adding <code>use crate::front_of_house::hosting;</code> in the crate root, <code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code> module had been defined in the crate root.</p>
<p>Note that <code>use</code> only creates the shortcut for the particular scope in which the <code>use</code> occurs. Listing 7-8 moves the <code>eat_at_restaurant</code> function into a new child module named <code>customer</code>, which is then a different scope than the <code>use</code>
statement, so the function body won’t compile:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p><span class="caption">Listing 7-8: A <code>use</code> statement only applies in the scope it’s in.</span></p>
<p>The compiler error shows that the shortcut no longer applies within the <code>customer</code> module:</p>
<pre><code class="language-shell">$ scarb build
   Compiling listing_07_05 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/Scarb.toml)
warn: Unused import: `listing_07_05::hosting`
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:9:28
use crate::front_of_house::hosting;
                           ^^^^^^^

error[E0006]: Identifier not found.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:13:9
        hosting::add_to_waitlist();
        ^^^^^^^

error: could not compile `listing_07_05` due to previous error

</code></pre>
<h2 id="creating-idiomatic-use-paths"><a class="header" href="#creating-idiomatic-use-paths">Creating Idiomatic <code>use</code> Paths</a></h2>
<p>In Listing 7-7, you might have wondered why we specified <code>use crate::front_of_house::hosting</code>
and then called <code>hosting::add_to_waitlist</code> in <code>eat_at_restaurant</code> rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing 7-9.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-9: Bringing the <code>add_to_waitlist</code> function into scope with <code>use</code>, which is unidiomatic</span></p>
<p>Although both Listing 7-7 and 7-9 accomplish the same task, Listing 7-7 is
the idiomatic way to bring a function into scope with <code>use</code>. Bringing the
function’s parent module into scope with <code>use</code> means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn’t locally defined
while still minimizing repetition of the full path. The code in Listing 7-9 is
unclear as to where <code>add_to_waitlist</code> is defined.</p>
<p>On the other hand, when bringing in structs, enums, traits, and other items with <code>use</code>, it’s idiomatic to specify the full path. Listing 7-10 shows the idiomatic way to bring the core library’s <code>BitSize</code> trait into the scope, allowing to call <code>bits</code> method to retrieve the size in bits of a type.</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

#[executable]
fn main() {
    let u8_size: usize = BitSize::&lt;u8&gt;::bits();
    println!("A u8 variable has {} bits", u8_size)
}
</code></pre>
<p><span class="caption">Listing 7-10: Bringing <code>BitSize</code> trait into scope in an idiomatic way</span></p>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged in the Rust community, and folks have gotten used to reading and writing Rust code this way.
As Cairo shares many idioms with Rust, we follow this convention as well.</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Cairo doesn’t allow that.</p>
<h3 id="providing-new-names-with-the-as-keyword"><a class="header" href="#providing-new-names-with-the-as-keyword">Providing New Names with the <code>as</code> Keyword</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or <em>alias</em>, for the type. Listing 7-11 shows how you can rename an import with <code>as</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">use core::array::ArrayTrait as Arr;

#[executable]
fn main() {
    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr
    arr.append(1);
}
</code></pre>
<p><span class="caption">Listing 7-11: Renaming a trait when it’s brought into scope with the <code>as</code> keyword</span></p>
<p>Here, we brought <code>ArrayTrait</code> into scope with the alias <code>Arr</code>. We can now access the trait's methods with the <code>Arr</code> identifier.</p>
<h3 id="importing-multiple-items-from-the-same-module"><a class="header" href="#importing-multiple-items-from-the-same-module">Importing Multiple Items from the Same Module</a></h3>
<p>When you want to import multiple items (like functions, structs or enums)
from the same module in Cairo, you can use curly braces <code>{}</code> to list all of
the items that you want to import. This helps to keep your code clean and easy
to read by avoiding a long list of individual <code>use</code> statements.</p>
<p>The general syntax for importing multiple items from the same module is:</p>
<pre><code class="language-cairo">use module::{item1, item2, item3};
</code></pre>
<p>Here is an example where we import three structures from the same module:</p>
<pre><code class="language-cairo">// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.
mod shapes {
    #[derive(Drop)]
    pub struct Square {
        pub side: u32,
    }

    #[derive(Drop)]
    pub struct Circle {
        pub radius: u32,
    }

    #[derive(Drop)]
    pub struct Triangle {
        pub base: u32,
        pub height: u32,
    }
}

// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like
// this:
use shapes::{Circle, Square, Triangle};

// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.
#[executable]
fn main() {
    let sq = Square { side: 5 };
    let cr = Circle { radius: 3 };
    let tr = Triangle { base: 5, height: 2 };
    // ...
}
</code></pre>
<p><span class="caption">Listing 7-12: Importing multiple items from the same module</span></p>
<h2 id="re-exporting-names-in-module-files"><a class="header" href="#re-exporting-names-in-module-files">Re-exporting Names in Module Files</a></h2>
<p>When we bring a name into scope with the <code>use</code> keyword, the name available in
the new scope can be imported as if it had been defined in that code’s scope.
This technique is called <em>re-exporting</em> because we’re bringing an item into scope,
but also making that item available for others to bring into their scope, with the <code>pub</code> keyword.</p>
<p>For example, let's re-export the <code>add_to_waitlist</code> function in the restaurant example:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-13: Making a name available for any code to use from a new scope with <code>pub use</code></span></p>
<p>Before this change, external code would have to call the <code>add_to_waitlist</code>
function by using the path <code>restaurant::front_of_house::hosting::add_to_waitlist()</code>.
Now that this <code>pub use</code> has re-exported the <code>hosting</code> module from the root module, external code
can now use the path <code>restaurant::hosting::add_to_waitlist()</code> instead.</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
<code>pub use</code>, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.</p>
<h2 id="using-external-packages-in-cairo-with-scarb"><a class="header" href="#using-external-packages-in-cairo-with-scarb">Using External Packages in Cairo with Scarb</a></h2>
<p>You might need to use external packages to leverage the functionality provided by the community. Scarb allows you to use dependencies by cloning packages from their Git repositories. To use an external package in your project with Scarb, simply declare the Git repository URL of the dependency you want to add in a dedicated <code>[dependencies]</code> section in your <em>Scarb.toml</em> configuration file. Note that the URL might correspond to the main branch, or any specific commit, branch or tag. For this, you will have to pass an extra <code>rev</code>, <code>branch</code>, or <code>tag</code> field, respectively. For example, the following code imports the main branch of <em>alexandria_math</em> crate from <em>alexandria</em> package:</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git" }
</code></pre>
<p>while the following code imports a specific branch (which is deprecated and should not be used):</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git", branch = "cairo-v2.3.0-rc0" }
</code></pre>
<p>If you want to import multiple packages in your project, you need to create only one <code>[dependencies]</code> section and list all the desired packages beneath it. You can also specify development dependencies by declaring a <code>[dev-dependencies]</code> section.</p>
<p>After that, simply run <code>scarb build</code> to fetch all external dependencies and compile your package with all the dependencies included.</p>
<p>Note that it is also possible to add dependencies with the <code>scarb add</code> command, which will automatically edit the <em>Scarb.toml</em> file for you. For development dependencies, just use the <code>scarb add --dev</code> command.</p>
<p>To remove a dependency, simply remove the corresponding line from your <em>Scarb.toml</em> file, or use the <code>scarb rm</code> command.</p>
<h2 id="the-glob-operator"><a class="header" href="#the-glob-operator">The Glob Operator</a></h2>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by the <code>*</code> glob operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::num::traits::*;
<span class="boring">}</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>core::num::traits</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.</p>
<p>The glob operator is often used when testing to bring everything under test
into the <code>tests</code> module; we’ll talk about that in the <a href="./ch10-01-how-to-write-tests.html">“How to Write
Tests”</a> section in Chapter 10.</p>
<p>{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separating-modules-into-different-files"><a class="header" href="#separating-modules-into-different-files">Separating Modules into Different Files</a></h1>
<p>So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.</p>
<p>For example, let’s start from the code in Listing 7-7 that had multiple
restaurant modules. We’ll extract modules into files instead of having all the
modules defined in the crate root file. In this case, the crate root file is
<em>src/lib.cairo</em>.</p>
<p>First, we’ll extract the <code>front_of_house</code> module to its own file. Remove the
code inside the curly brackets for the <code>front_of_house</code> module, leaving only
the <code>mod front_of_house;</code> declaration, so that <em>src/lib.cairo</em> contains the code
shown in Listing 7-14. Note that this won’t compile until we create the
<em>src/front_of_house.cairo</em> file.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house;
use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-14: Declaring the <code>front_of_house</code> module whose body will be in <em>src/front_of_house.cairo</em></span></p>
<p>Next, place the code that was in the curly brackets into a new file named
<em>src/front_of_house.cairo</em>, as shown in Listing 7-15. The compiler knows to look
in this file because it came across the module declaration in the crate root
with the name <code>front_of_house</code>.</p>
<p><span class="filename">Filename: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">Listing 7-15: Definitions inside the <code>front_of_house</code> module in <em>src/front_of_house.cairo</em></span></p>
<p>Note that you only need to load a file using a <code>mod</code> declaration <em>once</em> in your
module tree. Once the compiler knows the file is part of the project (and knows
where in the module tree the code resides because of where you’ve put the <code>mod</code>
statement), other files in your project should refer to the loaded file’s code
using a path to where it was declared, as covered in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Paths for Referring to an Item in the Module Tree"</a> chapter.
In other words, <code>mod</code> is <em>not</em> an “include” operation that you may have seen in other
programming languages.</p>
<p>Next, we’ll extract the <code>hosting</code> module to its own file. The process is a bit
different because <code>hosting</code> is a child module of <code>front_of_house</code>, not of the
root module. We’ll place the file for <code>hosting</code> in a new directory that will be
named for its ancestors in the module tree, in this case <em>src/front_of_house/</em>.</p>
<p>To start moving <code>hosting</code>, we change <em>src/front_of_house.cairo</em> to contain only the
declaration of the <code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting;
</code></pre>
<p>Then we create a <em>src/front_of_house</em> directory and a file <em>hosting.cairo</em> to
contain the definitions made in the <code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house/hosting.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add_to_waitlist() {}
</code></pre>
<p>If we instead put <em>hosting.cairo</em> in the <em>src</em> directory, the compiler would
expect the <em>hosting.cairo</em> code to be in a <code>hosting</code> module declared in the crate
root, and not declared as a child of the <code>front_of_house</code> module. The
compiler’s rules for which files to check for which modules’ code means the
directories and files more closely match the module tree.</p>
<p>We’ve moved each module’s code to a separate file, and the module tree remains
the same. The function calls in <code>eat_at_restaurant</code> will work without any
modification, even though the definitions live in different files. This
technique lets you move modules to new files as they grow in size.</p>
<p>Note that the <code>use crate::front_of_house::hosting;</code> statement in
<em>src/lib.cairo</em> also hasn’t changed, nor does <code>use</code> have any impact on what files
are compiled as part of the crate. The <code>mod</code> keyword declares modules, and Cairo
looks in a file with the same name as the module for the code that goes into
that module.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Cairo lets you split a package into multiple crates and a crate into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a <code>use</code> statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is <strong>private</strong> by default.</p>
<p>{{#quiz ../quizzes/ch07-05-separate-modules.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-and-traits"><a class="header" href="#generic-types-and-traits">Generic Types and Traits</a></h1>
<p>Every programming language has tools for effectively handling the duplication of concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete types or other properties. We can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.</p>
<p>Functions can take parameters of some generic type, instead of a concrete type like <code>u32</code> or <code>bool</code>, in the same way a function takes parameters with unknown values to run the same code on multiple concrete values. In fact, we’ve already used generics in <a href="./ch06-01-enums.html#the-option-enum-and-its-advantages">Chapter 6</a> with <code>Option&lt;T&gt;</code>.</p>
<p>In this chapter, you’ll explore how to define your own types, functions, and traits with generics.</p>
<p>Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. Upon compilation, the compiler creates a new definition for each concrete type that replaces a generic type, reducing development time for the programmer, but code duplication at compile level still exists. This may be of importance if you are writing Starknet contracts and using a generic for multiple types which will cause contract size to increment.</p>
<p>Then you’ll learn how to use traits to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just any type.</p>
<h2 id="removing-duplication-by-extracting-a-function"><a class="header" href="#removing-duplication-by-extracting-a-function">Removing Duplication by Extracting a Function</a></h2>
<p>Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. Before diving into generics syntax, let’s first look at how to remove duplication in a way that doesn’t involve generic types by extracting a function that replaces specific values with a placeholder that represents multiple values. Then we’ll apply the same technique to extract a generic function! By learning how to identify duplicated code that can be extracted into a function, you'll start to recognize instances where generics can be used to reduce duplication.</p>
<p>We begin with a short program that finds the largest number in an array of <code>u8</code>:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    while let Some(number) = number_list.pop_front() {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>We store an array of <code>u8</code> in the variable <code>number_list</code> and extract the first number in the array in a variable named <code>largest</code>. We then iterate through all the numbers in the array, and if the current number is greater than the number stored in <code>largest</code>, we update the value of <code>largest</code>. However, if the current number is less than or equal to the largest number seen so far, the variable doesn’t change, and the code moves on to the next number in the list. After considering all the numbers in the array, <code>largest</code> should contain the largest number, which in this case is 100.</p>
<p>We've now been tasked with finding the largest number in two different arrays of numbers. To do so, we can choose to duplicate the previous code and use the same logic at two different places in the program, as follows:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    while let Some(number) = number_list.pop_front() {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let mut number_list: Array&lt;u8&gt; = array![102, 34, 255, 89, 54, 2, 43, 8];

    let mut largest = number_list.pop_front().unwrap();

    while let Some(number) = number_list.pop_front() {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>Although this code works, duplicating code is tedious and error-prone. We also have to remember to update the code in multiple places when we want to change it.</p>
<p>To eliminate this duplication, we’ll create an abstraction by defining a function that operates on any array of <code>u8</code> passed in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in an array abstractly.</p>
<p>To do that, we extract the code that finds the largest number into a function named <code>largest</code>. Then we call the function to find the largest number in the two arrays. We could also use the function on any other array of <code>u8</code> values we might have in the future.</p>
<pre><code class="language-cairo">fn largest(ref number_list: Array&lt;u8&gt;) -&gt; u8 {
    let mut largest = number_list.pop_front().unwrap();

    while let Some(number) = number_list.pop_front() {
        if number &gt; largest {
            largest = number;
        }
    }

    largest
}

#[executable]
fn main() {
    let mut number_list = array![34, 50, 25, 100, 65];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);

    let mut number_list = array![102, 34, 255, 89, 54, 2, 43, 8];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);
}
</code></pre>
<p>The largest function has a parameter called <code>number_list</code>, passed by reference, which represents any concrete array of <code>u8</code> values we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</p>
<p>In summary, here are the steps we took to change the code:</p>
<ul>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ul>
<p>Next, we’ll use these same steps with generics to reduce code duplication. In the same way that the function body can operate on an abstract <code>Array&lt;T&gt;</code> instead of specific <code>u8</code> values, generics allow code to operate on abstract types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo, we can use generics when defining functions, structs, enums, traits, implementations and methods. In this chapter, we are going to take a look at how to effectively use generic types with all of them.</p>
<p>Generics allow us to write reusable code that works with many types, thus avoiding code duplication, while enhancing code maintainability.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>Making a function generic means it can operate on different types, avoiding the need for multiple, type-specific implementations. This leads to significant code reduction and increases the flexibility of the code.</p>
<p>When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two <code>Array</code> of items, will return the largest one. If we need to perform this operation for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.</p>
<pre><code class="language-cairo">// Specify generic type T between the angulars
fn largest_list&lt;T&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}

#[executable]
fn main() {
    let mut l1 = array![1, 2];
    let mut l2 = array![3, 4, 5];

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}
</code></pre>
<p>The <code>largest_list</code> function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an <code>Array&lt;T&gt;</code> is droppable when executing the <code>main</code> function. In order to drop an array of <code>T</code>, the compiler must first know how to drop <code>T</code>. This can be fixed by specifying in the function signature of <code>largest_list</code> that <code>T</code> must implement the <code>Drop</code> trait. The correct function definition of <code>largest_list</code> is as follows:</p>
<pre><code class="language-cairo">fn largest_list&lt;T, impl TDrop: Drop&lt;T&gt;&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}
</code></pre>
<p>The new <code>largest_list</code> function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. This is what we call <em>trait bounds</em>. The <code>main</code> function remains unchanged, the compiler is smart enough to deduce which concrete type is being used and if it implements the <code>Drop</code> trait.</p>
<h3 id="constraints-for-generic-types"><a class="header" href="#constraints-for-generic-types">Constraints for Generic Types</a></h3>
<p>When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allows us to use it more effectively in a function's logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the <code>TDrop</code> implementation as part of the generic arguments of <code>largest_list</code>. While <code>TDrop</code> was added to satisfy the compiler's requirements, we can also add constraints to benefit our function logic.</p>
<p>Imagine we have a list of elements of some generic type <code>T</code>, and we want to find the smallest element among them. Initially, we know that for an element of type <code>T</code> to be comparable, it must implement the <code>PartialOrd</code> trait. The resulting function would be:</p>
<pre><code class="language-cairo">// Given a list of T get the smallest one
// The PartialOrd trait implements comparison operations for T
fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0];

    // The index we will use to move through the list
    let mut index = 1;

    // Iterate through the whole list storing the smallest
    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}

#[executable]
fn main() {
    let list: Array&lt;u8&gt; = array![5, 3, 10];

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert!(s == 3);
}
</code></pre>
<p>The <code>smallest_element</code> function uses a generic type <code>T</code> that implements the <code>PartialOrd</code> trait, takes a snapshot of an <code>Array&lt;T&gt;</code> as a parameter and returns a copy of the smallest element. Because the parameter is of type <code>@Array&lt;T&gt;</code>, we no longer need to drop it at the end of the execution and so we are not required to implement the <code>Drop</code> trait for <code>T</code> as well. Why does it not compile then?</p>
<p>When indexing on <code>list</code>, the value results in a snap of the indexed element, and unless <code>PartialOrd</code> is implemented for <code>@T</code> we need to desnap the element using <code>*</code>. The <code>*</code> operation requires a copy from <code>@T</code> to <code>T</code>, which means that <code>T</code> needs to implement the <code>Copy</code> trait. After copying an element of type <code>@T</code> to <code>T</code>, there are now variables with type <code>T</code> that need to be dropped, requiring <code>T</code> to implement the <code>Drop</code> trait as well. We must then add both <code>Drop</code> and <code>Copy</code> traits implementation for the function to be correct. After updating the <code>smallest_element</code> function the resulting code would be:</p>
<pre><code class="language-cairo">fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;, impl TCopy: Copy&lt;T&gt;, impl TDrop: Drop&lt;T&gt;&gt;(
    list: @Array&lt;T&gt;,
) -&gt; T {
    let mut smallest = *list[0];
    let mut index = 1;

    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}
</code></pre>
<h3 id="anonymous-generic-implementation-parameter--operator"><a class="header" href="#anonymous-generic-implementation-parameter--operator">Anonymous Generic Implementation Parameter (<code>+</code> Operator)</a></h3>
<p>Until now, we have always specified a name for each implementation of the required generic trait: <code>TPartialOrd</code> for <code>PartialOrd&lt;T&gt;</code>, <code>TDrop</code> for <code>Drop&lt;T&gt;</code>, and <code>TCopy</code> for <code>Copy&lt;T&gt;</code>.</p>
<p>However, most of the time, we don't use the implementation in the function body; we only use it as a constraint. In these cases, we can use the <code>+</code> operator to specify that the generic type must implement a trait without naming the implementation. This is referred to as an <em>anonymous generic implementation parameter</em>.</p>
<p>For example, <code>+PartialOrd&lt;T&gt;</code> is equivalent to <code>impl TPartialOrd: PartialOrd&lt;T&gt;</code>.</p>
<p>We can rewrite the <code>smallest_element</code> function signature as follows:</p>
<pre><code class="language-cairo">fn smallest_element&lt;T, +PartialOrd&lt;T&gt;, +Copy&lt;T&gt;, +Drop&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
<span class="boring">    let mut smallest = *list[0];
</span><span class="boring">    let mut index = 1;
</span><span class="boring">    loop {
</span><span class="boring">        if index &gt;= list.len() {
</span><span class="boring">            break smallest;
</span><span class="boring">        }
</span><span class="boring">        if *list[index] &lt; smallest {
</span><span class="boring">            smallest = *list[index];
</span><span class="boring">        }
</span><span class="boring">        index = index + 1;
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>We can also define structs to use a generic type parameter for one or more fields using the <code>&lt;&gt;</code> syntax, similar to function definitions. First, we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition <code>Wallet&lt;T&gt;</code> which has a <code>balance</code> field of type <code>T</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>The above code derives the <code>Drop</code> trait for the <code>Wallet</code> type automatically. It is equivalent to writing the following code:</p>
<pre><code class="language-cairo">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, +Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;T&gt;&gt;;

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>We avoid using the <code>derive</code> macro for <code>Drop</code> implementation of <code>Wallet</code> and instead define our own <code>WalletDrop</code> implementation. Notice that we must define, just like functions, an additional generic type for <code>WalletDrop</code> saying that <code>T</code> implements the <code>Drop</code> trait as well. We are basically saying that the struct <code>Wallet&lt;T&gt;</code> is droppable as long as <code>T</code> is also droppable.</p>
<p>Finally, if we want to add a field to <code>Wallet</code> representing its address and we want that field to be different than <code>T</code> but generic as well, we can simply add another generic type between the <code>&lt;&gt;</code>:</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3, address: 14 };
}
</code></pre>
<p>We add to the <code>Wallet</code> struct definition a new generic type <code>U</code> and then assign this type to the new field member <code>address</code>. Notice that the <code>derive</code> attribute for the <code>Drop</code> trait works for <code>U</code> as well.</p>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>As we did with structs, we can define enums to hold generic data types in their variants. For example the <code>Option&lt;T&gt;</code> enum provided by the Cairo core library:</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p>The <code>Option&lt;T&gt;</code> enum is generic over a type <code>T</code> and has two variants: <code>Some</code>, which holds one value of type <code>T</code> and <code>None</code> that doesn't hold any value. By using the <code>Option&lt;T&gt;</code> enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type <code>T</code> we can use this abstraction with any type.</p>
<p>Enums can use multiple generic types as well, like the definition of the <code>Result&lt;T, E&gt;</code> enum that the core library provides:</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum has two generic types, <code>T</code> and <code>E</code>, and two variants: <code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type <code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we have an operation that might succeed (by returning a value of type <code>T</code>) or fail (by returning a value of type <code>E</code>).</p>
<h2 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h2>
<p>We can implement methods on structs and enums, and use the generic types in their definitions, too. Using our previous definition of <code>Wallet&lt;T&gt;</code> struct, we define a <code>balance</code> method for it:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

#[executable]
fn main() {
    let w = Wallet { balance: 50 };
    assert!(w.balance() == 50);
}
</code></pre>
<p>We first define <code>WalletTrait&lt;T&gt;</code> trait using a generic type <code>T</code> which defines a method that returns the value of the field <code>balance</code> from <code>Wallet</code>. Then we give an implementation for the trait in <code>WalletImpl&lt;T&gt;</code>. Note that you need to include a generic type in both definitions of the trait and the implementation.</p>
<p>We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for <code>Wallet&lt;u128&gt;</code> instances rather than <code>Wallet&lt;T&gt;</code>. In the code example, we define an implementation for wallets which have a concrete type of <code>u128</code> for the <code>balance</code> field.</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

/// Generic trait for wallets
trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

/// Trait for wallets of type u128
trait WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128) {
        self.balance += value;
    }
}

#[executable]
fn main() {
    let mut w = Wallet { balance: 50 };
    assert!(w.balance() == 50);

    w.receive(100);
    assert!(w.balance() == 150);
}
</code></pre>
<p>The new method <code>receive</code> increments the size of <code>balance</code> of any instance of a <code>Wallet&lt;u128&gt;</code>. Notice that we changed the <code>main</code> function making <code>w</code> a mutable variable in order for it to be able to update its balance. If we were to change the initialization of <code>w</code> by changing the type of <code>balance</code> the previous code wouldn't compile.</p>
<p>Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from <code>Wallet&lt;U, V&gt;</code> we are going to define a trait that picks two wallets of different generic types and creates a new one with a generic type of each. First, let's rewrite the struct definition:</p>
<pre><code class="language-cairo noplayground">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}
</code></pre>
<p>Next, we are going to naively define the mixup trait and implementation:</p>
<pre><code class="language-cairo noplayground">// This does not compile!
trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, U1&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}

</code></pre>
<p>We are creating a trait <code>WalletMixTrait&lt;T1, U1&gt;</code> with the <code>mixup&lt;T2, U2&gt;</code> method which given an instance of <code>Wallet&lt;T1, U1&gt;</code> and <code>Wallet&lt;T2, U2&gt;</code> creates a new <code>Wallet&lt;T1, U2&gt;</code>. As <code>mixup</code> signature specifies, both <code>self</code> and <code>other</code> are getting dropped at the end of the function, which is why this code does not compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the <code>Drop</code> trait for the compiler to know how to drop instances of <code>Wallet&lt;T, U&gt;</code>. The updated implementation is as follows:</p>
<pre><code class="language-cairo">trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, +Drop&lt;T1&gt;, U1, +Drop&lt;U1&gt;&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}
</code></pre>
<p>We add the requirements for <code>T1</code> and <code>U1</code> to be droppable on <code>WalletMixImpl</code> declaration. Then we do the same for <code>T2</code> and <code>U2</code>, this time as part of <code>mixup</code> signature. We can now try the <code>mixup</code> function:</p>
<pre><code class="language-cairo noplayground">#[executable]
fn main() {
    let w1: Wallet&lt;bool, u128&gt; = Wallet { balance: true, address: 10 };
    let w2: Wallet&lt;felt252, u8&gt; = Wallet { balance: 32, address: 100 };

    let w3 = w1.mixup(w2);

    assert!(w3.balance);
    assert!(w3.address == 100);
}
</code></pre>
<p>We first create two instances: one of <code>Wallet&lt;bool, u128&gt;</code> and the other of <code>Wallet&lt;felt252, u8&gt;</code>. Then, we call <code>mixup</code> and create a new <code>Wallet&lt;bool, u8&gt;</code> instance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-in-cairo"><a class="header" href="#traits-in-cairo">Traits in Cairo</a></h1>
<p>A trait defines a set of methods that can be implemented by a type. These methods can be called on instances of the type when this trait is implemented.
A trait combined with a generic type defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way.
We can use <em>trait bounds</em> to specify that a generic type can be any type that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called interfaces in other languages, although with some differences.</p>
</blockquote>
<p>While traits can be written to not accept generic types, they are most useful when used with generic types. We already covered generics in the <a href="./ch08-01-generic-data-types.html">previous chapter</a>, and we will use them in this chapter to demonstrate how traits can be used to define shared behavior for generic types.</p>
<h2 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a Trait</a></h2>
<p>A type’s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have a struct <code>NewsArticle</code> that holds a news story in a particular location. We can define a trait <code>Summary</code> that describes the behavior of something that can summarize the <code>NewsArticle</code> type.</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[derive(Drop, Clone)]
</span><span class="boring">struct NewsArticle {
</span><span class="boring">    headline: ByteArray,
</span><span class="boring">    location: ByteArray,
</span><span class="boring">    author: ByteArray,
</span><span class="boring">    content: ByteArray,
</span><span class="boring">}
</span><span class="boring">
</span>pub trait Summary {
    fn summarize(self: @NewsArticle) -&gt; ByteArray;
}
<span class="boring">
</span><span class="boring">impl NewsArticleSummary of Summary {
</span><span class="boring">    fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">        format!("{:?} by {:?} ({:?})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption"> Listing 8-1: A <code>Summary</code> trait that consists of the behavior provided by a <code>summarize</code> method</span></p>
<p>In Listing 8-1, we declare a trait using the <code>trait</code> keyword and then the trait’s name, which is <code>Summary</code> in this case.
We’ve also declared the trait as <code>pub</code> so that crates depending on this crate can make use of this trait too, as we’ll see in a few examples.</p>
<p>Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is <code>fn summarize(self: @NewsArticle) -&gt; ByteArray;</code>. After the method signature, instead of providing an implementation within curly brackets, we use a semicolon.</p>
<blockquote>
<p>Note: the <code>ByteArray</code> type is the type used to represent strings in Cairo.</p>
</blockquote>
<p>As the trait is not generic, the <code>self</code> parameter is not generic either and is of type <code>@NewsArticle</code>. This means that the <code>summarize</code> method can only be called on instances of <code>NewsArticle</code>.</p>
<p>Now, consider that we want to make a media aggregator library crate named <em>aggregator</em> that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we need a summary from each type, and we’ll request that summary by calling a summarize method on an instance of that type. By defining the <code>Summary</code> trait on generic type <code>T</code>, we can implement the <code>summarize</code> method on any type we want to be able to summarize.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption"> Listing 8-2: A <code>Summary</code> trait that consists of the behavior provided by a <code>summarize</code> method for a generic type</span></p>
<p>Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that implements the <code>Summary</code> trait will have the method <code>summarize</code> defined with this signature exactly.</p>
<p>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</p>
<h2 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></h2>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods,
we can implement it on the types in our media aggregator. The following code shows
an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses
the headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
        fn summarize(self: @NewsArticle) -&gt; ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize(self: @Tweet) -&gt; ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption"> Listing 8-3: Implementation of the <code>Summary</code> trait on <code>NewsArticle</code> and <code>Tweet</code></span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put a name for the implementation,
then use the <code>of</code> keyword, and then specify the name of the trait we are writing the implementation for.
If the implementation is for a generic type, we place the generic type name in the angle brackets after the trait name.</p>
<p>Note that for the trait method to be accessible, there must be an implementation of that trait visible from the scope where the method is called. If the trait is <code>pub</code> and the implementation is not, and the implementation is not visible in the scope where the trait method is called, this will cause a compilation error.</p>
<p>Within the <code>impl</code> block, we put the method signatures
that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific
behavior that we want the methods of the trait to have for the particular type.</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and
<code>Tweet</code>, users of the crate can call the trait methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods. The only
difference is that the user must bring the trait into scope as well as the
types. Here’s an example of how a crate could use our <code>aggregator</code> crate:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary, Tweet};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints the following:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_15_traits
New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
New tweet! EliBenSasson: Crypto is full of short-term maximizing projects.
 @Starknet and @StarkWareLtd are about long-term vision maximization.


</code></pre>
<p>Other crates that depend on the <em>aggregator</em> crate can also bring the <code>Summary</code> trait into scope to implement <code>Summary</code> on their own types.</p>
<h2 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h2>
<p>Sometimes it’s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. Then, as we implement the trait on a particular type, we can keep or override each method’s default behavior.</p>
<p>In Listing 8-5 we specify a default string for the <code>summarize</code> method of the <code>Summary</code> trait instead of only defining the method signature, as we did in Listing 8-2.</p>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray {
            "(Read more...)"
        }
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption"> Listing 8-5: Defining a <code>Summary</code> trait with a default implementation of the <code>summarize</code> method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code>, we specify an empty <code>impl</code> block with <code>impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}</code>.</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code> directly, we’ve provided a default implementation and specified that <code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call the <code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray {
</span><span class="boring">            "(Read more...)"
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation doesn’t require us to change anything about the previous implementation of <code>Summary</code> on <code>Tweet</code>. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation. In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it. For example, we could define the <code>Summary</code> trait to have a <code>summarize_author</code> method whose implementation is required, and then define a <code>summarize</code> method that has a default implementation that calls the <code>summarize_author</code> method:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(
            self: @T,
        ) -&gt; ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code> when we implement the trait on a type:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span>    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize_author(self: @Tweet) -&gt; ByteArray {
            format!("@{}", self.username)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the <code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented <code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the <code>summarize</code> method without requiring us to write any more code.</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{Summary, Tweet};

#[executable]
fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>1 new tweet: (Read more from @EliBenSasson...)</code>.</p>
<p>Note that it isn’t possible to call the default implementation from an overriding implementation of that same method.</p>
<!-- TODO: NOT AVAILABLE IN CAIRO FOR NOW move traits as parameters here -->
<!-- ## Traits as parameters

Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types. We'll use the
`Summary` trait we implemented on the `NewsArticle` and `Tweet` types to define a `notify` function that calls the `summarize` method
on its `item` parameter, which is of some type that implements the `Summary` trait. To do this, we use the `impl Trait` syntax.

Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`. -->
<!-- TODO NOT AVAILABLE IN CAIRO FOR NOW Using trait bounds to conditionally implement methods -->
<h2 id="managing-and-using-external-trait"><a class="header" href="#managing-and-using-external-trait">Managing and Using External Trait</a></h2>
<p>To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules.
If <code>CircleGeometry</code> implementation was in a separate module/file named <em>circle</em>, then to define <code>boundary</code> method on <code>Circle</code> struct, we'd need to import <code>ShapeGeometry</code> trait in the <em>circle</em> module.</p>
<p>If the code were to be organized into modules like in Listing 8-6 where the implementation of a trait is defined in a different module than the trait itself, explicitly importing the relevant trait or implementation would be required.</p>
<pre><code class="language-cairo noplayground">// Here T is an alias type which will be provided during implementation
pub trait ShapeGeometry&lt;T&gt; {
    fn boundary(self: T) -&gt; u64;
    fn area(self: T) -&gt; u64;
}

mod rectangle {
    // Importing ShapeGeometry is required to implement this trait for Rectangle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Rectangle {
        pub height: u64,
        pub width: u64,
    }

    // Implementation RectangleGeometry passes in &lt;Rectangle&gt;
    // to implement the trait for that type
    impl RectangleGeometry of ShapeGeometry&lt;Rectangle&gt; {
        fn boundary(self: Rectangle) -&gt; u64 {
            2 * (self.height + self.width)
        }
        fn area(self: Rectangle) -&gt; u64 {
            self.height * self.width
        }
    }
}

mod circle {
    // Importing ShapeGeometry is required to implement this trait for Circle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Circle {
        pub radius: u64,
    }

    // Implementation CircleGeometry passes in &lt;Circle&gt;
    // to implement the imported trait for that type
    impl CircleGeometry of ShapeGeometry&lt;Circle&gt; {
        fn boundary(self: Circle) -&gt; u64 {
            (2 * 314 * self.radius) / 100
        }
        fn area(self: Circle) -&gt; u64 {
            (314 * self.radius * self.radius) / 100
        }
    }
}
use circle::Circle;
use rectangle::Rectangle;

#[executable]
fn main() {
    let rect = Rectangle { height: 5, width: 7 };
    println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
    println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24

    let circ = Circle { radius: 5 };
    println!("Circle area: {}", ShapeGeometry::area(circ)); //78
    println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
}
</code></pre>
<p><span class="caption"> Listing 8-6: Implementing an external trait</span></p>
<p>Note that in Listing 8-6, <code>CircleGeometry</code> and <code>RectangleGeometry</code> implementations don't need to be declared as <code>pub</code>. Indeed, <code>ShapeGeometry</code> trait, which is public, is used to print the result in the <code>main</code> function. The compiler will find the appropriate implementation for the <code>ShapeGeometry</code> public trait, regardless of the implementation visibility.</p>
<h2 id="impl-aliases"><a class="header" href="#impl-aliases">Impl Aliases</a></h2>
<p>Implementations can be aliased when imported. This is most useful when you want to instantiate generic implementations with concrete types. For example, let's say we define a trait <code>Two</code> that is used to return the value <code>2</code> for a type <code>T</code>. We can write a trivial generic implementation of <code>Two</code> for all types that implement the <code>One</code> trait, simply by adding twice the value of <code>one</code> and returning it. However, in our public API, we may only want to expose the <code>Two</code> implementation for the <code>u8</code> and <code>u128</code> types.</p>
<pre><code class="language-cairo noplayground">trait Two&lt;T&gt; {
    fn two() -&gt; T;
}

mod one_based {
    pub impl TwoImpl&lt;
        T, +Copy&lt;T&gt;, +Drop&lt;T&gt;, +Add&lt;T&gt;, impl One: core::num::traits::One&lt;T&gt;,
    &gt; of super::Two&lt;T&gt; {
        fn two() -&gt; T {
            One::one() + One::one()
        }
    }
}

pub impl U8Two = one_based::TwoImpl&lt;u8&gt;;
pub impl U128Two = one_based::TwoImpl&lt;u128&gt;;
</code></pre>
<p><span class="caption"> Listing 8-7: Using impl aliases to instantiate generic impls with concrete types</span></p>
<p>We can define the generic implementation in a private module, use an impl alias to instantiate the generic implementation for these two concrete types, and make these two implementations public, while keeping the generic implementation private and unexposed. This way, we can avoid code duplication using the generic implementation, while keeping the public API clean and simple.</p>
<h2 id="negative-impls"><a class="header" href="#negative-impls">Negative Impls</a></h2>
<blockquote>
<p>Note: This is still an experimental feature and can only be used if <code>experimental-features = ["negative_impls"]</code> is enabled in your <em>Scarb.toml</em> file, under the <code>[package]</code> section.</p>
</blockquote>
<p>Negative implementations, also known as negative traits or negative bounds, are a mechanism that allows you to express that a type does not implement a certain trait when defining the implementation of a trait over a generic type. Negative impls enable you to write implementations that are applicable only when another implementation does not exist in the current scope.</p>
<p>For example, let's say we have a trait <code>Producer</code> and a trait <code>Consumer</code>, and we want to define a generic behavior where all types implement the <code>Consumer</code> trait by default. However, we want to ensure that no type can be both a <code>Consumer</code> and a <code>Producer</code>. We can use negative impls to express this restriction.</p>
<p>In Listing 8-8, we define a <code>ProducerType</code> that implements the <code>Producer</code> trait, and two other types, <code>AnotherType</code> and <code>AThirdType</code>, which do not implement the <code>Producer</code> trait. We then use negative impls to create a default implementation of the <code>Consumer</code> trait for all types that do not implement the <code>Producer</code> trait.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct ProducerType {}

#[derive(Drop, Debug)]
struct AnotherType {}

#[derive(Drop, Debug)]
struct AThirdType {}

trait Producer&lt;T&gt; {
    fn produce(self: T) -&gt; u32;
}

trait Consumer&lt;T&gt; {
    fn consume(self: T, input: u32);
}

impl ProducerImpl of Producer&lt;ProducerType&gt; {
    fn produce(self: ProducerType) -&gt; u32 {
        42
    }
}

impl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {
    fn consume(self: T, input: u32) {
        println!("{:?} consumed value: {}", self, input);
    }
}

#[executable]
fn main() {
    let producer = ProducerType {};
    let another_type = AnotherType {};
    let third_type = AThirdType {};
    let production = producer.produce();

    // producer.consume(production); Invalid: ProducerType does not implement Consumer
    another_type.consume(production);
    third_type.consume(production);
}
</code></pre>
<p><span class="caption"> Listing 8-8: Using negative impls to enforce that a type cannot implement both <code>Producer</code> and <code>Consumer</code> traits simultaneously</span></p>
<p>In the <code>main</code> function, we create instances of <code>ProducerType</code>, <code>AnotherType</code>, and <code>AThirdType</code>. We then call the <code>produce</code> method on the <code>producer</code> instance and pass the result to the <code>consume</code> method on the <code>another_type</code> and <code>third_type</code> instances. Finally, we try to call the <code>consume</code> method on the <code>producer</code> instance, which results in a compile-time error because <code>ProducerType</code> does not implement the <code>Consumer</code> trait.</p>
<h2 id="constraint-traits-on-associated-items"><a class="header" href="#constraint-traits-on-associated-items">Constraint traits on associated items</a></h2>
<blockquote>
<p>Currently, associated items are considered an experimental feature. In order to use them, you need to add the following to your <code>Scarb.toml</code> under the <code>[package]</code> section: <code>experimental-features = ["associated_item_constraints"]</code>.</p>
</blockquote>
<p>In some cases, you may want to constrain the <a href="./ch12-10-associated-items.html">associated items</a> of a trait based on the type of the generic parameter. You can do this using the <code>[AssociatedItem: ConstrainedValue]</code> syntax after a trait bound.</p>
<p>Let's say you want to implement an <code>extend</code> method for collections. This method takes an iterator and add its elements to the collection. To ensure type safety, we want the iterator's elements to match the collection's element type. We can achieve this by constraining the <code>Iterator::Item</code> associated type to match the collection's type.</p>
<p>In Listing 8-9, we implement this by defining a trait <code>Extend&lt;T, A&gt;</code> and use <code>[Item: A]</code> as a constraint on the <code>extend</code> function's trait bound. Additionally, we use the <code>Destruct</code> trait to ensure that the iterator is consumed, and show an example implementation for <code>Extend&lt;Array&lt;T&gt;, T&gt;</code>.</p>
<pre><code class="language-cairo">trait Extend&lt;T, A&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: A], +Destruct&lt;I&gt;&gt;(ref self: T, iterator: I);
}

impl ArrayExtend&lt;T, +Drop&lt;T&gt;&gt; of Extend&lt;Array&lt;T&gt;, T&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: T], +Destruct&lt;I&gt;&gt;(ref self: Array&lt;T&gt;, iterator: I) {
        for item in iterator {
            self.append(item);
        }
    }
}
</code></pre>
<p><span class="caption"> Listing 8-9: Using associated items constraints to ensure that a type matches the associated type of another type</span></p>
<h2 id="typeequal-trait-for-type-equality-constraints"><a class="header" href="#typeequal-trait-for-type-equality-constraints"><code>TypeEqual</code> Trait for type equality constraints</a></h2>
<p>The <code>TypeEqual</code> trait from the <code>core::metaprogramming</code> module lets you create constraints based on type equality. In most of the cases, you don't need <code>+TypeEqual</code> and you can achieve the same using only generic arguments and associated type constraints, but <code>TypeEqual</code> can be useful in some advanced scenarios.</p>
<p>The first use case is implementing a trait for all types that match certain conditions, except for specific types. We do this using a negative implementation on the <code>TypeEqual</code> trait.</p>
<p>In Listing 8-10, we create a <code>SafeDefault</code> trait and implement it for any type <code>T</code> that implements <code>Default</code>. However, we exclude the <code>SensitiveData</code> type using <code>-TypeEqual&lt;T, SensitiveData&gt;</code>.</p>
<pre><code class="language-cairo">trait SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T;
}

#[derive(Drop, Default)]
struct SensitiveData {
    secret: felt252,
}

// Implement SafeDefault for all types EXCEPT SensitiveData
impl SafeDefaultImpl&lt;
    T, +Default&lt;T&gt;, -core::metaprogramming::TypeEqual&lt;T, SensitiveData&gt;,
&gt; of SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T {
        Default::default()
    }
}

#[executable]
fn main() {
    let _safe: u8 = SafeDefault::safe_default();
    let _unsafe: SensitiveData = Default::default(); // Allowed
    // This would cause a compile error:
// let _dangerous: SensitiveData = SafeDefault::safe_default();
}
</code></pre>
<p><span class="caption"> Listing 8-10: Using the <code>TypeEqual</code> trait to exclude a specific type from an implementation</span></p>
<p>The second use case is ensuring that two types are equal, particularly useful when working with <a href="./ch12-10-associated-items.html#associated-types">associated types</a>.</p>
<p>In Listing 8-11, we show this with a <code>StateMachine</code> trait that has an associated type <code>State</code>. We create two types, <code>TA</code> and <code>TB</code>, both using <code>StateCounter</code> as their <code>State</code>. Then we implement a <code>combine</code> function that works only when both state machines have the same state type, using the bound <code>TypeEqual&lt;A::State, B::State&gt;</code>.</p>
<pre><code class="language-cairo">trait StateMachine {
    type State;
    fn transition(ref state: Self::State);
}

#[derive(Copy, Drop)]
struct StateCounter {
    counter: u8,
}

impl TA of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter += 1;
    }
}

impl TB of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter *= 2;
    }
}

fn combine&lt;
    impl A: StateMachine,
    impl B: StateMachine,
    +core::metaprogramming::TypeEqual&lt;A::State, B::State&gt;,
&gt;(
    ref self: A::State,
) {
    A::transition(ref self);
    B::transition(ref self);
}

#[executable]
fn main() {
    let mut initial = StateCounter { counter: 0 };
    combine::&lt;TA, TB&gt;(ref initial);
}
</code></pre>
<p><span class="caption"> Listing 8-11: Using the <code>TypeEqual</code> trait to ensure two types have matching associated types</span></p>
<p>{{#quiz ../quizzes/ch08-02-traits.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you to address potential issues in your code, but also make it easier to create programs that are adaptable and maintainable. By examining different approaches to managing errors, such as pattern matching with the <code>Result</code> enum, using the <code>?</code> operator for more ergonomic error propagation, and employing the <code>unwrap</code> or <code>expect</code> methods for handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. These concepts are crucial for building robust applications that can effectively handle unexpected situations, ensuring your code is ready for production.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unrecoverable-errors-with-panic"><a class="header" href="#unrecoverable-errors-with-panic">Unrecoverable Errors with <code>panic</code></a></h1>
<p>In Cairo, unexpected issues may arise during program execution, resulting in runtime errors. While the <code>panic</code> function from the core library doesn't provide a resolution for these errors, it does acknowledge their occurrence and terminates the program. There are two primary ways that a panic can be triggered in Cairo: inadvertently, through actions causing the code to panic (e.g., accessing an array beyond its bounds), or deliberately, by invoking the <code>panic</code> function.</p>
<p>When a panic occurs, it leads to an abrupt termination of the program. The <code>panic</code> function takes an array as an argument, which can be used to provide an error message and performs an unwind process where all variables are dropped and dictionaries squashed to ensure the soundness of the program to safely terminate the execution.</p>
<p>Here is how we can call <code>panic</code> from inside a program and return the error code <code>2</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut data = array![2];

    if true {
        panic(data);
    }
    println!("This line isn't reached");
}
</code></pre>
<p>Running the program will produce the following output:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_01_panic v0.1.0 (listings/ch09-error-handling/no_listing_01_panic/Scarb.toml)
    Finished `dev` profile target(s) in 0 seconds
   Executing no_listing_01_panic
error: Panicked with 0x2.

</code></pre>
<p>As you can notice in the output, the call to <code>println!</code> macro is never reached, as the program terminates after encountering the <code>panic</code> statement.</p>
<p>An alternative and more idiomatic approach to panic in Cairo would be to use the <code>panic_with_felt252</code> function. This function serves as an abstraction of the array-defining process and is often preferred due to its clearer and more concise expression of intent. By using <code>panic_with_felt252</code>, developers can panic in a one-liner by providing a <code>felt252</code> error message as an argument, making the code more readable and maintainable.</p>
<p>Let's consider an example:</p>
<pre><code class="language-cairo">use core::panic_with_felt252;

#[executable]
fn main() {
    panic_with_felt252(2);
}
</code></pre>
<p>Executing this program will yield the same error message as before. In that case, if there is no need for an array and multiple values to be returned within the error, <code>panic_with_felt252</code> is a more succinct alternative.</p>
<h2 id="panic-macro"><a class="header" href="#panic-macro"><code>panic!</code> Macro</a></h2>
<p><code>panic!</code> macro can be really helpful. The previous example returning the error code <code>2</code> shows how convenient <code>panic!</code> macro is. There is no need to create an array and pass it as an argument like with the <code>panic</code> function.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    if true {
        panic!("2");
    }
    println!("This line isn't reached");
}
</code></pre>
<p>Unlike the <code>panic_with_felt252</code> function, using <code>panic!</code> allows the input, which is ultimately the panic error, to be a literal longer than 31 bytes. This is because <code>panic!</code> takes a string as a parameter. For example, the following line of code will successfully compile:</p>
<pre><code class="language-cairo  noplayground">panic!("the error for panic! macro is not limited to 31 characters anymore");
</code></pre>
<h2 id="nopanic-notation"><a class="header" href="#nopanic-notation"><code>nopanic</code> Notation</a></h2>
<p>You can use the <code>nopanic</code> notation to indicate that a function will never panic. Only <code>nopanic</code> functions can be called in a function annotated as <code>nopanic</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() -&gt; felt252 nopanic {
    42
}
</code></pre>
<p>This function will always return <code>42</code> and is guaranteed to never panic. Conversely, the following function is not guaranteed to never panic:</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() nopanic {
    assert!(1 == 1, "what");
}
</code></pre>
<p>If you try to compile this function that includes code that may panic, you will get the following error:</p>
<pre><code class="language-shell">$ scarb execute
   Compiling no_listing_04_nopanic_wrong v0.1.0 (listings/ch09-error-handling/no_listing_05_nopanic_wrong/Scarb.toml)
error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:13
    assert!(1 == 1, "what");
            ^^^^^^

error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:5
    assert!(1 == 1, "what");
    ^^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `no_listing_04_nopanic_wrong` due to previous error
error: `scarb metadata` exited with error

</code></pre>
<p>Note that there are two functions that may panic here, <code>assert</code> and equality with <code>==</code>. We usually don't use <code>assert</code> function in practice and use <code>assert!</code> macro instead. We will discuss <code>assert!</code> macro in more detail in the <a href="./ch10-01-how-to-write-tests.html#checking-results-with-the-assert-macro">Testing Cairo Programs</a> chapter.</p>
<h2 id="panic_with-attribute"><a class="header" href="#panic_with-attribute"><code>panic_with</code> Attribute</a></h2>
<p>You can use the <code>panic_with</code> attribute to mark a function that returns an <code>Option</code> or <code>Result</code>. This attribute takes two arguments, which are the data that is passed as the panic reason as well as the name for a wrapping function. It will create a wrapper for your annotated function which will panic if the function returns <code>None</code> or <code>Err</code>, with the given data as the panic error.</p>
<p>Example:</p>
<pre><code class="language-cairo">#[panic_with('value is 0', wrap_not_zero)]
fn wrap_if_not_zero(value: u128) -&gt; Option&lt;u128&gt; {
    if value == 0 {
        None
    } else {
        Some(value)
    }
}

#[executable]
fn main() {
    wrap_if_not_zero(0); // this returns None
    wrap_not_zero(0); // this panics with 'value is 0'
}
</code></pre>
<p>{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recoverable-errors-with-result"><a class="header" href="#recoverable-errors-with-result">Recoverable Errors with <code>Result</code></a></h1>
<p>Most errors aren’t serious enough to require the program to stop entirely. Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to. For example, if you try to add two large integers and the operation overflows because the sum exceeds the maximum representable value, you might want to return an error or a wrapped result instead of causing undefined behavior or terminating the process.</p>
<h2 id="the-result-enum"><a class="header" href="#the-result-enum">The <code>Result</code> Enum</a></h2>
<p>Recall from <a href="./ch08-01-generic-data-types.html#enums">Generic data types</a> section in Chapter 8 that the <code>Result</code> enum is defined as having two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum has two generic types, <code>T</code> and <code>E</code>, and two variants: <code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type <code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we have an operation that might succeed (by returning a value of type <code>T</code>) or fail (by returning a value of type <code>E</code>).</p>
<h2 id="the-resulttrait"><a class="header" href="#the-resulttrait">The <code>ResultTrait</code></a></h2>
<p>The <code>ResultTrait</code> trait provides methods for working with the <code>Result&lt;T, E&gt;</code> enum, such as unwrapping values, checking whether the <code>Result</code> is <code>Ok</code> or <code>Err</code>, and panicking with a custom message. The <code>ResultTraitImpl</code> implementation defines the logic of these methods.</p>
<pre><code class="language-cairo noplayground">trait ResultTrait&lt;T, E&gt; {
    fn expect&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; T;

    fn unwrap&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T;

    fn expect_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; E;

    fn unwrap_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; E;

    fn is_ok(self: @Result&lt;T, E&gt;) -&gt; bool;

    fn is_err(self: @Result&lt;T, E&gt;) -&gt; bool;
}
</code></pre>
<p>The <code>expect</code> and <code>unwrap</code> methods are similar in that they both attempt to extract the value of type <code>T</code> from a <code>Result&lt;T, E&gt;</code> when it is in the <code>Ok</code> variant. If the <code>Result</code> is <code>Ok(x)</code>, both methods return the value <code>x</code>. However, the key difference between the two methods lies in their behavior when the <code>Result</code> is in the <code>Err</code> variant. The <code>expect</code> method allows you to provide a custom error message (as a <code>felt252</code> value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the <code>unwrap</code> method panics with a default error message, providing less information about the cause of the panic.</p>
<p>The <code>expect_err</code> and <code>unwrap_err</code> methods have the exact opposite behavior. If the <code>Result</code> is <code>Err(x)</code>, both methods return the value <code>x</code>. However, the key difference between the two methods is in case of <code>Ok()</code>. The <code>expect_err</code> method allows you to provide a custom error message (as a <code>felt252</code> value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the <code>unwrap_err</code> method panics with a default error message, providing less information about the cause of the panic.</p>
<p>A careful reader may have noticed the <code>&lt;+Drop&lt;T&gt;&gt;</code> and <code>&lt;+Drop&lt;E&gt;&gt;</code> in the first four methods signatures. This syntax represents generic type constraints in the Cairo language, as seen in the previous chapter. These constraints indicate that the associated functions require an implementation of the <code>Drop</code> trait for the generic types <code>T</code> and <code>E</code>, respectively.</p>
<p>Finally, the <code>is_ok</code> and <code>is_err</code> methods are utility functions provided by the <code>ResultTrait</code> trait to check the variant of a <code>Result</code> enum value.</p>
<ul>
<li><code>is_ok</code> takes a snapshot of a <code>Result&lt;T, E&gt;</code> value and returns <code>true</code> if the <code>Result</code> is the <code>Ok</code> variant, meaning the operation was successful. If the <code>Result</code> is the <code>Err</code> variant, it returns <code>false</code>.</li>
<li><code>is_err</code> takes a snapshot of a <code>Result&lt;T, E&gt;</code> value and returns <code>true</code> if the <code>Result</code> is the <code>Err</code> variant, meaning the operation encountered an error. If the <code>Result</code> is the <code>Ok</code> variant, it returns <code>false</code>.</li>
</ul>
<p>These methods are helpful when you want to check the success or failure of an operation without consuming the <code>Result</code> value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it.</p>
<p>You can find the implementation of the <code>ResultTrait</code> <a href="https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20">here</a>.</p>
<p>It is always easier to understand with examples. Have a look at this function signature:</p>
<pre><code class="language-cairo noplayground">fn u128_overflowing_add(a: u128, b: u128) -&gt; Result&lt;u128, u128&gt;;
</code></pre>
<p>It takes two <code>u128</code> integers, <code>a</code> and <code>b</code>, and returns a <code>Result&lt;u128, u128&gt;</code> where the <code>Ok</code> variant holds the sum if the addition does not overflow, and the <code>Err</code> variant holds the overflowed value if the addition does overflow.</p>
<p>Now, we can use this function elsewhere. For instance:</p>
<pre><code class="language-cairo noplayground">fn u128_checked_add(a: u128, b: u128) -&gt; Option&lt;u128&gt; {
    match u128_overflowing_add(a, b) {
        Ok(r) =&gt; Some(r),
        Err(r) =&gt; None,
    }
}

</code></pre>
<p>Here, it accepts two <code>u128</code> integers, <code>a</code> and <code>b</code>, and returns an <code>Option&lt;u128&gt;</code>. It uses the <code>Result</code> returned by <code>u128_overflowing_add</code> to determine the success or failure of the addition operation. The <code>match</code> expression checks the <code>Result</code> from <code>u128_overflowing_add</code>. If the result is <code>Ok(r)</code>, it returns <code>Some(r)</code> containing the sum. If the result is <code>Err(r)</code>, it returns <code>None</code> to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow.</p>
<p>Let's take another example:</p>
<pre><code class="language-cairo noplayground">fn parse_u8(s: felt252) -&gt; Result&lt;u8, felt252&gt; {
    match s.try_into() {
        Some(value) =&gt; Ok(value),
        None =&gt; Err('Invalid integer'),
    }
}
</code></pre>
<p>In this example, the <code>parse_u8</code> function takes a <code>felt252</code> and tries to convert it into a <code>u8</code> integer using the <code>try_into</code> method. If successful, it returns <code>Ok(value)</code>, otherwise it returns <code>Err('Invalid integer')</code>.</p>
<p>Our two test cases are:</p>
<pre><code class="language-cairo noplayground"><span class="boring">fn parse_u8(s: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    match s.try_into() {
</span><span class="boring">        Some(value) =&gt; Ok(value),
</span><span class="boring">        None =&gt; Err('Invalid integer'),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Don't worry about the <code>#[cfg(test)]</code> attribute for now. We'll explain in more detail its meaning in the next <a href="./ch10-01-how-to-write-tests.html">Testing Cairo Programs</a> chapter.</p>
<p><code>#[test]</code> attribute means the function is a test function, and <code>#[should_panic]</code> attribute means this test will pass if the test execution panics.</p>
<p>The first one tests a valid conversion from <code>felt252</code> to <code>u8</code>, expecting the <code>unwrap</code> method not to panic. The second test function attempts to convert a value that is out of the <code>u8</code> range, expecting the <code>unwrap</code> method to panic with the error message <code>Invalid integer</code>.</p>
<h2 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating Errors</a></h2>
<p>When a function’s implementation calls something that might fail, instead of handling the error within the function itself you can return the error to the calling code so that it can decide what to do. This is known as <em>propagating</em> the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>For example, Listing 9-1 shows an implementation of a function that tries to parse a number as <code>u8</code> and uses a match expression to handle a potential error.</p>
<pre><code class="language-cairo  noplayground">// A hypothetical function that might fail
fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_u256: u256 = input.into();
    if input_u256 &lt; 256 {
        Result::Ok(input.try_into().unwrap())
    } else {
        Result::Err('Invalid Integer')
    }
}

fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8 = match parse_u8(input) {
        Result::Ok(num) =&gt; num,
        Result::Err(err) =&gt; { return Result::Err(err); },
    };
    let res = input_to_u8 - 1;
    Result::Ok(res)
}
</code></pre>
<p><span class="caption">Listing 9-1: A function that returns errors to the calling code using a <code>match</code> expression.</span></p>
<p>The code that calls this <code>parse_u8</code> will handle getting either an <code>Ok</code> value that contains a number or an <code>Err</code> value that contains an error message. It’s up to the calling code to decide what to do with those values. If the calling code gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, or use a default value. We don’t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</p>
<p>This pattern of propagating errors is so common in Cairo that Cairo provides the question mark operator <code>?</code> to make this easier.</p>
<h2 id="a-shortcut-for-propagating-errors-the--operator"><a class="header" href="#a-shortcut-for-propagating-errors-the--operator">A Shortcut for Propagating Errors: the <code>?</code> Operator</a></h2>
<p>Listing 9-2 shows an implementation of <code>mutate_byte</code> that has the same functionality as the one in Listing 9-1 but uses the <code>?</code> operator to gracefully handle errors.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">// A hypothetical function that might fail
</span><span class="boring">fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    let input_u256: u256 = input.into();
</span><span class="boring">    if input_u256 &lt; 256 {
</span><span class="boring">        Result::Ok(input.try_into().unwrap())
</span><span class="boring">    } else {
</span><span class="boring">        Result::Err('Invalid Integer')
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8: u8 = parse_u8(input)?;
    let res = input_to_u8 - 1;
    Ok(res)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_function_2() {
</span><span class="boring">        let number: felt252 = 258;
</span><span class="boring">        match mutate_byte(number) {
</span><span class="boring">            Ok(value) =&gt; println!("Result: {}", value),
</span><span class="boring">            Err(e) =&gt; println!("Error: {}", e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 9-2: A function that returns errors to the calling code using the <code>?</code> operator.</span></p>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way as the <code>match</code> expressions we defined to handle the <code>Result</code> values in Listing 1. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will get returned from this expression, and the program will continue. If the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used the <code>return</code> keyword so the error value gets propagated to the calling code.</p>
<p>In the context of Listing 2, the <code>?</code> at the end of the <code>parse_u8</code> call will return the value inside an <code>Ok</code> to the variable <code>input_to_u8</code>. If an error occurs, the <code>?</code> operator will return early out of the whole function and give any <code>Err</code> value to the calling code.</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function’s implementation simpler and more ergonomic.</p>
<h3 id="where-the--operator-can-be-used"><a class="header" href="#where-the--operator-can-be-used">Where The <code>?</code> Operator Can Be Used</a></h3>
<p>The <code>?</code> operator can only be used in functions whose return type is compatible with the value the <code>?</code> is used on. This is because the <code>?</code> operator is defined to perform an early return of a value out of the function, in the same manner as the <code>match</code> expression we defined in Listing 9-1. In Listing 9-1, the <code>match</code> was using a <code>Result</code> value, and the early return arm returned an <code>Err(e)</code> value. The return type of the function has to be a <code>Result</code> so that it’s compatible with this return.</p>
<p>In Listing 9-3, let’s look at the error we’ll get if we use the <code>?</code> operator in a function with a return type that is incompatible with the type of the value we use <code>?</code> on.</p>
<pre><code class="language-cairo"><span class="boring">//TAG: does_not_compile
</span><span class="boring">
</span>#[executable]
fn main() {
    let some_num = parse_u8(258)?;
}
<span class="boring">
</span><span class="boring">fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    let input_u256: u256 = input.into();
</span><span class="boring">    if input_u256 &lt; 256 {
</span><span class="boring">        Result::Ok(input.try_into().unwrap())
</span><span class="boring">    } else {
</span><span class="boring">        Result::Err('Invalid Integer')
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 9-3: Attempting to use the <code>?</code> in a <code>main</code> function that returns <code>()</code> won’t compile.</span></p>
<p>This code calls a function that might fail. The <code>?</code> operator follows the <code>Result</code> value returned by <code>parse_u8</code>, but this <code>main</code> function has the return type of <code>()</code>, not <code>Result</code>. When we compile this code, we get an error message similar to this:</p>
<pre><code class="language-text">$ scarb build
   Compiling listing_invalid_qmark v0.1.0 (listings/ch09-error-handling/listing_invalid_qmark/Scarb.toml)
error: `?` can only be used in a function with `Option` or `Result` return type.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:4:20
    let some_num = parse_u8(258)?;
                   ^^^^^^^^^^^^^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:4:9
    let some_num = parse_u8(258)?;
        ^^^^^^^^

error: could not compile `listing_invalid_qmark` due to previous error

</code></pre>
<p>This error points out that we’re only allowed to use the <code>?</code> operator in a function that returns <code>Result</code> or <code>Option</code>.</p>
<p>To fix the error, you have two choices. One choice is to change the return type of your function to be compatible with the value you’re using the <code>?</code> operator on as long as you have no restrictions preventing that. The other choice is to use a <code>match</code> to handle the <code>Result&lt;T, E&gt;</code> in whatever way is appropriate.</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values as well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>: if the value is <code>None</code>, the <code>None</code> will be returned early from the function at that point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the resultant value of the expression, and the function continues.</p>
<h3 id="summary-4"><a class="header" href="#summary-4">Summary</a></h3>
<p>We saw that recoverable errors can be handled in Cairo using the <code>Result</code> enum, which has two variants: <code>Ok</code> and <code>Err</code>. The <code>Result&lt;T, E&gt;</code> enum is generic, with types <code>T</code> and <code>E</code> representing the successful and error values, respectively. The <code>ResultTrait</code> provides methods for working with <code>Result&lt;T, E&gt;</code>, such as unwrapping values, checking if the result is <code>Ok</code> or <code>Err</code>, and panicking with custom messages.</p>
<p>To handle recoverable errors, a function can return a <code>Result</code> type and use pattern matching to handle the success or failure of an operation. The <code>?</code> operator can be used to implicitly handle errors by propagating the error or unwrapping the successful value. This allows for more concise and clear error handling, where the caller is responsible for managing errors raised by the called function.</p>
<p>{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-cairo-programs"><a class="header" href="#testing-cairo-programs">Testing Cairo Programs</a></h1>
<p>Correctness in our programs is the extent to which our code does what we intend it to do. Cairo is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Cairo's linear type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Cairo includes support for writing tests.</p>
<p>Testing is a complex skill: although we can’t cover every detail about how to write good tests in one chapter, we’ll discuss the mechanics of Cairo's testing facilities. We’ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How To Write Tests</a></h1>
<h2 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h2>
<p>Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ul>
<p>Let’s look at the features Cairo provides for writing tests that take these actions, which include:</p>
<ul>
<li><code>#[test]</code> attribute.</li>
<li><code>assert!</code>macro.</li>
<li><code>assert_eq!</code>, <code>assert_ne!</code>, <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> macros. In order to use them, you will need to add <code>assert_macros = "2.8.2"</code> as a dev dependency.</li>
<li><code>#[should_panic]</code> attribute.</li>
</ul>
<blockquote>
<p>Note: Make sure to select Starknet Foundry as a test runner when creating your project.</p>
</blockquote>
<h3 id="the-anatomy-of-a-test-function-1"><a class="header" href="#the-anatomy-of-a-test-function-1">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Cairo is a function that’s annotated with the <code>#[test]</code> attribute. Attributes are metadata about pieces of Cairo code; one example is the <code>#[derive()]</code> attribute we used with structs in <a href="./ch05-01-defining-and-instantiating-structs.html">Chapter 5</a>. To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your tests with the <code>scarb test</code> command, Scarb runs Starknet Foundry's test runner binary that runs the annotated functions and reports on whether each test function passes or fails.</p>
<p>Let's create a new project called <em>adder</em> using Scarb with the command <code>scarb new adder</code>. Remove the <em>tests</em> folder.</p>
<pre><code class="language-shell">adder
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<p>In <em>lib.cairo</em>, let's remove the existing content and add a <code>tests</code> module containing the first test, as shown in Listing 10-1.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p><span class="caption">Listing 10-1: A simple test function</span></p>
<p>Note the <code>#[test]</code> annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.</p>
<p>We use the <code>#[cfg(test)]</code> attribute for the <code>tests</code> module, so that the compiler knows the code it contains needs to be compiled only when running tests. This is actually not an option: if you put a simple test with the <code>#[test]</code> attribute in a <em>lib.cairo</em> file, it will not compile. We will talk more about the <code>#[cfg(test)]</code> attribute in the next <a href="./ch10-02-test-organization.html">Test Organization</a> section.</p>
<p>The example function body uses the <code>assert_eq!</code> macro, which contains the result of adding 2 and 2, which equals 4. This assertion serves as an example of the format for a typical test. We'll explain in more detail how <code>assert_eq!</code> works later in this chapter. Let’s run it to see that this test passes.</p>
<p>The <code>scarb test</code> command runs all tests found in our project, and shows the following output:</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 2 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_01/target/dev/listing_10_01_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p><code>scarb test</code> compiled and ran the test. We see the line <code>Collected 1 test(s) from adder package</code> followed by the line <code>Running 1 test(s) from src/</code>. The next line shows the name of the test function, called <code>it_works</code>, and that the result of running that test is <code>ok</code>. The test runner also provides an estimation of the gas consumption. The overall summary shows that all the tests passed, and the portion that reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the <a href="ch10-01-how-to-write-tests.html#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a> section later in this chapter. Because we haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an argument to the <code>scarb test</code> command to run only a test whose name matches a string; this is called filtering and we’ll cover that in the <a href="ch10-01-how-to-write-tests.html#running-single-tests">Running Single Tests</a> section. Since we haven’t filtered the tests being run, the end of the summary shows <code>0 filtered out</code>.</p>
<p>Let’s start to customize the test to our own needs. First change the name of the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
</code></pre>
<p>Then run <code>scarb test</code> again. The output now shows <code>exploration</code> instead of <code>it_works</code>:</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 2 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_01/target/dev/listing_10_01_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named <code>another</code>, so your <em>src/lib.cairo</em> file looks like in Listing 10-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        let result = 2 + 2;
        assert!(result == 6, "Make this test fail");
    }
}
</code></pre>
<p><span class="caption">Listing 10-2: Adding a second test in <em>lib.cairo</em> that will fail</span></p>
<p>Run <code>scarb test</code> and you will see the following output:</p>
<pre><code class="language-shell">Collected 2 test(s) from adder package
Running 2 test(s) from src/
[FAIL] adder::tests::another

Failure data:
    "Make this test fail"

[PASS] adder::tests::exploration (gas: ~1)
Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out

Failures:
    adder::tests::another
</code></pre>
<p>Instead of <code>[PASS]</code>, the line <code>adder::tests::another</code> shows <code>[FAIL]</code>. A new section appears between the individual results and the summary. It displays the detailed reason for each test failure. In this case, we get the details that <code>another</code> failed because it panicked with <code>"Make this test fail"</code> error.</p>
<p>After that, the summary line is displayed: we had one test pass and one test fail. At the end, we see a list of the failing tests.</p>
<p>Now that you've seen what the test results look like in different scenarios, let’s look at some functions that are useful in tests.</p>
<h2 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h2>
<p>The <code>assert!</code> macro, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to <code>true</code>. We give the <code>assert!</code> macro the first argument that evaluates to a boolean. If the value is <code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the <code>assert!</code> macro calls <code>panic()</code> to cause the test to fail with a message we defined as the second argument. Using the <code>assert!</code> macro helps us check that our code is functioning in the way we intended.</p>
<p>Remember in <a href="./ch05-03-method-syntax.html">Chapter 5</a>, we used a <code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing 10-3. Let’s put this code in the <em>src/lib.cairo</em> file, then write some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p><span class="caption">Listing 10-3: Using the <code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter 5</span></p>
<p>The <code>can_hold</code> method returns a <code>bool</code>, which means it’s a perfect use case for the <code>assert!</code> macro. We can write a test that exercises the <code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of <code>8</code> and a height of <code>7</code> and asserting that it can hold another <code>Rectangle</code> instance that has a width of <code>5</code> and a height of <code>1</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
    }
}
<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is
a regular module that follows the usual visibility rules we covered in Chapter
7 in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here, so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two <code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and passed it the result of calling <code>larger.can_hold(@smaller)</code>. This expression is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_03/target/dev/listing_10_03_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 10-4: Adding another test in <em>lib.cairo</em> that will pass</span></p>
<p>Because the correct result of the <code>can_hold</code> method, in this case, is <code>false</code>, we need to negate that result before we pass it to the <code>assert!</code> macro. As a result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_03/target/dev/listing_10_03_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code> method by replacing the <code>&gt;</code> sign with a <code>&lt;</code> sign when it compares the widths:</p>
<pre><code class="language-cairo  noplayground">impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-shell">$ scarb test
     Running test no_listing_01_wrong_can_hold_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/target/dev/no_listing_01_wrong_can_hold_impl_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from no_listing_01_wrong_can_hold_impl package
Running 2 test(s) from src/
[PASS] no_listing_01_wrong_can_hold_impl::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[FAIL] no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

Failure data:
    "rectangle cannot hold"

Tests: 1 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is <code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code> (<code>8</code> is not less than <code>5</code>) in the <code>larger_can_hold_smaller</code> test. Notice that the <code>smaller_cannot_hold_larger</code> test still passes: to make this test fail, the height comparison should also be modified in <code>can_hold</code> method, replacing the <code>&gt;</code> sign with a <code>&lt;</code> sign.</p>
<h2 id="testing-equality-and-comparisons-with-the-assert_xx-macros"><a class="header" href="#testing-equality-and-comparisons-with-the-assert_xx-macros">Testing Equality and Comparisons with the <code>assert_xx!</code> Macros</a></h2>
<h3 id="assert_eq-and-assert_ne-macros"><a class="header" href="#assert_eq-and-assert_ne-macros"><code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could
do this using the <code>assert!</code> macro and passing it an expression using the <code>==</code>
operator. However, this is such a common test that the standard library
provides a pair of macros — <code>assert_eq!</code> and <code>assert_ne!</code> — to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, without printing the values that led to the <code>false</code> value.</p>
<p>In Listing 10-5, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter, then we test this function using <code>assert_eq!</code> and <code>assert_ne!</code> macros.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn wrong_check() {
        assert_ne!(0, add_two(2));
    }
}
</code></pre>
<p><span class="caption">Listing 10-5: Testing the function <code>add_two</code> using <code>assert_eq!</code> and <code>assert_ne!</code> macros</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_04 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_04/target/dev/listing_10_04_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from listing_10_04 package
Running 2 test(s) from src/
[PASS] listing_10_04::tests::wrong_check (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_04::tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>In the <code>it_adds_two</code> test, we pass <code>4</code> as argument to <code>assert_eq!</code> macro, which is equal to the result of
calling <code>add_two(2)</code>. The line for this test is <code>[PASS] adder::tests::it_adds_two (gas: ~1)</code>.</p>
<p>In the <code>wrong_check</code> test, we pass <code>0</code> as argument to <code>assert_ne!</code> macro, which is not equal to the result of
calling <code>add_two(2)</code>. Tests that use the <code>assert_ne!</code> macro will pass if the two values we give it are <em>not</em> equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but how the input is changed depends on the day of
the week that we run our tests, the best thing to assert might be that the
output of the function is not equal to the input.</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 3
}
</code></pre>
<p>Run the tests again:</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_10_04_wong_add (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_04_wong_add/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_04_wong_add/target/dev/listing_10_04_wong_add_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from listing_10_04_wong_add package
Running 1 test(s) from src/
[FAIL] listing_10_04_wong_add::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed.
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    listing_10_04_wong_add::tests::it_adds_two

</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed with the following
message: <code>"assertion `4 == add_two(2)` failed</code>.
It tells us that the assertion that failed was <code> "assertion `left == right` failed</code> and the <code>left</code>
and <code>right</code> values are printed on the next lines as <code>left: left_value</code> and <code>right: right_value</code>.
This helps us start debugging: the <code>left</code> argument was <code>4</code> but the <code>right</code> argument, where we had
<code>add_two(2)</code>, was <code>5</code>. You can imagine that this would be especially helpful
when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters for equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Cairo, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value
the code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(add_two(2), 4)</code>, which would result in the same failure message
that displays <code>assertion failed: `(left == right)`</code>.</p>
<p>Here is a simple example comparing two structs, showing how to use <code>assert_eq!</code> and <code>assert_ne!</code> macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Debug, PartialEq)]
struct MyStruct {
    var1: u8,
    var2: u8,
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first = MyStruct { var1: 1, var2: 2 };
    let second = MyStruct { var1: 1, var2: 2 };
    let third = MyStruct { var1: 1, var2: 3 };

    assert_eq!(first, second);
    assert_eq!(first, second, "{:?},{:?} should be equal", first, second);
    assert_ne!(first, third);
    assert_ne!(first, third, "{:?},{:?} should not be equal", first, third);
}
</code></pre>
<p>Under the surface, <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. They both take snapshots of values as arguments. When the assertions fail, these macros print their
arguments using debug formatting (<code>{:?}</code> syntax), which means the values being compared must
implement <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of
the core library types implement these traits. For structs and enums that
you define yourself, you’ll need to implement <code>PartialEq</code> to assert equality of
those types. You’ll also need to implement <code>Debug</code> to print the values when the
assertion fails. Because both traits are derivable, this is usually as straightforward as adding the
<code>#[derive(Drop, Debug, PartialEq)]</code> annotation to your struct or enum definition. See
<a href="./appendix-03-derivable-traits.html">Appendix C</a> for more details about these and other derivable traits.</p>
<h3 id="assert_lt-assert_le-assert_gt-and-assert_ge-macros"><a class="header" href="#assert_lt-assert_le-assert_gt-and-assert_ge-macros"><code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> Macros</a></h3>
<p>Comparisons in tests can be done using the <code>assert_xx!</code> macros:</p>
<ul>
<li><code>assert_lt!</code> checks if a given value is lower than another value, and reverts otherwise.</li>
<li><code>assert_le!</code> checks if a given value is lower or equal than another value, and reverts otherwise.</li>
<li><code>assert_gt!</code> checks if a given value is greater than another value, and reverts otherwise.</li>
<li><code>assert_ge!</code> checks if a given value is greater or equal than another value, and reverts otherwise.</li>
</ul>
<p>Listing 10-6 demonstrates how to use these macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Copy, Debug, PartialEq)]
struct Dice {
    number: u8,
}

impl DicePartialOrd of PartialOrd&lt;Dice&gt; {
    fn lt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt; rhs.number
    }

    fn le(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt;= rhs.number
    }

    fn gt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt; rhs.number
    }

    fn ge(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt;= rhs.number
    }
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first_throw = Dice { number: 5 };
    let second_throw = Dice { number: 2 };
    let third_throw = Dice { number: 6 };
    let fourth_throw = Dice { number: 5 };

    assert_gt!(first_throw, second_throw);
    assert_ge!(first_throw, fourth_throw);
    assert_lt!(second_throw, third_throw);
    assert_le!(
        first_throw, fourth_throw, "{:?},{:?} should be lower or equal", first_throw, fourth_throw,
    );
}
</code></pre>
<p><span class="caption">Listing 10-6: Example of tests that use the <code>assert_xx!</code> macros for comparisons</span></p>
<p>In this example, we roll a <code>Dice</code> struct multiple times and compare the results. We need to manually implement the <code>PartialOrd</code> trait for our struct so that we can compare <code>Dice</code> instances with <code>lt</code>, <code>le</code>, <code>gt</code> and <code>ge</code> functions, which are used by <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> macros, respectively. We also need to derive the <code>Copy</code> trait on our <code>Dice</code> struct to use the instantiated structs multiple times, as the comparison functions take ownership of the variables.</p>
<h2 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h2>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in the <a href="./ch12-08-printing.html#formatting">Printing</a> chapter), so you can pass a format string that contains <code>{}</code> placeholders and
values to go in those placeholders. Custom messages are useful for documenting
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.</p>
<p>Let’s add a custom failure message composed of a format
string with a placeholder filled in with the actual value we got from the previous
<code>add_two</code> function:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2), "Expected {}, got add_two(2)={}", 4, add_two(2));
    }
</code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-shell">$ scarb test
     Running test no_listing_02_custom_messages (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/target/dev/no_listing_02_custom_messages_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from no_listing_02_custom_messages package
Running 1 test(s) from src/
[FAIL] no_listing_02_custom_messages::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_02_custom_messages::tests::it_adds_two

</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h2 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for panics with <code>should_panic</code></a></h2>
<p>In addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the <code>Guess</code> type in Listing 10-7:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Guess {
    value: u64,
}

pub trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
</code></pre>
<p><span class="caption">Listing 10-7: <code>Guess</code> struct and its <code>new</code> method</span></p>
<p>Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances will contain only values between <code>1</code> and <code>100</code>. We can write a test that ensures that attempting to create a <code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.</p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and before the test function it applies to. Let’s look at the result to see that this test passes:</p>
<pre><code class="language-shell">$ scarb test
     Running test listing_09_08 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)
    Finished `dev` profile target(s) in 2 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_05/target/dev/listing_09_08_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from listing_09_08 package
Running 1 test(s) from src/
[PASS] listing_09_08::tests::greater_than_100 (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that the <code>new</code> function will panic if the value is greater than <code>100</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">// TAG: tests_fail
</span><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        GuessTrait::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>When we run the test, it will fail:</p>
<pre><code class="language-shell">$ scarb test
     Running test no_listing_03_wrong_new_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/target/dev/no_listing_03_wrong_new_impl_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from no_listing_03_wrong_new_impl package
Running 1 test(s) from src/
[FAIL] no_listing_03_wrong_new_impl::tests::greater_than_100

Failure data:
    Expected to panic, but no panic occurred

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_03_wrong_new_impl::tests::greater_than_100

</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with <code>#[should_panic]</code> attribute. The failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass even if the test panics for a different reason from the one we were expecting. To make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code> parameter to the <code>#[should_panic]</code> attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for <code>GuessImpl</code> in Listing 10-8 where the <code>new</code> function panics with different messages depending on whether the value is too small or too large:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1");
        } else if value &gt; 100 {
            panic!("Guess must be &lt;= 100");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 10-8: <code>new</code> implementation that panics with different error messages</span></p>
<p>The test will pass because the value we put in the <code>should_panic</code> attribute’s <code>expected</code> parameter is the string that the <code>Guess::new</code> method panics with. We need to specify the entire panic message that we expect.</p>
<p>To see what happens when a <code>should_panic</code> test with an expected message fails, let’s again introduce a bug into our code by swapping the bodies of the <code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-cairo  noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &lt;= 100");
        } else if value &gt; 100 {
            panic!("Guess must be &gt;= 1");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-shell">$ scarb test
     Running test no_listing_04_new_bug (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml)
    Finished `dev` profile target(s) in 2 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_04_new_bug/target/dev/no_listing_04_new_bug_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from no_listing_04_new_bug package
Running 1 test(s) from src/
[FAIL] no_listing_04_new_bug::tests::greater_than_100

Failure data:
    Incorrect panic data
    Actual:    [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203e3d2031, 0x12] (Guess must be &gt;= 1)
    Expected:  [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203c3d20313030, 0x14] (Guess must be &lt;= 100)

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_04_new_bug::tests::greater_than_100

</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this case was <code>Guess must be &gt;= 1</code>. Now we can start figuring out where our bug is!</p>
<h2 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h2>
<p>Sometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing <code>scarb test</code> the name of the test you want to run as an argument.</p>
<p>To demonstrate how to run a single test, we’ll first create two test functions, as shown in Listing 10-9, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert!(result == 5, "result is not 5");
    }
}
</code></pre>
<p><span class="caption">Listing 10-9: Two tests with two different names</span></p>
<p>We can pass the name of any test function to <code>scarb test</code> to run only that test:</p>
<pre><code class="language-shell">$ scarb test add_two_and_two
     Running test listing_10_07 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/listing_10_07/target/dev/listing_10_07_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 1 test(s) from listing_10_07 package
Running 1 test(s) from src/
[PASS] listing_10_07::tests::add_two_and_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 1 filtered out


</code></pre>
<p>Only the test with the name <code>add_two_and_two</code> ran; the other test didn’t match that name. The test output lets us know we had one more test that didn’t run by displaying <code>1 filtered out;</code> at the end.</p>
<p>We can also specify part of a test name, and any test whose name contains that value will be run.</p>
<h2 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h2>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of <code>scarb test</code>. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the <code>#[ignore]</code> attribute to exclude them, as shown here:</p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() { // code that takes an hour to run
    }
}
</code></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<pre><code class="language-shell">$ scarb test
     Running test no_listing_05_ignore_tests (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/target/dev/no_listing_05_ignore_tests_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from no_listing_05_ignore_tests package
Running 2 test(s) from src/
[IGNORE] no_listing_05_ignore_tests::tests::expensive_test
[PASS] no_listing_05_ignore_tests::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 1 ignored, 0 filtered out


</code></pre>
<p>The <code>expensive_test</code> function is listed as ignored.</p>
<p>When you’re at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run <code>scarb test --include-ignored</code> to run all tests, whether they’re ignored or not.</p>
<h2 id="testing-recursive-functions-or-loops"><a class="header" href="#testing-recursive-functions-or-loops">Testing Recursive Functions or Loops</a></h2>
<p>When testing recursive functions or loops, the test is instantiated by default with a maximum amount of gas that it can consume. This prevents running infinite loops or consuming too much gas, and can help you benchmark the efficiency of your implementations. This value is assumed reasonably large enough, but you can override it by adding the <code>#[available_gas(&lt;Number&gt;)]</code> attribute to the test function. The following example shows how to use it:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<h2 id="benchmarking-cairo-programs"><a class="header" href="#benchmarking-cairo-programs">Benchmarking Cairo Programs</a></h2>
<p>Starknet Foundry contains a profiling feature that is useful to analyze and optimize the performance of your Cairo programs.</p>
<p>The <a href="https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/profiling.html">profiling</a> feature generates execution traces for successful tests, which are used to create profile outputs. This allows you to benchmark specific parts of your code.</p>
<p>To use the profiler, you will need to:</p>
<ol>
<li>Install <a href="https://github.com/software-mansion/cairo-profiler">Cairo Profiler</a> from Software Mansion.</li>
<li>Install <a href="https://go.dev/doc/install">Go</a>, <a href="https://www.graphviz.org/download/">Graphviz</a> and <a href="https://github.com/google/pprof?tab=readme-ov-file#building-pprof">pprof</a>, all of them are required to visualize the generated profile output.</li>
<li>Run <code>snforge test --build-profile</code> command, which generates a trace file for each passing test, stored in the <em>snfoundry_trace</em> directory of your project. This command also generates the corresponding output files in the <em>profile</em> directory.</li>
<li>Run <code>go tool pprof -http=":8000" path/to/profile/output.pb.gz</code> to analyse a profile. This will start a web server at the specified port.</li>
</ol>
<p>Let's reuse the <code>sum_n</code> function studied above:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<p>After generating the trace file and the profile output, running <code>go tool pprof</code> in your project will start the web server where you can find many useful information about the test that you ran:</p>
<ul>
<li>
<p>The test includes one function call, corresponding to the call to the test function. Calling <code>sum_n</code> multiple times in the test function will still return 1 call. This is because <code>snforge</code> simulates a contract call when executing a test.</p>
</li>
<li>
<p>The <code>sum_n</code> function execution uses 256 Cairo steps:</p>
</li>
</ul>
<div align="center">
    <img src="pprof-steps.png" alt="pprof number of steps" width="800px"/>
</div>
<p>Other information is also available such as memory holes (i.e., unused memory cells) or builtins usage. The Cairo Profiler is under active development, and many other features will be made available in the future.</p>
<p>{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h1>
<p>We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the <code>src</code> directory in each file with the code that they’re testing.</p>
<p>The convention is to create a module named <code>tests</code> in each file to contain the test functions and to annotate the module with <code>#[cfg(test)]</code> attribute.</p>
<h3 id="the-tests-module-and-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest">The Tests Module and <code>#[cfg(test)]</code></a></h3>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Cairo to compile and run the test code only when you run <code>scarb test</code>, not when you run <code>scarb build</code>. This saves compile time when you only want to build the project and saves space in the resulting compiled artifact because the tests are not included. You’ll see that because integration tests go in a different directory, they don’t need the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files as the code, you’ll use <code>#[cfg(test)]</code> to specify that they shouldn’t be included in the compiled result.</p>
<p>Recall that when we created the new <code>adder</code> project in the first section of this chapter, we wrote this first test:</p>
<pre><code class="language-cairo">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>The attribute <code>cfg</code> stands for <em>configuration</em> and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is <code>test</code>, which is provided by Cairo for compiling and running tests. By using the <code>cfg</code> attribute, Cairo compiles our test code only if we actively run the tests with <code>scarb test</code>. This includes any helper functions that might be within this module, in addition to the functions annotated with <code>#[test]</code>.</p>
<h3 id="testing-private-functions"><a class="header" href="#testing-private-functions">Testing Private Functions</a></h3>
<p>There’s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Cairo's privacy rules do allow you to test private functions. Consider the code below with the private function <code>internal_adder</code>.</p>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add(a: u32, b: u32) -&gt; u32 {
    internal_adder(a, 2)
}

fn internal_adder(a: u32, b: u32) -&gt; u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p><span class="caption">Listing 10-10: Testing a private function</span></p>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>. Tests are just Cairo code, and the tests module is just another module. As we discussed in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Paths for Referring to an Item in the Module Tree"</a> section, items in child modules can use the items in their ancestor modules. In this test, we bring the <code>tests</code> module’s parent <code>internal_adder</code> into scope with <code>use super::internal_adder;</code> and then the test can call <code>internal_adder</code>. If you don’t think private functions should be tested, there’s nothing in Cairo that will compel you to do so.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a <em>tests</em> directory.</p>
<h3 id="the-tests-directory"><a class="header" href="#the-tests-directory">The <em>tests</em> Directory</a></h3>
<p>We create a <em>tests</em> directory at the top level of our project directory, next to <em>src</em>. Scarb knows to look for integration test files in this directory. We can then make as many test files as we want, and Scarb will compile each of the files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing 10-10 still in the <em>src/lib.cairo</em> file, make a <em>tests</em> directory, and create a new file named <em>tests/integration_test.cairo</em>. Your directory structure should look like this:</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    └── integration_tests.cairo

</code></pre>
<p>Enter the code in Listing 10-11 into the <em>tests/integration_test.cairo</em> file:</p>
<p><span class="caption">Filename: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo  noplayground">use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p><span class="caption">Listing 10-11: An integration test of a function in the <code>adder</code> crate</span></p>
<p>Each file in the <code>tests</code> directory is a separate crate, so we need to bring our library into each test crate’s scope. For that reason we add <code>use adder::add_two</code> at the top of the code, which we didn’t need in the unit tests.</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.cairo</em> with <code>#[cfg(test)]</code>. Scarb treats the tests directory specially and compiles files in this directory only when we run <code>scarb test</code>. Run <code>scarb test</code> now:</p>
<pre><code class="language-shell">$ scarb test
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/target/dev/adder_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/target/dev/adder_integrationtest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from adder package
Running 1 test(s) from src/
[PASS] adder::tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>The two sections of output include the unit tests and the integration tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there won’t be any output for integration tests because those tests will only be run if all unit tests are passing.</p>
<p>The first displayed section is for the integration tests.
Each integration test file has its own section, so if we add more files in the <em>tests</em> directory, there will be more integration test sections.</p>
<p>The second displayed section is the same as we’ve been seeing: one line for each unit test (one named add that we added just above) and then a summary line for the unit tests.</p>
<p>We can still run a particular integration test function by specifying the test function’s name as an argument of the option -f to <code>scarb test</code> like for instance <code>scarb test -f integration_tests::internal</code>. To run all the tests in a particular integration test file, we use the same option of <code>scarb test</code> but using only the name of the file.</p>
<p>Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains <em>integration_tests</em>.</p>
<pre><code class="language-shell">$ scarb test -f integration_tests
     Running test adder (snforge test)

</code></pre>
<p>We see that in the second section for the unit tests, 1 has been filtered out because it is not in the <em>integration_tests</em> file.</p>
<h3 id="submodules-in-integration-tests"><a class="header" href="#submodules-in-integration-tests">Submodules in Integration Tests</a></h3>
<p>As you add more integration tests, you might want to make more files in the <em>tests</em> directory to help organize them; for example, you can group the test functions by the functionality they’re testing. As mentioned earlier, each file in the tests directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the tests directory don’t share the same behavior as files in <em>src</em> do, as you learned in Chapter 7 regarding how to separate code into modules and files.</p>
<p>The different behavior of tests directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the <a href="ch07-05-separating-modules-into-different-files.html">Separating Modules into Different Files</a> section of Chapter 7 to extract them into a common module. For example, if we create <em>tests/common.cairo</em> and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that we want to call from multiple test functions in multiple test files:</p>
<p><span class="caption">Filename: tests/common.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn setup() {
    println!("Setting up tests...");
}
</code></pre>
<p><span class="caption">Filename: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo  noplayground">use adder::it_adds_two;

#[test]
fn internal() {
    assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
}
</code></pre>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn it_adds_two(a: u8, b: u8) -&gt; u8 {
    a + b
}

#[cfg(test)]
mod tests {
    #[test]
    fn add() {
        assert_eq!(4, super::it_adds_two(2, 2));
    }
}
</code></pre>
<p>When we run the tests with <code>scarb test</code>, we’ll see a new section in the test output for the <em>common.cairo</em> file, even though this file doesn’t contain any test functions nor did we call the setup function from anywhere:</p>
<pre><code class="language-shell">$ scarb test
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_12_submodules/target/dev/adder_integrationtest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_12_submodules/target/dev/adder_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from adder package
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>To avoid systematically getting a section for each file of the <em>tests</em> folder, we also have the option of making the <code>tests/</code> directory behave like a regular crate, by adding a <code>tests/lib.cairo</code> file. In that case, the <code>tests</code> directory will no longer compile as one crate per file, but as one crate for the whole directory.</p>
<p>Let's create this <em>tests/lib.cairo</em> file :</p>
<p><span class="caption">Filename: tests/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">mod common;
mod integration_tests;
</code></pre>
<p>The project directory will now look like this :</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    ├── common.cairo
    ├── integration_tests.cairo
    └── lib.cairo
</code></pre>
<p>When we run the <code>scarb test</code> command again, here is the output :</p>
<pre><code class="language-shell">$ scarb test
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/target/dev/adder_tests.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.
[WARNING] File = /Users/msaug/workspace/cairo-book/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/target/dev/adder_unittest.test.starknet_artifacts.json missing when it should be existing, perhaps due to Scarb problem.


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_tests::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>This way, only the test functions will be tested and the <code>setup</code> function can be imported without being tested.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Cairo's testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the library’s public API to test the code in the same way external code will use it. Even though Cairo's type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.</p>
<p>{{#quiz ../quizzes/ch10-02-testing-organization.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-features-iterators-and-closures"><a class="header" href="#functional-language-features-iterators-and-closures">Functional Language Features: Iterators and Closures</a></h1>
<p>Cairo’s design has taken strong inspiration from Rust, which itself has taken inspiration from many
existing languages and techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values by passing them in
arguments, returning them from other functions, assigning them to variables for later execution, and
so forth.</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Cairo that are similar to
features in Rust and many languages often referred to as functional.</p>
<p>More specifically, we’ll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements<!-- * How to use closures and iterators to improve the I/O project in Chapter 12
<!-- ^TODO: once we have a hands-on, pure cairo project, we can add this -->
<!-- * The performance of closures and iterators (Spoiler alert: they’re faster than
  you might think!) --> -->
<!-- ^TODO: once closures and iterators become more widespread and show consequent performance gains. -->
</li>
</ul>
<p>We’ve already covered some other Cairo features, such as pattern matching and
enums, that are also influenced by the Rust and the functional style. Because mastering
closures and iterators is an important part of writing idiomatic, fast Cairo
code, we’ll devote this entire chapter to them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.</p>
<blockquote>
<p>Note: Closures were introduced in Cairo 2.9 and are still under development.
Some new features will be introduced in future versions of Cairo, so this page will evolve accordingly.</p>
</blockquote>
<h2 id="understanding-closures"><a class="header" href="#understanding-closures">Understanding Closures</a></h2>
<p>When writing Cairo programs, you'll often need to pass behavior as a parameter to another function. Closures provide a way to define this behavior inline, without creating a separate named function. They are particularly valuable when working with collections, error handling, and any scenario where you want to customize how a function behaves using a function as a parameter.</p>
<p>Consider a simple example where we want to process numbers differently based on some condition. Instead of writing multiple functions, we can use closures to define the behavior where we need it:</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));
<span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<p>The closure's arguments go between the pipes (<code>|</code>). Note that we don't have to specify the types of arguments and of the return value (see <code>double</code> closure), they will be inferred from the closure usage, as it is done for any variables.
Of course, if you use a closure with different types, you will get a <code>Type annotations needed</code> error, telling you that you have to choose and specify the closure argument types.</p>
<p>The body is an expression, on a single line without <code>{}</code> like <code>double</code> or on several lines with <code>{}</code> like <code>sum</code>.</p>
<h2 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h2>
<p>One of the interests of closures is that they can include bindings from their enclosing scope.</p>
<p>In the following example, <code>my_closure</code> use a binding to <code>x</code> to compute <code>x + value * 3</code>.</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span>    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));
<span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Note that, at the moment, closures are still not allowed to capture mutable variables, but this will be supported in future Cairo versions.</p>
</blockquote>
<h2 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h2>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 11-1. In this example, we’re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument as we did in Listing 13-1.</p>
<pre><code class="language-cairo"><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!("Today, run for {} minutes!", expensive_closure(intensity));
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre>
<p>Listing 11-1: Adding optional type annotations of the parameter and return value types in the closure</p>
<!-- TODO: rework the example to add a println!(...) inside the closure -->
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<pre><code class="language-cairo  ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let array = array![];</code> needing either type annotations or values of
some type to be inserted into the <code>array</code> for Cairo to be able to infer the type.</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 11-2 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with <code>u64</code> the first time. If we then try to call
<code>example_closure</code> with a <code>u32</code>, we’ll get an error.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(5_u64);
    let n = example_closure(5_u32);
<span class="boring">}
</span></code></pre>
<p>Listing 11-2: Attempting to call a closure whose types are inferred with two different types</p>
<p>The compiler gives us this error:</p>
<pre><code>$ scarb build
