<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>The Cairo Programming Language</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("es");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "print.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cairo-book"><a class="header" href="#the-cairo-book">The Cairo Book</a></h1>
<p><em>By the Cairo Community and its
<a href="https://github.com/cairo-book/cairo-book.github.io">contributors</a>. Special
thanks to <a href="https://starkware.co/">StarkWare</a> through
<a href="https://www.onlydust.xyz/">OnlyDust</a>, and <a href="https://voyager.online/">Voyager</a>
for supporting the creation of this book.</em></p>
<p>This version of the text assumes you’re using
<a href="https://github.com/starkware-libs/cairo">Cairo</a>
<a href="https://github.com/starkware-libs/cairo/releases">version 2.13.1</a> and
<a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a>
<a href="https://github.com/foundry-rs/starknet-foundry/releases">version 0.51.1</a>. See
the <a href="ch01-01-installation.html">Installation</a> section of Chapter
1 to install or update Cairo and Starknet Foundry.</p>
<p>This book is open source. Find a typo or want to contribute? Check out the
book's <a href="https://github.com/cairo-book/cairo-book">GitHub repository</a>.</p>
<p>Additional resources for mastering Cairo:</p>
<ul>
<li>
<p><a href="https://www.cairo-lang.org/cairovm/">The Cairo Playground</a>: A browser-based
playground for Cairo, enabling to explore and experiment with Cairo by
writing, compiling, debugging, and proving Cairo code without any setup</p>
<blockquote>
<p>Note: You can use the Cairo Playground to experiment with the book's code
snippets and see how they compile into Sierra (Intermediate Representation)
and Casm (Cairo Assembly).</p>
</blockquote>
</li>
<li>
<p><a href="https://docs.cairo-lang.org/core?_=60">The Cairo Core Library Docs</a>: The
documentation for Cairo's Core library, the standard set of types, traits, and
utilities built into the language which provides essential building blocks
basic used throughout the Cairo ecosystem and is automatically available in
every Cairo project</p>
</li>
<li>
<p><a href="https://scarbs.xyz/">The Cairo Package Registry</a>: The host for Cairo's
growing collection of reusable libraries, including
<a href="https://github.com/keep-starknet-strange/alexandria">Alexandria</a>,
<a href="https://docs.openzeppelin.com/contracts-cairo/1.0.0/">Open Zeppelin Contracts for Cairo</a>,
all of which can be easily integrated via Scarb, streamlining development and
dependency management</p>
</li>
<li>
<p><a href="https://docs.swmansion.com/scarb/docs.html">The Scarb documentation</a>: The
official documentation for Cairo’s package manager and build tool, covering
how to create and manage packages, use dependencies, run builds, and configure
projects</p>
</li>
<li>
<p><a href="https://eprint.iacr.org/2021/1063.pdf">The Cairo whitepaper</a>: The original
paper introducing Cairo by StarkWare, which explains Cairo as a language for
writing provable programs, details its architecture, and shows how it enables
scalable, verifiable computation without relying on trusted setups</p>
</li>
</ul>
<p>If you have any questions, feedback or comments, you can reach out through
<a href="https://github.com/cairo-book/cairo-book/issues">Github Issues</a> or directly to
<a href="https://relens.ai/blog/author/eni">maintainers</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Zero-knowledge proofs have emerged as a transformative technology in the
blockchain space, offering solutions for both privacy and scalability
challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge)
stand out as a particularly powerful innovation. Unlike traditional proof
systems, STARKs rely solely on collision-resistant hash functions, making them
post-quantum secure and eliminating the need for trusted setups.</p>
<p>However, writing general-purpose programs that can generate cryptographic proofs
has historically been a significant challenge. Developers needed deep expertise
in cryptography and complex mathematical concepts to create verifiable
computations, making it impractical for mainstream adoption.</p>
<p>This is where Cairo comes in. As a general-purpose programming language designed
specifically for creating provable programs, Cairo abstracts away the underlying
cryptographic complexities while maintaining the full power of STARKs. Strongly
inspired by Rust, Cairo has been built to help you create provable programs
without requiring specific knowledge of its underlying architecture, allowing
you to focus on the program logic itself.</p>
<p>Blockchain developers that want to deploy contracts on Starknet will use the
Cairo programming language to code their smart contracts. This allows the
Starknet OS to generate execution traces for transactions to be proved by a
prover, which is then verified on Ethereum L1 prior to updating the state root
of Starknet.</p>
<p>However, Cairo is not only for blockchain developers. As a general purpose
programming language, it can be used for any computation that would benefit from
being proved on one computer and verified on other machines. Powered by a Rust
VM, and a next-generation prover, the execution and proof generation of Cairo
programs is blazingly fast - making Cairo the best tool for building provable
applications.</p>
<p>This book is designed for developers with a basic understanding of programming
concepts. It is a friendly and approachable text intended to help you level up
your knowledge of Cairo, but also help you develop your programming skills in
general. So, dive in and get ready to learn all there is to know about Cairo!</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>This book would not have been possible without the help of the Cairo community.
We would like to thank every contributor for their contributions to this book!</p>
<p>We would like to thank the Rust community for the <a href="https://doc.rust-lang.org/book/">Rust Book</a>, which
has been a great source of inspiration for this book. Many examples and
explanations have been adapted from the Rust Book to fit the Cairo programming
language, as the two languages share many similarities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-cairo"><a class="header" href="#what-is-cairo">What is Cairo?</a></h2>
<p>Cairo is a programming language designed to leverage the power of mathematical
proofs for computational integrity. Just as C.S. Lewis defined integrity as
"doing the right thing, even when no one is watching," Cairo enables programs to
prove they've done the right computation, even when executed on untrusted
machines.</p>
<p>The language is built on STARK technology, a modern evolution of PCP
(Probabilistically Checkable Proofs) that transforms computational claims into
constraint systems. While Cairo's ultimate purpose is to generate these
mathematical proofs that can be verified efficiently and with absolute
certainty.</p>
<h2 id="what-can-you-do-with-it"><a class="header" href="#what-can-you-do-with-it">What Can You Do with It?</a></h2>
<p>Cairo enables a paradigm shift in how we think about trusted computation. Its
primary application today is Starknet, a Layer 2 scaling solution for Ethereum
that addresses one of blockchain's fundamental challenges: scalability without
sacrificing security.</p>
<p>In the traditional blockchain model, every participant must verify every
computation. Starknet changes this by using Cairo's proof system: computations
are executed off-chain by a prover who generates a STARK proof, which is then
verified by an Ethereum smart contract. This verification requires significantly
less computational power than re-executing the computations, enabling massive
scalability while maintaining security.</p>
<p>However, Cairo's potential extends beyond blockchain. Any scenario where
computational integrity needs to be verified efficiently can benefit from
Cairo's verifiable computation capabilities.</p>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who Is This Book For?</a></h2>
<p>This book caters to three main audiences, each with their own learning path:</p>
<ol>
<li>
<p><strong>General-Purpose Developers</strong>: If you're interested in Cairo for its
verifiable computation capabilities outside of blockchain, you'll want to
focus on chapters
1-12. These chapters
cover the core language features and programming concepts without diving deep
into smart contract specifics.</p>
</li>
<li>
<p><strong>New Smart Contract Developers</strong>: If you're new to both Cairo and smart
contracts, we recommend reading the book front to back. This will give you a
solid foundation in both the language fundamentals and smart contract
development principles.</p>
</li>
<li>
<p><strong>Experienced Smart Contract Developers</strong>: If you're already familiar with
smart contract development in other languages, or Rust, you might want to
follow this focused path:</p>
<ul>
<li>Chapters 1-3 for Cairo
basics</li>
<li>Chapter 8 for Cairo's trait and generics
system</li>
<li>Skip to Chapter 15 for smart
contract development</li>
<li>Reference other chapters as needed</li>
</ul>
</li>
</ol>
<p>Regardless of your background, this book assumes basic programming knowledge
such as variables, functions, and common data structures. While prior experience
with Rust can be helpful (as Cairo shares many similarities), it's not required.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Cairo CPU Architecture: <a href="https://eprint.iacr.org/2021/1063">https://eprint.iacr.org/2021/1063</a></li>
<li>Cairo, Sierra and Casm:
<a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5</a></li>
<li>State of non determinism:
<a href="https://twitter.com/PapiniShahar/status/1638203716535713798">https://twitter.com/PapiniShahar/status/1638203716535713798</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let’s start your Cairo journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:</p>
<ul>
<li>Installing Scarb, which is Cairo's build toolchain and package manager, on
Linux, macOS, and Windows.</li>
<li>Installing Starknet Foundry, which is the default test runner when creating a
Cairo project.</li>
<li>Writing a program that prints <code>Hello, world!</code>.</li>
<li>Using basic Scarb commands to create a project and execute a program.</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you have any questions about Starknet or Cairo, you can ask them in the
<a href="https://discord.gg/starknet-community">Starknet Discord server</a>. The community is friendly and always willing
to help.</p>
<h2 id="interacting-with-the-starknet-ai-agent"><a class="header" href="#interacting-with-the-starknet-ai-agent">Interacting with the Starknet AI Agent</a></h2>
<p>Starknet proposes its own AI agent designed to assist with Cairo and
Starknet-related questions. This AI agent is trained on the Cairo book and the
Starknet documentation, using Retrieval-Augmented Generation (RAG) to
efficiently retrieve information and provide accurate assistance.</p>
<p>You can find the Starknet Agent on the <a href="https://ask.starknet.io/">Starknet Agent</a> website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The first step is to install Cairo. We'll download Cairo through
<a href="https://github.com/software-mansion/starkup">starkup</a>, a command line tool for managing Cairo versions and
associated tools. You'll need an internet connection for the download.</p>
<p>The following steps install the latest stable version of the Cairo compiler
through a binary called <a href="https://docs.swmansion.com/scarb/docs">Scarb</a>. Scarb bundles the Cairo compiler and
the Cairo language server together in an easy-to-install package so that you can
start writing Cairo code right away.</p>
<p>Scarb is also Cairo's package manager and is heavily inspired by
<a href="https://doc.rust-lang.org/cargo/">Cargo</a>, Rust's build system and package manager.</p>
<p>Scarb handles a lot of tasks for you, such as building your code (either pure
Cairo or Starknet contracts), downloading the libraries your code depends on,
building those libraries, and provides LSP support for the VSCode Cairo 1
extension.</p>
<p>As you write more complex Cairo programs, you might add dependencies, and if you
start a project using Scarb, managing external code and dependencies will be a
lot easier to do.</p>
<p><a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a> is a toolchain for Cairo programs and Starknet
smart contract development. It supports many features, including writing and
running tests with advanced features, deploying contracts, interacting with the
Starknet network, and more.</p>
<p>Let's start by installing starkup, which will help us manage Cairo, Scarb, and
Starknet Foundry.</p>
<h2 id="installing-starkup-on-linux-or-macos"><a class="header" href="#installing-starkup-on-linux-or-macos">Installing <code>starkup</code> on Linux or MacOs</a></h2>
<p>If you're using Linux or macOS, open a terminal and enter the following command:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.starkup.dev | sh
</code></pre>
<p>The command downloads a script and starts the installation of the starkup tool,
which installs the latest stable version of Cairo and related toolings. You
might be prompted for your password. If the install is successful, the following
line will appear:</p>
<pre><code class="language-bash">starkup: Installation complete.
</code></pre>
<p>After installation, starkup will automatically install the latest stable
versions of Cairo, Scarb, and Starknet Foundry. You can verify the installations
by running the following commands in a new terminal session:</p>
<pre><code class="language-bash">$ scarb --version
scarb 2.13.1 (639d0a65e 2025-08-04)
cairo: 2.13.1 (https://crates.io/crates/cairo-lang-compiler/2.13.1)
sierra: 1.7.0

$ snforge --version
snforge 0.51.1
</code></pre>
<p>We'll describe Starknet Foundry in more detail in <a href="./ch10-01-how-to-write-tests.html">Chapter
10</a> for Cairo programs testing and
in <a href="./ch104-02-testing-smart-contracts.html#testing-smart-contracts-with-starknet-foundry">Chapter 18</a>
when discussing Starknet smart contract testing and security in the second part
of the book.</p>
<h2 id="installing-the-vscode-extension"><a class="header" href="#installing-the-vscode-extension">Installing the VSCode Extension</a></h2>
<p>Cairo has a VSCode extension that provides syntax highlighting, code completion,
and other useful features. You can install it from the <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">VSCode
Marketplace</a>. Once installed, go into the extension settings, and
make sure to tick the <code>Enable Language Server</code> and <code>Enable Scarb</code> options.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch01-01-installation&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;1b7c7edd-8c2c-418b-ad80-c0b37b8ae215&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Cairo's package manager and build system&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;a VS Code extension&quot;,&quot;the name of the VM that runs Cairo&quot;],&quot;prompt&quot;:&quot;What is Scarb?&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>Now that you’ve installed Cairo through Scarb, it’s time to write your first
Cairo program. It’s traditional when learning a new language to write a little
program that prints the text <code>Hello, world!</code> to the screen, so we’ll do the same
here!</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Cairo makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. The Cairo team has
developed a VSCode extension for the Cairo language that you can use to get
the features from the language server and code highlighting. See <a href="./appendix-06-useful-development-tools.html">Appendix
F</a> for more details.</p>
</blockquote>
<h2 id="creating-a-project-directory"><a class="header" href="#creating-a-project-directory">Creating a Project Directory</a></h2>
<p>You’ll start by making a directory to store your Cairo code. It doesn’t matter
to Cairo where your code lives, but for the exercises and projects in this book,
we suggest making a <em>cairo_projects</em> directory in your home directory and
keeping all your projects there.</p>
<p>Open a terminal and enter the following commands to make a <em>cairo_projects</em>
directory.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<pre><code class="language-shell">mkdir ~/cairo_projects
cd ~/cairo_projects
</code></pre>
<p>For Windows CMD, enter this:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\cairo_projects"
&gt; cd /d "%USERPROFILE%\cairo_projects"
</code></pre>
<blockquote>
<p>Note: From now on, for each example shown in the book, we assume that you will
be working from a Scarb project directory. If you are not using Scarb, and try
to run the examples from a different directory, you might need to adjust the
commands accordingly or create a Scarb project.</p>
</blockquote>
<h2 id="creating-a-project-with-scarb"><a class="header" href="#creating-a-project-with-scarb">Creating a Project with Scarb</a></h2>
<p>Let’s create a new project using Scarb.</p>
<p>Navigate to your <em>cairo_projects</em> directory (or wherever you decided to store
your code). Then run the following:</p>
<pre><code class="language-bash">scarb new hello_world
</code></pre>
<p>Scarb will ask you about the dependencies you want to add. You will be given two
options :</p>
<pre><code class="language-text">? Which test runner do you want to set up? ›
❯ Starknet Foundry (default)
  Cairo Test
</code></pre>
<p>In general, we'll prefer using the first one <code>❯ Starknet Foundry (default)</code>.</p>
<p>This creates a new directory and project called <em>hello_world</em>. We’ve named our
project <em>hello_world</em>, and Scarb creates its files in a directory of the same
name.</p>
<p>Go into the <em>hello_world</em> directory with the command <code>cd hello_world</code>. You’ll
see that Scarb has generated three files and two directory for us: a
<em>Scarb.toml</em> file, a <em>src</em> directory with a <em>lib.cairo</em> file inside and a
<em>tests</em> directory containing a <em>test_contract.cairo</em> file. For now, we can
remove this <em>tests</em> directory.</p>
<p>It has also initialized a new Git repository along with a <code>.gitignore</code> file</p>
<blockquote>
<p>Note: Git is a common version control system. You can stop using version
control system by using the <code>--no-vcs</code> flag. Run <code>scarb new --help</code> to see the
available options.</p>
</blockquote>
<p>Open <em>Scarb.toml</em> in your text editor of choice. It should look similar to the
code in Listing 1-1.</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.13.1"

[dev-dependencies]
snforge_std = "0.51.1"
assert_macros = "2.13.1"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...
</code></pre>
<p>Contents of <em>Scarb.toml</em> generated by <code>scarb new</code></span></p>
<p>This file is in the <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) format,
which is Scarb’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>The next three lines set the configuration information Scarb needs to compile
your program: the name of the package and the version of Scarb to use, and the
edition of the prelude to use. The prelude is the collection of the most
commonly used items that are automatically imported into every Cairo program.
You can learn more about the prelude in <a href="./appendix-04-cairo-prelude.html">Appendix D</a>.</p>
<p>The <code>[dependencies]</code> section, is the start of a section for you to list any of
your project’s dependencies. In Cairo, packages of code are referred to as
crates. We won’t need any other crates for this project.</p>
<p>The <code>[dev-dependencies]</code> section is about dependencies that are required for
development, but are not needed for the actual production build of the project.
<code>snforge_std</code> and <code>assert_macros</code> are two examples of such dependencies. If you
want to test your project without using Starknet Foundry, you can use
<code>cairo_test</code>.</p>
<p>The <code>[[target.starknet-contract]]</code> section allows to build Starknet smart
contracts. We can remove it for now.</p>
<p>The <code>[script]</code> section allows to define custom scripts. By default, there is one
script for running tests using <code>snforge</code> with the <code>scarb test</code> command. We can
also remove it for now.</p>
<p>Starknet Foundry also have more options, check out
<a href="https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html">Starknet Foundry documentation</a>
for more information.</p>
<p>By default, using Starknet Foundry adds the <code>starknet</code> dependency and the
<code>[[target.starknet-contract]]</code> section, so that you can build contracts for
Starknet out of the box. We will start with only Cairo programs, so you can edit
your <em>Scarb.toml</em> file to the following:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"


[[target.executable]]
name = "hello_world_main"
function = "hello_world::hello_world::main"
</code></pre>
<p>1-2: Contents of modified <em>Scarb.toml</em></span></p>
<p>The other file created by Scarb is <em>src/lib.cairo</em>, let's delete all the content
and put in the following content, we will explain the reason later.</p>
<pre><code class="language-cairo noplayground">mod hello_world;
</code></pre>
<p>Then create a new file called <em>src/hello_world.cairo</em> and put the following code
in it:</p>
<p><span class="filename">Filename: src/hello_world.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    println!("Hello, World!");
}
</code></pre>
<p>We have just created a file called <em>lib.cairo</em>, which contains a module
declaration referencing another module named <code>hello_world</code>, as well as the file
<em>hello_world.cairo</em>, containing the implementation details of the <code>hello_world</code>
module.</p>
<p>Scarb requires your source files to be located within the <em>src</em> directory.</p>
<p>The top-level project directory is reserved for <em>README</em> files, license
information, configuration files, and any other non-code-related content. Scarb
ensures a designated location for all project components, maintaining a
structured organization.</p>
<p>If you started a project that doesn’t use Scarb, you can convert it to a project
that does use Scarb. Move the project code into the <em>src</em> directory and create
an appropriate <em>Scarb.toml</em> file. You can also use <code>scarb init</code> command to
generate the <em>src</em> folder and the <em>Scarb.toml</em> it contains.</p>
<pre><code class="language-txt">├── Scarb.toml
├── src
│   ├── lib.cairo
│   └── hello_world.cairo
</code></pre>
<p><span class="caption"> A sample Scarb project structure</span></p>
<h2 id="building-a-scarb-project"><a class="header" href="#building-a-scarb-project">Building a Scarb Project</a></h2>
<p>From your <em>hello_world</em> directory, build your project by entering the following
command:</p>
<pre><code class="language-bash">$ scarb build 
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 1 second

</code></pre>
<p>This command creates a <code>hello_world_main_executable.json</code> file in <em>target/dev</em>,
let's ignore this file for now.</p>
<p>If you have installed Cairo correctly, you should be able to run the <code>main</code>
function of your program with the <code>scarb execute</code> command and see the following
output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing hello_world
Hello, World!


</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should be
printed to the terminal.</p>
<p>If <code>Hello, world!</code> did print, congratulations! You’ve officially written a Cairo
program. That makes you a Cairo programmer — welcome!</p>
<h2 id="anatomy-of-a-cairo-program"><a class="header" href="#anatomy-of-a-cairo-program">Anatomy of a Cairo Program</a></h2>
<p>Let’s review this “Hello, world!” program in detail. Here’s the first piece of
the puzzle:</p>
<pre><code class="language-cairo noplayground">fn main() {

}
</code></pre>
<p>These lines define a function named <code>main</code>. The <code>main</code> function is special: it
is always the first code that runs in every executable Cairo program. Here, the
first line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses <code>()</code>.</p>
<p>The function body is wrapped in <code>{}</code>. Cairo requires curly brackets around all
function bodies. It’s good style to place the opening curly bracket on the same
line as the function declaration, adding one space in between.</p>
<blockquote>
<p>Note: If you want to stick to a standard style across Cairo projects, you can
use the automatic formatter tool available with <code>scarb fmt</code> to format your
code in a particular style (more on <code>scarb fmt</code> in <a href="./appendix-06-useful-development-tools.html">Appendix F</a>).
The Cairo team has included this tool with the standard Cairo distribution, as
<code>scarb execute</code> is, so it should already be installed on your computer!</p>
</blockquote>
<p>The body of the <code>main</code> function holds the following code:</p>
<pre><code class="language-cairo noplayground">    println!("Hello, World!");
</code></pre>
<p>This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.</p>
<p>First, Cairo style is to indent with four spaces, not a tab.</p>
<p>Second, <code>println!</code> calls a Cairo macro. If it had called a function instead, it
would be entered as <code>println</code> (without the <code>!</code>). We’ll discuss Cairo macros in
more detail in the <a href="./ch12-05-macros.html">"Macros"</a> chapter. For now, you just need to know
that using a <code>!</code> means that you’re calling a macro instead of a normal function
and that macros don’t always follow the same rules as functions.</p>
<p>Third, you see the <code>"Hello, world!"</code> string. We pass this string as an argument
to <code>println!</code>, and the string is printed to the screen.</p>
<p>Fourth, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Cairo code
end with a semicolon.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch01-02-hello-world&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;aac32d9f-b5a4-4946-81f2-eb6bcfc090ed&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;main&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;What is the name of the initial function that a Cairo program runs?&quot;}},{&quot;context&quot;:&quot;`scarb execute` will first compile and then run your code.&quot;,&quot;id&quot;:&quot;a89b37cf-aa75-4fc7-b433-3b57d273ce1d&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;scarb execute&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Which command will run the code in your project?&quot;}}]}"></div>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>Let’s recap what we’ve learned so far about Scarb:</p>
<ul>
<li>We can install one or multiple Scarb versions, either the latest stable or a
specific one, using asdf.</li>
<li>We can create a project using <code>scarb new</code>.</li>
<li>We can build a project using <code>scarb build</code> to generate the compiled Sierra
code.</li>
<li>We can execute a Cairo program using the <code>scarb execute</code> command.</li>
</ul>
<p>An additional advantage of using Scarb is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.</p>
<p>You’re already off to a great start on your Cairo journey! This is a great time
to build a more substantial program to get used to reading and writing Cairo
code.</p>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="proving-that-a-number-is-prime"><a class="header" href="#proving-that-a-number-is-prime">Proving That A Number Is Prime</a></h1>
<p>Let’s dive into Cairo by working through a hands-on project together! This
section introduces you to key Cairo concepts and the process of generating
zero-knowledge proofs locally, a powerful feature enabled by Cairo in
combination with the <a href="https://github.com/starkware-libs/stwo">Stwo prover</a>. You’ll learn about functions, control
flow, executable targets, Scarb workflows, and how to prove a statement — all
while practicing the fundamentals of Cairo programming. In later chapters, we’ll
explore these ideas in more depth.</p>
<p>For this project, we’ll implement a classic mathematical problem suited for
zero-knowledge proofs: proving that a number is prime. This is the ideal project
to introduce you to the concept of zero-knowledge proofs in Cairo, because while
<em>finding</em> prime numbers is a complex task, <em>proving</em> that a number is prime is
straightforward.</p>
<p>Here’s how it works: the program will take an input number from the user and
check whether it’s prime using a trial division algorithm. Then, we’ll use Scarb
to execute the program and generate a proof that the primality check was
performed correctly, so that anyone can verify your proof to trust that you
found a prime number. The user will input a number, and we’ll output whether
it’s prime, followed by generating and verifying a proof.</p>
<h2 id="setting-up-a-new-project"><a class="header" href="#setting-up-a-new-project">Setting Up a New Project</a></h2>
<p>To get started, ensure you have Scarb 2.13.1 or later installed (see
<a href="./ch01-01-installation.html">Installation</a> for details). We’ll use Scarb to create and manage
our Cairo project.</p>
<p>Open a terminal in your projects directory and create a new Scarb project:</p>
<pre><code class="language-bash">scarb new prime_prover
cd prime_prover
</code></pre>
<p>The scarb new command creates a new directory called <code>prime_prover</code> with a basic
project structure. Let’s examine the generated Scarb.toml file:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[dependencies]

[dev-dependencies]
cairo_test = "2.13.1"
</code></pre>
<p>This is a minimal manifest file for a Cairo project. However, since we want to
create an executable program that we can prove, we need to modify it. Update
Scarb.toml to define an executable target and include the <code>cairo_execute</code>
plugin:</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"


[[target.executable]]
name = "main"
function = "prime_prover::main"
</code></pre>
<p>Here’s what we’ve added:</p>
<ul>
<li><code>[[target.executable]]</code> specifies that this package compiles to a Cairo
executable (not a library or Starknet contract).</li>
<li><code>[cairo] enable-gas = false</code> disables gas tracking, which is required for
executable targets since gas is specific to Starknet contracts.
<code>[dependencies] cairo_execute = "2.13.1"</code> adds the plugin needed to execute
and prove our program.</li>
</ul>
<p>Now, check the generated <code>src/lib.cairo</code>, which is a simple placeholder. Since
we’re building an executable, we’ll replace this with a function annotated with
<code>#[executable]</code> to define our entry point.</p>
<h2 id="writing-the-prime-checking-logic"><a class="header" href="#writing-the-prime-checking-logic">Writing the Prime-Checking Logic</a></h2>
<p>Let’s write a program to check if a number is prime. A number is prime if it’s
greater than 1 and divisible only by 1 and itself. We’ll implement a simple
trial division algorithm and mark it as executable. Replace the contents of
<code>src/lib.cairo</code> with the following:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u32) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    loop {
        if i * i &gt; n {
            return true;
        }
        if n % i == 0 {
            return false;
        }
        i += 2;
    }
}

// Executable entry point
#[executable]
fn main(input: u32) -&gt; bool {
    is_prime(input)
}
</code></pre>
<p>Let’s break this down:</p>
<p>The <code>is_prime</code> function:</p>
<ul>
<li>Takes a <code>u32</code> input (an unsigned 32-bit integer) and returns a <code>bool</code>.</li>
<li>Checks edge cases: numbers ≤ 1 are not prime, 2 is prime, even numbers &gt; 2 are
not prime.</li>
<li>Uses a loop to test odd divisors up to the square root of <code>n</code>. If no divisors
are found, the number is prime.</li>
</ul>
<p>The <code>main</code> function:</p>
<ul>
<li>Marked with <code>#[executable]</code>, indicating it’s the entry point for our program.</li>
<li>Takes a u32 input from the user and returns a bool indicating whether it’s
prime.</li>
<li>Calls is_prime to perform the check.</li>
</ul>
<p>This is a straightforward implementation, but it’s perfect for demonstrating
proving in Cairo.</p>
<h2 id="executing-the-program"><a class="header" href="#executing-the-program">Executing the Program</a></h2>
<p>Now let’s run the program with Scarb to test it. Use the scarb execute command
and provide an input number as an argument:</p>
<pre><code class="language-bash">scarb execute -p prime_prover --print-program-output --arguments 17
</code></pre>
<ul>
<li><code>-p prime_prover</code> specifies the package name (matches Scarb.toml).</li>
<li><code>--print-program-output</code> displays the result.</li>
<li><code>--arguments 17</code> passes the number 17 as input.</li>
</ul>
<p>You should see output like this:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 17
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing prime_prover
Program output:
1


</code></pre>
<p>The output represents whether the program executed successfully and the result
of the program. Here, <code>0</code> indicates success (no panic), and <code>1</code> represents true
(17 is prime). Try a few more numbers:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 4
[0, 0]  # 4 is not prime
$ scarb execute -p prime_prover --print-program-output --arguments 23
[0, 1]  # 23 is prime
</code></pre>
<p>The execution creates a folder under <code>./target/execute/prime_prover/execution1/</code>
containing files like <code>air_public_input.json</code>, <code>air_private_input.json</code>,
<code>trace.bin</code>, and <code>memory.bin</code>. These are the artifacts needed for proving.</p>
<h2 id="generating-a-zero-knowledge-proof"><a class="header" href="#generating-a-zero-knowledge-proof">Generating a Zero-Knowledge Proof</a></h2>
<p>Now for the exciting part: proving that the primality check was computed
correctly without revealing the input! Cairo 2.10 integrates the Stwo prover via
Scarb, allowing us to generate a proof directly. Run:</p>
<pre><code class="language-bash">$ scarb prove --execution-id 1
     Proving prime_prover
warn: soundness of proof is not yet guaranteed by Stwo, use at your own risk
Saving proof to: target/execute/prime_prover/execution1/proof/proof.json

</code></pre>
<p><code>--execution_id 1</code> points to the first execution (from the <code>execution1</code> folder).</p>
<p>This command generates a <code>proof.json</code> file in
<code>./target/execute/prime_prover/execution1/proof/</code>. The proof demonstrates that
the program executed correctly for some input, producing a true or false output.</p>
<h2 id="verifying-the-proof"><a class="header" href="#verifying-the-proof">Verifying the Proof</a></h2>
<p>To ensure the proof is valid, verify it with:</p>
<pre><code class="language-bash">$ scarb verify --execution-id 1
   Verifying prime_prover
    Verified proof successfully

</code></pre>
<p>If successful, you’ll see a confirmation message. This verifies that the
computation (primality check) was performed correctly, aligning with the public
inputs, without needing to re-run the program.</p>
<h2 id="improving-the-program-handling-input-errors"><a class="header" href="#improving-the-program-handling-input-errors">Improving the Program: Handling Input Errors</a></h2>
<p>Currently, our program assumes the input is a valid <code>u32</code>. What if we want to
handle larger numbers or invalid inputs? Cairo’s <code>u32</code> has a maximum value of
<code>2^32 - 1 (4,294,967,295)</code>, and inputs must be provided as integers. Let’s
modify the program to use <code>u128</code> and add a basic check. Update <code>src/lib.cairo</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u128) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    loop {
        if i * i &gt; n {
            return true;
        }
        if n % i == 0 {
            return false;
        }
        i += 2;
    }
}

#[executable]
fn main(input: u128) -&gt; bool {
    if input &gt; 1000000 { // Arbitrary limit for demo purposes
        panic!("Input too large, must be &lt;= 1,000,000");
    }
    is_prime(input)
}
</code></pre>
<p>Changed <code>u32</code> to <code>u128</code> for a larger range (up to <code>2^128 - 1</code>). Added a check to
panic if the input exceeds 1,000,000 (for simplicity; adjust as needed). Test
it:</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 1000001
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover2/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing prime_prover
error: Panicked with "Input too large, must be &lt;= 1,000,000".

</code></pre>
<p>If we pass a number greater than 1,000,000, the program will panic - and thus,
no proof can be generated. As such, it's not possible to verify a proof for a
panicked execution.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Congratulations! You’ve built a Cairo program to check primality, executed it
with Scarb, and generated and verified a zero-knowledge proof using the Stwo
prover. This project introduced you to:</p>
<ul>
<li>Defining executable targets in Scarb.toml.</li>
<li>Writing functions and control flow in Cairo.</li>
<li>Using <code>scarb execute</code> to run programs and generate execution traces.</li>
<li>Proving and verifying computations with <code>scarb prove</code> and <code>scarb verify</code>.</li>
</ul>
<p>In the next chapters, you’ll dive deeper into Cairo’s syntax (Chapter
2), ownership (Chapter
4), and other features. For now, experiment with
different inputs or modify the primality check — can you optimize it further?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language
and how they work in Cairo. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Cairo,
but we’ll discuss them in the context of Cairo and explain the conventions
around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Cairo program, and learning
them early will give you a strong core to start from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-mutability"><a class="header" href="#variables-and-mutability">Variables and Mutability</a></h1>
<p>Cairo uses an immutable memory model, meaning that once a memory cell is written
to, it can't be overwritten but only read from. To reflect this immutable memory
model, variables in Cairo are immutable by default. However, the language
abstracts this model and gives you the option to make your variables mutable.
Let’s explore how and why Cairo enforces immutability, and how you can make your
variables mutable.</p>
<p>When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, generate a new project called <em>variables</em> in
your <em>cairo_projects</em> directory by using <code>scarb new variables</code>.</p>
<p>Then, in your new <em>variables</em> directory, open <em>src/lib.cairo</em> and replace its
code with the following code, which won’t compile just yet:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}

</code></pre>
<p>Save and run the program using <code>scarb execute</code>. You should receive an error
message regarding an immutability error, as shown in this output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_01_variables_are_immutable v0.1.0 (listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml)
error: Cannot assign to an immutable variable.
 --&gt; listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:7:5
    x = 6;
    ^^^^^

error: could not compile `no_listing_01_variables_are_immutable` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<p>This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but they only mean your program isn’t safely
doing what you want it to do yet; they do <em>not</em> mean that you’re not a good
programmer! Experienced Caironautes still get compiler errors.</p>
<p>You received the error message <code>Cannot assign to an immutable variable.</code> because
you tried to assign a second value to the immutable <code>x</code> variable.</p>
<p>It’s important that we get compile-time errors when we attempt to change a value
that’s designated as immutable because this specific situation can lead to bugs.
If one part of our code operates on the assumption that a value will never
change and another part of our code changes that value, it’s possible that the
first part of the code won’t do what it was designed to do. The cause of this
kind of bug can be difficult to track down after the fact, especially when the
second piece of code changes the value only <em>sometimes</em>.</p>
<p>Cairo, unlike most other languages, has immutable memory. This makes a whole
class of bugs impossible, because values will never change unexpectedly. This
makes code easier to reason about.</p>
<p>But mutability can be very useful, and can make code more convenient to write.
Although variables are immutable by default, you can make them mutable by adding
<code>mut</code> in front of the variable name. Adding <code>mut</code> also conveys intent to future
readers of the code by indicating that other parts of the code will be changing
the value associated to this variable.</p>
<!-- TODO: add an illustration of this -->
<p>However, you might be wondering at this point what exactly happens when a
variable is declared as <code>mut</code>, as we previously mentioned that Cairo's memory is
immutable. The answer is that the <em>value</em> is immutable, but the <em>variable</em>
isn't. The value associated to the variable can be changed. Assigning to a
mutable variable in Cairo is essentially equivalent to redeclaring it to refer
to another value in another memory cell, but the compiler handles that for you,
and the keyword <code>mut</code> makes it explicit. Upon examining the low-level Cairo
Assembly code, it becomes clear that variable mutation is implemented as
syntactic sugar, which translates mutation operations into a series of steps
equivalent to variable shadowing. The only difference is that at the Cairo
level, the variable is not redeclared so its type cannot change.</p>
<p>For example, let’s change <em>src/lib.cairo</em> to the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>When we run the program now, we get this:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_02_adding_mut v0.1.0 (listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_02_adding_mut
The value of x is: 5
The value of x is: 6


</code></pre>
<p>We’re allowed to change the value bound to <code>x</code> from <code>5</code> to <code>6</code> when <code>mut</code> is
used. Ultimately, deciding whether to use mutability or not is up to you and
depends on what you think is clearest in that particular situation.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Like immutable variables, <em>constants</em> are values that are bound to a name and
are not allowed to change, but there are a few differences between constants and
variables.</p>
<p>First, you aren’t allowed to use <code>mut</code> with constants. Constants aren’t just
immutable by default—they’re always immutable. You declare constants using the
<code>const</code> keyword instead of the <code>let</code> keyword, and the type of the value <em>must</em>
be annotated. We’ll cover types and type annotations in the next section, <a href="./ch02-02-data-types.html">“Data
Types”</a>, so don’t worry about the details right now. Just know that
you must always annotate the type.</p>
<p>Constant variables can be declared with any usual data type, including structs,
enums and fixed-size arrays.</p>
<p>Constants can only be declared in the global scope, which makes them useful for
values that many parts of code need to know about.</p>
<p>The last difference is that constants may natively be set only to a constant
expression, not the result of a value that could only be computed at runtime.</p>
<p>Here’s an example of constants declaration:</p>
<pre><code class="language-cairo noplayground">struct AnyStruct {
    a: u256,
    b: u32,
}

enum AnyEnum {
    A: felt252,
    B: (usize, u256),
}

const ONE_HOUR_IN_SECONDS: u32 = 3600;
const ONE_HOUR_IN_SECONDS_2: u32 = 60 * 60;
const STRUCT_INSTANCE: AnyStruct = AnyStruct { a: 0, b: 1 };
const ENUM_INSTANCE: AnyEnum = AnyEnum::A('any enum');
const BOOL_FIXED_SIZE_ARRAY: [bool; 2] = [true, false];
</code></pre>
<p>Cairo's naming convention for constants is to use all uppercase with underscores
between words.</p>
<p>Constants are valid for the entire time a program runs, within the scope in
which they were declared. This property makes constants useful for values in
your application domain that multiple parts of the program might need to know
about, such as the maximum number of points any player of a game is allowed to
earn, or the speed of light.</p>
<p>Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Variable shadowing refers to the declaration of a new variable with the same
name as a previous variable. Caironautes say that the first variable is
<em>shadowed</em> by the second, which means that the second variable is what the
compiler will see when you use the name of the variable. In effect, the second
variable overshadows the first, taking any uses of the variable name to itself
until either it itself is shadowed or the scope ends. We can shadow a variable
by using the same variable’s name and repeating the use of the <code>let</code> keyword as
follows:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("Inner scope x value is: {}", x);
    }
    println!("Outer scope x value is: {}", x);
}
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it creates a new variable
<code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the
value of <code>x</code> is then <code>6</code>. Then, within an inner scope created with the curly
brackets, the third <code>let</code> statement also shadows <code>x</code> and creates a new variable,
multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>. When that
scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code>. When we
run this program, it will output the following:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_03_shadowing
Inner scope x value is: 12
Outer scope x value is: 6


</code></pre>
<p>Shadowing is different from marking a variable as <code>mut</code> because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the <code>let</code> keyword. By using <code>let</code>, we can perform a few transformations on
a value but have the variable be immutable after those transformations have been
completed.</p>
<p>Another distinction between <code>mut</code> and shadowing is that when we use the <code>let</code>
keyword again, we are effectively creating a new variable, which allows us to
change the type of the value while reusing the same name. As mentioned before,
variable shadowing and mutable variables are equivalent at the lower level. The
only difference is that by shadowing a variable, the compiler will not complain
if you change its type. For example, say our program performs a type conversion
between the <code>u64</code> and <code>felt252</code> types.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: u64 = 2;
    println!("The value of x is {} of type u64", x);
    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.
    println!("The value of x is {} of type felt252", x);
}
</code></pre>
<p>The first <code>x</code> variable has a <code>u64</code> type while the second <code>x</code> variable has a
<code>felt252</code> type. Shadowing thus spares us from having to come up with different
names, such as <code>x_u64</code> and <code>x_felt252</code>; instead, we can reuse the simpler <code>x</code>
name. However, if we try to use <code>mut</code> for this, as shown here, we’ll get a
compile-time error:</p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let mut x: u64 = 2;
    println!("The value of x is: {}", x);
    x = 5_u8;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>The error says we were expecting a <code>u64</code> (the original type) but we got a
different type:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_05_mut_cant_change_type v0.1.0 (listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml)
error: Unexpected argument type. Expected: "core::integer::u64", found: "core::integer::u8".
 --&gt; listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:7:9
    x = 5_u8;
        ^^^^

error: could not compile `no_listing_05_mut_cant_change_type` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch02-01-variables-and-mutability&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e3db31-79aa-44b6-9dc2-be8b37b83ada&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nlet mut x = 99;\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nconst MINUTES_PER_HOUR = 60;\n```\n&quot;,&quot;```rust\nlet y = 10;\n```\n&quot;],&quot;prompt&quot;:&quot;Which syntax creates a variable that can be reassigned?&quot;}},{&quot;id&quot;:&quot;0a902a6d-3fca-4d72-b455-5e9ab12441d9&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`Final balance is: 6`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Final balance is: 12`&quot;,&quot;The program won't compile.&quot;],&quot;prompt&quot;:&quot;What will be the output of the following program?\n```rust\n#[executable]\nfn main() {\n    let initial_balance = 9;\n    let initial_balance = initial_balance - 3;\n    {\n        let initial_balance = initial_balance * 2;\n    }\n    println!(\&quot;Final balance is: {}\&quot;, initial_balance);\n}\n```\n&quot;}}]}"></div>
<p>Now that we’ve explored how variables work, let’s look at more data types they
can have.</p>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Every value in Cairo is of a certain <em>data type</em>, which tells Cairo what kind of
data is being specified so it knows how to work with that data. This section
covers two subsets of data types: scalars and compounds.</p>
<p>Keep in mind that Cairo is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer the desired type based on the value and its usage. In cases when many
types are possible, we can use a conversion method where we specify the desired
output type.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: felt252 = 3;
    let y: u32 = x.try_into().unwrap();
}
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<h2 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h2>
<p>A <em>scalar</em> type represents a single value. Cairo has three primary scalar types:
felts, integers, and booleans. You may recognize these from other programming
languages. Let’s jump into how they work in Cairo.</p>
<h3 id="felt-type"><a class="header" href="#felt-type">Felt Type</a></h3>
<p>In Cairo, if you don't specify the type of a variable or argument, its type
defaults to a field element, represented by the keyword <code>felt252</code>. In the
context of Cairo, when we say “a field element” we mean an integer in the range
\( 0 \leq x &lt; P \), where \( P \) is a very large prime number currently
equal to \( {2^{251}} + 17 \cdot {2^{192}} + 1 \). When adding, subtracting,
or multiplying, if the result falls outside the specified range of the prime
number, an overflow (or underflow) occurs, and an appropriate multiple of \( P
\) is added or subtracted to bring the result back within the range (i.e., the
result is computed \( \mod P \) ).</p>
<p>The most important difference between integers and field elements is division:
Division of field elements (and therefore division in Cairo) is unlike regular
CPUs division, where integer division \( \frac{x}{y} \) is defined as \(
\left\lfloor \frac{x}{y} \right\rfloor \) where the integer part of the
quotient is returned (so you get \( \frac{7}{3} = 2 \)) and it may or may not
satisfy the equation \( \frac{x}{y} \cdot y == x \), depending on the
divisibility of <code>x</code> by <code>y</code>.</p>
<p>In Cairo, the result of \( \frac{x}{y} \) is defined to always satisfy the
equation \( \frac{x}{y} \cdot y == x \). If y divides x as integers, you will
get the expected result in Cairo (for example \( \frac{6}{2} \) will indeed
result in <code>3</code>). But when y does not divide x, you may get a surprising result:
for example, since \( 2 \cdot \frac{P + 1}{2} = P + 1 \equiv 1 \mod P \), the
value of \( \frac{1}{2} \) in Cairo is \( \frac{P + 1}{2} \) (and not 0 or
0.5), as it satisfies the above equation.</p>
<h3 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h3>
<p>The felt252 type is a fundamental type that serves as the basis for creating all
types in the core library. However, it is highly recommended for programmers to
use the integer types instead of the <code>felt252</code> type whenever possible, as the
<code>integer</code> types come with added security features that provide extra protection
against potential vulnerabilities in the code, such as overflow and underflow
checks. By using these integer types, programmers can ensure that their programs
are more secure and less susceptible to attacks or other security threats. An
<code>integer</code> is a number without a fractional component. This type declaration
indicates the number of bits the programmer can use to store the integer. Table
3-1 shows the built-in integer types in Cairo. We can use any of these variants
to declare the type of an integer value.</p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>u128</code></td></tr>
<tr><td>256-bit</td><td><code>u256</code></td></tr>
<tr><td>32-bit</td><td><code>usize</code></td></tr>
</tbody></table>
</div><br>
<div align="center"><span class="caption">Table 3-1: Integer Types in Cairo.</span></div>
<p>Each variant has an explicit size. Note that for now, the <code>usize</code> type is just
an alias for <code>u32</code>; however, it might be useful when in the future Cairo can be
compiled to MLIR. As variables are unsigned, they can't contain a negative
number. This code will cause the program to panic:</p>
<pre><code class="language-cairo">fn sub_u8s(x: u8, y: u8) -&gt; u8 {
    x - y
}

#[executable]
fn main() {
    sub_u8s(1, 3);
}
</code></pre>
<p>All integer types previously mentioned fit into a <code>felt252</code>, except for <code>u256</code>
which needs 4 more bits to be stored. Under the hood, <code>u256</code> is basically a
struct with 2 fields: <code>u256 {low: u128, high: u128}</code>.</p>
<p>Cairo also provides support for signed integers, starting with the prefix <code>i</code>.
These integers can represent both positive and negative values, with sizes
ranging from <code>i8</code> to <code>i128</code>. Each signed variant can store numbers from \(
-({2^{n - 1}}) \) to \( {2^{n - 1}} - 1 \) inclusive, where <code>n</code> is the number
of bits that variant uses. So an i8 can store numbers from \( -({2^7}) \) to
\( {2^7} - 1 \), which equals <code>-128</code> to <code>127</code>.</p>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note that
number literals that can be multiple numeric types allow a type suffix, such as
<code>57_u8</code>, to designate the type. It is also possible to use a visual separator
<code>_</code> for number literals, in order to improve code readability.</p>
<div class="table-wrapper"><table><thead><tr><th>Numeric literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o04321</code></td></tr>
<tr><td>Binary</td><td><code>0b01</code></td></tr>
</tbody></table>
</div><br>
<div align="center"><span class="caption">Table 3-2: Integer Literals in Cairo.</span></div>
<p>So how do you know which type of integer to use? Try to estimate the max value
your int can have and choose the good size. The primary situation in which you’d
use <code>usize</code> is when indexing some sort of collection.</p>
<h3 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h3>
<p>Cairo supports the basic mathematical operations you’d expect for all the
integer types: addition, subtraction, multiplication, division, and remainder.
Integer division truncates toward zero to the nearest integer. The following
code shows how you’d use each numeric operation in a <code>let</code> statement:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}
</code></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable.</p>
<p><a href="./appendix-02-operators-and-symbols.html#operators">Appendix B</a> contains a list of all operators that Cairo provides.</p>
<h3 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h3>
<p>As in most other programming languages, a Boolean type in Cairo has two possible
values: <code>true</code> and <code>false</code>. Booleans are one <code>felt252</code> in size. The Boolean type
in Cairo is specified using <code>bool</code>. For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
<p>When declaring a <code>bool</code> variable, it is mandatory to use either <code>true</code> or
<code>false</code> literals as value. Hence, it is not allowed to use integer literals
(i.e. <code>0</code> instead of false) for <code>bool</code> declarations.</p>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Cairo in the <a href="./ch02-05-control-flow.html">"Control
Flow"</a> section.</p>
<h3 id="string-types"><a class="header" href="#string-types">String Types</a></h3>
<p>Cairo doesn't have a native type for strings but provides two ways to handle
them: short strings using simple quotes and ByteArray using double quotes.</p>
<h4 id="short-strings"><a class="header" href="#short-strings">Short strings</a></h4>
<p>A short string is an ASCII string where each character is encoded on one byte
(see the <a href="https://www.asciitable.com/">ASCII table</a>). For example:</p>
<ul>
<li><code>'a'</code> is equivalent to <code>0x61</code></li>
<li><code>'b'</code> is equivalent to <code>0x62</code></li>
<li><code>'c'</code> is equivalent to <code>0x63</code></li>
<li><code>0x616263</code> is equivalent to <code>'abc'</code>.</li>
</ul>
<p>Cairo uses the <code>felt252</code> for short strings. As the <code>felt252</code> is on 251 bits, a
short string is limited to 31 characters (31 * 8 = 248 bits, which is the
maximum multiple of 8 that fits in 251 bits).</p>
<p>You can choose to represent your short string with an hexadecimal value like
<code>0x616263</code> or by directly writing the string using simple quotes like <code>'abc'</code>,
which is more convenient.</p>
<p>Here are some examples of declaring short strings in Cairo:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span>fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
<span class="boring">    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;
</span><span class="boring">
</span><span class="boring">    let long_string: ByteArray = "this is a string which has more than 31 characters";
</span><span class="boring">}
</span></code></pre>
<h4 id="byte-array-strings"><a class="header" href="#byte-array-strings">Byte Array Strings</a></h4>
<p>Cairo's Core Library provides a <code>ByteArray</code> type for handling strings and byte
sequences longer than short strings. This type is particularly useful for longer
strings or when you need to perform operations on the string data.</p>
<p>The <code>ByteArray</code> in Cairo is implemented as a combination of two parts:</p>
<ol>
<li>An array of <code>bytes31</code> words, where each word contains 31 bytes of data.</li>
<li>A pending <code>felt252</code> word that acts as a buffer for bytes that haven't yet
filled a complete <code>bytes31</code> word.</li>
</ol>
<p>This design enables efficient handling of byte sequences while aligning with
Cairo's memory model and basic types. Developers interact with <code>ByteArray</code>
through its provided methods and operators, abstracting away the internal
implementation details.</p>
<p>Unlike short strings, <code>ByteArray</code> strings can contain more than 31 characters
and are written using double quotes:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let my_first_char = 'C';
</span><span class="boring">    let my_first_char_in_hex = 0x43;
</span><span class="boring">
</span><span class="boring">    let my_first_string = 'Hello world';
</span><span class="boring">    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;
</span>
<span class="boring">    let long_string: ByteArray = "this is a string which has more than 31 characters";
</span><span class="boring">}
</span></code></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h3>
<p>A <em>tuple</em> is a general way of grouping together a number of values with a
variety of types into one compound type. Tuples have a fixed length: once
declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup: (u32, u64, bool) = (10, 20, true);
}
</code></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can use
pattern matching to destructure a tuple value, like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        println!("y is 6!");
    }
}
</code></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em> because it breaks
the single tuple into three parts. Finally, the program prints <code>y is 6!</code> as the
value of <code>y</code> is <code>6</code>.</p>
<p>We can also declare the tuple with value and types, and destructure it at the
same time. For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let (x, y): (felt252, felt252) = (2, 3);
}
</code></pre>
<h4 id="the-unit-type-"><a class="header" href="#the-unit-type-">The Unit Type ()</a></h4>
<p>A <em>unit type</em> is a type which has only one value <code>()</code>. It is represented by a
tuple with no elements. Its size is always zero, and it is guaranteed to not
exist in the compiled code.</p>
<p>You might be wondering why you would even need a unit type? In Cairo, everything
is an expression, and an expression that returns nothing actually returns <code>()</code>
implicitly.</p>
<h3 id="the-fixed-size-array-type"><a class="header" href="#the-fixed-size-array-type">The Fixed Size Array Type</a></h3>
<p>Another way to have a collection of multiple values is with a <em>fixed size
array</em>. Unlike a tuple, every element of a fixed size array must have the same
type.</p>
<p>We write the values in a fixed-size array as a comma-separated list inside
square brackets. The array’s type is written using square brackets with the type
of each element, a semicolon, and then the number of elements in the array, like
so:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: [u64; 5] = [1, 2, 3, 4, 5];
}
</code></pre>
<p>In the type annotation <code>[u64; 5]</code>, <code>u64</code> specifies the type of each element,
while <code>5</code> after the semicolon defines the array's length. This syntax ensures
that the array always contains exactly 5 elements of type <code>u64</code>.</p>
<p>Fixed size arrays are useful when you want to hardcode a potentially long
sequence of data directly in your program. This type of array must not be
confused with the <a href="./ch03-01-arrays.html"><code>Array&lt;T&gt;</code> type</a>, which is a similar collection type
provided by the core library that <em>is</em> allowed to grow in size. If you're unsure
whether to use a fixed size array or the <code>Array&lt;T&gt;</code> type, chances are that you
are looking for the <code>Array&lt;T&gt;</code> type.</p>
<p>Because their size is known at compile-time, fixed-size arrays don't require
runtime memory management, which makes them more efficient than
dynamically-sized arrays. Overall, they're more useful when you know the number
of elements will not need to change. For example, they can be used to
efficiently store lookup tables that won't change during runtime. If you were
using the names of the month in a program, you would probably use a fixed size
array rather than an <code>Array&lt;T&gt;</code> because you know it will always contain 12
elements:</p>
<pre><code class="language-cairo">    let months = [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December',
    ];

</code></pre>
<p>You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:</p>
<pre><code class="language-cairo">    let a = [3; 5];
</code></pre>
<p>The array named <code>a</code> will contain <code>5</code> elements that will all be set to the value
<code>3</code> initially. This is the same as writing <code>let a = [3, 3, 3, 3, 3];</code> but in a
more concise way.</p>
<h4 id="accessing-fixed-size-arrays-elements"><a class="header" href="#accessing-fixed-size-arrays-elements">Accessing Fixed Size Arrays Elements</a></h4>
<p>As a fixed-size array is a data structure known at compile time, it's content is
represented as a sequence of values in the program bytecode. Accessing an
element of that array will simply read that value from the program bytecode
efficiently.</p>
<p>We have two different ways of accessing fixed size array elements:</p>
<ul>
<li>Deconstructing the array into multiple variables, as we did with tuples.</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by deconstruction
    let [a, b, c, _, _] = my_arr;
    println!("c: {}", c); // c: 3
}
</code></pre>
<ul>
<li>Converting the array to a <a href="./ch03-01-arrays.html#span">Span</a>, that supports indexing. This operation
is <em>free</em> and doesn't incur any runtime cost.</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by index
    let my_span = my_arr.span();
    println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
}
</code></pre>
<p>Note that if we plan to repeatedly access the array, then it makes sense to call
<code>.span()</code> only once and keep it available throughout the accesses.</p>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<p>Cairo addresses conversion between types by using the <code>try_into</code> and <code>into</code>
methods provided by the <code>TryInto</code> and <code>Into</code> traits from the core library. There
are numerous implementations of these traits within the standard library for
conversion between types, and they can be implemented for <a href="./ch05-02-an-example-program-using-structs.html#conversions-of-custom-types">custom types as
well</a>.</p>
<h3 id="into"><a class="header" href="#into">Into</a></h3>
<p>The <code>Into</code> trait allows for a type to define how to convert itself into another
type. It can be used for type conversion when success is guaranteed, such as
when the source type is smaller than the destination type.</p>
<p>To perform the conversion, call <code>var.into()</code> on the source value to convert it
to another type. The new variable's type must be explicitly defined, as
demonstrated in the example below.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_u8: u8 = 10;
    let my_u16: u16 = my_u8.into();
    let my_u32: u32 = my_u16.into();
    let my_u64: u64 = my_u32.into();
    let my_u128: u128 = my_u64.into();

    let my_felt252 = 10;
    // As a felt252 is smaller than a u256, we can use the into() method
    let my_u256: u256 = my_felt252.into();
    let my_other_felt252: felt252 = my_u8.into();
    let my_third_felt252: felt252 = my_u16.into();
}
</code></pre>
<h3 id="tryinto"><a class="header" href="#tryinto">TryInto</a></h3>
<p>Similar to <code>Into</code>, <code>TryInto</code> is a generic trait for converting between types.
Unlike <code>Into</code>, the <code>TryInto</code> trait is used for fallible conversions, and as
such, returns <a href="./ch06-01-enums.html#the-option-enum-and-its-advantages">Option&lt;T&gt;</a>. An example of a fallible conversion is when
the target type might not fit the source value.</p>
<p>Also similar to <code>Into</code> is the process to perform the conversion; just call
<code>var.try_into()</code> on the source value to convert it to another type. The new
variable's type also must be explicitly defined, as demonstrated in the example
below.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_u256: u256 = 10;

    // Since a u256 might not fit in a felt252, we need to unwrap the Option&lt;T&gt; type
    let my_felt252: felt252 = my_u256.try_into().unwrap();
    let my_u128: u128 = my_felt252.try_into().unwrap();
    let my_u64: u64 = my_u128.try_into().unwrap();
    let my_u32: u32 = my_u64.try_into().unwrap();
    let my_u16: u16 = my_u32.try_into().unwrap();
    let my_u8: u8 = my_u16.try_into().unwrap();

    let my_large_u16: u16 = 2048;
    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch02-02-data-types&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;In general, a **signed** number with *n* bits can represent numbers between -(2&lt;sup&gt;n - 1&lt;/sup&gt;) and 2&lt;sup&gt;n - 1&lt;/sup&gt; - 1. For **unsigned** numbers the range is from 0 to 2&lt;sup&gt;n&lt;/sup&gt; - 1.\n&quot;,&quot;id&quot;:&quot;4fd0bdba-6ef4-44ad-b552-953b09b814d7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;2&lt;sup&gt;127&lt;/sup&gt; - 1&quot;},&quot;prompt&quot;:{&quot;answerIndex&quot;:3,&quot;distractors&quot;:[&quot;2&lt;sup&gt;127&lt;/sup&gt;&quot;,&quot;2&lt;sup&gt;128&lt;/sup&gt;&quot;,&quot;This type can hold any number.&quot;],&quot;prompt&quot;:&quot;The largest number representable by the type `i128` is:&quot;}},{&quot;context&quot;:&quot;`u8` is an unsigned integer type which cannot contain negative numbers.\n&quot;,&quot;id&quot;:&quot;4d5cab51-6eca-4aa0-8666-993acdd85c8d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It will always panic.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It will return `-1`.&quot;,&quot;Compiler will issue a warning about underflow.&quot;],&quot;prompt&quot;:&quot;If `x : u8 = 0`, what will happen when computing `x - 1`?&quot;}},{&quot;context&quot;:&quot;The type `felt32` does not exist. Proper field type is `felt252`.\n&quot;,&quot;id&quot;:&quot;dc1e6fa1-0d7b-479e-98ac-6a514d60eb1b&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:2},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n  let x: felt32 = 2;\n  println!(\&quot;{x}\&quot;);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are prevalent in Cairo code. You’ve already seen one of the most
important functions in the language: the <code>main</code> function, which is the entry
point of many programs. You’ve also seen the <code>fn</code> keyword, which allows you to
declare new functions.</p>
<p>Cairo code uses <em>snake case</em> as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words. Here’s
a program that contains an example function definition:</p>
<pre><code class="language-cairo">fn another_function() {
    println!("Another function.");
}

#[executable]
fn main() {
    println!("Hello, world!");
    another_function();
}
</code></pre>
<p>We define a function in Cairo by entering <code>fn</code> followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function body
begins and ends.</p>
<p>We can call any function we’ve defined by entering its name followed by a set of
parentheses. Because <code>another_function</code> is defined in the program, it can be
called from inside the <code>main</code> function. Note that we defined <code>another_function</code>
<em>before</em> the <code>main</code> function in the source code; we could have defined it after
as well. Cairo doesn’t care where you define your functions, only that they’re
defined somewhere in a scope that can be seen by the caller.</p>
<p>Let’s start a new project with Scarb named <em>functions</em> to explore functions
further. Place the <code>another_function</code> example in <em>src/lib.cairo</em> and run it. You
should see the following output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_15_functions
Hello, world!
Another function.


</code></pre>
<p>The lines execute in the order in which they appear in the <code>main</code> function.
First the <code>Hello, world!</code> message prints, and then <code>another_function</code> is called
and its message is printed.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>We can define functions to have <em>parameters</em>, which are special variables that
are part of a function’s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called <em>arguments</em>, but in casual conversation, people tend to use
the words <em>parameter</em> and <em>argument</em> interchangeably for either the variables in
a function’s definition or the concrete values passed in when you call a
function.</p>
<p>In this version of <code>another_function</code> we add a parameter:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}
</code></pre>
<p>Try running this program; you should get the following output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_16_single_param
The value of x is: 5


</code></pre>
<p>The declaration of <code>another_function</code> has one parameter named <code>x</code>. The type of
<code>x</code> is specified as <code>felt252</code>. When we pass <code>5</code> in to <code>another_function</code>, the
<code>println!</code> macro puts <code>5</code> where the pair of curly brackets containing <code>x</code> was in
the format string.</p>
<p>In function signatures, you <em>must</em> declare the type of each parameter. This is a
deliberate decision in Cairo’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean. The compiler is also able to give
more helpful error messages if it knows what types the function expects.</p>
<p>When defining multiple parameters, separate the parameter declarations with
commas, like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}
</code></pre>
<p>This example creates a function named <code>print_labeled_measurement</code> with two
parameters. The first parameter is named <code>value</code> and is a <code>u128</code>. The second is
named <code>unit_label</code> and is of type <code>ByteArray</code> - Cairo's internal type to
represent string literals. The function then prints text containing both the
<code>value</code> and the <code>unit_label</code>.</p>
<p>Let’s try running this code. Replace the program currently in your <em>functions</em>
project’s <em>src/lib.cairo</em> file with the preceding example and run it using
<code>scarb execute</code>:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_17_multiple_params
The measurement is: 5h


</code></pre>
<p>Because we called the function with <code>5</code> as the value for value and <code>"h"</code> as the
value for <code>unit_label</code>, the program output contains those values.</p>
<h3 id="named-parameters"><a class="header" href="#named-parameters">Named Parameters</a></h3>
<p>In Cairo, named parameters allow you to specify the names of arguments when you
call a function. This makes the function calls more readable and
self-descriptive. If you want to use named parameters, you need to specify the
name of the parameter and the value you want to pass to it. The syntax is
<code>parameter_name: value</code>. If you pass a variable that has the same name as the
parameter, you can simply write <code>:parameter_name</code> instead of
<code>parameter_name: variable_name</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo">fn foo(x: u8, y: u8) {}

#[executable]
fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}
</code></pre>
<h2 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h2>
<p>Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we’ve covered haven’t included an ending
expression, but you have seen an expression as part of a statement. Because
Cairo is an expression-based language, this is an important distinction to
understand. Other languages don’t have the same distinctions, so let’s look at
what statements and expressions are and how their differences affect the bodies
of functions.</p>
<ul>
<li><strong>Statements</strong> are instructions that perform some action and do not return a
value.</li>
<li><strong>Expressions</strong> evaluate to a resultant value. Let’s look at some examples.</li>
</ul>
<p>We’ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the <code>let</code> keyword is a statement. In Listing
2-1, <code>let y = 6;</code> is a statement.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let y = 6;
}
</code></pre>
<p>function declaration containing one statement</span></p>
<p>Function definitions are also statements; the entire preceding example is a
statement in itself.</p>
<p>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement
to another variable, as the following code tries to do; you’ll get an error:</p>
<pre><code class="language-cairo  noplayground">#[executable]
fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>When you run this program, the error you’ll get looks like this:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token ')'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to 4 previous errors and 2 warnings
error: `scarb` command exited with error

</code></pre>
<p>The <code>let y = 6</code> statement does not return a value, so there isn’t anything for
<code>x</code> to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value
<code>6</code>; that is not the case in Cairo.</p>
<p>Expressions evaluate to a value and make up most of the rest of the code that
you’ll write in Cairo. Consider a math operation, such as <code>5 + 6</code>, which is an
expression that evaluates to the value <code>11</code>. Expressions can be part of
statements: in Listing 2-1, the <code>6</code> in the statement <code>let y = 6;</code>
is an expression that evaluates to the value <code>6</code>.</p>
<p>Calling a function is an expression since it always evaluates to a value: the
function's explicit return value, if specified, or the 'unit' type <code>()</code>
otherwise.</p>
<p>A new scope block created with curly brackets is an expression, for example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
<p>This expression:</p>
<pre><code class="language-cairo  noplayground">    let y = {
        let x = 3;
        x + 1
    };
</code></pre>
<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code> as
part of the <code>let</code> statement. Note that the <code>x + 1</code> line doesn’t have a semicolon
at the end, which is unlike most of the lines you’ve seen so far. Expressions do
not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, and it will then not return a value.
Keep this in mind as you explore function return values and expressions next.</p>
<h2 id="functions-with-return-values"><a class="header" href="#functions-with-return-values">Functions with Return Values</a></h2>
<p>Functions can return values to the code that calls them. We don’t name return
values, but we must declare their type after an arrow (<code>-&gt;</code>). In Cairo, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the <code>return</code> keyword and specifying a value, but most
functions return the last expression implicitly. Here’s an example of a function
that returns a value:</p>
<pre><code class="language-cairo">fn five() -&gt; u32 {
    5
}

#[executable]
fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
</code></pre>
<p>There are no function calls, or even <code>let</code> statements in the <code>five</code>
function—just the number <code>5</code> by itself. That’s a perfectly valid function in
Cairo. Note that the function’s return type is specified too, as <code>-&gt; u32</code>. Try
running this code; the output should look like this:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_20_function_return_values
The value of x is: 5


</code></pre>
<p>The <code>5</code> in <code>five</code> is the function’s return value, which is why the return type
is <code>u32</code>. Let’s examine this in more detail. There are two important bits:
first, the line <code>let x = five();</code> shows that we’re using the return value of a
function to initialize a variable. Because the function <code>five</code> returns a <code>5</code>,
that line is the same as the following:</p>
<pre><code class="language-cairo  noplayground">let x = 5;
</code></pre>
<p>Second, the <code>five</code> function has no parameters and defines the type of the return
value, but the body of the function is a lonely <code>5</code> with no semicolon because
it’s an expression whose value we want to return. Let’s look at another example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1
}
</code></pre>
<p>Running this code will print <code>x = 6</code>. But if we place a semicolon at the end of
the line containing <code>x + 1</code>, changing it from an expression to a statement,
we’ll get an error:</p>
<pre><code class="language-cairo does_not_compile">#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1;
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --&gt; listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:10:24
fn plus_one(x: u32) -&gt; u32 {
                       ^^^

error: could not compile `no_listing_22_function_return_invalid` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<p>The main error message, <code>Unexpected return type</code>, reveals the core issue with
this code. The definition of the function <code>plus_one</code> says that it will return an
<code>u32</code>, but statements don’t evaluate to a value, which is expressed by <code>()</code>, the
unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error.</p>
<h3 id="const-functions"><a class="header" href="#const-functions">Const Functions</a></h3>
<p>Functions that can be evaluated at compile time can be marked as <code>const</code> using
the <code>const fn</code> syntax. This allows the function to be called from a constant
context and interpreted by the compiler at compile time.</p>
<p>Declaring a function as <code>const</code> restricts the types that arguments and the
return type may use, and limits the function body to constant expressions.</p>
<p>Several functions in the core library are marked as <code>const</code>. Here's an example
from the core library showing the <code>pow</code> function implemented as a <code>const fn</code>:</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

const BYTE_MASK: u16 = 2_u16.pow(8) - 1;

#[executable]
fn main() {
    let my_value = 12345;
    let first_byte = my_value &amp; BYTE_MASK;
    println!("first_byte: {}", first_byte);
}
</code></pre>
<p>In this example, <code>pow</code> is a <code>const</code> function, allowing it to be used in a
constant expression to define <code>mask</code> at compile time. Here's a snippet of how
<code>pow</code> is defined in the core library using <code>const fn</code>:</p>
<p>Note that declaring a function as <code>const</code> has no effect on existing uses; it
only imposes restrictions for constant contexts.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch02-03-functions&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;fa63d18f-fee3-4923-962b-bdeabbf61fbd&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;fn&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;The keyword for declaring a new function in Cairo is:&quot;}},{&quot;context&quot;:&quot;A function must declare the types of its parameters. In this case, function `f` could be corrected by adding `u8` type to the `x` parameter like this: `fn f(x:u8)`.\n&quot;,&quot;id&quot;:&quot;6343598f-380f-4a59-b6fb-7dfadc397f74&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:1},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn f(x) {\n  println!(\&quot;{x}\&quot;);\n}\n\n#[executable]\nfn main() {\n  f(0);\n}\n&quot;}},{&quot;context&quot;:&quot;A block is an expression (#1) that is allowed to contain statements. It also defines a syntactic scope for let-bindings inside it (#3).\n&quot;,&quot;id&quot;:&quot;695f318f-539b-4ce8-9c00-92e29f7f1bb3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;1 and 3&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1 only&quot;,&quot;2 only&quot;,&quot;2 and 3&quot;],&quot;prompt&quot;:&quot;In Cairo, a curly-brace block like `{ /* ... */ }` is:\n1. An expression\n2. A statement\n3. A syntactic scope\n&quot;}},{&quot;id&quot;:&quot;7bbc0afb-2ad7-4d8d-97fd-610a65a85e38&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;3&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn f(x: usize) -&gt; usize { x + 1 }\n#[executable]\nfn main() {\n  println!(\&quot;{}\&quot;, f({\n    let y = 1;\n    y + 1\n  }));\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave comments in
their source code that the compiler will ignore but people reading the source
code may find useful.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-cairo noplayground">// hello, world
</code></pre>
<p>In Cairo, the idiomatic comment style starts a comment with two slashes, and the
comment continues until the end of the line. For comments that extend beyond a
single line, you’ll need to include <code>//</code> on each line, like this:</p>
<pre><code class="language-cairo noplayground">// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    1 + 4 // return the sum of 1 and 4
}
</code></pre>
<p>But you’ll more often see them used in this format, with the comment on a
separate line above the code it’s annotating:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    // this function performs a simple addition
    1 + 4
}
</code></pre>
<h2 id="item-level-documentation"><a class="header" href="#item-level-documentation">Item-level Documentation</a></h2>
<p>Item-level documentation comments refer to specific items such as functions,
implementations, traits, etc. They are prefixed with three slashes (<code>///</code>).
These comments provide a detailed description of the item, examples of usage,
and any conditions that might cause a panic. In case of functions, the comments
may also include separate sections for parameter and return value descriptions.</p>
<pre><code class="language-cairo noplayground">/// Returns the sum of `arg1` and `arg2`.
/// `arg1` cannot be zero.
///
/// # Panics
///
/// This function will panic if `arg1` is `0`.
///
/// # Examples
///
/// ```
/// let a: felt252 = 2;
/// let b: felt252 = 3;
/// let c: felt252 = add(a, b);
/// assert!(c == a + b, "Should equal a + b");
/// ```
fn add(arg1: felt252, arg2: felt252) -&gt; felt252 {
    assert!(arg1 != 0, "Cannot be zero");
    arg1 + arg2
}
</code></pre>
<h2 id="module-documentation"><a class="header" href="#module-documentation">Module Documentation</a></h2>
<p>Module documentation comments provide an overview of the entire module,
including its purpose and examples of use. These comments are meant to be placed
above the module they're describing and are prefixed with <code>//!</code>. This type of
documentation gives a broad understanding of what the module does and how it can
be used.</p>
<pre><code class="language-cairo noplayground">//! # my_module and implementation
//!
//! This is an example description of my_module and some of its features.
//!
//! # Examples
//!
//! ```
//! mod my_other_module {
//!   use path::to::my_module;
//!
//!   fn foo() {
//!     my_module.bar();
//!   }
//! }
//! ```
mod my_module { // rest of implementation...
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch02-04-comments&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;ed752dc7-dffd-4ccb-9571-fd442aafe998&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;//&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;What is the syntax introducing a comment?&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>The ability to run some code depending on whether a condition is true and to run
some code repeatedly while a condition is true are basic building blocks in most
programming languages. The most common constructs that let you control the flow
of execution of Cairo code are if expressions and loops.</p>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> Expressions</a></h2>
<p>An if expression allows you to branch your code depending on conditions. You
provide a condition and then state, “If this condition is met, run this block of
code. If the condition is not met, do not run this block of code.”</p>
<p>Create a new project called <em>branches</em> in your <em>cairo_projects</em> directory to
explore the <code>if</code> expression. In the <em>src/lib.cairo</em> file, input the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}
</code></pre>
<p>All <code>if</code> expressions start with the keyword <code>if</code>, followed by a condition. In
this case, the condition checks whether or not the variable <code>number</code> has a value
equal to 5. We place the block of code to execute if the condition is <code>true</code>
immediately after the condition inside curly brackets.</p>
<p>Optionally, we can also include an <code>else</code> expression, which we chose to do here,
to give the program an alternative block of code to execute should the condition
evaluate to <code>false</code>. If you don’t provide an <code>else</code> expression and the condition
is <code>false</code>, the program will just skip the <code>if</code> block and move on to the next
bit of code.</p>
<p>Try running this code; you should see the following output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_24_if
condition was false and number = 3


</code></pre>
<p>Let’s try changing the value of <code>number</code> to a value that makes the condition
<code>true</code> to see what happens:</p>
<pre><code class="language-cairo  noplayground">    let number = 5;
</code></pre>
<pre><code class="language-shell">$ scarb execute
condition was true and number = 5
Run completed successfully, returning []
</code></pre>
<p>It’s also worth noting that the condition in this code must be a <code>bool</code>. If the
condition isn’t a <code>bool</code>, we’ll get an error. For example, try running the
following code:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
</code></pre>
<p>The <code>if</code> condition evaluates to a value of 3 this time, and Cairo throws an
error:</p>
<pre><code class="language-shell">$ scarb build 
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --&gt; listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:5:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to 1 previous error

</code></pre>
<p>The error indicates that Cairo inferred the type of <code>number</code> to be a <code>bool</code>
based on its later use as a condition of the <code>if</code> statement. It tries to create
a <code>bool</code> from the value <code>3</code>, but Cairo doesn't support instantiating a <code>bool</code>
from a numeric literal anyway - you can only use <code>true</code> or <code>false</code> to create a
<code>bool</code>. Unlike languages such as Ruby and JavaScript, Cairo will not
automatically try to convert non-Boolean types to a Boolean. If we want the <code>if</code>
code block to run only when a number is not equal to 0, for example, we can
change the if expression to the following:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

</code></pre>
<p>Running this code will print <code>number was something other than zero</code>.</p>
<h2 id="handling-multiple-conditions-with-else-if"><a class="header" href="#handling-multiple-conditions-with-else-if">Handling Multiple Conditions with <code>else if</code></a></h2>
<p>You can use multiple conditions by combining <code>if</code> and <code>else</code> in an <code>else if</code>
expression. For example:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}
</code></pre>
<p>This program has four possible paths it can take. After running it, you should
see the following output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_25_else_if
number is 3


</code></pre>
<p>When this program executes, it checks each <code>if</code> expression in turn and executes
the first body for which the condition evaluates to <code>true</code>. Note that even
though <code>number - 2 == 1</code> is <code>true</code>, we don’t see the output
<code>number minus 2 is 1</code> nor do we see the <code>number not found</code> text from the <code>else</code>
block. That’s because Cairo only executes the block for the first true
condition, and once it finds one, it doesn’t even check the rest. Using too many
<code>else if</code> expressions can clutter your code, so if you have more than one, you
might want to refactor your code. <a href="./ch06-02-the-match-control-flow-construct.html">Chapter
6</a> describes a powerful Cairo
branching construct called <code>match</code> for these cases.</p>
<h2 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> Statement</a></h2>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code>
statement to assign the outcome to a variable.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_26_if_let
condition was true and number is 5


</code></pre>
<p>The <code>number</code> variable will be bound to a value based on the outcome of the <code>if</code>
expression, which will be 5 here.</p>
<h2 id="repetition-with-loops"><a class="header" href="#repetition-with-loops">Repetition with Loops</a></h2>
<p>It’s often useful to execute a block of code more than once. For this task,
Cairo provides a simple loop syntax, which will run through the code inside the
loop body to the end and then start immediately back at the beginning. To
experiment with loops, let’s create a new project called <em>loops</em>.</p>
<p>Cairo has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Let’s try each one.</p>
<h3 id="repeating-code-with-loop"><a class="header" href="#repeating-code-with-loop">Repeating Code with <code>loop</code></a></h3>
<p>The <code>loop</code> keyword tells Cairo to execute a block of code over and over again
forever or until you explicitly tell it to stop.</p>
<p>As an example, change the <em>src/lib.cairo</em> file in your <em>loops</em> directory to look
like this:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously
until either the program runs out of gas or we stop the program manually. Most
terminals support the keyboard shortcut ctrl-c to interrupt a program that is
stuck in a continual loop. Give it a try:</p>
<pre><code class="language-shell">$ scarb execute --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed ctrl-c. You may or may not see the
word <code>again!</code> printed after the ^C, depending on where the code was in the loop
when it received the interrupt signal.</p>
<blockquote>
<p>Note: Cairo prevents us from running program with infinite loops by including
a gas meter. The gas meter is a mechanism that limits the amount of
computation that can be done in a program. By setting a value to the
<code>--available-gas</code> flag, we can set the maximum amount of gas available to the
program. Gas is a unit of measurement that expresses the computation cost of
an instruction. When the gas meter runs out, the program will stop. In the
previous case, we set the gas limit high enough for the program to run for
quite some time.</p>
</blockquote>
<blockquote>
<p>It is particularly important in the context of smart contracts deployed on
Starknet, as it prevents from running infinite loops on the network. If you're
writing a program that needs to run a loop, you will need to execute it with
the <code>--available-gas</code> flag set to a value that is large enough to run the
program.</p>
</blockquote>
<p>Now, try running the same program again, but this time with the
<code>--available-gas</code> flag set to <code>200000</code> instead of <code>2000000000000</code>. You will see
the program only prints <code>again!</code> 3 times before it stops, as it ran out of gas
to keep executing the loop.</p>
<p>Fortunately, Cairo also provides a way to break out of a loop using code. You
can place the <code>break</code> keyword within the loop to tell the program when to stop
executing the loop.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p>The <code>continue</code> keyword tells the program to go to the next iteration of the loop
and to skip the rest of the code in this iteration. Let's add a <code>continue</code>
statement to our loop to skip the <code>println!</code> statement when <code>i</code> is equal to <code>5</code>.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p>Executing this program will not print the value of <code>i</code> when it is equal to <code>5</code>.</p>
<h3 id="returning-values-from-loops"><a class="header" href="#returning-values-from-loops">Returning Values from Loops</a></h3>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such
as checking whether an operation has succeeded. You might also need to pass the
result of that operation out of the loop to the rest of your code. To do this,
you can add the value you want returned after the <code>break</code> expression you use to
stop the loop; that value will be returned out of the loop so you can use it, as
shown here:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}
</code></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to <code>0</code>.
Then we declare a variable named <code>result</code> to hold the value returned from the
loop. On every iteration of the loop, we check whether the <code>counter</code> is equal to
<code>10</code>, and then add <code>1</code> to the <code>counter</code> variable. When the condition is met, we
use the <code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a
semicolon to end the statement that assigns the value to <code>result</code>. Finally, we
print the value in <code>result</code>, which in this case is <code>20</code>.</p>
<h3 id="conditional-loops-with-while"><a class="header" href="#conditional-loops-with-while">Conditional Loops with <code>while</code></a></h3>
<p>A program will often need to evaluate a condition within a loop. While the
condition is <code>true</code>, the loop runs. When the condition ceases to be <code>true</code>, the
program calls <code>break</code>, stopping the loop. It’s possible to implement behavior
like this using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could
try that now in a program, if you’d like. However, this pattern is so common
that Cairo has a built-in language construct for it, called a <code>while</code> loop.</p>
<p>In Listing 2-2, we use <code>while</code> to loop the program three times,
counting down each time after printing the value of <code>number</code>, and then, after
the loop, print a message and exit.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
<p><code>while</code> loop to run code while a condition holds <code>true</code>.</span></p>
<p>This construct eliminates a lot of nesting that would be necessary if you used
<code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>, and it’s clearer. While a condition evaluates
to <code>true</code>, the code runs; otherwise, it exits the loop.</p>
<h3 id="looping-through-a-collection-with-for"><a class="header" href="#looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h3>
<p>You can also use the while construct to loop over the elements of a collection,
such as an array. For example, the loop in Listing 2-3 prints
each element in the array <code>a</code>.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
</code></pre>
<p>through each element of a collection using a <code>while</code> loop</span></p>
<p>Here, the code counts up through the elements in the array. It starts at index
<code>0</code>, and then loops until it reaches the final index in the array (that is, when
<code>index &lt; 5</code> is no longer <code>true</code>). Running this code will print every element in
the array:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50


</code></pre>
<p>All five array values appear in the terminal, as expected. Even though <code>index</code>
will reach a value of <code>5</code> at some point, the loop stops executing before trying
to fetch a sixth value from the array.</p>
<p>However, this approach is error prone; we could cause the program to panic if
the index value or test condition is incorrect. For example, if you changed the
definition of the <code>a</code> array to have four elements but forgot to update the
condition to <code>while index &lt; 4</code>, the code would panic. It’s also slow, because
the compiler adds runtime code to perform the conditional check of whether the
index is within the bounds of the array on every iteration through the loop.</p>
<p>As a more concise alternative, you can use a <code>for</code> loop and execute some code
for each item in a collection. A <code>for</code> loop looks like the code in Listing
2-4.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}
</code></pre>
<p>through each element of a collection using a <code>for</code> loop</span></p>
<p>When we run this code, we’ll see the same output as in Listing
2-3. More importantly, we’ve now increased the safety of the
code and eliminated the chance of bugs that might result from going beyond the
end of the array or not going far enough and missing some items.</p>
<p>Using the <code>for</code> loop, you wouldn’t need to remember to change any other code if
you changed the number of values in the array, as you would with the method used
in Listing 2-3.</p>
<p>The safety and conciseness of <code>for</code> loops make them the most commonly used loop
construct in Cairo. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a while loop in
Listing 2-2. Another way to run code a certain number of times
would be to use a <code>Range</code>, provided by the core library, which generates all
numbers in sequence starting from one number and ending before another number.</p>
<p>Here’s how you can use a <code>Range</code> to count from 1 to 3:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    }
    println!("Go!!!");
}
</code></pre>
<p>This code is a bit nicer, isn’t it?</p>
<h2 id="equivalence-between-loops-and-recursive-functions"><a class="header" href="#equivalence-between-loops-and-recursive-functions">Equivalence Between Loops and Recursive Functions</a></h2>
<p>Loops and recursive functions are two common ways to repeat a block of code
multiple times. The <code>loop</code> keyword is used to create an infinite loop that can
be broken by using the <code>break</code> keyword.</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    }
    x
}
</code></pre>
<p>Loops can be transformed into recursive functions by calling the function within
itself. Here is an example of a recursive function that mimics the behavior of
the <code>loop</code> example above.</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -&gt; felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}
</code></pre>
<p>In both cases, the code block will run indefinitely until the condition <code>x == 2</code>
is met, at which point the value of x will be displayed.</p>
<p>In Cairo, loops and recursions are not only conceptually equivalent: they are
also compiled down to similar low-level representations. To understand this, we
can compile both examples to Sierra, and analyze the Sierra Code generated by
the Cairo compiler for both examples. Add the following in your <code>Scarb.toml</code>
file:</p>
<pre><code class="language-toml">[lib]
sierra-text = true
</code></pre>
<p>Then, run <code>scarb build</code> to compile both examples. You will find that the Sierra
code generated for both examples is extremely similar, as the loop is compiled
to a recursive function in the Sierra statements.</p>
<blockquote>
<p>Note: For our example, our findings came from understanding the <strong>statements</strong>
section in Sierra that shows the execution traces of the two programs. If you
are curious to learn more about Sierra, check out
<a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">Exploring Sierra</a>.</p>
</blockquote>
<div class="quiz-placeholder" data-quiz-name="&quot;ch02-05-control-flow&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The condition to an if-expression must be a boolean. Cairo does not have a concept of \&quot;truthy\&quot; or \&quot;falsy\&quot; values.\n&quot;,&quot;id&quot;:&quot;17a48401-18af-42d3-bc5a-c9fe9d87815e&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:3},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n  let x = 1;\n  let y = if x { 0 } else { 1 };\n  println!(\&quot;{y}\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;When an if condition in Cairo evaluates to true, the program executes the block of code associated with that if condition.\n&quot;,&quot;id&quot;:&quot;2b4f0ad1-ccb2-4854-a8de-9b5067b8a3f1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;2&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;1&quot;,&quot;3&quot;,&quot;1 and 3&quot;],&quot;prompt&quot;:&quot;What happens in Cairo if an if condition evaluates to true?\n\n1. The program skips the if block and executes the next block of code.\n2. The program executes the block of code associated with the if condition.\n3. The program terminates immediately.\n&quot;}},{&quot;id&quot;:&quot;1abbb637-f4cc-42d2-8a02-c85c1002096a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program skips the if block and moves on to the next bit of code.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The program panics.&quot;,&quot;The program executes an implicit else block.&quot;,&quot;The program stops execution.&quot;],&quot;prompt&quot;:&quot;What is the result of running a Cairo program with an if statement where the condition evaluates to false and no else block is provided?\n&quot;}},{&quot;context&quot;:&quot;Cairo supports `loop` and `while` loops that continue execution indefinitely until a break condition is explicitly met or the program runs out of gas.\nThe safety and conciseness of `for` loops make them the most commonly used loop construct in Cairo.\n&quot;,&quot;id&quot;:&quot;5b0baa2b-f5b3-4718-a4d7-9f28c0540e79&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`loop`, `while` or `for` with a break condition.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Automated mechanisms that handle execution retries for you.&quot;,&quot;`while`, `for` or `repeat` until a certain number of iterations is reached.&quot;,&quot;An `if` statement that checks for a condition and repeats execution until the condition is met.&quot;],&quot;prompt&quot;:&quot;What feature does Cairo provide for repeating code execution until a specified condition is met or gas runs out?\n&quot;}},{&quot;context&quot;:&quot;The 'continue' keyword in Cairo skips the remaining code in the current iteration of the loop. In this case, it skips the sum += 10 when 'i = 2'.\n&quot;,&quot;id&quot;:&quot;d2bcb7e6-f234-47b8-9498-4c2332acbd0e&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;40&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n    let mut sum: usize = 0;\n\n    for i in 0..5_usize {\n        if i == 2 {\n            continue;\n        }\n        sum += 10;\n    };\n\n    println!(\&quot;{}\&quot;, sum);\n}\n&quot;}},{&quot;context&quot;:&quot;Can only break with a value inside a `loop`\n&quot;,&quot;id&quot;:&quot;5e2ff5a8-ad4a-47bd-805b-ca58f7821122&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n    let mut i = 0;\n\n     let result = while(i &lt; 10) {\n        if i == 5 {\n            break i * 2;\n        }\n        i += 1;\n    };\n\n    println!(\&quot;The result is {}\&quot;, result);\n}\n&quot;}}]}"></div>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>You made it! This was a sizable chapter: you learned about variables, data
types, functions, comments, <code>if</code> expressions and loops! To practice with the
concepts discussed in this chapter, try building programs to do the following:</p>
<ul>
<li>Generate the <em>n</em>-th Fibonacci number.</li>
<li>Compute the factorial of a number <em>n</em>.</li>
</ul>
<p>Now, we’ll review the common collection types in Cairo in the next chapter.</p>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Cairo provides a set of common collection types that can be used to store and
manipulate data. These collections are designed to be efficient, flexible, and
easy to use. This section introduces the primary collection types available in
Cairo: Arrays and Dictionaries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>An array is a collection of elements of the same type. You can create and use
array methods by using the <code>ArrayTrait</code> trait from the core library.</p>
<p>An important thing to note is that arrays have limited modification options.
Arrays are, in fact, queues whose values can't be modified. This has to do with
the fact that once a memory slot is written to, it cannot be overwritten, but
only read from it. You can only append items to the end of an array and remove
items from the front.</p>
<h2 id="creating-an-array"><a class="header" href="#creating-an-array">Creating an Array</a></h2>
<p>Creating an array is done with the <code>ArrayTrait::new()</code> call. Here's an example
of creating an array and appending 3 elements to it:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}
</code></pre>
<p>When required, you can pass the expected type of items inside the array when
instantiating the array like this, or explicitly define the type of the
variable.</p>
<pre><code class="language-cairo  noplayground">let mut arr = ArrayTrait::&lt;u128&gt;::new();
</code></pre>
<pre><code class="language-cairo  noplayground">let mut arr:Array&lt;u128&gt; = ArrayTrait::new();
</code></pre>
<h2 id="updating-an-array"><a class="header" href="#updating-an-array">Updating an Array</a></h2>
<h3 id="adding-elements"><a class="header" href="#adding-elements">Adding Elements</a></h3>
<p>To add an element to the end of an array, you can use the <code>append()</code> method:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut a = ArrayTrait::new();
</span><span class="boring">    a.append(0);
</span>    a.append(1);
<span class="boring">    a.append(2);
</span><span class="boring">}
</span></code></pre>
<h3 id="removing-elements"><a class="header" href="#removing-elements">Removing Elements</a></h3>
<p>You can only remove elements from the front of an array by using the
<code>pop_front()</code> method. This method returns an <code>Option</code> that can be unwrapped,
containing the removed element, or <code>None</code> if the array is empty.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}
</code></pre>
<p>The above code will print <code>The first value is 10</code> as we remove the first element
that was added.</p>
<p>In Cairo, memory is immutable, which means that it is not possible to modify the
elements of an array once they've been added. You can only add elements to the
end of an array and remove elements from the front of an array. These operations
do not require memory mutation, as they involve updating pointers rather than
directly modifying the memory cells.</p>
<h2 id="reading-elements-from-an-array"><a class="header" href="#reading-elements-from-an-array">Reading Elements from an Array</a></h2>
<p>To access array elements, you can use <code>get()</code> or <code>at()</code> array methods that
return different types. Using <code>arr.at(index)</code> is equivalent to using the
subscripting operator <code>arr[index]</code>.</p>
<h3 id="get-method"><a class="header" href="#get-method"><code>get()</code> Method</a></h3>
<p>The <code>get</code> function returns an <code>Option&lt;Box&lt;@T&gt;&gt;</code>, which means it returns an
option to a Box type (Cairo's smart-pointer type) containing a snapshot to the
element at the specified index if that element exists in the array. If the
element doesn't exist, <code>get</code> returns <code>None</code>. This method is useful when you
expect to access indices that may not be within the array's bounds and want to
handle such cases gracefully without panics. Snapshots will be explained in more
detail in the <a href="./ch04-02-references-and-snapshots.html#snapshots">"References and Snapshots"</a> chapter.</p>
<p>Here is an example with the <code>get()</code> method:</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; u128 {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Some(x) =&gt; {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        None =&gt; { panic!("out of bounds") },
    }
}
</code></pre>
<h3 id="at-method"><a class="header" href="#at-method"><code>at()</code> Method</a></h3>
<p>The <code>at</code> function, and its equivalent the subscripting operator, on the other
hand, directly return a snapshot to the element at the specified index using the
<code>unbox()</code> operator to extract the value stored in a box. If the index is out of
bounds, a panic error occurs. You should only use <code>at</code> when you want the program
to panic if the provided index is out of the array's bounds, which can prevent
unexpected behavior.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}
</code></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>0</code> because that
is the value at index <code>0</code> in the array. The variable named <code>second</code> will get the
value <code>1</code> from index <code>1</code> in the array.</p>
<p>In summary, use <code>at</code> when you want to panic on out-of-bounds access attempts,
and use <code>get</code> when you prefer to handle such cases gracefully without panicking.</p>
<h2 id="size-related-methods"><a class="header" href="#size-related-methods">Size-related Methods</a></h2>
<p>To determine the number of elements in an array, use the <code>len()</code> method. The
return value is of type <code>usize</code>.</p>
<p>If you want to check if an array is empty or not, you can use the <code>is_empty()</code>
method, which returns <code>true</code> if the array is empty and <code>false</code> otherwise.</p>
<h2 id="array-macro"><a class="header" href="#array-macro"><code>array!</code> Macro</a></h2>
<p>Sometimes, we need to create arrays with values that are already known at
compile time. The basic way of doing that is redundant. You would first declare
the array and then append each value one by one. <code>array!</code> is a simpler way of
doing this task by combining the two steps. At compile time, the macro expands
into code that appends the items sequentially. For a deeper explanation of how
declarative macros match patterns and expand, see
<a href="./ch12-05-macros.html#declarative-inline-macros-for-general-metaprogramming">Macros → Declarative Inline Macros</a>.</p>
<p>Without <code>array!</code>:</p>
<pre><code class="language-cairo">    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);
</code></pre>
<p>With <code>array!</code>:</p>
<pre><code class="language-cairo">    let arr = array![1, 2, 3, 4, 5];
</code></pre>
<h2 id="storing-multiple-types-with-enums"><a class="header" href="#storing-multiple-types-with-enums">Storing Multiple Types with Enums</a></h2>
<p>If you want to store elements of different types in an array, you can use an
<code>Enum</code> to define a custom data type that can hold multiple types. Enums will be
explained in more detail in the <a href="./ch06-00-enums-and-pattern-matching.html">"Enums and Pattern Matching"</a> chapter.</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

#[executable]
fn main() {
    let mut messages: Array&lt;Data&gt; = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}
</code></pre>
<h2 id="span"><a class="header" href="#span">Span</a></h2>
<p><code>Span</code> is a struct that represents a snapshot of an <code>Array</code>. It is designed to
provide safe and controlled access to the elements of an array without modifying
the original array. Span is particularly useful for ensuring data integrity and
avoiding borrowing issues when passing arrays between functions or when
performing read-only operations, as introduced in <a href="./ch04-02-references-and-snapshots.html">"References and
Snapshots"</a>.</p>
<p>All methods provided by <code>Array</code> can also be used with <code>Span</code>, except for the
<code>append()</code> method.</p>
<h3 id="turning-an-array-into-span"><a class="header" href="#turning-an-array-into-span">Turning an Array into Span</a></h3>
<p>To create a <code>Span</code> of an <code>Array</code>, call the <code>span()</code> method:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut array: Array&lt;u8&gt; = ArrayTrait::new();
    array.span();
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch03-01-arrays&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;If `til = 4`, then for an array of length 3, the loop will attempt to index the array with `i = 3`,\nwhich is out of bounds.  This function does not panic if `n = 1` because it returns before reaching\nthe out-of-bounds index.\n&quot;,&quot;id&quot;:&quot;dd16401e-9f74-4c86-a6ec-da2937cb26e5&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`find_until(array![1, 2, 3].span(), 4, 4);`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`find_until(array![1, 2, 3].span(), 0, 0);`&quot;,&quot;`find_until(array![1, 2, 3].span(), 3, 3);`&quot;,&quot;`find_until(array![1, 2, 3].span(), 1, 4);`&quot;],&quot;prompt&quot;:&quot;Which call to this `find_until` function will cause a runtime panic?\n\n```\nfn find_until(mut v: Span&lt;u64&gt;, n: u64, til: usize) -&gt; Option&lt;usize&gt; {\n    let mut i = 0;\n    loop {\n        if i == til {\n            break None;\n        }\n        if *v[i] == n {\n            break Some(i);\n        }\n        i += 1;\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;As Cairo's memory layout is immutable, types cannot be moved out of an array by indexing. The only\npossibility is to copy the value to a new variable using the `*` (desnap) operator.  Therefore, as\nByteArray is not copyable, the line `let mut s = *v[0];` does not compile.\n&quot;,&quot;id&quot;:&quot;2e6570eb-8bf4-48b7-9032-5815475bc412&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:3},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n    let mut v: Array&lt;ByteArray&gt; = array![\&quot;Hello \&quot;];\n    let mut s = *v[0];\n    s.append(@\&quot;world\&quot;);\n    println!(\&quot;{s}\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;`*v[0]` copies the value of the first element of the array to `i`. Therefore, `i` is a copy of the\nvalue of `v[0]`, and incrementing `i` does not affect `v[0]`.\n&quot;,&quot;id&quot;:&quot;95d528ee-ae78-4892-a438-a5d97f07f52a&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;2, 1&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n    let mut v: Array&lt;usize&gt; = array![1, 2, 3];\n    let mut i = *v[0];\n    i += 1;\n    println!(\&quot;{}, {}\&quot;, i, v[0]);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="dictionaries"><a class="header" href="#dictionaries">Dictionaries</a></h1>
<p>Cairo provides in its core library a dictionary-like type. The <code>Felt252Dict&lt;T&gt;</code>
data type represents a collection of key-value pairs where each key is unique
and associated with a corresponding value. This type of data structure is known
differently across different programming languages such as maps, hash tables,
associative arrays and many others.</p>
<p>The <code>Felt252Dict&lt;T&gt;</code> type is useful when you want to organize your data in a
certain way for which using an <code>Array&lt;T&gt;</code> and indexing doesn't suffice. Cairo
dictionaries also allow the programmer to easily simulate the existence of
mutable memory when there is none.</p>
<h2 id="basic-use-of-dictionaries"><a class="header" href="#basic-use-of-dictionaries">Basic Use of Dictionaries</a></h2>
<p>It is normal in other languages when creating a new dictionary to define the
data types of both key and value. In Cairo, the key type is restricted to
<code>felt252</code>, leaving only the possibility to specify the value data type,
represented by <code>T</code> in <code>Felt252Dict&lt;T&gt;</code>.</p>
<p>The core functionality of a <code>Felt252Dict&lt;T&gt;</code> is implemented in the trait
<code>Felt252DictTrait</code> which includes all basic operations. Among them we can find:</p>
<ol>
<li><code>insert(felt252, T) -&gt; ()</code> to write values to a dictionary instance and</li>
<li><code>get(felt252) -&gt; T</code> to read values from it.</li>
</ol>
<p>These functions allow us to manipulate dictionaries like in any other language.
In the following example, we create a dictionary to represent a mapping between
individuals and their balance:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}
</code></pre>
<p>We can create a new instance of <code>Felt252Dict&lt;u64&gt;</code> by using the <code>default</code> method
of the <code>Default</code> trait and add two individuals, each one with their own balance,
using the <code>insert</code> method. Finally, we check the balance of our users with the
<code>get</code> method. These methods are defined in the <code>Felt252DictTrait</code> trait in the
core library.</p>
<p>Throughout the book we have talked about how Cairo's memory is immutable,
meaning you can only write to a memory cell once but the <code>Felt252Dict&lt;T&gt;</code> type
represents a way to overcome this obstacle. We will explain how this is
implemented later on in <a href="./ch03-02-dictionaries.html#dictionaries-underneath">"Dictionaries Underneath"</a>.</p>
<p>Building upon our previous example, let us show a code example where the balance
of the same user changes:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}
</code></pre>
<p>Notice how in this example we added the 'Alex' individual twice, each time using
a different balance and each time that we checked for its balance it had the
last value inserted! <code>Felt252Dict&lt;T&gt;</code> effectively allows us to "rewrite" the
stored value for any given key.</p>
<p>Before heading on and explaining how dictionaries are implemented it is worth
mentioning that once you instantiate a <code>Felt252Dict&lt;T&gt;</code>, behind the scenes all
keys have their associated values initialized as zero. This means that if for
example, you tried to get the balance of an inexistent user you will get 0
instead of an error or an undefined value. This also means there is no way to
delete data from a dictionary. Something to take into account when incorporating
this structure into your code.</p>
<p>Until this point, we have seen all the basic features of <code>Felt252Dict&lt;T&gt;</code> and
how it mimics the same behavior as the corresponding data structures in any
other language, that is, externally of course. Cairo is at its core a
non-deterministic Turing-complete programming language, very different from any
other popular language in existence, which as a consequence means that
dictionaries are implemented very differently as well!</p>
<p>In the following sections, we are going to give some insights about
<code>Felt252Dict&lt;T&gt;</code> inner mechanisms and the compromises that were taken to make
them work. After that, we are going to take a look at how to use dictionaries
with other data structures as well as use the <code>entry</code> method as another way to
interact with them.</p>
<h2 id="dictionaries-underneath"><a class="header" href="#dictionaries-underneath">Dictionaries Underneath</a></h2>
<p>One of the constraints of Cairo's non-deterministic design is that its memory
system is immutable, so in order to simulate mutability, the language implements
<code>Felt252Dict&lt;T&gt;</code> as a list of entries. Each of the entries represents a time
when a dictionary was accessed for reading/updating/writing purposes. An entry
has three fields:</p>
<ol>
<li>A <code>key</code> field that identifies the key for this key-value pair of the
dictionary.</li>
<li>A <code>previous_value</code> field that indicates which previous value was held at
<code>key</code>.</li>
<li>A <code>new_value</code> field that indicates the new value that is held at <code>key</code>.</li>
</ol>
<p>If we try implementing <code>Felt252Dict&lt;T&gt;</code> using high-level structures we would
internally define it as <code>Array&lt;Entry&lt;T&gt;&gt;</code> where each <code>Entry&lt;T&gt;</code> has information
about what key-value pair it represents and the previous and new values it
holds. The definition of <code>Entry&lt;T&gt;</code> would be:</p>
<pre><code class="language-cairo noplayground">struct Entry&lt;T&gt; {
    key: felt252,
    previous_value: T,
    new_value: T,
}
</code></pre>
<p>For each time we interact with a <code>Felt252Dict&lt;T&gt;</code>, a new <code>Entry&lt;T&gt;</code> will be
registered:</p>
<ul>
<li>A <code>get</code> would register an entry where there is no change in state, and
previous and new values are stored with the same value.</li>
<li>An <code>insert</code> would register a new <code>Entry&lt;T&gt;</code> where the <code>new_value</code> would be the
element being inserted, and the <code>previous_value</code> the last element inserted
before this. In case it is the first entry for a certain key, then the
previous value will be zero.</li>
</ul>
<p>The use of this entry list shows how there isn't any rewriting, just the
creation of new memory cells per <code>Felt252Dict&lt;T&gt;</code> interaction. Let's show an
example of this using the <code>balances</code> dictionary from the previous section and
inserting the users 'Alex' and 'Maria':</p>
<pre><code class="language-cairo"><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">
</span><span class="boring">struct Entry&lt;T&gt; {
</span><span class="boring">    key: felt252,
</span><span class="boring">    previous_value: T,
</span><span class="boring">    new_value: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();
</span>    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
<span class="boring">}
</span></code></pre>
<p>These instructions would then produce the following list of entries:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>50</td></tr>
<tr><td style="text-align: center">Alex</td><td>100</td><td>200</td></tr>
<tr><td style="text-align: center">Maria</td><td>50</td><td>50</td></tr>
</tbody></table>
</div>
<p>Notice that since 'Alex' was inserted twice, it appears twice and the <code>previous</code>
and <code>current</code> values are set properly. Also reading from 'Maria' registered an
entry with no change from previous to current values.</p>
<p>This approach to implementing <code>Felt252Dict&lt;T&gt;</code> means that for each read/write
operation, there is a scan for the whole entry list in search of the last entry
with the same <code>key</code>. Once the entry has been found, its <code>new_value</code> is extracted
and used on the new entry to be added as the <code>previous_value</code>. This means that
interacting with <code>Felt252Dict&lt;T&gt;</code> has a worst-case time complexity of <code>O(n)</code>
where <code>n</code> is the number of entries in the list.</p>
<p>If you pour some thought into alternate ways of implementing <code>Felt252Dict&lt;T&gt;</code>
you'd surely find them, probably even ditching completely the need for a
<code>previous_value</code> field, nonetheless, since Cairo is not your normal language
this won't work. One of the purposes of Cairo is, with the STARK proof system,
to generate proofs of computational integrity. This means that you need to
verify that program execution is correct and inside the boundaries of Cairo
restrictions. One of those boundary checks consists of "dictionary squashing"
and that requires information on both previous and new values for every entry.</p>
<h2 id="squashing-dictionaries"><a class="header" href="#squashing-dictionaries">Squashing Dictionaries</a></h2>
<p>To verify that the proof generated by a Cairo program execution that used a
<code>Felt252Dict&lt;T&gt;</code> is correct, we need to check that there wasn't any illegal
tampering with the dictionary. This is done through a method called
<code>squash_dict</code> that reviews each entry of the entry list and checks that access
to the dictionary remains coherent throughout the execution.</p>
<p>The process of squashing is as follows: given all entries with certain key <code>k</code>,
taken in the same order as they were inserted, verify that the ith entry
<code>new_value</code> is equal to the ith + 1 entry <code>previous_value</code>.</p>
<p>For example, given the following entry list:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>150</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
<tr><td style="text-align: center">Maria</td><td>100</td><td>250</td></tr>
<tr><td style="text-align: center">Alex</td><td>150</td><td>40</td></tr>
<tr><td style="text-align: center">Alex</td><td>40</td><td>300</td></tr>
<tr><td style="text-align: center">Maria</td><td>250</td><td>190</td></tr>
<tr><td style="text-align: center">Alex</td><td>300</td><td>90</td></tr>
</tbody></table>
</div>
<p>After squashing, the entry list would be reduced to:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr></thead><tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>90</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>190</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
</tbody></table>
</div>
<p>In case of a change on any of the values of the first table, squashing would
have failed during runtime.</p>
<h2 id="dictionary-destruction"><a class="header" href="#dictionary-destruction">Dictionary Destruction</a></h2>
<p>If you run the examples from <a href="./ch03-02-dictionaries.html#basic-use-of-dictionaries">"Basic Use of Dictionaries"</a>
section, you'd notice that there was never a call to squash dictionary, but the
program compiled successfully nonetheless. What happened behind the scene was
that squash was called automatically via the <code>Felt252Dict&lt;T&gt;</code> implementation of
the <code>Destruct&lt;T&gt;</code> trait. This call occurred just before the <code>balance</code> dictionary
went out of scope.</p>
<p>The <code>Destruct&lt;T&gt;</code> trait represents another way of removing instances out of
scope apart from <code>Drop&lt;T&gt;</code>. The main difference between these two is that
<code>Drop&lt;T&gt;</code> is treated as a no-op operation, meaning it does not generate new CASM
while <code>Destruct&lt;T&gt;</code> does not have this restriction. The only type which actively
uses the <code>Destruct&lt;T&gt;</code> trait is <code>Felt252Dict&lt;T&gt;</code>, for every other type
<code>Destruct&lt;T&gt;</code> and <code>Drop&lt;T&gt;</code> are synonyms. You can read more about these traits
in <a href="./appendix-03-derivable-traits.html#drop-and-destruct">Drop and Destruct</a> section of Appendix C.</p>
<p>Later in <a href="./ch12-01-custom-data-structures.html#dictionaries-as-struct-members">"Dictionaries as Struct Members"</a> section, we
will have a hands-on example where we implement the <code>Destruct&lt;T&gt;</code> trait for a
custom type.</p>
<h2 id="more-dictionaries"><a class="header" href="#more-dictionaries">More Dictionaries</a></h2>
<p>Up to this point, we have given a comprehensive overview of the functionality of
<code>Felt252Dict&lt;T&gt;</code> as well as how and why it is implemented in a certain way. If
you haven't understood all of it, don't worry because in this section we will
have some more examples using dictionaries.</p>
<p>We will start by explaining the <code>entry</code> method which is part of a dictionary
basic functionality included in <code>Felt252DictTrait&lt;T&gt;</code> which we didn't mention at
the beginning. Soon after, we will see examples of how to use <code>Felt252Dict&lt;T&gt;</code>
with other <a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">complex types</a> such as <code>Array&lt;T&gt;</code>.</p>
<h2 id="entry-and-finalize"><a class="header" href="#entry-and-finalize">Entry and Finalize</a></h2>
<p>In the <a href="./ch03-02-dictionaries.html#dictionaries-underneath">"Dictionaries Underneath"</a> section, we explained how
<code>Felt252Dict&lt;T&gt;</code> internally worked. It was a list of entries for each time the
dictionary was accessed in any manner. It would first find the last entry given
a certain <code>key</code> and then update it accordingly to whatever operation it was
executing. The Cairo language gives us the tools to replicate this ourselves
through the <code>entry</code> and <code>finalize</code> methods.</p>
<p>The <code>entry</code> method comes as part of <code>Felt252DictTrait&lt;T&gt;</code> with the purpose of
creating a new entry given a certain key. Once called, this method takes
ownership of the dictionary and returns the entry to update. The method
signature is as follows:</p>
<pre><code class="language-cairo noplayground">fn entry(self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; (Felt252DictEntry&lt;T&gt;, T) nopanic
</code></pre>
<p>The first input parameter takes ownership of the dictionary while the second one
is used to create the appropriate entry. It returns a tuple containing a
<code>Felt252DictEntry&lt;T&gt;</code>, which is the type used by Cairo to represent dictionary
entries, and a <code>T</code> representing the value held previously. The <code>nopanic</code>
notation simply indicates that the function is guaranteed to never panic.</p>
<p>The next thing to do is to update the entry with the new value. For this, we use
the <code>finalize</code> method which inserts the entry and returns ownership of the
dictionary:</p>
<pre><code class="language-cairo noplayground">fn finalize(self: Felt252DictEntry&lt;T&gt;, new_value: T) -&gt; Felt252Dict&lt;T&gt;
</code></pre>
<p>This method receives the entry and the new value as parameters, and returns the
updated dictionary.</p>
<p>Let us see an example using <code>entry</code> and <code>finalize</code>. Imagine we would like to
implement our own version of the <code>get</code> method from a dictionary. We should then
do the following:</p>
<ol>
<li>Create the new entry to add using the <code>entry</code> method.</li>
<li>Insert back the entry where the <code>new_value</code> equals the <code>previous_value</code>.</li>
<li>Return the value.</li>
</ol>
<p>Implementing our custom get would look like this:</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get&lt;T, +Felt252DictValue&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252,
) -&gt; T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}
</code></pre>
<p>The <code>ref</code> keyword means that the ownership of the variable will be given back at
the end of the function. This concept will be explained in more detail in the
<a href="./ch04-02-references-and-snapshots.html">"References and Snapshots"</a> section.</p>
<p>Implementing the <code>insert</code> method would follow a similar workflow, except for
inserting a new value when finalizing. If we were to implement it, it would look
like the following:</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert&lt;T, +Felt252DictValue&lt;T&gt;, +Destruct&lt;T&gt;, +Drop&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}
</code></pre>
<p>As a finalizing note, these two methods are implemented in a similar way to how
<code>insert</code> and <code>get</code> are implemented for <code>Felt252Dict&lt;T&gt;</code>. This code shows some
example usage:</p>
<pre><code class="language-cairo"><span class="boring">use core::dict::{Felt252Dict, Felt252DictEntryTrait};
</span><span class="boring">
</span><span class="boring">fn custom_get&lt;T, +Felt252DictValue&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(
</span><span class="boring">    ref dict: Felt252Dict&lt;T&gt;, key: felt252,
</span><span class="boring">) -&gt; T {
</span><span class="boring">    // Get the new entry and the previous value held at `key`
</span><span class="boring">    let (entry, prev_value) = dict.entry(key);
</span><span class="boring">
</span><span class="boring">    // Store the value to return
</span><span class="boring">    let return_value = prev_value;
</span><span class="boring">
</span><span class="boring">    // Update the entry with `prev_value` and get back ownership of the dictionary
</span><span class="boring">    dict = entry.finalize(prev_value);
</span><span class="boring">
</span><span class="boring">    // Return the read value
</span><span class="boring">    return_value
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn custom_insert&lt;T, +Felt252DictValue&lt;T&gt;, +Destruct&lt;T&gt;, +Drop&lt;T&gt;&gt;(
</span><span class="boring">    ref dict: Felt252Dict&lt;T&gt;, key: felt252, value: T,
</span><span class="boring">) {
</span><span class="boring">    // Get the last entry associated with `key`
</span><span class="boring">    // Notice that if `key` does not exist, `_prev_value` will
</span><span class="boring">    // be the default value of T.
</span><span class="boring">    let (entry, _prev_value) = dict.entry(key);
</span><span class="boring">
</span><span class="boring">    // Insert `entry` back in the dictionary with the updated value,
</span><span class="boring">    // and receive ownership of the dictionary
</span><span class="boring">    dict = entry.finalize(value);
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let mut dict: Felt252Dict&lt;u64&gt; = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="dictionaries-of-types-not-supported-natively"><a class="header" href="#dictionaries-of-types-not-supported-natively">Dictionaries of Types not Supported Natively</a></h2>
<p>One restriction of <code>Felt252Dict&lt;T&gt;</code> that we haven't talked about is the trait
<code>Felt252DictValue&lt;T&gt;</code>. This trait defines the <code>zero_default</code> method which is the
one that gets called when a value does not exist in the dictionary. This is
implemented by some common data types, such as most unsigned integers, <code>bool</code>
and <code>felt252</code> - but it is not implemented for more complex types such as arrays,
structs (including <code>u256</code>), and other types from the core library. This means
that making a dictionary of types not natively supported is not a
straightforward task, because you would need to write a couple of trait
implementations in order to make the data type a valid dictionary value type. To
compensate this, you can wrap your type inside a <code>Nullable&lt;T&gt;</code>.</p>
<p><code>Nullable&lt;T&gt;</code> is a smart pointer type that can either point to a value or be
<code>null</code> in the absence of value. It is usually used in Object Oriented
Programming Languages when a reference doesn't point anywhere. The difference
with <code>Option</code> is that the wrapped value is stored inside a <code>Box&lt;T&gt;</code> data type.
The <code>Box&lt;T&gt;</code> type is a smart pointer that allows us to use a dedicated
<code>boxed_segment</code> memory segment for our data, and access this segment using a
pointer that can only be manipulated in one place at a time. See
<a href="./ch12-02-smart-pointers.html">Smart Pointers Chapter</a> for more information.</p>
<p>Let's show using an example. We will try to store a <code>Span&lt;felt252&gt;</code> inside a
dictionary. For that, we will use <code>Nullable&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>. Also, we are
storing a <code>Span&lt;T&gt;</code> and not an <code>Array&lt;T&gt;</code> because the latter does not implement
the <code>Copy&lt;T&gt;</code> trait which is required for reading from a dictionary.</p>
<pre><code class="language-cairo noplayground">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};

#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...
</code></pre>
<p>In this code snippet, the first thing we did was to create a new dictionary <code>d</code>.
We want it to hold a <code>Nullable&lt;Span&gt;</code>. After that, we created an array and
filled it with values.</p>
<p>The last step is inserting the array as a span inside the dictionary. Notice
that we do this using the <code>new</code> function of the <code>NullableTrait</code>.</p>
<p>Once the element is inside the dictionary, and we want to get it, we follow the
same steps but in reverse order. The following code shows how to achieve that:</p>
<pre><code class="language-cairo noplayground">//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}
</code></pre>
<p>Here we:</p>
<ol>
<li>Read the value using <code>get</code>.</li>
<li>Verified it is non-null using the <code>match_nullable</code> function.</li>
<li>Unwrapped the value inside the box and asserted it was correct.</li>
</ol>
<p>The complete script would look like this:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};

#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

</code></pre>
<h2 id="using-arrays-inside-dictionaries"><a class="header" href="#using-arrays-inside-dictionaries">Using Arrays inside Dictionaries</a></h2>
<p>In the previous section, we explored how to store and retrieve complex types
inside a dictionary using <code>Nullable&lt;T&gt;</code> and <code>Box&lt;T&gt;</code>. Now, let's take a look at
how to store an array inside a dictionary and dynamically modify its contents.</p>
<p>Storing arrays in dictionaries in Cairo is slightly different from storing other
types. This is because arrays are more complex data structures that require
special handling to avoid issues with memory copying and references.</p>
<p>First, let's look at how to create a dictionary and insert an array into it.
This process is pretty straightforward and follows a similar pattern to
inserting other types of data:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}
</code></pre>
<p>However, attempting to read an array from the dictionary using the <code>get</code> method
will result in a compiler error. This is because <code>get</code> tries to copy the array
in memory, which is not possible for arrays (as we've already mentioned in the
<a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">previous section</a>, <code>Array&lt;T&gt;</code> does not implement
the <code>Copy&lt;T&gt;</code> trait):</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, match_nullable};

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value!"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };
    arr.span()
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::&lt;core::nullable::Nullable::&lt;core::array::Array::&lt;core::integer::u8&gt;&gt;&gt;.
 --&gt; listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:14:20
    let val = dict.get(0); // This will cause a compiler error
                   ^^^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<p>To correctly read an array from the dictionary, we need to use dictionary
entries. This allows us to get a reference to the array value without copying
it:</p>
<pre><code class="language-cairo noplayground">fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}
</code></pre>
<blockquote>
<p>Note: We must convert the array to a <code>Span</code> before finalizing the entry,
because calling <code>NullableTrait::new(arr)</code> moves the array, thus making it
impossible to return it from the function.</p>
</blockquote>
<p>To modify the stored array, such as appending a new value, we can use a similar
approach. The following <code>append_value</code> function demonstrates this:</p>
<pre><code class="language-cairo noplayground">fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}
</code></pre>
<p>In the <code>append_value</code> function, we access the dictionary entry, dereference the
array, append the new value, and finalize the entry with the updated array.</p>
<blockquote>
<p>Note: Removing an item from a stored array can be implemented in a similar
manner.</p>
</blockquote>
<p>Below is the complete example demonstrating the creation, insertion, reading,
and modification of an array in a dictionary:</p>
<pre><code class="language-cairo">use core::dict::{Felt252Dict, Felt252DictEntryTrait};
use core::nullable::NullableTrait;

fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch03-02-dictionaries&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The code compiles and runs without panicking because `get` returns the default value for `u64` when the key is not found.\nThe value of `john_balance` is `0 + 100 = 100`.\n&quot;,&quot;id&quot;:&quot;8b538a1f-0cf9-4c57-8304-c4b07e0134dd&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;100&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;use core::dict::Felt252Dict;\n\n#[executable]\nfn main() {\n    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();\n    balances.insert('Alex', 100);\n    balances.insert('Maria', 200);\n    let john_balance = balances.get('John') + 100;\n    println!(\&quot;{}\&quot;, john_balance);\n}\n&quot;}},{&quot;context&quot;:&quot;We could store a Span&lt;T&gt; in the dictionary because it implements the Copy&lt;T&gt; trait.\nHowever, the `zero_default` method is not implemented for Span&lt;T&gt; which thus must be wrapped inside a Nullable&lt;T&gt; type.\nFor this reason the code will not compile.\n&quot;,&quot;id&quot;:&quot;af5bc548-fb84-487f-958e-0622d242dc6f&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;use core::dict::Felt252Dict;\n\n#[executable]\nfn main() {\n    let mut dict: Felt252Dict&lt;Span&lt;felt252&gt;&gt; = Default::default();\n    let a = array![8, 9, 10];\n    dict.insert('my_span', a.span());\n    let my_span = d.get('my_span');\n    println!(\&quot;{:?}\&quot;, *my_span.at(0));\n}\n&quot;}},{&quot;context&quot;:&quot;The value type of this dictionary is `u64`, which is an unsigned integer. So the variable `alex_balance` is an unsigned integer that can't be negative.\nThe subtraction operation will cause a runtime panic.\n&quot;,&quot;id&quot;:&quot;8fe876cf-4373-42ca-ae2c-4d13ae23dbed&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;There will be a runtime panic.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Alex : -50&quot;,&quot;Alex : 0&quot;,&quot;Alex : 100&quot;],&quot;prompt&quot;:&quot;What will be the output of this code snippet?\n```\nuse core::dict::Felt252Dict;\n\n#[executable]\nfn main() {\n    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();\n    balances.insert('Alex', 200);\n    balances.insert('Maria', 200);\n    balances.insert('Alex', 100);\n    let alex_balance = balances.get('Alex') - 150;\n    balances.insert('Alex', alex_balance);\n    println!(\&quot;Alex : {}\&quot;, alex_balance);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The `entry` method returns a tuple with the entry and the value.  We can mutate this value, and then\nfinalize the entry with this new value, which restores ownership of the dictionary in the calling\ncontext.\n&quot;,&quot;id&quot;:&quot;f78d9b38-1d3a-4b00-a014-9c618070738c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`let (entry, my_array) = dict.entry(key);`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`let my_array = dict.entry(key);`&quot;,&quot;`let mut my_array = dict.entry(key);`&quot;,&quot;None of these options are correct: Arrays can't be mutated inside Dicts.&quot;],&quot;prompt&quot;:&quot;We want to write a function to append a value to an array stored in a dictionary.\nChoose the right line of code to make the function below work as expected.\n\n```\nfn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, key: felt252, value_to_append: u8) {\n    // insert the right line here\n    let mut my_array_unboxed = my_array.deref_or(array![]);\n    my_array_unboxed.append(value_to_append);\n    dict = entry.finalize(NullableTrait::new(my_array_unboxed));\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Squashing only keeps the last entry for each key. In this case, the table will only contain the entries for 'John', 'Alex', 'Maria', and 'Alicia'.\n&quot;,&quot;id&quot;:&quot;d643e8df-2b76-4d2a-bb1f-1a00e53ec8df&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;4&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;6&quot;,&quot;3&quot;,&quot;0&quot;],&quot;prompt&quot;:&quot;Let's consider the following instructions and the associated entry table:\n```\nbalances.insert('Alex', 100);\nbalances.insert('Maria', 200);\nbalances.insert('John', 300);\nbalances.insert('Alex', 50);\nbalances.insert('Maria', 150);\nbalances.insert('Alicia', 250);\n```\nAfter squashing, how many entries will the table contain?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-cairos-ownership-system"><a class="header" href="#understanding-cairos-ownership-system">Understanding Cairo's Ownership system</a></h1>
<p>Cairo is a language built around a linear type system that allows us to
statically ensure that in every Cairo program, a value is used exactly once.
This linear type system helps prevent runtime errors by ensuring that operations
that could cause such errors, such as writing twice to a memory cell, are
detected at compile time. This is achieved by implementing an ownership system
and forbidding copying and dropping values by default. In this chapter, we’ll
talk about Cairo's ownership system as well as references and snapshots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-using-a-linear-type-system"><a class="header" href="#ownership-using-a-linear-type-system">Ownership Using a Linear Type System</a></h1>
<p>Cairo uses a linear type system. In such a type system, any value (a basic type,
a struct, an enum) must be used and must only be used once. 'Used' here means
that the value is either <em>destroyed</em> or <em>moved</em>.</p>
<p><em>Destruction</em> can happen in several ways:</p>
<ul>
<li>a variable goes out of scope.</li>
<li>a struct is destructured.</li>
<li>explicit destruction using <code>destruct()</code>.</li>
</ul>
<p><em>Moving</em> a value simply means passing that value to another function.</p>
<p>This results in somewhat similar constraints to the Rust ownership model, but
there are some differences. In particular, the Rust ownership model exists (in
part) to avoid data races and concurrent mutable access to a memory value. This
is obviously impossible in Cairo since the memory is immutable. Instead, Cairo
leverages its linear type system for two main purposes:</p>
<ul>
<li>Ensuring that all code is provable and thus verifiable.</li>
<li>Abstracting away the immutable memory of the Cairo VM.</li>
</ul>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>In Cairo, ownership applies to <em>variables</em> and not to <em>values</em>. A value can
safely be referred to by many different variables (even if they are mutable
variables), as the value itself is always immutable. Variables however can be
mutable, so the compiler must ensure that constant variables aren't accidentally
modified by the programmer. This makes it possible to talk about ownership of a
variable: the owner is the code that can read (and write if mutable) the
variable.</p>
<p>This means that variables (not values) follow similar rules to Rust values:</p>
<ul>
<li>Each variable in Cairo has an owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the variable is destroyed.</li>
</ul>
<p>Now that we’re past basic Cairo syntax, we won’t include all the <code>fn main() {</code>
code in examples, so if you’re following along, make sure to put the following
examples inside a main function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than boilerplate
code.</p>
<h2 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h2>
<p>As a first example of the linear type system, we’ll look at the <em>scope</em> of some
variables. A scope is the range within a program for which an item is valid.
Take the following variable:</p>
<pre><code class="language-cairo noplayground">let s = 'hello';
</code></pre>
<p>The variable <code>s</code> refers to a short string. The variable is valid from the point
at which it’s declared until the end of the current <em>scope</em>. Listing
4-1 shows a program with comments annotating where the
variable <code>s</code> would be valid.</p>
<pre><code class="language-cairo"><span class="boring">//TAG: ignore_fmt
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    { // s is not valid here, it’s not yet declared
        let s = 'hello'; // s is valid from this point forward
        // do stuff with s
    } // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre>
<p>A variable and the scope in which it is valid</span></p>
<p>In other words, there are two important points in time here:</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by using the <code>Array</code> type we introduced in the previous
<a href="./ch03-01-arrays.html">"Arrays"</a> section.</p>
<h3 id="moving-values"><a class="header" href="#moving-values">Moving values</a></h3>
<p>As said earlier, <em>moving</em> a value simply means passing that value to another
function. When that happens, the variable referring to that value in the
original scope is destroyed and can no longer be used, and a new variable is
created to hold the same value.</p>
<p>Arrays are an example of a complex type that is moved when passing it to another
function. Here is a short reminder of what an array looks like:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span>fn main() {
    let mut arr: Array&lt;u128&gt; = array![];
    arr.append(1);
<span class="boring">    arr.append(2);
</span><span class="boring">}
</span></code></pre>
<p>How does the type system ensure that the Cairo program never tries to write to
the same memory cell twice? Consider the following code, where we try to remove
the front of the array twice:</p>
<pre><code class="language-cairo does_not_compile">fn foo(mut arr: Array&lt;u128&gt;) {
    arr.pop_front();
}

#[executable]
fn main() {
    let arr: Array&lt;u128&gt; = array![];
    foo(arr);
    foo(arr);
}
</code></pre>
<p>In this case, we try to pass the same value (the array in the <code>arr</code> variable) to
both function calls. This means our code tries to remove the first element
twice, which would try to write to the same memory cell twice - which is
forbidden by the Cairo VM, leading to a runtime error. Thankfully, this code
does not actually compile. Once we have passed the array to the <code>foo</code> function,
the variable <code>arr</code> is no longer usable. We get this compile-time error, telling
us that we would need Array to implement the Copy Trait:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_02_pass_array_by_value v0.1.0 (listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/Scarb.toml)
warn: Unhandled `#[must_use]` type `core::option::Option::&lt;core::integer::u128&gt;`
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:3:5
    arr.pop_front();
    ^^^^^^^^^^^^^^^

error: Variable was previously moved.
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:10:9
    foo(arr);
        ^^^
note: variable was previously used here:
  --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:9:9
    foo(arr);
        ^^^
note: Trait has no implementation in context: core::traits::Copy::&lt;core::array::Array::&lt;core::integer::u128&gt;&gt;.

error: could not compile `no_listing_02_pass_array_by_value` due to 1 previous error and 1 warning
error: `scarb` command exited with error

</code></pre>
<h2 id="the-copy-trait"><a class="header" href="#the-copy-trait">The <code>Copy</code> Trait</a></h2>
<p>The <code>Copy</code> trait allows simple types to be duplicated by copying felts, without
allocating new memory segments. This contrasts with Cairo's default "move"
semantics, which transfer ownership of values to ensure memory safety and
prevent issues like multiple writes to the same memory cell. <code>Copy</code> is
implemented for types where duplication is safe and efficient, bypassing the
need for move semantics. Types like <code>Array</code> and <code>Felt252Dict</code> cannot implement
<code>Copy</code>, as manipulating them in different scopes is forbidden by the type
system.</p>
<p>All basic types previously described in <a href="./ch02-02-data-types.html">"Data Types"</a> implement by
default the <code>Copy</code> trait.</p>
<p>While Arrays and Dictionaries can't be copied, custom types that don't contain
either of them can be. You can implement the <code>Copy</code> trait on your type by adding
the <code>#[derive(Copy)]</code> annotation to your type definition. However, Cairo won't
allow a type to be annotated with Copy if the type itself or any of its
components doesn't implement the Copy trait.</p>
<pre><code class="language-cairo ignore_format">#[derive(Copy, Drop)]
struct Point {
    x: u128,
    y: u128,
}

#[executable]
fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1);
}

fn foo(p: Point) { // do something with p
}
</code></pre>
<p>In this example, we can pass <code>p1</code> twice to the foo function because the <code>Point</code>
type implements the <code>Copy</code> trait. This means that when we pass <code>p1</code> to <code>foo</code>, we
are actually passing a copy of <code>p1</code>, so <code>p1</code> remains valid. In ownership terms,
this means that the ownership of <code>p1</code> remains with the <code>main</code> function. If you
remove the <code>Copy</code> trait derivation from the <code>Point</code> type, you will get a
compile-time error when trying to compile the code.</p>
<p><em>Don't worry about the <code>Struct</code> keyword. We will introduce this in <a href="./ch05-00-using-structs-to-structure-related-data.html">Chapter
5</a>.</em></p>
<h2 id="destroying-values---example-with-feltdict"><a class="header" href="#destroying-values---example-with-feltdict">Destroying Values - Example with FeltDict</a></h2>
<p>The other way linear types can be <em>used</em> is by being destroyed. Destruction must
ensure that the 'resource' is now correctly released. In Rust, for example, this
could be closing the access to a file, or locking a mutex. In Cairo, one type
that has such behaviour is <code>Felt252Dict</code>. For provability, dicts must be
'squashed' when they are destructed. This would be very easy to forget, so it is
enforced by the type system and the compiler.</p>
<h3 id="no-op-destruction-the-drop-trait"><a class="header" href="#no-op-destruction-the-drop-trait">No-op Destruction: the <code>Drop</code> Trait</a></h3>
<p>You may have noticed that the <code>Point</code> type in the previous example also
implements the <code>Drop</code> trait. For example, the following code will not compile,
because the struct <code>A</code> is not moved or destroyed before it goes out of scope:</p>
<pre><code class="language-cairo does_not_compile">struct A {}

#[executable]
fn main() {
    A {}; // error: Variable not dropped.
}
</code></pre>
<p>However, types that implement the <code>Drop</code> trait are automatically destroyed when
going out of scope. This destruction does nothing, it is a no-op - simply a hint
to the compiler that this type can safely be destroyed once it's no longer
useful. We call this "dropping" a value.</p>
<p>At the moment, the <code>Drop</code> implementation can be derived for all types, allowing
them to be dropped when going out of scope, except for dictionaries
(<code>Felt252Dict</code>) and types containing dictionaries. For example, the following
code compiles:</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    A {}; // Now there is no error.
}
</code></pre>
<h3 id="destruction-with-a-side-effect-the-destruct-trait"><a class="header" href="#destruction-with-a-side-effect-the-destruct-trait">Destruction with a Side-effect: the <code>Destruct</code> Trait</a></h3>
<p>When a value is destroyed, the compiler first tries to call the <code>drop</code> method on
that type. If it doesn't exist, then the compiler tries to call <code>destruct</code>
instead. This method is provided by the <code>Destruct</code> trait.</p>
<p>As said earlier, dictionaries in Cairo are types that must be "squashed" when
destructed, so that the sequence of access can be proven. This is easy for
developers to forget, so instead dictionaries implement the <code>Destruct</code> trait to
ensure that all dictionaries are <em>squashed</em> when going out of scope. As such,
the following example will not compile:</p>
<pre><code class="language-cairo does_not_compile">use core::dict::Felt252Dict;

struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() };
}
</code></pre>
<p>If you try to run this code, you will get a compile-time error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_06_no_destruct_compile_fails v0.1.0 (listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/Scarb.toml)
error: Variable not dropped.
 --&gt; listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo:10:5
    A { dict: Default::default() };
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: Trait has no implementation in context: core::traits::Drop::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.
note: Trait has no implementation in context: core::traits::Destruct::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.

error: could not compile `no_listing_06_no_destruct_compile_fails` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<p>When <code>A</code> goes out of scope, it can't be dropped as it implements neither the
<code>Drop</code> (as it contains a dictionary and can't <code>derive(Drop)</code>) nor the <code>Destruct</code>
trait. To fix this, we can derive the <code>Destruct</code> trait implementation for the
<code>A</code> type:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[derive(Destruct)]
struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() }; // No error here
}
</code></pre>
<p>Now, when <code>A</code> goes out of scope, its dictionary will be automatically
<code>squashed</code>, and the program will compile.</p>
<h2 id="copy-array-data-with-clone"><a class="header" href="#copy-array-data-with-clone">Copy Array Data with <code>clone</code></a></h2>
<p>If we <em>do</em> want to deeply copy the data of an <code>Array</code>, we can use a common
method called <code>clone</code>. We’ll discuss method syntax in a dedicated section in
<a href="./ch05-03-method-syntax.html">Chapter 5</a>, but
because methods are a common feature in many programming languages, you’ve
probably seen them before.</p>
<p>Here’s an example of the <code>clone</code> method in action.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];
    let arr2 = arr1.clone();
}
</code></pre>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on. In this case, the <em>value</em> <code>arr1</code> refers to is being
copied, resulting in new memory cells being used, and a new <em>variable</em> <code>arr2</code> is
created, referring to the new copied value.</p>
<h2 id="return-values-and-scope"><a class="header" href="#return-values-and-scope">Return Values and Scope</a></h2>
<p>Returning values is equivalent to <em>moving</em> them. Listing
4-2 shows an example of a function that returns some
value, with similar annotations as those in Listing 4-1.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    let a1 = gives_ownership();           // gives_ownership moves its return
                                          // value into a1

    let a2 = A {};                        // a2 comes into scope

    let a3 = takes_and_gives_back(a2);    // a2 is moved into
                                          // takes_and_gives_back, which also
                                          // moves its return value into a3

} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
  // happens. a1 goes out of scope and is dropped.

fn gives_ownership() -&gt; A {               // gives_ownership will move its
                                          // return value into the function
                                          // that calls it

    let some_a = A {};                    // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}

// This function takes an instance some_a of A and returns it
fn takes_and_gives_back(some_a: A) -&gt; A { // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}
</code></pre>
<p>4-2: Moving return values</span></p>
<p>While this works, moving into and out of every function is a bit tedious. What
if we want to let a function use a value but not move the value? It’s quite
annoying that anything we pass in also needs to be passed back if we want to use
it again, in addition to any data resulting from the body of the function that
we might want to return as well.</p>
<p>Cairo does let us return multiple values using a tuple, as shown in Listing
4-3.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];

    let (arr2, len) = calculate_length(arr1);
}

fn calculate_length(arr: Array&lt;u128&gt;) -&gt; (Array&lt;u128&gt;, usize) {
    let length = arr.len(); // len() returns the length of an array

    (arr, length)
}
</code></pre>
<p>4-3: Returning many values</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Cairo has two features for passing a value without
destroying or moving it, called <em>references</em> and <em>snapshots</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-and-snapshots"><a class="header" href="#references-and-snapshots">References and Snapshots</a></h1>
<p>The issue with the tuple code in previous Listing
4-3 is that we have to return the <code>Array</code> to the
calling function so we can still use the <code>Array</code> after the call to
<code>calculate_length</code>, because the <code>Array</code> was moved into <code>calculate_length</code>.</p>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>In the previous chapter, we talked about how Cairo's ownership system prevents
us from using a variable after we've moved it, protecting us from potentially
writing twice to the same memory cell. However, it's not very convenient. Let's
see how we can retain ownership of the variable in the calling function using
snapshots.</p>
<p>In Cairo, a snapshot is an immutable view of a value at a certain point in the
execution of the program. Recall that memory is immutable, so modifying a
variable actually fills a new memory cell. The old memory cell still exists, and
snapshots are variables that refer to that "old" value. In this sense, snapshots
are a view "into the past".</p>
<p>Here is how you would define and use a <code>calculate_area</code> function that takes a
snapshot of a <code>Rectangle</code> struct as a parameter instead of taking ownership of
the underlying value. In this example, the <code>calculate_area</code> function returns the
area of the <code>Rectangle</code> passed as a snapshot. Since we’re passing it as an
immutable view, we can be sure that <code>calculate_area</code> will not mutate the
<code>Rectangle</code>, and ownership remains in the <code>main</code> function.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    let first_snapshot = @rec; // Take a snapshot of `rec` at this point in time
    rec.height = 5; // Mutate `rec` by changing its height
    let first_area = calculate_area(first_snapshot); // Calculate the area of the snapshot
    let second_area = calculate_area(@rec); // Calculate the current area
    println!("The area of the rectangle when the snapshot was taken is {}", first_area);
    println!("The current area of the rectangle is {}", second_area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    *rec.height * *rec.width
}
</code></pre>
<blockquote>
<p>Note: Accessing fields of a snapshot (e.g., <code>rec.height</code>) yields snapshots of
those fields, which we desnap with <code>*</code> to get the values. This works here
because <code>u64</code> implements <code>Copy</code>. You’ll learn more about desnapping in the
next section.</p>
</blockquote>
<p>The output of this program is:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_09_snapshots v0.1.0 (listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_09_snapshots
The area of the rectangle when the snapshot was taken is 30
The current area of the rectangle is 50


</code></pre>
<p>First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass <code>@rec</code> into
<code>calculate_area</code> and, in its definition, we take <code>@Rectangle</code> rather than
<code>Rectangle</code>.</p>
<p>Let’s take a closer look at the function call here:</p>
<pre><code class="language-cairo">let second_length = calculate_length(@arr1); // Calculate the current length of the array
</code></pre>
<p>The <code>@rec</code> syntax lets us create a snapshot of the value in <code>rec</code>. Because a
snapshot is an immutable view of a value at a specific point in execution, the
usual rules of the linear type system are not enforced. In particular, snapshot
variables always implement the <code>Drop</code> trait, never the <code>Destruct</code> trait, even
dictionary snapshots.</p>
<p>It’s worth noting that <code>@T</code> is not a pointer—snapshots are passed by value to
functions, just like regular variables. This means that the size of <code>@T</code> is the
same as the size of <code>T</code>, and when you pass <code>@rec</code> to <code>calculate_area</code>, the
entire struct (in this case, a <code>Rectangle</code> with two <code>u64</code> fields) is copied to
the function’s stack. For large data structures, this copying can be avoided by
using <code>Box&lt;T&gt;</code>—provided that there's no need to mutate the value, which we’ll
explore in <a href="./ch12-02-smart-pointers.html">Chapter 12</a>, but for now, understand that
snapshots rely on this by-value mechanism.</p>
<p>Similarly, the signature of the function uses <code>@</code> to indicate that the type of
the parameter <code>arr</code> is a snapshot. Let’s add some explanatory annotations:</p>
<pre><code class="language-cairo  noplayground">fn calculate_area(
    rec_snapshot: @Rectangle // rec_snapshot is a snapshot of a Rectangle
) -&gt; u64 {
    *rec_snapshot.height * *rec_snapshot.width
} // Here, rec_snapshot goes out of scope and is dropped.
// However, because it is only a view of what the original `rec` contains, the original `rec` can still be used.
</code></pre>
<p>The scope in which the variable <code>rec_snapshot</code> is valid is the same as any
function parameter’s scope, but the underlying value of the snapshot is not
dropped when <code>rec_snapshot</code> stops being used. When functions have snapshots as
parameters instead of the actual values, we won’t need to return the values in
order to give back ownership of the original value, because we never had it.</p>
<h3 id="desnap-operator"><a class="header" href="#desnap-operator">Desnap Operator</a></h3>
<p>To convert a snapshot back into a regular variable, you can use the <code>desnap</code>
operator <code>*</code>, which serves as the opposite of the <code>@</code> operator.</p>
<p>Only <code>Copy</code> types can be desnapped. However, in the general case, because the
value is not modified, the new variable created by the <code>desnap</code> operator reuses
the old value, and so desnapping is a completely free operation, just like
<code>Copy</code>.</p>
<p>In the following example, we want to calculate the area of a rectangle, but we
don't want to take ownership of the rectangle in the <code>calculate_area</code> function,
because we might want to use the rectangle again after the function call. Since
our function doesn't mutate the rectangle instance, we can pass the snapshot of
the rectangle to the function, and then transform the snapshots back into values
using the <code>desnap</code> operator <code>*</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    let area = calculate_area(@rec);
    println!("Area: {}", area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.
    // We need to transform the snapshots back into values using the desnap operator `*`.
    // This is only possible if the type is copyable, which is the case for u64.
    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.
    *rec.height * *rec.width
}
</code></pre>
<p>But, what happens if we try to modify something we’re passing as a snapshot? Try
the code in Listing 4-4. Spoiler alert: it doesn’t work!</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">#[derive(Copy, Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    flip(@rec);
}

fn flip(rec: @Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p><span class="caption">Listing 4-4: Attempting to modify a
snapshot value</span></p>
<p>Here’s the error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_04 v0.1.0 (listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/Scarb.toml)
error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:16:5
    rec.height = rec.width;
    ^^^^^^^^^^

error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:17:5
    rec.width = temp;
    ^^^^^^^^^

error: could not compile `listing_04_04` due to 2 previous errors
error: `scarb` command exited with error

</code></pre>
<p>The compiler prevents us from modifying values associated to snapshots.</p>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<p>We can achieve the behavior we want in Listing 4-4 by using
a <em>mutable reference</em> instead of a snapshot. Mutable references are actually
mutable values passed to a function that are implicitly returned at the end of
the function, returning ownership to the calling context. By doing so, they
allow you to mutate the value passed while keeping ownership of it by returning
it automatically at the end of the execution. In Cairo, a parameter can be
passed as <em>mutable reference</em> using the <code>ref</code> modifier.</p>
<blockquote>
<p><strong>Note</strong>: In Cairo, a parameter can only be passed as <em>mutable reference</em>
using the <code>ref</code> modifier if the variable is declared as mutable with <code>mut</code>.</p>
</blockquote>
<p>In Listing 4-5, we use a mutable reference to modify the value of the <code>height</code>
and <code>width</code> fields of the <code>Rectangle</code> instance in the <code>flip</code> function.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    flip(ref rec);
    println!("height: {}, width: {}", rec.height, rec.width);
}

fn flip(ref rec: Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p><span class="caption">Listing 4-5: Use of a mutable reference to modify a
value</span></p>
<p>First, we change <code>rec</code> to be <code>mut</code>. Then we pass a mutable reference of <code>rec</code>
into <code>flip</code> with <code>ref rec</code>, and update the function signature to accept a
mutable reference with <code>ref rec: Rectangle</code>. This makes it very clear that the
<code>flip</code> function will mutate the value of the <code>Rectangle</code> instance passed as
parameter.</p>
<p>Unlike snapshots, mutable references allow mutation, but like snapshots, <code>ref</code>
arguments are not pointers—they are also passed by value. When you pass
<code>ref rec</code>, the entire <code>Rectangle</code> type is copied to the function’s stack,
regardless of whether it implements <code>Copy</code>. This ensures the function operates
on its own local version of the data, which is then implicitly returned to the
caller. To avoid this copying for large types, Cairo provides the <code>Box&lt;T&gt;</code> type
introduced in <a href="./ch12-02-smart-pointers.html">Chapter 12</a> as an
alternative, but for this example, the <code>ref</code> modifier suits our needs perfectly.</p>
<p>The output of the program is:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_05 v0.1.0 (listings/ch04-understanding-ownership/listing_05_mutable_reference/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing listing_04_05
height: 10, width: 3


</code></pre>
<p>As expected, the <code>height</code> and <code>width</code> fields of the <code>rec</code> variable have been
swapped.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch04-02-references-and-snapshots&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The code does not compile because the *desnap* operator has to be used on snapshots, not references.\nInside the `incr` function, the `n` parameter is a reference to a `u32` value, so the `*n` operation is not allowed. The code should be changed to `n += 1;`.\n&quot;,&quot;id&quot;:&quot;6555e9b4-5989-40ee-a8e8-e1fd70d7aa1f&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn incr(ref n: u32) {\n    *n += 1;\n}\n\n#[executable]\nfn main() {\n    let mut n : u32 = 1;\n    incr(ref n);\n    println!(\&quot;{}\&quot;, n);\n}\n&quot;}},{&quot;context&quot;:&quot;The code does not compile because a `ref` can only be used on mutable variables.\nYou should write `let mut rect = Rectangle { height: 10, width: 20 };` instead.\n&quot;,&quot;id&quot;:&quot;7237725b-b4d8-4c05-81be-8d8dd4056cc6&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct Rectangle {\n    height: u64,\n    width: u64,\n}\n\nfn double_rect(ref rect: Rectangle) {\n    rect.height *= 2;\n    rect.width *= 2;\n}\n\n#[executable]\nfn main() {\n    let rect = Rectangle { height: 10, width: 20 };\n    double_rect(ref rect);\n    println!(\&quot;{}\&quot;, rect.height);\n}\n&quot;}},{&quot;context&quot;:&quot;First `snap` and `snap2` are snapshots of a memory location that contains the array `arr1`.\nThen, `arr1` is mutated by appending a new element.\nFinally, `snap2` is updated to be a snapshot of the new array while `snap` remains a snapshot of the old array.\nThe function `sum` receives the latter and returns its sum before the mutation.\n&quot;,&quot;id&quot;:&quot;4512ce8b-c183-4ad1-96e9-bb808456c321&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;6&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn sum(arr: @Array&lt;u128&gt;) -&gt; u128 {\n    let mut span = arr.span();\n    let mut sum = 0;\n    while let Some(x) = span.pop_front() {\n        sum += *x;\n    };\n    sum\n}\n\n#[executable]\nfn main() {\n    let mut arr1: Array&lt;u128&gt; = array![1, 2, 3];\n    let snap = @arr1;\n    let mut snap2 = snap;\n    arr1.append(4);\n    snap2 = @arr1;\n    println!(\&quot;{}\&quot;, sum(snap));\n}\n&quot;}},{&quot;context&quot;:&quot;We want to modify the array and return the ownership to the main function so we must use a mutable reference to the array.\nThe snapshot can't be used because it is immutable and operating on it does not alter the value of the underlying array.\nA mutable reference must be used on mutable variables.\nTo pass a mutable reference as an argument, we must use the `ref` keyword in the definition of the function parameter **and** during the call of the function.\n&quot;,&quot;id&quot;:&quot;b691d9bd-4047-4eb3-bbc8-096f889bb5ac&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\nfn give_and_take(ref arr: Array&lt;u128&gt;, n: u128) -&gt; u128 {\n    arr.append(n);\n    arr.pop_front().unwrap_or(0)\n}\n#[executable]\nfn main() {\n    let mut arr1: Array&lt;u128&gt; = array![1,2,3];\n    let elem = give_and_take(ref arr1, 4);\n    println!(\&quot;{}\&quot;, elem);\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nfn give_and_take(arr: @Array&lt;u128&gt;, n: u128) -&gt; u128 {\n    arr.append(n);\n    arr.pop_front().unwrap_or(0)\n}\n#[executable]\nfn main() {\n    let mut arr1: Array&lt;u128&gt; = array![1,2,3];\n    let elem = give_and_take(@arr1, 4);\n    println!(\&quot;{}\&quot;, elem);\n}\n```\n&quot;,&quot;```\nfn give_and_take(arr: @Array&lt;u128&gt;, n: u128) -&gt; u128 {\n    *arr.append(n);\n    *arr.pop_front().unwrap_or(0)\n}\n#[executable]\nfn main() {\n    let mut arr1: Array&lt;u128&gt; = array![1,2,3];\n    let elem = give_and_take(@arr1, 4);\n    println!(\&quot;{}\&quot;, elem);\n}\n```\n&quot;,&quot;```\nfn give_and_take(ref arr: Array&lt;u128&gt;, n: u128) -&gt; u128 {\n    arr.append(n);\n    arr.pop_front().unwrap_or(0)\n}\n#[executable]\nfn main() {\n    let mut arr1: Array&lt;u128&gt; = array![1,2,3];\n    let elem = give_and_take(arr1, 4);\n    println!(\&quot;{}\&quot;, elem);\n}\n```\n&quot;,&quot;```\nfn give_and_take(ref arr: Array&lt;u128&gt;, n: u128) -&gt; u128 {\n    arr.append(n);\n    arr.pop_front().unwrap_or(0)\n}\n#[executable]\nfn main() {\n    let arr1: Array&lt;u128&gt; = array![1,2,3];\n    let elem = give_and_take(ref arr1, 4);\n    println!(\&quot;{}\&quot;, elem);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Choose the working code snippet that properly defines and uses the function to insert a value at the end of an array while removing the first element and returning it.\nThe array has to be modified by the function and should be usable after the function call.\n&quot;}}]}"></div>
<h2 id="small-recap"><a class="header" href="#small-recap">Small Recap</a></h2>
<p>Let’s recap what we’ve discussed about the linear type system, ownership,
snapshots, and references:</p>
<ul>
<li>At any given time, a variable can only have one owner.</li>
<li>You can pass a variable by-value, by-snapshot, or by-reference to a function.</li>
<li>If you pass-by-value, ownership of the variable is transferred to the
function.</li>
<li>If you want to keep ownership of the variable and know that your function
won’t mutate it, you can pass it as a snapshot with <code>@</code>.</li>
<li>If you want to keep ownership of the variable and know that your function will
mutate it, you can pass it as a mutable reference with <code>ref</code>.</li>
</ul>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="using-structs-to-structure-related-data"><a class="header" href="#using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></h1>
<p>A struct, or structure, is a custom data type that lets you package together and
name multiple related values that make up a meaningful group. If you’re familiar
with an object-oriented language, a struct is like an object’s data attributes.
In this chapter, we’ll compare and contrast tuples with structs to build on what
you already know and demonstrate when structs are a better way to group data.</p>
<p>We’ll demonstrate how to define and instantiate structs. We’ll discuss how to
define associated functions, especially the kind of associated functions called
methods, to specify behavior associated with a struct type. Structs and enums
(discussed in the <a href="ch06-01-enums.html">next chapter</a>) are the building blocks for
creating new types in your program’s domain to take full advantage of Cairo's
compile-time type checking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-and-instantiating-structs"><a class="header" href="#defining-and-instantiating-structs">Defining and Instantiating Structs</a></h1>
<p>Structs are similar to tuples, discussed in the
<a href="ch02-02-data-types.html">Data Types</a> section, in that both hold multiple related
values. Like tuples, the pieces of a struct can be different types. Unlike with
tuples, in a struct you’ll name each piece of data so it’s clear what the values
mean. Adding these names means that structs are more flexible than tuples: you
don’t have to rely on the order of the data to specify or access the values of
an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call fields. For example, Listing
5-1 shows a struct that stores information about a user
account.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}
</code></pre>
<p><span class="caption">Listing 5-1: A <code>User</code> struct
definition</span></p>
<blockquote>
<p><strong>Note :</strong><br />
You can derive multiple traits on structs, such as <code>Drop</code>, <code>PartialEq</code> for
comparison and <code>Debug</code> for debug-printing.<br />
See the <a href="./appendix-03-derivable-traits.html">Appendix on Derivable Traits</a> for
a complete list and examples.</p>
</blockquote>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing <em>key:
value</em> pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill in
that template with particular data to create values of the type.</p>
<p>For example, we can declare two particular users as shown in Listing
5-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}

#[executable]
fn main() {
    let user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    let user2 = User {
        sign_in_count: 1, username: "someusername123", active: true, email: "someone@example.com",
    };
}

</code></pre>
<p>Creating two instances of the <code>User</code> struct</span></p>
<p>To get a specific value from a struct, we use dot notation. For example, to
access <code>user1</code>'s email address, we use <code>user1.email</code>. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field. Listing 5-3 shows how to change the value in the
<code>email</code> field of a mutable <code>User</code> instance.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span>#[executable]
fn main() {
    let mut user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    user1.email = "anotheremail@example.com";
}
<span class="boring">
</span><span class="boring">fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username: username, email: email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username, email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>the value in the email field of a <code>User</code> instance</span></p>
<p>Note that the entire instance must be mutable; Cairo doesn’t allow us to mark
only certain fields as mutable.</p>
<p>As with any expression, we can construct a new instance of the struct as the
last expression in the function body to implicitly return that new instance.</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code>
instance with the given email and username. The <code>active</code> field gets the value of
<code>true</code>, and the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">    user1.email = "anotheremail@example.com";
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username: username, email: email, sign_in_count: 1 }
}
<span class="boring">
</span><span class="boring">fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username, email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><code>build_user</code> function that takes an email and username and returns a <code>User</code>
instance.</span></p>
<p>It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the <code>email</code> and <code>username</code> field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<h2 id="using-the-field-init-shorthand"><a class="header" href="#using-the-field-init-shorthand">Using the Field Init Shorthand</a></h2>
<p>Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the field init shorthand syntax to
rewrite <code>build_user</code> so it behaves exactly the same but doesn’t have the
repetition of <code>username</code> and <code>email</code>, as shown in Listing
5-5.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut user1 = User {
</span><span class="boring">        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">    user1.email = "anotheremail@example.com";
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
</span><span class="boring">    User { active: true, username: username, email: email, sign_in_count: 1 }
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username, email, sign_in_count: 1 }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>A <code>build_user</code> function that uses field init shorthand because the <code>username</code>
and <code>email</code> parameters have the same name as struct fields.</span></p>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field
named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the
<code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather
than <code>email: email</code>.</p>
<h2 id="creating-instances-from-other-instances-with-struct-update-syntax"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances from Other Instances with Struct Update Syntax</a></h2>
<p>It’s often useful to create a new instance of a struct that includes most of the
values from another instance, but changes some. You can do this using <em>struct
update syntax</em>.</p>
<p>First, in Listing 5-6 we show how to create a new
<code>User</code> instance in <code>user2</code> regularly, without the update syntax. We set a new
value for <code>email</code> but otherwise use the same values from <code>user1</code> that we created
in Listing 5-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: "another@example.com",
        sign_in_count: user1.sign_in_count,
    };
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-6: Creating a new
<code>User</code> instance using all but one of the values from <code>user1</code></span></p>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the
remaining fields not explicitly set should have the same value as the fields in
the given instance.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">use core::byte_array;
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: ByteArray,
</span><span class="boring">    email: ByteArray,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: "someone@example.com", username: "someusername123", active: true, sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User { email: "another@example.com", ..user1 };
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 5-7: Using struct update syntax
to set a new <code>email</code> value for a <code>User</code> instance but to use the rest of the
values from <code>user1</code></span></p>
<p>The code in Listing 5-7 also creates an instance of <code>user2</code>
that has a different value for <code>email</code> but has the same values for the
<code>username</code>, <code>active</code>, and <code>sign_in_count</code> fields as <code>user1</code>. The <code>..user1</code> part
must come last to specify that any remaining fields should get their values from
the corresponding fields in <code>user1</code>, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.</p>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because
it moves the data, just as we saw in the <a href="ch04-01-what-is-ownership.html#moving-values">"Moving Values"</a><!-- ignore -->
section. In this example, we can no longer use <code>user1</code> as a whole after creating
<code>user2</code> because the <code>ByteArray</code> in the <code>username</code> field of <code>user1</code> was moved
into <code>user2</code>. If we had given <code>user2</code> new <code>ByteArray</code> values for both <code>email</code>
and <code>username</code>, and thus only used the <code>active</code> and <code>sign_in_count</code> values from
<code>user1</code>, then <code>user1</code> would still be valid after creating <code>user2</code>. Both <code>active</code>
and <code>sign_in_count</code> are types that implement the <code>Copy</code> trait, so the behavior
we discussed in the <a href="ch04-01-what-is-ownership.html#the-copy-trait">"<code>Copy</code> Trait"</a><!-- ignore --> section would apply.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch05-01-defining-and-instantiating-structs&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The `..a` syntax copies each field of `a` into `b` (except `y`), so the second `a.x += 1` has no effect on `b`.\n&quot;,&quot;id&quot;:&quot;bba8893d-f59f-492a-b639-ea04a5c8093b&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;2&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Copy, Drop)]\nstruct Point {\n  x: u32,\n  y: u32,\n}\n\n#[executable]\nfn main() {\n  let mut a = Point { x: 1, y: 2 };\n  a.x += 1;\n  let b = Point { y: 1, ..a };\n  a.x += 1;\n  println!(\&quot;{}\&quot;, b.x);\n}\n&quot;}},{&quot;context&quot;:&quot;`p.x` and `p.y` are __copied__ into new `x` and `y` variables, so the `x += 1` and `y += 1` lines have no effect on `p`.\n&quot;,&quot;id&quot;:&quot;77ef68d6-ee7f-4642-8817-73b846c46b2b&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;1 2&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Copy, Drop)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\n#[executable]\nfn main() {\n    let mut p = Point { x: 1, y: 2 };\n    let mut x = p.x;\n    let mut y = p.y;\n    x += 1;\n    y += 1;\n    println!(\&quot;{} {}\&quot;, p.x, p.y);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-program-using-structs"><a class="header" href="#an-example-program-using-structs">An Example Program Using Structs</a></h1>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start by using single variables, and
then refactor the program until we’re using structs instead.</p>
<p>Let’s make a new project with Scarb called <em>rectangles</em> that will take the width
and height of a rectangle specified in pixels and calculate the area of the
rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s <em>src/lib.cairo</em>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let width = 30;
    let height = 10;
    let area = area(width, height);
    println!("Area is {}", area);
}

fn area(width: u64, height: u64) -&gt; u64 {
    width * height
}
</code></pre>
<p>the area of a rectangle specified by separate width and height variables.</span></p>
<p>Now run the program with <code>scarb execute</code>:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_06_no_struct v0.1.0 (listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing listing_04_06_no_struct
Area is 300


</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the
<code>area</code> function with each dimension, but we can do more to make this code clear
and readable.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-cairo noplayground">fn area(width: u64, height: u64) -&gt; u64 {
</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters, and it’s not clear anywhere in our program
that the parameters are related. It would be more readable and more manageable
to group width and height together. We’ve already discussed one way we might do
that in the
<a href="./ch02-02-data-types.html#the-tuple-type">Tuple Section of Chapter 2</a>.</p>
<h2 id="refactoring-with-tuples"><a class="header" href="#refactoring-with-tuples">Refactoring with Tuples</a></h2>
<p>Listing 5-9 shows another version of our program that uses
tuples.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let rectangle = (30, 10);
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(dimension: (u64, u64)) -&gt; u64 {
    let (x, y) = dimension;
    x * y
}
</code></pre>
<p>5-9: Specifying the width and height of the rectangle with
a tuple.</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so we have to index into the parts of
the tuple, making our calculation less obvious.</p>
<p>Mixing up the width and height wouldn’t matter for the area calculation, but if
we want to calculate the difference, it would matter! We would have to keep in
mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple index <code>1</code>.
This would be even harder for someone else to figure out and keep in mind if
they were to use our code. Because we haven’t conveyed the meaning of our data
in our code, it’s now easier to introduce errors.</p>
<h2 id="refactoring-with-structs-adding-more-meaning"><a class="header" href="#refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</a></h2>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a struct with a name for the whole as well as names for the
parts.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">struct Rectangle {
    width: u64,
    height: u64,
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 30, height: 10 };
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(rectangle: Rectangle) -&gt; u64 {
    rectangle.width * rectangle.height
}
</code></pre>
<p>5-10: Defining a <code>Rectangle</code> struct.</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly brackets,
we defined the fields as <code>width</code> and <code>height</code>, both of which have type <code>u64</code>.
Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code> that has a
width of <code>30</code> and a height of <code>10</code>. Our <code>area</code> function is now defined with one
parameter, which we’ve named <code>rectangle</code> which is of type <code>Rectangle</code> struct. We
can then access the fields of the instance with dot notation, and it gives
descriptive names to the values rather than using the tuple index values of <code>0</code>
and <code>1</code>.</p>
<h2 id="conversions-of-custom-types"><a class="header" href="#conversions-of-custom-types">Conversions of Custom Types</a></h2>
<p>We've already described how to perform type conversion on in-built types, see
<a href="./ch02-02-data-types.html#type-conversion">Data Types &gt; Type Conversion</a>. In this section, we will see
how to define conversions for custom types.</p>
<blockquote>
<p>Note: conversion can be defined for compound types, e.g. tuples, too.</p>
</blockquote>
<h3 id="into-1"><a class="header" href="#into-1">Into</a></h3>
<p>Defining a conversion for a custom type using the <code>Into</code> trait will typically
require specification of the type to convert into, as the compiler is unable to
determine this most of the time. However this is a small trade-off considering
we get the functionality for free.</p>
<pre><code class="language-cairo">#[derive(Drop, PartialEq)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop)]
struct Square {
    side_length: u64,
}

impl SquareIntoRectangle of Into&lt;Square, Rectangle&gt; {
    fn into(self: Square) -&gt; Rectangle {
        Rectangle { width: self.side_length, height: self.side_length }
    }
}

#[executable]
fn main() {
    let square = Square { side_length: 5 };
    // Compiler will complain if you remove the type annotation
    let result: Rectangle = square.into();
    let expected = Rectangle { width: 5, height: 5 };
    assert!(
        result == expected,
        "A square is always convertible to a rectangle with the same width and height!",
    );
}
</code></pre>
<h3 id="tryinto-1"><a class="header" href="#tryinto-1">TryInto</a></h3>
<p>Defining a conversion for <code>TryInto</code> is similar to defining it for <code>Into</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop, PartialEq)]
struct Square {
    side_length: u64,
}

impl RectangleIntoSquare of TryInto&lt;Rectangle, Square&gt; {
    fn try_into(self: Rectangle) -&gt; Option&lt;Square&gt; {
        if self.height == self.width {
            Some(Square { side_length: self.height })
        } else {
            None
        }
    }
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 8, height: 8 };
    let result: Square = rectangle.try_into().unwrap();
    let expected = Square { side_length: 8 };
    assert!(
        result == expected,
        "Rectangle with equal width and height should be convertible to a square.",
    );

    let rectangle = Rectangle { width: 5, height: 8 };
    let result: Option&lt;Square&gt; = rectangle.try_into();
    assert!(
        result.is_none(),
        "Rectangle with different width and height should not be convertible to a square.",
    );
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch05-02-an-example-program-using-structs&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The perimeter function takes ownership of its argument `rectangle`, which doesn't implement `Copy`. Calling `perimeter(rectangle)` therefore moves `rectangle`, meaning it cannot be used on the next line.&quot;,&quot;id&quot;:&quot;3d5a7161-f117-46c6-a293-ccbabe4b4a9d&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct Rectangle {\n    width: u64,\n    height: u64,\n}\n\nfn perimeter(r: Rectangle) -&gt; u64 {\n    2 * (r.width + r.height)\n}\n\n#[executable]\nfn main() {\n    let rectangle = Rectangle { width: 20, height: 10, };\n    let p = perimeter(rectangle);\n    println!(\&quot;2 * ({} + {}) = {}\&quot;, rectangle.width, rectangle.height, p);\n}\n&quot;}},{&quot;context&quot;:&quot;Destructuring refers to the process of extracting individual fields from a struct and binding them to separate variables. When destructuring a struct, you can either use variables with the same names as the struct fields or explicitly bind the fields to variables with different names using the syntax `field_name: variable_name`.&quot;,&quot;id&quot;:&quot;da04e96e-b05c-489d-819a-07e53cc4fee4&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;struct Point { x: u128, y: u128, }\n\n#[executable]\nfn main() {\n    let p = Point { x: 5, y: 10 };\n    let Point { z, w } = p;\n    println!(\&quot;The values of z and w are: ({}, {})\&quot;, z, w);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h1>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum which we cover in
<a href="./ch06-01-enums.html">Chapter 6</a>), and their first
parameter is always <code>self</code>, which represents the instance of the type the method
is being called on.</p>
<h2 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h2>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown in
Listing 5-11</p>
<pre><code class="language-cairo  noplayground">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
</code></pre>
<p>on the <code>Rectangle</code> struct.</p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block for a trait <code>RectangleTrait</code> that defines the methods
that can be called on a <code>Rectangle</code> instance. As impl blocks can only be defined
for traits and not types, we need to define this trait first - but it's not
meant to be used for anything else.</p>
<p>Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code>
type. Then we move the <code>area</code> function within the <code>impl</code> curly brackets and
change the first (and in this case, only) parameter to be <code>self</code> in the
signature and everywhere within the body. In <code>main</code>, where we called the <code>area</code>
function and passed <code>rect1</code> as an argument, we can instead use <em>method syntax</em>
to call the <code>area</code> method on our <code>Rectangle</code> instance. The method syntax goes
after an instance: we add a dot followed by the method name, parentheses, and
any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>self: @Rectangle</code> instead of
<code>rectangle: @Rectangle</code>. Methods must have a parameter named <code>self</code>, for their
first parameter, and the type of <code>self</code> indicates the type that method can be
called on. Methods can take ownership of <code>self</code>, but <code>self</code> can also be passed
by snapshot or by reference, just like any other parameter.</p>
<blockquote>
<p>There is no direct link between a type and a trait. Only the type of the
<code>self</code> parameter of a method defines the type from which this method can be
called. That means, it is technically possible to define methods on multiple
types in a same trait (mixing <code>Rectangle</code> and <code>Circle</code> methods, for example).
But <strong>this is not a recommended practice</strong> as it can lead to confusion.</p>
</blockquote>
<p>The main reason for using methods instead of functions, in addition to providing
method syntax, is for organization. We’ve put all the things we can do with an
instance of a type in one <code>impl</code> block rather than making future users of our
code search for capabilities of <code>Rectangle</code> in various places in the library we
provide.</p>
<h2 id="the-generate_trait-attribute"><a class="header" href="#the-generate_trait-attribute">The <code>generate_trait</code> Attribute</a></h2>
<p>If you are familiar with Rust, you may find Cairo's approach confusing because
methods cannot be defined directly on types. Instead, you must define a
<a href="./ch08-02-traits-in-cairo.html">trait</a> and an implementation of this trait
associated with the type for which the method is intended. However, defining a
trait and then implementing it to define methods on a specific type is verbose,
and unnecessary: the trait itself will not be reused.</p>
<p>So, to avoid defining useless traits, Cairo provides the <code>#[generate_trait]</code>
attribute to add above a trait implementation, which tells the compiler to
generate the corresponding trait definition for you, and lets you focus on the
implementation only. Both approaches are equivalent, but it's considered a best
practice to not explicitly define traits in this case.</p>
<p>The previous example can also be written as follows:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
</code></pre>
<p>Let's use this <code>#[generate_trait]</code> in the following chapters to make our code
cleaner.</p>
<h2 id="snapshots-and-references"><a class="header" href="#snapshots-and-references">Snapshots and References</a></h2>
<p>As the <code>area</code> method does not modify the calling instance, <code>self</code> is declared as
a snapshot of a <code>Rectangle</code> instance with the <code>@</code> snapshot operator. But, of
course, we can also define some methods receiving a mutable reference of this
instance, to be able to modify it.</p>
<p>Let's write a new method <code>scale</code> which resizes a rectangle of a <code>factor</code> given
as parameter:</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }
}

#[executable]
fn main() {
    let mut rect2 = Rectangle { width: 10, height: 20 };
    rect2.scale(2);
    println!("The new size is (width: {}, height: {})", rect2.width, rect2.height);
}
</code></pre>
<p>It is also possible to define a method which takes ownership of the instance by
using just <code>self</code> as the first parameter but it is rare. This technique is
usually used when the method transforms <code>self</code> into something else and you want
to prevent the caller from using the original instance after the transformation.</p>
<p>Look at the <a href="ch04-00-understanding-ownership.html">Understanding Ownership</a>
chapter for more details about these important notions.</p>
<h2 id="methods-with-several-parameters"><a class="header" href="#methods-with-several-parameters">Methods with Several Parameters</a></h2>
<p>Let’s practice using methods by implementing another method on the <code>Rectangle</code>
struct. This time we want to write the method <code>can_hold</code> which accepts another
instance of <code>Rectangle</code> and returns <code>true</code> if this rectangle can fit completely
within self; otherwise, it should return false.</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(@rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(@rect3));
}
</code></pre>
<p>Here, we expect that <code>rect1</code> can hold <code>rect2</code> but not <code>rect3</code>.</p>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h2>
<p>We call <em>associated functions</em> all functions that are defined inside an <code>impl</code>
block that are associated to a specific type. While this is not enforced by the
compiler, it is a good practice to keep associated functions related to the same
type in the same <code>impl</code> block - for example, all functions related to
<code>Rectangle</code> will be grouped in the same <code>impl</code> block for <code>RectangleTrait</code>.</p>
<p>Methods are a special kind of associated function, but we can also define
associated functions that don’t have <code>self</code> as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with,
but are still associated with that type.</p>
<p>Associated functions that aren’t methods are often used for constructors that
will return a new instance of the type. These are often called <code>new</code>, but <code>new</code>
isn’t a special name and isn’t built into the language. For example, we could
choose to provide an associated function named <code>square</code> that would have one
dimension parameter and use that as both width and height, thus making it easier
to create a square <code>Rectangle</code> rather than having to specify the same value
twice:</p>
<p>Let's create the function <code>new</code> which creates a <code>Rectangle</code> from a <code>width</code> and a
<code>height</code>, <code>square</code> which creates a square <code>Rectangle</code> from a <code>size</code> and <code>avg</code>
which computes the average of two <code>Rectangle</code> instances:</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }

    fn new(width: u64, height: u64) -&gt; Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }

    fn avg(lhs: @Rectangle, rhs: @Rectangle) -&gt; Rectangle {
        Rectangle {
            width: ((*lhs.width) + (*rhs.width)) / 2, height: ((*lhs.height) + (*rhs.height)) / 2,
        }
    }
}

#[executable]
fn main() {
    let rect1 = RectangleTrait::new(30, 50);
    let rect2 = RectangleTrait::square(10);

    println!(
        "The average Rectangle of {:?} and {:?} is {:?}",
        @rect1,
        @rect2,
        RectangleTrait::avg(@rect1, @rect2),
    );
}
</code></pre>
<p>To call the <code>square</code> associated function, we use the <code>::</code> syntax with the struct
name; <code>let sq = RectangleTrait::square(3);</code> is an example. This function is
namespaced by the trait: the <code>::</code> syntax is used for both associated functions
and namespaces created by modules. We’ll discuss modules in <a href="./ch07-02-defining-modules-to-control-scope.html">Chapter
7</a>.</p>
<p>Note that the <code>avg</code> function could also be written as a method with <code>self</code> as
the first rectangle. In this case, instead of using the method with
<code>RectangleTrait::avg(@rect1, @rect2)</code>, it would be called with
<code>rect1.avg(rect2)</code>.</p>
<h2 id="multiple-traits-and-impl-blocks"><a class="header" href="#multiple-traits-and-impl-blocks">Multiple Traits and <code>impl</code> Blocks</a></h2>
<p>Each struct is allowed to have multiple <code>trait</code> and <code>impl</code> blocks. For example,
the following code is equivalent to the code shown in the <em>Methods with several
parameters</em> section, which has each method in its own <code>trait</code> and <code>impl</code> blocks.</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[generate_trait]
impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>There’s no strong reason to separate these methods into multiple <code>trait</code> and
<code>impl</code> blocks here, but this is valid syntax.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch05-03-method-syntax&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;It compiles, because the type `Rectangle` on which we call the method on reference is implicitly passed as a `@Rectangle`\n&quot;,&quot;id&quot;:&quot;98bbc25c-80b2-4226-9219-a8d7b20fb991&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;false&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Copy, Drop)]\nstruct Rectangle {\n    width: u64,\n    height: u64,\n}\n\n#[generate_trait]\nimpl RectangleImpl of RectangleTrait {\n    fn area(self: @Rectangle) -&gt; u64 {\n        (*self.width) * (*self.height)\n    }\n    fn new(width: u64, height: u64) -&gt; Rectangle {\n        Rectangle { width, height }\n    }\n    fn compare_areas(self: @Rectangle, r2: @Rectangle) -&gt; bool {\n        self.area() == r2.area()\n    }\n}\n\n#[executable]\nfn main() {\n    let rect1 = Rectangle {width: 40, height: 50};\n    let rect2 = RectangleTrait::new(10, 40);\n    println!(\&quot;{}\&quot;, rect1.compare_areas(@rect2));\n}\n&quot;}},{&quot;context&quot;:&quot;Methods can only be called on the types they're defined for; here, we try to call `area()` on `Circle`, when it's defined for `Rectangle`.\n&quot;,&quot;id&quot;:&quot;1e4a5bff-dc92-4c09-9f04-1d95fcf039bb&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:25},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct Rectangle {\n    width: u64,\n    height: u64,\n}\n\n#[derive(Drop)]\nstruct Circle {\n    radius: u64,\n}\n\ntrait RectangleTrait {\n    fn area(self: @Rectangle) -&gt; u64;\n}\n\nimpl RectangleImpl of RectangleTrait {\n    fn area(self: @Rectangle) -&gt; u64 {\n        return (*self.width) * (*self.height);\n    }\n}\n\n#[executable]\nfn main() {\n    let my_square = Rectangle { width: 30, height: 50 };\n    let my_circle = Circle { radius: 10 };\n    let area = my_circle.area();\n    println!(\&quot;{}\&quot;, area)\n}\n\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-pattern-matching"><a class="header" href="#enums-and-pattern-matching">Enums and Pattern Matching</a></h1>
<p>In this chapter, we’ll look at <em>enumerations</em>, also referred to as <em>enums</em>.
Enums allow you to define a type by enumerating its possible <em>variants</em>. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called <code>Option</code>, which
expresses that a value can be either something or nothing. Finally, we’ll look
at how pattern matching in the <code>match</code> expression makes it easy to run different
code for different values of an enum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Enums, short for "enumerations," are a way to define a custom data type that
consists of a fixed set of named values, called <em>variants</em>. Enums are useful for
representing a collection of related values where each value is distinct and has
a specific meaning.</p>
<h2 id="enum-variants-and-values"><a class="header" href="#enum-variants-and-values">Enum Variants and Values</a></h2>
<p>Here's a simple example of an enum:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}
</code></pre>
<p>In this example, we've defined an enum called <code>Direction</code> with four variants:
<code>North</code>, <code>East</code>, <code>South</code>, and <code>West</code>. The naming convention is to use PascalCase
for enum variants. Each variant represents a distinct value of the <code>Direction</code>
type. In this particular example, variants don't have any associated value. One
variant can be instantiated using this syntax:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Direction {
</span><span class="boring">    North,
</span><span class="boring">    East,
</span><span class="boring">    South,
</span><span class="boring">    West,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let direction = Direction::North;
<span class="boring">}
</span></code></pre>
<p>Now let's imagine that our variants have associated values, that store the exact
degree of the direction. We can define a new <code>Direction</code> enum:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let direction = Direction::North(10);
</span><span class="boring">}
</span></code></pre>
<p>and instantiate it as follows:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Direction {
</span><span class="boring">    North: u128,
</span><span class="boring">    East: u128,
</span><span class="boring">    South: u128,
</span><span class="boring">    West: u128,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let direction = Direction::North(10);
<span class="boring">}
</span></code></pre>
<p>In this code, each variant is associated with a <code>u128</code> value, representing the
direction in degrees. In the next example, we will see that it is also possible
to associate different data types with each variant.</p>
<p>It's easy to write code that acts differently depending on the variant of an
enum instance, in this example to run specific code according to a direction.
You can learn more about it in the <a href="./ch06-02-the-match-control-flow-construct.html">Match Control Flow Construct</a>
section.</p>
<h2 id="enums-combined-with-custom-types"><a class="header" href="#enums-combined-with-custom-types">Enums Combined with Custom Types</a></h2>
<p>Enums can also be used to store more interesting custom data associated with
each variant. For example:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}
</code></pre>
<p>In this example, the <code>Message</code> enum has three variants: <code>Quit</code>, <code>Echo</code>, and
<code>Move</code>, all with different types:</p>
<ul>
<li><code>Quit</code> doesn't have any associated value.</li>
<li><code>Echo</code> is a single <code>felt252</code>.</li>
<li><code>Move</code> is a tuple of two <code>u128</code> values.</li>
</ul>
<p>You could even use a Struct or another enum you defined inside one of your enum
variants.</p>
<h2 id="trait-implementations-for-enums"><a class="header" href="#trait-implementations-for-enums">Trait Implementations for Enums</a></h2>
<p>In Cairo, you can define traits and implement them for your custom enums. This
allows you to define methods and behaviors associated with the enum. Here's an
example of defining a trait and implementing it for the previous <code>Message</code> enum:</p>
<pre><code class="language-cairo  noplayground">trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit =&gt; { println!("quitting") },
            Message::Echo(value) =&gt; { println!("echoing {}", value) },
            Message::Move((x, y)) =&gt; { println!("moving from {} to {}", x, y) },
        }
    }
}
</code></pre>
<p>In this example, we implemented the <code>Processing</code> trait for <code>Message</code>. Here is
how it could be used to process a <code>Quit</code> message:</p>
<pre><code class="language-cairo"><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Echo: felt252,
</span><span class="boring">    Move: (u128, u128),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Processing {
</span><span class="boring">    fn process(self: Message);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ProcessingImpl of Processing {
</span><span class="boring">    fn process(self: Message) {
</span><span class="boring">        match self {
</span><span class="boring">            Message::Quit =&gt; { println!("quitting") },
</span><span class="boring">            Message::Echo(value) =&gt; { println!("echoing {}", value) },
</span><span class="boring">            Message::Move((x, y)) =&gt; { println!("moving from {} to {}", x, y) },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="the-option-enum-and-its-advantages"><a class="header" href="#the-option-enum-and-its-advantages">The <code>Option</code> Enum and Its Advantages</a></h2>
<p>The <code>Option</code> enum is a standard Cairo enum that represents the concept of an
optional value. It has two variants: <code>Some: T</code> and <code>None</code>. <code>Some: T</code> indicates
that there's a value of type <code>T</code>, while <code>None</code> represents the absence of a
value.</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p>The <code>Option</code> enum is helpful because it allows you to explicitly represent the
possibility of a value being absent, making your code more expressive and easier
to reason about. Using <code>Option</code> can also help prevent bugs caused by using
uninitialized or unexpected <code>null</code> values.</p>
<p>To give you an example, here is a function which returns the index of the first
element of an array with a given value, or <code>None</code> if the element is not present.</p>
<p>We are demonstrating two approaches for the above function:</p>
<ul>
<li>Recursive approach with <code>find_value_recursive</code>.</li>
<li>Iterative approach with <code>find_value_iterative</code>.</li>
</ul>
<pre><code class="language-cairo noplayground">fn find_value_recursive(mut arr: Span&lt;felt252&gt;, value: felt252, index: usize) -&gt; Option&lt;usize&gt; {
    match arr.pop_front() {
        Some(index_value) =&gt; { if (*index_value == value) {
            return Some(index);
        } },
        None =&gt; { return None; },
    }

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span&lt;felt252&gt;, value: felt252) -&gt; Option&lt;usize&gt; {
    for (idx, array_value) in arr.into_iter().enumerate() {
        if (*array_value == value) {
            return Some(idx);
        }
    }
    None
}
</code></pre>
<p>Enums can be useful in many situations, especially when using the <code>match</code> flow
construct that we just used. We will describe it in the next section.</p>
<p>Other enums are used very often, such as the <code>Result</code> enum, allowing to handle
errors gracefully. We will explain the <code>Result</code> enum in detail in the <a href="./ch09-02-recoverable-errors.html#the-result-enum">"Error
Handling"</a> chapter.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch06-01-enums&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Cairo does not have null pointers, so the `null` keyword does not exist.\nAn `Option` type should be used to represent the possibility of an object being null.\n&quot;,&quot;id&quot;:&quot;8b786183-ef9f-43f8-89a6-0e9c0e87c576&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[executable]\nfn main() {\n    let x = null;\n    foo(x);\n}\n\nfn foo(x:u8) {\n    println!(\&quot;{}\&quot;, x);\n}\n&quot;}},{&quot;context&quot;:&quot;It's perfectly fine to have structs contain `Option` types as fields (the question asked for a statement which does **NOT** describe a valid reason). But if your data structure has invariants like \&quot;exactly one of two optional fields should be `Some`\&quot;, then that invariant is better ensured by the use of an enum.\n&quot;,&quot;id&quot;:&quot;0d9b6f65-bfac-447f-a2d4-a650abc8bc01&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The struct contains `Option` types, which are only intended to wrap structs&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The struct is more syntactically verbose to construct than the enum&quot;,&quot;The struct uses more space in memory at runtime than the enum&quot;,&quot;The struct could have `ok` and `err` both be `None`, while the enum must have at least one of them&quot;],&quot;prompt&quot;:&quot;Consider these two representations of a `Result` type that contains a value `T` if a computation succeeds, or an error `E` if it fails.\n```\nstruct Result1&lt;T, E&gt; {\n    ok: Option&lt;T&gt;,\n    err: Option&lt;E&gt;,\n}\n\nenum Result2&lt;T, E&gt; {\n    Ok : T,\n    Err : E,\n}\n```\nThe enum `Result2` is considered more idiomatic than the struct `Result1` in Cairo. Which statement below is **NOT** a valid reason why?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="the-match-control-flow-construct"><a class="header" href="#the-match-control-flow-construct">The Match Control Flow Construct</a></h1>
<p>Cairo has an extremely powerful control flow construct called <code>match</code> that
allows you to compare a value against a series of patterns and then execute code
based on which pattern matches. Patterns can be made up of literal values,
variable names, wildcards, and many other things. The power of <code>match</code> comes
from the expressiveness of the patterns and the fact that the compiler confirms
that all possible cases are handled.</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a match, and at the first pattern the value “fits”, the
value falls into the associated code block to be used during execution.</p>
<p>Speaking of coins, let’s use them as an example using <code>match</code>! We can write a
function that takes an unknown US coin and, in a similar way as the counting
machine, determines which coin it is and returns its value in cents, as shown in
Listing 6-1.</p>
<pre><code class="language-cairo noplayground">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<p>and a <code>match</code> expression that has the variants of the enum as its
patterns</span></p>
<p>Let’s break down the <code>match</code> expression in the <code>value_in_cents</code> function. First,
we list the <code>match</code> keyword followed by an expression, which in this case is the
value <code>coin</code>. This seems very similar to a conditional expression used with the
<code>if</code> statement, but there’s a big difference: with <code>if</code>, the condition needs to
evaluate to a boolean value, but here it can be any type. The type of <code>coin</code> in
this example is the <code>Coin</code> enum that we defined on the first line.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code>
operator that separates the pattern and the code to run. The code in this case
is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against
the pattern of each arm, in the order they are given. If a pattern matches the
value, the code associated with that pattern is executed. If that pattern
doesn’t match the value, execution continues to the next arm, much as in a
coin-sorting machine. We can have as many arms as we need: in the above example,
our <code>match</code> has four arms.</p>
<p>The code associated with each arm is an expression, and the resultant value of
the expression in the matching arm is the value that gets returned for the
entire match expression.</p>
<p>We don’t typically use curly brackets if the <code>match</code> arm code is short, as it is
in our example where each arm just returns a value. If you want to run multiple
lines of code in a <code>match</code> arm, you must use curly brackets, with a comma
following the arm. For example, the following code prints “Lucky penny!” every
time the method is called with a <code>Coin::Penny</code>, but still returns the last value
of the block, <code>1</code>:</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<h2 id="patterns-that-bind-to-values"><a class="header" href="#patterns-that-bind-to-values">Patterns That Bind to Values</a></h2>
<p>Another useful feature of <code>match</code> arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different designs
for each of the 50 states on one side. No other coins got state designs, so only
quarters have this extra value. We can add this information to our <code>enum</code> by
changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored inside it,
which we’ve done in Listing 6-2.</p>
<pre><code class="language-cairo noplayground">
#[derive(Drop, Debug)] // Debug so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
}

#[derive(Drop)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter: UsState,
}
</code></pre>
<p>6-2: A <code>Coin</code> enum in which the <code>Quarter</code> variant also
holds a <code>UsState</code> value</span></p>
<p>Let’s imagine that a friend is trying to collect all 50 state quarters. While we
sort our loose change by coin type, we’ll also call out the name of the state
associated with each quarter so that if it’s one our friend doesn’t have, they
can add it to their collection.</p>
<p>In the <code>match</code> expression for this code, we add a variable called <code>state</code> to the
pattern that matches values of the variant <code>Coin::Quarter</code>. When a
<code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that
quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
</code></pre>
<p>Because <code>state</code> is an <code>UsState</code> enum which implements the <code>Debug</code> trait, we can
print <code>state</code> value with <code>println!</code> macro.</p>
<blockquote>
<p>Note: <code>{:?}</code> is a special formatting syntax that allows to print a debug form
of the parameter passed to the <code>println!</code> macro. You can find more information
about it in <a href="./appendix-03-derivable-traits.html#debug-for-printing-and-debugging">Appendix C</a>.</p>
</blockquote>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code>
would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each
of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At
that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can
then use that binding in <code>println!</code> macro, thus getting the inner state value
out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<h2 id="matching-with-optiont"><a class="header" href="#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h2>
<p>In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code>
case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code>, as we
did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the variants
of <code>Option&lt;T&gt;</code>, but the way the <code>match</code> expression works remains the same.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;u8&gt;</code> and, if there’s
a value inside, adds <code>1</code> to that value. If there is no value inside, the
function should return the <code>None</code> value and not attempt to perform any
operations.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like
Listing 6-3.</p>
<pre><code class="language-cairo">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Some(val) =&gt; Some(val + 1),
        None =&gt; None,
    }
}

#[executable]
fn main() {
    let five: Option&lt;u8&gt; = Some(5);
    let six: Option&lt;u8&gt; = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<p>function that uses a <code>match</code> expression on an <code>Option&lt;u8&gt;</code></span></p>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call
<code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value
<code>Some(5)</code>. We then compare that against each <code>match</code> arm:</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p>Does <code>Some(5)</code> value match the pattern <code>Some(val)</code>? It does! We have the same
variant. The <code>val</code> binds to the value contained in <code>Some</code>, so <code>val</code> takes the
value <code>5</code>. The code in the <code>match</code> arm is then executed, so we add <code>1</code> to the
value of <code>val</code> and create a new <code>Some</code> value with our total <code>6</code> inside. Because
the first arm matched, no other arms are compared.</p>
<p>Now let’s consider the second call of <code>plus_one</code> in our main function, where <code>x</code>
is <code>None</code>. We enter the <code>match</code> and compare to the first arm:</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p>The <code>Some(val)</code> value doesn’t match the pattern <code>None</code>, so we continue to the
next arm:</p>
<pre><code class="language-cairo">        None =&gt; None,
</code></pre>
<p>It matches! There’s no value to add to, so the matching construct ends and
returns the <code>None</code> value on the right side of <code>=&gt;</code>.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this
pattern a lot in Cairo code: <code>match</code> against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.</p>
<h2 id="matches-are-exhaustive"><a class="header" href="#matches-are-exhaustive">Matches Are Exhaustive</a></h2>
<p>There’s one other aspect of <code>match</code> we need to discuss: the arms’ patterns must
cover all possibilities. Consider this version of our <code>plus_one</code> function, which
has a bug and won’t compile:</p>
<pre><code class="language-cairo noplayground">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Some(val) =&gt; Some(val + 1),
    }
}
</code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug. Luckily, it’s a
bug Cairo knows how to catch. If we try to compile this code, we’ll get this
error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_08_missing_match_arm v0.1.0 (listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml)
error: Match is non-exhaustive: `None(_)` not covered.
 --&gt; listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:5:5-7:5
      match x {
 _____^
|         Some(val) =&gt; Some(val + 1),
|     }
|_____^

error: could not compile `no_listing_08_missing_match_arm` due to 1 previous error
error: `scarb` command exited with error

</code></pre>
<p>Cairo knows that we didn’t cover every possible case, and even knows which
pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
<code>Option&lt;T&gt;</code>, when Cairo prevents us from forgetting to explicitly handle the
<code>None</code> case, it protects us from assuming that we have a value when we might
have null, thus making the <a href="https://en.wikipedia.org/wiki/Null_pointer#History">billion-dollar mistake</a> discussed
earlier impossible.</p>
<h2 id="catch-all-with-the-_-placeholder"><a class="header" href="#catch-all-with-the-_-placeholder">Catch-all with the <code>_</code> Placeholder</a></h2>
<p>Using enums, we can also take special actions for a few particular values, but
for all other values take one default action. <code>_</code> is a special pattern that
matches any value and does not bind to that value. You can use it by simply
adding a new arm with <code>_</code> as the pattern for the last arm of the <code>match</code>
expression.</p>
<p>Imagine we have a vending machine that only accepts Dime coins. We want to have
a function that processes inserted coins and returns <code>true</code> only if the coin is
accepted.</p>
<p>Here's a <code>vending_machine_accept</code> function that implements this logic:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<p>This example also meets the exhaustiveness requirement because we’re explicitly
ignoring all other values in the last arm; we haven’t forgotten anything.</p>
<blockquote>
<p>There's no catch-all pattern in Cairo that allows you to use the value of the
pattern.</p>
</blockquote>
<!--
  TODO move the following in a separate chapter when there's more pattern matching features in upcoming Cairo versions. cf rust book chapter 18
-->
<h2 id="multiple-patterns-with-the--operator"><a class="header" href="#multiple-patterns-with-the--operator">Multiple Patterns with the <code>|</code> Operator</a></h2>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which is the pattern <em>or</em> operator.</p>
<p>For example, in the following code we modified the <code>vending_machine_accept</code>
function to accept both <code>Dime</code> and <code>Quarter</code> coins in a single arm:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime | Coin::Quarter =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="matching-tuples"><a class="header" href="#matching-tuples">Matching Tuples</a></h2>
<p>It is possible to match tuples. Let's introduce a new <code>DayType</code> enum:</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum DayType {
    Week,
    Weekend,
    Holiday,
}
</code></pre>
<p>Now, let's suppose that our vending machine accepts any coin on weekdays, but
only accepts quarters and dimes on weekends and holidays. We can modify the
<code>vending_machine_accept</code> function to accept a tuple of a <code>Coin</code> and a <code>Weekday</code>
and return <code>true</code> only if the given coin is accepted on the specified day:</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, _) =&gt; true,
        (_, Coin::Dime) | (_, Coin::Quarter) =&gt; true,
        (_, _) =&gt; false,
    }
}
</code></pre>
<p>Writing <code>(_, _)</code> for the last arm of a tuple matching pattern might feel
superfluous. Hence, we can use the <code>_ =&gt;</code> syntax if we want, for example, that
our vending machine only accepts quarters on weekdays:</p>
<pre><code class="language-cairo noplayground">fn vending_week_machine(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, Coin::Quarter) =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="matching-felt252-and-integer-variables"><a class="header" href="#matching-felt252-and-integer-variables">Matching <code>felt252</code> and Integer Variables</a></h2>
<p>You can also match <code>felt252</code> and integer variables. This is useful when you want
to match against a range of values. However, there are some restrictions:</p>
<ul>
<li>Only integers that fit into a single <code>felt252</code> are supported (i.e. <code>u256</code> is
not supported).</li>
<li>The first arm must be 0.</li>
<li>Each arm must cover a sequential segment, contiguously with other arms.</li>
</ul>
<p>Imagine we’re implementing a game where you roll a six-sided die to get a number
between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you can roll
again. For all other values you lose.</p>
<p>Here's a match that implements that logic:</p>
<pre><code class="language-cairo noplayground">fn roll(value: u8) {
    match value {
        0 | 1 | 2 =&gt; println!("you won!"),
        3 =&gt; println!("you can roll again!"),
        _ =&gt; println!("you lost..."),
    }
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch06-02-match&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Cairo supports matching for tuples. The program matches the `Range` variant,\nthen matches the tuple `(2, 5)` against the pattern `(_, n)`, binding `n` to `5`.\n&quot;,&quot;id&quot;:&quot;b0621230-c040-4f30-b658-14d31f4fab82&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;5&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Copy, Drop)]\nenum Location {\n    Point : u32,\n    Range : (u32, u32)\n}\n\n#[executable]\nfn main() {\n    let loc: Location = Location::Range((2, 5));\n    let n: u32 = match loc {\n        Location::Point(p) =&gt; p,\n        Location::Range(r) =&gt; match r {\n            (0, _) =&gt; 0,\n            (_, n) =&gt; n,\n            _ =&gt; 404\n        },\n        _ =&gt; 403\n    };\n    println!(\&quot;{}\&quot;, n);\n}\n&quot;}},{&quot;context&quot;:&quot;The first match arm `Either::Right(s)` moves the field `s`, so `x` cannot be used in the second match.\n&quot;,&quot;id&quot;:&quot;b0147849-6c36-46a5-b933-51289913a621&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nenum Either {\n    Left: u32,\n    Right: ByteArray\n}\n\n#[executable]\nfn main() {\n    let x = Either::Right(\&quot;Hello World\&quot;);\n    let simple = match x {\n      Either::Left(n) =&gt; n,\n      Either::Right(s) =&gt; s.len()\n    };\n    let doubled = match x {\n      Either::Left(n) =&gt; n * 2,\n      Either::Right(s) =&gt; s.len() * 2\n    };\n    println!(\&quot;doubled: {}\&quot;, doubled);\n}\n&quot;}},{&quot;context&quot;:&quot;There's no catch-all pattern in Cairo that allows you to use the value of the pattern.\nYou have to use the placeholder `_` instead.\n&quot;,&quot;id&quot;:&quot;bb07c951-7f3d-4225-ae54-adff59774b76&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn decr_twice(n: u32) -&gt; Option&lt;u32&gt; {\n    match n {\n        0 | 1 =&gt; None,\n        val =&gt; Some(val - 2)\n    }\n}\n&quot;}},{&quot;context&quot;:&quot;This function \&quot;unwraps\&quot; the option by consuming ownership of it and retrieving the value inside, but if no value exists then it falls back by returning `default`. This is a real function in the core library!\n&quot;,&quot;id&quot;:&quot;72e6696d-379e-4440-af15-803b7255bc80&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Returns the object inside `self` if it exists, and `default` otherwise&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Returns a reference to the object inside `self` if it exists, and `default` otherwise&quot;,&quot;Returns a new option containing the object inside `self` if it exists, and `default` otherwise&quot;,&quot;Inserts `default` into `self` if `self` does not already contain a value&quot;],&quot;prompt&quot;:&quot;Consider this method implemented for the `Option` type:\n```\nfn unwrap_or&lt;+Drop&lt;T&gt;&gt;(self: Option&lt;T&gt;, default: T) -&gt; T {\n    match self {\n        Some(x) =&gt; x,\n        None =&gt; default,\n    }\n}\n```\nWhich sentence best describes the behavior of this function?\n&quot;}},{&quot;context&quot;:&quot;The `match` and `if` perform the same operation here. A `match` is like a specialized `if` that checks for equality of the matched object.\n&quot;,&quot;id&quot;:&quot;e07e8e36-2c53-4b30-8040-091c3d4f2fd1&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;All inputs&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Some, but not all inputs&quot;,&quot;No inputs&quot;],&quot;prompt&quot;:&quot;Consider these two implementations of a function to decrement an unsigned number twice.\n```\nfn decr_twice_v1(n: u32) -&gt; Option&lt;u32&gt; {\n    match n {\n        0 | 1 =&gt; None,\n        _ =&gt; Some(n - 2)\n    }\n}\n\nfn decr_twice_v2(n: u32) -&gt; Option&lt;u32&gt; {\n    if n == 0 {\n        None\n    } else if n == 1 {\n        None\n    } else {\n        Some(n - 2)\n    }\n}\n```\nThe functions have the same behavior for:\n&quot;}}]}"></div>
<blockquote>
<p>These restrictions are planned to be relaxed in future versions of Cairo.</p>
</blockquote>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="concise-control-flow-with-if-let-and-while-let"><a class="header" href="#concise-control-flow-with-if-let-and-while-let">Concise Control Flow with <code>if let</code> and <code>while let</code></a></h1>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-4 that matches on an <code>Some&lt;u8&gt;</code> value in
the <code>config_max</code> variable but only wants to execute code if the value is <code>Some</code>
variant.</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let config_max = Some(5);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {}", max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre>
<p><code>match</code> that only cares about executing code when the value is <code>Some</code></span></p>
<p>If the value is <code>Some</code>, we print out the value in the <code>Some</code> variant by binding
the value to the variable <code>max</code> in the pattern. We don’t want to do anything
with the <code>None</code> value. To satisfy the <code>match</code> expression, we have to add
<code>_ =&gt; ()</code> after processing just one variant, which is annoying boilerplate code
to add.</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following code
behaves the same as the <code>match</code> in Listing 6-4:</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let number = Some(5);
    if let Some(max) = number {
        println!("The maximum is configured to be {}", max);
    }
<span class="boring">}
</span></code></pre>
<p>The syntax <code>if let</code> takes a pattern and an expression separated by an equal
sign. It works the same way as a <code>match</code>, where the expression is given to the
<code>match</code> and the pattern is its first arm. In this case, the pattern is
<code>Some(max)</code>, and <code>max</code> binds to the value inside <code>Some</code>. We can then use <code>max</code>
in the body of the <code>if let</code> block in the same way we used <code>max</code> in the
corresponding <code>match</code> arm. The code in the <code>if let</code> block isn’t run if the value
doesn’t match the pattern.</p>
<p>Using <code>if let</code> means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that <code>match</code> enforces. Choosing
between <code>match</code> and <code>if let</code> depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for losing
exhaustive checking.</p>
<p>In other words, you can think of <code>if let</code> as syntactic sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with
<code>else</code> is the same as the block of code that would go with the <code>_</code> case in the
<code>match</code> expression. Recall the <code>Coin</code> enum definition in Listing
6-2, where the <code>Quarter</code> variant also held a <code>UsState</code>
value. If we wanted to count all non-quarter coins we see while also announcing
the state of the quarters, we could do that with a <code>match</code> expression, like
this:</p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let coin = Coin::Quarter;
    let mut count = 0;
    match coin {
        Coin::Quarter =&gt; println!("You got a quarter!"),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression, like this:</p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop)]
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let coin = Coin::Quarter;
    let mut count = 0;
    if let Coin::Quarter = coin {
        println!("You got a quarter!");
    } else {
        count += 1;
    }
<span class="boring">    println!("{}", count);
</span><span class="boring">}
</span></code></pre>
<p>If you have a situation in which your program has logic that is too verbose to
express using <code>match</code>, remember that <code>if let</code> is in your Cairo toolbox as well.</p>
<h2 id="while-let"><a class="header" href="#while-let"><code>while let</code></a></h2>
<p>The <code>while let</code> syntax is similar to the <code>if let</code> syntax, but it allows you to
loop over a collection of values and execute a block of code for each value that
matches a specified pattern. In the case below, the pattern is <code>Some(x)</code>, which
matches any <code>Some</code> variant of the <code>Option</code> enum.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr = array![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut sum = 0;
    while let Some(value) = arr.pop_front() {
        sum += value;
    }
    println!("{}", sum);
}
</code></pre>
<p>Using <code>while let</code> provides a more concise and idiomatic way of writing this loop
compared to a traditional <code>while</code> loop with explicit pattern matching or
handling of the <code>Option</code> type. However, as with <code>if let</code>, you lose the
exhaustive checking that a <code>match</code> expression provides, so you need to be
careful to handle any remaining cases outside the <code>while let</code> loop if necessary.</p>
<h2 id="let-chains"><a class="header" href="#let-chains">Let Chains</a></h2>
<p>Cairo supports let chains to combine multiple conditions involving <code>if let</code> or
<code>while let</code> without nesting. This lets you pattern-match and apply additional
boolean conditions in a single expression:</p>
<pre><code class="language-cairo">fn get_x() -&gt; Option&lt;u32&gt; {
    Some(5)
}

fn get_y() -&gt; Option&lt;u32&gt; {
    Some(8)
}

#[executable]
fn main() {
    // Using a let chain to combine pattern matching and additional conditions
    if let Some(x) = get_x() &amp;&amp; x &gt; 0 &amp;&amp; let Some(y) = get_y() &amp;&amp; y &gt; 0 {
        let sum: u32 = x + y;
        println!("sum: {}", sum);
        return;
    }
    println!("x or y is not positive");
    // else is not supported yet;
}
</code></pre>
<blockquote>
<p>Note: <code>else</code> is not yet supported for let chain expressions; this will be
added in a later version.</p>
</blockquote>
<h2 id="let-else"><a class="header" href="#let-else"><code>let else</code></a></h2>
<p><code>let else</code> enables refutable pattern matching in a <code>let</code> binding and allows the
<code>else</code> block to diverge (for example with <code>return</code>, <code>break</code>, <code>continue</code>, or
<code>panic!</code>) when the pattern does not match:</p>
<pre><code class="language-cairo">#[derive(Drop)]
enum MyEnum {
    A: u32,
    B: u32,
}

fn foo(a: MyEnum) {
    let MyEnum::A(x) = a else {
        println!("Called with B");
        return;
    };
    println!("Called with A({x})");
}

#[executable]
fn main() {
    foo(MyEnum::A(42));
    foo(MyEnum::B(7));
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-cairo-projects-with-packages-crates-and-modules"><a class="header" href="#managing-cairo-projects-with-packages-crates-and-modules">Managing Cairo Projects with Packages, Crates and Modules</a></h1>
<p>As you write large programs, organizing your code will become increasingly
important. By grouping related functionality and separating code with distinct
features, you’ll clarify where to find code that implements a particular feature
and where to go to change how a feature works.</p>
<p>The programs we’ve written so far have been in one module in one file. As a
project grows, you should organize code by splitting it into multiple modules
and then multiple files. As a package grows, you can extract parts into separate
crates that become external dependencies. This chapter covers all these
techniques.</p>
<p>We’ll also discuss encapsulating implementation details, which lets you reuse
code at a higher level: once you’ve implemented an operation, other code can
call your code without having to know how the implementation works.</p>
<p>A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope”. When reading, writing, and
compiling code, programmers and compilers need to know whether a particular name
at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope.</p>
<p>Cairo has a number of features that allow you to manage your code’s
organization. These features, sometimes collectively referred to as the <em>module
system</em>, include:</p>
<ul>
<li><strong>Packages:</strong> A Scarb feature that lets you build, test, and share crates.</li>
<li><strong>Crates:</strong> A tree of modules that corresponds to a single compilation unit.
It has a root directory, and a root module defined at the <em>lib.cairo</em> file
under this directory.</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization and scope of items.</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module.</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-and-crates"><a class="header" href="#packages-and-crates">Packages and Crates</a></h1>
<h2 id="what-is-a-crate"><a class="header" href="#what-is-a-crate">What is a Crate?</a></h2>
<p>A crate is a subset of a package that is used in the actual Cairo compilation.
This includes:</p>
<ul>
<li>The package source code, identified by the package name and the crate root,
which is the main entry point of the package.</li>
<li>A subset of the package metadata that identifies crate-level settings of the
Cairo compiler, for example, the <code>edition</code> field in the <em>Scarb.toml</em> file.</li>
</ul>
<p>Crates can contain modules, and the modules may be defined in other files that
get compiled with the crate, as will be discussed in the subsequent sections.</p>
<h2 id="what-is-the-crate-root"><a class="header" href="#what-is-the-crate-root">What is the Crate Root?</a></h2>
<p>The crate root is the <em>lib.cairo</em> source file that the Cairo compiler starts
from and makes up the root module of your crate. We’ll explain modules in depth
in the <a href="./ch07-02-defining-modules-to-control-scope.html">"Defining Modules to Control Scope"</a> chapter.</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a Package?</a></h2>
<p>A Cairo package is a directory (or equivalent) containing:</p>
<ul>
<li>A <em>Scarb.toml</em> manifest file with a <code>[package]</code> section.</li>
<li>Associated source code.</li>
</ul>
<p>This definition implies that a package might contain other packages, with a
corresponding <em>Scarb.toml</em> file for each package.</p>
<h2 id="creating-a-package-with-scarb"><a class="header" href="#creating-a-package-with-scarb">Creating a Package with Scarb</a></h2>
<p>You can create a new Cairo package using the Scarb command-line tool. To create
a new package, run the following command:</p>
<pre><code class="language-bash">scarb new my_package
</code></pre>
<p>This command will generate a new package directory named <em>my_package</em> with the
following structure:</p>
<pre><code>my_package/
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<ul>
<li><em>src/</em> is the main directory where all the Cairo source files for the package
will be stored.</li>
<li><em>lib.cairo</em> is the default root module of the crate, which is also the main
entry point of the package.</li>
<li><em>Scarb.toml</em> is the package manifest file, which contains metadata and
configuration options for the package, such as dependencies, package name,
version, and authors. You can find documentation about it on the <a href="https://docs.swmansion.com/scarb/docs/reference/manifest.html">Scarb
reference</a>.</li>
</ul>
<pre><code class="language-toml">[package]
name = "my_package"
version = "0.1.0"
edition = "2024_07"

[executable]

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"
</code></pre>
<p>As you develop your package, you may want to organize your code into multiple
Cairo source files. You can do this by creating additional <em>.cairo</em> files within
the <em>src</em> directory or its subdirectories.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-01-packages-crates&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;A package is the top-level organizational unit, containing crates. A crate contains modules.\n&quot;,&quot;id&quot;:&quot;340f3191-f990-4a3d-89ab-7c98ac6ae0e3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;package &gt; crate &gt; module&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;crate &gt; package &gt; module&quot;,&quot;crate &gt; module &gt; package&quot;,&quot;package &gt; module &gt; crate&quot;],&quot;prompt&quot;:&quot;Which is the correct order, where \&quot;A &gt; B\&quot; means \&quot;A contains B\&quot;?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="defining-modules-to-control-scope"><a class="header" href="#defining-modules-to-control-scope">Defining Modules to Control Scope</a></h1>
<p>In this section, we’ll talk about modules and other parts of the module system,
namely <em>paths</em> that allow you to name items and the <code>use</code> keyword that brings a
path into scope.</p>
<p>First, we’re going to start with a list of rules for easy reference when you’re
organizing your code in the future. Then we’ll explain each of the rules in
detail.</p>
<h2 id="modules-cheat-sheet"><a class="header" href="#modules-cheat-sheet">Modules Cheat Sheet</a></h2>
<p>Here we provide a quick reference on how modules, paths and the <code>use</code> keyword
work in the compiler, and how most developers organize their code. We’ll be
going through examples of each of these rules throughout this chapter, but this
is a great place to refer to as a reminder of how modules work. You can create a
new Scarb project with <code>scarb new backyard</code> to follow along.</p>
<ul>
<li>
<p><strong>Start from the crate root</strong>: When compiling a crate, the compiler first
looks in the crate root file (<em>src/lib.cairo</em>) for code to compile.</p>
</li>
<li>
<p><strong>Declaring modules</strong>: In the crate root file, you can declare new modules;
say, you declare a “garden” module with <code>mod garden;</code>. The compiler will look
for the module’s code in these places:</p>
<ul>
<li>
<p>Inline, within curly brackets that replace the semicolon following
<code>mod garden</code>.</p>
<pre><code class="language-cairo noplayground">  // crate root file (src/lib.cairo)
  mod garden {
      // code defining the garden module goes here
  }
</code></pre>
</li>
<li>
<p>In the file <em>src/garden.cairo</em>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Declaring submodules</strong>: In any file other than the crate root, you can
declare submodules. For example, you might declare <code>mod vegetables;</code> in
<em>src/garden.cairo</em>. The compiler will look for the submodule’s code within the
directory named for the parent module in these places:</p>
<ul>
<li>
<p>Inline, directly following <code>mod vegetables</code>, within curly brackets instead
of the semicolon.</p>
<pre><code class="language-cairo noplayground">// src/garden.cairo file
mod vegetables {
    // code defining the vegetables submodule goes here
}
</code></pre>
</li>
<li>
<p>In the file <em>src/garden/vegetables.cairo</em>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Paths to code in modules</strong>: Once a module is part of your crate, you can
refer to code in that module from anywhere else in that same crate, using the
path to the code. For example, an <code>Asparagus</code> type in the <code>vegetables</code>
submodule would be found at <code>crate::garden::vegetables::Asparagus</code>.</p>
</li>
<li>
<p><strong>Private vs public</strong>: Code within a module is private from its parent modules
by default. This means that it may only be accessed by the current module and
its descendants. To make a module public, declare it with <code>pub mod</code> instead of
<code>mod</code>. To make items within a public module public as well, use <code>pub</code> before
their declarations. Cairo also provides the <code>pub(crate)</code> keyword, allowing an
item or module to be only visible within the crate in which the definition is
included.</p>
</li>
<li>
<p><strong>The <code>use</code> keyword</strong>: Within a scope, the <code>use</code> keyword creates shortcuts to
items to reduce repetition of long paths. In any scope that can refer to
<code>crate::garden::vegetables::Asparagus</code>, you can create a shortcut with
<code>use crate::garden::vegetables::Asparagus;</code> and from then on you only need to
write <code>Asparagus</code> to make use of that type in the scope.</p>
</li>
</ul>
<p>Here we create a crate named <code>backyard</code> that illustrates these rules. The
crate’s directory, also named <code>backyard</code>, contains these files and directories:</p>
<pre><code class="language-text">backyard/
├── Scarb.toml
└── src
    ├── garden
    │   └── vegetables.cairo
    ├── garden.cairo
    └── lib.cairo
</code></pre>
<p>The crate root file in this case is <em>src/lib.cairo</em>, and it contains:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">pub mod garden;
use crate::garden::vegetables::Asparagus;

#[executable]
fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
</code></pre>
<p>The <code>pub mod garden;</code> line imports the <code>garden</code> module. Using <code>pub</code> to make
<code>garden</code> publicly accessible, or <code>pub(crate)</code> if you really want to make
<code>garden</code> only available for your crate, is optional to run our program here, as
the <code>main</code> function resides in the same module as <code>pub mod garden;</code> declaration.
Nevertheless, not declaring <code>garden</code> as <code>pub</code> will make it not accessible from
any other package. This line tells the compiler to include the code it finds in
<em>src/garden.cairo</em>, which is:</p>
<p><span class="filename">Filename: src/garden.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod vegetables;
</code></pre>
<p>Here, <code>pub mod vegetables;</code> means the code in <em>src/garden/vegetables.cairo</em> is
included too. That code is:</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Debug)]
pub struct Asparagus {}
</code></pre>
<p>The line <code>use crate::garden::vegetables::Asparagus;</code> lets us bring the
<code>Asparagus</code> type into scope, so we can use it in the <code>main</code> function.</p>
<p>Now let’s get into the details of these rules and demonstrate them in action!</p>
<h2 id="grouping-related-code-in-modules"><a class="header" href="#grouping-related-code-in-modules">Grouping Related Code in Modules</a></h2>
<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.
Modules also allow us to control the privacy of items, because code within a
module is private by default. Private items are internal implementation details
not available for outside use. We can choose to make modules and the items
within them public, which exposes them to allow external code to use and depend
on them.</p>
<p>As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than the
implementation of a restaurant.</p>
<p>In the restaurant industry, some parts of a restaurant are referred to as <em>front
of house</em> and others as <em>back of house</em>. Front of house is where customers are;
this encompasses where the hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.</p>
<p>To structure our crate in this way, we can organize its functions into nested
modules. Create a new package named <em>restaurant</em> by running
<code>scarb new restaurant</code>; then enter the code in Listing 7-1
into <em>src/lib.cairo</em> to define some modules and function signatures. Here’s the
front of house section:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p>A <code>front_of_house</code> module containing other modules that then contain
functions</span></p>
<p>We define a module with the <code>mod</code> keyword followed by the name of the module (in
this case, <code>front_of_house</code>). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules <code>hosting</code> and <code>serving</code>. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and functions.</p>
<p>By using modules, we can group related definitions together and name why they’re
related. Programmers using this code can navigate the code based on the groups
rather than having to read through all the definitions, making it easier to find
the definitions relevant to them. Programmers adding new functionality to this
code would know where to place the code to keep the program organized.</p>
<p>Earlier, we mentioned that <em>src/lib.cairo</em> is called the crate root. The reason
for this name is that the content of this file forms a module named after the
crate name at the root of the crate’s module structure, known as the <em>module
tree</em>.</p>
<p>Listing 7-2 shows the module tree for the structure in Listing
7-1.</p>
<pre><code class="language-text">restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>module tree for the code in Listing 7-1</span></p>
<p>This tree shows how some of the modules nest inside one another; for example,
<code>hosting</code> nests inside <code>front_of_house</code>. The tree also shows that some modules
are <em>siblings</em> to each other, meaning they’re defined in the same module;
<code>hosting</code> and <code>serving</code> are siblings defined within <code>front_of_house</code>. If module
A is contained inside module B, we say that module A is the <em>child</em> of module B
and that module B is the <em>parent</em> of module A. Notice that the entire module
tree is rooted under the explicit name of the crate <em>restaurant</em>.</p>
<p>The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-02-defining-modules-to-control-scope&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Modules have no effect on runtime, they are purely for compile-time organization.\n&quot;,&quot;id&quot;:&quot;cedb14f3-d1b4-4760-8b32-ab8626372b2c&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Modules boost the runtime performance of interdependent code within the same module&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Modules provide a scope to avoid naming conflicts across parts of a codebase&quot;,&quot;Modules group related code so programmers can more easily work on a large codebase&quot;,&quot;Modules encapsulate implementation details that shouldn't be used by external clients&quot;],&quot;prompt&quot;:&quot;Which of the following is **NOT** a benefit of using modules?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h1>
<p>To show Cairo where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. To call a function, we need to
know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> is the full path starting from a crate root. The absolute
path begins with the crate name.</li>
<li>A <em>relative path</em> starts from the current module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
<p>To illustrate this notion let's take back our example Listing
7-1 for the restaurant we used in the last chapter. We have
a crate named <em>restaurant</em> in which we have a module named <code>front_of_house</code> that
contains a module named <code>hosting</code>. The <code>hosting</code> module contains a function
named <code>add_to_waitlist</code>. We want to call the <code>add_to_waitlist</code> function from the
<code>eat_at_restaurant</code> function. We need to tell Cairo the path to the
<code>add_to_waitlist</code> function so it can find it.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}


pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>the <code>add_to_waitlist</code> function using absolute and relative paths</span></p>
<p>The <code>eat_at_restaurant</code> function is part of our library's public API, so we mark
it with the <code>pub</code> keyword. We’ll go into more detail about <code>pub</code> in
the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Exposing Paths with the <code>pub</code> Keyword"</a> section.</p>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>, we
use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>. In Cairo, absolute paths start from the crate
root, which you need to refer to by using the crate name. You can imagine a
filesystem with the same structure: we’d specify the path
<em>/front_of_house/hosting/add_to_waitlist</em> to run the <em>add_to_waitlist</em> program;
using the crate name to start from the crate root is like using a slash (<code>/</code>) to
start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code>, we use a relative path. The path
starts with <code>front_of_house</code>, the name of the module defined at the same level
of the module tree as <code>eat_at_restaurant</code>. Here the filesystem equivalent would
be using the path <em>./front_of_house/hosting/add_to_waitlist</em>. Starting with a
module name means that the path is relative to the current module.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t
compile yet! We get the following error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_07_02 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/Scarb.toml)
error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:28
    crate::front_of_house::hosting::add_to_waitlist();
                           ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:37
    crate::front_of_house::hosting::add_to_waitlist();
                                    ^^^^^^^^^^^^^^^

error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:21
    front_of_house::hosting::add_to_waitlist();
                    ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:30
    front_of_house::hosting::add_to_waitlist();
                             ^^^^^^^^^^^^^^^

error: could not compile `listing_07_02` due to 4 previous errors
error: `scarb` command exited with error

</code></pre>
<p>The error messages say that module <code>hosting</code> and the <code>add_to_waitlist</code> function
are not visible. In other words, we have the correct paths for the <code>hosting</code>
module and the <code>add_to_waitlist</code> function, but Cairo won’t let us use them
because it doesn’t have access to them. In Cairo, all items (functions, methods,
structs, enums, modules, and constants) are private to parent modules by
default. If you want to make an item like a function or struct private, you put
it in a module.</p>
<p>Items in a parent module can’t use the private items inside child modules, but
items in child modules can use the items in their ancestor modules. This is
because child modules wrap and hide their implementation details, but the child
modules can see the context in which they’re defined. To continue with our
metaphor, think of the privacy rules as being like the back office of a
restaurant: what goes on in there is private to restaurant customers, but office
managers can see and do everything in the restaurant they operate.</p>
<p>Cairo chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. However, Cairo does give
you the option to expose inner parts of child modules’ code to outer ancestor
modules by using the <code>pub</code> keyword to make an item public.</p>
<h2 id="exposing-paths-with-the-pub-keyword"><a class="header" href="#exposing-paths-with-the-pub-keyword">Exposing Paths with the <code>pub</code> Keyword</a></h2>
<p>Let’s return to the previous error that told us the <code>hosting</code> module and the
<code>add_to_waitlist</code> function are not visible. We want the <code>eat_at_restaurant</code>
function in the parent module to have access to the <code>add_to_waitlist</code> function
in the child module, so we mark the <code>hosting</code> module with the <code>pub</code> keyword, as
shown in Listing 7-4.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>7-4: Declaring the <code>hosting</code> module as <code>pub</code> to
use it from <code>eat_at_restaurant</code></span></p>
<p>Unfortunately, the code in Listing 7-4 still
results in an error.</p>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting;</code> makes the
module public. With this change, if we can access <code>front_of_house</code>, we can
access <code>hosting</code>. But the contents of <code>hosting</code> are still private; making the
module public doesn’t make its contents public. The <code>pub</code> keyword on a module
only lets code in its ancestor modules refer to it, not access its inner code.
Because modules are containers, there’s not much we can do by only making the
module public; we need to go further and choose to make one or more of the items
within the module public as well.</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code>
keyword before its definition, as in Listing 7-5.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles

    // Relative path
    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles
}
</code></pre>
<p>Declaring the <code>hosting</code> module as <code>pub</code> to use it from
<code>eat_at_restaurant</code></span></p>
<p>Now the code will compile! To see why adding the <code>pub</code> keyword lets us use these
paths in <code>add_to_waitlist</code> with respect to the privacy rules, let’s look at the
absolute and the relative paths.</p>
<p>In the absolute path, we start with the crate root, the root of our crate’s
module tree. The <code>front_of_house</code> module is defined in the crate root. While
<code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is
defined in the same module as <code>front_of_house</code> (that is, <code>front_of_house</code> and
<code>eat_at_restaurant</code> are siblings), we can refer to <code>front_of_house</code> from
<code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can
access the parent module of <code>hosting</code>, so we can access <code>hosting</code> itself.
Finally, the <code>add_to_waitlist</code> function is marked with <code>pub</code> and we can access
its parent module, so this function call works!</p>
<p>In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
<code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module
as <code>eat_at_restaurant</code>, so the relative path starting from the module in which
<code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and
<code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this
function call is valid!</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-03-paths-in-module-tree-1&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;An absolute path is the full path starting from a package root.\nThe absolute path begins with the package name which is specified in the `Scarb.toml` file.\n**Note:** The package and crate are equivalent in Cairo since each package has only one crate corresponding to the `lib.cairo` file.\n&quot;,&quot;id&quot;:&quot;a434804d-90a4-44ec-9e2e-ed72a7494ead&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Package name&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Folder name&quot;,&quot;Module name&quot;],&quot;prompt&quot;:&quot;What is the first word of an absolute path ?\n&quot;}},{&quot;context&quot;:&quot;`b` is not accessible to `main` because the module `bar` is not marked as `pub`.\n&quot;,&quot;id&quot;:&quot;457de43b-c6b5-4b16-a0bb-14102c6d2248&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub mod foo {\n    fn a() { println!(\&quot;a\&quot;); }\n    mod bar {\n        pub fn b() { println!(\&quot;b\&quot;); }\n    }\n}\n\n#[executable]\nfn main() {\n    foo::bar::b();\n}\n&quot;}},{&quot;context&quot;:&quot;It is valid within `foo` to use a relative path to refer to items within `bar`.\n&quot;,&quot;id&quot;:&quot;6404c595-f37f-4131-9e6d-92b0e0ba745f&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;b&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub mod foo {\n    pub mod bar {\n        pub fn b() { println!(\&quot;b\&quot;);  }\n    }\n    pub fn a() { bar::b(); }\n}\n\n#[executable]\nfn main() {\n    foo::a();\n}\n&quot;}}]}"></div>
<h2 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h2>
<p>We can construct relative paths that begin in the parent module, rather than the
current module or the crate root, by using <code>super</code> at the start of the path.
This is like starting a filesystem path with the <code>..</code> syntax. Using <code>super</code>
allows us to reference an item that we know is in the parent module, which can
make rearranging the module tree easier when the module is closely related to
the parent, but the parent might be moved elsewhere in the module tree someday.</p>
<p>Consider the code in Listing 7-6 that models the situation in
which a chef fixes an incorrect order and personally brings it out to the
customer. The function <code>fix_incorrect_order</code> defined in the <code>back_of_house</code>
module calls the function <code>deliver_order</code> defined in the parent module by
specifying the path to <code>deliver_order</code> starting with <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p>Calling a function using a relative path starting with <code>super</code></span></p>
<p>Here you can see directly that you access a parent's module easily using
<code>super</code>, which wasn't the case previously. Note that the <code>back_of_house</code> is kept
private, as external users are not supposed to interact with the back of house
directly.</p>
<h2 id="making-structs-and-enums-public"><a class="header" href="#making-structs-and-enums-public">Making Structs and Enums Public</a></h2>
<p>We can also use <code>pub</code> to designate structs and enums as public, but there are a
few extra details to consider when using <code>pub</code> with structs and enums.</p>
<ul>
<li>If we use <code>pub</code> before a struct definition, we make the struct public, but the
struct’s fields will still be private. We can make each field public or not on
a case-by-case basis.</li>
<li>In contrast, if we make an enum public, all of its variants are then public.
We only need the <code>pub</code> before the <code>enum</code> keyword.</li>
</ul>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that is
our last module system feature: the <code>use</code> keyword. We’ll cover <code>use</code> by itself
first, and then we’ll show how to combine <code>pub</code> and <code>use</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-03-paths-in-module-tree-2&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;While the `Rectangle` structure is public, the fields `width` and `height` are not marked as `pub`.\nTherefore instantiating these fields outside of the `rectangle` module is not allowed. It's also impossible to access the field `width` to print it.\nThis program would compile if the structure were changed to:\n```\npub struct Rectangle {\n    pub width: u64,\n    pub height: u64\n}\n```\n&quot;,&quot;id&quot;:&quot;ba0f75cb-dfa6-461f-906e-e9eeaea192e6&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub mod rectangle {\n    #[derive(Copy, Drop)]\n    pub struct Rectangle {\n        width: u64,\n        height: u64\n    }\n}\n\n#[executable]\nfn main() {\n    let r = rectangle::Rectangle { width: 10, height: 20 };\n    println!(\&quot;{}\&quot;, r.width);\n}\n&quot;}},{&quot;context&quot;:&quot;`entry` uses the path `super::b::c::f`. `entry` is within the module `a`, so `super` refers to the parent module of `a`, which is the root crate.\nThen the child `b` of the root is the outermost module `b`, whose child `c` contains a function `f` that prints \&quot;c2\&quot;.\n&quot;,&quot;id&quot;:&quot;2f0361e2-b5d4-46cd-ac72-dca753a553c8&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;c2&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub mod a {\n    pub mod b {\n        pub fn f() {\n            println!(\&quot;b1\&quot;);\n        }\n\n        pub mod c {\n            pub fn f() {\n                println!(\&quot;c1\&quot;);\n            }\n        }\n    }\n\n    pub fn entry() {\n        super::b::c::f();\n    }\n}\n\npub mod b {\n    pub fn f() {\n        println!(\&quot;b2\&quot;);\n    }\n\n    pub mod c {\n        pub fn f() {\n            println!(\&quot;c2\&quot;);\n        }\n    }\n}\n\n#[executable]\nfn main() {\n    a::entry();\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h1>
<p>Having to write out the paths to call functions can feel inconvenient and
repetitive. Fortunately, there’s a way to simplify this process: we can create a
shortcut to a path with the <code>use</code> keyword once, and then use the shorter name
everywhere else in the scope.</p>
<p>In Listing 7-7, we bring the <code>crate::front_of_house::hosting</code>
module into the scope of the <code>eat_at_restaurant</code> function so we only have to
specify <code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">// section "Defining Modules to Control Scope"

mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist(); // ✅ Shorter path
}
</code></pre>
<p>Bringing a module into scope with <code>use</code></span></p>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in the
filesystem. By adding <code>use crate::front_of_house::hosting;</code> in the crate root,
<code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code> module
had been defined in the crate root.</p>
<p>Note that <code>use</code> only creates the shortcut for the particular scope in which the
<code>use</code> occurs. Listing 7-8 moves the <code>eat_at_restaurant</code> function
into a new child module named <code>customer</code>, which is then a different scope than
the <code>use</code> statement, so the function body won’t compile:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p>statement only applies in the scope it’s in.</span></p>
<p>The compiler error shows that the shortcut no longer applies within the
<code>customer</code> module:</p>
<pre><code class="language-shell">$ scarb build 
   Compiling listing_07_05 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/Scarb.toml)
warn: Unused import: `listing_07_05::hosting`
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:9:28
use crate::front_of_house::hosting;
                           ^^^^^^^

error[E0006]: Identifier not found.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:13:9
        hosting::add_to_waitlist();
        ^^^^^^^

error: could not compile `listing_07_05` due to 1 previous error and 1 warning

</code></pre>
<h2 id="creating-idiomatic-use-paths"><a class="header" href="#creating-idiomatic-use-paths">Creating Idiomatic <code>use</code> Paths</a></h2>
<p>In Listing 7-7, you might have wondered why we specified
<code>use crate::front_of_house::hosting</code> and then called <code>hosting::add_to_waitlist</code>
in <code>eat_at_restaurant</code> rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing
7-9.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p>7-9: Bringing the <code>add_to_waitlist</code> function into scope
with <code>use</code>, which is unidiomatic</span></p>
<p>Although both Listing 7-7 and 7-9
accomplish the same task, Listing 7-7 is the idiomatic way to
bring a function into scope with <code>use</code>. Bringing the function’s parent module
into scope with <code>use</code> means we have to specify the parent module when calling
the function. Specifying the parent module when calling the function makes it
clear that the function isn’t locally defined while still minimizing repetition
of the full path. The code in Listing 7-9 is unclear as to
where <code>add_to_waitlist</code> is defined.</p>
<p>On the other hand, when bringing in structs, enums, traits, and other items with
<code>use</code>, it’s idiomatic to specify the full path. Listing 7-10
shows the idiomatic way to bring the core library’s <code>BitSize</code> trait into the
scope, allowing to call <code>bits</code> method to retrieve the size in bits of a type.</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

#[executable]
fn main() {
    let u8_size: usize = BitSize::&lt;u8&gt;::bits();
    println!("A u8 variable has {} bits", u8_size)
}
</code></pre>
<p>Bringing <code>BitSize</code> trait into scope in an idiomatic way</span></p>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged in the Rust community, and folks have gotten used to reading and writing
Rust code this way. As Cairo shares many idioms with Rust, we follow this
convention as well.</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Cairo doesn’t allow that.</p>
<h3 id="providing-new-names-with-the-as-keyword"><a class="header" href="#providing-new-names-with-the-as-keyword">Providing New Names with the <code>as</code> Keyword</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or <em>alias</em>, for the type. Listing 7-11 shows how you
can rename an import with <code>as</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">use core::array::ArrayTrait as Arr;

#[executable]
fn main() {
    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr
    arr.append(1);
}
</code></pre>
<p>Renaming a trait when it’s brought into scope with the <code>as</code> keyword</span></p>
<p>Here, we brought <code>ArrayTrait</code> into scope with the alias <code>Arr</code>. We can now access
the trait's methods with the <code>Arr</code> identifier.</p>
<h3 id="importing-multiple-items-from-the-same-module"><a class="header" href="#importing-multiple-items-from-the-same-module">Importing Multiple Items from the Same Module</a></h3>
<p>When you want to import multiple items (like functions, structs or enums) from
the same module in Cairo, you can use curly braces <code>{}</code> to list all of the items
that you want to import. This helps to keep your code clean and easy to read by
avoiding a long list of individual <code>use</code> statements.</p>
<p>The general syntax for importing multiple items from the same module is:</p>
<pre><code class="language-cairo">use module::{item1, item2, item3};
</code></pre>
<p>Here is an example where we import three structures from the same module:</p>
<pre><code class="language-cairo">// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.
mod shapes {
    #[derive(Drop)]
    pub struct Square {
        pub side: u32,
    }

    #[derive(Drop)]
    pub struct Circle {
        pub radius: u32,
    }

    #[derive(Drop)]
    pub struct Triangle {
        pub base: u32,
        pub height: u32,
    }
}

// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like
// this:
use shapes::{Circle, Square, Triangle};

// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.
#[executable]
fn main() {
    let sq = Square { side: 5 };
    let cr = Circle { radius: 3 };
    let tr = Triangle { base: 5, height: 2 };
    // ...
}
</code></pre>
<p>7-12: Importing multiple items from the same module</span></p>
<h2 id="re-exporting-names-in-module-files"><a class="header" href="#re-exporting-names-in-module-files">Re-exporting Names in Module Files</a></h2>
<p>When we bring a name into scope with the <code>use</code> keyword, the name available in
the new scope can be imported as if it had been defined in that code’s scope.
This technique is called <em>re-exporting</em> because we’re bringing an item into
scope, but also making that item available for others to bring into their scope,
with the <code>pub</code> keyword.</p>
<p>For example, let's re-export the <code>add_to_waitlist</code> function in the restaurant
example:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p>Making a name available for any code to use from a new scope with
<code>pub use</code></span></p>
<p>Before this change, external code would have to call the <code>add_to_waitlist</code>
function by using the path
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. Now that this
<code>pub use</code> has re-exported the <code>hosting</code> module from the root module, external
code can now use the path <code>restaurant::hosting::add_to_waitlist()</code> instead.</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
<code>pub use</code>, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.</p>
<h2 id="using-external-packages-in-cairo-with-scarb"><a class="header" href="#using-external-packages-in-cairo-with-scarb">Using External Packages in Cairo with Scarb</a></h2>
<p>You might need to use external packages to leverage the functionality provided
by the community. Scarb allows you to use dependencies by cloning packages from
their Git repositories. To use an external package in your project with Scarb,
simply declare the Git repository URL of the dependency you want to add in a
dedicated <code>[dependencies]</code> section in your <em>Scarb.toml</em> configuration file. Note
that the URL might correspond to the main branch, or any specific commit, branch
or tag. For this, you will have to pass an extra <code>rev</code>, <code>branch</code>, or <code>tag</code>
field, respectively. For example, the following code imports the main branch of
<em>alexandria_math</em> crate from <em>alexandria</em> package:</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git" }
</code></pre>
<p>while the following code imports a specific branch (which is deprecated and
should not be used):</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git", branch = "cairo-v2.3.0-rc0" }
</code></pre>
<p>If you want to import multiple packages in your project, you need to create only
one <code>[dependencies]</code> section and list all the desired packages beneath it. You
can also specify development dependencies by declaring a <code>[dev-dependencies]</code>
section.</p>
<p>After that, simply run <code>scarb build</code> to fetch all external dependencies and
compile your package with all the dependencies included.</p>
<p>Note that it is also possible to add dependencies with the <code>scarb add</code> command,
which will automatically edit the <em>Scarb.toml</em> file for you. For development
dependencies, just use the <code>scarb add --dev</code> command.</p>
<p>To remove a dependency, simply remove the corresponding line from your
<em>Scarb.toml</em> file, or use the <code>scarb rm</code> command.</p>
<h2 id="the-glob-operator"><a class="header" href="#the-glob-operator">The Glob Operator</a></h2>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by the <code>*</code> glob operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::num::traits::*;
<span class="boring">}</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>core::num::traits</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program was
defined.</p>
<p>The glob operator is often used when testing to bring everything under test into
the <code>tests</code> module; we’ll talk about that in the <a href="./ch10-01-how-to-write-tests.html">“How to Write
Tests”</a> section in Chapter 10.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-04-bringing-paths-into-scope&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;`use` allows references to items in the used path that are shorter than without `use`, reducing the verbosity of references.\n&quot;,&quot;id&quot;:&quot;446098fa-3695-43e9-8d70-a160188b1c30&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`use` reduces the verbosity of referring to items in the used path&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`use` copies the contents of an item from one module to another&quot;,&quot;`use` indicates to the compiler that an item will be used and should be optimized&quot;,&quot;`use` allows access to items that circumvents normal privacy rules&quot;],&quot;prompt&quot;:&quot;Which of the following statements best describes the function of the `use` keyword?\n&quot;}},{&quot;context&quot;:&quot;There are two paths to `a`: `parent::a` and `a`.\nThere is no path to `b`, because it is private.\nThere are two paths to `c`: `parent::child::c`, and `alias::c`.\n&quot;,&quot;id&quot;:&quot;21fd3314-cf90-4b32-9223-d5d773f484dd&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;4&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Consider this module and `use` statement:\n```\npub mod parent {\n    pub fn a() {}\n\n    fn b() {}\n\n    pub mod child {\n        pub fn c() {}\n    }\n}\n\nuse parent::{a, child as alias};\n\n#[executable]\nfn main() {\n    // here\n}\n```\nInside `main`, what is the total number of paths that can refer to `a`, `b`, or `c` (not including those that use `self` and `super`)?\nWrite your answer as a digit such as 0 or 1.\nFor example, if the only two valid paths were `a` and `parent::b`, then the answer would be 2.\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="separating-modules-into-different-files"><a class="header" href="#separating-modules-into-different-files">Separating Modules into Different Files</a></h1>
<p>So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.</p>
<p>For example, let’s start from the code in Listing 7-7 that had
multiple restaurant modules. We’ll extract modules into files instead of having
all the modules defined in the crate root file. In this case, the crate root
file is <em>src/lib.cairo</em>.</p>
<p>First, we’ll extract the <code>front_of_house</code> module to its own file. Remove the
code inside the curly brackets for the <code>front_of_house</code> module, leaving only the
<code>mod front_of_house;</code> declaration, so that <em>src/lib.cairo</em> contains the code
shown in Listing 7-14. Note that this won’t compile until
we create the <em>src/front_of_house.cairo</em> file.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house;
use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p>7-14: Declaring the <code>front_of_house</code> module whose body will
be in <em>src/front_of_house.cairo</em></span></p>
<p>Next, place the code that was in the curly brackets into a new file named
<em>src/front_of_house.cairo</em>, as shown in Listing 7-15. The
compiler knows to look in this file because it came across the module
declaration in the crate root with the name <code>front_of_house</code>.</p>
<p><span class="filename">Filename: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p>Definitions inside the <code>front_of_house</code> module in
<em>src/front_of_house.cairo</em></span></p>
<p>Note that you only need to load a file using a <code>mod</code> declaration <em>once</em> in your
module tree. Once the compiler knows the file is part of the project (and knows
where in the module tree the code resides because of where you’ve put the <code>mod</code>
statement), other files in your project should refer to the loaded file’s code
using a path to where it was declared, as covered in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Paths for Referring
to an Item in the Module Tree"</a> chapter. In other words, <code>mod</code> is <em>not</em> an
“include” operation that you may have seen in other programming languages.</p>
<p>Next, we’ll extract the <code>hosting</code> module to its own file. The process is a bit
different because <code>hosting</code> is a child module of <code>front_of_house</code>, not of the
root module. We’ll place the file for <code>hosting</code> in a new directory that will be
named for its ancestors in the module tree, in this case <em>src/front_of_house/</em>.</p>
<p>To start moving <code>hosting</code>, we change <em>src/front_of_house.cairo</em> to contain only
the declaration of the <code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting;
</code></pre>
<p>Then we create a <em>src/front_of_house</em> directory and a file <em>hosting.cairo</em> to
contain the definitions made in the <code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house/hosting.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add_to_waitlist() {}
</code></pre>
<p>If we instead put <em>hosting.cairo</em> in the <em>src</em> directory, the compiler would
expect the <em>hosting.cairo</em> code to be in a <code>hosting</code> module declared in the
crate root, and not declared as a child of the <code>front_of_house</code> module. The
compiler’s rules for which files to check for which modules’ code means the
directories and files more closely match the module tree.</p>
<p>We’ve moved each module’s code to a separate file, and the module tree remains
the same. The function calls in <code>eat_at_restaurant</code> will work without any
modification, even though the definitions live in different files. This
technique lets you move modules to new files as they grow in size.</p>
<p>Note that the <code>use crate::front_of_house::hosting;</code> statement in <em>src/lib.cairo</em>
also hasn’t changed, nor does <code>use</code> have any impact on what files are compiled
as part of the crate. The <code>mod</code> keyword declares modules, and Cairo looks in a
file with the same name as the module for the code that goes into that module.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Cairo lets you split a package into multiple crates and a crate into modules so
you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a <code>use</code> statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is <strong>private</strong> by default.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch07-05-separate-modules&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The module tree generated by this directory structure is as follows:\n```\nfoobar\n└── engine\n    └── run\n```\nTherefore the path to run is `foobar::engine::run`.\n&quot;,&quot;id&quot;:&quot;de0b3303-de2c-4fe0-8617-5e73f2b11cdf&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;foobar::engine::run&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Consider this module and `use` statement:\n```markdown\nfoobar\n├── Scarb.toml\n└── src/\n    ├── lib.cairo\n    ├── engine.cairo\n    └── engine/\n        └── analysis.cairo\n```\nThe contents of each file are:\n```\n// engine/analysis.cairo\npub fn run() {}\n\n// engine.cairo\nmod analysis;\npub use analysis::run;\n\n// lib.cairo\npub mod engine;\n```\nSay that another Cairo developer is using the `foobar` crate in a separate package, and they want to call the `run` function. \nWhat is the path they would write?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-and-traits"><a class="header" href="#generic-types-and-traits">Generic Types and Traits</a></h1>
<p>Every programming language has tools for effectively handling the duplication of
concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete
types or other properties. We can express the behavior of generics or how they
relate to other generics without knowing what will be in their place when
compiling and running the code.</p>
<p>Functions can take parameters of some generic type, instead of a concrete type
like <code>u32</code> or <code>bool</code>, in the same way a function takes parameters with unknown
values to run the same code on multiple concrete values. In fact, we’ve already
used generics in <a href="./ch06-01-enums.html#the-option-enum-and-its-advantages">Chapter 6</a>
with <code>Option&lt;T&gt;</code>.</p>
<p>In this chapter, you’ll explore how to define your own types, functions, and
traits with generics.</p>
<p>Generics allow us to replace specific types with a placeholder that represents
multiple types to remove code duplication. Upon compilation, the compiler
creates a new definition for each concrete type that replaces a generic type,
reducing development time for the programmer, but code duplication at compile
level still exists. This may be of importance if you are writing Starknet
contracts and using a generic for multiple types which will cause contract size
to increment.</p>
<p>Then you’ll learn how to use traits to define behavior in a generic way. You can
combine traits with generic types to constrain a generic type to accept only
those types that have a particular behavior, as opposed to just any type.</p>
<h2 id="removing-duplication-by-extracting-a-function"><a class="header" href="#removing-duplication-by-extracting-a-function">Removing Duplication by Extracting a Function</a></h2>
<p>Generics allow us to replace specific types with a placeholder that represents
multiple types to remove code duplication. Before diving into generics syntax,
let’s first look at how to remove duplication in a way that doesn’t involve
generic types by extracting a function that replaces specific values with a
placeholder that represents multiple values. Then we’ll apply the same technique
to extract a generic function! By learning how to identify duplicated code that
can be extracted into a function, you'll start to recognize instances where
generics can be used to reduce duplication.</p>
<p>We begin with a short program that finds the largest number in an array of <code>u8</code>:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>We store an array of <code>u8</code> in the variable <code>number_list</code> and extract the first
number in the array in a variable named <code>largest</code>. We then iterate through all
the numbers in the array, and if the current number is greater than the number
stored in <code>largest</code>, we update the value of <code>largest</code>. However, if the current
number is less than or equal to the largest number seen so far, the variable
doesn’t change, and the code moves on to the next number in the list. After
considering all the numbers in the array, <code>largest</code> should contain the largest
number, which in this case is 100.</p>
<p>We've now been tasked with finding the largest number in two different arrays of
numbers. To do so, we can choose to duplicate the previous code and use the same
logic at two different places in the program, as follows:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let mut number_list: Array&lt;u8&gt; = array![102, 34, 255, 89, 54, 2, 43, 8];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>Although this code works, duplicating code is tedious and error-prone. We also
have to remember to update the code in multiple places when we want to change
it.</p>
<p>To eliminate this duplication, we’ll create an abstraction by defining a
function that operates on any array of <code>u8</code> passed in a parameter. This solution
makes our code clearer and lets us express the concept of finding the largest
number in an array abstractly.</p>
<p>To do that, we extract the code that finds the largest number into a function
named <code>largest</code>. Then we call the function to find the largest number in the two
arrays. We could also use the function on any other array of <code>u8</code> values we
might have in the future.</p>
<pre><code class="language-cairo">fn largest(ref number_list: Array&lt;u8&gt;) -&gt; u8 {
    let mut largest = number_list.pop_front().unwrap();

    for number in number_list.span() {
        if *number &gt; largest {
            largest = *number;
        }
    }

    largest
}

#[executable]
fn main() {
    let mut number_list = array![34, 50, 25, 100, 65];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);

    let mut number_list = array![102, 34, 255, 89, 54, 2, 43, 8];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);
}
</code></pre>
<p>The largest function has a parameter called <code>number_list</code>, passed by reference,
which represents any concrete array of <code>u8</code> values we might pass into the
function. As a result, when we call the function, the code runs on the specific
values that we pass in.</p>
<p>In summary, here are the steps we took to change the code:</p>
<ul>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function and specify the
inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ul>
<p>Next, we’ll use these same steps with generics to reduce code duplication. In
the same way that the function body can operate on an abstract <code>Array&lt;T&gt;</code>
instead of specific <code>u8</code> values, generics allow code to operate on abstract
types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>We use generics to create definitions for item declarations, such as structs and
functions, which we can then use with many different concrete data types. In
Cairo, we can use generics when defining functions, structs, enums, traits,
implementations and methods. In this chapter, we are going to take a look at how
to effectively use generic types with all of them.</p>
<p>Generics allow us to write reusable code that works with many types, thus
avoiding code duplication, while enhancing code maintainability.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>Making a function generic means it can operate on different types, avoiding the
need for multiple, type-specific implementations. This leads to significant code
reduction and increases the flexibility of the code.</p>
<p>When defining a function that uses generics, we place the generics in the
function signature, where we would usually specify the data types of the
parameter and return value. For example, imagine we want to create a function
which given two <code>Array</code> of items, will return the largest one. If we need to
perform this operation for lists of different types, then we would have to
redefine the function each time. Luckily we can implement the function once
using generics and move on to other tasks.</p>
<pre><code class="language-cairo">// Specify generic type T between the angulars
fn largest_list&lt;T&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}

#[executable]
fn main() {
    let mut l1 = array![1, 2];
    let mut l2 = array![3, 4, 5];

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}
</code></pre>
<p>The <code>largest_list</code> function compares two lists of the same type and returns the
one with more elements and drops the other. If you compile the previous code,
you will notice that it will fail with an error saying that there are no traits
defined for dropping an array of a generic type. This happens because the
compiler has no way to guarantee that an <code>Array&lt;T&gt;</code> is droppable when executing
the <code>main</code> function. In order to drop an array of <code>T</code>, the compiler must first
know how to drop <code>T</code>. This can be fixed by specifying in the function signature
of <code>largest_list</code> that <code>T</code> must implement the <code>Drop</code> trait. The correct function
definition of <code>largest_list</code> is as follows:</p>
<pre><code class="language-cairo">fn largest_list&lt;T, impl TDrop: Drop&lt;T&gt;&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}
</code></pre>
<p>The new <code>largest_list</code> function includes in its definition the requirement that
whatever generic type is placed there, it must be droppable. This is what we
call <em>trait bounds</em>. The <code>main</code> function remains unchanged, the compiler is
smart enough to deduce which concrete type is being used and if it implements
the <code>Drop</code> trait.</p>
<h3 id="constraints-for-generic-types"><a class="header" href="#constraints-for-generic-types">Constraints for Generic Types</a></h3>
<p>When defining generic types, it is useful to have information about them.
Knowing which traits a generic type implements allows us to use it more
effectively in a function's logic at the cost of constraining the generic types
that can be used with the function. We saw an example of this previously by
adding the <code>TDrop</code> implementation as part of the generic arguments of
<code>largest_list</code>. While <code>TDrop</code> was added to satisfy the compiler's requirements,
we can also add constraints to benefit our function logic.</p>
<p>Imagine we have a list of elements of some generic type <code>T</code>, and we want to find
the smallest element among them. Initially, we know that for an element of type
<code>T</code> to be comparable, it must implement the <code>PartialOrd</code> trait. The resulting
function would be:</p>
<pre><code class="language-cairo">// Given a list of T get the smallest one
// The PartialOrd trait implements comparison operations for T
fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0];

    // The index we will use to move through the list
    let mut index = 1;

    // Iterate through the whole list storing the smallest
    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}

#[executable]
fn main() {
    let list: Array&lt;u8&gt; = array![5, 3, 10];

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert!(s == 3);
}
</code></pre>
<p>The <code>smallest_element</code> function uses a generic type <code>T</code> that implements the
<code>PartialOrd</code> trait, takes a snapshot of an <code>Array&lt;T&gt;</code> as a parameter and returns
a copy of the smallest element. Because the parameter is of type <code>@Array&lt;T&gt;</code>, we
no longer need to drop it at the end of the execution and so we are not required
to implement the <code>Drop</code> trait for <code>T</code> as well. Why does it not compile then?</p>
<p>When indexing on <code>list</code>, the value results in a snap of the indexed element, and
unless <code>PartialOrd</code> is implemented for <code>@T</code> we need to desnap the element using
<code>*</code>. The <code>*</code> operation requires a copy from <code>@T</code> to <code>T</code>, which means that <code>T</code>
needs to implement the <code>Copy</code> trait. After copying an element of type <code>@T</code> to
<code>T</code>, there are now variables with type <code>T</code> that need to be dropped, requiring
<code>T</code> to implement the <code>Drop</code> trait as well. We must then add both <code>Drop</code> and
<code>Copy</code> traits implementation for the function to be correct. After updating the
<code>smallest_element</code> function the resulting code would be:</p>
<pre><code class="language-cairo">fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;, impl TCopy: Copy&lt;T&gt;, impl TDrop: Drop&lt;T&gt;&gt;(
    list: @Array&lt;T&gt;,
) -&gt; T {
    let mut smallest = *list[0];
    let mut index = 1;

    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}
</code></pre>
<h3 id="anonymous-generic-implementation-parameter--operator"><a class="header" href="#anonymous-generic-implementation-parameter--operator">Anonymous Generic Implementation Parameter (<code>+</code> Operator)</a></h3>
<p>Until now, we have always specified a name for each implementation of the
required generic trait: <code>TPartialOrd</code> for <code>PartialOrd&lt;T&gt;</code>, <code>TDrop</code> for
<code>Drop&lt;T&gt;</code>, and <code>TCopy</code> for <code>Copy&lt;T&gt;</code>.</p>
<p>However, most of the time, we don't use the implementation in the function body;
we only use it as a constraint. In these cases, we can use the <code>+</code> operator to
specify that the generic type must implement a trait without naming the
implementation. This is referred to as an <em>anonymous generic implementation
parameter</em>.</p>
<p>For example, <code>+PartialOrd&lt;T&gt;</code> is equivalent to
<code>impl TPartialOrd: PartialOrd&lt;T&gt;</code>.</p>
<p>We can rewrite the <code>smallest_element</code> function signature as follows:</p>
<pre><code class="language-cairo">fn smallest_element&lt;T, +PartialOrd&lt;T&gt;, +Copy&lt;T&gt;, +Drop&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
<span class="boring">    let mut smallest = *list[0];
</span><span class="boring">    for element in list {
</span><span class="boring">        if *element &lt; smallest {
</span><span class="boring">            smallest = *element;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    smallest
</span><span class="boring">}
</span></code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>We can also define structs to use a generic type parameter for one or more
fields using the <code>&lt;&gt;</code> syntax, similar to function definitions. First, we declare
the name of the type parameter inside the angle brackets just after the name of
the struct. Then we use the generic type in the struct definition where we would
otherwise specify concrete data types. The next code example shows the
definition <code>Wallet&lt;T&gt;</code> which has a <code>balance</code> field of type <code>T</code>.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>The above code derives the <code>Drop</code> trait for the <code>Wallet</code> type automatically. It
is equivalent to writing the following code:</p>
<pre><code class="language-cairo">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, +Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;T&gt;&gt;;

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>We avoid using the <code>derive</code> macro for <code>Drop</code> implementation of <code>Wallet</code> and
instead define our own <code>WalletDrop</code> implementation. Notice that we must define,
just like functions, an additional generic type for <code>WalletDrop</code> saying that <code>T</code>
implements the <code>Drop</code> trait as well. We are basically saying that the struct
<code>Wallet&lt;T&gt;</code> is droppable as long as <code>T</code> is also droppable.</p>
<p>Finally, if we want to add a field to <code>Wallet</code> representing its address and we
want that field to be different than <code>T</code> but generic as well, we can simply add
another generic type between the <code>&lt;&gt;</code>:</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3, address: 14 };
}
</code></pre>
<p>We add to the <code>Wallet</code> struct definition a new generic type <code>U</code> and then assign
this type to the new field member <code>address</code>. Notice that the <code>derive</code> attribute
for the <code>Drop</code> trait works for <code>U</code> as well.</p>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>As we did with structs, we can define enums to hold generic data types in their
variants. For example the <code>Option&lt;T&gt;</code> enum provided by the Cairo core library:</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p>The <code>Option&lt;T&gt;</code> enum is generic over a type <code>T</code> and has two variants: <code>Some</code>,
which holds one value of type <code>T</code> and <code>None</code> that doesn't hold any value. By
using the <code>Option&lt;T&gt;</code> enum, it is possible for us to express the abstract
concept of an optional value and because the value has a generic type <code>T</code> we can
use this abstraction with any type.</p>
<p>Enums can use multiple generic types as well, like the definition of the
<code>Result&lt;T, E&gt;</code> enum that the core library provides:</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum has two generic types, <code>T</code> and <code>E</code>, and two variants:
<code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (by returning a value of type <code>T</code>) or fail
(by returning a value of type <code>E</code>).</p>
<h2 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h2>
<p>We can implement methods on structs and enums, and use the generic types in
their definitions, too. Using our previous definition of <code>Wallet&lt;T&gt;</code> struct, we
define a <code>balance</code> method for it:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

#[executable]
fn main() {
    let w = Wallet { balance: 50 };
    assert!(w.balance() == 50);
}
</code></pre>
<p>We first define <code>WalletTrait&lt;T&gt;</code> trait using a generic type <code>T</code> which defines a
method that returns the value of the field <code>balance</code> from <code>Wallet</code>. Then we give
an implementation for the trait in <code>WalletImpl&lt;T&gt;</code>. Note that you need to
include a generic type in both definitions of the trait and the implementation.</p>
<p>We can also specify constraints on generic types when defining methods on the
type. We could, for example, implement methods only for <code>Wallet&lt;u128&gt;</code> instances
rather than <code>Wallet&lt;T&gt;</code>. In the code example, we define an implementation for
wallets which have a concrete type of <code>u128</code> for the <code>balance</code> field.</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

/// Generic trait for wallets
trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

/// Trait for wallets of type u128
trait WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128) {
        self.balance += value;
    }
}

#[executable]
fn main() {
    let mut w = Wallet { balance: 50 };
    assert!(w.balance() == 50);

    w.receive(100);
    assert!(w.balance() == 150);
}
</code></pre>
<p>The new method <code>receive</code> increments the size of <code>balance</code> of any instance of a
<code>Wallet&lt;u128&gt;</code>. Notice that we changed the <code>main</code> function making <code>w</code> a mutable
variable in order for it to be able to update its balance. If we were to change
the initialization of <code>w</code> by changing the type of <code>balance</code> the previous code
wouldn't compile.</p>
<p>Cairo allows us to define generic methods inside generic traits as well. Using
the past implementation from <code>Wallet&lt;U, V&gt;</code> we are going to define a trait that
picks two wallets of different generic types and creates a new one with a
generic type of each. First, let's rewrite the struct definition:</p>
<pre><code class="language-cairo noplayground">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}
</code></pre>
<p>Next, we are going to naively define the mixup trait and implementation:</p>
<pre><code class="language-cairo noplayground">// This does not compile!
trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, U1&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}

</code></pre>
<p>We are creating a trait <code>WalletMixTrait&lt;T1, U1&gt;</code> with the <code>mixup&lt;T2, U2&gt;</code> method
which given an instance of <code>Wallet&lt;T1, U1&gt;</code> and <code>Wallet&lt;T2, U2&gt;</code> creates a new
<code>Wallet&lt;T1, U2&gt;</code>. As <code>mixup</code> signature specifies, both <code>self</code> and <code>other</code> are
getting dropped at the end of the function, which is why this code does not
compile. If you have been following from the start until now you would know that
we must add a requirement for all the generic types specifying that they will
implement the <code>Drop</code> trait for the compiler to know how to drop instances of
<code>Wallet&lt;T, U&gt;</code>. The updated implementation is as follows:</p>
<pre><code class="language-cairo">trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, +Drop&lt;T1&gt;, U1, +Drop&lt;U1&gt;&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}
</code></pre>
<p>We add the requirements for <code>T1</code> and <code>U1</code> to be droppable on <code>WalletMixImpl</code>
declaration. Then we do the same for <code>T2</code> and <code>U2</code>, this time as part of <code>mixup</code>
signature. We can now try the <code>mixup</code> function:</p>
<pre><code class="language-cairo noplayground">#[executable]
fn main() {
    let w1: Wallet&lt;bool, u128&gt; = Wallet { balance: true, address: 10 };
    let w2: Wallet&lt;felt252, u8&gt; = Wallet { balance: 32, address: 100 };

    let w3 = w1.mixup(w2);

    assert!(w3.balance);
    assert!(w3.address == 100);
}
</code></pre>
<p>We first create two instances: one of <code>Wallet&lt;bool, u128&gt;</code> and the other of
<code>Wallet&lt;felt252, u8&gt;</code>. Then, we call <code>mixup</code> and create a new <code>Wallet&lt;bool, u8&gt;</code>
instance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-in-cairo"><a class="header" href="#traits-in-cairo">Traits in Cairo</a></h1>
<p>A trait defines a set of methods that can be implemented by a type. These
methods can be called on instances of the type when this trait is implemented. A
trait combined with a generic type defines functionality a particular type has
and can share with other types. We can use traits to define shared behavior in
an abstract way. We can use <em>trait bounds</em> to specify that a generic type can be
any type that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called interfaces in other
languages, although with some differences.</p>
</blockquote>
<p>While traits can be written to not accept generic types, they are most useful
when used with generic types. We already covered generics in the <a href="./ch08-01-generic-data-types.html">previous
chapter</a>, and we will use them in this chapter to demonstrate how
traits can be used to define shared behavior for generic types.</p>
<h2 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a Trait</a></h2>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to define
a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have a struct <code>NewsArticle</code> that holds a news story in
a particular location. We can define a trait <code>Summary</code> that describes the
behavior of something that can summarize the <code>NewsArticle</code> type.</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[derive(Drop, Clone)]
</span><span class="boring">struct NewsArticle {
</span><span class="boring">    headline: ByteArray,
</span><span class="boring">    location: ByteArray,
</span><span class="boring">    author: ByteArray,
</span><span class="boring">    content: ByteArray,
</span><span class="boring">}
</span><span class="boring">
</span>pub trait Summary {
    fn summarize(self: @NewsArticle) -&gt; ByteArray;
}
<span class="boring">
</span><span class="boring">impl NewsArticleSummary of Summary {
</span><span class="boring">    fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">        format!("{:?} by {:?} ({:?})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>8-1: A <code>Summary</code> trait that consists of the behavior
provided by a <code>summarize</code> method</span></p>
<p>In Listing 8-1, we declare a trait using the <code>trait</code>
keyword and then the trait’s name, which is <code>Summary</code> in this case. We’ve also
declared the trait as <code>pub</code> so that crates depending on this crate can make use
of this trait too, as we’ll see in a few examples.</p>
<p>Inside the curly brackets, we declare the method signatures that describe the
behaviors of the types that implement this trait, which in this case is
<code>fn summarize(self: @NewsArticle) -&gt; ByteArray;</code>. After the method signature,
instead of providing an implementation within curly brackets, we use a
semicolon.</p>
<blockquote>
<p>Note: the <code>ByteArray</code> type is the type used to represent strings in Cairo.</p>
</blockquote>
<p>As the trait is not generic, the <code>self</code> parameter is not generic either and is
of type <code>@NewsArticle</code>. This means that the <code>summarize</code> method can only be
called on instances of <code>NewsArticle</code>.</p>
<p>Now, consider that we want to make a media aggregator library crate named
<em>aggregator</em> that can display summaries of data that might be stored in a
<code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we need a summary from each type,
and we’ll request that summary by calling a summarize method on an instance of
that type. By defining the <code>Summary</code> trait on generic type <code>T</code>, we can implement
the <code>summarize</code> method on any type we want to be able to summarize.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>8-2: A <code>Summary</code> trait that consists of the behavior
provided by a <code>summarize</code> method for a generic type</span></p>
<p>Each type implementing this trait must provide its own custom behavior for the
body of the method. The compiler will enforce that any type that implements the
<code>Summary</code> trait will have the method <code>summarize</code> defined with this signature
exactly.</p>
<p>A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.</p>
<h2 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></h2>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods,
we can implement it on the types in our media aggregator. The following code
shows an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that
uses the headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the tweet, assuming that tweet content is already
limited to 280 characters.</p>
<pre><code class="language-cairo noplayground"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
        fn summarize(self: @NewsArticle) -&gt; ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize(self: @Tweet) -&gt; ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    }; // Tweet instantiation
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">    println!("New tweet! {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Implementation of the <code>Summary</code> trait on <code>NewsArticle</code> and <code>Tweet</code></span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put a name for the implementation, then use
the <code>of</code> keyword, and then specify the name of the trait we are writing the
implementation for. If the implementation is for a generic type, we place the
generic type name in the angle brackets after the trait name.</p>
<p>Note that for the trait method to be accessible, there must be an implementation
of that trait visible from the scope where the method is called. If the trait is
<code>pub</code> and the implementation is not, and the implementation is not visible in
the scope where the trait method is called, this will cause a compilation error.</p>
<p>Within the <code>impl</code> block, we put the method signatures that the trait definition
has defined. Instead of adding a semicolon after each signature, we use curly
brackets and fill in the method body with the specific behavior that we want the
methods of the trait to have for the particular type.</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and
<code>Tweet</code>, users of the crate can call the trait methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods. The only
difference is that the user must bring the trait into scope as well as the
types. Here’s an example of how a crate could use our <code>aggregator</code> crate:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
</span><span class="boring">        fn summarize(self: @NewsArticle) -&gt; ByteArray {
</span><span class="boring">            format!("{} by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary, Tweet};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints the following:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_15_traits
New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
New tweet! EliBenSasson: Crypto is full of short-term maximizing projects. 
 @Starknet and @StarkWareLtd are about long-term vision maximization.


</code></pre>
<p>Other crates that depend on the <em>aggregator</em> crate can also bring the <code>Summary</code>
trait into scope to implement <code>Summary</code> on their own types.</p>
<h2 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h2>
<p>Sometimes it’s useful to have default behavior for some or all of the methods in
a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.</p>
<p>In Listing 8-5 we specify a default string for the <code>summarize</code>
method of the <code>Summary</code> trait instead of only defining the method signature, as
we did in Listing 8-2.</p>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray {
            "(Read more...)"
        }
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let news = NewsArticle {
</span><span class="boring">        headline: "Cairo has become the most popular language for developers",
</span><span class="boring">        location: "Worldwide",
</span><span class="boring">        author: "Cairo Digger",
</span><span class="boring">        content: "Cairo is a new programming language for zero-knowledge proofs",
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("New article available! {}", news.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Defining a <code>Summary</code> trait with a default implementation of the <code>summarize</code>
method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code>, we
specify an empty <code>impl</code> block with
<code>impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}</code>.</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code>
directly, we’ve provided a default implementation and specified that
<code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call the
<code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(self: @T) -&gt; ByteArray {
</span><span class="boring">            "(Read more...)"
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct NewsArticle {
</span><span class="boring">        pub headline: ByteArray,
</span><span class="boring">        pub location: ByteArray,
</span><span class="boring">        pub author: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("{}: {}", self.username, self.content)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{NewsArticle, Summary};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation doesn’t require us to change anything about
the previous implementation of <code>Summary</code> on <code>Tweet</code>. The reason is that the
syntax for overriding a default implementation is the same as the syntax for
implementing a trait method that doesn’t have a default implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify a
small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, and then define a
<code>summarize</code> method that has a default implementation that calls the
<code>summarize_author</code> method:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span>    pub trait Summary&lt;T&gt; {
        fn summarize(
            self: @T,
        ) -&gt; ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -&gt; ByteArray;
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code> when
we implement the trait on a type:</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span>    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize_author(self: @Tweet) -&gt; ByteArray {
            format!("@{}", self.username)
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">use aggregator::{Summary, Tweet};
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let tweet = Tweet {
</span><span class="boring">        username: "EliBenSasson",
</span><span class="boring">        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
</span><span class="boring">        reply: false,
</span><span class="boring">        retweet: false,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("1 new tweet: {}", tweet.summarize());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code.</p>
<pre><code class="language-cairo"><span class="boring">mod aggregator {
</span><span class="boring">    pub trait Summary&lt;T&gt; {
</span><span class="boring">        fn summarize(
</span><span class="boring">            self: @T,
</span><span class="boring">        ) -&gt; ByteArray {
</span><span class="boring">            format!("(Read more from {}...)", Self::summarize_author(self))
</span><span class="boring">        }
</span><span class="boring">        fn summarize_author(self: @T) -&gt; ByteArray;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop)]
</span><span class="boring">    pub struct Tweet {
</span><span class="boring">        pub username: ByteArray,
</span><span class="boring">        pub content: ByteArray,
</span><span class="boring">        pub reply: bool,
</span><span class="boring">        pub retweet: bool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TweetSummary of Summary&lt;Tweet&gt; {
</span><span class="boring">        fn summarize_author(self: @Tweet) -&gt; ByteArray {
</span><span class="boring">            format!("@{}", self.username)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use aggregator::{Summary, Tweet};

#[executable]
fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This code prints <code>1 new tweet: (Read more from @EliBenSasson...)</code>.</p>
<p>Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.</p>
<!-- TODO: NOT AVAILABLE IN CAIRO FOR NOW move traits as parameters here -->
<!-- ## Traits as parameters

Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types. We'll use the
`Summary` trait we implemented on the `NewsArticle` and `Tweet` types to define a `notify` function that calls the `summarize` method
on its `item` parameter, which is of some type that implements the `Summary` trait. To do this, we use the `impl Trait` syntax.

Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`. -->
<!-- TODO NOT AVAILABLE IN CAIRO FOR NOW Using trait bounds to conditionally implement methods -->
<h2 id="managing-and-using-external-trait"><a class="header" href="#managing-and-using-external-trait">Managing and Using External Trait</a></h2>
<p>To use traits methods, you need to make sure the correct
traits/implementation(s) are imported. In some cases you might need to import
not only the trait but also the implementation if they are declared in separate
modules. If <code>CircleGeometry</code> implementation was in a separate module/file named
<em>circle</em>, then to define <code>boundary</code> method on <code>Circle</code> struct, we'd need to
import <code>ShapeGeometry</code> trait in the <em>circle</em> module.</p>
<p>If the code were to be organized into modules like in Listing
8-6 where the implementation of a trait is defined in a
different module than the trait itself, explicitly importing the relevant trait
or implementation would be required.</p>
<pre><code class="language-cairo noplayground">// Here T is an alias type which will be provided during implementation
pub trait ShapeGeometry&lt;T&gt; {
    fn boundary(self: T) -&gt; u64;
    fn area(self: T) -&gt; u64;
}

mod rectangle {
    // Importing ShapeGeometry is required to implement this trait for Rectangle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Rectangle {
        pub height: u64,
        pub width: u64,
    }

    // Implementation RectangleGeometry passes in &lt;Rectangle&gt;
    // to implement the trait for that type
    impl RectangleGeometry of ShapeGeometry&lt;Rectangle&gt; {
        fn boundary(self: Rectangle) -&gt; u64 {
            2 * (self.height + self.width)
        }
        fn area(self: Rectangle) -&gt; u64 {
            self.height * self.width
        }
    }
}

mod circle {
    // Importing ShapeGeometry is required to implement this trait for Circle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Circle {
        pub radius: u64,
    }

    // Implementation CircleGeometry passes in &lt;Circle&gt;
    // to implement the imported trait for that type
    impl CircleGeometry of ShapeGeometry&lt;Circle&gt; {
        fn boundary(self: Circle) -&gt; u64 {
            (2 * 314 * self.radius) / 100
        }
        fn area(self: Circle) -&gt; u64 {
            (314 * self.radius * self.radius) / 100
        }
    }
}
use circle::Circle;
use rectangle::Rectangle;

#[executable]
fn main() {
    let rect = Rectangle { height: 5, width: 7 };
    println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
    println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24

    let circ = Circle { radius: 5 };
    println!("Circle area: {}", ShapeGeometry::area(circ)); //78
    println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
}
</code></pre>
<p>8-6: Implementing an external trait</span></p>
<p>Note that in Listing 8-6, <code>CircleGeometry</code> and
<code>RectangleGeometry</code> implementations don't need to be declared as <code>pub</code>. Indeed,
<code>ShapeGeometry</code> trait, which is public, is used to print the result in the
<code>main</code> function. The compiler will find the appropriate implementation for the
<code>ShapeGeometry</code> public trait, regardless of the implementation visibility.</p>
<h2 id="impl-aliases"><a class="header" href="#impl-aliases">Impl Aliases</a></h2>
<p>Implementations can be aliased when imported. This is most useful when you want
to instantiate generic implementations with concrete types. For example, let's
say we define a trait <code>Two</code> that is used to return the value <code>2</code> for a type <code>T</code>.
We can write a trivial generic implementation of <code>Two</code> for all types that
implement the <code>One</code> trait, simply by adding twice the value of <code>one</code> and
returning it. However, in our public API, we may only want to expose the <code>Two</code>
implementation for the <code>u8</code> and <code>u128</code> types.</p>
<pre><code class="language-cairo noplayground">trait Two&lt;T&gt; {
    fn two() -&gt; T;
}

mod one_based {
    pub impl TwoImpl&lt;
        T, +Copy&lt;T&gt;, +Drop&lt;T&gt;, +Add&lt;T&gt;, impl One: core::num::traits::One&lt;T&gt;,
    &gt; of super::Two&lt;T&gt; {
        fn two() -&gt; T {
            One::one() + One::one()
        }
    }
}

pub impl U8Two = one_based::TwoImpl&lt;u8&gt;;
pub impl U128Two = one_based::TwoImpl&lt;u128&gt;;
</code></pre>
<p>Using impl aliases to instantiate generic impls with concrete types</span></p>
<p>We can define the generic implementation in a private module, use an impl alias
to instantiate the generic implementation for these two concrete types, and make
these two implementations public, while keeping the generic implementation
private and unexposed. This way, we can avoid code duplication using the generic
implementation, while keeping the public API clean and simple.</p>
<h2 id="negative-impls"><a class="header" href="#negative-impls">Negative Impls</a></h2>
<blockquote>
<p>Note: This is still an experimental feature and can only be used if
<code>experimental-features = ["negative_impls"]</code> is enabled in your <em>Scarb.toml</em>
file, under the <code>[package]</code> section.</p>
</blockquote>
<p>Negative implementations, also known as negative traits or negative bounds, are
a mechanism that allows you to express that a type does not implement a certain
trait when defining the implementation of a trait over a generic type. Negative
impls enable you to write implementations that are applicable only when another
implementation does not exist in the current scope.</p>
<p>For example, let's say we have a trait <code>Producer</code> and a trait <code>Consumer</code>, and we
want to define a generic behavior where all types implement the <code>Consumer</code> trait
by default. However, we want to ensure that no type can be both a <code>Consumer</code> and
a <code>Producer</code>. We can use negative impls to express this restriction.</p>
<p>In Listing 8-8, we define a <code>ProducerType</code> that implements
the <code>Producer</code> trait, and two other types, <code>AnotherType</code> and <code>AThirdType</code>, which
do not implement the <code>Producer</code> trait. We then use negative impls to create a
default implementation of the <code>Consumer</code> trait for all types that do not
implement the <code>Producer</code> trait.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct ProducerType {}

#[derive(Drop, Debug)]
struct AnotherType {}

#[derive(Drop, Debug)]
struct AThirdType {}

trait Producer&lt;T&gt; {
    fn produce(self: T) -&gt; u32;
}

trait Consumer&lt;T&gt; {
    fn consume(self: T, input: u32);
}

impl ProducerImpl of Producer&lt;ProducerType&gt; {
    fn produce(self: ProducerType) -&gt; u32 {
        42
    }
}

impl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {
    fn consume(self: T, input: u32) {
        println!("{:?} consumed value: {}", self, input);
    }
}

#[executable]
fn main() {
    let producer = ProducerType {};
    let another_type = AnotherType {};
    let third_type = AThirdType {};
    let production = producer.produce();

    // producer.consume(production); Invalid: ProducerType does not implement Consumer
    another_type.consume(production);
    third_type.consume(production);
}
</code></pre>
<p>8-8: Using negative impls to enforce that a type cannot
implement both <code>Producer</code> and <code>Consumer</code> traits simultaneously</span></p>
<p>In the <code>main</code> function, we create instances of <code>ProducerType</code>, <code>AnotherType</code>,
and <code>AThirdType</code>. We then call the <code>produce</code> method on the <code>producer</code> instance
and pass the result to the <code>consume</code> method on the <code>another_type</code> and
<code>third_type</code> instances. Finally, we try to call the <code>consume</code> method on the
<code>producer</code> instance, which results in a compile-time error because
<code>ProducerType</code> does not implement the <code>Consumer</code> trait.</p>
<h2 id="constraint-traits-on-associated-items"><a class="header" href="#constraint-traits-on-associated-items">Constraint traits on associated items</a></h2>
<blockquote>
<p>Currently, associated items are considered an experimental feature. In order
to use them, you need to add the following to your <code>Scarb.toml</code> under the
<code>[package]</code> section:
<code>experimental-features = ["associated_item_constraints"]</code>.</p>
</blockquote>
<p>In some cases, you may want to constrain the <a href="./ch12-10-associated-items.html">associated items</a> of a trait based
on the type of the generic parameter. You can do this using the
<code>[AssociatedItem: ConstrainedValue]</code> syntax after a trait bound.</p>
<p>Let's say you want to implement an <code>extend</code> method for collections. This method
takes an iterator and add its elements to the collection. To ensure type safety,
we want the iterator's elements to match the collection's element type. We can
achieve this by constraining the <code>Iterator::Item</code> associated type to match the
collection's type.</p>
<p>In Listing 8-9, we implement this by defining
a trait <code>Extend&lt;T, A&gt;</code> and use <code>[Item: A]</code> as a constraint on the <code>extend</code>
function's trait bound. Additionally, we use the <code>Destruct</code> trait to ensure that
the iterator is consumed, and show an example implementation for
<code>Extend&lt;Array&lt;T&gt;, T&gt;</code>.</p>
<pre><code class="language-cairo">trait Extend&lt;T, A&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: A], +Destruct&lt;I&gt;&gt;(ref self: T, iterator: I);
}

impl ArrayExtend&lt;T, +Drop&lt;T&gt;&gt; of Extend&lt;Array&lt;T&gt;, T&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: T], +Destruct&lt;I&gt;&gt;(ref self: Array&lt;T&gt;, iterator: I) {
        for item in iterator {
            self.append(item);
        }
    }
}
</code></pre>
<p>8-9: Using associated items constraints to
ensure that a type matches the associated type of another type</span></p>
<h2 id="typeequal-trait-for-type-equality-constraints"><a class="header" href="#typeequal-trait-for-type-equality-constraints"><code>TypeEqual</code> Trait for type equality constraints</a></h2>
<p>The <code>TypeEqual</code> trait from the <code>core::metaprogramming</code> module lets you create
constraints based on type equality. In most of the cases, you don't need
<code>+TypeEqual</code> and you can achieve the same using only generic arguments and
associated type constraints, but <code>TypeEqual</code> can be useful in some advanced
scenarios.</p>
<p>The first use case is implementing a trait for all types that match certain
conditions, except for specific types. We do this using a negative
implementation on the <code>TypeEqual</code> trait.</p>
<p>In Listing 8-10, we create a <code>SafeDefault</code>
trait and implement it for any type <code>T</code> that implements <code>Default</code>. However, we
exclude the <code>SensitiveData</code> type using <code>-TypeEqual&lt;T, SensitiveData&gt;</code>.</p>
<pre><code class="language-cairo">trait SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T;
}

#[derive(Drop, Default)]
struct SensitiveData {
    secret: felt252,
}

// Implement SafeDefault for all types EXCEPT SensitiveData
impl SafeDefaultImpl&lt;
    T, +Default&lt;T&gt;, -core::metaprogramming::TypeEqual&lt;T, SensitiveData&gt;,
&gt; of SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T {
        Default::default()
    }
}

#[executable]
fn main() {
    let _safe: u8 = SafeDefault::safe_default();
    let _unsafe: SensitiveData = Default::default(); // Allowed
    // This would cause a compile error:
// let _dangerous: SensitiveData = SafeDefault::safe_default();
}
</code></pre>
<p>8-10: Using the <code>TypeEqual</code> trait to exclude
a specific type from an implementation</span></p>
<p>The second use case is ensuring that two types are equal, particularly useful
when working with <a href="./ch12-10-associated-items.html#associated-types">associated types</a>.</p>
<p>In Listing 8-11, we show this with a <code>StateMachine</code>
trait that has an associated type <code>State</code>. We create two types, <code>TA</code> and <code>TB</code>,
both using <code>StateCounter</code> as their <code>State</code>. Then we implement a <code>combine</code>
function that works only when both state machines have the same state type,
using the bound <code>TypeEqual&lt;A::State, B::State&gt;</code>.</p>
<pre><code class="language-cairo">trait StateMachine {
    type State;
    fn transition(ref state: Self::State);
}

#[derive(Copy, Drop)]
struct StateCounter {
    counter: u8,
}

impl TA of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter += 1;
    }
}

impl TB of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter *= 2;
    }
}

fn combine&lt;
    impl A: StateMachine,
    impl B: StateMachine,
    +core::metaprogramming::TypeEqual&lt;A::State, B::State&gt;,
&gt;(
    ref self: A::State,
) {
    A::transition(ref self);
    B::transition(ref self);
}

#[executable]
fn main() {
    let mut initial = StateCounter { counter: 0 };
    combine::&lt;TA, TB&gt;(ref initial);
}
</code></pre>
<p>8-11: Using the <code>TypeEqual</code> trait to ensure two types
have matching associated types</span></p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch08-02-traits&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The `MakeNoise` trait is not implemented for the `Cat` type.\nTo make use of the default implementation for `Cat`, we would need to add `impl MakeNoiseImpl of MakeNoise&lt;Cat&gt; {}`.\nThe empty implementation block `{}` tells Cairo to use the default implementation from the trait\n&quot;,&quot;id&quot;:&quot;4120c3cf-a86a-4d30-b307-4a50b2e9d627&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;pub trait MakeNoise&lt;T&gt; {\n    fn make_noise(self: @T) {\n        println!(\&quot;noise\&quot;);\n    }\n}\n\npub mod dog {\n    use super::MakeNoise;\n\n    #[derive(Drop)]\n    pub struct Dog {}\n\n    impl Barking of MakeNoise&lt;Dog&gt; {\n        fn make_noise(self: @Dog) {\n            println!(\&quot;bark\&quot;);\n        }\n    }\n}\n\npub mod cat {\n    use super::MakeNoise;\n\n    #[derive(Drop)]\n    pub struct Cat {}\n}\n\n#[executable]\nfn main() {\n    let dog = dog::Dog {};\n    dog.make_noise();\n\n    let cat = cat::Cat {};\n    cat.make_noise();\n}\n&quot;}},{&quot;context&quot;:&quot;The `draw` method is a method implemented for the `Shape` type, so it should be called on the `my_shape` object.\nIt is also possible to call the method on the snapshot of the object by using the `@` operator, for example `Drawable::draw(@my_shape)`.\n&quot;,&quot;id&quot;:&quot;af789385-e4e4-4405-8fb7-049b9a51bc3b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`my_shape.draw();`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`draw(my_shape);`&quot;,&quot;`draw(@my_shape);`&quot;],&quot;prompt&quot;:&quot;What line of code is correct to draw the shape `my_shape` in the `main` function ?\n```\n#[derive(Drop)]\nstruct Shape {}\n\ntrait Drawable&lt;T&gt; {\n    fn draw(self: @T);\n}\n\nimpl DrawableShape of Drawable&lt;Shape&gt; {\n    fn draw(self: @Shape){\n        println!(\&quot;Drawing a shape!\&quot;);\n    }\n}\n\n#[executable]\nfn main() {\n    let my_shape = Shape{};\n    // the line goes here\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The code doesn't compile because there are two implementations of the trait `Consumer&lt;T&gt;` for the type `AThirdType`.\nThe implementation `TConsumerImpl` is a negative implementation of the trait `Producer&lt;T&gt;`, implementing the trait `Consumer&lt;T&gt;` for all types `T` that don't implement the trait `Producer&lt;T&gt;`.\nThe implementation `ThirdConsumerImpl` is thus redundant.\n&quot;,&quot;id&quot;:&quot;26b22cf1-9a7f-4a2d-98f3-34dab7a6dfcd&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct ProducerType {}\n\n#[derive(Drop, Debug)]\nstruct AnotherType {}\n\n#[derive(Drop, Debug)]\nstruct AThirdType {}\n\ntrait Producer&lt;T&gt; {\n    fn produce(self: T) -&gt; u32;\n}\n\ntrait Consumer&lt;T&gt; {\n    fn consume(self: T, input: u32);\n}\n\nimpl ProducerImpl of Producer&lt;ProducerType&gt; {\n    fn produce(self: ProducerType) -&gt; u32 {\n        42\n    }\n}\n\nimpl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {\n    fn consume(self: T, input: u32) {\n        println!(\&quot;{:?} consumed value: {}\&quot;, self, input);\n    }\n}\n\nimpl ThirdConsumerImpl of Consumer&lt;AThirdType&gt; {\n    fn consume(self: AThirdType, input: u32) {\n        println!(\&quot;{:?} consumed value: {}\&quot;, self, input);\n    }\n}\n\n#[executable]\nfn main() {\n    let producer = ProducerType {};\n    let another_type = AnotherType {};\n    let third_type = AThirdType {};\n    let production = producer.produce();\n    another_type.consume(production);\n    third_type.consume(production);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>In this chapter, we will explore various error handling techniques provided by
Cairo, which not only allow you to address potential issues in your code, but
also make it easier to create programs that are adaptable and maintainable. By
examining different approaches to managing errors, such as pattern matching with
the <code>Result</code> enum, using the <code>?</code> operator for more ergonomic error propagation,
and employing the <code>unwrap</code> or <code>expect</code> methods for handling recoverable errors,
you'll gain a deeper understanding of Cairo's error handling features. These
concepts are crucial for building robust applications that can effectively
handle unexpected situations, ensuring your code is ready for production.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unrecoverable-errors-with-panic"><a class="header" href="#unrecoverable-errors-with-panic">Unrecoverable Errors with <code>panic</code></a></h1>
<p>In Cairo, unexpected issues may arise during program execution, resulting in
runtime errors. While the <code>panic</code> function from the core library doesn't provide
a resolution for these errors, it does acknowledge their occurrence and
terminates the program. There are two primary ways that a panic can be triggered
in Cairo: inadvertently, through actions causing the code to panic (e.g.,
accessing an array beyond its bounds), or deliberately, by invoking the <code>panic</code>
function.</p>
<p>When a panic occurs, it leads to an abrupt termination of the program. The
<code>panic</code> function takes an array as an argument, which can be used to provide an
error message and performs an unwind process where all variables are dropped and
dictionaries squashed to ensure the soundness of the program to safely terminate
the execution.</p>
<p>Here is how we can call <code>panic</code> from inside a program and return the error code
<code>2</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut data = array![2];

    if true {
        panic(data);
    }
    println!("This line isn't reached");
}
</code></pre>
<p>Running the program will produce the following output:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_01_panic v0.1.0 (listings/ch09-error-handling/no_listing_01_panic/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_01_panic
error: Panicked with 0x2.

</code></pre>
<p>As you can notice in the output, the call to <code>println!</code> macro is never reached,
as the program terminates after encountering the <code>panic</code> statement.</p>
<p>An alternative and more idiomatic approach to panic in Cairo would be to use the
<code>panic_with_felt252</code> function. This function serves as an abstraction of the
array-defining process and is often preferred due to its clearer and more
concise expression of intent. By using <code>panic_with_felt252</code>, developers can
panic in a one-liner by providing a <code>felt252</code> error message as an argument,
making the code more readable and maintainable.</p>
<p>Let's consider an example:</p>
<pre><code class="language-cairo">use core::panic_with_felt252;

#[executable]
fn main() {
    panic_with_felt252(2);
}
</code></pre>
<p>Executing this program will yield the same error message as before. In that
case, if there is no need for an array and multiple values to be returned within
the error, <code>panic_with_felt252</code> is a more succinct alternative.</p>
<h2 id="panic-macro"><a class="header" href="#panic-macro"><code>panic!</code> Macro</a></h2>
<p><code>panic!</code> macro can be really helpful. The previous example returning the error
code <code>2</code> shows how convenient <code>panic!</code> macro is. There is no need to create an
array and pass it as an argument like with the <code>panic</code> function.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    if true {
        panic!("2");
    }
    println!("This line isn't reached");
}
</code></pre>
<p>Unlike the <code>panic_with_felt252</code> function, using <code>panic!</code> allows the input, which
is ultimately the panic error, to be a literal longer than 31 bytes. This is
because <code>panic!</code> takes a string as a parameter. For example, the following line
of code will successfully compile:</p>
<pre><code class="language-cairo  noplayground">panic!("the error for panic! macro is not limited to 31 characters anymore");
</code></pre>
<h2 id="nopanic-notation"><a class="header" href="#nopanic-notation"><code>nopanic</code> Notation</a></h2>
<p>You can use the <code>nopanic</code> notation to indicate that a function will never panic.
Only <code>nopanic</code> functions can be called in a function annotated as <code>nopanic</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() -&gt; felt252 nopanic {
    42
}
</code></pre>
<p>This function will always return <code>42</code> and is guaranteed to never panic.
Conversely, the following function is not guaranteed to never panic:</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() nopanic {
    assert!(1 == 1, "what");
}
</code></pre>
<p>If you try to compile this function that includes code that may panic, you will
get the following error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_04_nopanic_wrong v0.1.0 (listings/ch09-error-handling/no_listing_05_nopanic_wrong/Scarb.toml)
error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:13
    assert!(1 == 1, "what");
            ^^^^^^

error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:5
    assert!(1 == 1, "what");
    ^^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `no_listing_04_nopanic_wrong` due to 2 previous errors
error: `scarb` command exited with error

</code></pre>
<p>Note that there are two functions that may panic here, <code>assert</code> and equality
with <code>==</code>. We usually don't use <code>assert</code> function in practice and use <code>assert!</code>
macro instead. We will discuss <code>assert!</code> macro in more detail in the <a href="./ch10-01-how-to-write-tests.html#checking-results-with-the-assert-macro">Testing
Cairo Programs</a> chapter.</p>
<h2 id="panic_with-attribute"><a class="header" href="#panic_with-attribute"><code>panic_with</code> Attribute</a></h2>
<p>You can use the <code>panic_with</code> attribute to mark a function that returns an
<code>Option</code> or <code>Result</code>. This attribute takes two arguments, which are the data
that is passed as the panic reason as well as the name for a wrapping function.
It will create a wrapper for your annotated function which will panic if the
function returns <code>None</code> or <code>Err</code>, with the given data as the panic error.</p>
<p>Example:</p>
<pre><code class="language-cairo">#[panic_with('value is 0', wrap_not_zero)]
fn wrap_if_not_zero(value: u128) -&gt; Option&lt;u128&gt; {
    if value == 0 {
        None
    } else {
        Some(value)
    }
}

#[executable]
fn main() {
    wrap_if_not_zero(0); // this returns None
    wrap_not_zero(0); // this panics with 'value is 0'
}
</code></pre>
<div class="quiz-placeholder" data-quiz-name="&quot;ch09-01-unrecoverable-errors-with-panic&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;The macro `panic!` takes one and only one `ByteArray` argument.\nThe function `core::panic_with_felt252` takes one and only one `felt252` argument.\nThe function `panic` takes an array of `felt252` elements as an argument and returns it.\n&quot;,&quot;id&quot;:&quot;5bf03883-59ab-4063-85e8-8c1d2fafa3e3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`panic(array![2, 'This is the error message']);`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`panic(array![2, \&quot;This is the error message\&quot;]);`&quot;,&quot;`panic!(\&quot;2\&quot;, \&quot;This is the error message\&quot;);`&quot;,&quot;`core::panic_with_felt252(2, 'This is the error message');`&quot;],&quot;prompt&quot;:&quot;Which line of code is correct to return the error code `2` and the error message `This is the error message`?\n&quot;}},{&quot;context&quot;:&quot;A panic should not be used to communicate failure *within* the program, as it will terminate the program immediately.\n&quot;,&quot;id&quot;:&quot;0e7bb9f9-af5a-441d-83b4-bcd0a97daf70&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;The program has reached an error state which should be communicated to a caller function&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;The program is about to perform a dangerous operation&quot;,&quot;The program should stop executing as soon as possible&quot;,&quot;The program has reached an unrecoverable error state&quot;],&quot;prompt&quot;:&quot;Which of the following is **NOT** a good reason to use a panic?\n&quot;}},{&quot;context&quot;:&quot;Program 3 tries to access an element at an index that is out of bounds, but it matches the\nresulting `Option` and returns a default value `0` instead of panicking.\n&quot;,&quot;id&quot;:&quot;b6ee33f0-5b70-4286-a6d9-a08aad66f9c8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Program 3&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Program 1&quot;,&quot;Program 2&quot;,&quot;Program 2 and Program 3&quot;],&quot;prompt&quot;:&quot;Which of the following programs will **NOT** cause a runtime panic?\n\n```\n#[executable]\nfn main() {\n    if true {\n        panic!(\&quot;2\&quot;);\n    }\n    println!(\&quot;This line shouldn't be reached\&quot;);\n}\n```\n\n```\n#[executable]\nfn main() {\n    let arr = array![1, 2, 3];\n    let index = 5;\n\n    println!(\&quot;Value at index {}: {}\&quot;, index, arr[index]);\n}\n```\n\n```\n#[executable]\nfn main() {\n    let mut arr: Array&lt;u128&gt; = array![5];\n    let index_to_access = 3;\n    let value = match arr.get(index_to_access) {\n        Some(x) =&gt; { *x.unbox() },\n        None =&gt; { 0 }\n    };\n\n    println!(\&quot;Value at index {} is {}\&quot;, index_to_access, value);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;If a function is annotated with `#[panic_with]`, a wrapper function is created that panics if the\nannotated function returns `None` or `Err`.\n&quot;,&quot;id&quot;:&quot;f618cfc9-3419-4cde-962d-72210879b3b3&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;To create a wrapper function that panics if the annotated function returns `None` or `Err`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;To handle runtime errors gracefully&quot;,&quot;To indicate that a function may panic&quot;,&quot;To catch errors at compile time&quot;],&quot;prompt&quot;:&quot;What is the purpose of the `panic_with` attribute in Cairo?\n\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="recoverable-errors-with-result"><a class="header" href="#recoverable-errors-with-result">Recoverable Errors with <code>Result</code></a></h1>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that you can easily
interpret and respond to. For example, if you try to add two large integers and
the operation overflows because the sum exceeds the maximum representable value,
you might want to return an error or a wrapped result instead of causing
undefined behavior or terminating the process.</p>
<h2 id="the-result-enum"><a class="header" href="#the-result-enum">The <code>Result</code> Enum</a></h2>
<p>Recall from <a href="./ch08-01-generic-data-types.html#enums">Generic data types</a> section in Chapter
8 that the <code>Result</code> enum is defined as having
two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum has two generic types, <code>T</code> and <code>E</code>, and two variants:
<code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (by returning a value of type <code>T</code>) or fail
(by returning a value of type <code>E</code>).</p>
<h2 id="the-resulttrait"><a class="header" href="#the-resulttrait">The <code>ResultTrait</code></a></h2>
<p>The <code>ResultTrait</code> trait provides methods for working with the <code>Result&lt;T, E&gt;</code>
enum, such as unwrapping values, checking whether the <code>Result</code> is <code>Ok</code> or <code>Err</code>,
and panicking with a custom message. The <code>ResultTraitImpl</code> implementation
defines the logic of these methods.</p>
<pre><code class="language-cairo noplayground">trait ResultTrait&lt;T, E&gt; {
    fn expect&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; T;

    fn unwrap&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T;

    fn expect_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; E;

    fn unwrap_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; E;

    fn is_ok(self: @Result&lt;T, E&gt;) -&gt; bool;

    fn is_err(self: @Result&lt;T, E&gt;) -&gt; bool;
}
</code></pre>
<p>The <code>expect</code> and <code>unwrap</code> methods are similar in that they both attempt to
extract the value of type <code>T</code> from a <code>Result&lt;T, E&gt;</code> when it is in the <code>Ok</code>
variant. If the <code>Result</code> is <code>Ok(x)</code>, both methods return the value <code>x</code>. However,
the key difference between the two methods lies in their behavior when the
<code>Result</code> is in the <code>Err</code> variant. The <code>expect</code> method allows you to provide a
custom error message (as a <code>felt252</code> value) that will be used when panicking,
giving you more control and context over the panic. On the other hand, the
<code>unwrap</code> method panics with a default error message, providing less information
about the cause of the panic.</p>
<p>The <code>expect_err</code> and <code>unwrap_err</code> methods have the exact opposite behavior. If
the <code>Result</code> is <code>Err(x)</code>, both methods return the value <code>x</code>. However, the key
difference between the two methods is in case of <code>Ok()</code>. The <code>expect_err</code> method
allows you to provide a custom error message (as a <code>felt252</code> value) that will be
used when panicking, giving you more control and context over the panic. On the
other hand, the <code>unwrap_err</code> method panics with a default error message,
providing less information about the cause of the panic.</p>
<p>A careful reader may have noticed the <code>&lt;+Drop&lt;T&gt;&gt;</code> and <code>&lt;+Drop&lt;E&gt;&gt;</code> in the first
four methods signatures. This syntax represents generic type constraints in the
Cairo language, as seen in the previous chapter. These constraints indicate that
the associated functions require an implementation of the <code>Drop</code> trait for the
generic types <code>T</code> and <code>E</code>, respectively.</p>
<p>Finally, the <code>is_ok</code> and <code>is_err</code> methods are utility functions provided by the
<code>ResultTrait</code> trait to check the variant of a <code>Result</code> enum value.</p>
<ul>
<li><code>is_ok</code> takes a snapshot of a <code>Result&lt;T, E&gt;</code> value and returns <code>true</code> if the
<code>Result</code> is the <code>Ok</code> variant, meaning the operation was successful. If the
<code>Result</code> is the <code>Err</code> variant, it returns <code>false</code>.</li>
<li><code>is_err</code> takes a snapshot of a <code>Result&lt;T, E&gt;</code> value and returns <code>true</code> if the
<code>Result</code> is the <code>Err</code> variant, meaning the operation encountered an error. If
the <code>Result</code> is the <code>Ok</code> variant, it returns <code>false</code>.</li>
</ul>
<p>These methods are helpful when you want to check the success or failure of an
operation without consuming the <code>Result</code> value, allowing you to perform
additional operations or make decisions based on the variant without unwrapping
it.</p>
<p>You can find the implementation of the <code>ResultTrait</code> <a href="https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20">here</a>.</p>
<p>It is always easier to understand with examples. Have a look at this function
signature:</p>
<pre><code class="language-cairo noplayground">fn u128_overflowing_add(a: u128, b: u128) -&gt; Result&lt;u128, u128&gt;;
</code></pre>
<p>It takes two <code>u128</code> integers, <code>a</code> and <code>b</code>, and returns a <code>Result&lt;u128, u128&gt;</code>
where the <code>Ok</code> variant holds the sum if the addition does not overflow, and the
<code>Err</code> variant holds the overflowed value if the addition does overflow.</p>
<p>Now, we can use this function elsewhere. For instance:</p>
<pre><code class="language-cairo noplayground">fn u128_checked_add(a: u128, b: u128) -&gt; Option&lt;u128&gt; {
    match u128_overflowing_add(a, b) {
        Ok(r) =&gt; Some(r),
        Err(r) =&gt; None,
    }
}

</code></pre>
<p>Here, it accepts two <code>u128</code> integers, <code>a</code> and <code>b</code>, and returns an
<code>Option&lt;u128&gt;</code>. It uses the <code>Result</code> returned by <code>u128_overflowing_add</code> to
determine the success or failure of the addition operation. The <code>match</code>
expression checks the <code>Result</code> from <code>u128_overflowing_add</code>. If the result is
<code>Ok(r)</code>, it returns <code>Some(r)</code> containing the sum. If the result is <code>Err(r)</code>, it
returns <code>None</code> to indicate that the operation has failed due to overflow. The
function does not panic in case of an overflow.</p>
<p>Let's take another example:</p>
<pre><code class="language-cairo noplayground">fn parse_u8(s: felt252) -&gt; Result&lt;u8, felt252&gt; {
    match s.try_into() {
        Some(value) =&gt; Ok(value),
        None =&gt; Err('Invalid integer'),
    }
}
</code></pre>
<p>In this example, the <code>parse_u8</code> function takes a <code>felt252</code> and tries to convert
it into a <code>u8</code> integer using the <code>try_into</code> method. If successful, it returns
<code>Ok(value)</code>, otherwise it returns <code>Err('Invalid integer')</code>.</p>
<p>Our two test cases are:</p>
<pre><code class="language-cairo noplayground"><span class="boring">fn parse_u8(s: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    match s.try_into() {
</span><span class="boring">        Some(value) =&gt; Ok(value),
</span><span class="boring">        None =&gt; Err('Invalid integer'),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Don't worry about the <code>#[cfg(test)]</code> attribute for now. We'll explain in more
detail its meaning in the next <a href="./ch10-01-how-to-write-tests.html">Testing Cairo Programs</a> chapter.</p>
<p><code>#[test]</code> attribute means the function is a test function, and <code>#[should_panic]</code>
attribute means this test will pass if the test execution panics.</p>
<p>The first one tests a valid conversion from <code>felt252</code> to <code>u8</code>, expecting the
<code>unwrap</code> method not to panic. The second test function attempts to convert a
value that is out of the <code>u8</code> range, expecting the <code>unwrap</code> method to panic with
the error message <code>Invalid integer</code>.</p>
<h2 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating Errors</a></h2>
<p>When a function’s implementation calls something that might fail, instead of
handling the error within the function itself you can return the error to the
calling code so that it can decide what to do. This is known as <em>propagating</em>
the error and gives more control to the calling code, where there might be more
information or logic that dictates how the error should be handled than what you
have available in the context of your code.</p>
<p>For example, Listing 9-1 shows an implementation of a
function that tries to parse a number as <code>u8</code> and uses a match expression to
handle a potential error.</p>
<pre><code class="language-cairo  noplayground">// A hypothetical function that might fail
fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_u256: u256 = input.into();
    if input_u256 &lt; 256 {
        Result::Ok(input.try_into().unwrap())
    } else {
        Result::Err('Invalid Integer')
    }
}

fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8 = match parse_u8(input) {
        Result::Ok(num) =&gt; num,
        Result::Err(err) =&gt; { return Result::Err(err); },
    };
    let res = input_to_u8 - 1;
    Result::Ok(res)
}
</code></pre>
<p>function that returns errors to the calling code using a <code>match</code>
expression.</span></p>
<p>The code that calls this <code>parse_u8</code> will handle getting either an <code>Ok</code> value
that contains a number or an <code>Err</code> value that contains an error message. It’s up
to the calling code to decide what to do with those values. If the calling code
gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, or use a
default value. We don’t have enough information on what the calling code is
actually trying to do, so we propagate all the success or error information
upward for it to handle appropriately.</p>
<p>This pattern of propagating errors is so common in Cairo that Cairo provides the
question mark operator <code>?</code> to make this easier.</p>
<h2 id="a-shortcut-for-propagating-errors-the--operator"><a class="header" href="#a-shortcut-for-propagating-errors-the--operator">A Shortcut for Propagating Errors: the <code>?</code> Operator</a></h2>
<p>Listing 9-2 shows an implementation of <code>mutate_byte</code> that
has the same functionality as the one in Listing 9-1 but uses
the <code>?</code> operator to gracefully handle errors.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">// A hypothetical function that might fail
</span><span class="boring">fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    let input_u256: u256 = input.into();
</span><span class="boring">    if input_u256 &lt; 256 {
</span><span class="boring">        Result::Ok(input.try_into().unwrap())
</span><span class="boring">    } else {
</span><span class="boring">        Result::Err('Invalid Integer')
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8: u8 = parse_u8(input)?;
    let res = input_to_u8 - 1;
    Ok(res)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_function_2() {
</span><span class="boring">        let number: felt252 = 258;
</span><span class="boring">        match mutate_byte(number) {
</span><span class="boring">            Ok(value) =&gt; println!("Result: {}", value),
</span><span class="boring">            Err(e) =&gt; println!("Error: {}", e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>9-2: A function that returns errors to the calling code
using the <code>?</code> operator.</span></p>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way
as the <code>match</code> expressions we defined to handle the <code>Result</code> values in
Listing 1. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code>
will get returned from this expression, and the program will continue. If the
value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we
had used the <code>return</code> keyword so the error value gets propagated to the calling
code.</p>
<p>In the context of Listing 2, the <code>?</code> at the end of the <code>parse_u8</code> call will
return the value inside an <code>Ok</code> to the variable <code>input_to_u8</code>. If an error
occurs, the <code>?</code> operator will return early out of the whole function and give
any <code>Err</code> value to the calling code.</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function’s
implementation simpler and more ergonomic.</p>
<h3 id="where-the--operator-can-be-used"><a class="header" href="#where-the--operator-can-be-used">Where The <code>?</code> Operator Can Be Used</a></h3>
<p>The <code>?</code> operator can only be used in functions whose return type is compatible
with the value the <code>?</code> is used on. This is because the <code>?</code> operator is defined
to perform an early return of a value out of the function, in the same manner as
the <code>match</code> expression we defined in Listing 9-1. In Listing
9-1, the <code>match</code> was using a <code>Result</code> value, and the early
return arm returned an <code>Err(e)</code> value. The return type of the function has to be
a <code>Result</code> so that it’s compatible with this return.</p>
<p>In Listing 9-3, let’s look at the error
we’ll get if we use the <code>?</code> operator in a function with a return type that is
incompatible with the type of the value we use <code>?</code> on.</p>
<pre><code class="language-cairo"><span class="boring">//TAG: does_not_compile
</span><span class="boring">
</span>#[executable]
fn main() {
    let some_num = parse_u8(258)?;
}
<span class="boring">
</span><span class="boring">fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
</span><span class="boring">    let input_u256: u256 = input.into();
</span><span class="boring">    if input_u256 &lt; 256 {
</span><span class="boring">        Result::Ok(input.try_into().unwrap())
</span><span class="boring">    } else {
</span><span class="boring">        Result::Err('Invalid Integer')
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>9-3: Attempting to use the <code>?</code> in a <code>main</code>
function that returns <code>()</code> won’t compile.</span></p>
<p>This code calls a function that might fail. The <code>?</code> operator follows the
<code>Result</code> value returned by <code>parse_u8</code>, but this <code>main</code> function has the return
type of <code>()</code>, not <code>Result</code>. When we compile this code, we get an error message
similar to this:</p>
<pre><code class="language-text">$ scarb build 
   Compiling listing_invalid_qmark v0.1.0 (listings/ch09-error-handling/listing_invalid_qmark/Scarb.toml)
error: `?` can only be used in a function with `Option` or `Result` return type.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:6:20
    let some_num = parse_u8(258)?;
                   ^^^^^^^^^^^^^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:6:9
    let some_num = parse_u8(258)?;
        ^^^^^^^^

error: could not compile `listing_invalid_qmark` due to 1 previous error and 1 warning

</code></pre>
<p>This error points out that we’re only allowed to use the <code>?</code> operator in a
function that returns <code>Result</code> or <code>Option</code>.</p>
<p>To fix the error, you have two choices. One choice is to change the return type
of your function to be compatible with the value you’re using the <code>?</code> operator
on as long as you have no restrictions preventing that. The other choice is to
use a <code>match</code> to handle the <code>Result&lt;T, E&gt;</code> in whatever way is appropriate.</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values as
well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a
function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called
on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>: if
the value is <code>None</code>, the <code>None</code> will be returned early from the function at that
point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the resultant
value of the expression, and the function continues.</p>
<h3 id="summary-4"><a class="header" href="#summary-4">Summary</a></h3>
<p>We saw that recoverable errors can be handled in Cairo using the <code>Result</code> enum,
which has two variants: <code>Ok</code> and <code>Err</code>. The <code>Result&lt;T, E&gt;</code> enum is generic, with
types <code>T</code> and <code>E</code> representing the successful and error values, respectively.
The <code>ResultTrait</code> provides methods for working with <code>Result&lt;T, E&gt;</code>, such as
unwrapping values, checking if the result is <code>Ok</code> or <code>Err</code>, and panicking with
custom messages.</p>
<p>To handle recoverable errors, a function can return a <code>Result</code> type and use
pattern matching to handle the success or failure of an operation. The <code>?</code>
operator can be used to implicitly handle errors by propagating the error or
unwrapping the successful value. This allows for more concise and clear error
handling, where the caller is responsible for managing errors raised by the
called function.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch09-02-error-handling-result&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;`Option` can just represent that an operation has failed, but `Result` can explain why the operation has failed.\n&quot;,&quot;id&quot;:&quot;f9aee0d9-6974-433d-8391-c601b9c803f5&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Because `Result` can represent why an operation failed, the division can fail for many reasons (e.g either at least one operand is `None` or the divisor is 0)&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Because `Result` uses fewer bytes at runtime than `Option` to represent failures&quot;,&quot;Because `Result` represents the possibility of failure, while `Option` cannot represent failures&quot;,&quot;Because `Result` represents errors the same way as the underlying system calls&quot;],&quot;prompt&quot;:&quot;Let's consider this function that performs the division between two `Option&lt;u32&gt;`.\nWhy do we want it to return a `Result` instead of an `Option` ?\n```\nfn option_div (lhs: Option&lt;u32&gt;, rhs: Option&lt;u32&gt;) -&gt; Result&lt;u32, ByteArray&gt; {\n    match lhs {\n        Some(dividend) =&gt; {\n            match rhs {\n                Some(divisor) =&gt; {\n                    if divisor == 0 {\n                        Err(\&quot;Divisor is 0\&quot;)\n                    } else {\n                        Ok(dividend / divisor)\n                    }\n                },\n                None =&gt; Err(\&quot;Divisor is None\&quot;)\n            }\n        },\n        None =&gt; {\n          Err(\&quot;Dividend is None\&quot;)\n        },\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;`option_div` returns a `Result`, but the return type of `try_division_by_0` expects an `Option`.\nTherefore it is invalid to use the `?` operator until the `Result` has been converted to an `Option` (e.g. with the `Ok` method).\n&quot;,&quot;id&quot;:&quot;021a3060-6076-4b40-ba4f-eb305543e449&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn option_div (lhs: Option&lt;u32&gt;, rhs: Option&lt;u32&gt;) -&gt; Result&lt;u32, ByteArray&gt; {\n    match lhs {\n        Some(dividend) =&gt; {\n            match rhs {\n                Some(divisor) =&gt; {\n                    if divisor == 0 {\n                        Err(\&quot;Divisor is 0\&quot;)\n                    } else {\n                        Ok(dividend / divisor)\n                    }\n                },\n                None =&gt; Err(\&quot;Divisor is None\&quot;)\n            }\n        },\n        None =&gt; {\n          Err(\&quot;Dividend is None\&quot;)\n        },\n    }\n}\n\nfn try_division_by_0 () -&gt; Option&lt;u32&gt; {\n    let dividend = Some(10);\n    let divisor = Some(0);\n    let result = option_div(dividend, divisor)?;\n    Some(result)\n}\n\n#[executable]\nfn main() {\n    println!(\&quot;{}\&quot;, try_division_by_0().unwrap());\n}\n&quot;}},{&quot;context&quot;:&quot;If `e` is of type `Result`, then `e?` extracts the value inside `Ok` if possible; otherwise, it returns the `Err` from the current function.\n&quot;,&quot;id&quot;:&quot;b4ddf5d9-ee90-47b3-a183-24a7fa578669&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\nmatch e {\n    Ok(v) =&gt; v,\n    Err(e) =&gt; return Err(e)\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nif let Err(e) = e {\n    return Err(e);\n}\n```\n&quot;,&quot;```\nmatch e {\n    Ok(x) =&gt; x,\n    Err(err) =&gt; panic!(\&quot;{}\&quot;, err)\n}\n```\n&quot;,&quot;`e.unwrap()`&quot;],&quot;prompt&quot;:&quot;Given an arbitrary expression `e` of type `Result&lt;T, E&gt;`, which code snippet best represents how `e?` is translated?\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="testing-cairo-programs"><a class="header" href="#testing-cairo-programs">Testing Cairo Programs</a></h1>
<p>Correctness in our programs is the extent to which our code does what we intend
it to do. Cairo is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Cairo's linear
type system shoulders a huge part of this burden, but the type system cannot
catch everything. As such, Cairo includes support for writing tests.</p>
<p>Testing is a complex skill: although we can’t cover every detail about how to
write good tests in one chapter, we’ll discuss the mechanics of Cairo's testing
facilities. We’ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How To Write Tests</a></h1>
<h2 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h2>
<p>Tests are Cairo functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ul>
<p>Let’s look at the features Cairo provides for writing tests that take these
actions, which include:</p>
<ul>
<li><code>#[test]</code> attribute.</li>
<li><code>assert!</code>macro.</li>
<li><code>assert_eq!</code>, <code>assert_ne!</code>, <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and
<code>assert_ge!</code> macros. In order to use them, you will need to add
<code>assert_macros = "2.8.2"</code> as a dev dependency.</li>
<li><code>#[should_panic]</code> attribute.</li>
</ul>
<blockquote>
<p>Note: Make sure to select Starknet Foundry as a test runner when creating your
project.</p>
</blockquote>
<h3 id="the-anatomy-of-a-test-function-1"><a class="header" href="#the-anatomy-of-a-test-function-1">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Cairo is a function that’s annotated with the
<code>#[test]</code> attribute. Attributes are metadata about pieces of Cairo code; one
example is the <code>#[derive()]</code> attribute we used with structs in <a href="./ch05-01-defining-and-instantiating-structs.html">Chapter
5</a>. To change a
function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you
run your tests with the <code>scarb test</code> command, Scarb runs Starknet Foundry's test
runner binary that runs the annotated functions and reports on whether each test
function passes or fails.</p>
<p>Let's create a new project called <em>adder</em> using Scarb with the command
<code>scarb new adder</code>. Remove the <em>tests</em> folder.</p>
<pre><code class="language-shell">adder
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<p>In <em>lib.cairo</em>, let's remove the existing content and add a <code>tests</code> module
containing the first test, as shown in Listing 10-1.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>simple test function</span></p>
<p>Note the <code>#[test]</code> annotation: this attribute indicates this is a test function,
so the test runner knows to treat this function as a test. We might also have
non-test functions to help set up common scenarios or perform common operations,
so we always need to indicate which functions are tests.</p>
<p>We use the <code>#[cfg(test)]</code> attribute for the <code>tests</code> module, so that the compiler
knows the code it contains needs to be compiled only when running tests. This is
actually not an option: if you put a simple test with the <code>#[test]</code> attribute in
a <em>lib.cairo</em> file, it will not compile. We will talk more about the
<code>#[cfg(test)]</code> attribute in the next <a href="./ch10-02-test-organization.html">Test Organization</a>
section.</p>
<p>The example function body uses the <code>assert_eq!</code> macro, which contains the result
of adding 2 and 2, which equals 4. This assertion serves as an example of the
format for a typical test. We'll explain in more detail how <code>assert_eq!</code> works
later in this chapter. Let’s run it to see that this test passes.</p>
<p>The <code>scarb test</code> command runs all tests found in our project, and shows the
following output:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~15240)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p><code>scarb test</code> compiled and ran the test. We see the line
<code>Collected 1 test(s) from adder package</code> followed by the line
<code>Running 1 test(s) from src/</code>. The next line shows the name of the test
function, called <code>it_works</code>, and that the result of running that test is <code>ok</code>.
The test runner also provides an estimation of the gas consumption. The overall
summary shows that all the tests passed, and the portion that reads
<code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular
instance; we’ll cover that in the
<a href="ch10-01-how-to-write-tests.html#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a>
section later in this chapter. Because we haven’t done that here, the summary
shows <code>0 ignored</code>. We can also pass an argument to the <code>scarb test</code> command to
run only a test whose name matches a string; this is called filtering and we’ll
cover that in the <a href="ch10-01-how-to-write-tests.html#running-single-tests">Running Single Tests</a> section. Since
we haven’t filtered the tests being run, the end of the summary shows
<code>0 filtered out</code>.</p>
<p>Let’s start to customize the test to our own needs. First change the name of the
<code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
</code></pre>
<p>Then run <code>scarb test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~15240)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests
fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. Enter the new test as a function named <code>another</code>, so your
<em>src/lib.cairo</em> file looks like in Listing 10-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        let result = 2 + 2;
        assert!(result == 6, "Make this test fail");
    }
}
</code></pre>
<p>Adding a second test in <em>lib.cairo</em> that will fail</span></p>
<p>Run <code>scarb test</code> and you will see the following output:</p>
<pre><code class="language-shell">Collected 2 test(s) from adder package
Running 2 test(s) from src/
[FAIL] adder::tests::another

Failure data:
    "Make this test fail"

[PASS] adder::tests::exploration (gas: ~1)
Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out

Failures:
    adder::tests::another
</code></pre>
<p>Instead of <code>[PASS]</code>, the line <code>adder::tests::another</code> shows <code>[FAIL]</code>. A new
section appears between the individual results and the summary. It displays the
detailed reason for each test failure. In this case, we get the details that
<code>another</code> failed because it panicked with <code>"Make this test fail"</code> error.</p>
<p>After that, the summary line is displayed: we had one test pass and one test
fail. At the end, we see a list of the failing tests.</p>
<p>Now that you've seen what the test results look like in different scenarios,
let’s look at some functions that are useful in tests.</p>
<h2 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h2>
<p>The <code>assert!</code> macro, provided by Cairo, is useful when you want to ensure that
some condition in a test evaluates to <code>true</code>. We give the <code>assert!</code> macro the
first argument that evaluates to a boolean. If the value is <code>true</code>, nothing
happens and the test passes. If the value is <code>false</code>, the <code>assert!</code> macro calls
<code>panic()</code> to cause the test to fail with a message we defined as the second
argument. Using the <code>assert!</code> macro helps us check that our code is functioning
in the way we intended.</p>
<p>Remember in <a href="./ch05-03-method-syntax.html">Chapter
5</a>, we used a
<code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing
10-3. Let’s put this code in the <em>src/lib.cairo</em> file, then write
some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p><code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter
5</span></p>
<p>The <code>can_hold</code> method returns a <code>bool</code>, which means it’s a perfect use case for
the <code>assert!</code> macro. We can write a test that exercises the <code>can_hold</code> method by
creating a <code>Rectangle</code> instance that has a width of <code>8</code> and a height of <code>7</code> and
asserting that it can hold another <code>Rectangle</code> instance that has a width of <code>5</code>
and a height of <code>1</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
    }
}
<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a
regular module that follows the usual visibility rules we covered in Chapter
7 in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for
Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use a
glob here, so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(@smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
    }
<span class="boring">}
</span></code></pre>
<p>Adding another test in <em>lib.cairo</em> that will pass</span></p>
<p>Because the correct result of the <code>can_hold</code> method, in this case, is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code>
method by replacing the <code>&gt;</code> sign with a <code>&lt;</code> sign when it compares the widths:</p>
<pre><code class="language-cairo  noplayground">impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_01_wrong_can_hold_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_01_wrong_can_hold_impl_unittest) no_listing_01_wrong_can_hold_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_01_wrong_can_hold_impl package
Running 2 test(s) from src/
[PASS] no_listing_01_wrong_can_hold_impl::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
[FAIL] no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

Failure data:
    "rectangle cannot hold"

Tests: 1 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is
<code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code> (<code>8</code> is not
less than <code>5</code>) in the <code>larger_can_hold_smaller</code> test. Notice that the
<code>smaller_cannot_hold_larger</code> test still passes: to make this test fail, the
height comparison should also be modified in <code>can_hold</code> method, replacing the
<code>&gt;</code> sign with a <code>&lt;</code> sign.</p>
<h2 id="testing-equality-and-comparisons-with-the-assert_xx-macros"><a class="header" href="#testing-equality-and-comparisons-with-the-assert_xx-macros">Testing Equality and Comparisons with the <code>assert_xx!</code> Macros</a></h2>
<h3 id="assert_eq-and-assert_ne-macros"><a class="header" href="#assert_eq-and-assert_ne-macros"><code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could do
this using the <code>assert!</code> macro and passing it an expression using the <code>==</code>
operator. However, this is such a common test that the standard library provides
a pair of macros — <code>assert_eq!</code> and <code>assert_ne!</code> — to perform this test more
conveniently. These macros compare two arguments for equality or inequality,
respectively. They’ll also print the two values if the assertion fails, which
makes it easier to see <em>why</em> the test failed; conversely, the <code>assert!</code> macro
only indicates that it got a <code>false</code> value for the <code>==</code> expression, without
printing the values that led to the <code>false</code> value.</p>
<p>In Listing 10-5, we write a function named <code>add_two</code> that adds <code>2</code>
to its parameter, then we test this function using <code>assert_eq!</code> and <code>assert_ne!</code>
macros.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn wrong_check() {
        assert_ne!(0, add_two(2));
    }
}
</code></pre>
<p>function <code>add_two</code> using <code>assert_eq!</code> and <code>assert_ne!</code> macros</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04 (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_unittest) listing_10_04 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_04 package
Running 2 test(s) from src/
[PASS] listing_10_04::tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
[PASS] listing_10_04::tests::wrong_check (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~15040)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>In the <code>it_adds_two</code> test, we pass <code>4</code> as argument to <code>assert_eq!</code> macro, which
is equal to the result of calling <code>add_two(2)</code>. The line for this test is
<code>[PASS] adder::tests::it_adds_two (gas: ~1)</code>.</p>
<p>In the <code>wrong_check</code> test, we pass <code>0</code> as argument to <code>assert_ne!</code> macro, which
is not equal to the result of calling <code>add_two(2)</code>. Tests that use the
<code>assert_ne!</code> macro will pass if the two values we give it are <em>not</em> equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but how the input is changed depends on the day of the week that we
run our tests, the best thing to assert might be that the output of the function
is not equal to the input.</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 3
}
</code></pre>
<p>Run the tests again:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04_wong_add (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_wong_add_unittest) listing_10_04_wong_add v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04_wong_add/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_04_wong_add package
Running 1 test(s) from src/
[FAIL] listing_10_04_wong_add::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed.
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    listing_10_04_wong_add::tests::it_adds_two

</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed with the following
message: <code>"assertion `4 == add_two(2)` failed</code>. It tells us that the assertion
that failed was <code> "assertion `left == right` failed</code> and the <code>left</code> and
<code>right</code> values are printed on the next lines as <code>left: left_value</code> and
<code>right: right_value</code>. This helps us start debugging: the <code>left</code> argument was <code>4</code>
but the <code>right</code> argument, where we had <code>add_two(2)</code>, was <code>5</code>. You can imagine
that this would be especially helpful when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters for equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Cairo, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value the
code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(add_two(2), 4)</code>, which would result in the same failure message that
displays <code>assertion failed: `(left == right)`</code>.</p>
<p>Here is a simple example comparing two structs, showing how to use <code>assert_eq!</code>
and <code>assert_ne!</code> macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Debug, PartialEq)]
struct MyStruct {
    var1: u8,
    var2: u8,
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first = MyStruct { var1: 1, var2: 2 };
    let second = MyStruct { var1: 1, var2: 2 };
    let third = MyStruct { var1: 1, var2: 3 };

    assert_eq!(first, second);
    assert_eq!(first, second, "{:?},{:?} should be equal", first, second);
    assert_ne!(first, third);
    assert_ne!(first, third, "{:?},{:?} should not be equal", first, third);
}
</code></pre>
<p>Under the surface, <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators <code>==</code>
and <code>!=</code>, respectively. They both take snapshots of values as arguments. When
the assertions fail, these macros print their arguments using debug formatting
(<code>{:?}</code> syntax), which means the values being compared must implement
<code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of the core library
types implement these traits. For structs and enums that you define yourself,
you’ll need to implement <code>PartialEq</code> to assert equality of those types. You’ll
also need to implement <code>Debug</code> to print the values when the assertion fails.
Because both traits are derivable, this is usually as straightforward as adding
the <code>#[derive(Drop, Debug, PartialEq)]</code> annotation to your struct or enum
definition. See <a href="./appendix-03-derivable-traits.html">Appendix C</a> for more details about these and
other derivable traits.</p>
<h3 id="assert_lt-assert_le-assert_gt-and-assert_ge-macros"><a class="header" href="#assert_lt-assert_le-assert_gt-and-assert_ge-macros"><code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> Macros</a></h3>
<p>Comparisons in tests can be done using the <code>assert_xx!</code> macros:</p>
<ul>
<li><code>assert_lt!</code> checks if a given value is lower than another value, and reverts
otherwise.</li>
<li><code>assert_le!</code> checks if a given value is lower or equal than another value, and
reverts otherwise.</li>
<li><code>assert_gt!</code> checks if a given value is greater than another value, and
reverts otherwise.</li>
<li><code>assert_ge!</code> checks if a given value is greater or equal than another value,
and reverts otherwise.</li>
</ul>
<p>Listing 10-6 demonstrates how to use these macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Copy, Debug, PartialEq)]
struct Dice {
    number: u8,
}

impl DicePartialOrd of PartialOrd&lt;Dice&gt; {
    fn lt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt; rhs.number
    }

    fn le(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt;= rhs.number
    }

    fn gt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt; rhs.number
    }

    fn ge(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt;= rhs.number
    }
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first_throw = Dice { number: 5 };
    let second_throw = Dice { number: 2 };
    let third_throw = Dice { number: 6 };
    let fourth_throw = Dice { number: 5 };

    assert_gt!(first_throw, second_throw);
    assert_ge!(first_throw, fourth_throw);
    assert_lt!(second_throw, third_throw);
    assert_le!(
        first_throw, fourth_throw, "{:?},{:?} should be lower or equal", first_throw, fourth_throw,
    );
}
</code></pre>
<p>Example of tests that use the <code>assert_xx!</code> macros for comparisons</span></p>
<p>In this example, we roll a <code>Dice</code> struct multiple times and compare the results.
We need to manually implement the <code>PartialOrd</code> trait for our struct so that we
can compare <code>Dice</code> instances with <code>lt</code>, <code>le</code>, <code>gt</code> and <code>ge</code> functions, which are
used by <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> macros,
respectively. We also need to derive the <code>Copy</code> trait on our <code>Dice</code> struct to
use the instantiated structs multiple times, as the comparison functions take
ownership of the variables.</p>
<h2 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h2>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in the <a href="./ch12-08-printing.html#formatting">Printing</a> chapter), so you can
pass a format string that contains <code>{}</code> placeholders and values to go in those
placeholders. Custom messages are useful for documenting what an assertion
means; when a test fails, you’ll have a better idea of what the problem is with
the code.</p>
<p>Let’s add a custom failure message composed of a format string with a
placeholder filled in with the actual value we got from the previous <code>add_two</code>
function:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2), "Expected {}, got add_two(2)={}", 4, add_two(2));
    }
</code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_02_custom_messages (snforge test)
   Compiling test(no_listing_02_custom_messages_unittest) no_listing_02_custom_messages v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_02_custom_messages package
Running 1 test(s) from src/
[FAIL] no_listing_02_custom_messages::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_02_custom_messages::tests::it_adds_two

</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h2 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for panics with <code>should_panic</code></a></h2>
<p>In addition to checking return values, it’s important to check that our code
handles error conditions as we expect. For example, consider the <code>Guess</code> type in
Listing 10-7:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Guess {
    value: u64,
}

pub trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
</code></pre>
<p>and its <code>new</code> method</span></p>
<p>Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances
will contain only values between <code>1</code> and <code>100</code>. We can write a test that ensures
that attempting to create a <code>Guess</code> instance with a value outside that range
panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test
passes if the code inside the function panics; the test fails if the code inside
the function doesn’t panic.</p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result to see that
this test passes:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_09_08 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_09_08_unittest) listing_09_08 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_09_08 package
Running 1 test(s) from src/
[PASS] listing_09_08::tests::greater_than_100 (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~14440)
Tests: 1 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that
the <code>new</code> function will panic if the value is greater than <code>100</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">// TAG: tests_fail
</span><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        GuessTrait::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>When we run the test, it will fail:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_03_wrong_new_impl (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_03_wrong_new_impl_unittest) no_listing_03_wrong_new_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_03_wrong_new_impl package
Running 1 test(s) from src/
[FAIL] no_listing_03_wrong_new_impl::tests::greater_than_100

Failure data:
    Expected to panic, but no panic occurred

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_03_wrong_new_impl::tests::greater_than_100

</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code> attribute. The
failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass
even if the test panics for a different reason from the one we were expecting.
To make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>#[should_panic]</code> attribute. The test harness will make sure
that the failure message contains the provided text. For example, consider the
modified code for <code>GuessImpl</code> in Listing 10-8 where the <code>new</code>
function panics with different messages depending on whether the value is too
small or too large:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1");
        } else if value &gt; 100 {
            panic!("Guess must be &lt;= 100");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>implementation that panics with different error messages</span></p>
<p>The test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is the string that the <code>Guess::new</code> method panics with. We
need to specify the entire panic message that we expect.</p>
<p>To see what happens when a <code>should_panic</code> test with an expected message fails,
let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-cairo  noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &lt;= 100");
        } else if value &gt; 100 {
            panic!("Guess must be &gt;= 1");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_04_new_bug (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_04_new_bug_unittest) no_listing_04_new_bug v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_04_new_bug package
Running 1 test(s) from src/
[FAIL] no_listing_04_new_bug::tests::greater_than_100

Failure data:
    Incorrect panic data
    Actual:    [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203e3d2031, 0x12] (Guess must be &gt;= 1)
    Expected:  [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203c3d20313030, 0x14] (Guess must be &lt;= 100)

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_04_new_bug::tests::greater_than_100

</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string. The panic message
that we did get in this case was <code>Guess must be &gt;= 1</code>. Now we can start figuring
out where our bug is!</p>
<h2 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h2>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>scarb test</code> the name of
the test you want to run as an argument.</p>
<p>To demonstrate how to run a single test, we’ll first create two test functions,
as shown in Listing 10-9, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert!(result == 5, "result is not 5");
    }
}
</code></pre>
<p>with two different names</span></p>
<p>We can pass the name of any test function to <code>scarb test</code> to run only that test:</p>
<pre><code class="language-shell">$ scarb test add_two_and_two
     Running test listing_10_07 (snforge test)
   Compiling test(listing_10_07_unittest) listing_10_07 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_07 package
Running 1 test(s) from src/
[PASS] listing_10_07::tests::add_two_and_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~15240)
Tests: 1 passed, 0 failed, 0 ignored, 1 filtered out


</code></pre>
<p>Only the test with the name <code>add_two_and_two</code> ran; the other test didn’t match
that name. The test output lets us know we had one more test that didn’t run by
displaying <code>1 filtered out;</code> at the end.</p>
<p>We can also specify part of a test name, and any test whose name contains that
value will be run.</p>
<h2 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h2>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>scarb test</code>. Rather than listing
as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>#[ignore]</code> attribute to exclude them, as shown
here:</p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() { // code that takes an hour to run
    }
}
</code></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now
when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_05_ignore_tests (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_05_ignore_tests_unittest) no_listing_05_ignore_tests v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_05_ignore_tests package
Running 2 test(s) from src/
[IGNORE] no_listing_05_ignore_tests::tests::expensive_test
[PASS] no_listing_05_ignore_tests::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 1 passed, 0 failed, 1 ignored, 0 filtered out


</code></pre>
<p>The <code>expensive_test</code> function is listed as ignored.</p>
<p>When you’re at a point where it makes sense to check the results of the ignored
tests and you have time to wait for the results, you can run
<code>scarb test --include-ignored</code> to run all tests, whether they’re ignored or not.</p>
<h2 id="testing-recursive-functions-or-loops"><a class="header" href="#testing-recursive-functions-or-loops">Testing Recursive Functions or Loops</a></h2>
<p>When testing recursive functions or loops, the test is instantiated by default
with a maximum amount of gas that it can consume. This prevents running infinite
loops or consuming too much gas, and can help you benchmark the efficiency of
your implementations. This value is assumed reasonably large enough, but you can
override it by adding the <code>#[available_gas(&lt;Number&gt;)]</code> attribute to the test
function. The following example shows how to use it:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<h2 id="benchmarking-cairo-programs"><a class="header" href="#benchmarking-cairo-programs">Benchmarking Cairo Programs</a></h2>
<p>Starknet Foundry contains a profiling feature that is useful to analyze and
optimize the performance of your Cairo programs.</p>
<p>The <a href="https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/profiling.html">profiling</a> feature generates execution traces for successful
tests, which are used to create profile outputs. This allows you to benchmark
specific parts of your code.</p>
<p>To use the profiler, you will need to:</p>
<ol>
<li>Install <a href="https://github.com/software-mansion/cairo-profiler">Cairo Profiler</a> from Software Mansion.</li>
<li>Install <a href="https://go.dev/doc/install">Go</a>, <a href="https://www.graphviz.org/download/">Graphviz</a> and <a href="https://github.com/google/pprof?tab=readme-ov-file#building-pprof">pprof</a>, all of them are
required to visualize the generated profile output.</li>
<li>Run <code>snforge test --build-profile</code> command, which generates a trace file for
each passing test, stored in the <em>snfoundry_trace</em> directory of your project.
This command also generates the corresponding output files in the <em>profile</em>
directory.</li>
<li>Run <code>go tool pprof -http=":8000" path/to/profile/output.pb.gz</code> to analyse a
profile. This will start a web server at the specified port.</li>
</ol>
<p>Let's reuse the <code>sum_n</code> function studied above:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<p>After generating the trace file and the profile output, running <code>go tool pprof</code>
in your project will start the web server where you can find many useful
information about the test that you ran:</p>
<ul>
<li>
<p>The test includes one function call, corresponding to the call to the test
function. Calling <code>sum_n</code> multiple times in the test function will still
return 1 call. This is because <code>snforge</code> simulates a contract call when
executing a test.</p>
</li>
<li>
<p>The <code>sum_n</code> function execution uses 256 Cairo steps:</p>
</li>
</ul>
<div align="center">
    <img src="pprof-steps.png" alt="pprof number of steps" width="800px"/>
</div>
<p>Other information is also available such as memory holes (i.e., unused memory
cells) or builtins usage. The Cairo Profiler is under active development, and
many other features will be made available in the future.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch10-01-how_to_write_tests&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;This informs scarb to treat the function as a test and not source code.\n&quot;,&quot;id&quot;:&quot;c7365cd4-c0cf-4d92-8e42-c47ab8936775&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;#[test]&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;What is the annotation you add to a function to indicate that it's a test?&quot;}},{&quot;context&quot;:&quot;`should_err` does not exist in Cairo &amp;mdash; tests that return `Result` will pass even if the result is an `Err`.\n&quot;,&quot;id&quot;:&quot;cd77485f-723a-4978-8da6-c4ca3df44c44&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\n#[test]\n#[should_err]\nfn test() -&gt; Result&lt;usize, String&gt; {\n    f(0)\n}\n```\n  &quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\n#[test]\nfn test() {\n    assert!(f(0).is_err());\n}\n```\n&quot;,&quot;```\n#[test]\n#[should_panic]\nfn test() {\n    f(0).unwrap();\n}\n```\n  &quot;,&quot;```\n#[test]\nfn test() {\n    assert!(match f(0) {\n        Ok(_) =&gt; false,\n        Err(_) =&gt; true\n    });\n}\n```\n  &quot;],&quot;prompt&quot;:&quot;Let's say you have a function with the type signature:\n\n```\nfn f(x: usize) -&gt; Result&lt;usize, ByteArray&gt;;\n```\n\nAnd you want to test that `f(0)` should return `Err(_)`.\nWhich of the following is **NOT** a valid way to test that?\n&quot;}},{&quot;context&quot;:&quot;The expected string `\&quot;Zerodivisionerror not allowed!\&quot;` should be exactly\nthe same as the panic string `\&quot;ZeroDivisionError not allowed!\&quot;`\n&quot;,&quot;id&quot;:&quot;4becac9f-5173-4439-bd1f-e1e9958423ab&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;No&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Yes&quot;],&quot;prompt&quot;:&quot;Does the test pass?\n```\nfn division_operation(number1: u16, number2: u16) -&gt; u16 {\n    if number2 == 0 {\n        panic!(\&quot;ZeroDivisionError not allowed!\&quot;);\n    }\n    let result = number1 / number2;\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{division_operation};\n\n    #[test]\n    #[should_panic(expected: (\&quot;Zerodivisionerror not allowed!\&quot;,))]\n    fn test_division_operation() {\n        division_operation(10, 0);\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;One ignored: `test_addition`, because it has the `ignore` attribute\n\nOne filtered out: `division_with_available_gas`, because its name doesn't match the filter `test_`\n\nZero failed\n\nTwo passed: `test_multiplication` and `test_subtraction`, because all the conditions in the assertions are true\n&quot;,&quot;id&quot;:&quot;0b3385b4-069f-4883-ab3f-6feb8ebf72f8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Tests: 1 passed, 0 failed, 0 ignored, 3 filtered out&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Error: test result: FAILED. 1 passed; 1 failed; 1 ignored;&quot;,&quot;Tests: 1 passed, 0 failed, 3 ignored, 0 filtered out&quot;,&quot;Tests: 3 passed, 0 failed, 1 ignored, 0 filtered out&quot;],&quot;prompt&quot;:&quot;What is the output when these tests are run with the command `scarb test division_function`\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    #[ignore]\n    fn test_addition() {\n        assert_ne!((5 + 4), 5);\n    }\n\n    #[test]\n    fn division_function() {\n        assert_eq!((10_u8 / 5), 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_ne!((3 * 2), 8);\n        assert_eq!((5 * 5), 25);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert!((12 - 11) == 1, \&quot;The first argument was false\&quot;);\n    }\n}\n```\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h1>
<p>We'll think about tests in terms of two main categories: unit tests and
integration tests. Unit tests are small and more focused, testing one module in
isolation at a time, and can test private functions. Integration tests use your
code in the same way any other external code would, using only the public
interface and potentially exercising multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. You’ll put unit tests in the <code>src</code> directory in each file with the
code that they’re testing.</p>
<p>The convention is to create a module named <code>tests</code> in each file to contain the
test functions and to annotate the module with <code>#[cfg(test)]</code> attribute.</p>
<h3 id="the-tests-module-and-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest">The Tests Module and <code>#[cfg(test)]</code></a></h3>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Cairo to compile and run
the test code only when you run <code>scarb test</code>, not when you run <code>scarb build</code>.
This saves compile time when you only want to build the project and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files
as the code, you’ll use <code>#[cfg(test)]</code> to specify that they shouldn’t be
included in the compiled result.</p>
<p>Recall that when we created the new <code>adder</code> project in the first section of this
chapter, we wrote this first test:</p>
<pre><code class="language-cairo">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>The attribute <code>cfg</code> stands for <em>configuration</em> and tells Cairo that the
following item should only be included given a certain configuration option. In
this case, the configuration option is <code>test</code>, which is provided by Cairo for
compiling and running tests. By using the <code>cfg</code> attribute, Cairo compiles our
test code only if we actively run the tests with <code>scarb test</code>. This includes any
helper functions that might be within this module, in addition to the functions
annotated with <code>#[test]</code>.</p>
<h3 id="testing-private-functions"><a class="header" href="#testing-private-functions">Testing Private Functions</a></h3>
<p>There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Cairo's privacy rules do allow you to test private functions.
Consider the code below with the private function <code>internal_adder</code>.</p>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add(a: u32, b: u32) -&gt; u32 {
    internal_adder(a, 2)
}

fn internal_adder(a: u32, b: u32) -&gt; u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p>Testing a private function</span></p>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>. Tests are just
Cairo code, and the tests module is just another module. As we discussed in the
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Paths for Referring to an Item in the Module Tree"</a>
section, items in child modules can use the items in their ancestor modules. In
this test, we bring the <code>tests</code> module’s parent <code>internal_adder</code> into scope with
<code>use super::internal_adder;</code> and then the test can call <code>internal_adder</code>. If you
don’t think private functions should be tested, there’s nothing in Cairo that
will compel you to do so.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests use your library in the same way any other code would. Their
purpose is to test whether many parts of your library work together correctly.
Units of code that work correctly on their own could have problems when
integrated, so test coverage of the integrated code is important as well. To
create integration tests, you first need a <em>tests</em> directory.</p>
<h3 id="the-tests-directory"><a class="header" href="#the-tests-directory">The <em>tests</em> Directory</a></h3>
<p>We create a <em>tests</em> directory at the top level of our project directory, next to
<em>src</em>. Scarb knows to look for integration test files in this directory. We can
then make as many test files as we want, and Scarb will compile each of the
files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing
10-10 still in the <em>src/lib.cairo</em> file, make a <em>tests</em>
directory, and create a new file named <em>tests/integration_test.cairo</em>. Your
directory structure should look like this:</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    └── integration_tests.cairo

</code></pre>
<p>Enter the code in Listing 10-11 into the
<em>tests/integration_test.cairo</em> file:</p>
<p><span class="caption">Filename: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo  noplayground">use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>10-11: An integration test of a function in the <code>adder</code>
crate</span></p>
<p>Each file in the <code>tests</code> directory is a separate crate, so we need to bring our
library into each test crate’s scope. For that reason we add
<code>use adder::add_two</code> at the top of the code, which we didn’t need in the unit
tests.</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.cairo</em> with
<code>#[cfg(test)]</code>. Scarb treats the tests directory specially and compiles files in
this directory only when we run <code>scarb test</code>. Run <code>scarb test</code> now:</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(adder_integrationtest) adder_integrationtest v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Running 1 test(s) from src/
[PASS] adder::tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>The two sections of output include the unit tests and the integration tests.
Note that if any test in a section fails, the following sections will not be
run. For example, if a unit test fails, there won’t be any output for
integration tests because those tests will only be run if all unit tests are
passing.</p>
<p>The first displayed section is for the integration tests. Each integration test
file has its own section, so if we add more files in the <em>tests</em> directory,
there will be more integration test sections.</p>
<p>The second displayed section is the same as we’ve been seeing: one line for each
unit test (one named add that we added just above) and then a summary line for
the unit tests.</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument of the option -f to <code>scarb test</code> like for
instance <code>scarb test -f integration_tests::internal</code>. To run all the tests in a
particular integration test file, we use the same option of <code>scarb test</code> but
using only the name of the file.</p>
<p>Then, to run all of our integration tests, we can just add a filter to only run
tests whose path contains <em>integration_tests</em>.</p>
<pre><code class="language-shell">$ scarb test -f integration_tests
     Running test adder (snforge test)

</code></pre>
<p>We see that in the second section for the unit tests, 1 has been filtered out
because it is not in the <em>integration_tests</em> file.</p>
<h3 id="submodules-in-integration-tests"><a class="header" href="#submodules-in-integration-tests">Submodules in Integration Tests</a></h3>
<p>As you add more integration tests, you might want to make more files in the
<em>tests</em> directory to help organize them; for example, you can group the test
functions by the functionality they’re testing. As mentioned earlier, each file
in the tests directory is compiled as its own separate crate, which is useful
for creating separate scopes to more closely imitate the way end users will be
using your crate. However, this means files in the tests directory don’t share
the same behavior as files in <em>src</em> do, as you learned in Chapter
7 regarding how to separate code into modules and
files.</p>
<p>The different behavior of tests directory files is most noticeable when you have
a set of helper functions to use in multiple integration test files and you try
to follow the steps in the
<a href="ch07-05-separating-modules-into-different-files.html">Separating Modules into Different Files</a>
section of Chapter 7 to extract them into a common
module. For example, if we create <em>tests/common.cairo</em> and place a function
named <code>setup</code> in it, we can add some code to <code>setup</code> that we want to call from
multiple test functions in multiple test files:</p>
<p><span class="caption">Filename: tests/common.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn setup() {
    println!("Setting up tests...");
}
</code></pre>
<p><span class="caption">Filename: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo  noplayground">use adder::it_adds_two;

#[test]
fn internal() {
    assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
}
</code></pre>
<p><span class="caption">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn it_adds_two(a: u8, b: u8) -&gt; u8 {
    a + b
}

#[cfg(test)]
mod tests {
    #[test]
    fn add() {
        assert_eq!(4, super::it_adds_two(2, 2));
    }
}
</code></pre>
<p>When we run the tests with <code>scarb test</code>, we’ll see a new section in the test
output for the <em>common.cairo</em> file, even though this file doesn’t contain any
test functions nor did we call the setup function from anywhere:</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
   Compiling test(adder_integrationtest) adder_integrationtest v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>To avoid systematically getting a section for each file of the <em>tests</em> folder,
we also have the option of making the <code>tests/</code> directory behave like a regular
crate, by adding a <code>tests/lib.cairo</code> file. In that case, the <code>tests</code> directory
will no longer compile as one crate per file, but as one crate for the whole
directory.</p>
<p>Let's create this <em>tests/lib.cairo</em> file :</p>
<p><span class="caption">Filename: tests/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">mod common;
mod integration_tests;
</code></pre>
<p>The project directory will now look like this :</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    ├── common.cairo
    ├── integration_tests.cairo
    └── lib.cairo
</code></pre>
<p>When we run the <code>scarb test</code> command again, here is the output :</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
   Compiling test(adder_tests) adder_tests v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Running 1 test(s) from tests/
[PASS] adder_tests::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~13840)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>This way, only the test functions will be tested and the <code>setup</code> function can be
imported without being tested.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Cairo's testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Cairo's type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch10-02-testing-organization&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;All unit tests in a given file have access to that file's private functions, regardless of being in `mod tests` or not.\n&quot;,&quot;id&quot;:&quot;3da96b29-d975-4cd8-a8eb-b1a6bd9b5c0a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It gives your tests access to private functions&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It can reduce the size of generated compiler artifacts&quot;,&quot;It can improve compile times&quot;,&quot;It separates test helper functions from library code&quot;],&quot;prompt&quot;:&quot;Which of the following is **NOT** a good reason to wrap unit tests in `#[cfg(test)] mod tests { ... }`?\n&quot;}},{&quot;context&quot;:&quot;To run all integration tests, add a filter to `scarb test` that contains the module path containing the integration tests.\n&quot;,&quot;id&quot;:&quot;2b553604-8201-4fad-90d6-1b63d99de219&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;By running `scarb test` with a filter for the integration tests&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;By running `scarb cairo-test`&quot;,&quot;By running `scarb cairo-build` with a filter for the test&quot;,&quot;By running `scarb execute`&quot;],&quot;prompt&quot;:&quot;How do you run integration tests in a Cairo project?&quot;}},{&quot;context&quot;:&quot;Unit tests and integration tests serve different purposes and have distinct characteristics:\n\n- Unit tests:\n\t- Focus on testing individual functions or modules in isolation.\n\t- Aim to ensure the correctness of small, self-contained units of code.\n\t- Often test private functions and implementation details.\n\t- Located in the same file as the code being tested, typically in a `#[cfg(test)]` module.\n\n- Integration tests:\n\t- Focus on testing the interaction and behavior of multiple modules or components working together.\n\t- Verify that different parts of the system integrate correctly and produce the expected results.\n\t- Use the public API of the library or application being tested.\n\t- Located in the _tests/_ directory, separate from the main code files.\n&quot;,&quot;id&quot;:&quot;93d3c7fb-14af-41f6-aba2-7ceff84a163b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Unit tests focus on testing individual functions or modules in isolation, while\nintegration tests verify the interaction and behavior of multiple modules or components working\ntogether.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Unit tests use the `#[test]` attribute, while integration tests use the `#[cfg(test)]` attribute.&quot;,&quot;Unit tests are limited to testing a single module, while integration tests can test multiple modules but not their interactions.&quot;,&quot;Unit tests are written in a separate file, while integration tests are written in the same file as the code being tested.&quot;],&quot;prompt&quot;:&quot;What is the difference between unit tests and integration tests?&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-features-iterators-and-closures"><a class="header" href="#functional-language-features-iterators-and-closures">Functional Language Features: Iterators and Closures</a></h1>
<p>Cairo’s design has taken strong inspiration from Rust, which itself has taken
inspiration from many existing languages and techniques, and one significant
influence is <em>functional programming</em>. Programming in a functional style often
includes using functions as values by passing them in arguments, returning them
from other functions, assigning them to variables for later execution, and so
forth.</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Cairo that are similar to
features in Rust and many languages often referred to as functional.</p>
<p>More specifically, we’ll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements<!-- * How to use closures and iterators to improve the I/O project in Chapter 12
<!-- ^TODO: once we have a hands-on, pure cairo project, we can add this -->
<!-- * The performance of closures and iterators (Spoiler alert: they’re faster than
  you might think!) --> -->
<!-- ^TODO: once closures and iterators become more widespread and show consequent performance gains. -->
</li>
</ul>
<p>We’ve already covered some other Cairo features, such as pattern matching and
enums, that are also influenced by the Rust and the functional style. Because
mastering closures and iterators is an important part of writing idiomatic, fast
Cairo code, we’ll devote this entire chapter to them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures are anonymous functions you can save in a variable or pass as arguments
to other functions. You can create the closure in one place and then call the
closure elsewhere to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<blockquote>
<p>Note: Closures were introduced in Cairo 2.9 and are still under development.
Some new features will be introduced in future versions of Cairo, so this page
will evolve accordingly.</p>
</blockquote>
<h2 id="understanding-closures"><a class="header" href="#understanding-closures">Understanding Closures</a></h2>
<p>When writing Cairo programs, you'll often need to pass behavior as a parameter
to another function. Closures provide a way to define this behavior inline,
without creating a separate named function. They are particularly valuable when
working with collections, error handling, and any scenario where you want to
customize how a function behaves using a function as a parameter.</p>
<p>Consider a simple example where we want to process numbers differently based on
some condition. Instead of writing multiple functions, we can use closures to
define the behavior where we need it:</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));
<span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<p>The closure's arguments go between the pipes (<code>|</code>). Note that we don't have to
specify the types of arguments and of the return value (see <code>double</code> closure),
they will be inferred from the closure usage, as it is done for any variables.
Of course, if you use a closure with different types, you will get a
<code>Type annotations needed</code> error, telling you that you have to choose and specify
the closure argument types.</p>
<p>The body is an expression, on a single line without <code>{}</code> like <code>double</code> or on
several lines with <code>{}</code> like <code>sum</code>.</p>
<h2 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h2>
<p>One of the interests of closures is that they can include bindings from their
enclosing scope.</p>
<p>In the following example, <code>my_closure</code> use a binding to <code>x</code> to compute
<code>x + value * 3</code>.</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span>    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));
<span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Note that, at the moment, closures are still not allowed to capture mutable
variables, but this will be supported in future Cairo versions.</p>
</blockquote>
<h2 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h2>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 11-1. In this example, we’re defining a
closure and storing it in a variable rather than defining the closure in the
spot we pass it as an argument as we did in Listing 13-1.</p>
<pre><code class="language-cairo"><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!("Today, run for {} minutes!", expensive_closure(intensity));
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre>
<p>annotations of the parameter and return value types in the closure</p>
<!-- TODO: rework the example to add a println!(...) inside the closure -->
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces to
line up the relevant parts. This illustrates how closure syntax is similar to
function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<pre><code class="language-cairo  ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let array = array![];</code> needing either type annotations or values of
some type to be inserted into the <code>array</code> for Cairo to be able to infer the
type.</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing
11-2 shows the definition of a short closure that
just returns the value it receives as a parameter. This closure isn’t very
useful except for the purposes of this example. Note that we haven’t added any
type annotations to the definition. Because there are no type annotations, we
can call the closure with any type, which we’ve done here with <code>u64</code> the first
time. If we then try to call <code>example_closure</code> with a <code>u32</code>, we’ll get an error.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(5_u64);
    let n = example_closure(5_u32);
<span class="boring">}
</span></code></pre>
<p>Attempting to call a closure whose types are inferred with two different types</p>
<p>The compiler gives us this error:</p>
<pre><code>$ scarb build 
   Compiling listing_closure_different_types v0.1.0 (listings/ch11-functional-features/listing_closure_different_types/Scarb.toml)
warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:7:9
    let s = example_closure(5_u64);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:9
    let n = example_closure(5_u32);
        ^

error: Trait has no implementation in context: core::ops::function::Fn::&lt;{closure@listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:5:27: 5:30}, (core::integer::u32,)&gt;.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:13
    let n = example_closure(5_u32);
            ^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `listing_closure_different_types` due to 1 previous error and 2 warnings

</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>u64</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>u64</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
<!-- TODO: add a section on capturing references or moving ownership once supported -->
<h2 id="moving-captured-values-out-of-closures-and-the-fn-traits"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the <code>Fn</code> Traits</a></h2>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure). A closure body can
do any of the following: move a captured value out of the closure, neither move
nor mutate the value, or capture nothing from the environment to begin with.</p>
<!-- TODO: later, closures will be able to do any of the followings: -->
<!-- A closure body can
do any of the following: move a captured value out of the closure, mutate the
captured value, neither move nor mutate the value, or capture nothing from the
environment to begin with. -->
<p>The way a closure captures and handles values from the environment affects which
traits the closure implements, and traits are how functions and structs can
specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<ol>
<li>
<p><code>FnOnce</code> applies to closures that can be called once. All closures implement
at least this trait, because all closures can be called. A closure that moves
captured values out of its body will only implement <code>FnOnce</code> and none of the
other <code>Fn</code> traits, because it can only be called once.</p>
</li>
<li>
<p><code>Fn</code> applies to closures that don’t move captured values out of their body
and that don’t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.</p>
</li>
</ol>
<!-- TODO: later on,
2. `FnMut` applies to closures that don’t move captured values out of their
   body, but that might mutate the captured values. These closures can be
   called more than once.
-->
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>OptionTrait&lt;T&gt;</code>
that we used in Listing 13-1:</p>
<pre><code class="language-cairo  ignore">pub impl OptionTraitImpl&lt;T&gt; of OptionTrait&lt;T&gt; {
    #[inline]
    fn unwrap_or_else&lt;F, +Drop&lt;F&gt;, impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T], +Drop&lt;func::Output&gt;&gt;(
        self: Option&lt;T&gt;, f: F,
    ) -&gt; T {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the
<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the
<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an
<code>Option&lt;ByteArray&gt;</code>, for example, will get a <code>ByteArray</code>.</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type
parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is the
closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>The trait bound specified on the generic type <code>F</code> is
<code>impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T]</code>, which means <code>F</code> must be able
to be called once, take no arguments (the unit type <code>()</code> is used), and return a
<code>T</code> as output. Using <code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of
<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be
called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all closures
implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all two kinds of closures and is as
flexible as it can be.</p>
<!-- TODO: all _three_ types of closures -->
<!-- > Note: Functions can implement all two of the `Fn` traits too. If what we
> want to do doesn’t require capturing a value from the environment, we can use
> the name of a function rather than a closure where we need something that
> implements one of the `Fn` traits. For example, on an `Option<Vec<T>>` value,
> we could call `unwrap_or_else(Vec::new)` to get a new, empty vector if the
> value is `None`. -->
<!-- TODO: function _do not_ implement the `Fn` traits yet. -->
<!-- TODO: all _three_ types of the `Fn` traits -->
<!-- TODO: add examples using FnMut from a corelib function once it exists. -->
<p>The <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
<p>Under the hood, closures are implemented through <code>FnOnce</code> and <code>Fn</code> traits.
<code>FnOnce</code> is implemented for closures that may consume captured variables, where
<code>Fn</code> is implemented for closures that capture only copyable variables.</p>
<h2 id="implementing-your-functional-programming-patterns-with-closures"><a class="header" href="#implementing-your-functional-programming-patterns-with-closures">Implementing Your Functional Programming Patterns with Closures</a></h2>
<p>Another great interest of closures is that, like any type of variables, you can
pass them as function arguments. This mechanism is massively used in functional
programming, through classic functions like <code>map</code>, <code>filter</code> or <code>reduce</code>.</p>
<p>Here is a potential implementation of <code>map</code> to apply a same function to all the
items of an array:</p>
<pre><code class="language-cairo  noplayground">#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;func::Output&gt; {
        let mut output: Array&lt;func::Output&gt; = array![];
        for elem in self {
            output.append(f(elem));
        }
        output
    }
}
<span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Note that, due to a bug in inlining analysis, this analysis process should be
disabled using <code>#[inline(never)]</code>.</p>
</blockquote>
<p>In this implementation, you'll notice that, while <code>T</code> is the element type of the
input array <code>self</code>, the element type of the output array is defined by the
output type of the <code>f</code> closure (the associated type <code>func::Output</code> from the <code>Fn</code>
trait).</p>
<p>This means that your <code>f</code> closure can return the same type of elements like as
for <code>_double</code> in the following code, or any other type of elements like as for
<code>_another</code>:</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span>    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);
<span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Currently, Cairo 2.9 provides an experimental feature allowing you to specify
the associated type of trait, using
<code>experimental-features = ["associated_item_constraints"]</code> in your
<code>Scarb.toml</code>.</p>
</blockquote>
<p>Let's say we want to implement the <code>filter</code> function for arrays, to filter out
elements which do not match a criteria. This criteria will be provided through a
closure which takes an element as input, and return <code>true</code> if the element has to
be kept, <code>false</code> otherwise. That means, we need to specify that the closure must
return a <code>boolean</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter&lt;
        T,
        +Copy&lt;T&gt;,
        +Drop&lt;T&gt;,
        F,
        +Drop&lt;F&gt;,
        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
        +Drop&lt;func::Output&gt;,
    &gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;T&gt; {
        let mut output: Array&lt;T&gt; = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        }
        output
    }
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span>    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
<span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>Now, let's learn about more advanced features offered by Cairo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-data-structures"><a class="header" href="#custom-data-structures">Custom Data Structures</a></h1>
<p>When you first start programming in Cairo, you'll likely want to use arrays
(<code>Array&lt;T&gt;</code>) to store collections of data. However, you will quickly realize
that arrays have one big limitation - the data stored in them is immutable. Once
you append a value to an array, you can't modify it.</p>
<p>This can be frustrating when you want to use a mutable data structure. For
example, say you're making a game where the players have a level, and they can
level up. You might try to store the level of the players in an array:</p>
<pre><code class="language-cairo noplayground">    let mut level_players = array![5, 1, 10];
</code></pre>
<p>But then you realize you can't increase the level at a specific index once it's
set. If a player dies, you cannot remove it from the array unless he happens to
be in the first position.</p>
<p>Fortunately, Cairo provides a handy built-in
<a href="./ch03-02-dictionaries.html">dictionary type</a> called <code>Felt252Dict&lt;T&gt;</code> that allows
us to simulate the behavior of mutable data structures. Let's first explore how
to create a struct that contains, among others, a <code>Felt252Dict&lt;T&gt;</code>.</p>
<blockquote>
<p>Note: Several concepts used in this chapter were already presented earlier in
the book. We recommend checking out the following chapters if you need to
revise them: <a href="ch05-00-using-structs-to-structure-related-data.html">Structs</a>,
<a href="./ch05-03-method-syntax.html">Methods</a>,
<a href="./ch08-00-generic-types-and-traits.html">Generic types</a>,
<a href="./ch08-02-traits-in-cairo.html">Traits</a>.</p>
</blockquote>
<h2 id="dictionaries-as-struct-members"><a class="header" href="#dictionaries-as-struct-members">Dictionaries as Struct Members</a></h2>
<p>Defining dictionaries as struct members is possible in Cairo but correctly
interacting with them may not be entirely seamless. Let's try implementing a
custom <em>user database</em> that will allow us to add users and query them. We will
need to define a struct to represent the new type and a trait to define its
functionality:</p>
<pre><code class="language-cairo noplayground">struct UserDatabase&lt;T&gt; {
    users_updates: u64,
    balances: Felt252Dict&lt;T&gt;,
}

trait UserDatabaseTrait&lt;T&gt; {
    fn new() -&gt; UserDatabase&lt;T&gt;;
    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T);
    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T;
}
</code></pre>
<p>Our new type <code>UserDatabase&lt;T&gt;</code> represents a database of users. It is generic
over the balances of the users, giving major flexibility to whoever uses our
data type. Its two members are:</p>
<ul>
<li><code>users_updates</code>, the number of users updates in the dictionary.</li>
<li><code>balances</code>, a mapping of each user to its balance.</li>
</ul>
<p>The database core functionality is defined by <code>UserDatabaseTrait</code>. The following
methods are defined:</p>
<ul>
<li><code>new</code> for easily creating new <code>UserDatabase</code> types.</li>
<li><code>update_user</code> to update the balance of users in the database.</li>
<li><code>get_balance</code> to find user's balance in the database.</li>
</ul>
<p>The only remaining step is to implement each of the methods in
<code>UserDatabaseTrait</code>, but since we are working with
<a href="./ch08-00-generic-types-and-traits.html">Generic types</a> we also need to correctly
establish the requirements of <code>T</code> so it can be a valid <code>Felt252Dict&lt;T&gt;</code> value
type:</p>
<ol>
<li><code>T</code> should implement the <code>Copy&lt;T&gt;</code> since it's required for getting values
from a <code>Felt252Dict&lt;T&gt;</code>.</li>
<li>All value types of a dictionary implement the <code>Felt252DictValue&lt;T&gt;</code>, our
generic type should do as well.</li>
<li>To insert values, <code>Felt252DictTrait&lt;T&gt;</code> requires all value types to be
droppable (implement the <code>Drop&lt;T&gt;</code> trait).</li>
</ol>
<p>The implementation, with all restrictions in place, would be as follows:</p>
<pre><code class="language-cairo noplayground">impl UserDatabaseImpl&lt;T, +Felt252DictValue&lt;T&gt;&gt; of UserDatabaseTrait&lt;T&gt; {
    // Creates a database
    fn new() -&gt; UserDatabase&lt;T&gt; {
        UserDatabase { users_updates: 0, balances: Default::default() }
    }

    // Get the user's balance
    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T {
        self.balances.get(name)
    }

    // Add a user
    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T) {
        self.balances.insert(name, balance);
        self.users_updates += 1;
    }
}
</code></pre>
<p>Our database implementation is almost complete, except for one thing: the
compiler doesn't know how to make a <code>UserDatabase&lt;T&gt;</code> go out of scope, since it
doesn't implement the <code>Drop&lt;T&gt;</code> trait, nor the <code>Destruct&lt;T&gt;</code> trait. Since it has
a <code>Felt252Dict&lt;T&gt;</code> as a member, it cannot be dropped, so we are forced to
implement the <code>Destruct&lt;T&gt;</code> trait manually (refer to the
<a href="ch04-01-what-is-ownership.html#no-op-destruction-the-drop-trait">Ownership</a>
chapter for more information). Using <code>#[derive(Destruct)]</code> on top of the
<code>UserDatabase&lt;T&gt;</code> definition won't work because of the use of <a href="./ch08-00-generic-types-and-traits.html">Generic
types</a> in the struct definition. We need to code the <code>Destruct&lt;T&gt;</code>
trait implementation by ourselves:</p>
<pre><code class="language-cairo noplayground">impl UserDatabaseDestruct&lt;T, +Drop&lt;T&gt;, +Felt252DictValue&lt;T&gt;&gt; of Destruct&lt;UserDatabase&lt;T&gt;&gt; {
    fn destruct(self: UserDatabase&lt;T&gt;) nopanic {
        self.balances.squash();
    }
}
</code></pre>
<p>Implementing <code>Destruct&lt;T&gt;</code> for <code>UserDatabase</code> was our last step to get a fully
functional database. We can now try it out:</p>
<pre><code class="language-cairo"><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">
</span><span class="boring">struct UserDatabase&lt;T&gt; {
</span><span class="boring">    users_updates: u64,
</span><span class="boring">    balances: Felt252Dict&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait UserDatabaseTrait&lt;T&gt; {
</span><span class="boring">    fn new() -&gt; UserDatabase&lt;T&gt;;
</span><span class="boring">    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T);
</span><span class="boring">    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UserDatabaseImpl&lt;T, +Felt252DictValue&lt;T&gt;&gt; of UserDatabaseTrait&lt;T&gt; {
</span><span class="boring">    // Creates a database
</span><span class="boring">    fn new() -&gt; UserDatabase&lt;T&gt; {
</span><span class="boring">        UserDatabase { users_updates: 0, balances: Default::default() }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Get the user's balance
</span><span class="boring">    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T {
</span><span class="boring">        self.balances.get(name)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Add a user
</span><span class="boring">    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T) {
</span><span class="boring">        self.balances.insert(name, balance);
</span><span class="boring">        self.users_updates += 1;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UserDatabaseDestruct&lt;T, +Drop&lt;T&gt;, +Felt252DictValue&lt;T&gt;&gt; of Destruct&lt;UserDatabase&lt;T&gt;&gt; {
</span><span class="boring">    fn destruct(self: UserDatabase&lt;T&gt;) nopanic {
</span><span class="boring">        self.balances.squash();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let mut db = UserDatabaseTrait::&lt;u64&gt;::new();

    db.update_user('Alex', 100);
    db.update_user('Maria', 80);

    db.update_user('Alex', 40);
    db.update_user('Maria', 0);

    let alex_latest_balance = db.get_balance('Alex');
    let maria_latest_balance = db.get_balance('Maria');

    assert!(alex_latest_balance == 40, "Expected 40");
    assert!(maria_latest_balance == 0, "Expected 0");
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="simulating-a-dynamic-array-with-dicts"><a class="header" href="#simulating-a-dynamic-array-with-dicts">Simulating a Dynamic Array with Dicts</a></h2>
<p>First, let's think about how we want our mutable dynamic array to behave. What
operations should it support?</p>
<p>It should:</p>
<ul>
<li>Allow us to append items at the end.</li>
<li>Let us access any item by index.</li>
<li>Allow setting the value of an item at a specific index.</li>
<li>Return the current length.</li>
</ul>
<p>We can define this interface in Cairo like:</p>
<pre><code class="language-cairo noplayground">trait MemoryVecTrait&lt;V, T&gt; {
    fn new() -&gt; V;
    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
    fn at(ref self: V, index: usize) -&gt; T;
    fn push(ref self: V, value: T) -&gt; ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -&gt; usize;
}
</code></pre>
<p>This provides a blueprint for the implementation of our dynamic array. We named
it <em>MemoryVec</em> as it is similar to the <code>Vec&lt;T&gt;</code> data structure in Rust.</p>
<blockquote>
<p>Note: The core library of Cairo already includes a <code>Vec&lt;T&gt;</code> data structure,
strictly used as a storage type in smart contracts. To differentiate our data
structure from the core library's one, we named our implementation
<em>MemoryVec</em>.</p>
</blockquote>
<h3 id="implementing-a-dynamic-array-in-cairo"><a class="header" href="#implementing-a-dynamic-array-in-cairo">Implementing a Dynamic Array in Cairo</a></h3>
<p>To store our data, we'll use a <code>Felt252Dict&lt;T&gt;</code> which maps index numbers (felts)
to values. We'll also store a separate <code>len</code> field to track the length.</p>
<p>Here is what our struct looks like. We wrap the type <code>T</code> inside <code>Nullable</code>
pointer to allow using any type <code>T</code> in our data structure, as explained in the
<a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">Dictionaries</a> section:</p>
<pre><code class="language-cairo noplayground"><span class="boring">
</span><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">use core::nullable::NullableTrait;
</span><span class="boring">use core::num::traits::WrappingAdd;
</span><span class="boring">
</span><span class="boring">trait MemoryVecTrait&lt;V, T&gt; {
</span><span class="boring">    fn new() -&gt; V;
</span><span class="boring">    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
</span><span class="boring">    fn at(ref self: V, index: usize) -&gt; T;
</span><span class="boring">    fn push(ref self: V, value: T) -&gt; ();
</span><span class="boring">    fn set(ref self: V, index: usize, value: T);
</span><span class="boring">    fn len(self: @V) -&gt; usize;
</span><span class="boring">}
</span><span class="boring">
</span>struct MemoryVec&lt;T&gt; {
    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
    len: usize,
}
<span class="boring">
</span><span class="boring">impl DestructMemoryVec&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;MemoryVec&lt;T&gt;&gt; {
</span><span class="boring">    fn destruct(self: MemoryVec&lt;T&gt;) nopanic {
</span><span class="boring">        self.data.squash();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl MemoryVecImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of MemoryVecTrait&lt;MemoryVec&lt;T&gt;, T&gt; {
</span><span class="boring">    fn new() -&gt; MemoryVec&lt;T&gt; {
</span><span class="boring">        MemoryVec { data: Default::default(), len: 0 }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">        if index &lt; self.len() {
</span><span class="boring">            Some(self.data.get(index.into()).deref())
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn at(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; T {
</span><span class="boring">        assert!(index &lt; self.len(), "Index out of bounds");
</span><span class="boring">        self.data.get(index.into()).deref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn push(ref self: MemoryVec&lt;T&gt;, value: T) -&gt; () {
</span><span class="boring">        self.data.insert(self.len.into(), NullableTrait::new(value));
</span><span class="boring">        self.len.wrapping_add(1_usize);
</span><span class="boring">    }
</span><span class="boring">    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
</span><span class="boring">        assert!(index &lt; self.len(), "Index out of bounds");
</span><span class="boring">        self.data.insert(index.into(), NullableTrait::new(value));
</span><span class="boring">    }
</span><span class="boring">    fn len(self: @MemoryVec&lt;T&gt;) -&gt; usize {
</span><span class="boring">        *self.len
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Since we again have <code>Felt252Dict&lt;T&gt;</code> as a struct member, we need to implement
the <code>Destruct&lt;T&gt;</code> trait to tell the compiler how to make <code>MemoryVec&lt;T&gt;</code> go out
of scope.</p>
<pre><code class="language-cairo noplayground"><span class="boring">
</span><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">use core::nullable::NullableTrait;
</span><span class="boring">use core::num::traits::WrappingAdd;
</span><span class="boring">
</span><span class="boring">trait MemoryVecTrait&lt;V, T&gt; {
</span><span class="boring">    fn new() -&gt; V;
</span><span class="boring">    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
</span><span class="boring">    fn at(ref self: V, index: usize) -&gt; T;
</span><span class="boring">    fn push(ref self: V, value: T) -&gt; ();
</span><span class="boring">    fn set(ref self: V, index: usize, value: T);
</span><span class="boring">    fn len(self: @V) -&gt; usize;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MemoryVec&lt;T&gt; {
</span><span class="boring">    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
</span><span class="boring">    len: usize,
</span><span class="boring">}
</span><span class="boring">
</span>impl DestructMemoryVec&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;MemoryVec&lt;T&gt;&gt; {
    fn destruct(self: MemoryVec&lt;T&gt;) nopanic {
        self.data.squash();
    }
}
<span class="boring">
</span><span class="boring">impl MemoryVecImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of MemoryVecTrait&lt;MemoryVec&lt;T&gt;, T&gt; {
</span><span class="boring">    fn new() -&gt; MemoryVec&lt;T&gt; {
</span><span class="boring">        MemoryVec { data: Default::default(), len: 0 }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">        if index &lt; self.len() {
</span><span class="boring">            Some(self.data.get(index.into()).deref())
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn at(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; T {
</span><span class="boring">        assert!(index &lt; self.len(), "Index out of bounds");
</span><span class="boring">        self.data.get(index.into()).deref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn push(ref self: MemoryVec&lt;T&gt;, value: T) -&gt; () {
</span><span class="boring">        self.data.insert(self.len.into(), NullableTrait::new(value));
</span><span class="boring">        self.len.wrapping_add(1_usize);
</span><span class="boring">    }
</span><span class="boring">    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
</span><span class="boring">        assert!(index &lt; self.len(), "Index out of bounds");
</span><span class="boring">        self.data.insert(index.into(), NullableTrait::new(value));
</span><span class="boring">    }
</span><span class="boring">    fn len(self: @MemoryVec&lt;T&gt;) -&gt; usize {
</span><span class="boring">        *self.len
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The key thing that makes this vector mutable is that we can insert values into
the dictionary to set or update values in our data structure. For example, to
update a value at a specific index, we do:</p>
<pre><code class="language-cairo noplayground"><span class="boring">
</span><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">use core::nullable::NullableTrait;
</span><span class="boring">use core::num::traits::WrappingAdd;
</span><span class="boring">
</span><span class="boring">trait MemoryVecTrait&lt;V, T&gt; {
</span><span class="boring">    fn new() -&gt; V;
</span><span class="boring">    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
</span><span class="boring">    fn at(ref self: V, index: usize) -&gt; T;
</span><span class="boring">    fn push(ref self: V, value: T) -&gt; ();
</span><span class="boring">    fn set(ref self: V, index: usize, value: T);
</span><span class="boring">    fn len(self: @V) -&gt; usize;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MemoryVec&lt;T&gt; {
</span><span class="boring">    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
</span><span class="boring">    len: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DestructMemoryVec&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;MemoryVec&lt;T&gt;&gt; {
</span><span class="boring">    fn destruct(self: MemoryVec&lt;T&gt;) nopanic {
</span><span class="boring">        self.data.squash();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl MemoryVecImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of MemoryVecTrait&lt;MemoryVec&lt;T&gt;, T&gt; {
</span><span class="boring">    fn new() -&gt; MemoryVec&lt;T&gt; {
</span><span class="boring">        MemoryVec { data: Default::default(), len: 0 }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">        if index &lt; self.len() {
</span><span class="boring">            Some(self.data.get(index.into()).deref())
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn at(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; T {
</span><span class="boring">        assert!(index &lt; self.len(), "Index out of bounds");
</span><span class="boring">        self.data.get(index.into()).deref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn push(ref self: MemoryVec&lt;T&gt;, value: T) -&gt; () {
</span><span class="boring">        self.data.insert(self.len.into(), NullableTrait::new(value));
</span><span class="boring">        self.len.wrapping_add(1_usize);
</span><span class="boring">    }
</span>    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
<span class="boring">    fn len(self: @MemoryVec&lt;T&gt;) -&gt; usize {
</span><span class="boring">        *self.len
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This overwrites the previously existing value at that index in the dictionary.</p>
<p>While arrays are immutable, dictionaries provide the flexibility we need for
modifiable data structures like vectors.</p>
<p>The implementation of the rest of the interface is straightforward. The
implementation of all the methods defined in our interface can be done as follow
:</p>
<pre><code class="language-cairo noplayground"><span class="boring">
</span><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">use core::nullable::NullableTrait;
</span><span class="boring">use core::num::traits::WrappingAdd;
</span><span class="boring">
</span><span class="boring">trait MemoryVecTrait&lt;V, T&gt; {
</span><span class="boring">    fn new() -&gt; V;
</span><span class="boring">    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
</span><span class="boring">    fn at(ref self: V, index: usize) -&gt; T;
</span><span class="boring">    fn push(ref self: V, value: T) -&gt; ();
</span><span class="boring">    fn set(ref self: V, index: usize, value: T);
</span><span class="boring">    fn len(self: @V) -&gt; usize;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MemoryVec&lt;T&gt; {
</span><span class="boring">    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
</span><span class="boring">    len: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DestructMemoryVec&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;MemoryVec&lt;T&gt;&gt; {
</span><span class="boring">    fn destruct(self: MemoryVec&lt;T&gt;) nopanic {
</span><span class="boring">        self.data.squash();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl MemoryVecImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of MemoryVecTrait&lt;MemoryVec&lt;T&gt;, T&gt; {
    fn new() -&gt; MemoryVec&lt;T&gt; {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; Option&lt;T&gt; {
        if index &lt; self.len() {
            Some(self.data.get(index.into()).deref())
        } else {
            None
        }
    }

    fn at(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; T {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec&lt;T&gt;, value: T) -&gt; () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    fn len(self: @MemoryVec&lt;T&gt;) -&gt; usize {
        *self.len
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The full implementation of the <code>MemoryVec</code> structure can be found in the
community-maintained library
<a href="https://github.com/keep-starknet-strange/alexandria/blob/main/packages/data_structures/src/vec.cairo">Alexandria</a>.</p>
<h2 id="simulating-a-stack-with-dicts"><a class="header" href="#simulating-a-stack-with-dicts">Simulating a Stack with Dicts</a></h2>
<p>We will now look at a second example and its implementation details: a Stack.</p>
<p>A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new
element and removal of an existing element takes place at the same end,
represented as the top of the stack.</p>
<p>Let us define what operations we need to create a stack:</p>
<ul>
<li>Push an item to the top of the stack.</li>
<li>Pop an item from the top of the stack.</li>
<li>Check whether there are still any elements in the stack.</li>
</ul>
<p>From these specifications we can define the following interface :</p>
<pre><code class="language-cairo noplayground">trait StackTrait&lt;S, T&gt; {
    fn push(ref self: S, value: T);
    fn pop(ref self: S) -&gt; Option&lt;T&gt;;
    fn is_empty(self: @S) -&gt; bool;
}
</code></pre>
<h3 id="implementing-a-mutable-stack-in-cairo"><a class="header" href="#implementing-a-mutable-stack-in-cairo">Implementing a Mutable Stack in Cairo</a></h3>
<p>To create a stack data structure in Cairo, we can again use a <code>Felt252Dict&lt;T&gt;</code>
to store the values of the stack along with a <code>usize</code> field to keep track of the
length of the stack to iterate over it.</p>
<p>The Stack struct is defined as:</p>
<pre><code class="language-cairo noplayground">struct NullableStack&lt;T&gt; {
    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
    len: usize,
}
</code></pre>
<p>Next, let's see how our main functions <code>push</code> and <code>pop</code> are implemented.</p>
<pre><code class="language-cairo noplayground"><span class="boring">
</span><span class="boring">use core::dict::Felt252Dict;
</span><span class="boring">use core::nullable::{FromNullableResult, NullableTrait, match_nullable};
</span><span class="boring">
</span><span class="boring">trait StackTrait&lt;S, T&gt; {
</span><span class="boring">    fn push(ref self: S, value: T);
</span><span class="boring">    fn pop(ref self: S) -&gt; Option&lt;T&gt;;
</span><span class="boring">    fn is_empty(self: @S) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct NullableStack&lt;T&gt; {
</span><span class="boring">    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
</span><span class="boring">    len: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DestructNullableStack&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;NullableStack&lt;T&gt;&gt; {
</span><span class="boring">    fn destruct(self: NullableStack&lt;T&gt;) nopanic {
</span><span class="boring">        self.data.squash();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>impl NullableStackImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of StackTrait&lt;NullableStack&lt;T&gt;, T&gt; {
    fn push(ref self: NullableStack&lt;T&gt;, value: T) {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len += 1;
    }

    fn pop(ref self: NullableStack&lt;T&gt;) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None;
        }
        self.len -= 1;
        Some(self.data.get(self.len.into()).deref())
    }

    fn is_empty(self: @NullableStack&lt;T&gt;) -&gt; bool {
        *self.len == 0
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The code uses the <code>insert</code> and <code>get</code> methods to access the values in the
<code>Felt252Dict&lt;T&gt;</code>. To push an element to the top of the stack, the <code>push</code>
function inserts the element in the dict at index <code>len</code> and increases the <code>len</code>
field of the stack to keep track of the position of the stack top. To remove a
value, the <code>pop</code> function decreases the value of <code>len</code> to update the position of
the stack top and then retrieves the last value at position <code>len</code>.</p>
<p>The full implementation of the Stack, along with more data structures that you
can use in your code, can be found in the community-maintained
<a href="https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src">Alexandria</a> library, in the "data_structures"
crate.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch12-01-custom-structs&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;While Cairo has an immutable memory model, you can use the `Felt252Dict&lt;T&gt;` type to simulate mutable data structures.\n&quot;,&quot;id&quot;:&quot;43074990-3724-4818-94dd-eeac0c078780&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`Felt252Dict&lt;T&gt;`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Array&lt;T&gt;`&quot;,&quot;`Box&lt;T&gt;`&quot;,&quot;Nothing in particular, just make sure to declare the structure as mutable.&quot;],&quot;prompt&quot;:&quot;What can you use to implement a mutable data structure?\n&quot;}},{&quot;context&quot;:&quot;The member of type `Felt252Dict&lt;T&gt;` can't be dropped so the struct has to implement the `Destruct&lt;T&gt;` trait.\nBecause the struct is working with generic types, the `Destruct` trait cannot be derived.\nThe elements stored in the dictionary must implement the `Copy&lt;T&gt;` trait to be read, but the struct type itself doesn't necessarily require this implementation.\n&quot;,&quot;id&quot;:&quot;76864942-6f11-4fbf-87a3-46480e26749a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`Destruct&lt;T&gt;`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Drop&lt;T&gt;`&quot;,&quot;None, you can just derive the required traits&quot;,&quot;`Copy&lt;T&gt;` to read the value of the dictionary&quot;],&quot;prompt&quot;:&quot;When you have a member of type `Felt252Dict&lt;T&gt;` in your generic data structure, what trait do you **must** manually implement for that structure?\n&quot;}},{&quot;context&quot;:&quot;The `new` function should return a `NullableStack&lt;T&gt;` with an empty dictionary of type `Nullable&lt;T&gt;` and a length of 0.\n&quot;,&quot;id&quot;:&quot;743ccd28-548f-453c-a4a2-edfecc90ed37&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\nfn new() -&gt; NullableStack&lt;T&gt; {\n    let data: Felt252Dict&lt;Nullable&lt;T&gt;&gt; = Default::default();\n    NullableStack { data, len: 0 }\n}\n```&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\nfn new() -&gt; NullableStack&lt;T&gt; {\n    let data: Felt252Dict&lt;T&gt; = Default::default();\n    NullableStack { data, len: 0 }\n}\n```&quot;,&quot;```\nfn new() -&gt; NullableStack&lt;T&gt; {\n    NullableStack {\n        data: Felt252Dict::default(),\n        len: 0,\n    }\n}\n```&quot;,&quot;```\nfn new() -&gt; NullableStack&lt;T&gt; {\n    NullableStack {\n        data: Default::default(),\n    }\n}\n```&quot;],&quot;prompt&quot;:&quot;Consider the following code snippet:\n```\nstruct NullableStack&lt;T&gt; {\n    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,\n    len: usize,\n}\n\ntrait StackTrait&lt;S, T&gt; {\n    fn push(ref self: S, value: T);\n    fn pop(ref self: S) -&gt; Option&lt;T&gt;;\n    fn is_empty(self: @S) -&gt; bool;\n    fn new() -&gt; S;\n}\n\nimpl NullableStackImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of StackTrait&lt;NullableStack&lt;T&gt;, T&gt; {\n    fn push(ref self: NullableStack&lt;T&gt;, value: T) {\n        self.data.insert(self.len.into(), NullableTrait::new(value));\n        self.len += 1;\n    }\n\n    fn pop(ref self: NullableStack&lt;T&gt;) -&gt; Option&lt;T&gt; {\n        if self.is_empty() {\n            return None;\n        }\n        self.len -= 1;\n        Some(self.data.get(self.len.into()).deref())\n    }\n\n    fn is_empty(self: @NullableStack&lt;T&gt;) -&gt; bool {\n        *self.len == 0\n    }\n\n    // The implementation goes here\n}\n```\nWhat is the correct implementation of the function `fn new() -&gt; S` ?&quot;}}]}"></div>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Well done! Now you have knowledge of arrays, dictionaries and even custom data
structures. While Cairo's memory model is immutable and can make it difficult to
implement mutable data structures, we can fortunately use the <code>Felt252Dict&lt;T&gt;</code>
type to simulate mutable data structures. This allows us to implement a wide
range of data structures that are useful for many applications, effectively
hiding the complexity of the underlying memory model.</p>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>A pointer is a general concept for a variable that contains a memory address.
This address refers to, or “points at,” some other data. While pointers are a
powerful feature, they can also be a source of bugs and security
vulnerabilities. For example, a pointer can reference an unassigned memory cell,
which means that attempting to access the data at that address would cause the
program to crash, making it unprovable. To prevent such issues, Cairo uses
<em>Smart Pointers</em>.</p>
<p>Smart pointers are data structures that act like a pointer, but also have
additional metadata and capabilities. The concept of smart pointers isn’t unique
to Cairo: smart pointers originated in C++ and exist in other languages like
Rust as well. In the specific case of Cairo, smart pointers ensure that memory
is not addressed in an unsafe way that could cause a program to be unprovable,
by providing a safe way to access memory through strict type checking and
ownership rules.</p>
<p>Though we didn’t call them as such at the time, we’ve already encountered a few
smart pointers in this book, including <code>Felt252Dict&lt;T&gt;</code> and <code>Array&lt;T&gt;</code> in
Chapter 3. Both these types count as smart pointers
because they own a memory segment and allow you to manipulate it. They also have
metadata and extra capabilities or guarantees. Arrays keep track of their
current length to ensure that existing elements are not overwritten, and that
new elements are only appended to the end.</p>
<p>The Cairo VM memory is composed by multiple segments that can store data, each
identified by a unique index. When you create an array, you allocate a new
segment in the memory to store the future elements. The array itself is just a
pointer to that segment where the elements are stored.</p>
<h2 id="the-boxt-type-to-manipulate-pointers"><a class="header" href="#the-boxt-type-to-manipulate-pointers">The <code>Box&lt;T&gt;</code> Type to Manipulate Pointers</a></h2>
<p>The principal smart pointer type in Cairo is a <em>box</em>, denoted as <code>Box&lt;T&gt;</code>.
Manually defining boxes allow you to store data in a specific memory segment of
the Cairo VM called the <em>boxed segment</em>. This segment is dedicated to store all
boxed values, and what remains in the execution segment is only a pointer to the
boxed segment. Whenever you instantiate a new pointer variable of type <code>Box&lt;T&gt;</code>,
you append the data of type <code>T</code> to the boxed segment.</p>
<p>Boxes have very little performance overhead, other than writing their inner
values to the boxed segment. But they don’t have many extra capabilities either.
You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want to
use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
</ul>
<p>We’ll demonstrate the first situation in the <a href="./ch12-02-smart-pointers.html#enabling-recursive-types-with-boxes">“Enabling Recursive Types with
Boxes”</a> section. In the second case, transferring
ownership of a large amount of data can take a long time because the data is
copied around in memory. To improve performance in this situation, we can store
the large amount of data in the boxed segment using a box type. Then, only the
small amount of pointer data is copied around in memory, while the data it
references stays in one place on the boxed segment.</p>
<h3 id="using-a-boxt-to-store-data-in-the-boxed-segment"><a class="header" href="#using-a-boxt-to-store-data-in-the-boxed-segment">Using a <code>Box&lt;T&gt;</code> to Store Data in the Boxed Segment</a></h3>
<p>Before we discuss the boxed segment storage use cases for <code>Box&lt;T&gt;</code>, we’ll cover
the syntax and how to interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>Listing 12-1 shows how to use a box to store a value in the boxed
segment:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let b = BoxTrait::new(5_u128);
    println!("b = {}", b.unbox())
}
</code></pre>
<p><code>u128</code> value in the boxed segment using a box</span></p>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value
<code>5</code>, which is stored in the boxed segment. This program will print <code>b = 5</code>; in
this case, we can access the data in the box similar to how we would if this
data was simply in the execution memory. Putting a single value in a box isn’t
very useful, so you won’t use boxes by themselves in this way very often. Having
values like a single <code>u128</code> in the execution memory, where they’re stored by
default, is more appropriate in the majority of situations. Let’s look at a case
where boxes allow us to define types that we wouldn’t be allowed to if we didn’t
have boxes.</p>
<h3 id="enabling-recursive-types-with-boxes"><a class="header" href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></h3>
<p>A value of recursive type can have another value of the same type as part of
itself. Recursive types pose an issue because at compile time because Cairo
needs to know how much space a type takes up. However, the nesting of values of
recursive types could theoretically continue infinitely, so Cairo can’t know how
much space the value needs. Because boxes have a known size, we can enable
recursive types by inserting a box in the recursive type definition.</p>
<p>As an example of a recursive type, let’s explore the implementation of a binary
tree. The binary tree type we’ll define is straightforward except for the
recursion; therefore, the concepts in the example we’ll work with will be useful
any time you get into more complex situations involving recursive types.</p>
<p>A binary tree is a tree data structure in which each node has at most two
children, which are referred to as the left child and the right child. The last
element of a branch is a leaf, which is a node without children.</p>
<p>Listing 12-2 shows an attempt to implement a binary
tree of <code>u32</code> values. Note that this code won’t compile yet because the
<code>BinaryTree</code> type doesn’t have a known size, which we’ll demonstrate.</p>
<pre><code class="language-cairo  noplayground">#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, BinaryTree, BinaryTree),
}

#[executable]
fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, leaf2, leaf3));
    let _root = BinaryTree::Node((5, leaf1, node));
}
</code></pre>
<p>12-2: The first attempt at implementing a binary tree
of <code>u32</code> values</span></p>
<blockquote>
<p>Note: We’re implementing a binary tree that holds only u32 values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 8, to define a binary
tree that could store values of any type.</p>
</blockquote>
<p>The root node contains 5 and two child nodes. The left child is a leaf
containing 1. The right child is another node containing 4, which in turn has
two leaf children: one containing 2 and another containing 3. This structure
forms a simple binary tree with a depth of 2.</p>
<p>If we try to compile the code in listing 12-2, we get
the following error:</p>
<pre><code class="language-plaintext">$ scarb build 
   Compiling listing_recursive_types_wrong v0.1.0 (listings/ch12-advanced-features/listing_recursive_types_wrong/Scarb.toml)
error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:6:5
    Node: (u32, BinaryTree, BinaryTree),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Recursive type "listing_recursive_types_wrong::BinaryTree" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:11:17
    let leaf1 = BinaryTree::Leaf(1);
                ^^^^^^^^^^^^^^^^^^^

error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:14:33
    let node = BinaryTree::Node((4, leaf2, leaf3));
                                ^^^^^^^^^^^^^^^^^

error: could not compile `listing_recursive_types_wrong` due to 3 previous errors

</code></pre>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>BinaryTree</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Cairo can’t figure out how much space it needs to store a
<code>BinaryTree</code> value.</p>
<!-- TODO: explain why we get this error? -->
<p>Hopefully, we can fix this error by using a <code>Box&lt;T&gt;</code> to store the recursive
variant of <code>BinaryTree</code>. Because a <code>Box&lt;T&gt;</code> is a pointer, Cairo always knows how
much space a <code>Box&lt;T&gt;</code> needs: a pointer’s size doesn’t change based on the amount
of data it’s pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Node</code>
variant instead of another <code>BinaryTree</code> value directly. The <code>Box&lt;T&gt;</code> will point
to the child <code>BinaryTree</code> values that will be stored in their own segment,
rather than inside the <code>Node</code> variant. Conceptually, we still have a binary
tree, created with binary trees holding other binary trees, but this
implementation is now more like placing the items next to one another rather
than inside one another.</p>
<p>We can change the definition of the <code>BinaryTree</code> enum in Listing
12-2 and the usage of the <code>BinaryTree</code> in Listing
12-2 to the code in Listing 12-3,
which will compile:</p>
<pre><code class="language-cairo">mod display;
use display::DebugBinaryTree;

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;),
}


#[executable]
fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, BoxTrait::new(leaf2), BoxTrait::new(leaf3)));
    let root = BinaryTree::Node((5, BoxTrait::new(leaf1), BoxTrait::new(node)));

    println!("{:?}", root);
}
</code></pre>
<p>12-3: Defining a recursive Binary Tree using Boxes</span></p>
<p>The <code>Node</code> variant now holds a <code>(u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;)</code>,
indicating that the <code>Node</code> variant will store a <code>u32</code> value, and two
<code>Box&lt;BinaryTree&gt;</code> values. Now, we know that the <code>Node</code> variant will need a size
of <code>u32</code> plus the size of the two <code>Box&lt;BinaryTree&gt;</code> values. By using a box,
we’ve broken the infinite, recursive chain, so the compiler can figure out the
size it needs to store a <code>BinaryTree</code> value.</p>
<!--  Figure {{label Node-size}} shows what the Node variant looks like now. -->
<h3 id="using-boxes-to-improve-performance"><a class="header" href="#using-boxes-to-improve-performance">Using Boxes to Improve Performance</a></h3>
<p>Passing pointers between functions allows you to reference data without copying
the data itself. Using boxes can improve performance as it allows you to pass a
pointer to some data from one function to another, without the need to copy the
entire data in memory before performing the function call. Instead of having to
write <code>n</code> values into memory before calling a function, only a single value is
written, corresponding to the pointer to the data. If the data stored in the box
is very large, the performance improvement can be significant, as you would save
<code>n-1</code> memory operations before each function call.</p>
<blockquote>
<p>Note: This only works if the data stored in the box is not mutated. If the
data is mutated, a new <code>Box&lt;T&gt;</code> will be created, which will require copying
the data to the new box.</p>
</blockquote>
<p>Let's take a look at the code in Listing 12-4, which shows two ways of
passing data to a function: by value and by pointer.</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Cart {
    paid: bool,
    items: u256,
    buyer: ByteArray,
}

fn pass_data(cart: Cart) {
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn pass_pointer(cart: Box&lt;Cart&gt;) {
    let cart = cart.unbox();
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

#[executable]
fn main() {
    let new_struct = Cart { paid: true, items: 1, buyer: "Eli" };
    pass_data(new_struct);

    let new_box = BoxTrait::new(Cart { paid: false, items: 2, buyer: "Uri" });
    pass_pointer(new_box);
}
</code></pre>
<p>of data in a box for performance.</span></p>
<p>The <code>main</code> function includes 2 function calls:</p>
<ul>
<li><code>pass_data</code> that takes a variable of type <code>Cart</code>.</li>
<li><code>pass_pointer</code> that takes a pointer of type <code>Box&lt;Cart&gt;</code>.</li>
</ul>
<p>When passing data to a function, the entire data is copied into the last
available memory cells right before the function call. Calling <code>pass_data</code> will
copy all 3 fields of <code>Cart</code> to memory, while <code>pass_pointer</code> only requires the
copy of the <code>new_box</code> pointer which is of size 1.</p>
<div align="center">
    <img src="box_memory.png" alt="box memory" width="500px"/>
<div align="center">
    </div>
    <span class="caption">CairoVM Memory layout when using boxes</span>
</div>
<p>The illustration above demonstrates how the memory behaves in both cases. The
first instance of <code>Cart</code> is stored in the execution segment, and we need to copy
all its fields to memory before calling the <code>pass_data</code> function. The second
instance of <code>Cart</code> is stored in the boxed segment, and the pointer to it is
stored in the execution segment. When calling the <code>pass_pointer</code> function, only
the pointer to the struct is copied to memory right before the function call. In
both cases, however, instantiating the struct will store all its values in the
execution segment: the boxed segment can only be filled with data taken from the
execution segment.</p>
<h2 id="the-nullablet-type-for-dictionaries"><a class="header" href="#the-nullablet-type-for-dictionaries">The <code>Nullable&lt;T&gt;</code> Type for Dictionaries</a></h2>
<p><code>Nullable&lt;T&gt;</code> is another type of smart pointer that can either point to a value
or be <code>null</code> in the absence of value. It is defined at the Sierra level. This
type is mainly used in dictionaries that contain types that don't implement the
<code>zero_default</code> method of the <code>Felt252DictValue&lt;T&gt;</code> trait (i.e., arrays and
structs).</p>
<p>If we try to access an element that does not exist in a dictionary, the code
will fail if the <code>zero_default</code> method cannot be called.</p>
<p><a href="./ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively">Chapter 3</a> about
dictionaries thoroughly explains how to store a <code>Span&lt;felt252&gt;</code> variable inside
a dictionary using the <code>Nullable&lt;T&gt;</code> type. Please refer to it for further
information.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch12-02-smart_pointers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Smart pointers in Cairo possess additional metadata and capabilities beyond merely serving as a reference to a value.\nThey offer memory management features that extend beyond simple referencing, including strict type checking and ownership rules that enforce memory safety.\nCairo provides several explicit smart pointer types, such as `Box` and `Nullable`, but other types like `Array` of `Felt252Dict` are also a form of smart pointers.\nThese smart pointers ensure memory safety through strict ownership rules, preventing common issues like null dereferences.\n&quot;,&quot;id&quot;:&quot;dbf869eb-b27a-41d0-b428-20d9ae00498b&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Smart pointers store a reference to a value but do not provide any automatic memory management or ownership tracking.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Smart pointers help prevent common memory issues such as dereferences unallocated memory and re-writing to existing cells.&quot;,&quot;Smart pointers ensure proper initialization and prevent access to uninitialized or invalid memory.&quot;,&quot;Smart pointers such as `Box` and `Nullable` enable efficient passing of large data by moving or sharing ownership without expensive copying.&quot;],&quot;prompt&quot;:&quot;Which one of the following is **NOT** true about smart pointers?&quot;}},{&quot;context&quot;:&quot;The `student1` variable was first instantiated as a smart pointer to an instance of the struct `Student`.\nWhen we assigned `student1` to a new variable `student2`, we merely copied the _smart pointer_ to the previously created struct,\nso both variables referred to the same struct in memory.\nOnce `student1` was reinstantiated with a new smart pointer to a new `Student` instance, the `student2` variable\nstill referred to the original struct, so printing `student2.name` displayed `\&quot;Peter\&quot;`.\n&quot;,&quot;id&quot;:&quot;8d7ac906-4579-4d47-8345-4ec30a5f41f3&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;Peter&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct Student {\n    name: ByteArray,\n    age: u8,\n    id: u32\n}\n\n#[executable]\nfn main() {\n    let mut student1 = BoxTrait::new(Student { name: \&quot;Peter\&quot;, age: 12, id: 12345 });\n    let student2 = student1;\n    student1 = BoxTrait::new(Student { name: \&quot;James\&quot;, age: 18, id: 56789 });\n    println!(\&quot;{}\&quot;, student2.unbox().name);\n}\n&quot;}},{&quot;context&quot;:&quot;The `Index out of bounds` error occurs due to an attempt to access\nthe fifth element of a four-element array, which is an unallocated memory cell.\n&quot;,&quot;id&quot;:&quot;df5c2298-4896-459e-ac4a-bc5e47582a13&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Panics with an 'Index out of bounds' error&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Outputs `Exams 90`&quot;,&quot;Outputs 'No value found' panic because it implements the `zero_default` method&quot;,&quot;Fails to compile&quot;],&quot;prompt&quot;:&quot;Which of the following statement is TRUE when the following program is run with `scarb execute`?\n```\nuse core::nullable::{NullableTrait, match_nullable, FromNullableResult};\n\n#[executable]\nfn main() {\n    let mut scoreSheet: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();\n\n    let exams = array![60, 70, 80, 90];\n    scoreSheet.insert(0, NullableTrait::new(exams.span()));\n\n    let firstSession = scoreSheet.get(0);\n\n    let record = match match_nullable(firstSession) {\n        FromNullableResult::Null =&gt; panic!(\&quot;No value found\&quot;),\n        FromNullableResult::NotNull(firstSession) =&gt; firstSession.unbox(),\n    };\n    println!(\&quot;Exams {}\&quot;, *record.at(4));\n}\n```\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="deref-coercion"><a class="header" href="#deref-coercion">Deref Coercion</a></h1>
<p>Deref coercion simplifies the way we interact with nested or wrapped data
structures by allowing an instance of one type to behave like an instance of
another type. This mechanism is enabled by implementing the <code>Deref</code> trait, which
allows implicit conversion (or coercion) to a different type, providing direct
access to the underlying data.</p>
<p>Deref coercion is implemented via the <code>Deref</code> and <code>DerefMut</code> traits. When a type
<code>T</code> implements <code>Deref</code> or <code>DerefMut</code> to type <code>K</code>, instances of <code>T</code> can access
the members of <code>K</code> directly.</p>
<p>The <code>Deref</code> trait in Cairo is defined as follows:</p>
<pre><code class="language-cairo  noplayground">pub trait Deref&lt;T&gt; {
    type Target;
    fn deref(self: T) -&gt; Self::Target;
}
<span class="boring">
</span><span class="boring">pub trait DerefMut&lt;T&gt; {
</span><span class="boring">    type Target;
</span><span class="boring">    fn deref_mut(ref self: T) -&gt; Self::Target;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The <code>Target</code> type specifies the result of dereferencing, and the <code>deref</code> method
defines how to transform <code>T</code> into <code>K</code>.</p>
<h2 id="using-deref-coercion"><a class="header" href="#using-deref-coercion">Using Deref Coercion</a></h2>
<p>To better understand how deref coercion works, let's look at a practical
example. We'll create a simple generic wrapper type around a type <code>T</code> called
<code>Wrapper&lt;T&gt;</code>, and use it to wrap a <code>UserProfile</code> struct.</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper&lt;T&gt; {
    value: T,
}
<span class="boring">
</span><span class="boring">impl DerefWrapper&lt;T&gt; of Deref&lt;Wrapper&lt;T&gt;&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">    fn deref(self: Wrapper&lt;T&gt;) -&gt; T {
</span><span class="boring">        self.value
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">    // Access fields directly via deref coercion
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">    println!("Current age: {}", wrapped_profile.age);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The <code>Wrapper</code> struct wraps a single value generic of type <code>T</code>. To simplify
access to the wrapped value, we implement the <code>Deref</code> trait for <code>Wrapper&lt;T&gt;</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct UserProfile {
</span><span class="boring">    username: felt252,
</span><span class="boring">    email: felt252,
</span><span class="boring">    age: u16,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct Wrapper&lt;T&gt; {
</span><span class="boring">    value: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl DerefWrapper&lt;T&gt; of Deref&lt;Wrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref(self: Wrapper&lt;T&gt;) -&gt; T {
        self.value
    }
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">    // Access fields directly via deref coercion
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">    println!("Current age: {}", wrapped_profile.age);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>This implementation is quite simple. The <code>deref</code> method returns the wrapped
value, allowing instances of <code>Wrapper&lt;T&gt;</code> to access the members of <code>T</code> directly.</p>
<p>In practice, this mechanism is totally transparent. The following example
demonstrates how, holding an instance of <code>Wrapper&lt;UserProfile&gt;</code>, we can print
the <code>username</code> and <code>age</code> fields of the underlying <code>UserProfile</code> instance.</p>
<pre><code class="language-cairo"><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct UserProfile {
</span><span class="boring">    username: felt252,
</span><span class="boring">    email: felt252,
</span><span class="boring">    age: u16,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct Wrapper&lt;T&gt; {
</span><span class="boring">    value: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DerefWrapper&lt;T&gt; of Deref&lt;Wrapper&lt;T&gt;&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">    fn deref(self: Wrapper&lt;T&gt;) -&gt; T {
</span><span class="boring">        self.value
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Access fields directly via deref coercion
    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h3 id="restricting-deref-coercion-to-mutable-variables"><a class="header" href="#restricting-deref-coercion-to-mutable-variables">Restricting Deref Coercion to Mutable Variables</a></h3>
<p>While <code>Deref</code> works for both mutable and immutable variables, <code>DerefMut</code> will
only be applicable to mutable variables. Contrary to what the name might
suggest, <code>DerefMut</code> does not provide mutable access to the underlying data.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">
</span><span class="boring">use core::ops::DerefMut;
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct UserProfile {
</span><span class="boring">    username: felt252,
</span><span class="boring">    email: felt252,
</span><span class="boring">    age: u16,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct Wrapper&lt;T&gt; {
</span><span class="boring">    value: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl DerefMutWrapper&lt;T, +Copy&lt;T&gt;&gt; of DerefMut&lt;Wrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref_mut(ref self: Wrapper&lt;T&gt;) -&gt; T {
        self.value
    }
}
<span class="boring">
</span><span class="boring">fn error() {
</span><span class="boring">    let wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">    // Uncommenting the next line will cause a compilation error
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">    println!("Current age: {}", wrapped_profile.age);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>If you try to use <code>DerefMut</code> with an immutable variable, the compiler would
throw an error. Here’s an example:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">
</span><span class="boring">use core::ops::DerefMut;
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct UserProfile {
</span><span class="boring">    username: felt252,
</span><span class="boring">    email: felt252,
</span><span class="boring">    age: u16,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct Wrapper&lt;T&gt; {
</span><span class="boring">    value: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DerefMutWrapper&lt;T, +Copy&lt;T&gt;&gt; of DerefMut&lt;Wrapper&lt;T&gt;&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">    fn deref_mut(ref self: Wrapper&lt;T&gt;) -&gt; T {
</span><span class="boring">        self.value
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn error() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Uncommenting the next line will cause a compilation error
    println!("Username: {}", wrapped_profile.username);
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let mut wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">    println!("Current age: {}", wrapped_profile.age);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Compiling this code will result in the following error:</p>
<pre><code class="language-plaintext">$ scarb build 
   Compiling no_listing_09_deref_coercion_example v0.1.0 (listings/ch12-advanced-features/no_listing_09_deref_mut_example/Scarb.toml)
error[E0007]: Type "no_listing_09_deref_coercion_example::Wrapper::&lt;no_listing_09_deref_coercion_example::UserProfile&gt;" has no member "username"
 --&gt; listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:32:46
    println!("Username: {}", wrapped_profile.username);
                                             ^^^^^^^^

error: could not compile `no_listing_09_deref_coercion_example` due to 1 previous error

</code></pre>
<p>For the above code to work, we need to define <code>wrapped_profile</code> as a mutable
variable.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">
</span><span class="boring">use core::ops::DerefMut;
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct UserProfile {
</span><span class="boring">    username: felt252,
</span><span class="boring">    email: felt252,
</span><span class="boring">    age: u16,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Copy)]
</span><span class="boring">struct Wrapper&lt;T&gt; {
</span><span class="boring">    value: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DerefMutWrapper&lt;T, +Copy&lt;T&gt;&gt; of DerefMut&lt;Wrapper&lt;T&gt;&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">    fn deref_mut(ref self: Wrapper&lt;T&gt;) -&gt; T {
</span><span class="boring">        self.value
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn error() {
</span><span class="boring">    let wrapped_profile = Wrapper {
</span><span class="boring">        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
</span><span class="boring">    };
</span><span class="boring">    // Uncommenting the next line will cause a compilation error
</span><span class="boring">    println!("Username: {}", wrapped_profile.username);
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let mut wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };

    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="calling-methods-via-deref-coercion"><a class="header" href="#calling-methods-via-deref-coercion">Calling Methods via Deref Coercion</a></h2>
<p>In addition to accessing members, deref coercion also allows calling methods
defined on the target type directly on the source type instance. Let's
illustrate this with an example:</p>
<pre><code class="language-cairo">struct MySource {
    pub data: u8,
}

struct MyTarget {
    pub data: u8,
}

#[generate_trait]
impl TargetImpl of TargetTrait {
    fn foo(self: MyTarget) -&gt; u8 {
        self.data
    }
}

impl SourceDeref of Deref&lt;MySource&gt; {
    type Target = MyTarget;
    fn deref(self: MySource) -&gt; MyTarget {
        MyTarget { data: self.data }
    }
}

#[executable]
fn main() {
    let source = MySource { data: 5 };
    // Thanks to the Deref impl, we can call foo directly on MySource
    let res = source.foo();
    assert!(res == 5);
}
</code></pre>
<p>In this example, <code>MySource</code> implements <code>Deref</code> to <code>MyTarget</code>. The <code>MyTarget</code>
struct has an implementation <code>TargetImpl</code> of the trait <code>TargetTrait</code> which
defines a method <code>foo</code>. Because <code>MySource</code> dereferences to <code>MyTarget</code>, we can
call the <code>foo</code> method directly on an instance of <code>MySource</code>, as demonstrated in
the <code>main</code> function.</p>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>By using the <code>Deref</code> and <code>DerefMut</code> traits, we can transparently convert one
type into another, simplifying the access to nested or wrapped data structures
and enabling method calls defined on the target type. This feature is
particularly useful when working with generic types or building abstractions
that require easy access to the underlying data and can help reduce boilerplate
code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-items"><a class="header" href="#associated-items">Associated Items</a></h1>
<p><em>Associated Items</em> are the items declared in <a href="./ch08-02-traits-in-cairo.html">traits</a> or defined in
<a href="./ch08-02-traits-in-cairo.html#implementing-a-trait-on-a-type">implementations</a>. Specifically, there are <a href="./ch05-03-method-syntax.html#associated-functions">associated functions</a> (including
methods, that we already covered in Chapter
5), <a href="./ch12-10-associated-items.html#associated-types">associated types</a>,
<a href="./ch12-10-associated-items.html#associated-constants">associated constants</a>, and <a href="./ch12-10-associated-items.html#associated-implementations">associated implementations</a>.</p>
<p>Associated items are useful when they are logically related to the
implementation. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically
related to Options, so should be associated.</p>
<p>Every associated item kind comes in two varieties: definitions that contain the
actual implementation and declarations that declare signatures for definitions.</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h2>
<p>Associated types are <em>type aliases</em> allowing you to define abstract type
placeholders within traits. Instead of specifying concrete types in the trait
definition, associated types let trait implementers choose the actual types to
use.</p>
<p>Let's consider the following <code>Pack</code> trait:</p>
<pre><code class="language-cairo  noplayground">trait Pack&lt;T&gt; {
    type Result;

    fn pack(self: T, other: T) -&gt; Self::Result;
}
<span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The <code>Result</code> type in our <code>Pack</code> trait acts as placeholder for a type that will
be filled in later. Think of associated types as leaving a blank space in your
trait for each implementation to write in the specific type it needs. This
approach keeps your trait definition clean and flexible. When you use the trait,
you don't need to worry about specifying these types - they're already chosen
for you by the implementation. In our <code>Pack</code> trait, the type <code>Result</code> is such a
placeholder. The method's definition shows that it will return values of type
<code>Self::Result</code>, but it doesn't specify what <code>Result</code> actually is. This is left
to the implementers of the <code>Pack</code> trait, who will specify the concrete type for
<code>Result</code>. When the <code>pack</code> method is called, it will return a value of that
chosen concrete type, whatever it may be.</p>
<p>Let's see how associated types compare to a more traditional generic approach.
Suppose we need a function <code>foo</code> that can pack two variables of type <code>T</code>.
Without associated types, we might define a <code>PackGeneric</code> trait and an
implementation to pack two <code>u32</code> like this:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span>trait PackGeneric&lt;T, U&gt; {
    fn pack_generic(self: T, other: T) -&gt; U;
}

impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
    fn pack_generic(self: u32, other: u32) -&gt; u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
<span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>With this approach, <code>foo</code> would be implemented as:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
    self.pack_generic(other)
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Notice how <code>foo</code> needs to specify both <code>T</code> and <code>U</code> as generic parameters. Now,
let's compare this to our <code>Pack</code> trait with an associated type:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span>impl PackU32Impl of Pack&lt;u32&gt; {
    type Result = u64;

    fn pack(self: u32, other: u32) -&gt; Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
<span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>With associated types, we can define <code>bar</code> more concisely:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
    PackImpl::pack(self, b)
}
<span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Finally, let's see both approaches in action, demonstrating that the end result
is the same:</p>
<pre><code class="language-cairo"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>As you can see, <code>bar</code> doesn't need to specify a second generic type for the
packing result. This information is hidden in the implementation of the <code>Pack</code>
trait, making the function signature cleaner and more flexible. Associated types
allow us to express the same functionality with less verbosity, while still
maintaining the flexibility of generic programming.</p>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated Constants</a></h2>
<p>Associated constants are constants associated with a type. They are declared
using the <code>const</code> keyword in a trait and defined in its implementation. In our
next example, we define a generic <code>Shape</code> trait that we implement for a
<code>Triangle</code> and a <code>Square</code>. This trait includes an associated constant, defining
the number of sides of the type that implements the trait.</p>
<pre><code class="language-cairo  noplayground">trait Shape&lt;T&gt; {
    const SIDES: u32;
    fn describe() -&gt; ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape&lt;Triangle&gt; {
    const SIDES: u32 = 3;
    fn describe() -&gt; ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape&lt;Square&gt; {
    const SIDES: u32 = 4;
    fn describe() -&gt; ByteArray {
        "I am a square."
    }
}
<span class="boring">
</span><span class="boring">fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
</span><span class="boring">    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    print_shape_info::&lt;Triangle&gt;();
</span><span class="boring">    print_shape_info::&lt;Square&gt;();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>After that, we create a <code>print_shape_info</code> generic function, which requires that
the generic argument implements the <code>Shape</code> trait. This function will use the
associated constant to retrieve the number of sides of the geometric figure, and
print it along with its description.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Shape&lt;T&gt; {
</span><span class="boring">    const SIDES: u32;
</span><span class="boring">    fn describe() -&gt; ByteArray;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {}
</span><span class="boring">
</span><span class="boring">impl TriangleShape of Shape&lt;Triangle&gt; {
</span><span class="boring">    const SIDES: u32 = 3;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a triangle."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Square {}
</span><span class="boring">
</span><span class="boring">impl SquareShape of Shape&lt;Square&gt; {
</span><span class="boring">    const SIDES: u32 = 4;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a square."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    print_shape_info::&lt;Triangle&gt;();
</span><span class="boring">    print_shape_info::&lt;Square&gt;();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Associated constants allow us to bind a constant number to the <code>Shape</code> trait
rather than adding it to the struct or just hardcoding the value in the
implementation. This approach provides several benefits:</p>
<ol>
<li>It keeps the constant closely tied to the trait, improving code organization.</li>
<li>It allows for compile-time checks to ensure all implementors define the
required constant.</li>
<li>It ensures two instances of the same type have the same number of sides.</li>
</ol>
<p>Associated constants can also be used for type-specific behavior or
configuration, making them a versatile tool in trait design.</p>
<p>We can ultimately run the <code>print_shape_info</code> and see the output for both
<code>Triangle</code> and <code>Square</code>:</p>
<pre><code class="language-cairo"><span class="boring">trait Shape&lt;T&gt; {
</span><span class="boring">    const SIDES: u32;
</span><span class="boring">    fn describe() -&gt; ByteArray;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {}
</span><span class="boring">
</span><span class="boring">impl TriangleShape of Shape&lt;Triangle&gt; {
</span><span class="boring">    const SIDES: u32 = 3;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a triangle."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Square {}
</span><span class="boring">
</span><span class="boring">impl SquareShape of Shape&lt;Square&gt; {
</span><span class="boring">    const SIDES: u32 = 4;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a square."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
</span><span class="boring">    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    print_shape_info::&lt;Triangle&gt;();
    print_shape_info::&lt;Square&gt;();
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="associated-implementations"><a class="header" href="#associated-implementations">Associated Implementations</a></h2>
<p>Associated implementations allow you to declare that a trait implementation must
exist for an associated type. This feature is particularly useful when you want
to enforce relationships between types and implementations at the trait level.
It ensures type safety and consistency across different implementations of a
trait, which is important in generic programming contexts.</p>
<p>To understand the utility of associated implementations, let's examine the
<code>Iterator</code> and <code>IntoIterator</code> traits from the Cairo core library, with their
respective implementations using <code>ArrayIter&lt;T&gt;</code> as the collection type:</p>
<pre><code class="language-cairo  noplayground">// Collection type that contains a simple array
#[derive(Drop)]
pub struct ArrayIter&lt;T&gt; {
    array: Array&lt;T&gt;,
}

// T is the collection type
pub trait Iterator&lt;T&gt; {
    type Item;
    fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;;
}

impl ArrayIterator&lt;T&gt; of Iterator&lt;ArrayIter&lt;T&gt;&gt; {
    type Item = T;
    fn next(ref self: ArrayIter&lt;T&gt;) -&gt; Option&lt;T&gt; {
        self.array.pop_front()
    }
}

/// Turns a collection of values into an iterator
pub trait IntoIterator&lt;T&gt; {
    /// The iterator type that will be created
    type IntoIter;
    impl Iterator: Iterator&lt;Self::IntoIter&gt;;

    fn into_iter(self: T) -&gt; Self::IntoIter;
}

impl ArrayIntoIterator&lt;T&gt; of IntoIterator&lt;Array&lt;T&gt;&gt; {
    type IntoIter = ArrayIter&lt;T&gt;;
    fn into_iter(self: Array&lt;T&gt;) -&gt; ArrayIter&lt;T&gt; {
        ArrayIter { array: self }
    }
}
</code></pre>
<ol>
<li>The <code>IntoIterator</code> trait is designed to convert a collection into an
iterator.</li>
<li>The <code>IntoIter</code> associated type represents the specific iterator type that
will be created. This allows different collections to define their own
efficient iterator types.</li>
<li>The associated implementation <code>Iterator: Iterator&lt;Self::IntoIter&gt;</code> (the key
feature we're discussing) declares that this <code>IntoIter</code> type must implement
the <code>Iterator</code> trait.</li>
<li>This design allows for type-safe iteration without needing to specify the
iterator type explicitly every time, improving code ergonomics.</li>
</ol>
<p>The associated implementation creates a binding at the trait level, guaranteeing
that:</p>
<ul>
<li>The <code>into_iter</code> method will always return a type that implements <code>Iterator</code>.</li>
<li>This relationship is enforced for all implementations of <code>IntoIterator</code>, not
just on a case-by-case basis.</li>
</ul>
<p>The following <code>main</code> function demonstrates how this works in practice for an
<code>Array&lt;felt252&gt;</code>:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr: Array&lt;felt252&gt; = array![1, 2, 3];

    // Converts the array into an iterator
    let mut iter = arr.into_iter();

    // Uses the iterator to print each element
    while let Some(item) = iter.next() {
        println!("Item: {}", item);
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>Operator overloading is a feature in some programming languages that allows the
redefinition of standard operators, such as addition (<code>+</code>), subtraction (<code>-</code>),
multiplication (<code>*</code>), and division (<code>/</code>), to work with user-defined types. This
can make the syntax of the code more intuitive, by enabling operations on
user-defined types to be expressed in the same way as operations on primitive
types.</p>
<p>In Cairo, operator overloading is achieved through the implementation of
specific traits. Each operator has an associated trait, and overloading that
operator involves providing an implementation of that trait for a custom type.
However, it's essential to use operator overloading judiciously. Misuse can lead
to confusion, making the code more difficult to maintain, for example when there
is no semantic meaning to the operator being overloaded.</p>
<p>Consider an example where two <code>Potions</code> need to be combined. <code>Potions</code> have two
data fields, mana and health. Combining two <code>Potions</code> should add their
respective fields.</p>
<pre><code class="language-cairo">struct Potion {
    health: felt252,
    mana: felt252,
}

impl PotionAdd of Add&lt;Potion&gt; {
    fn add(lhs: Potion, rhs: Potion) -&gt; Potion {
        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }
    }
}

#[executable]
fn main() {
    let health_potion: Potion = Potion { health: 100, mana: 0 };
    let mana_potion: Potion = Potion { health: 0, mana: 100 };
    let super_potion: Potion = health_potion + mana_potion;
    // Both potions were combined with the `+` operator.
    assert!(super_potion.health == 100);
    assert!(super_potion.mana == 100);
}
</code></pre>
<p>In the code above, we're implementing the <code>Add</code> trait for the <code>Potion</code> type. The
add function takes two arguments: <code>lhs</code> and <code>rhs</code> (left and right-hand side).
The function body returns a new <code>Potion</code> instance, its field values being a
combination of <code>lhs</code> and <code>rhs</code>.</p>
<p>As illustrated in the example, overloading an operator requires specification of
the concrete type being overloaded. The overloaded generic trait is <code>Add&lt;T&gt;</code>,
and we define a concrete implementation for the type <code>Potion</code> with
<code>Add&lt;Potion&gt;</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch12-03-operator-overloading&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;When implementing a trait, the parameter names in the implementing function must match the parameter names specified in the trait definition.&quot;,&quot;id&quot;:&quot;c1d67428-426d-4ffc-a45c-96c2b34ba90f&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false},&quot;prompt&quot;:{&quot;program&quot;:&quot;#[derive(Drop)]\nstruct Character {\n    health: u8,\n    attack: u8,\n}\n\nimpl CharacterSub of Sub&lt;Character&gt; {\n    fn sub(p1: Character, p2: Character) -&gt; Character {\n        Character { health: p1.health - p2.attack, attack: p1.attack }\n    }\n}\n\n#[executable]\nfn main() {\n    let mut player1: Character = Character { health: 100, attack: 2 };\n    let player2: Character = Character { health: 100, attack: 5 };\n    player1 = player1 - player2;\n    println!(\&quot;{}\&quot;, player1.health);\n}\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="hashes"><a class="header" href="#hashes">Hashes</a></h1>
<p>At its essence, hashing is a process of converting input data (often called a
message) of any length into a fixed-size value, typically referred to as a
"hash." This transformation is deterministic, meaning that the same input will
always produce the same hash value. Hash functions are a fundamental component
in various fields, including data storage, cryptography and data integrity
verification. They are very often used when developing smart contracts,
especially when working with <a href="https://en.wikipedia.org/wiki/Merkle_tree#Uses">Merkle trees</a>.</p>
<p>In this chapter, we will present the two hash functions implemented natively in
the Cairo core library: <code>Poseidon</code> and <code>Pedersen</code>. We will discuss when and how
to use them, and see examples with Cairo programs.</p>
<h3 id="hash-functions-in-cairo"><a class="header" href="#hash-functions-in-cairo">Hash Functions in Cairo</a></h3>
<p>The Cairo core library provides two hash functions: Pedersen and Poseidon.</p>
<p>Pedersen hash functions are cryptographic algorithms that rely on <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">elliptic
curve cryptography</a>. These functions perform operations on points along
an elliptic curve — essentially, doing math with the locations of these points —
which are easy to do in one direction and hard to undo. This one-way difficulty
is based on the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a
problem so hard to solve that it ensures the security of the hash function. The
difficulty of reversing these operations is what makes the Pedersen hash
function secure and reliable for cryptographic purposes.</p>
<p>Poseidon is a family of hash functions designed to be very efficient as
algebraic circuits. Its design is particularly efficient for Zero-Knowledge
proof systems, including STARKs (so, Cairo). Poseidon uses a method called a
'sponge construction,' which soaks up data and transforms it securely using a
process known as the Hades permutation. Cairo's version of Poseidon is based on
a three-element state permutation with <a href="https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt">specific
parameters</a>.</p>
<h4 id="when-to-use-them"><a class="header" href="#when-to-use-them">When to Use Them?</a></h4>
<p>Pedersen was the first hash function used on Starknet, and is still used to
compute the addresses of variables in storage (for example, <code>LegacyMap</code> uses
Pedersen to hash the keys of a storage mapping on Starknet). However, as
Poseidon is cheaper and faster than Pedersen when working with STARK proofs
system, it's now the recommended hash function to use in Cairo programs.</p>
<h3 id="working-with-hashes"><a class="header" href="#working-with-hashes">Working with Hashes</a></h3>
<p>The core library makes it easy to work with hashes. The <code>Hash</code> trait is
implemented for all types that can be converted to <code>felt252</code>, including
<code>felt252</code> itself. For more complex types like structs, deriving <code>Hash</code> allows
them to be hashed easily using the hash function of your choice - given that all
of the struct's fields are themselves hashable. You cannot derive the <code>Hash</code>
trait on a struct that contains un-hashable values, such as <code>Array&lt;T&gt;</code> or
<code>Felt252Dict&lt;T&gt;</code>, even if <code>T</code> itself is hashable.</p>
<p>The <code>Hash</code> trait is accompanied by the <code>HashStateTrait</code> and <code>HashStateExTrait</code>
that define the basic methods to work with hashes. They allow you to initialize
a hash state that will contain the temporary values of the hash after each
application of the hash function, update the hash state and finalize it when the
computation is completed. <code>HashStateTrait</code> and <code>HashStateExTrait</code> are defined as
follows:</p>
<pre><code class="language-cairo noplayground">/// A trait for hash state accumulators.
trait HashStateTrait&lt;S&gt; {
    fn update(self: S, value: felt252) -&gt; S;
    fn finalize(self: S) -&gt; felt252;
}

/// Extension trait for hash state accumulators.
trait HashStateExTrait&lt;S, T&gt; {
    /// Updates the hash state with the given value.
    fn update_with(self: S, value: T) -&gt; S;
}

/// A trait for values that can be hashed.
trait Hash&lt;T, S, +HashStateTrait&lt;S&gt;&gt; {
    /// Updates the hash state with the given value.
    fn update_state(state: S, value: T) -&gt; S;
}
</code></pre>
<p>To use hashes in your code, you must first import the relevant traits and
functions. In the following example, we will demonstrate how to hash a struct
using both the Pedersen and Poseidon hash functions.</p>
<p>The first step is to initialize the hash with either
<code>PoseidonTrait::new() -&gt; HashState</code> or
<code>PedersenTrait::new(base: felt252) -&gt; HashState</code> depending on which hash
function we want to work with. Then the hash state can be updated with the
<code>update(self: HashState, value: felt252) -&gt; HashState</code> or
<code>update_with(self: S, value: T) -&gt; S</code> functions as many times as required. Then
the function <code>finalize(self: HashState) -&gt; felt252</code> is called on the hash state
and it returns the value of the hash as a <code>felt252</code>.</p>
<pre><code class="language-cairo">use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;

#[derive(Drop, Hash)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

#[executable]
fn main() -&gt; felt252 {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
    hash
}
</code></pre>
<p>Pedersen is different from Poseidon, as it starts with a base state. This base
state must be of <code>felt252</code> type, which forces us to either hash the struct with
an arbitrary base state using the <code>update_with</code> method, or serialize the struct
into an array to loop through all of its fields and hash its elements together.</p>
<p>Here is a short example of Pedersen hashing:</p>
<pre><code class="language-cairo"><span class="boring">use core::hash::{HashStateExTrait, HashStateTrait};
</span><span class="boring">use core::pedersen::PedersenTrait;
</span><span class="boring">
</span><span class="boring">#[derive(Drop, Hash, Serde, Copy)]
</span><span class="boring">struct StructForHash {
</span><span class="boring">    first: felt252,
</span><span class="boring">    second: felt252,
</span><span class="boring">    third: (u32, u32),
</span><span class="boring">    last: bool,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() -&gt; (felt252, felt252) {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    // hash1 is the result of hashing a struct with a base state of 0
    let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();

    let mut serialized_struct: Array&lt;felt252&gt; = ArrayTrait::new();
    Serde::serialize(@struct_to_hash, ref serialized_struct);
    let first_element = serialized_struct.pop_front().unwrap();
    let mut state = PedersenTrait::new(first_element);

    for value in serialized_struct {
        state = state.update(value);
    }

    // hash2 is the result of hashing only the fields of the struct
    let hash2 = state.finalize();

    (hash1, hash2)
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h3 id="advanced-hashing-hashing-arrays-with-poseidon"><a class="header" href="#advanced-hashing-hashing-arrays-with-poseidon">Advanced Hashing: Hashing Arrays with Poseidon</a></h3>
<p>Let us look at an example of hashing a struct that contains a <code>Span&lt;felt252&gt;</code>.
To hash a <code>Span&lt;felt252&gt;</code> or a struct that contains a <code>Span&lt;felt252&gt;</code> you can
use the built-in function
<code>poseidon_hash_span(mut span: Span&lt;felt252&gt;) -&gt; felt252</code>. Similarly, you can
hash <code>Array&lt;felt252&gt;</code> by calling <code>poseidon_hash_span</code> on its span.</p>
<p>First, let us import the following traits and function:</p>
<pre><code class="language-cairo noplayground">use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::{PoseidonTrait, poseidon_hash_span};
</code></pre>
<p>Now we define the struct. As you might have noticed, we didn't derive the <code>Hash</code>
trait. If you attempt to derive the <code>Hash</code> trait for this struct, it will result
in an error because the structure contains a field that is not hashable.</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array&lt;felt252&gt;,
}
</code></pre>
<p>In this example, we initialized a <code>HashState</code> (<code>hash</code>), updated it and then
called the function <code>finalize()</code> on the <code>HashState</code> to get the computed hash
<code>hash_felt252</code>. We used <code>poseidon_hash_span</code> on the <code>Span</code> of the
<code>Array&lt;felt252&gt;</code> to compute its hash.</p>
<pre><code class="language-cairo"><span class="boring">use core::hash::{HashStateExTrait, HashStateTrait};
</span><span class="boring">use core::poseidon::{PoseidonTrait, poseidon_hash_span};
</span><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct StructForHashArray {
</span><span class="boring">    first: felt252,
</span><span class="boring">    second: felt252,
</span><span class="boring">    third: Array&lt;felt252&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };

    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Cairo: <em>declarative</em> macros with <code>macro</code> and three kinds of
<em>procedural</em> macros covered in
<a href="./ch12-10-procedural-macros.html">Procedural Macros</a>:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<h2 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h2>
<p>Fundamentally, macros are a way of writing code that writes other code, which is
known as <em>metaprogramming</em>. In Appendix C, we discuss derivable traits and the
<code>derive</code> attribute, which generates an implementation of various traits for you.
We’ve also used the <code>println!</code> and <code>array!</code> macros throughout the book. All of
these macros <em>expand</em> to produce more code than the code you’ve written
manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have some
additional powers that functions don’t.</p>
<p>A function signature must declare the number and type of parameters the function
has. Macros, on the other hand, can take a variable number of parameters: we can
call <code>println!("hello")</code> with one argument or <code>println!("hello {}", name)</code> with
two arguments. Also, macros are expanded before the compiler interprets the
meaning of the code, so a macro can, for example, implement a trait on a given
type. A function can’t, because it gets called at runtime and a trait needs to
be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Cairo code — or, even more complex, Rust code — that writes Cairo code. Due to
this indirection, macro definitions are generally more difficult to read,
understand, and maintain than function definitions.</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<h2 id="declarative-inline-macros-for-general-metaprogramming"><a class="header" href="#declarative-inline-macros-for-general-metaprogramming">Declarative Inline Macros for General Metaprogramming</a></h2>
<p>The most simple form of macros in Cairo is the <em>declarative macro</em>, also
sometimes referred to as just plain “macros.” At their core, declarative macros
allow you to write something similar to a <code>match</code> expression. As discussed in
<a href="./ch06-00-enums-and-pattern-matching.html">Chapter 6</a>, <code>match</code> expressions are
control structures that take an expression, compare the resultant value of the
expression to patterns, and then run the code associated with the matching
pattern. Macros also compare a value to patterns that are associated with
particular code: in this situation, the value is the literal Cairo source code
passed to the macro; the patterns are compared with the structure of that source
code; and the code associated with each pattern, when matched, replaces the code
passed to the macro. This all happens during compilation.</p>
<p>To define a macro, you use the <code>macro</code> construct. Let’s explore this style by
looking at how an “array-building” macro works. Earlier, we used Cairo’s
built-in <code>array!</code> macro to create arrays with particular values. For example,
the following creates a new array containing three integers:</p>
<pre><code class="language-cairo">let a = array![1, 2, 3];
</code></pre>
<p>We could also use <code>array!</code> to make an array of two integers or five values of
other types, because the macro can accept a variable number of arguments. We
wouldn’t be able to use a regular function to do the same because we wouldn’t
know the number or types of values up front.</p>
<p>Below is a slightly simplified definition of an array-building macro written in
Cairo. It isn’t the exact <code>array!</code> macro from the core library, but it shows the
same core idea using declarative inline macros:</p>
<pre><code class="language-cairo">macro make_array {
    ($($x:expr), *) =&gt; {
        {
            let mut arr = $defsite::ArrayTrait::new();
            $(arr.append($x);)*
            arr
        }
    };
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Note: The built-in <code>array!</code> macro in the standard library may include
optimizations (like reserving capacity) that we don’t include here to keep the
example simple.</p>
</blockquote>
<p>The structure of the macro body is similar to a <code>match</code> expression. Here we have
one arm with the pattern <code>($($x:expr), *)</code>, followed by <code>=&gt;</code> and the block of
code associated with this pattern. If the pattern matches, the associated block
of code is emitted. More complex macros can have multiple arms, each with a
different pattern.</p>
<p>Pattern syntax in macro definitions differs from pattern syntax used when
matching values: macro patterns are matched against Cairo source code structure.
Let’s walk through the pattern pieces in the example above:</p>
<ul>
<li>We use parentheses to encompass the whole matcher pattern.</li>
<li>A dollar sign (<code>$</code>) introduces a macro variable that will capture the code
matching the subpattern. Within <code>$()</code> is <code>$x:expr</code>, which matches any Cairo
expression and gives that expression the name <code>$x</code>.</li>
<li>The comma following <code>$()</code> requires literal commas between each matched
expression.</li>
<li>The <code>*</code> quantifier specifies the subpattern can repeat zero or more times.</li>
</ul>
<p>When we call this macro with <code>make_array![1, 2, 3]</code>, the <code>$x</code> pattern matches
three times: the expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now look at the expansion side: <code>$(arr.append($x);)*</code> is generated once for each
match of <code>$()</code> in the pattern. The <code>$x</code> is replaced with each matched
expression. Calling <code>make_array![1, 2, 3]</code> expands to code like the following:</p>
<blockquote>
<p>Note: The VSCode extension can help you inspect the expanded code by doing
<code>Ctrl+Shift+P</code> and then <code>Cairo: Recursively expand macros for item at caret</code>.</p>
</blockquote>
<pre><code class="language-cairo ignore">{
    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr
}
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and
generate code to create an array containing the specified elements.</p>
<p>Usage looks like this:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span>    let a = make_array![1, 2, 3];
<span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>To use them, enable the experimental feature in your <code>Scarb.toml</code>:</p>
<pre><code class="language-toml"># [package]
# name = "listing_inline_macros"
# version = "0.1.0"
# edition = "2024_07"
# 
experimental-features = ["user_defined_inline_macros"]
# 
# [cairo]
# 
# [dependencies]
# cairo_execute = "2.13.1"
# 
# [dev-dependencies]
# snforge_std = "0.51.1"
# assert_macros = "2.13.1"
# 
# [scripts]
# test = "snforge test"
# 
# [tool.scarb]
# allow-prebuilt-plugins = ["snforge_std"]
</code></pre>
<p>Inline macros are defined with <code>macro name { ... }</code> where each arm matches a
code pattern and expands to replacement code. Like Rust’s macros-by-example, you
capture syntax fragments with <code>$var: kind</code> and can repeat matches with <code>$()*</code>,
<code>$()+</code>, or <code>$()?</code>.</p>
<!-- Removed trivial first macro example to reduce redundancy with array example -->
<h3 id="hygiene-defsitecallsite-and-expose"><a class="header" href="#hygiene-defsitecallsite-and-expose">Hygiene, <code>$defsite</code>/<code>$callsite</code>, and <code>expose!</code></a></h3>
<p>Cairo’s inline macros are hygienic: names introduced in the macro definition
don’t leak into the call site unless you explicitly expose them. Name resolution
within macros can reference either the macro definition site or the call site
using <code>$defsite::</code> and <code>$callsite::</code>.</p>
<p>Note that, similarly to Rust, macros are expected to expand to a single
expression; thus, if your macro defines several statements, you should wrap them
with an additional <code>{}</code> block that returns a final expression.</p>
<p>The following end-to-end example illustrates all of these aspects together:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span>mod hygiene_demo {
    // A helper available at the macro definition site
    fn def_bonus() -&gt; u8 {
        10
    }

    // Adds the defsite bonus, regardless of what exists at the callsite
    pub macro add_defsite_bonus {
        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
    }

    // Adds the callsite bonus, resolved where the macro is invoked
    pub macro add_callsite_bonus {
        ($x: expr) =&gt; { $x + $callsite::bonus() };
    }

    // Exposes a variable to the callsite using `expose!`.
    pub macro apply_and_expose_total {
        ($base: expr) =&gt; {
            let total = $base + 1;
            expose!(let exposed_total = total;);
        };
    }

    // A helper macro that reads a callsite-exposed variable
    pub macro read_exposed_total {
        () =&gt; { $callsite::exposed_total };
    }

    // Wraps apply_and_expose_total and then uses another inline macro
    // that accesses the exposed variable via `$callsite::...`.
    pub macro wrapper_uses_exposed {
        ($x: expr) =&gt; {
            {
                $defsite::apply_and_expose_total!($x);
                $defsite::read_exposed_total!()
            }
        };
    }
}
<span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Usage at the call site:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span>
    // Callsite defines its own `bonus` — used only by callsite-resolving macro
    let bonus = | | -&gt; u8 {
        20
    };
    let price: u8 = 5;
    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20

    // Call in statement position; it exposes `exposed_total` at the callsite
    apply_and_expose_total!(3);
    assert_eq!(exposed_total, 4);

    // A macro invoked by another macro can access exposed values via `$callsite::...`
    let w = wrapper_uses_exposed!(7);
    assert_eq!(w, 8);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>What this demonstrates:</p>
<ul>
<li><code>$defsite::...</code> resolves to items next to the macro definition, stable across
call sites.</li>
<li><code>$callsite::...</code> resolves to items visible where the macro is invoked.</li>
<li>Names don’t leak by default; <code>expose!</code> can deliberately introduce new items
into the call site.</li>
<li>Exposed names are accessible to other inline macros invoked inside your macro
body via <code>$callsite::name</code>.</li>
</ul>
<!-- Removed standalone repetition section; already covered in make_array example matcher and expansion explanation. -->
<!-- Consolidated into the hygiene e2e example above. -->
<!-- Covered by the hygiene e2e example (returns from a block). -->
<!-- Omitted to keep this section focused on core concepts for release notes. -->
<p>Notes:</p>
<ul>
<li>This feature is experimental; syntax and capabilities may evolve.</li>
<li>Item-producing macros (structs, enums, functions, etc.) are not yet supported;
support will be added in future versions.</li>
<li>For attributes, derives, and crate-wide transformations, prefer procedural
macros (next section).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h1>
<p>Cairo provides macros as a fundamental feature that lets you write code that
generates other code (known as metaprogramming). When you use macros, you can
extend Cairo's capabilities beyond what regular functions offer. Throughout this
book, we've used macros like <code>println!</code> and <code>assert!</code>, but haven't fully
explored how we can create our own macros.</p>
<p>Before diving into procedural macros specifically, let's understand why we need
macros when we already have functions:</p>
<blockquote>
<p>Tip: For many expression-level use cases, prefer the declarative inline macros
written directly in Cairo (see
<a href="./ch12-05-macros.html#declarative-inline-macros-for-general-metaprogramming">Macros → Declarative Inline Macros</a>).
Use procedural macros when you need attributes/derives or advanced
transformations that operate across items or require Rust-side logic.</p>
</blockquote>
<h2 id="cairo-procedural-macros-are-rust-functions"><a class="header" href="#cairo-procedural-macros-are-rust-functions">Cairo Procedural Macros are Rust Functions</a></h2>
<p>Just as the Cairo compiler is written in Rust, procedural macros are Rust
functions that transform Cairo code. These functions take Cairo code as input
and return modified Cairo code as output. To implement macros, you'll need a
package with both a <code>Cargo.toml</code> and a <code>Scarb.toml</code> file. The <code>Cargo.toml</code>
defines the macro implementation dependencies, while the <code>Scarb.toml</code> marks the
package as a macro and defines its metadata.</p>
<p>The function that defines a procedural macro operates on two key types:</p>
<ul>
<li><code>TokenStream</code>: A sequence of Cairo tokens representing your source code.
Tokens are the smallest units of code that the compiler recognizes (like
identifiers, keywords, and operators).</li>
<li><code>ProcMacroResult</code>: An enhanced version of TokenStream that includes both the
generated code and any diagnostic messages (warnings or errors) that should be
shown to the user during compilation.</li>
</ul>
<p>The function implementing the macro must be decorated with one of three special
attributes that tell the compiler how the macro should be used:</p>
<ul>
<li><code>#[inline_macro]</code>: For macros that look like function calls (e.g.,
<code>println!()</code>)</li>
<li><code>#[attribute_macro]</code>: For macros that act as attributes (e.g.,
<code>#[generate_trait]</code>)</li>
<li><code>#[derive_macro]</code>: For macros that implement traits automatically</li>
</ul>
<p>Each attribute type corresponds to a different use case and affects how the
macro can be invoked in your code.</p>
<p>Here are the signatures for each types :</p>
<pre><code class="language-rust  ignore">#[inline_macro]
pub fn inline(code: TokenStream) -&gt; ProcMacroResult {}

#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -&gt; ProcMacroResult {}

#[derive_macro]
pub fn derive(code: TokenStream) -&gt; ProcMacroResult {}</code></pre>
<h3 id="install-dependencies"><a class="header" href="#install-dependencies">Install dependencies</a></h3>
<p>To use procedural macros, you need to have Rust toolchain (Cargo) installed on
your machine. To install Rust using Rustup, you can run the following command in
you terminal :</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2 id="create-your-macro"><a class="header" href="#create-your-macro">Create your macro</a></h2>
<p>Creating a procedural macro requires setting up a specific project structure.
Your macro project needs:</p>
<ol>
<li>
<p>A Rust Project (where you implement the macro):</p>
<ul>
<li><code>Cargo.toml</code>: Defines Rust dependencies and build settings</li>
<li><code>src/lib.rs</code>: Contains the macro implementation</li>
</ul>
</li>
<li>
<p>A Cairo Project:</p>
<ul>
<li><code>Scarb.toml</code>: Declares the macro for Cairo projects</li>
<li>No Cairo source files needed</li>
</ul>
</li>
</ol>
<p>Let's walk through each component and understand its role:</p>
<pre><code class="language-bash">├── Cargo.toml
├── Scarb.toml
├── src
│   └── lib.rs
</code></pre>
<p>The project contains a <code>Scarb.toml</code> and a <code>Cargo.toml</code> file in the root
directory.</p>
<p>The Cargo manifest file needs to contain a <code>crate-type = ["cdylib"]</code> on the
<code>[lib]</code> target, and the <code>cairo-lang-macro</code> crate on the <code>[dependencies]</code> target.
Here is an example :</p>
<pre><code class="language-toml">[package]
name = "pow"
version = "0.1.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
bigdecimal = "0.4.5"
cairo-lang-macro = "0.1.1"
cairo-lang-parser = "2.13.1"
cairo-lang-syntax = "2.13.1"

[workspace]
</code></pre>
<p>The Scarb manifest file must define a <code>[cairo-plugin]</code> target type. Here is an
example :</p>
<pre><code class="language-toml">[package]
name = "pow"
version = "0.1.0"

[cairo-plugin]
</code></pre>
<p>Finally the project needs to contain a Rust library (<code>lib.rs</code>), inside the
<code>src/</code> directory that implements the procedural macro API.</p>
<p>As you might have notice the project doesn't need any cairo code, it only
requires the <code>Scarb.toml</code> manifest file mentioned.</p>
<h2 id="using-your-macro"><a class="header" href="#using-your-macro">Using your macro</a></h2>
<p>From the user's perspective, you only need to add the package defining the macro
in your dependencies. In the project using the macro you will have a Scarb
manifest file with :</p>
<pre><code class="language-toml">[package]
name = "no_listing_15_procedural_macro"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
cairo_execute = "2.13.1"
pow = { path = "../no_listing_16_procedural_macro_expression" }
hello_macro = { path = "../no_listing_17_procedural_macro_derive" }
rename_macro = { path = "../no_listing_18_procedural_macro_attribute" }


[dev-dependencies]
cairo_test = "2.13.1"

[cairo]
enable-gas = false


[[target.executable]]
name = "main"
function = "no_listing_15_procedural_macro::main"
</code></pre>
<h2 id="expression-macros"><a class="header" href="#expression-macros">Expression Macros</a></h2>
<p>Note: If your goal is to generate or transform expressions and small blocks, the
inline declarative macros covered earlier are simpler to write and maintain. Use
procedural expression macros when you specifically need Rust-powered parsing or
when your macro logic lives outside Cairo. As a concrete example, let’s look at
a compile-time power function implemented as a procedural macro.</p>
<h3 id="creating-an-expression-macros"><a class="header" href="#creating-an-expression-macros">Creating an expression Macros</a></h3>
<p>To understand how to create an expression macro, we will look at a <code>pow</code> macro
implementation from the
<a href="https://github.com/keep-starknet-strange/alexandria">Alexandria</a> library that
computes the power of a number at compile time.</p>
<p>The core code of the macro implementation is a Rust code that uses three Rust
crates : <code>cairo_lang_macro</code> specific to macros implementation,
<code>cairo_lang_parser</code> crate with function related to the compiler parser and
<code>cairo_lang_syntax</code> related to the compiler syntax. The two latters were
initially created for the Cairo lang compiler, as macro functions operate at the
Cairo syntax level, we can reuse the logic directly from the syntax functions
created for the compiler to create macros.</p>
<blockquote>
<p><strong>Note:</strong> To understand better the Cairo compiler and some of the concepts we
only mention here such as the Cairo parser or the Cairo syntax, you can read
the
<a href="https://github.com/software-mansion-labs/cairo-compiler-workshop">Cairo compiler workshop</a>.</p>
</blockquote>
<p>In the <code>pow</code> function example below the input is processed to extract the value
of the base argument and the exponent argument to return the result of
\(base^{exponent}\).</p>
<pre><code class="language-rust  noplayground">use bigdecimal::{num_traits::pow, BigDecimal};
use cairo_lang_macro::{inline_macro, Diagnostic, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;

#[inline_macro]
pub fn pow(token_stream: TokenStream) -&gt; ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);

    // extracting the args from the parsed input
    let macro_args: Vec&lt;String&gt; = parsed
        .descendants(&amp;db)
        .next()
        .unwrap()
        .get_text(&amp;db)
        .trim_matches(|c| c == '(' || c == ')')
        .split(',')
        .map(|s| s.trim().to_string())
        .collect();

    if macro_args.len() != 2 {
        return ProcMacroResult::new(TokenStream::empty()).with_diagnostics(
            Diagnostic::error(format!("Expected two arguments, got {:?}", macro_args)).into(),
        );
    }

    // getting the value from the base arg
    let base: BigDecimal = match macro_args[0].parse() {
        Ok(val) =&gt; val,
        Err(_) =&gt; {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid base value").into());
        }
    };

    // getting the value from the exponent arg
    let exp: usize = match macro_args[1].parse() {
        Ok(val) =&gt; val,
        Err(_) =&gt; {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid exponent value").into());
        }
    };

    // base^exp
    let result: BigDecimal = pow(base, exp);

    ProcMacroResult::new(TokenStream::new(result.to_string()))
}</code></pre>
<p>Now that the macro is defined, we can use it. In a Cairo project we need to have
<code>pow = { path = "path/to/pow" }</code> in the <code>[dependencies]</code> target of the
<code>Scarb.toml</code> manifest file. And then we can use it without further import like
this :</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a = SomeType {};
</span><span class="boring">    a.hello();
</span><span class="boring">
</span>    let res = pow!(10, 2);
    println!("res : {}", res);
<span class="boring">
</span><span class="boring">    let _a = RenamedType {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(HelloMacro, Drop, Destruct)]
</span><span class="boring">struct SomeType {}
</span><span class="boring">
</span><span class="boring">#[rename]
</span><span class="boring">struct OldType {}
</span><span class="boring">
</span><span class="boring">trait Hello&lt;T&gt; {
</span><span class="boring">    fn hello(self: @T);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h2>
<p>Derive macros let you define custom trait implementations that can be
automatically applied to types. When you annotate a type with
<code>#[derive(TraitName)]</code>, your derive macro:</p>
<ol>
<li>Receives the type's structure as input</li>
<li>Contains your custom logic for generating the trait implementation</li>
<li>Outputs the implementation code that will be included in the crate</li>
</ol>
<p>Writing derive macros eliminates repetitive trait implementation code by using a
generic logic on how to generate the trait implementation.</p>
<h3 id="creating-a-derive-macro"><a class="header" href="#creating-a-derive-macro">Creating a derive macro</a></h3>
<p>In this example, we will implement a derive macro that will implement the
<code>Hello</code> Trait. The <code>Hello</code> trait will have a <code>hello()</code> function that will print
: <code>Hello, StructName!</code>, where <em>StructName</em> is the name of the struct.</p>
<p>Here is the definition of the <code>Hello</code> trait :</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a = SomeType {};
</span><span class="boring">    a.hello();
</span><span class="boring">
</span><span class="boring">    let res = pow!(10, 2);
</span><span class="boring">    println!("res : {}", res);
</span><span class="boring">
</span><span class="boring">    let _a = RenamedType {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(HelloMacro, Drop, Destruct)]
</span><span class="boring">struct SomeType {}
</span><span class="boring">
</span><span class="boring">#[rename]
</span><span class="boring">struct OldType {}
</span><span class="boring">
</span>trait Hello&lt;T&gt; {
    fn hello(self: @T);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Let's check the marcro implementation, first the <code>hello_derive</code> function parses
the input token stream and then extracts the <code>struct_name</code> to implement the
trait for that specific struct.</p>
<p>Then hello derived returns a hard-coded piece of code containing the
implementation of <code>Hello</code> trait for the type <em>StructName</em>.</p>
<pre><code class="language-rust  noplayground">use cairo_lang_macro::{derive_macro, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;
use cairo_lang_syntax::node::kind::SyntaxKind::{TerminalStruct, TokenIdentifier};

#[derive_macro]
pub fn hello_macro(token_stream: TokenStream) -&gt; ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);
    let mut nodes = parsed.descendants(&amp;db);

    let mut struct_name = String::new();
    for node in nodes.by_ref() {
        if node.kind(&amp;db) == TerminalStruct {
            struct_name = nodes
                .find(|node| node.kind(&amp;db) == TokenIdentifier)
                .unwrap()
                .get_text(&amp;db)
                .to_string();
            break;
        }
    }

    ProcMacroResult::new(TokenStream::new(indoc::formatdoc! {r#"
            impl SomeHelloImpl of Hello&lt;{0}&gt; {{
                fn hello(self: @{0}) {{
                    println!("Hello {0}!");
                }}
            }}
        "#, struct_name}))
}</code></pre>
<p>Now that the macro is defined, we can use it. In a Cairo project we need to have
<code>hello_macro = { path = "path/to/hello_macro" }</code> in the <code>[dependencies]</code> target
of the <code>Scarb.toml</code> manifest file. And we can then use it without further import
on any struct :</p>
<pre><code class="language-cairo  noplayground">#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}
</code></pre>
<p>And now we can call the implemented function <code>hello</code> on an variable of the type
<em>SomeType</em>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let a = SomeType {};
    a.hello();
<span class="boring">
</span><span class="boring">    let res = pow!(10, 2);
</span><span class="boring">    println!("res : {}", res);
</span><span class="boring">
</span><span class="boring">    let _a = RenamedType {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(HelloMacro, Drop, Destruct)]
</span><span class="boring">struct SomeType {}
</span><span class="boring">
</span><span class="boring">#[rename]
</span><span class="boring">struct OldType {}
</span><span class="boring">
</span><span class="boring">trait Hello&lt;T&gt; {
</span><span class="boring">    fn hello(self: @T);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Note that the <code>Hello</code> trait that is implemented in the macro has to be defined
somewhere in the code or imported.</p>
<h2 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute Macros</a></h2>
<p>Attribute-like macros are similar to custom derive macros, but allowing more
possibilities, they are not restricted to struct and enum and can be applied to
other items as well, such as functions. They can be used for more diverse code
generation than implementing trait. It could be used to modify the name of a
struct, add fields in the structure, execute some code before a function, change
the signature of a function and many other possibilities.</p>
<p>The extra possibilities also come from the fact that they are defined with a
second argument <code>TokenStream</code>, indeed the signature looks like this :</p>
<pre><code class="language-rust  noplayground">#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -&gt; ProcMacroResult {}</code></pre>
<p>With the first attribute (<code>attr</code>) for the attribute arguments
(#[macro(arguments)]) and second for the actual code on which the attribute is
applied to, the second attribute is the only one the two other macros have.</p>
<h3 id="creating-an-attribute-macro"><a class="header" href="#creating-an-attribute-macro">Creating an attribute macro</a></h3>
<p>Now let's look at an example of a custom made attribute macro, in this example
we will create a macro that will rename the struct.</p>
<pre><code class="language-rust  noplayground">use cairo_lang_macro::attribute_macro;
use cairo_lang_macro::{ProcMacroResult, TokenStream};

#[attribute_macro]
pub fn rename(_attr: TokenStream, token_stream: TokenStream) -&gt; ProcMacroResult {
    ProcMacroResult::new(TokenStream::new(
        token_stream
            .to_string()
            .replace("struct OldType", "#[derive(Drop)]\n struct RenamedType"),
    ))
}</code></pre>
<p>Again, to use the macro in a Cairo project we need to have
<code>rename_macro = { path = "path/to/rename_macro" }</code> in the <code>[dependencies]</code>
target of the <code>Scarb.toml</code> manifest file. And we can then use it without further
import on any struct.</p>
<p>The rename macro can be derived as follow :</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a = SomeType {};
</span><span class="boring">    a.hello();
</span><span class="boring">
</span><span class="boring">    let res = pow!(10, 2);
</span><span class="boring">    println!("res : {}", res);
</span><span class="boring">
</span><span class="boring">    let _a = RenamedType {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(HelloMacro, Drop, Destruct)]
</span><span class="boring">struct SomeType {}
</span><span class="boring">
</span>#[rename]
struct OldType {}
<span class="boring">
</span><span class="boring">trait Hello&lt;T&gt; {
</span><span class="boring">    fn hello(self: @T);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Now the compiler knows the <em>RenamedType</em> struct, therefore we can create an
instance as such :</p>
<pre><code class="language-cairo"><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a = SomeType {};
</span><span class="boring">    a.hello();
</span><span class="boring">
</span><span class="boring">    let res = pow!(10, 2);
</span><span class="boring">    println!("res : {}", res);
</span><span class="boring">
</span>    let _a = RenamedType {};
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(HelloMacro, Drop, Destruct)]
</span><span class="boring">struct SomeType {}
</span><span class="boring">
</span><span class="boring">#[rename]
</span><span class="boring">struct OldType {}
</span><span class="boring">
</span><span class="boring">trait Hello&lt;T&gt; {
</span><span class="boring">    fn hello(self: @T);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>You can notice that the names <em>OldType</em> and <em>RenamedType</em> were hardcoded in the
example but could be variables leveraging the second arg of rattribute macro.
Also note that due to the order of compilation, the derive of other macro such
as <em>Drop</em> here as to be done in the code generated by the macro. Some deeper
understanding of Cairo compilation can be required for custom macro creation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inlining-in-cairo"><a class="header" href="#inlining-in-cairo">Inlining in Cairo</a></h1>
<p>Inlining is a common code optimization technique supported by most compilers. It
involves replacing a function call at the call site with the actual code of the
called function, eliminating the overhead associated with the function call
itself. This can improve performance by reducing the number of instructions
executed, but may increase the total size of the program. When you're thinking
about whether to inline a function, take into account things like how big it is,
what parameters it has, how often it gets called, and how it might affect the
size of your compiled code.</p>
<h2 id="the-inline-attribute"><a class="header" href="#the-inline-attribute">The <code>inline</code> Attribute</a></h2>
<p>In Cairo, the <code>inline</code> attribute suggests whether or not the Sierra code
corresponding to the attributed function should be directly injected in the
caller function's context, rather than using a <code>function_call</code> libfunc to
execute that code.</p>
<p>There are three variants of the <code>inline</code> attribute that one can use:</p>
<ul>
<li><code>#[inline]</code> suggests performing an inline expansion.</li>
<li><code>#[inline(always)]</code> suggests that an inline expansion should always be
performed.</li>
<li><code>#[inline(never)]</code> suggests that an inline expansion should never be
performed.</li>
</ul>
<blockquote>
<p>Note: the <code>inline</code> attribute in every form is a hint, with no requirements on
the language to place a copy of the attributed function in the caller. This
means that the attribute may be ignored by the compiler. In practice,
<code>#[inline(always)]</code> will cause inlining in all but the most exceptional cases.</p>
</blockquote>
<p>Many of the Cairo corelib functions are inlined. User-defined functions may also
be annotated with the <code>inline</code> attribute. Annotating functions with the
<code>#[inline(always)]</code> attribute reduces the total number of steps required when
calling these attributed functions. Indeed, injecting the Sierra code at the
caller site avoids the step-cost involved in calling functions and obtaining
their arguments.</p>
<p>However, inlining can also lead to increased code size. Whenever a function is
inlined, the call site contains a copy of the function's Sierra code,
potentially leading to duplication of code across the compiled code.</p>
<p>Therefore, inlining should be applied with caution. Using <code>#[inline]</code> or
<code>#[inline(always)]</code> indiscriminately will lead to increased compile time. It is
particularly useful to inline small functions, ideally with many arguments. This
is because inlining large functions will increase the code length of the
program, and handling many arguments will increase the number of steps to
execute these functions.</p>
<p>The more frequently a function is called, the more beneficial inlining becomes
in terms of performance. By doing so, the number of steps for the execution will
be lower, while the code length will not grow that much or might even decrease
in terms of total number of instructions.</p>
<blockquote>
<p>Inlining is often a tradeoff between number of steps and code length. Use the
<code>inline</code> attribute cautiously where it is appropriate.</p>
</blockquote>
<h2 id="inlining-decision-process"><a class="header" href="#inlining-decision-process">Inlining decision process</a></h2>
<p>The Cairo compiler follows the <code>inline</code> attribute but for functions without
explicit inline directives, it will use a heuristic approach. The decision to
inline or not a function will be made depending on the complexity of the
attributed function and mostly rely on the threshold
<code>DEFAULT_INLINE_SMALL_FUNCTIONS_THRESHOLD</code>.</p>
<p>The compiler calculates a function's "weight" using the <code>ApproxCasmInlineWeight</code>
struct, which estimates the number of Cairo Assembly (CASM) statements the
function will generate. This weight calculation provides a more nuanced view of
the function's complexity than a simple statement count. If a function's weight
falls below the threshold, it will be inlined.</p>
<p>In addition to the weight-based approach, the compiler also considers the raw
statement count. Functions with fewer statements than the threshold are
typically inlined, promoting the optimization of small, frequently called
functions.</p>
<p>The inlining process also accounts for special cases. Very simple functions,
such as those that only call another function or return a constant, are always
inlined regardless of other factors. Conversely, functions with complex control
flow structures like <code>Match</code> or those ending with a <code>Panic</code> are generally not
inlined.</p>
<h2 id="inlining-example"><a class="header" href="#inlining-example">Inlining Example</a></h2>
<p>Let's introduce a short example to illustrate the mechanisms of inlining in
Cairo. Listing 12-5 shows a basic program allowing comparison
between inlined and non-inlined functions.</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    inlined() + not_inlined()
}

#[inline(always)]
fn inlined() -&gt; felt252 {
    1
}

#[inline(never)]
fn not_inlined() -&gt; felt252 {
    2
}
</code></pre>
<p>Cairo program that adds the return value of 2 functions, with one of them being
inlined</span></p>
<p>Let's take a look at the corresponding Sierra code to see how inlining works
under the hood:</p>
<pre><code class="language-cairo noplayground">// type declarations
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]

// libfunc declarations
libfunc function_call&lt;user@main::main::not_inlined&gt; = function_call&lt;user@main::main::not_inlined&gt;
libfunc felt252_const&lt;1&gt; = felt252_const&lt;1&gt;
libfunc store_temp&lt;felt252&gt; = store_temp&lt;felt252&gt;
libfunc felt252_add = felt252_add
libfunc felt252_const&lt;2&gt; = felt252_const&lt;2&gt;

// statements
00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 felt252_const&lt;1&gt;() -&gt; ([1])
02 store_temp&lt;felt252&gt;([1]) -&gt; ([1])
03 felt252_add([1], [0]) -&gt; ([2])
04 store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05 return([2])
06 felt252_const&lt;1&gt;() -&gt; ([0])
07 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
08 return([0])
09 felt252_const&lt;2&gt;() -&gt; ([0])
10 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
11 return([0])

// funcs
main::main::main@0() -&gt; (felt252)
main::main::inlined@6() -&gt; (felt252)
main::main::not_inlined@9() -&gt; (felt252)
</code></pre>
<p>The Sierra file is structured in three parts:</p>
<ul>
<li>Type and libfunc declarations.</li>
<li>Statements that constitute the program.</li>
<li>Declaration of the functions of the program.</li>
</ul>
<p>The Sierra code statements always match the order of function declarations in
the Cairo program. Indeed, the declaration of the functions of the program tells
us that:</p>
<ul>
<li><code>main</code> function starts at line 0, and returns a <code>felt252</code> on line 5.</li>
<li><code>inlined</code> function starts at line 6, and returns a <code>felt252</code> on line 8.</li>
<li><code>not_inlined</code> function starts at line 9, and returns a <code>felt252</code> on line 11.</li>
</ul>
<p>All statements corresponding to the <code>main</code> function are located between lines 0
and 5:</p>
<pre><code class="language-cairo noplayground">00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 felt252_const&lt;1&gt;() -&gt; ([1])
02 store_temp&lt;felt252&gt;([1]) -&gt; ([1])
03 felt252_add([1], [0]) -&gt; ([2])
04 store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05 return([2])
</code></pre>
<p>The <code>function_call</code> libfunc is called on line 0 to execute the <code>not_inlined</code>
function. This will execute the code from lines 9 to 10 and store the return
value in the variable with id <code>0</code>.</p>
<pre><code class="language-cairo noplayground">09	felt252_const&lt;2&gt;() -&gt; ([0])
10	store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>This code uses a single data type, <code>felt252</code>. It uses two library functions
- <code>felt252_const&lt;2&gt;</code>, which returns the constant <code>felt252</code> 2,
and <code>store_temp&lt;felt252&gt;</code>, which pushes a constant value to memory. The first
line calls the <code>felt252_const&lt;2&gt;</code> libfunc to create a variable with id <code>0</code>.
Then, the second line pushes this variable to memory for later use.</p>
<p>After that, Sierra statements from line 1 to 2 are the actual body of the
<code>inlined</code> function:</p>
<pre><code class="language-cairo noplayground">06	felt252_const&lt;1&gt;() -&gt; ([0])
07	store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>The only difference is that the inlined code will store the <code>felt252_const</code>
value in a variable with id <code>1</code>, because <code>[0]</code> refers to a variable previously
assigned:</p>
<pre><code class="language-cairo noplayground">01	felt252_const&lt;1&gt;() -&gt; ([1])
02	store_temp&lt;felt252&gt;([1]) -&gt; ([1])
</code></pre>
<blockquote>
<p>Note: in both cases (inlined or not), the <code>return</code> instruction of the function
being called is not executed, as this would lead to prematurely end the
execution of the <code>main</code> function. Instead, return values of <code>inlined</code> and
<code>not_inlined</code> will be added and the result will be returned.</p>
</blockquote>
<p>Lines 3 to 5 contain the Sierra statements that will add the values contained in
variables with ids <code>0</code> and <code>1</code>, store the result in memory and return it:</p>
<pre><code class="language-cairo noplayground">03	felt252_add([1], [0]) -&gt; ([2])
04	store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05	return([2])
</code></pre>
<p>Now, let's take a look at the Casm code corresponding to this program to really
understand the benefits of inlining.</p>
<h2 id="casm-code-explanations"><a class="header" href="#casm-code-explanations">Casm Code Explanations</a></h2>
<p>Here is the Casm code for our previous program example:</p>
<pre><code class="language-cairo noplayground">1	call rel 3
2	ret
3	call rel 9
4	[ap + 0] = 1, ap++
5	[ap + 0] = [ap + -1] + [ap + -2], ap++
6	ret
7	[ap + 0] = 1, ap++
8	ret
9	[ap + 0] = 2, ap++
10	ret
11	ret
</code></pre>
<p>Don't hesitate to use <a href="https://cairovm.codes/">cairovm.codes</a> playground to
follow along and see all the execution trace.</p>
<p>Each instruction and each argument for any instruction increment the Program
Counter (known as PC) by 1. This means that <code>ret</code> on line 2 is actually the
instruction at <code>PC = 3</code>, as the argument <code>3</code> corresponds to <code>PC = 2</code>.</p>
<p>The <code>call</code> and <code>ret</code> instructions allow implementation of a function stack:</p>
<ul>
<li><code>call</code> instruction acts like a jump instruction, updating the PC to a given
value, whether relatively to the current value using <code>rel</code> or absolutely using
<code>abs</code>.</li>
<li><code>ret</code> instruction jumps back right after the <code>call</code> instruction and continues
the execution of the code.</li>
</ul>
<p>We can now decompose how these instructions are executed to understand what this
code does:</p>
<ul>
<li><code>call rel 3</code>: this instruction increments the PC by 3 and executes the
instruction at this location, which is <code>call rel 9</code> at <code>PC = 4</code>.</li>
<li><code>call rel 9</code> increments the PC by 9 and executes the instruction at <code>PC = 13</code>,
which is actually line 9.</li>
<li><code>[ap + 0] = 2, ap++</code>: <code>ap</code> stands for Allocation Pointer, which points to the
first memory cell that has not been used by the program so far. This means we
store the value <code>2</code> in the next free memory cell indicated by the current
value of <code>ap</code>, after which we increment <code>ap</code> by 1. Then, we go to the next
line which is <code>ret</code>.</li>
<li><code>ret</code>: jumps back to the line after <code>call rel 9</code>, so we go to line 4.</li>
<li><code>[ap + 0] = 1, ap++</code> : we store the value <code>1</code> in <code>[ap]</code> and we apply <code>ap++</code> so
that <code>[ap - 1] = 1</code>. This means we now have <code>[ap-1] = 1, [ap-2] = 2</code> and we go
to the next line.</li>
<li><code>[ap + 0] = [ap + -1] + [ap + -2], ap++</code>: we sum the values <code>1</code> and <code>2</code> and
store the result in <code>[ap]</code>, and we apply <code>ap++</code> so the result is
<code>[ap-1] = 3, [ap-2] = 1, [ap-3]=2</code>.</li>
<li><code>ret</code>: jumps back to the line after <code>call rel 3</code>, so we go to line 2.</li>
<li><code>ret</code>: last instruction executed as there is no more <code>call</code> instruction where
to jump right after. This is the actual return instruction of the Cairo <code>main</code>
function.</li>
</ul>
<p>To summarize:</p>
<ul>
<li><code>call rel 3</code> corresponds to the <code>main</code> function, which is obviously not
inlined.</li>
<li><code>call rel 9</code> triggers the call to the <code>not_inlined</code> function, which returns
<code>2</code> and stores it at the final location <code>[ap-3]</code>.</li>
<li>The line 4 is the inlined code of the <code>inlined</code> function, which returns <code>1</code>
and stores it at the final location <code>[ap-2]</code>. We clearly see that there is no
<code>call</code> instruction in this case, because the body of the function is inserted
and directly executed.</li>
<li>After that, the sum is computed and we ultimately go back to the line 2 which
contains the final <code>ret</code> instruction that returns the sum, corresponding to
the return value of the <code>main</code> function.</li>
</ul>
<p>It is interesting to note that in both Sierra code and Casm code, the
<code>not_inlined</code> function will be called and executed before the body of the
<code>inlined</code> function, even though the Cairo program executes
<code>inlined() + not_inlined()</code>.</p>
<blockquote>
<p>The Casm code of our program clearly shows that there is a function call for
the <code>not_inlined</code> function, while the <code>inlined</code> function is correctly inlined.</p>
</blockquote>
<h2 id="additional-optimizations"><a class="header" href="#additional-optimizations">Additional Optimizations</a></h2>
<p>Let's study another program that shows other benefits that inlining may
sometimes provide. Listing 12-6 shows a Cairo program that
calls 2 functions and doesn't return anything:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    inlined();
    not_inlined();
}

#[inline(always)]
fn inlined() -&gt; felt252 {
    'inlined'
}

#[inline(never)]
fn not_inlined() -&gt; felt252 {
    'not inlined'
}
</code></pre>
<p>small Cairo program that calls <code>inlined</code> and <code>not_inlined</code> and doesn't return
any value.</span></p>
<p>Here is the corresponding Sierra code:</p>
<pre><code class="language-cairo noplayground">// type declarations
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]
type Unit = Struct&lt;ut@Tuple&gt; [storable: true, drop: true, dup: true, zero_sized: true]

// libfunc declarations
libfunc function_call&lt;user@main::main::not_inlined&gt; = function_call&lt;user@main::main::not_inlined&gt;
libfunc drop&lt;felt252&gt; = drop&lt;felt252&gt;
libfunc struct_construct&lt;Unit&gt; = struct_construct&lt;Unit&gt;
libfunc felt252_const&lt;29676284458984804&gt; = felt252_const&lt;29676284458984804&gt;
libfunc store_temp&lt;felt252&gt; = store_temp&lt;felt252&gt;
libfunc felt252_const&lt;133508164995039583817065828&gt; = felt252_const&lt;133508164995039583817065828&gt;

// statements
00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 drop&lt;felt252&gt;([0]) -&gt; ()
02 struct_construct&lt;Unit&gt;() -&gt; ([1])
03 return([1])
04 felt252_const&lt;29676284458984804&gt;() -&gt; ([0])
05 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
06 return([0])
07 felt252_const&lt;133508164995039583817065828&gt;() -&gt; ([0])
08 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
09 return([0])

// funcs
main::main::main@0() -&gt; (Unit)
main::main::inlined@4() -&gt; (felt252)
main::main::not_inlined@7() -&gt; (felt252)
</code></pre>
<p>In this specific case, we can observe that the compiler has applied additional
optimizations to the <code>main</code> function of our code : the code of the <code>inlined</code>
function, which is annotated with the <code>#[inline(always)]</code> attribute, is actually
not copied in the <code>main</code> function. Instead, the <code>main</code> function starts with the
<code>function_call</code> libfunc to call the <code>not_inlined</code> function, entirely omitting
the code of the <code>inlined</code> function.</p>
<blockquote>
<p>Because <code>inlined</code> return value is never used, the compiler optimizes the
<code>main</code> function by skipping the <code>inlined</code> function code. This will actually
reduce the code length while reducing the number of steps required to execute
<code>main</code>.</p>
</blockquote>
<p>In contrast, line 0 uses the <code>function_call</code> libfunc to execute the
<code>not_inlined</code> function normally. This means that all the code from lines 7 to 8
will be executed:</p>
<pre><code class="language-cairo noplayground">07 felt252_const&lt;133508164995039583817065828&gt;() -&gt; ([0])
08 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>This value stored in the variable with id <code>0</code> is then dropped on line 1, as it
is not used in the <code>main</code> function:</p>
<pre><code class="language-cairo noplayground">01 drop&lt;felt252&gt;([0]) -&gt; ()
</code></pre>
<p>Finally, as the <code>main</code> function doesn't return any value, a variable of unit
type <code>()</code> is created and returned:</p>
<pre><code class="language-cairo noplayground">02 struct_construct&lt;Unit&gt;() -&gt; ([1])
03 return([1])
</code></pre>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Inlining is a compiler optimization technique that can be very useful in various
situations. Inlining a function allows to get rid of the overhead of calling a
function with the <code>function_call</code> libfunc by injecting the Sierra code directly
in the caller function's context, while potentially optimizing the Sierra code
executed to reduce the number of steps. If used effectively, inlining can even
reduce code length as shown in the previous example.</p>
<p>Nevertheless, applying the <code>inline</code> attribute to a function with a lot of code
and few parameters might result in an increased code size, especially if the
inlined function is used many times in the codebase. Use inlining only where it
makes sense, and be aware that the compiler handles inlining by default.
Therefore, manually applying inlining is not recommended in most situations, but
can help improve and fine-tune your code's behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing"><a class="header" href="#printing">Printing</a></h1>
<p>When writing a program, it is quite common to print some data to the console,
either for the normal process of the program or for debugging purpose. In this
chapter, we describe the options you have to print simple and complex data
types.</p>
<h2 id="printing-standard-data-types"><a class="header" href="#printing-standard-data-types">Printing Standard Data Types</a></h2>
<p>Cairo provides two macros to print standard data types:</p>
<ul>
<li><code>println!</code> which prints on a new line</li>
<li><code>print!</code> with inline printing</li>
</ul>
<p>Both take a <code>ByteArray</code> string as first parameter (see <a href="./ch02-02-data-types.html#byte-array-strings">Data
Types</a>), which can be a simple string to print a message or a string
with placeholders to format the way values are printed.</p>
<p>There are two ways to use these placeholders and both can be mixed:</p>
<ul>
<li>empty curly brackets <code>{}</code> are replaced by values given as parameters to the
<code>print!</code> macro, in the same order.</li>
<li>curly brackets with variable names are directly replaced by the variable
value.</li>
</ul>
<p>Here are some examples:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = 10;
    let b = 20;
    let c = 30;

    println!("Hello world!");
    println!("{} {} {}", a, b, c); // 10 20 30
    println!("{c} {a} {}", b); // 30 10 20
}
</code></pre>
<blockquote>
<p><code>print!</code> and <code>println!</code> macros use the <code>Display</code> trait under the hood, and are
therefore used to print the value of types that implement it. This is the case
for basic data types, but not for more complex ones. If you try to print
complex data type values with these macros, e.g. for debugging purposes, you
will get an error. In that case, you can either <a href="./ch12-08-printing.html#printing-custom-data-types">manually
implement</a> the <code>Display</code> trait for your type or use the
<code>Debug</code> trait (see <a href="./ch12-08-printing.html#print-debug-traces">below</a>).</p>
</blockquote>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>Cairo also provides a useful macro to handle string formatting: <code>format!</code>. This
macro works like <code>println!</code>, but instead of printing the output to the screen,
it returns a <code>ByteArray</code> with the contents. In the following example, we perform
string concatenation using either the <code>+</code> operator or the <code>format!</code> macro. The
version of the code using <code>format!</code> is much easier to read, and the code
generated by the <code>format!</code> macro uses snapshots, so that this call doesn’t take
ownership of any of its parameters.</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = s1 + "-" + s2 + "-" + s3;
    // using + operator consumes the strings, so they can't be used again!

    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
    // or
    let s = format!("{}-{}-{}", s1, s2, s3);

    println!("{}", s);
}
</code></pre>
<h2 id="printing-custom-data-types"><a class="header" href="#printing-custom-data-types">Printing Custom Data Types</a></h2>
<p>As previously explained, if you try to print the value of a custom data type
with <code>print!</code> or <code>println!</code> macros, you'll get an error telling you that the
<code>Display</code> trait is not implemented for your custom type:</p>
<pre><code class="language-shell">error: Trait has no implementation in context: core::fmt::Display::&lt;package_name::struct_name&gt;
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, the curly
brackets tell <code>println!</code> to use formatting known as <code>Display</code> - output intended
for direct end user consumption. The primitive types we’ve seen so far implement
<code>Display</code> by default because there’s only one way you’d want to show a <code>1</code> or
any other primitive type to a user. But with structs, the way <code>println!</code> should
format the output is less clear because there are more display possibilities: Do
we want commas or not? Do we want to print the curly brackets? Should all the
fields be shown? Due to this ambiguity, Cairo doesn’t try to guess what we want,
and structs don’t have a provided implementation of <code>Display</code> to use with
<code>println!</code> and the <code>{}</code> placeholder.</p>
<p>Here is the <code>Display</code> trait to implement:</p>
<pre><code class="language-cairo noplayground">trait Display&lt;T&gt; {
    fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p>The second parameter <code>f</code> is of type <code>Formatter</code>, which is just a struct
containing a <code>ByteArray</code>, representing the pending result of formatting:</p>
<pre><code class="language-cairo noplayground">#[derive(Default, Drop)]
pub struct Formatter {
    /// The pending result of formatting.
    pub buffer: ByteArray,
}
</code></pre>
<p>Knowing this, here is an example of how to implement the <code>Display</code> trait for a
custom <code>Point</code> struct:</p>
<pre><code class="language-cairo">use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display&lt;Point&gt; {
    fn fmt(self: @Point, ref f: Formatter) -&gt; Result&lt;(), Error&gt; {
        let str: ByteArray = format!("Point ({}, {})", *self.x, *self.y);
        f.buffer.append(@str);
        Ok(())
    }
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}
</code></pre>
<p>Cairo also provides the <code>write!</code> and <code>writeln!</code> macros to write formatted
strings in a formatter. Here is a short example using <code>write!</code> macro to
concatenate multiple strings on the same line and then print the result:</p>
<pre><code class="language-cairo">use core::fmt::Formatter;

#[executable]
fn main() {
    let mut formatter: Formatter = Default::default();
    let a = 10;
    let b = 20;
    write!(formatter, "hello");
    write!(formatter, "world");
    write!(formatter, " {a} {b}");

    println!("{}", formatter.buffer); // helloworld 10 20
}
</code></pre>
<p>It is also possible to implement the <code>Display</code> trait for the <code>Point</code> struct
using these macros, as shown here:</p>
<pre><code class="language-cairo">use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display&lt;Point&gt; {
    fn fmt(self: @Point, ref f: Formatter) -&gt; Result&lt;(), Error&gt; {
        let x = *self.x;
        let y = *self.y;

        writeln!(f, "Point ({x}, {y})")
    }
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}
</code></pre>
<blockquote>
<p>Printing complex data types this way might not be ideal as it requires
additional steps to use the <code>print!</code> and <code>println!</code> macros. If you need to
print complex data types, especially when debugging, use the <code>Debug</code> trait
described below instead.</p>
</blockquote>
<h2 id="print-in-hexadecimal"><a class="header" href="#print-in-hexadecimal">Print in Hexadecimal</a></h2>
<p>By default, the <code>Display</code> trait prints integer values in decimal. But, as in
Rust, you can use the <code>{:x}</code> notation to print them in hexadecimal.</p>
<p>Under the hood, Cairo implements the <code>LowerHex</code> trait for common types such as
unsigned integers, <code>felt252</code> and <code>NonZero</code> but also for common Starknet types
such as <code>ContractAddress</code> and <code>ClassHash</code>.</p>
<p>If it makes sense for you, you can also implement the <code>LowerHex</code> trait for your
custom types using the same approach as for the <code>Display</code> trait (see <a href="./ch12-08-printing.html#printing-custom-data-types">Printing
Custom Data Types</a>).</p>
<h2 id="print-debug-traces"><a class="header" href="#print-debug-traces">Print Debug Traces</a></h2>
<p>Cairo provides the <code>Debug</code> trait, which can be derived to print the value of
variables when debugging. Simply add <code>:?</code> within the curly brackets <code>{}</code>
placeholders in a <code>print!</code> or <code>println!</code> macro string.</p>
<p>This trait is very useful and is implemented by default for basic data types. It
can also be simply derived for complex data types using the <code>#[derive(Debug)]</code>
attribute, as long as all types they contain implement it. This eliminates the
need to manually implement extra code to print complex data types.</p>
<p>Note that <code>assert_xx!</code> macros used in tests require the provided values to
implement the <code>Debug</code> trait, as they also print the result in case of assertion
failure.</p>
<p>For more details about the <code>Debug</code> trait and its usage for printing values when
debugging, please refer to the <a href="./appendix-03-derivable-traits.html#debug-for-printing-and-debugging">Derivable Traits</a> appendix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-circuits"><a class="header" href="#arithmetic-circuits">Arithmetic Circuits</a></h1>
<p>Arithmetic circuits are mathematical models used to represent polynomial
computations. They are defined over a field (typically a finite field \(F_p\)
where \(p\) is prime) and consist of:</p>
<ul>
<li>Input signals (values in the range \([0, p-1]\))</li>
<li>Arithmetic operations (addition and multiplication gates)</li>
<li>Output signals</li>
</ul>
<p>Cairo supports emulated arithmetic circuits with modulo up to 384 bits.</p>
<p>This is especially useful for:</p>
<ul>
<li>Implementing verification for other proof systems</li>
<li>Implementing cryptographic primitives</li>
<li>Creating more low-level programs, with potential reduced overhead compared to
standard Cairo constructs</li>
</ul>
<h2 id="implementing-arithmetic-circuits-in-cairo"><a class="header" href="#implementing-arithmetic-circuits-in-cairo">Implementing Arithmetic Circuits in Cairo</a></h2>
<p>Cairo's circuit constructs are available in the <code>core::circuit</code> module of the
corelib.</p>
<p>Arithmetic circuits consist of:</p>
<ul>
<li>Addition modulo \(p\): <code>AddMod</code> builtin</li>
<li>Multiplication modulo \(p\): <code>MulMod</code> builtin</li>
</ul>
<p>Because of the modulo properties, we can build four basic arithmetic gates:</p>
<ul>
<li>Addition: <code>AddModGate</code></li>
<li>Subtraction: <code>SubModGate</code></li>
<li>Multiplication: <code>MulModGate</code></li>
<li>Inverse: <code>InvModGate</code></li>
</ul>
<p>Let's create a circuit that computes \(a \cdot (a + b)\) over the BN254 prime
field.</p>
<p>We start from the empty struct <code>CircuitElement&lt;T&gt;</code>.</p>
<p>The inputs of our circuit are defined as <code>CircuitInput</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span>    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
<span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>We can combine circuit inputs and gates: <code>CircuitElement&lt;a&gt;</code> and
<code>CircuitElement&lt;b&gt;</code> combined with an addition gate gives
<code>CircuitElement&lt;AddModGate&lt;a, b&gt;&gt;</code>.</p>
<p>We can use <code>circuit_add</code>, <code>circuit_sub</code>, <code>circuit_mul</code> and <code>circuit_inverse</code> to
directly combine circuit elements. For \(a * (a + b)\), the description of
our circuit is:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span>    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);
<span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>Note that <code>a</code>, <code>b</code> and <code>add</code> are intermediate circuit elements and not
specifically inputs or gates, which is why we need the distinction between the
empty struct <code>CircuitElement&lt;T&gt;</code> and the circuit description specified by the
type <code>T</code>.</p>
<p>The outputs of the circuits are defined as a tuple of circuit elements. It's
possible to add any intermediate gates of our circuit, but we must add all gates
with degree 0 (gates where the output signal is not used as input of any other
gate). In our case, we will only add the last gate <code>mul</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span>    let output = (mul,);
<span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>We now have a complete description of our circuit and its outputs. We now need
to assign a value to each input. As circuits are defined with 384-bit modulus, a
single <code>u384</code> value can be represented as a fixed array of four <code>u96</code>. We can
initialize \(a\) and \(b\) to respectively \(10\) and \(20\):</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span>    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();
<span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>As the number of inputs can vary, Cairo use an accumulator and the <code>new_inputs</code>
and <code>next</code> functions return a variant of the <code>AddInputResult</code> enum.</p>
<pre><code class="language-cairo  noplayground">pub enum AddInputResult&lt;C&gt; {
    /// All inputs have been filled.
    Done: CircuitData&lt;C&gt;,
    /// More inputs are needed to fill the circuit instance's data.
    More: CircuitInputAccumulator&lt;C&gt;,
}
</code></pre>
<p>We have to assign a value to every input, by calling <code>next</code> on each
<code>CircuitInputAccumulator</code> variant. After the inputs initialization, by calling
the <code>done</code> function we get the complete circuit <code>CircuitData&lt;C&gt;</code>, where <code>C</code> is a
long type that encodes the entire circuit instance.</p>
<p>We then need to define what modulus our circuit is using (up to 384-bit
modulus), by defining a <code>CircuitModulus</code>. We want to use BN254 prime field
modulus:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span>    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();
<span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>The last part is the evaluation of the circuit, i.e. the actual process of
passing the input signals correctly through each gate described by our circuit
and getting the values of each output gate. We can evaluate and get the results
for a given modulus as follows:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span>    let res = instance.eval(bn254_modulus).unwrap();
<span class="boring">
</span><span class="boring">    let add_output = res.get_output(add);
</span><span class="boring">    let circuit_output = res.get_output(mul);
</span><span class="boring">
</span><span class="boring">    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
</span><span class="boring">    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</span><span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>To retrieve the value of a specific output, we can use the <code>get_output</code> function
on our results with the <code>CircuitElement</code> instance of the output gate we want. We
can also retrieve any intermediate gate value as well.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use core::circuit::{
</span><span class="boring">    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
</span><span class="boring">    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">// Circuit: a * (a + b)
</span><span class="boring">// witness: a = 10, b = 20
</span><span class="boring">// expected output: 10 * (10 + 20) = 300
</span><span class="boring">fn eval_circuit() -&gt; (u384, u384) {
</span><span class="boring">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
</span><span class="boring">    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</span><span class="boring">
</span><span class="boring">    let add = circuit_add(a, b);
</span><span class="boring">    let mul = circuit_mul(a, add);
</span><span class="boring">
</span><span class="boring">    let output = (mul,);
</span><span class="boring">
</span><span class="boring">    let mut inputs = output.new_inputs();
</span><span class="boring">    inputs = inputs.next([10, 0, 0, 0]);
</span><span class="boring">    inputs = inputs.next([20, 0, 0, 0]);
</span><span class="boring">
</span><span class="boring">    let instance = inputs.done();
</span><span class="boring">
</span><span class="boring">    let bn254_modulus = TryInto::&lt;
</span><span class="boring">        _, CircuitModulus,
</span><span class="boring">    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    let res = instance.eval(bn254_modulus).unwrap();
</span><span class="boring">
</span>    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
<span class="boring">
</span><span class="boring">    (add_output, circuit_output)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<p>To recap, we did the following steps:</p>
<ul>
<li>Define Circuit Inputs</li>
<li>Describe the circuit</li>
<li>Specify the outputs</li>
<li>Assign values to the inputs</li>
<li>Define the modulus</li>
<li>Evaluate the circuit</li>
<li>Get the output values</li>
</ul>
<p>And the full code is:</p>
<pre><code class="language-cairo  noplayground">use core::circuit::{
    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -&gt; (u384, u384) {
    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");

    (add_output, circuit_output)
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    eval_circuit();
</span><span class="boring">}
</span></code></pre>
<h2 id="arithmetic-circuits-in-zero-knowledge-proof-systems"><a class="header" href="#arithmetic-circuits-in-zero-knowledge-proof-systems">Arithmetic Circuits in Zero-Knowledge Proof Systems</a></h2>
<p>In zero-knowledge proof systems, a prover creates a proof of computational
statements, which a verifier can check without performing the full computation.
However, these statements must first be converted into a suitable representation
for the proof system.</p>
<h3 id="zk-snarks-approach"><a class="header" href="#zk-snarks-approach">zk-SNARKs Approach</a></h3>
<p>Some proof systems, like zk-SNARKs, use arithmetic circuits over a finite field
\(F_p\). These circuits include constraints at specific gates, represented as
equations:</p>
<p>\[ (a_1 \cdot s_1 + ... + a_n \cdot s_n) \cdot (b_1 \cdot s_1 + ... + b_n \cdot
s_n) + (c_1 \cdot s_1 + ... + c_n \cdot s_n) = 0 \mod p \] Where \(s_1, ...,
s_n\) are signals, and \(a_i, b_i, c_i\) are coefficients.</p>
<p>A witness is an assignment of signals that satisfies all constraints in a
circuit. zk-SNARK proofs use these properties to prove knowledge of a witness
without revealing private input signals, ensuring the prover's honesty while
preserving privacy.</p>
<p>Some work has already been done, such as
<a href="https://felt.gitbook.io/garaga/deploy-your-snark-verifier-on-starknet/groth16/generate-and-deploy-your-verifier-contract">Garaga Groth16 verifier</a></p>
<h3 id="zk-starks-approach"><a class="header" href="#zk-starks-approach">zk-STARKs Approach</a></h3>
<p>STARKs (which Cairo uses) use an Algebraic Intermediate Representation (AIR)
instead of arithmetic circuits. AIR describes computations as a set of
polynomial constraints.</p>
<p>By allowing emulated arithmetic circuits, Cairo can be used to implement
zk-SNARKs proof verification inside STARK proofs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="offloading-computations-with-oracles"><a class="header" href="#offloading-computations-with-oracles">Offloading Computations with Oracles</a></h1>
<p>In this chapter, we’ll build a small Cairo executable that asks an external
helper (an “oracle”) to do some work and then constrains the returned values
inside Cairo so they become part of the proof. Along the way, you’ll learn what
oracles are, why they fit naturally in Cairo’s non‑deterministic machine, and
how to use them safely.</p>
<p>Oracles are an experimental Scarb feature available for Cairo executables
executed with <code>--experimental-oracles</code>. They are not available inside Starknet
contracts.</p>
<blockquote>
<p>Note: This "oracle" system is not related to Smart Contract Oracles; but the
concept is similar: using an external process to query data in a constrained
system.</p>
</blockquote>
<h2 id="why-use-oracles"><a class="header" href="#why-use-oracles">Why use Oracles?</a></h2>
<p>When the Cairo VM runs, oracles allow the prover to assign arbitrary values to
memory cells. This non‑determinism lets us "inject" values that come from the
outside world. For example, to prove we know \(\sqrt{25}\), we don't need to
implement a square‑root algorithm in Cairo; we can obtain \(5\) from an oracle
and trivially assert \(5 \cdot 5 = 25\).</p>
<p>If you’re curious about the underlying memory model, see
<a href="./ch202-01-non-deterministic-read-only-memory.html">Non‑Deterministic Read‑Only Memory</a>.</p>
<h2 id="what-well-build"><a class="header" href="#what-well-build">What We’ll Build</a></h2>
<p>We’ll create two pieces that work together:</p>
<ul>
<li>A Cairo executable that calls two oracle endpoints: one that returns the
integer square root of a number and one that decomposes a number into
little‑endian bytes. After each call, we’ll assert properties that must hold
in order for the soundness properties of the program to be preserved.</li>
<li>A Rust process that implements those endpoints and communicates with Cairo
over standard input/output via JSON‑RPC (the <code>stdio:</code> protocol supported by
Scarb’s executor).</li>
</ul>
<p>We prepared a complete example under <code>listing_oracles/</code>. We’ll walk through the
important files and then run it.</p>
<h2 id="the-cairo-package"><a class="header" href="#the-cairo-package">The Cairo Package</a></h2>
<p>First, let’s look at the manifest. We declare an executable package, depend on
<code>cairo_execute</code> so we can run with Scarb, and add the <code>oracle</code> crate to access
<code>oracle::invoke</code>.</p>
<p><span class="caption">Filename: listing_oracles/Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "example"
version = "0.1.0"
edition = "2024_07"
publish = false

[dependencies]
cairo_execute = "2.13.1"
oracle = "0.1.0-dev.4"

[executable]

[cairo]
enable-gas = false

[dev-dependencies]
cairo_test = "2"
</code></pre>
<p>Now let’s see how we call the oracle from Cairo. We define two helper functions
that forward to the Rust oracle using a connection string of the form
<code>stdio:...</code>, then we assert relationships that make the returned values part of
the proof.</p>
<p><span class="caption">Filename: listing_oracles/src/lib.cairo</span></p>
<pre><code class="language-cairo">use core::num::traits::Pow;

// Call into the Rust oracle to get the square root of an integer.
fn sqrt_call(x: u64) -&gt; oracle::Result&lt;u64&gt; {
    oracle::invoke("stdio:cargo -q run --manifest-path ./src/my_oracle/Cargo.toml", 'sqrt', (x,))
}

// Call into the Rust oracle to convert an integer to little-endian bytes.
fn to_le_bytes(val: u64) -&gt; oracle::Result&lt;Array&lt;u8&gt;&gt; {
    oracle::invoke(
        "stdio:cargo -q run --manifest-path ./src/my_oracle/Cargo.toml", 'to_le_bytes', (val,),
    )
}

fn oracle_calls(x: u64) -&gt; Result&lt;(), oracle::Error&gt; {
    let sqrt = sqrt_call(x)?;
    // CONSTRAINT: sqrt * sqrt == x
    assert!(sqrt * sqrt == x, "Expected sqrt({x}) * sqrt({x}) == x, got {sqrt} * {sqrt} == {x}");
    println!("Computed sqrt({x}) = {sqrt}");

    let bytes = to_le_bytes(x)?;
    // CONSTRAINT: sum(bytes_i * 256^i) == x
    let mut recomposed_val = 0;
    for (i, byte) in bytes.span().into_iter().enumerate() {
        recomposed_val += (*byte).into() * 256_u64.pow(i.into());
    }
    assert!(
        recomposed_val == x,
        "Expected recomposed value {recomposed_val} == {x}, got {recomposed_val}",
    );
    println!("le_bytes decomposition of {x}) = {:?}", bytes.span());

    Ok(())
}

#[executable]
fn main(x: u64) -&gt; bool {
    match oracle_calls(x) {
        Ok(()) =&gt; true,
        Err(e) =&gt; panic!("Oracle call failed: {e:?}"),
    }
}
</code></pre>
<p>There are two important ideas here:</p>
<ol>
<li>We call out to the oracle with
<code>oracle::invoke(connection, selector, inputs_tuple)</code>. The <code>connection</code> tells
Scarb how to spawn the process (here, a Cargo command over <code>stdio:</code>), the
<code>selector</code> picks the endpoint by name, and the tuple contains the inputs. The
return type is <code>oracle::Result&lt;T&gt;</code>, so we handle errors explicitly.</li>
<li>We immediately constrain whatever came back from the oracle. For the square
root, we assert <code>sqrt * sqrt == x</code>. For the byte decomposition, we recompute
the value from its bytes and assert it equals the original number. These
assertions are what turn injected values into sound witness data. It's very
important to properly constrain the returned values; otherwise, a malicious
prover could inject arbitrary values into memory, and forge arbitrary valid
ZK-Proofs.</li>
</ol>
<h2 id="the-rust-oracle"><a class="header" href="#the-rust-oracle">The Rust Oracle</a></h2>
<p>On the Rust side, we implement the endpoints and let a helper crate
(<code>cairo_oracle_server</code>) handle the plumbing. Inputs are decoded automatically;
outputs are encoded back to Cairo.</p>
<p><span class="caption">Filename: listing_oracles/src/my_oracle/Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "my_oracle"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
anyhow = "1"
cairo-oracle-server = "0.1"
starknet-core = "0.11"
</code></pre>
<p><span class="caption">Filename: listing_oracles/src/my_oracle/src/main.rs</span></p>
<pre><code class="language-rust  noplayground">use anyhow::ensure;
use cairo_oracle_server::Oracle;
use std::process::ExitCode;

fn main() -&gt; ExitCode {
    Oracle::new()
        .provide("sqrt", |value: u64| {
            let sqrt = (value as f64).sqrt() as u64;
            ensure!(
                sqrt * sqrt == value,
                "Cannot compute integer square root of {value}"
            );
            Ok(sqrt)
        })
        .provide("to_le_bytes", |value: u64| {
            let value_bytes = value.to_le_bytes();
            Ok(value_bytes.to_vec())
        })
        .run()
}</code></pre>
<p>The <code>sqrt</code> endpoint returns the integer square root and rejects values that
don’t have an exact square root. The <code>to_le_bytes</code> endpoint returns the
little‑endian byte decomposition of a <code>u64</code>.</p>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the Example</a></h2>
<p>From the example directory, execute the program with oracles enabled:</p>
<pre><code class="language-bash">scarb execute --experimental-oracles --print-program-output --arguments 25000000
</code></pre>
<p>You’ll see the program returning <code>1</code>, indicating success. The Cairo code asked
the oracle for <code>sqrt(25000000)</code>, verified that <code>5000 * 5000 == 25000000</code>, then
decomposed <code>25000000</code> into bytes and verified that recomposing them equals the
original input.</p>
<p>Try a value that isn’t a perfect square, such as <code>27</code>:</p>
<pre><code class="language-bash">scarb execute --experimental-oracles --print-program-output --arguments 27
</code></pre>
<p>The <code>sqrt</code> endpoint will return an error, because <code>27</code> has no integer square
root, which propagates back to Cairo. Our program panics.</p>
<h2 id="a-quick-look-at-the-api"><a class="header" href="#a-quick-look-at-the-api">A Quick Look at the API</a></h2>
<p>All oracle interactions go through a single function on the Cairo side:</p>
<pre><code class="language-text">oracle::invoke(connection: felt252*, selector: felt252*, inputs: (..)) -&gt; oracle::Result&lt;T&gt;
</code></pre>
<p>The connection string selects the transport and the process to run (here,
<code>stdio:</code> plus a Cargo command). The selector is the endpoint name you provided
in Rust (for example, <code>'sqrt'</code>). The inputs are a Cairo tuple matching the Rust
handler’s parameters. The return type is <code>oracle::Result&lt;T&gt;</code>, so you can handle
errors with <code>match</code>, <code>unwrap_or</code>, or custom logic.</p>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>You now have a working example showing how to offload work to an external
process and make the results part of a Cairo proof. Use this pattern when you
want fast, flexible helpers during client‑side proving, and remember: oracles
are experimental, runner‑only, and everything that comes from them must be
validated by your Cairo code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your
Cairo journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a---keywords"><a class="header" href="#appendix-a---keywords">Appendix A - Keywords</a></h1>
<p>The following list contains keywords that are reserved for current or future use
by the Cairo language.</p>
<p>There are three keyword categories:</p>
<ul>
<li>strict</li>
<li>loose</li>
<li>reserved</li>
</ul>
<p>There is a fourth category, which are functions from the core library. While
their names are not reserved, they are not recommended to be used as names of
any items to follow good practices.</p>
<hr />
<h2 id="strict-keywords"><a class="header" href="#strict-keywords">Strict keywords</a></h2>
<p>These keywords can only be used in their correct contexts. They cannot be used
as names of any items.</p>
<ul>
<li><code>as</code> - Rename import</li>
<li><code>break</code> - Exit a loop immediately</li>
<li><code>const</code> - Define constant items</li>
<li><code>continue</code> - Continue to the next loop iteration</li>
<li><code>else</code> - Fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - Define an enumeration</li>
<li><code>extern</code> - Function defined at the compiler level that can be compiled to CASM</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - Define a function</li>
<li><code>if</code> - Branch based on the result of a conditional expression</li>
<li><code>impl</code> - Implement inherent or trait functionality</li>
<li><code>implicits</code> - Special kind of function parameters that are required to perform
certain actions</li>
<li><code>let</code> - Bind a variable</li>
<li><code>loop</code> - Loop unconditionally</li>
<li><code>match</code> - Match a value to patterns</li>
<li><code>mod</code> - Define a module</li>
<li><code>mut</code> - Denote variable mutability</li>
<li><code>nopanic</code> - Functions marked with this notation mean that the function will
never panic.</li>
<li><code>of</code> - Implement a trait</li>
<li><code>pub</code> - Denote public visibility in items, such as struct and struct fields,
enums, consts, traits and impl blocks, or modules</li>
<li><code>ref</code> - Parameter passed implicitly returned at the end of a function</li>
<li><code>return</code> - Return from function</li>
<li><code>struct</code> - Define a structure</li>
<li><code>trait</code> - Define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - Define a type alias</li>
<li><code>use</code> - Bring symbols into scope</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<hr />
<h2 id="loose-keywords"><a class="header" href="#loose-keywords">Loose Keywords</a></h2>
<p>These keywords are associated with a specific behaviour, but can also be used to
define items.</p>
<ul>
<li><code>self</code> - Method subject</li>
<li><code>super</code> - Parent module of the current module</li>
</ul>
<hr />
<h2 id="reserved-keywords"><a class="header" href="#reserved-keywords">Reserved Keywords</a></h2>
<p>These keywords aren't used yet, but they are reserved for future use. For now,
it is possible to use them to define items, although it is highly recommended
not to do so. The reasoning behind this recommendation is to make current
programs forward compatible with future versions of Cairo by forbidding them to
use these keywords.</p>
<ul>
<li><code>Self</code></li>
<li><code>do</code></li>
<li><code>dyn</code></li>
<li><code>for</code></li>
<li><code>hint</code></li>
<li><code>in</code></li>
<li><code>macro</code></li>
<li><code>move</code></li>
<li><code>static_assert</code></li>
<li><code>static</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsafe</code></li>
<li><code>where</code></li>
<li><code>with</code></li>
<li><code>yield</code></li>
</ul>
<hr />
<h2 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h2>
<p>The Cairo programming language provides several specific functions that serve a
special purpose. We will not cover all of them in this book, but using the names
of these functions as names of other items is not recommended.</p>
<ul>
<li><code>assert</code> - This function checks a boolean expression, and if it evaluates to
false, it triggers the panic function.</li>
<li><code>panic</code> - This function acknowledges the occurrence of an error and terminates
the program.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b---operators-and-symbols"><a class="header" href="#appendix-b---operators-and-symbols">Appendix B - Operators and Symbols</a></h1>
<p>This appendix contains a glossary of Cairo's syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
macros, attributes, comments, tuples, and brackets.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Table B-1 contains the operators in Cairo, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>~</code></td><td><code>~expr</code></td><td>Bitwise NOT</td><td><code>BitNot</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Non-equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemEq</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Short-circuiting logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulEq</code></td></tr>
<tr><td><code>@</code></td><td><code>@var</code></td><td>Snapshot</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*var</code></td><td>Desnap</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddEq</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>-expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubEq</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Member access</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivEq</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code></td><td>Assignment</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Short-circuiting logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td>expr?</td><td>Error propagation</td><td></td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-1: Operators</span></p>
<h2 id="non-operator-symbols"><a class="header" href="#non-operator-symbols">Non Operator Symbols</a></h2>
<p>The following list contains all symbols that are not used as operators; that is,
they do not have the same behavior as a function or method call.</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>..._u8</code>, <code>..._usize</code>, <code>..._bool</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>"..."</code></td><td>String literal</td></tr>
<tr><td><code>'...'</code></td><td>Short string, 31 ASCII characters maximum</td></tr>
<tr><td><code>_</code></td><td>“Ignored” pattern binding</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<p>Table B-3 shows symbols that are used within the context of a module hierarchy
path to access an item.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<p>Table B-4 shows symbols that appear in the context of using generic type
parameters.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Array&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to a generic type, function, or method in an expression; often referred to as turbofish</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-4: Generics</span></p>
<p>Table B-5 shows symbols that appear in the context of specifying attributes on
an item.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[derive(...)]</code></td><td>Automatically implements a trait for a type</td></tr>
<tr><td><code>#[inline]</code></td><td>Hint to the compiler to allow inlining of annotated function</td></tr>
<tr><td><code>#[inline(always)]</code></td><td>Hint to the compiler to systematically inline annotated function</td></tr>
<tr><td><code>#[inline(never)]</code></td><td>Hint to the compiler to never inline annotated function</td></tr>
<tr><td><code>#[must_use]</code></td><td>Hint to the compiler that the return value of a function or a specific returned type must be used</td></tr>
<tr><td><code>#[generate_trait]</code></td><td>Automatically generates a trait for an impl</td></tr>
<tr><td><code>#[available_gas(...)]</code></td><td>Set the maximum amount of gas available to execute a function</td></tr>
<tr><td><code>#[panic_with('...', wrapper_name)]</code></td><td>Creates a wrapper for the annotated function which will panic if the function returns <code>None</code> or <code>Err</code>, with the given data as the panic error</td></tr>
<tr><td><code>#[test]</code></td><td>Describe a function as a test function</td></tr>
<tr><td><code>#[cfg(...)]</code></td><td>Configuration attribute, especially used to configure a <code>tests</code> module with <code>#[cfg(test)]</code></td></tr>
<tr><td><code>#[should_panic]</code></td><td>Specifies that a test function should necessarily panic</td></tr>
<tr><td><code>#[starknet::contract]</code></td><td>Defines a Starknet smart contract</td></tr>
<tr><td><code>#[starknet::interface]</code></td><td>Defines a Starknet interface</td></tr>
<tr><td><code>#[starknet::component]</code></td><td>Defines a Starknet component</td></tr>
<tr><td><code>#[starknet::embeddable]</code></td><td>Defines an isolated embeddable implementation that can be injected in any smart contract</td></tr>
<tr><td><code>#[embeddable_as(...)]</code></td><td>Defines an embeddable implementation inside a component</td></tr>
<tr><td><code>#[storage]</code></td><td>Defines the storage of a smart contract</td></tr>
<tr><td><code>#[event]</code></td><td>Defines an event in a smart contract</td></tr>
<tr><td><code>#[constructor]</code></td><td>Defines the constructor in a smart contract</td></tr>
<tr><td><code>#[abi(embed_v0)]</code></td><td>Defines an implementation of a trait, exposing the functions of the impl as entrypoints of a contract</td></tr>
<tr><td><code>#[abi(per_item)]</code></td><td>Allows individual definition of the entrypoint type of functions inside an impl</td></tr>
<tr><td><code>#[external(v0)]</code></td><td>Defines an external function when <code>#[abi(per_item)]</code> is used</td></tr>
<tr><td><code>#[flat]</code></td><td>Defines a enum variant of the <code>Event</code> enum that is not nested, ignoring the variant name in the serialization process, very useful for composability when using Starknet components</td></tr>
<tr><td><code>#[key]</code></td><td>Defines an indexed <code>Event</code> enum field, allowing for more efficient queries and filtering of events</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-5: Attributes</span></p>
<p>Table B-6 shows symbols that appear in the context of calling or defining
macros.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>print!</code></td><td>Inline printing</td></tr>
<tr><td><code>println!</code></td><td>Print on a new line</td></tr>
<tr><td><code>array!</code></td><td>Instantiate and fill arrays</td></tr>
<tr><td><code>panic!</code></td><td>Calls <code>panic</code> function and allows to provide a message error longer than 31 characters</td></tr>
<tr><td><code>assert!</code></td><td>Evaluates a Boolean and panics if <code>false</code></td></tr>
<tr><td><code>assert_eq!</code></td><td>Evaluates an equality, and panics if not equal</td></tr>
<tr><td><code>assert_ne!</code></td><td>Evaluates an equality, and panics if equal</td></tr>
<tr><td><code>assert_lt!</code></td><td>Evaluates a comparison, and panics if greater or equal</td></tr>
<tr><td><code>assert_le!</code></td><td>Evaluates a comparison, and panics if greater</td></tr>
<tr><td><code>assert_gt!</code></td><td>Evaluates a comparison, and panics if lower or equal</td></tr>
<tr><td><code>assert_ge!</code></td><td>Evaluates a comparison, and panics if lower</td></tr>
<tr><td><code>format!</code></td><td>Format a string and returns a <code>ByteArray</code> with the contents</td></tr>
<tr><td><code>write!</code></td><td>Write formatted strings in a formatter</td></tr>
<tr><td><code>writeln!</code></td><td>Write formatted strings in a formatter on a new line</td></tr>
<tr><td><code>get_dep_component!</code></td><td>Returns the requested component state from a snapshot of the state inside a component</td></tr>
<tr><td><code>get_dep_component_mut!</code></td><td>Returns the requested component state from a reference of the state inside a component</td></tr>
<tr><td><code>component!</code></td><td>Macro used in Starknet contracts to embed a component inside a contract</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-6: Macros</span></p>
<p>Table B-7 shows symbols that create comments.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-7: Comments</span></p>
<p>Table B-8 shows symbols that appear in the context of using tuples.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-8: Tuples</span></p>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
</div>
<p><span class="caption">Table B-9: Curly Braces</span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c---derivable-traits"><a class="header" href="#appendix-c---derivable-traits">Appendix C - Derivable Traits</a></h1>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which you
can apply to a struct or enum definition. The <code>derive</code> attribute generates code
to implement a default trait on the type you’ve annotated with the <code>derive</code>
syntax.</p>
<p>In this appendix, we provide a comprehensive reference detailing all the traits
in the standard library compatible with the <code>derive</code> attribute.</p>
<p>These traits listed here are the only ones defined by the core library that can
be implemented on your types using <code>derive</code>. Other traits defined in the
standard library don’t have sensible default behavior, so it’s up to you to
implement them in a way that makes sense for what you’re trying to accomplish.</p>
<h2 id="drop-and-destruct"><a class="header" href="#drop-and-destruct">Drop and Destruct</a></h2>
<p>When moving out of scope, variables need to be moved first. This is where the
<code>Drop</code> trait intervenes. You can find more details about its usage
<a href="ch04-01-what-is-ownership.html#no-op-destruction-the-drop-trait">here</a>.</p>
<p>Moreover, Dictionaries need to be squashed before going out of scope. Calling
the <code>squash</code> method on each of them manually can quickly become redundant.
<code>Destruct</code> trait allows Dictionaries to be automatically squashed when they get
out of scope. You can also find more information about <code>Destruct</code>
<a href="ch04-01-what-is-ownership.html#destruction-with-a-side-effect-the-destruct-trait">here</a>.</p>
<h2 id="clone-and-copy-for-duplicating-values"><a class="header" href="#clone-and-copy-for-duplicating-values"><code>Clone</code> and <code>Copy</code> for Duplicating Values</a></h2>
<p>The <code>Clone</code> trait provides the functionality to explicitly create a deep copy of
a value.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which, in turn, calls clone on
each of the type's components. This means all the fields or values in the type
must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>Here is a simple example:</p>
<pre><code class="language-cairo">#[derive(Clone, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct.clone();
    assert!(second_struct.item == 2, "Not equal");
}
</code></pre>
<p>The <code>Copy</code> trait allows for the duplication of values. You can derive <code>Copy</code> on
any type whose parts all implement <code>Copy</code>.</p>
<p>Example:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct;
    // Copy Trait prevents first_struct from moving into second_struct
    assert!(second_struct.item == 2, "Not equal");
    assert!(first_struct.item == 2, "Not Equal");
}
</code></pre>
<h2 id="debug-for-printing-and-debugging"><a class="header" href="#debug-for-printing-and-debugging"><code>Debug</code> for Printing and Debugging</a></h2>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you indicate
by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>It allows you to print instances of a type for debugging purposes, so you and
other programmers using this type can inspect an instance at a particular point
in a program’s execution.</p>
<p>For example, if you want to print the value of a variable of type <code>Point</code>, you
can do it as follows:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop, Debug)]
struct Point {
    x: u8,
    y: u8,
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{:?}", p);
}
</code></pre>
<pre><code class="language-shell">scarb execute
Point { x: 1, y: 3 }
</code></pre>
<p>The <code>Debug</code> trait is required, for example, when using the <code>assert_xx!</code> macros
in tests. These macros print the values of instances given as arguments if the
equality or comparison assertion fails so programmers can see why the two
instances weren’t equal.</p>
<h2 id="default-for-default-values"><a class="header" href="#default-for-default-values"><code>Default</code> for Default Values</a></h2>
<p>The <code>Default</code> trait allows creation of a default value of a type. The most
common default value is zero. All primitive types in the standard library
implement <code>Default</code>.</p>
<p>If you want to derive <code>Default</code> on a composite type, each of its elements must
already implement <code>Default</code>. If you have an <a href="ch06-01-enums.html"><code>enum</code></a> type, you
must declare its default value by using the <code>#[default]</code> attribute on one of its
variants.</p>
<p>An example:</p>
<pre><code class="language-cairo">#[derive(Default, Drop)]
struct A {
    item1: felt252,
    item2: u64,
}

#[derive(Default, Drop, PartialEq)]
enum CaseWithDefault {
    A: felt252,
    B: u128,
    #[default]
    C: u64,
}

#[executable]
fn main() {
    let defaulted: A = Default::default();
    assert!(defaulted.item1 == 0_felt252, "item1 mismatch");
    assert!(defaulted.item2 == 0_u64, "item2 mismatch");

    let default_case: CaseWithDefault = Default::default();
    assert!(default_case == CaseWithDefault::C(0_u64), "case mismatch");
}
</code></pre>
<h2 id="partialeq-for-equality-comparisons"><a class="header" href="#partialeq-for-equality-comparisons"><code>PartialEq</code> for Equality Comparisons</a></h2>
<p>The <code>PartialEq</code> trait allows for comparison between instances of a type for
equality, thereby enabling the <code>==</code> and <code>!=</code> operators.</p>
<p>When <code>PartialEq</code> is derived on structs, two instances are equal only if all
their fields are equal; they are not equal if any field is different. When
derived for enums, each variant is equal to itself and not equal to the other
variants.</p>
<p>You can write your own implementation of the <code>PartialEq</code> trait for your type, if
you can't derive it or if you want to implement your custom rules. In the
following example, we write an implementation for <code>PartialEq</code> in which we
consider that two rectangles are equal if they have the same area:</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

impl PartialEqImpl of PartialEq&lt;Rectangle&gt; {
    fn eq(lhs: @Rectangle, rhs: @Rectangle) -&gt; bool {
        (*lhs.width) * (*lhs.height) == (*rhs.width) * (*rhs.height)
    }

    fn ne(lhs: @Rectangle, rhs: @Rectangle) -&gt; bool {
        (*lhs.width) * (*lhs.height) != (*rhs.width) * (*rhs.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 50, height: 30 };

    println!("Are rect1 and rect2 equal? {}", rect1 == rect2);
}
</code></pre>
<p>The <code>PartialEq</code> trait is required when using the <code>assert_eq!</code> macro in tests,
which needs to be able to compare two instances of a type for equality.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo">#[derive(PartialEq, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = A { item: 2 };
    assert!(first_struct == second_struct, "Structs are different");
}
</code></pre>
<h2 id="serializing-with-serde"><a class="header" href="#serializing-with-serde">Serializing with <code>Serde</code></a></h2>
<p><code>Serde</code> provides trait implementations for <code>serialize</code> and <code>deserialize</code>
functions for data structures defined in your crate. It allows you to transform
your structure into an array (or the opposite).</p>
<blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a></strong> is a process
of transforming data structures into a format that can be easily stored or
transmitted. Let's say you are running a program and would like to persist its
state to be able to resume it later. To do this, you could take each of the
objects your program is using and save their information, for example in a
file. This is a simplified version of serialization. Now if you want to resume
your program with this saved state, you would perform <strong>deserialization</strong>,
which means loading the state of the objects from the saved source.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-cairo">#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    panic(output_array);
}

</code></pre>
<p>If you run the <code>main</code> function, the output will be:</p>
<pre><code class="language-shell">Run panicked with [2, 99 ('c'), ].
</code></pre>
<p>We can see here that our struct <code>A</code> has been serialized into the output array.
Note that the <code>serialize</code> function takes as argument a snapshot of the type you
want to convert into an array. This is why deriving <code>Drop</code> for <code>A</code> is required
here, as the <code>main</code> function keeps ownership of the <code>first_struct</code> struct.</p>
<p>Also, we can use the <code>deserialize</code> function to convert the serialized array back
into our <code>A</code> struct.</p>
<p>Here is an example:</p>
<pre><code class="language-cairo">#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    let mut span_array = output_array.span();
    let deserialized_struct: A = Serde::&lt;A&gt;::deserialize(ref span_array).unwrap();
}
</code></pre>
<p>Here we are converting a serialized array span back to the struct <code>A</code>.
<code>deserialize</code> returns an <code>Option</code> so we need to unwrap it. When using
<code>deserialize</code> we also need to specify the type we want to deserialize into.</p>
<h2 id="hashing-with-hash"><a class="header" href="#hashing-with-hash">Hashing with <code>Hash</code></a></h2>
<p>It is possible to derive the <code>Hash</code> trait on structs and enums. This allows them
to be hashed easily using any available hash function. For a struct or an enum
to derive the <code>Hash</code> attribute, all fields or variants need to be hashable
themselves.</p>
<p>You can refer to the <a href="ch12-04-hash.html">Hashes section</a> to get more information
about how to hash complex data types.</p>
<h2 id="starknet-storage-with-starknetstore"><a class="header" href="#starknet-storage-with-starknetstore">Starknet Storage with <code>starknet::Store</code></a></h2>
<p>The <code>starknet::Store</code> trait is relevant only when building on
<a href="ch100-00-introduction-to-smart-contracts.html">Starknet</a>. It allows for a type to
be used in smart contract storage by automatically implementing the necessary
read and write functions.</p>
<p>You can find detailed information about the inner workings of Starknet storage
in the <a href="ch101-01-00-contract-storage.html">Contract storage section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d---the-cairo-prelude"><a class="header" href="#appendix-d---the-cairo-prelude">Appendix D - The Cairo Prelude</a></h1>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>The Cairo prelude is a collection of commonly used modules, functions, data
types, and traits that are automatically brought into scope of every module in a
Cairo crate without needing explicit import statements. Cairo's prelude provides
the basic building blocks developers need to start Cairo programs and writing
smart contracts.</p>
<p>The core library prelude is defined in the
<em><a href="https://github.com/starkware-libs/cairo/blob/main/corelib/src/lib.cairo">lib.cairo</a></em>
file of the corelib crate and contains Cairo's primitive data types, traits,
operators, and utility functions. This includes:</p>
<ul>
<li>Data types: integers, bools, arrays, dicts, etc.</li>
<li>Traits: behaviors for arithmetic, comparison, and serialization operations</li>
<li>Operators: arithmetic, logical, bitwise</li>
<li>Utility functions - helpers for arrays, maps, boxing, etc.</li>
</ul>
<p>The core library prelude delivers the fundamental programming constructs and
operations needed for basic Cairo programs, without requiring the explicit
import of elements. Since the core library prelude is automatically imported,
its contents are available for use in any Cairo crate without explicit imports.
This prevents repetition and provides a better devX. This is what allows you to
use <code>ArrayTrait::append()</code> or the <code>Default</code> trait without bringing them
explicitly into scope.</p>
<p>You can choose which prelude to use. For example, adding <code>edition = "2024_07"</code>
in the <em>Scarb.toml</em> configuration file will load the prelude from July 2024.
Note that when you create a new project using <code>scarb new</code> command, the
<em>Scarb.toml</em> file will automatically include <code>edition = "2024_07"</code>. Different
prelude versions will expose different functions and traits, so it is important
to specify the correct edition in the <em>Scarb.toml</em> file. Generally, you want to
start a new project using the latest edition, and migrate to newer editions as
they are released.</p>
<h2 id="cairo-editions"><a class="header" href="#cairo-editions">Cairo editions</a></h2>
<p>Here is the list of available Cairo editions (i.e prelude versions) with their
details:</p>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Details</th></tr></thead><tbody>
<tr><td><code>2024-07</code></td><td><a href="https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#the-2024_07-edition-3">details for 2024-07</a></td></tr>
<tr><td><code>2023-11</code></td><td><a href="https://community.starknet.io/t/cairo-v2-5-0-is-out/112807#the-pub-keyword-9">details for 2023-11</a></td></tr>
<tr><td><code>2023-10</code> / <code>2023-1</code></td><td><a href="https://community.starknet.io/t/cairo-v2-4-0-is-out/109275#editions-and-the-introduction-of-preludes-10">details for 2023-10</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-e---common-error-messages"><a class="header" href="#appendix-e---common-error-messages">Appendix E - Common Error Messages</a></h1>
<p>You might encounter error messages when writing Cairo code. Some of them occur
very frequently, which is why we will be listing the most common error messages
in this appendix to help you resolve common issues.</p>
<ul>
<li>
<p><code>Variable not dropped.</code>: this error message means that you are trying to make
a variable with a type that do not implement the <code>Drop</code> trait go out of scope,
without destroying it. Make sure that variables that need to be dropped at the
end of the execution of a function implement the <code>Drop</code> trait or the
<code>Destruct</code> trait. See
<a href="ch04-01-what-is-ownership.html#destroying-values---example-with-feltdict">Ownership</a>
section.</p>
</li>
<li>
<p><code>Variable was previously moved.</code>: this error message means that you are trying
to use a variable whose ownership has already been transferred to another
function. When a variable doesn't implement the <code>Copy</code> trait, it is passed by
value to functions, and ownership of the variable is transferred to the
function. Such a variable cannot be used anymore in the current context after
its ownership has been transferred. It is often useful to use the <code>clone</code>
method in this situation.</p>
</li>
<li>
<p><code>error: Trait has no implementation in context: core::fmt::Display::&lt;package_name::struct_name&gt;</code>:
this error message is encountered if you try to print an instance of a custom
data type with <code>{}</code> placeholders in a <code>print!</code> or <code>println!</code> macro. To
mitigate this issue, you need to either manually implement the <code>Display</code> trait
for your type, or use the <code>Debug</code> trait by applying <code>derive(Debug)</code> to your
type, allowing to print your instance by adding <code>:?</code> in <code>{}</code> placeholders.</p>
</li>
<li>
<p><code>Got an exception while executing a hint: Hint Error: Failed to deserialize param #x.</code>:
this error means that the execution failed because an entrypoint was called
without the expected arguments. Make sure that the arguments you provide when
calling an entrypoint are correct. There is a classic issue with <code>u256</code>
variables, which are actually structs of 2 <code>u128</code>. Therefore, when calling a
function that takes a <code>u256</code> as argument, you need to pass 2 values.</p>
</li>
<li>
<p><code>Item path::item is not visible in this context.</code>: this error message lets us
know that the path to bring an item into scope is correct, but there is a
vibility issue. In cairo, all items are private to parent modules by default.
To resolve this issue, make sure that all the modules on the path to items and
items themselves are declared with <code>pub(crate)</code> or <code>pub</code> to have access to
them.</p>
</li>
<li>
<p><code>Identifier not found.</code>: this error message is a bit aspecific but might
indicate that:</p>
<ul>
<li>A variable is being used before it has been declared. Make sure to declare
variables with the <code>let</code> keyword.</li>
<li>The path to bring an item into scope is wrongly defined. Make sure to use
valid paths.</li>
</ul>
</li>
</ul>
<h2 id="starknet-components-related-error-messages"><a class="header" href="#starknet-components-related-error-messages">Starknet Components Related Error Messages</a></h2>
<p>You might encounter some errors when trying to implement components.
Unfortunately, some of them lack meaningful error messages to help debug. This
section aims to provide you with some pointers to help you debug your code.</p>
<ul>
<li>
<p><code>Trait not found. Not a trait.</code>: this error can occur when you're not
importing the component's impl block correctly in your contract. Make sure to
respect the following syntax:</p>
<pre><code class="language-cairo noplayground">#[abi(embed_v0)]
impl IMPL_NAME = PATH_TO_COMPONENT::EMBEDDED_NAME&lt;ContractState&gt;
</code></pre>
</li>
<li>
<p><code>Plugin diagnostic: name is not a substorage member in the contract's Storage. Consider adding to Storage: (...)</code>:
the compiler helps you a lot debugging this by giving you recommendation on
the action to take. Basically, you forgot to add the component's storage to
your contract's storage. Make sure to add the path to the component's storage
annotated with the <code>#[substorage(v0)]</code> attribute to your contract's storage.</p>
</li>
<li>
<p><code>Plugin diagnostic: name is not a nested event in the contract's Event enum. Consider adding to the Event enum:</code>
similar to the previous error, the compiler tells you that you forgot to add
the component's events to your contract's events. Make sure to add the path to
the component's events to your contract's events.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-f---useful-development-tools"><a class="header" href="#appendix-f---useful-development-tools">Appendix F - Useful Development Tools</a></h1>
<p>In this appendix, we talk about some useful development tools that the Cairo
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.</p>
<h2 id="automatic-formatting-with-scarb-fmt"><a class="header" href="#automatic-formatting-with-scarb-fmt">Automatic Formatting with <code>scarb fmt</code></a></h2>
<p>Scarb projects can be formatted using the <code>scarb fmt</code> command. If you're using
the Cairo binaries directly, you can run <code>cairo-format</code> instead. Many
collaborative projects use <code>scarb fmt</code> to prevent arguments about which style to
use when writing Cairo: everyone formats their code using the tool.</p>
<p>To format any Cairo project, enter the following inside the project directory:</p>
<pre><code class="language-bash">scarb fmt
</code></pre>
<p>For things you do not want <code>scarb fmt</code> to mangle, use <code>#[cairofmt::skip]</code>:</p>
<pre><code class="language-cairo  noplayground">#[cairofmt::skip]
let table: Array&lt;ByteArray&gt; = array![
    "oxo",
    "xox",
    "oxo",
];
</code></pre>
<h2 id="ide-integration-using-cairo-language-server"><a class="header" href="#ide-integration-using-cairo-language-server">IDE Integration Using <code>cairo-language-server</code></a></h2>
<p>To help IDE integration, the Cairo community recommends using the
<a href="https://github.com/software-mansion/cairols"><code>cairo-language-server</code></a><!-- ignore -->. This tool is a
set of compiler-centric utilities that speaks the <a href="http://langserver.org/">Language Server
Protocol</a><!--
ignore -->, which is a specification for IDEs and programming languages to
communicate with each other. Different clients can use <code>cairo-language-server</code>,
such as <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">the Cairo extension for Visual Studio Code</a>.</p>
<p>Visit the <code>vscode-cairo</code> <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">page</a><!-- ignore --> to install it on
VSCode. You will get abilities such as autocompletion, jump to definition, and
inline errors.</p>
<blockquote>
<p>Note: If you have Scarb installed, it should work out of the box with the
Cairo VSCode extension, without a manual installation of the language server.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>meta:
"Explore the fundamentals of smart contracts in this comprehensive
introduction, tailored for developers using Cairo. Learn how smart contracts
work and their role in blockchain technology."</h2>
<h1 id="introduction-to-smart-contracts"><a class="header" href="#introduction-to-smart-contracts">Introduction to Smart Contracts</a></h1>
<p>This chapter will give you a high level introduction to what smart contracts
are, what they are used for, and why blockchain developers would use Cairo and
Starknet. If you are already familiar with blockchain programming, feel free to
skip this chapter. The last part might still be interesting though.</p>
<h2 id="smart-contracts---introduction"><a class="header" href="#smart-contracts---introduction">Smart Contracts - Introduction</a></h2>
<p>Smart contracts gained popularity and became more widespread with the birth of
Ethereum. Smart contracts are essentially programs deployed on a blockchain. The
term "smart contract" is somewhat misleading, as they are neither "smart" nor
"contracts" but rather code and instructions that are executed based on specific
inputs. They primarily consist of two components: storage and functions. Once
deployed, users can interact with smart contracts by initiating blockchain
transactions containing execution data (which function to call and with what
input). Smart contracts can modify and read the storage of the underlying
blockchain. A smart contract has its own address and is considered a blockchain
account, meaning it can hold tokens.</p>
<p>The programming language used to write smart contracts varies depending on the
blockchain. For example, on Ethereum and the <a href="https://ethereum.org/en/developers/docs/evm/">EVM-compatible ecosystem</a>,
the most commonly used language is Solidity, while on Starknet, it is Cairo. The
way the code is compiled also differs based on the blockchain. On Ethereum,
Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra
and then into Cairo Assembly (CASM).</p>
<p>Smart contracts possess several unique characteristics. They are
<strong>permissionless</strong>, meaning anyone can deploy a smart contract on the network
(within the context of a decentralized blockchain, of course). Smart contracts
are also <strong>transparent</strong>; the data stored by the smart contract is accessible to
anyone. The code that composes the contract can also be transparent, enabling
<strong>composability</strong>. This allows developers to write smart contracts that use
other smart contracts. Smart contracts can only access and interact with data
from the blockchain they are deployed on. They require third-party software
(called <em>oracles</em>) to access external data (the price of a token for instance).</p>
<p>For developers to build smart contracts that can interact with each other, it is
required to know what the other contracts look like. Hence, Ethereum developers
started to build standards for smart contract development, the <code>ERCxx</code>. The two
most used and famous standards are the <code>ERC20</code>, used to build tokens like
<code>USDC</code>, <code>DAI</code> or <code>STARK</code>, and the <code>ERC721</code>, for NFTs (Non-Fungible Tokens) like
<code>CryptoPunks</code> or <code>Everai</code>.</p>
<h2 id="smart-contracts---use-cases"><a class="header" href="#smart-contracts---use-cases">Smart Contracts - Use Cases</a></h2>
<p>There are many possible use cases for smart contracts. The only limits are the
technical constraints of the blockchain and the creativity of developers.</p>
<h3 id="defi"><a class="header" href="#defi">DeFi</a></h3>
<p>For now, the principal use case for smart contracts is similar to that of
Ethereum or Bitcoin, which is essentially handling money. In the context of the
alternative payment system promised by Bitcoin, smart contracts on Ethereum
enable the creation of decentralized financial applications that no longer rely
on traditional financial intermediaries. This is what we call DeFi
(decentralized finance). DeFi consists of various projects such as
lending/borrowing applications, decentralized exchanges (DEX), on-chain
derivatives, stablecoins, decentralized hedge funds, insurance, and many more.</p>
<h3 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h3>
<p>Smart contracts can facilitate the tokenization of real-world assets, such as
real estate, art, or precious metals. Tokenization divides an asset into digital
tokens, which can be easily traded and managed on blockchain platforms. This can
increase liquidity, enable fractional ownership, and simplify the buying and
selling process.</p>
<h3 id="voting"><a class="header" href="#voting">Voting</a></h3>
<p>Smart contracts can be used to create secure and transparent voting systems.
Votes can be recorded on the blockchain, ensuring immutability and transparency.
The smart contract can then automatically tally the votes and declare the
results, minimizing the potential for fraud or manipulation.</p>
<h3 id="royalties"><a class="header" href="#royalties">Royalties</a></h3>
<p>Smart contracts can automate royalty payments for artists, musicians, and other
content creators. When a piece of content is consumed or sold, the smart
contract can automatically calculate and distribute the royalties to the
rightful owners, ensuring fair compensation and reducing the need for
intermediaries.</p>
<h3 id="decentralized-identities-dids"><a class="header" href="#decentralized-identities-dids">Decentralized Identities DIDs</a></h3>
<p>Smart contracts can be used to create and manage digital identities, allowing
individuals to control their personal information and share it with third
parties securely. The smart contract could verify the authenticity of a user's
identity and automatically grant or revoke access to specific services based on
the user's credentials.</p>
<br/>
<br/>
As Ethereum continues to mature, we can expect the use cases and applications of smart contracts to expand further, bringing about exciting new opportunities and reshaping traditional systems for the better.
<h2 id="the-rise-of-starknet-and-cairo"><a class="header" href="#the-rise-of-starknet-and-cairo">The Rise of Starknet and Cairo</a></h2>
<p>Ethereum, being the most widely used and resilient smart contract platform,
became a victim of its own success. With the rapid adoption of some previously
mentioned use cases, mainly DeFi, the cost of performing transactions became
extremely high, rendering the network almost unusable. Engineers and researchers
in the ecosystem began working on solutions to address this scalability issue.</p>
<p>A famous trilemma called The Blockchain Trilemma in the blockchain space states
that it is hard to achieve a high level of scalability, decentralization, and
security simultaneously; trade-offs must be made. Ethereum is at the
intersection of decentralization and security. Eventually, it was decided that
Ethereum's purpose would be to serve as a secure settlement layer, while complex
computations would be offloaded to other networks built on top of Ethereum.
These are called Layer 2s (L2s).</p>
<p>The two primary types of L2s are optimistic rollups and validity rollups. Both
approaches involve compressing and batching numerous transactions together,
computing the new state, and settling the result on Ethereum (L1). The
difference lies in the way the result is settled on L1. For optimistic rollups,
the new state is considered valid by default, but there is a 7-day window for
nodes to identify malicious transactions.</p>
<p>In contrast, validity rollups, such as Starknet, use cryptography to prove that
the new state has been correctly computed. This is the purpose of STARKs, this
cryptographic technology could permit validity rollups to scale significantly
more than optimistic rollups. You can learn more about STARKs from Starkware's
Medium <a href="https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a">article</a>, which serves as a good primer.</p>
<blockquote>
<p>Starknet's architecture is thoroughly described in the
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/">Starknet documentation</a>,
which is a great resource to learn more about the Starknet network.</p>
</blockquote>
<p>Remember Cairo? It is, in fact, a language developed specifically to work with
STARKs and make them general-purpose. With Cairo, we can write <strong>provable
code</strong>. In the context of Starknet, this allows proving the correctness of
computations from one state to another.</p>
<p>Unlike most (if not all) of Starknet's competitors that chose to use the EVM
(either as-is or adapted) as a base layer, Starknet employs its own VM. This
frees developers from the constraints of the EVM, opening up a broader range of
possibilities. Coupled with decreased transaction costs, the combination of
Starknet and Cairo creates an exciting playground for developers. Native account
abstraction enables more complex logic for accounts, that we call "Smart
Accounts", and transaction flows. Emerging use cases include <strong>transparent AI</strong>
and machine learning applications. Finally, <strong>blockchain games</strong> can be
developed entirely <strong>on-chain</strong>. Starknet has been specifically designed to
maximize the capabilities of STARK proofs for optimal scalability.</p>
<blockquote>
<p>Learn more about Account Abstraction in the
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Account_Abstraction/introduction/">Starknet documentation</a>.</p>
</blockquote>
<h2 id="cairo-programs-and-starknet-smart-contracts-what-is-the-difference"><a class="header" href="#cairo-programs-and-starknet-smart-contracts-what-is-the-difference">Cairo Programs and Starknet Smart Contracts: What Is the Difference?</a></h2>
<p>Starknet contracts are a special superset of Cairo programs, so the concepts
previously learned in this book are still applicable to write Starknet
contracts. As you may have already noticed, a Cairo program must always have a
<code>main</code> function that serves as the entry point for this program:</p>
<pre><code class="language-cairo">fn main() {}
</code></pre>
<p>Contracts deployed on the Starknet network are essentially programs that are run
by the sequencer, and as such, have access to Starknet's state. Contracts do not
have a <code>main</code> function but one or multiple functions that can serve as entry
points.</p>
<p>Starknet contracts are defined within <a href="./ch07-02-defining-modules-to-control-scope.html">modules</a>. For a module to
be handled as a contract by the compiler, it must be annotated with the
<code>#[starknet::contract]</code> attribute.</p>
<h2 id="anatomy-of-a-simple-contract"><a class="header" href="#anatomy-of-a-simple-contract">Anatomy of a Simple Contract</a></h2>
<p>This chapter will introduce you to the basics of Starknet contracts using a very
simple smart contract as example. You will learn how to write a contract that
allows anyone to store a single number on the Starknet blockchain.</p>
<p>Let's consider the following contract for the whole chapter. It might not be
easy to understand it all at once, but we will go through it step by step:</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait ISimpleStorage&lt;TContractState&gt; {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -&gt; u128;
}

#[starknet::contract]
mod SimpleStorage {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        stored_data: u128,
    }

    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState, x: u128) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
}
</code></pre>
<p>14-1: A simple storage contract</span></p>
<h3 id="what-is-this-contract"><a class="header" href="#what-is-this-contract">What Is this Contract?</a></h3>
<p>Contracts are defined by encapsulating state and logic within a module annotated
with the <code>#[starknet::contract]</code> attribute.</p>
<p>The state is defined within the <code>Storage</code> struct, and is always initialized
empty. Here, our struct contains a single field called <code>stored_data</code> of type
<code>u128</code> (unsigned integer of 128 bits), indicating that our contract can store
any number between 0 and \( {2^{128}} - 1 \).</p>
<p>The logic is defined by functions that interact with the state. Here, our
contract defines and publicly exposes the functions <code>set</code> and <code>get</code> that can be
used to modify or retrieve the value of the stored variable. You can think of it
as a single slot in a database that you can query and modify by calling
functions of the code that manages the database.</p>
<h3 id="the-interface-the-contracts-blueprint"><a class="header" href="#the-interface-the-contracts-blueprint">The Interface: the Contract's Blueprint</a></h3>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait ISimpleStorage&lt;TContractState&gt; {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -&gt; u128;
}
</code></pre>
<p>contract interface</span></p>
<p>Interfaces represent the blueprint of the contract. They define the functions
that the contract exposes to the outside world, without including the function
body. In Cairo, they're defined by annotating a trait with the
<code>#[starknet::interface]</code> attribute. All functions of the trait are considered
public functions of any contract that implements this trait, and are callable
from the outside world.</p>
<blockquote>
<p>The contract constructor is not part of the interface. Nor are internal
functions.</p>
</blockquote>
<p>All contract interfaces use a generic type for the <code>self</code> parameter,
representing the contract state. We chose to name this generic parameter
<code>TContractState</code> in our interface, but this is not enforced and any name can be
chosen.</p>
<p>In our interface, note the generic type <code>TContractState</code> of the <code>self</code> argument
which is passed by reference to the <code>set</code> function. Seeing the <code>self</code> argument
passed in a contract function tells us that this function can access the state
of the contract. The <code>ref</code> modifier implies that <code>self</code> may be modified, meaning
that the storage variables of the contract may be modified inside the <code>set</code>
function.</p>
<p>On the other hand, the <code>get</code> function takes a snapshot of <code>TContractState</code>,
which immediately tells us that it does not modify the state (and indeed, the
compiler will complain if we try to modify storage inside the <code>get</code> function).</p>
<p>By leveraging the <a href="./ch08-02-traits-in-cairo.html">traits &amp; impls</a> mechanism from
Cairo, we can make sure that the actual implementation of the contract matches
its interface. In fact, you will get a compilation error if your contract
doesn’t conform with the declared interface. For example, Listing
14-3 shows a wrong implementation of the <code>ISimpleStorage</code>
interface, containing a slightly different <code>set</code> function that doesn't have the
same signature.</p>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState) {}
        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
</code></pre>
<p>implementation of the interface of the contract. This does not compile, as the
signature of <code>set</code> doesn't match the trait's.</span></p>
<p>Trying to compile a contract using this implementation will result in the
following error:</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_99_02 v0.1.0 (listings/ch100-introduction-to-smart-contracts/listing_02_wrong_impl/Scarb.toml)
error: The number of parameters in the impl function `SimpleStorage::set` is incompatible with `ISimpleStorage::set`. Expected: 2, actual: 1.
 --&gt; listings/ch100-introduction-to-smart-contracts/listing_02_wrong_impl/src/lib.cairo:23:16
        fn set(ref self: ContractState) {}
               ^^^^^^^^^^^^^^^^^^^^^^^

error: Wrong number of arguments. Expected 2, found: 1
 --&gt; listings/ch100-introduction-to-smart-contracts/listing_02_wrong_impl/src/lib.cairo:23:9
        fn set(ref self: ContractState) {}
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `listing_99_02` due to 2 previous errors
error: `scarb` command exited with error

</code></pre>
<h3 id="public-functions-defined-in-an-implementation-block"><a class="header" href="#public-functions-defined-in-an-implementation-block">Public Functions Defined in an Implementation Block</a></h3>
<p>Before we explore things further down, let's define some terminology.</p>
<ul>
<li>
<p>In the context of Starknet, a <em>public function</em> is a function that is exposed
to the outside world. A public function can be called by anyone, either from
outside the contract or from within the contract itself. In the example above,
<code>set</code> and <code>get</code> are public functions.</p>
</li>
<li>
<p>What we call an <em>external</em> function is a public function that can be directly
invoked through a Starknet transaction and that can mutate the state of the
contract. <code>set</code> is an external function.</p>
</li>
<li>
<p>A <em>view</em> function is a public function that is typically read-only and cannot
mutate the state of the contract. However, this limitation is only enforced by
the compiler, and not by Starknet itself. We will discuss the implications of
this in a later section. <code>get</code> is a view function.</p>
</li>
</ul>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState, x: u128) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
</code></pre>
<p><code>SimpleStorage</code> implementation</span></p>
<p>Since the contract interface is defined as the <code>ISimpleStorage</code> trait, in order
to match the interface, the public functions of the contract must be defined in
an implementation of this trait — which allows us to make sure that the
implementation of the contract matches its interface.</p>
<p>However, simply defining the functions in the implementation block is not
enough. The implementation block must be annotated with the <code>#[abi(embed_v0)]</code>
attribute. This attribute exposes the functions defined in this implementation
to the outside world — forget to add it and your functions will not be callable
from the outside. All functions defined in a block marked as <code>#[abi(embed_v0)]</code>
are consequently <em>public functions</em>.</p>
<p>Because the <code>SimpleStorage</code> contract is defined as a module, we need to access
the interface defined in the parent module. We can either bring it to the
current scope with the <code>use</code> keyword, or refer to it directly using <code>super</code>.</p>
<p>When writing the implementation of an interface, the <code>self</code> parameter in the
trait methods <strong>must</strong> be of type <code>ContractState</code>. The <code>ContractState</code> type is
generated by the compiler, and gives access to the storage variables defined in
the <code>Storage</code> struct. Additionally, <code>ContractState</code> gives us the ability to emit
events. The name <code>ContractState</code> is not surprising, as it’s a representation of
the contract’s state, which is what we think of <code>self</code> in the contract interface
trait. When <code>self</code> is a snapshot of <code>ContractState</code>, only read access is
allowed, and emitting events is not possible.</p>
<h3 id="accessing-and-modifying-the-contracts-state"><a class="header" href="#accessing-and-modifying-the-contracts-state">Accessing and Modifying the Contract's State</a></h3>
<p>Two methods are commonly used to access or modify the state of a contract:</p>
<ul>
<li><code>read</code>, which returns the value of a storage variable. This method is called
on the variable itself and does not take any argument.</li>
</ul>
<pre><code class="language-cairo noplayground">            self.stored_data.read()
</code></pre>
<ul>
<li><code>write</code>, which allows to write a new value in a storage slot. This method is
also called on the variable itself and takes one argument, which is the value
to be written. Note that <code>write</code> may take more than one argument, depending on
the type of the storage variable. For example, writing on a mapping requires 2
arguments: the key and the value to be written.</li>
</ul>
<pre><code class="language-cairo noplayground">            self.stored_data.write(x);
</code></pre>
<blockquote>
<p>Reminder: if the contract state is passed as a snapshot with <code>@</code> instead of
passed by reference with <code>ref</code>, attempting to modify the contract state will
result in a compilation error.</p>
</blockquote>
<p>This contract does not do much apart from allowing anyone to store a single
number that is accessible by anyone in the world. Anyone could call <code>set</code> again
with a different value and overwrite the current number. Nevertheless, each
value stored in the storage of the contract will still be stored in the history
of the blockchain. Later in this book, you will see how you can impose access
restrictions so that only you can alter the number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-contract-classes-and-instances"><a class="header" href="#starknet-contract-classes-and-instances">Starknet contract classes and instances</a></h1>
<p>As in object-oriented programming, Starknet distinguishes between a contract and
its implementation by separating contracts into <a href="ch100-01-contracts-classes-and-instances.html#contract-classes">classes</a> and
<a href="ch100-01-contracts-classes-and-instances.html#contract-instances">instances</a> A contract class is the definition of a
contract, while a contract instance is a deployed contract that corresponds to a
class. Only contract instances act as true contracts, in that they have their
own storage and can be called by transactions or other contracts.</p>
<!-- > Note: A contract class does not necessarily require a deployed instance in Starknet. -->
<h2 id="contract-classes"><a class="header" href="#contract-classes">Contract classes</a></h2>
<h3 id="components-of-a-cairo-class-definition"><a class="header" href="#components-of-a-cairo-class-definition">Components of a Cairo class definition</a></h3>
<p>The components that define a class are:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Notes</th></tr></thead><tbody>
<tr><td>Contract class version</td><td>The version of the contract class object. Currently, the Starknet OS supports version 0.1.0.</td></tr>
<tr><td>Array of external functions entry points</td><td>An entry point is a pair <code>(_selector_, _function_idx_)</code>, where <code>_function_idx_</code> is the index of the function inside the Sierra program. A selector is an identifier through which the function is callable in transactions or in other classes. The selector is the <code>starknet_keccak</code> hash of the function name, encoded in ASCII.</td></tr>
<tr><td>Array of L1 handlers entry points</td><td>-</td></tr>
<tr><td>Array of constructors entry points</td><td>Currently, the compiler allows only one constructor.</td></tr>
<tr><td>ABI</td><td>A string representing the ABI of the class. The ABI hash (which affects the class hash) is given by <code>starknet_keccak(bytes(ABI, "UTF-8"))</code>. This string is supplied by the user declaring the class (and is signed on as part of the <code>DECLARE</code> transaction), and is not enforced to be the true ABI of the associated class. Without seeing the underlying source code (i.e. the Cairo code generating the class's Sierra), this ABI should be treated as the "intended" ABI by the declaring party, which may be incorrect (intentionally or otherwise). The "honest" string would be the json serialization of the contract's ABI as produced by the Cairo compiler.</td></tr>
<tr><td>Sierra program</td><td>An array of field elements representing the Sierra instructions.</td></tr>
</tbody></table>
</div>
<h3 id="class-hash"><a class="header" href="#class-hash">Class hash</a></h3>
<p>Each class is uniquely identified by its <em>class hash</em>, comparable to a class
name in traditional object-oriented programming languages. The hash of the class
is the chain hash of its components, computed as follows:</p>
<pre><code>class_hash = h(
    contract_class_version,
    external_entry_points,
    l1_handler_entry_points,
    constructor_entry_points,
    abi_hash,
    sierra_program_hash
)
</code></pre>
<p>Where:</p>
<ul>
<li><code>h</code> is the Poseidon hash function</li>
<li>The hash of an entry point array \( (selector,index)_{i=1}^n] \) is given
by \(
h(\text{selector}_1,\text{index}_1,...,\text{selector}_n,\text{index}_n)
\)</li>
<li><code>sierra_program_hash</code> is the Poseidon hash of the program's bytecode array</li>
</ul>
<blockquote>
<p>Note: The Starknet OS currently supports contract class version 0.1.0, which
is represented in the above hash computation as the ASCII encoding of the
string <code>CONTRACT_CLASS_V0.1.0</code> (hashing the version in this manner gives us
domain separation between the hashes of classes and other objects). For more
details, see the
<a href="https://github.com/starkware-libs/cairo-lang/blob/7712b21fc3b1cb02321a58d0c0579f5370147a8b/src/starkware/starknet/core/os/contracts.cairo#L47">Cairo implementation</a>.</p>
</blockquote>
<h3 id="working-with-classes"><a class="header" href="#working-with-classes">Working with classes</a></h3>
<ul>
<li>Adding new classes: To introduce new classes to Starknet's state, use the
<code>DECLARE</code> transaction.</li>
<li>Deploying instances: To deploy a new instance of a previously declared class,
use the <code>deploy</code> system call.</li>
<li>Using class functionality: To use the functionality of a declared class
without deploying an instance, use the <code>library_call</code> system call. Analogous
to Ethereum's <code>delegatecall</code>, it enables you to use code in an existing class
without deploying a contract instance.</li>
</ul>
<h2 id="contract-instances"><a class="header" href="#contract-instances">Contract instances</a></h2>
<h3 id="contract-nonce"><a class="header" href="#contract-nonce">Contract nonce</a></h3>
<p>A contract instance has a nonce, the value of which is the number of
transactions originating from this address plus 1. For example, when you deploy
an account with a <code>DEPLOY_ACCOUNT</code> transaction, the nonce of the account
contract in the transaction is <code>0</code>. After the <code>DEPLOY_ACCOUNT</code> transaction,
until the account contract sends its next transaction, the nonce is <code>1</code>.</p>
<h3 id="contract-address"><a class="header" href="#contract-address">Contract address</a></h3>
<p>The contract address is a unique identifier of the contract on Starknet. It is a
chain hash of the following information:</p>
<ul>
<li><code>prefix</code>: The ASCII encoding of the constant string
<code>STARKNET_CONTRACT_ADDRESS</code>.</li>
<li><code>deployer_address</code>, which is:
<ul>
<li><code>0</code> when the contract is deployed via a <code>DEPLOY_ACCOUNT</code> transaction</li>
<li>determined by the value of the <code>deploy_from_zero</code> parameter when the
contract is deployed via the <code>deploy</code> system call
<blockquote>
<p>Note: For information on the <code>deploy_from_zero</code> parameter, see the
<a href=""><code>deploy</code> system call</a>.</p>
</blockquote>
</li>
</ul>
</li>
<li><code>salt</code>: The salt passed by the contract calling the syscall, provided by the
transaction sender.</li>
<li><code>class_hash</code>: See <a href="ch100-01-contracts-classes-and-instances.html#class-hash">Class hash</a>.</li>
<li><code>constructor_calldata_hash</code>:: Array hash of the inputs to the constructor.</li>
</ul>
<p>The address is computed as follows:</p>
<pre><code>contract_address = pedersen(
    “STARKNET_CONTRACT_ADDRESS”,
    deployer_address,
    salt,
    class_hash,
    constructor_calldata_hash)
</code></pre>
<blockquote>
<p>Note: A random <code>salt</code> ensures unique addresses for smart contract deployments,
preventing conflicts when deploying identical contract classes. It also
thwarts replay attacks by influencing the transaction hash with a unique
sender address.</p>
</blockquote>
<p>For more information on the address computation, see
<a href="https://github.com/starkware-libs/cairo/blob/2c96b181a6debe9a564b51dbeaaf48fa75808d53/corelib/src/starknet/contract_address.cairo"><code>contract_address.cairo</code></a>
in the Cairo GitHub repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-starknet-smart-contracts"><a class="header" href="#building-starknet-smart-contracts">Building Starknet Smart Contracts</a></h1>
<p>In the previous section, we gave an introductory example of a smart contract
written in Cairo, describing the basic blocks to build smart contracts on
Starknet. In this section, we'll be taking a deeper look at all the components
of a smart contract, step by step.</p>
<p>When we discussed <a href="./ch100-00-introduction-to-smart-contracts.html#the-interface-the-contracts-blueprint"><em>interfaces</em></a>, we specified the
difference between the two types of <em>public functions</em>, i.e., <em>external
functions</em> and <em>view functions</em>, and we mentioned how to interact with the
<em>storage</em> of a contract.</p>
<p>At this point, you should have multiple questions that come to mind:</p>
<ul>
<li>How can I store more complex data types?</li>
<li>How do I define internal/private functions?</li>
<li>How can I emit events? How can I index them?</li>
<li>Is there a way to reduce the boilerplate?</li>
</ul>
<p>Luckily, we'll be answering all these questions in this chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-types"><a class="header" href="#starknet-types">Starknet Types</a></h1>
<p>When building smart contracts on Starknet, you'll work with specialized types
that represent blockchain-specific concepts. These types allow you to interact
with deployed contracts through their addresses, handle cross-chain
communication, and handle contract-specific data types. This chapter introduces
the Starknet-specific types provided by the Core library.</p>
<h2 id="contract-address-1"><a class="header" href="#contract-address-1">Contract Address</a></h2>
<p>The <code>ContractAddress</code> type represents the address of a deployed contract on
Starknet. Every deployed contract has a unique address that identifies it on the
network. You'll use it to call other contracts, check caller identities, manage
access control, and anything that involves on-chain accounts.</p>
<pre><code class="language-cairo">use starknet::{ContractAddress, get_caller_address};

#[starknet::interface]
pub trait IAddressExample&lt;TContractState&gt; {
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
}

#[starknet::contract]
mod AddressExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        owner: ContractAddress,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_owner: ContractAddress) {
        self.owner.write(initial_owner);
    }

    #[abi(embed_v0)]
    impl AddressExampleImpl of super::IAddressExample&lt;ContractState&gt; {
        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {
            let caller = get_caller_address();
            assert!(caller == self.owner.read(), "Only owner can transfer");
            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p>Contract addresses in Starknet have a value range of <code>[0, 2^251)</code>, which is
enforced by the type system. You can create a <code>ContractAddress</code> from a <code>felt252</code>
using the regular <code>TryInto</code> trait.</p>
<h2 id="storage-address"><a class="header" href="#storage-address">Storage Address</a></h2>
<p>The <code>StorageAddress</code> type represents the location of a value within a contract's
storage. While you typically won't create these addresses directly (the storage
system handles this for you through types like
<a href="./ch101-01-01-storage-mappings.html">Map</a> and
<a href="./ch101-01-02-storage-vecs.html">Vec</a>), understanding this type is important for
advanced storage patterns. Each value stored in the <code>Storage</code> struct has its own
<code>StorageAddress</code>, and can be accessed directly following the rules defined in
the <a href="./ch101-01-00-contract-storage.html">Storage</a> chapter.</p>
<pre><code class="language-cairo">#[starknet::contract]
mod StorageExample {
    use starknet::storage_access::StorageAddress;

    #[storage]
    struct Storage {
        value: u256,
    }

    // This is an internal function that demonstrates StorageAddress usage
    // In practice, you rarely need to work with StorageAddress directly
    fn read_from_storage_address(address: StorageAddress) -&gt; felt252 {
        starknet::syscalls::storage_read_syscall(0, address).unwrap()
    }
}
</code></pre>
<p>Storage addresses share the same value range as contract addresses <code>[0, 2^251)</code>.
The related <code>StorageBaseAddress</code> type represents base addresses that can be
combined with offsets, with a slightly smaller range of <code>[0, 2^251 - 256)</code> to
accommodate offset calculations.</p>
<h2 id="ethereum-address"><a class="header" href="#ethereum-address">Ethereum Address</a></h2>
<p>The <code>EthAddress</code> type represents a 20-byte Ethereum address and is used mostly
for building cross-chain applications on Starknet. This type is used in L1-L2
messaging, token bridges, and any contract that needs to interact with Ethereum.</p>
<pre><code class="language-cairo">use starknet::EthAddress;

#[starknet::interface]
pub trait IEthAddressExample&lt;TContractState&gt; {
    fn set_l1_contract(ref self: TContractState, l1_contract: EthAddress);
    fn send_message_to_l1(ref self: TContractState, recipient: EthAddress, amount: felt252);
}

#[starknet::contract]
mod EthAddressExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::syscalls::send_message_to_l1_syscall;
    use super::EthAddress;

    #[storage]
    struct Storage {
        l1_contract: EthAddress,
    }

    #[abi(embed_v0)]
    impl EthAddressExampleImpl of super::IEthAddressExample&lt;ContractState&gt; {
        fn set_l1_contract(ref self: ContractState, l1_contract: EthAddress) {
            self.l1_contract.write(l1_contract);
        }

        fn send_message_to_l1(ref self: ContractState, recipient: EthAddress, amount: felt252) {
            // Send a message to L1 with recipient and amount
            let payload = array![recipient.into(), amount];
            send_message_to_l1_syscall(self.l1_contract.read().into(), payload.span()).unwrap();
        }
    }

    #[l1_handler]
    fn handle_message_from_l1(ref self: ContractState, from_address: felt252, amount: felt252) {
        // Verify the message comes from the expected L1 contract
        assert!(from_address == self.l1_contract.read().into(), "Invalid L1 sender");
        // Process the message...
    }
}
</code></pre>
<p>This example shows the key uses of <code>EthAddress</code>:</p>
<ul>
<li>Storing L1 contract addresses</li>
<li>Sending messages to Ethereum using <code>send_message_to_l1_syscall</code></li>
<li>Receiving and validating messages from L1 with <code>#[l1_handler]</code></li>
</ul>
<p>The <code>EthAddress</code> type ensures type safety and can be converted to/from <code>felt252</code>
for L1-L2 message serialization.</p>
<h2 id="class-hash-1"><a class="header" href="#class-hash-1">Class Hash</a></h2>
<p>The <code>ClassHash</code> type represents the hash of a contract class (the contract's
code). In Starknet's architecture, contract classes are deployed separately from
contract instances, allowing multiple contracts to share the same code. As such,
you can use the same class hash to deploy multiple contracts, or to upgrade a
contract to a new version.</p>
<pre><code class="language-cairo">use starknet::ClassHash;

#[starknet::interface]
pub trait IClassHashExample&lt;TContractState&gt; {
    fn get_implementation_hash(self: @TContractState) -&gt; ClassHash;
    fn upgrade(ref self: TContractState, new_class_hash: ClassHash);
}

#[starknet::contract]
mod ClassHashExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::syscalls::replace_class_syscall;
    use super::ClassHash;

    #[storage]
    struct Storage {
        implementation_hash: ClassHash,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_class_hash: ClassHash) {
        self.implementation_hash.write(initial_class_hash);
    }

    #[abi(embed_v0)]
    impl ClassHashExampleImpl of super::IClassHashExample&lt;ContractState&gt; {
        fn get_implementation_hash(self: @ContractState) -&gt; ClassHash {
            self.implementation_hash.read()
        }

        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            replace_class_syscall(new_class_hash).unwrap();
            self.implementation_hash.write(new_class_hash);
        }
    }
}
</code></pre>
<p>Class hashes have the same value range as addresses <code>[0, 2^251)</code>. They uniquely
identify a specific version of contract code and are used in deployment
operations, proxy patterns, and upgrade mechanisms.</p>
<h2 id="working-with-block-and-transaction-information"><a class="header" href="#working-with-block-and-transaction-information">Working with Block and Transaction Information</a></h2>
<p>Starknet provides several functions to access information about the current
execution context. These functions return specialized types or structures
containing blockchain state information.</p>
<pre><code class="language-cairo">#[starknet::interface]
pub trait IBlockInfo&lt;TContractState&gt; {
    fn get_block_info(self: @TContractState) -&gt; (u64, u64);
    fn get_tx_info(self: @TContractState) -&gt; (ContractAddress, felt252);
}

#[starknet::contract]
mod BlockInfoExample {
    use starknet::{get_block_info, get_tx_info};
    use super::ContractAddress;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl BlockInfoImpl of super::IBlockInfo&lt;ContractState&gt; {
        fn get_block_info(self: @ContractState) -&gt; (u64, u64) {
            let block_info = get_block_info();
            (block_info.block_number, block_info.block_timestamp)
        }

        fn get_tx_info(self: @ContractState) -&gt; (ContractAddress, felt252) {
            let tx_info = get_tx_info();

            // Access transaction details
            let sender = tx_info.account_contract_address;
            let tx_hash = tx_info.transaction_hash;

            (sender, tx_hash)
        }
    }
}
</code></pre>
<p>The <code>BlockInfo</code> structure contains details about the current block, including
its number and timestamp. The <code>TxInfo</code> structure provides transaction-specific
information, including the sender's address, transaction hash, and fee details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-storage"><a class="header" href="#contract-storage">Contract Storage</a></h1>
<p>The contract’s storage is a persistent storage space where you can read, write,
modify, and persist data. The storage is a map with \(2^{251}\) slots, where
each slot is a <code>felt252</code> initialized to 0.</p>
<p>Each storage slot is identified by a <code>felt252</code> value, called the storage
address, which is computed from the variable's name and parameters that depend
on the variable's type, outlined in the <a href="./ch101-01-00-contract-storage.html#addresses-of-storage-variables">"Addresses of Storage
Variables"</a> section.</p>
<p>We can interact with the contract's storage in two ways:</p>
<ol>
<li>Through high-level storage variables, which are declared in a special
<code>Storage</code> struct annotated with the <code>#[storage]</code> attribute.</li>
<li>Directly accessing storage slots using their computed address and the
low-level <code>storage_read</code> and <code>storage_write</code> syscalls. This is useful when
you need to perform custom storage operations that don't fit well with the
structured approach of storage variables, but should generally be avoided; as
such, we will not cover them in this chapter.</li>
</ol>
<h2 id="declaring-and-using-storage-variables"><a class="header" href="#declaring-and-using-storage-variables">Declaring and Using Storage Variables</a></h2>
<p>Storage variables in Starknet contracts are stored in a special struct called
<code>Storage</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span>    #[storage]
    struct Storage {
        owner: Person,
        expiration: Expiration,
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>The <code>Storage</code> struct is a <a href="./ch05-00-using-structs-to-structure-related-data.html">struct</a> like any other, except that it
<strong>must</strong> be annotated with the <code>#[storage]</code> attribute. This annotation tells the
compiler to generate the required code to interact with the blockchain state,
and allows you to read and write data from and to storage. This struct can
contain any type that implements the <code>Store</code> trait, including other structs,
enums, as well as <a href="./ch101-01-01-storage-mappings.html">Storage Mappings</a>, <a href="./ch101-01-02-storage-vecs.html">Storage
Vectors</a>, and <a href="./ch101-01-00-contract-storage.html#storage-nodes">Storage Nodes</a>. In this section,
we'll focus on simple storage variables, and we'll see how to store more complex
types in the next sections.</p>
<h3 id="accessing-storage-variables"><a class="header" href="#accessing-storage-variables">Accessing Storage Variables</a></h3>
<p>Variables stored in the <code>Storage</code> struct can be accessed and modified using the
<code>read</code> and <code>write</code> functions, respectively. All these functions are
automatically generated by the compiler for each storage variable.</p>
<p>To read the value of the <code>owner</code> storage variable, which is of type <code>Person</code>, we
call the <code>read</code> function on the <code>owner</code> variable, passing in no arguments.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span>        fn get_owner(self: @ContractState) -&gt; Person {
            self.owner.read()
        }
<span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>To write a new value to the storage slot of a storage variable, we call the
<code>write</code> function, passing in the value as argument. Here, we only pass in the
value to write to the <code>owner</code> variable as it is a simple variable.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.owner.write(owner);
    }
<span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>When working with compound types, instead of calling <code>read</code> and <code>write</code> on the
struct variable itself, which would perform a storage operation for each member,
you can call <code>read</code> and <code>write</code> on specific members of the struct. This allows
you to access and modify the values of the struct members directly, minimizing
the amount of storage operations performed. In the following example, the
<code>owner</code> variable is of type <code>Person</code>. Thus, it has one attribute called <code>name</code>,
on which we can call the <code>read</code> and <code>write</code> functions to access and modify its
value.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span>        fn get_owner_name(self: @ContractState) -&gt; felt252 {
            self.owner.name.read()
        }
<span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h2 id="storing-custom-types-with-the-store-trait"><a class="header" href="#storing-custom-types-with-the-store-trait">Storing Custom Types with the <code>Store</code> Trait</a></h2>
<p>The <code>Store</code> trait, defined in the <code>starknet::storage_access</code> module, is used to
specify how a type should be stored in storage. In order for a type to be stored
in storage, it <strong>must</strong> implement the <code>Store</code> trait. Most types from the core
library, such as unsigned integers (<code>u8</code>, <code>u128</code>, <code>u256</code>...), <code>felt252</code>, <code>bool</code>,
<code>ByteArray</code>, <code>ContractAddress</code>, etc. implement the <code>Store</code> trait and can thus be
stored without further action. However, <strong>memory collections</strong>, such as
<code>Array&lt;T&gt;</code> and <code>Felt252Dict&lt;T&gt;</code>, <strong>cannot</strong> be stored in contract storage - you
will have to use the special types <code>Vec&lt;T&gt;</code> and <code>Map&lt;K, V&gt;</code> instead.</p>
<p>But what if you wanted to store a type that you defined yourself, such as an
enum or a struct? In that case, you have to explicitly tell the compiler how to
store this type.</p>
<p>In our example, we want to store a <code>Person</code> struct in storage, which is only
possible by implementing the <code>Store</code> trait for the <code>Person</code> type. This can be
simply achieved by adding a <code>#[derive(starknet::Store)]</code> attribute on top of our
struct definition. Note that all the members of the struct need to implement the
<code>Store</code> trait for the trait to be derived.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }
<span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>Similarly, Enums can only be written to storage if they implement the <code>Store</code>
trait, which can be trivially derived as long as all associated types implement
the <code>Store</code> trait.</p>
<p>Enums used in contract storage <strong>must</strong> define a default variant. This default
variant is returned when reading an empty storage slot - otherwise, it will
result in a runtime error.</p>
<p>Here's an example of how to properly define an enum for use in contract storage:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Copy, Drop, Serde, starknet::Store)]
    pub enum Expiration {
        Finite: u64,
        #[default]
        Infinite,
    }
<span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>In this example, we've added the <code>#[default]</code> attribute to the <code>Infinite</code>
variant. This tells the Cairo compiler that if we try to read an uninitialized
enum from storage, the <code>Infinite</code> variant should be returned.</p>
<p>You might have noticed that we also derived <code>Drop</code> and <code>Serde</code> on our custom
types. Both of them are required for properly serializing arguments passed to
entrypoints and deserializing their outputs.</p>
<h2 id="structs-storage-layout"><a class="header" href="#structs-storage-layout">Structs Storage Layout</a></h2>
<p>On Starknet, structs are stored in storage as a sequence of primitive types. The
elements of the struct are stored in the same order as they are defined in the
struct definition. The first element of the struct is stored at the base address
of the struct, which is computed as specified in the <a href="./ch101-01-00-contract-storage.html#addresses-of-storage-variables">"Addresses of Storage
Variables"</a> section and can be obtained with
<code>var.__base_address__</code>. Subsequent elements are stored at addresses contiguous
to the previous element. For example, the storage layout for the <code>owner</code>
variable of type <code>Person</code> will result in the following layout:</p>
<div class="table-wrapper"><table><thead><tr><th>Fields</th><th>Address</th></tr></thead><tbody>
<tr><td>name</td><td><code>owner.__base_address__</code></td></tr>
<tr><td>address</td><td><code>owner.__base_address__ +1</code></td></tr>
</tbody></table>
</div>
<p>Note that tuples are similarly stored in contract's storage, with the first
element of the tuple being stored at the base address, and subsequent elements
stored contiguously.</p>
<h2 id="enums-storage-layout"><a class="header" href="#enums-storage-layout">Enums Storage Layout</a></h2>
<p>When you store an enum variant, what you're essentially storing is the variant's
index and eventual associated values. This index starts at 0 for the first
variant of your enum and increments by 1 for each subsequent variant. If your
variant has an associated value, this value is stored starting from the address
immediately following the address of the index of the variant. For example,
suppose we have the <code>Expiration</code> enum with the <code>Finite</code> variant that carries an
associated limit date, and the <code>Infinite</code> variant without associated data. The
storage layout for the <code>Finite</code> variant would look like this:</p>
<div class="table-wrapper"><table><thead><tr><th>Element</th><th>Address</th></tr></thead><tbody>
<tr><td>Variant index (0 for Finite)</td><td><code>expiration.__base_address__</code></td></tr>
<tr><td>Associated limit date</td><td><code>expiration.__base_address__ + 1</code></td></tr>
</tbody></table>
</div>
<p>while the storage layout for the <code>Infinite</code> variant would be as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Element</th><th>Address</th></tr></thead><tbody>
<tr><td>Variant index (1 for Infinite)</td><td><code>expiration.__base_address__</code></td></tr>
</tbody></table>
</div><!-- TODO: add example -->
<h2 id="storage-nodes"><a class="header" href="#storage-nodes">Storage Nodes</a></h2>
<p>A storage node is a special kind of struct that can contain storage-specific
types, such as <a href="./ch101-01-01-storage-mappings.html"><code>Map</code></a>, <a href="./ch101-01-02-storage-vecs.html"><code>Vec</code></a>, or other
storage nodes, as members. Unlike regular structs, storage nodes can only exist
within contract storage and cannot be instantiated or used outside of it. You
can think of storage nodes as intermediate nodes involved in address
calculations within the tree representing the contract's storage space. In the
next subsection, we will introduce how this concept is modeled in the core
library.</p>
<p>The main benefits of storage nodes is that they allow you to create more
sophisticated storage layouts, including mappings or vectors inside custom
types, and allow you to logically group related data, improving code readability
and maintainability.</p>
<p>Storage nodes are structs defined with the <code>#[starknet::storage_node]</code>
attribute. In this new contract that implements a voting system, we implement a
<code>ProposalNode</code> storage node containing a <code>Map&lt;ContractAddress, bool&gt;</code> to keep
track of the voters of the proposal, along with other fields to store the
proposal's metadata.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::contract]
</span><span class="boring">mod VotingSystem {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        proposals: Map&lt;u32, ProposalNode&gt;,
</span><span class="boring">        proposal_count: u32,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[starknet::storage_node]
    struct ProposalNode {
        title: felt252,
        description: felt252,
        yes_votes: u32,
        no_votes: u32,
        voters: Map&lt;ContractAddress, bool&gt;,
    }
<span class="boring">
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn create_proposal(ref self: ContractState, title: felt252, description: felt252) -&gt; u32 {
</span><span class="boring">        let mut proposal_count = self.proposal_count.read();
</span><span class="boring">        let new_proposal_id = proposal_count + 1;
</span><span class="boring">
</span><span class="boring">        let mut proposal = self.proposals.entry(new_proposal_id);
</span><span class="boring">        proposal.title.write(title);
</span><span class="boring">        proposal.description.write(description);
</span><span class="boring">        proposal.yes_votes.write(0);
</span><span class="boring">        proposal.no_votes.write(0);
</span><span class="boring">
</span><span class="boring">        self.proposal_count.write(new_proposal_id);
</span><span class="boring">
</span><span class="boring">        new_proposal_id
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn vote(ref self: ContractState, proposal_id: u32, vote: bool) {
</span><span class="boring">        let mut proposal = self.proposals.entry(proposal_id);
</span><span class="boring">        let caller = get_caller_address();
</span><span class="boring">        let has_voted = proposal.voters.entry(caller).read();
</span><span class="boring">        if has_voted {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        proposal.voters.entry(caller).write(true);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>When accessing a storage node, you can't <code>read</code> or <code>write</code> it directly. Instead,
you have to access its individual members. Here's an example from our
<code>VotingSystem</code> contract that demonstrates how we populate each field of the
<code>ProposalNode</code> storage node:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::contract]
</span><span class="boring">mod VotingSystem {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        proposals: Map&lt;u32, ProposalNode&gt;,
</span><span class="boring">        proposal_count: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[starknet::storage_node]
</span><span class="boring">    struct ProposalNode {
</span><span class="boring">        title: felt252,
</span><span class="boring">        description: felt252,
</span><span class="boring">        yes_votes: u32,
</span><span class="boring">        no_votes: u32,
</span><span class="boring">        voters: Map&lt;ContractAddress, bool&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[external(v0)]
    fn create_proposal(ref self: ContractState, title: felt252, description: felt252) -&gt; u32 {
        let mut proposal_count = self.proposal_count.read();
        let new_proposal_id = proposal_count + 1;

        let mut proposal = self.proposals.entry(new_proposal_id);
        proposal.title.write(title);
        proposal.description.write(description);
        proposal.yes_votes.write(0);
        proposal.no_votes.write(0);

        self.proposal_count.write(new_proposal_id);

        new_proposal_id
    }
<span class="boring">
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn vote(ref self: ContractState, proposal_id: u32, vote: bool) {
</span><span class="boring">        let mut proposal = self.proposals.entry(proposal_id);
</span><span class="boring">        let caller = get_caller_address();
</span><span class="boring">        let has_voted = proposal.voters.entry(caller).read();
</span><span class="boring">        if has_voted {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        proposal.voters.entry(caller).write(true);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Because no voter has voted on this proposal yet, we don't need to populate the
<code>voters</code> map when creating the proposal. But we could very well access the
<code>voters</code> map to check if a given address has already voted on this proposal when
it tries to cast its vote:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::contract]
</span><span class="boring">mod VotingSystem {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        proposals: Map&lt;u32, ProposalNode&gt;,
</span><span class="boring">        proposal_count: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[starknet::storage_node]
</span><span class="boring">    struct ProposalNode {
</span><span class="boring">        title: felt252,
</span><span class="boring">        description: felt252,
</span><span class="boring">        yes_votes: u32,
</span><span class="boring">        no_votes: u32,
</span><span class="boring">        voters: Map&lt;ContractAddress, bool&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn create_proposal(ref self: ContractState, title: felt252, description: felt252) -&gt; u32 {
</span><span class="boring">        let mut proposal_count = self.proposal_count.read();
</span><span class="boring">        let new_proposal_id = proposal_count + 1;
</span><span class="boring">
</span><span class="boring">        let mut proposal = self.proposals.entry(new_proposal_id);
</span><span class="boring">        proposal.title.write(title);
</span><span class="boring">        proposal.description.write(description);
</span><span class="boring">        proposal.yes_votes.write(0);
</span><span class="boring">        proposal.no_votes.write(0);
</span><span class="boring">
</span><span class="boring">        self.proposal_count.write(new_proposal_id);
</span><span class="boring">
</span><span class="boring">        new_proposal_id
</span><span class="boring">    }
</span><span class="boring">
</span>    #[external(v0)]
    fn vote(ref self: ContractState, proposal_id: u32, vote: bool) {
        let mut proposal = self.proposals.entry(proposal_id);
        let caller = get_caller_address();
        let has_voted = proposal.voters.entry(caller).read();
        if has_voted {
            return;
        }
        proposal.voters.entry(caller).write(true);
    }
<span class="boring">}
</span></code></pre>
<p>In this example, we access the <code>ProposalNode</code> for a specific proposal ID. We
then check if the caller has already voted by reading from the <code>voters</code> map
within the storage node. If they haven't voted yet, we write to the <code>voters</code> map
to mark that they have now voted.</p>
<h2 id="addresses-of-storage-variables"><a class="header" href="#addresses-of-storage-variables">Addresses of Storage Variables</a></h2>
<p>The address of a storage variable is computed as follows:</p>
<ul>
<li>
<p>If the variable is a single value, the address is the <code>sn_keccak</code> hash of the
ASCII encoding of the variable's name. <code>sn_keccak</code> is Starknet's version of
the Keccak256 hash function, whose output is truncated to 250 bits.</p>
</li>
<li>
<p>If the variable is composed of multiple values (i.e., a tuple, a struct or an
enum), we also use the <code>sn_keccak</code> hash of the ASCII encoding of the
variable's name to determine the base address in storage. Then, depending on
the type, the storage layout will differ. See the <a href="./ch101-01-00-contract-storage.html#storing-custom-types-with-the-store-trait">"Storing Custom
Types"</a> section.</p>
</li>
<li>
<p>If the variable is part of a <a href="./ch101-01-00-contract-storage.html#storage-nodes">storage node</a>, its address is
based on a chain of hashes that reflects the structure of the node. For a
storage node member <code>m</code> within a storage variable <code>variable_name</code>, the path to
that member is computed as <code>h(sn_keccak(variable_name), sn_keccak(m))</code>, where
<code>h</code> is the Pedersen hash. This process continues for nested storage nodes,
building a chain of hashes that represents the path to a leaf node. Once a
leaf node is reached, the storage calculation proceeds as it normally would
for that type of variable.</p>
</li>
<li>
<p>If the variable is a <a href="./ch101-01-01-storage-mappings.html">Map</a> or a <a href="./ch101-01-02-storage-vecs.html">Vec</a>, the
address is computed relative to the storage base address, which is the
<code>sn_keccak</code> hash of the variable's name, and the keys of the mapping or
indexes in the Vec. The exact computation is described in the <a href="./ch101-01-01-storage-mappings.html">"Storage
Mappings"</a> and <a href="./ch101-01-02-storage-vecs.html">"Storage Vecs"</a> sections.</p>
</li>
</ul>
<p>You can access the base address of a storage variable by accessing the
<code>__base_address__</code> attribute on the variable, which returns a <code>felt252</code> value.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span>        self.total_names.__base_address__
<span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>This address calculation mechanism is performed through a modelisation of the
contract storage space using a concept of StoragePointers and StoragePaths that
we'll now introduce.</p>
<h2 id="modeling-of-the-contract-storage-in-the-core-library"><a class="header" href="#modeling-of-the-contract-storage-in-the-core-library">Modeling of the Contract Storage in the Core Library</a></h2>
<p>To understand how storage variables are stored in Cairo, it's important to note
that they are not stored contiguously but in different locations in the
contract's storage. To facilitate the retrieval of these addresses, the core
library provides a model of the contract storage through a system of
<code>StoragePointers</code> and <code>StoragePaths</code>.</p>
<p>Each storage variable can be converted to a <code>StoragePointer</code>. This pointer
contains two main fields:</p>
<ul>
<li>The base address of the storage variable in the contract's storage.</li>
<li>The offset, relative to the base address, of the specific storage slot being
pointed to.</li>
</ul>
<p>An example is worth a thousand words. Let's consider the <code>Person</code> struct defined
in the previous section:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait ISimpleStorage&lt;TContractState&gt; {
</span><span class="boring">    fn get_owner(self: @TContractState) -&gt; SimpleStorage::Person;
</span><span class="boring">    fn get_owner_name(self: @TContractState) -&gt; felt252;
</span><span class="boring">    fn get_expiration(self: @TContractState) -&gt; SimpleStorage::Expiration;
</span><span class="boring">    fn change_expiration(ref self: TContractState, expiration: SimpleStorage::Expiration);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod SimpleStorage {
</span><span class="boring">    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        owner: Person,
</span><span class="boring">        expiration: Expiration,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }
<span class="boring">
</span><span class="boring">    #[derive(Copy, Drop, Serde, starknet::Store)]
</span><span class="boring">    pub enum Expiration {
</span><span class="boring">        Finite: u64,
</span><span class="boring">        #[default]
</span><span class="boring">        Infinite,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.owner.write(owner);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl SimpleCounterImpl of super::ISimpleStorage&lt;ContractState&gt; {
</span><span class="boring">        fn get_owner(self: @ContractState) -&gt; Person {
</span><span class="boring">            self.owner.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">            self.owner.name.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_expiration(self: @ContractState) -&gt; Expiration {
</span><span class="boring">            self.expiration.read()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_expiration(ref self: ContractState, expiration: Expiration) {
</span><span class="boring">            if get_caller_address() != self.owner.address.read() {
</span><span class="boring">                panic!("Only the owner can change the expiration");
</span><span class="boring">            }
</span><span class="boring">            self.expiration.write(expiration);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.__base_address__
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_owner_name_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.owner.name.__storage_pointer_address__.into()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>When we write <code>let x = self.owner;</code>, we access a variable of type <code>StorageBase</code>
that represents the base location of the <code>owner</code> variable in the contract's
storage. From this base address, we can either get pointers to the struct's
fields (like <code>name</code> or <code>address</code>) or a pointer to the struct itself. On these
pointers, we can call <code>read</code> and <code>write</code>, defined in the <code>Store</code> trait, to read
and write the values pointed to.</p>
<p>Of course, all of this is transparent to the developer. We can read and write to
the struct's fields as if we were accessing regular variables, but the compiler
translates these accesses into the appropriate <code>StoragePointer</code> manipulations
under the hood.</p>
<p>For storage mappings, the process is similar, except that we introduce an
intermediate type, <code>StoragePath</code>. A <code>StoragePath</code> is a chain of storage nodes
and struct fields that form a path to a specific storage slot. For example, to
access a value contained in a <code>Map&lt;ContractAddress, u128&gt;</code>, the process would be
the following:</p>
<ol>
<li>Start at <code>StorageBase</code> of the <code>Map</code>, and convert it to a <code>StoragePath</code>.</li>
<li>Walk the <code>StoragePath</code> to reach the desired value using the <code>entry</code> method,
which, in the case of a <code>Map</code>, hashes the current path with the next key to
generate the next <code>StoragePath</code>.</li>
<li>Repeat step 2 until the <code>StoragePath</code> points to the desired value, converting
the final value to a <code>StoragePointer</code></li>
<li>Read or write the value at that pointer.</li>
</ol>
<p>Note that we need to convert the <code>ContractAddress</code> to a <code>StoragePointer</code> before
being able to read or write to it.</p>
<p><img src="mermaid-storage-model.png" alt="Modelisation of the Storage Space in the Core Library" /></p>
<!-- ./mermaid-storage-model.txt -->
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>In this chapter, we covered the following key points:</p>
<ul>
<li><strong>Storage Variables</strong>: These are used to store persistent data on the
blockchain. They are defined in a special <code>Storage</code> struct annotated with the
<code>#[storage]</code> attribute.</li>
<li><strong>Accessing Storage Variables</strong>: You can read and write storage variables
using automatically generated <code>read</code> and <code>write</code> functions. For structs, you
can access individual members directly.</li>
<li><strong>Custom Types with the <code>Store</code> Trait</strong>: To store custom types like structs
and enums, they must implement the <code>Store</code> trait. This can be achieved using
the <code>#[derive(starknet::Store)]</code> attribute or writing your own implementation.</li>
<li><strong>Addresses of Storage Variables</strong>: The address of a storage variable is
computed using the <code>sn_keccak</code> hash of its name, and additional steps for
special types. For complex types, the storage layout is determined by the
type's structure.</li>
<li><strong>Structs and Enums Storage Layout</strong>: Structs are stored as a sequence of
primitive types, while enums store the variant index and potential associated
values.</li>
<li><strong>Storage Nodes</strong>: Special structs that can contain storage-specific types
like <code>Map</code> or <code>Vec</code>. They allow for more sophisticated storage layouts and can
only exist within contract storage.</li>
</ul>
<p>Next, we'll focus on the <code>Map</code> and <code>Vec</code> types in depth.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-key-value-pairs-with-mappings"><a class="header" href="#storing-key-value-pairs-with-mappings">Storing Key-Value Pairs with Mappings</a></h1>
<p>Storage mappings in Cairo provide a way to associate keys with values and
persist them in the contract's storage. Unlike traditional hash tables, storage
mappings do not store the key data itself; instead, they use the hash of the key
to compute an address that corresponds to the storage slot where the
corresponding value is stored. Therefore, it is not possible to iterate over the
keys of a storage mapping.</p>
<div align="center">
    <img src="mappings.png" alt="mappings" width="500px"/>
<div align="center">
    </div>
    <span class="caption">Figure 15-1: Mapping keys to values in storage</span>
</div>
<p>Mappings do not have a concept of length or whether a key-value pair is set. All
values are by default set to 0. As such, the only way to remove an entry from a
mapping is to set its value to the default value for the type, which would be
<code>0</code> for the <code>u64</code> type.</p>
<p>The <code>Map</code> type, provided by the Cairo core library, inside the
<code>core::starknet::storage</code> module, is used to declare mappings in contracts.</p>
<p>To declare a mapping, use the <code>Map</code> type enclosed in angle brackets <code>&lt;&gt;</code>,
specifying the key and value types. In Listing 15-2, we
create a simple contract that stores values mapped to the caller's address.</p>
<blockquote>
<p>The <code>Felt252Dict</code> type is a <strong>memory</strong> type that cannot be stored in contract
storage. For persistent storage of key-value pairs, use the <code>Map</code> type, which
is a [phantom type][phantom types] designed specifically for contract storage.
However, <code>Map</code> has limitations: it can't be instantiated as a regular
variable, used as a function parameter, or included as a member in regular
structs. <code>Map</code> can only be used as a storage variable within a contract's
storage struct. To work with the contents of a <code>Map</code> in memory or perform
complex operations, you'll need to copy its elements to and from a
<code>Felt252Dict</code> or other suitable data structure.</p>
</blockquote>
<h2 id="declaring-and-using-storage-mappings"><a class="header" href="#declaring-and-using-storage-mappings">Declaring and Using Storage Mappings</a></h2>
<!-- TODO PHANTOM TYPES -->
<!-- [phantom types]: ./ch12-03-intro-to-phantom-data.html -->
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IUserValues&lt;TState&gt; {
</span><span class="boring">    fn set(ref self: TState, amount: u64);
</span><span class="boring">    fn get(self: @TState, address: ContractAddress) -&gt; u64;
</span><span class="boring">}
</span><span class="boring">
</span>#[starknet::contract]
mod UserValues {
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        user_values: Map&lt;ContractAddress, u64&gt;,
    }

    #[abi(embed_v0)]
    impl UserValuesImpl of super::IUserValues&lt;ContractState&gt; {
        fn set(ref self: ContractState, amount: u64) {
            let caller = get_caller_address();
            self.user_values.entry(caller).write(amount);
        }

        fn get(self: @ContractState, address: ContractAddress) -&gt; u64 {
            self.user_values.entry(address).read()
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>15-2: Declaring a storage mapping in the Storage
struct</span></p>
<p>To read the value corresponding to a key in a mapping, you first need to
retrieve the storage pointer associated with that key. This is done by calling
the <code>entry</code> method on the storage mapping variable, passing in the key as a
parameter. Once you have the entry path, you can call the <code>read</code> function on it
to retrieve the stored value.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IUserValues&lt;TState&gt; {
</span><span class="boring">    fn set(ref self: TState, amount: u64);
</span><span class="boring">    fn get(self: @TState, address: ContractAddress) -&gt; u64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod UserValues {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        user_values: Map&lt;ContractAddress, u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl UserValuesImpl of super::IUserValues&lt;ContractState&gt; {
</span><span class="boring">        fn set(ref self: ContractState, amount: u64) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self.user_values.entry(caller).write(amount);
</span><span class="boring">        }
</span><span class="boring">
</span>        fn get(self: @ContractState, address: ContractAddress) -&gt; u64 {
            self.user_values.entry(address).read()
        }
<span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>Similarly, to write a value in a storage mapping, you need to retrieve the
storage pointer corresponding to the key. Once you have this storage pointer,
you can call the <code>write</code> function on it with the value to write.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IUserValues&lt;TState&gt; {
</span><span class="boring">    fn set(ref self: TState, amount: u64);
</span><span class="boring">    fn get(self: @TState, address: ContractAddress) -&gt; u64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod UserValues {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        user_values: Map&lt;ContractAddress, u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl UserValuesImpl of super::IUserValues&lt;ContractState&gt; {
</span>        fn set(ref self: ContractState, amount: u64) {
            let caller = get_caller_address();
            self.user_values.entry(caller).write(amount);
        }
<span class="boring">
</span><span class="boring">        fn get(self: @ContractState, address: ContractAddress) -&gt; u64 {
</span><span class="boring">            self.user_values.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h2 id="nested-mappings"><a class="header" href="#nested-mappings">Nested Mappings</a></h2>
<p>You can also create more complex mappings with multiple keys. To illustrate
this, we'll implement a contract representing warehouses assigned to users,
where each user can store multiple items with their respective quantities.</p>
<p>The <code>user_warehouse</code> mapping is a storage mapping that maps <code>ContractAddress</code> to
another mapping that maps <code>u64</code> (item ID) to <code>u64</code> (quantity). This can be
implemented by declaring a <code>Map&lt;ContractAddress, Map&lt;u64, u64&gt;&gt;</code> in the storage
struct. Each <code>ContractAddress</code> key in the <code>user_warehouse</code> mapping corresponds
to a user's warehouse, and each user's warehouse contains a mapping of item IDs
to their respective quantities.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IWarehouseContract&lt;TState&gt; {
</span><span class="boring">    fn set_quantity(ref self: TState, item_id: u64, quantity: u64);
</span><span class="boring">    fn get_item_quantity(self: @TState, address: ContractAddress, item_id: u64) -&gt; u64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod WarehouseContract {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span>    #[storage]
    struct Storage {
        user_warehouse: Map&lt;ContractAddress, Map&lt;u64, u64&gt;&gt;,
    }
<span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl WarehouseContractImpl of super::IWarehouseContract&lt;ContractState&gt; {
</span><span class="boring">        fn set_quantity(ref self: ContractState, item_id: u64, quantity: u64) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self.user_warehouse.entry(caller).entry(item_id).write(quantity);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_item_quantity(self: @ContractState, address: ContractAddress, item_id: u64) -&gt; u64 {
</span><span class="boring">            self.user_warehouse.entry(address).entry(item_id).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IWarehouseContractDispatcher, IWarehouseContractDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IWarehouseContractDispatcher {
</span><span class="boring">        let contract = declare("WarehouseContract").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IWarehouseContractDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_default_quantity_is_zero() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 1), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_set_and_get_quantity_for_caller() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.set_quantity(10, 42);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 10), 42);
</span><span class="boring">        // Different item id should remain zero
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 11), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_quantities_are_per_user() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user1: ContractAddress = 0xabc.try_into().unwrap();
</span><span class="boring">        let user2: ContractAddress = 0xdef.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user1);
</span><span class="boring">        dispatcher.set_quantity(1, 10);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user2);
</span><span class="boring">        dispatcher.set_quantity(1, 7);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user1, 1), 10);
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user2, 1), 7);
</span><span class="boring">        // Ensure other item for user1 remains zero
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user1, 2), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_update_quantity_overwrites_value() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.set_quantity(5, 1);
</span><span class="boring">        dispatcher.set_quantity(5, 99);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 5), 99);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In this case, the same principle applies for accessing the stored values. You
need to traverse the keys step by step, using the <code>entry</code> method to get the
storage path to the next key in the sequence, and finally calling <code>read</code> or
<code>write</code> on the innermost mapping.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IWarehouseContract&lt;TState&gt; {
</span><span class="boring">    fn set_quantity(ref self: TState, item_id: u64, quantity: u64);
</span><span class="boring">    fn get_item_quantity(self: @TState, address: ContractAddress, item_id: u64) -&gt; u64;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod WarehouseContract {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        user_warehouse: Map&lt;ContractAddress, Map&lt;u64, u64&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl WarehouseContractImpl of super::IWarehouseContract&lt;ContractState&gt; {
</span>        fn set_quantity(ref self: ContractState, item_id: u64, quantity: u64) {
            let caller = get_caller_address();
            self.user_warehouse.entry(caller).entry(item_id).write(quantity);
        }

        fn get_item_quantity(self: @ContractState, address: ContractAddress, item_id: u64) -&gt; u64 {
            self.user_warehouse.entry(address).entry(item_id).read()
        }
<span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IWarehouseContractDispatcher, IWarehouseContractDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IWarehouseContractDispatcher {
</span><span class="boring">        let contract = declare("WarehouseContract").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IWarehouseContractDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_default_quantity_is_zero() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 1), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_set_and_get_quantity_for_caller() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.set_quantity(10, 42);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 10), 42);
</span><span class="boring">        // Different item id should remain zero
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 11), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_quantities_are_per_user() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user1: ContractAddress = 0xabc.try_into().unwrap();
</span><span class="boring">        let user2: ContractAddress = 0xdef.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user1);
</span><span class="boring">        dispatcher.set_quantity(1, 10);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user2);
</span><span class="boring">        dispatcher.set_quantity(1, 7);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user1, 1), 10);
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user2, 1), 7);
</span><span class="boring">        // Ensure other item for user1 remains zero
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user1, 2), 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_update_quantity_overwrites_value() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        let user: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.set_quantity(5, 1);
</span><span class="boring">        dispatcher.set_quantity(5, 99);
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_item_quantity(user, 5), 99);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="storage-address-computation-for-mappings"><a class="header" href="#storage-address-computation-for-mappings">Storage Address Computation for Mappings</a></h2>
<p>The address in storage of a variable stored in a mapping is computed according
to the following rules:</p>
<ul>
<li>For a single key <code>k</code>, the address of the value at key <code>k</code> is
<code>h(sn_keccak(variable_name), k)</code>, where <code>h</code> is the Pedersen hash and the final
value is taken modulo \( {2^{251}} - 256\).</li>
<li>For multiple keys, the address is computed as
<code>h(...h(h(sn_keccak(variable_name), k_1), k_2), ..., k_n)</code>, with
<code>k_1, ..., k_n</code> being all keys that constitute the mapping.</li>
</ul>
<p>If the key of a mapping is a struct, each element of the struct constitutes a
key. Moreover, the struct should implement the <code>Hash</code> trait, which can be
derived with the <code>#[derive(Hash)]</code> attribute.</p>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<ul>
<li>Storage mappings allow you to map keys to values in contract storage.</li>
<li>Use the <code>Map</code> type to declare mappings.</li>
<li>Access mappings using the <code>entry</code> method and <code>read</code>/<code>write</code> functions.</li>
<li>Mappings can contain other mappings, creating nested storage mappings.</li>
<li>The address of a mapping variable is computed using the <code>sn_keccak</code> and the
Pedersen hash functions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-collections-with-vectors"><a class="header" href="#storing-collections-with-vectors">Storing Collections with Vectors</a></h1>
<p>The <code>Vec</code> type provides a way to store collections of values in the contract's
storage. In this section, we will explore how to declare, add elements to and
retrieve elements from a <code>Vec</code>, as well as how the storage addresses for <code>Vec</code>
variables are computed.</p>
<p>The <code>Vec</code> type is provided by the Cairo core library, inside the
<code>starknet::storage</code> module. Its associated methods are defined in the <code>VecTrait</code>
and <code>MutableVecTrait</code> traits that you will also need to import for read and
write operations on the <code>Vec</code> type.</p>
<blockquote>
<p>The <code>Array&lt;T&gt;</code> type is a <strong>memory</strong> type and cannot be directly stored in
contract storage. For storage, use the <code>Vec&lt;T&gt;</code> type, which is a [phantom
type][phantom types] designed specifically for contract storage. However,
<code>Vec&lt;T&gt;</code> has limitations: it can't be instantiated as a regular variable, used
as a function parameter, or included as a member in regular structs. To work
with the full contents of a <code>Vec&lt;T&gt;</code>, you'll need to copy its elements to and
from a memory <code>Array&lt;T&gt;</code>.</p>
</blockquote>
<h2 id="declaring-and-using-storage-vectors"><a class="header" href="#declaring-and-using-storage-vectors">Declaring and Using Storage Vectors</a></h2>
<p>To declare a Storage Vector, use the <code>Vec</code> type enclosed in angle brackets <code>&lt;&gt;</code>,
specifying the type of elements it will store. In Listing 15-3,
we create a simple contract that registers all the addresses that call it and
stores them in a <code>Vec</code>. We can then retrieve the <code>n</code>-th registered address, or
all registered addresses.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IAddressList&lt;TState&gt; {
</span><span class="boring">    fn register_caller(ref self: TState);
</span><span class="boring">    fn get_n_th_registered_address(self: @TState, index: u64) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">    fn get_all_addresses(self: @TState) -&gt; Array&lt;ContractAddress&gt;;
</span><span class="boring">    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
</span><span class="boring">    fn pop_last_registered_address(ref self: TState) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>#[starknet::contract]
pub mod AddressList {
    use starknet::storage::{
        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
    };
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        addresses: Vec&lt;ContractAddress&gt;,
    }

    #[abi(embed_v0)]
    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.push(caller);
        }

        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.get(index).map(|ptr| ptr.read())
        }

        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses[i].read());
            }
            addresses
        }

        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            self.addresses[index].write(new_address);
        }

        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.pop()
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IAddressListDispatcher, IAddressListDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IAddressListDispatcher {
</span><span class="boring">        let contract = declare("AddressList").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IAddressListDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_get_out_of_bounds_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_and_get_single() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let first = dispatcher.get_n_th_registered_address(0).unwrap();
</span><span class="boring">        assert_eq!(first, user);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_multiple_and_get_all_in_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0xaaa.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0xbbb.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0xccc.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let mut all = dispatcher.get_all_addresses();
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a1);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a2);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a3);
</span><span class="boring">        assert!(all.pop_front().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_modify_nth_address() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x101.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x202.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">        let new_mid: ContractAddress = 0x404.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // Modify the second entry (index 1)
</span><span class="boring">        dispatcher.modify_nth_address(1, new_mid);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(1).unwrap(), new_mid);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(2).unwrap(), a3);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_empty_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_removes_last_in_lifo_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // First pop returns last pushed (a2)
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a2);
</span><span class="boring">        // Index 1 should now be out of bounds
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(1).is_none());
</span><span class="boring">        // Index 0 remains a1
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">
</span><span class="boring">        // Second pop returns a1 and empties the list
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a1);
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">        // Further pops return None
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Declaring a storage <code>Vec</code> in the Storage struct</span></p>
<p>To add an element to a <code>Vec</code>, you can use the <code>push</code> method to add an element to
the end of the <code>Vec</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IAddressList&lt;TState&gt; {
</span><span class="boring">    fn register_caller(ref self: TState);
</span><span class="boring">    fn get_n_th_registered_address(self: @TState, index: u64) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">    fn get_all_addresses(self: @TState) -&gt; Array&lt;ContractAddress&gt;;
</span><span class="boring">    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
</span><span class="boring">    fn pop_last_registered_address(ref self: TState) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">pub mod AddressList {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        addresses: Vec&lt;ContractAddress&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
</span>        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.push(caller);
        }
<span class="boring">
</span><span class="boring">        fn get_n_th_registered_address(
</span><span class="boring">            self: @ContractState, index: u64,
</span><span class="boring">        ) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.get(index).map(|ptr| ptr.read())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
</span><span class="boring">            let mut addresses = array![];
</span><span class="boring">            for i in 0..self.addresses.len() {
</span><span class="boring">                addresses.append(self.addresses[i].read());
</span><span class="boring">            }
</span><span class="boring">            addresses
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
</span><span class="boring">            self.addresses[index].write(new_address);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.pop()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IAddressListDispatcher, IAddressListDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IAddressListDispatcher {
</span><span class="boring">        let contract = declare("AddressList").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IAddressListDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_get_out_of_bounds_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_and_get_single() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let first = dispatcher.get_n_th_registered_address(0).unwrap();
</span><span class="boring">        assert_eq!(first, user);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_multiple_and_get_all_in_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0xaaa.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0xbbb.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0xccc.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let mut all = dispatcher.get_all_addresses();
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a1);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a2);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a3);
</span><span class="boring">        assert!(all.pop_front().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_modify_nth_address() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x101.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x202.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">        let new_mid: ContractAddress = 0x404.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // Modify the second entry (index 1)
</span><span class="boring">        dispatcher.modify_nth_address(1, new_mid);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(1).unwrap(), new_mid);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(2).unwrap(), a3);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_empty_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_removes_last_in_lifo_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // First pop returns last pushed (a2)
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a2);
</span><span class="boring">        // Index 1 should now be out of bounds
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(1).is_none());
</span><span class="boring">        // Index 0 remains a1
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">
</span><span class="boring">        // Second pop returns a1 and empties the list
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a1);
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">        // Further pops return None
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>To retrieve an element, you can use the indexing syntax (<code>vec[index]</code>) or the
<code>at</code>/<code>get</code> methods to obtain a storage pointer to the element at the specified
index, and then call <code>read()</code> to get the value. If the index is out of bounds,
<code>at</code> (and indexing) panics, while <code>get</code> returns <code>None</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IAddressList&lt;TState&gt; {
</span><span class="boring">    fn register_caller(ref self: TState);
</span><span class="boring">    fn get_n_th_registered_address(self: @TState, index: u64) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">    fn get_all_addresses(self: @TState) -&gt; Array&lt;ContractAddress&gt;;
</span><span class="boring">    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
</span><span class="boring">    fn pop_last_registered_address(ref self: TState) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">pub mod AddressList {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        addresses: Vec&lt;ContractAddress&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
</span><span class="boring">        fn register_caller(ref self: ContractState) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self.addresses.push(caller);
</span><span class="boring">        }
</span><span class="boring">
</span>        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.get(index).map(|ptr| ptr.read())
        }

        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses[i].read());
            }
            addresses
        }
<span class="boring">
</span><span class="boring">        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
</span><span class="boring">            self.addresses[index].write(new_address);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.pop()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IAddressListDispatcher, IAddressListDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IAddressListDispatcher {
</span><span class="boring">        let contract = declare("AddressList").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IAddressListDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_get_out_of_bounds_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_and_get_single() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let first = dispatcher.get_n_th_registered_address(0).unwrap();
</span><span class="boring">        assert_eq!(first, user);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_multiple_and_get_all_in_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0xaaa.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0xbbb.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0xccc.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let mut all = dispatcher.get_all_addresses();
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a1);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a2);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a3);
</span><span class="boring">        assert!(all.pop_front().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_modify_nth_address() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x101.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x202.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">        let new_mid: ContractAddress = 0x404.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // Modify the second entry (index 1)
</span><span class="boring">        dispatcher.modify_nth_address(1, new_mid);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(1).unwrap(), new_mid);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(2).unwrap(), a3);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_empty_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_removes_last_in_lifo_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // First pop returns last pushed (a2)
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a2);
</span><span class="boring">        // Index 1 should now be out of bounds
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(1).is_none());
</span><span class="boring">        // Index 0 remains a1
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">
</span><span class="boring">        // Second pop returns a1 and empties the list
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a1);
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">        // Further pops return None
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>If you want to retrieve all the elements of the Vec, you can iterate over the
indices of the storage <code>Vec</code>, read the value at each index, and append it to a
memory <code>Array&lt;T&gt;</code>. Similarly, you can't store an <code>Array&lt;T&gt;</code> in storage: you
would need to iterate over the elements of the array and append them to a
storage <code>Vec&lt;T&gt;</code>.</p>
<p>At this point, you should be familiar with the concept of storage pointers and
storage paths introduced in the <a href="./ch101-01-00-contract-storage.html">"Contract Storage"</a> section
and how they are used to access storage variables through a pointer-based model.
Thus how would you modify the address stored at a specific index of a <code>Vec</code>?</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IAddressList&lt;TState&gt; {
</span><span class="boring">    fn register_caller(ref self: TState);
</span><span class="boring">    fn get_n_th_registered_address(self: @TState, index: u64) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">    fn get_all_addresses(self: @TState) -&gt; Array&lt;ContractAddress&gt;;
</span><span class="boring">    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
</span><span class="boring">    fn pop_last_registered_address(ref self: TState) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">pub mod AddressList {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        addresses: Vec&lt;ContractAddress&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
</span><span class="boring">        fn register_caller(ref self: ContractState) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self.addresses.push(caller);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_n_th_registered_address(
</span><span class="boring">            self: @ContractState, index: u64,
</span><span class="boring">        ) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.get(index).map(|ptr| ptr.read())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
</span><span class="boring">            let mut addresses = array![];
</span><span class="boring">            for i in 0..self.addresses.len() {
</span><span class="boring">                addresses.append(self.addresses[i].read());
</span><span class="boring">            }
</span><span class="boring">            addresses
</span><span class="boring">        }
</span><span class="boring">
</span>        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            self.addresses[index].write(new_address);
        }
<span class="boring">
</span><span class="boring">        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.pop()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IAddressListDispatcher, IAddressListDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IAddressListDispatcher {
</span><span class="boring">        let contract = declare("AddressList").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IAddressListDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_get_out_of_bounds_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_and_get_single() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let first = dispatcher.get_n_th_registered_address(0).unwrap();
</span><span class="boring">        assert_eq!(first, user);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_multiple_and_get_all_in_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0xaaa.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0xbbb.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0xccc.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let mut all = dispatcher.get_all_addresses();
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a1);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a2);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a3);
</span><span class="boring">        assert!(all.pop_front().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_modify_nth_address() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x101.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x202.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">        let new_mid: ContractAddress = 0x404.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // Modify the second entry (index 1)
</span><span class="boring">        dispatcher.modify_nth_address(1, new_mid);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(1).unwrap(), new_mid);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(2).unwrap(), a3);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_empty_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_removes_last_in_lifo_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // First pop returns last pushed (a2)
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a2);
</span><span class="boring">        // Index 1 should now be out of bounds
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(1).is_none());
</span><span class="boring">        // Index 0 remains a1
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">
</span><span class="boring">        // Second pop returns a1 and empties the list
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a1);
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">        // Further pops return None
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The answer is fairly simple: get a mutable pointer to the storage pointer at the
desired index, and use the <code>write</code> method to modify the value at that index.</p>
<p>You can also remove the last element of a storage <code>Vec</code> using the <code>pop</code> method.
It returns <code>Some(value)</code> if the vector is non-empty and <code>None</code> otherwise, and
updates the stored length accordingly.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IAddressList&lt;TState&gt; {
</span><span class="boring">    fn register_caller(ref self: TState);
</span><span class="boring">    fn get_n_th_registered_address(self: @TState, index: u64) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">    fn get_all_addresses(self: @TState) -&gt; Array&lt;ContractAddress&gt;;
</span><span class="boring">    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
</span><span class="boring">    fn pop_last_registered_address(ref self: TState) -&gt; Option&lt;ContractAddress&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">pub mod AddressList {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        addresses: Vec&lt;ContractAddress&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
</span><span class="boring">        fn register_caller(ref self: ContractState) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self.addresses.push(caller);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_n_th_registered_address(
</span><span class="boring">            self: @ContractState, index: u64,
</span><span class="boring">        ) -&gt; Option&lt;ContractAddress&gt; {
</span><span class="boring">            self.addresses.get(index).map(|ptr| ptr.read())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
</span><span class="boring">            let mut addresses = array![];
</span><span class="boring">            for i in 0..self.addresses.len() {
</span><span class="boring">                addresses.append(self.addresses[i].read());
</span><span class="boring">            }
</span><span class="boring">            addresses
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
</span><span class="boring">            self.addresses[index].write(new_address);
</span><span class="boring">        }
</span><span class="boring">
</span>        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.pop()
        }
<span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use snforge_std::{
</span><span class="boring">        ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">        stop_cheat_caller_address,
</span><span class="boring">    };
</span><span class="boring">    use starknet::ContractAddress;
</span><span class="boring">    use super::{IAddressListDispatcher, IAddressListDispatcherTrait};
</span><span class="boring">
</span><span class="boring">    fn deploy_contract() -&gt; IAddressListDispatcher {
</span><span class="boring">        let contract = declare("AddressList").unwrap().contract_class();
</span><span class="boring">        let (contract_address, _) = contract.deploy(@array![]).unwrap();
</span><span class="boring">        IAddressListDispatcher { contract_address }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_get_out_of_bounds_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_and_get_single() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let user: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, user);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let first = dispatcher.get_n_th_registered_address(0).unwrap();
</span><span class="boring">        assert_eq!(first, user);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_register_multiple_and_get_all_in_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0xaaa.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0xbbb.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0xccc.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        let mut all = dispatcher.get_all_addresses();
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a1);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a2);
</span><span class="boring">        assert_eq!(all.pop_front().unwrap(), a3);
</span><span class="boring">        assert!(all.pop_front().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_modify_nth_address() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x101.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x202.try_into().unwrap();
</span><span class="boring">        let a3: ContractAddress = 0x303.try_into().unwrap();
</span><span class="boring">        let new_mid: ContractAddress = 0x404.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a3);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // Modify the second entry (index 1)
</span><span class="boring">        dispatcher.modify_nth_address(1, new_mid);
</span><span class="boring">
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(1).unwrap(), new_mid);
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(2).unwrap(), a3);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_empty_returns_none() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_pop_removes_last_in_lifo_order() {
</span><span class="boring">        let dispatcher = deploy_contract();
</span><span class="boring">
</span><span class="boring">        let a1: ContractAddress = 0x111.try_into().unwrap();
</span><span class="boring">        let a2: ContractAddress = 0x222.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a1);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        start_cheat_caller_address(dispatcher.contract_address, a2);
</span><span class="boring">        dispatcher.register_caller();
</span><span class="boring">        stop_cheat_caller_address(dispatcher.contract_address);
</span><span class="boring">
</span><span class="boring">        // First pop returns last pushed (a2)
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a2);
</span><span class="boring">        // Index 1 should now be out of bounds
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(1).is_none());
</span><span class="boring">        // Index 0 remains a1
</span><span class="boring">        assert_eq!(dispatcher.get_n_th_registered_address(0).unwrap(), a1);
</span><span class="boring">
</span><span class="boring">        // Second pop returns a1 and empties the list
</span><span class="boring">        assert_eq!(dispatcher.pop_last_registered_address().unwrap(), a1);
</span><span class="boring">        assert!(dispatcher.get_n_th_registered_address(0).is_none());
</span><span class="boring">        // Further pops return None
</span><span class="boring">        assert!(dispatcher.pop_last_registered_address().is_none());
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="storage-address-computation-for-vecs"><a class="header" href="#storage-address-computation-for-vecs">Storage Address Computation for Vecs</a></h2>
<p>The address in storage of a variable stored in a <code>Vec</code> is computed according to
the following rules:</p>
<ul>
<li>The length of the <code>Vec</code> is stored at the base address, computed as
<code>sn_keccak(variable_name)</code>.</li>
<li>The elements of the <code>Vec</code> are stored in addresses computed as
<code>h(base_address, i)</code>, where <code>i</code> is the index of the element in the <code>Vec</code> and
<code>h</code> is the Pedersen hash function.</li>
</ul>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<ul>
<li>Use the <code>Vec</code> type to store collections of values in contract storage</li>
<li>Access Vecs using the <code>push</code> method to add elements, the <code>pop</code> method to
remove the last element, and the <code>at</code>/indexing or <code>get</code> methods to read
elements</li>
<li>The address of a <code>Vec</code> variable is computed using the <code>sn_keccak</code> and the
Pedersen hash functions</li>
</ul>
<p>This wraps up our tour of the Contract Storage! In the next section, we'll start
looking at the different kind of functions defined in a contract. You already
know most of them, as we used them in the previous chapters, but we'll explain
them in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-functions"><a class="header" href="#contract-functions">Contract Functions</a></h1>
<p>In this section, we are going to be looking at the different types of functions
you could encounter in Starknet smart contracts.</p>
<p>Functions can access the contract's state easily via the <code>self: ContractState</code>
object, which abstracts away the complexity of underlying system calls
(<code>storage_read_syscall</code> and <code>storage_write_syscall</code>). The compiler provides two
modifiers: <code>ref</code> and <code>@</code> to decorate <code>self</code>, which intends to distinguish view
and external functions.</p>
<p>Let's consider the <code>NameRegistry</code> contract in Listing
15-4 that we'll be using throughout this chapter:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry&lt;TContractState&gt; {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
}

#[starknet::contract]
mod NameRegistry {
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        names: Map&lt;ContractAddress, felt252&gt;,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        self.total_names.__base_address__
    }
}
</code></pre>
<p>15-4: Our reference contract for this chapter</span></p>
<h2 id="1-constructors"><a class="header" href="#1-constructors">1. Constructors</a></h2>
<p>Constructors are a special type of function that only runs once when deploying a
contract, and can be used to initialize the state of a contract.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span>    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }
<span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>Some important rules to note:</p>
<ol>
<li>A contract can't have more than one constructor.</li>
<li>The constructor function must be named <code>constructor</code>, and must be annotated
with the <code>#[constructor]</code> attribute.</li>
</ol>
<p>The <code>constructor</code> function might take arguments, which are passed when deploying
the contract. In our example, we pass some value corresponding to a <code>Person</code>
type as argument in order to store the <code>owner</code> information (address and name) in
the contract.</p>
<p>Note that the <code>constructor</code> function <strong>must</strong> take <code>self</code> as a first argument,
corresponding to the state of the contract, generally passed by reference with
the <code>ref</code> keyword to be able to modify the contract's state. We will explain
<code>self</code> and its type shortly.</p>
<h2 id="2-public-functions"><a class="header" href="#2-public-functions">2. Public Functions</a></h2>
<p>As stated previously, public functions are accessible from outside of the
contract. They are usually defined inside an implementation block annotated with
the <code>#[abi(embed_v0)]</code> attribute, but might also be defined independently under
the <code>#[external(v0)]</code> attribute.</p>
<p>The <code>#[abi(embed_v0)]</code> attribute means that all functions embedded inside it are
implementations of the Starknet interface of the contract, and therefore
potential entry points.</p>
<p>Annotating an impl block with the <code>#[abi(embed_v0)]</code> attribute only affects the
visibility (i.e., public vs private/internal) of the functions it contains, but
it doesn't inform us on the ability of these functions to modify the state of
the contract.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span>    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
    }
<span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Similarly to the <code>constructor</code> function, all public functions, either
standalone functions annotated with the <code>#[external(v0)]</code> or functions within
an impl block annotated with the <code>#[abi(embed_v0)]</code> attribute, <strong>must</strong> take
<code>self</code> as a first argument. This is not the case for private functions.</p>
</blockquote>
<h3 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h3>
<p>External functions are <em>public</em> functions where the <code>self: ContractState</code>
argument is passed by reference with the <code>ref</code> keyword, which exposes both the
<code>read</code> and <code>write</code> access to storage variables. This allows modifying the state
of the contract via <code>self</code> directly.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span>        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }
<span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h3 id="view-functions"><a class="header" href="#view-functions">View Functions</a></h3>
<p>View functions are <em>public</em> functions where the <code>self: ContractState</code> argument
is passed as snapshot, which only allows the <code>read</code> access to storage variables,
and restricts writes to storage made via <code>self</code> by causing compilation errors.
The compiler will mark their <em>state_mutability</em> to <code>view</code>, preventing any state
modification through <code>self</code> directly.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span>        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            self.names.entry(address).read()
        }
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h3 id="state-mutability-of-public-functions"><a class="header" href="#state-mutability-of-public-functions">State Mutability of Public Functions</a></h3>
<p>However, as you may have noticed, passing <code>self</code> as a snapshot only restricts
the storage write access via <code>self</code> at compile time. It does not prevent state
modification via direct system calls, nor calling another contract that would
modify the state.</p>
<p>The read-only property of view functions is not enforced on Starknet, and
sending a transaction targeting a view function <em>could</em> change the state.</p>
<!-- TODO: add an example of a view function that could modify the state using low-level syscalls -->
<p>In conclusion, even though external and view functions are distinguished by the
Cairo compiler, <strong>all public functions</strong> can be called through an invoke
transaction and can potentially modify the Starknet state. Moreover, all public
functions can be called with the <code>starknet_call</code> RPC method, which will not
create a transaction and hence will not change the state.</p>
<blockquote>
<p><strong>Warning:</strong> This is different from the EVM where a <code>staticcall</code> opcode is
provided, which prevents storage modifications in the current context and
subcontexts. Hence developers <strong>should not</strong> have the assumption that calling
a view function on another contract cannot modify the state.</p>
</blockquote>
<h3 id="standalone-public-functions"><a class="header" href="#standalone-public-functions">Standalone Public Functions</a></h3>
<p>It is also possible to define public functions outside of an implementation of a
trait, using the <code>#[external(v0)]</code> attribute. Doing this will automatically
generate an entry in the contract ABI, allowing these standalone public
functions to be callable by anyone from outside. These functions can also be
called from within the contract just like any function in Starknet contracts.
The first parameter must be <code>self</code>.</p>
<p>Here, we define a standalone <code>get_contract_name</code> function outside of an impl
block:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }
<span class="boring">
</span><span class="boring">    // Could be a group of functions about a same topic
</span><span class="boring">    #[generate_trait]
</span><span class="boring">    impl InternalFunctions of InternalFunctionsTrait {
</span><span class="boring">        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
</span><span class="boring">            let total_names = self.total_names.read();
</span><span class="boring">
</span><span class="boring">            self.names.entry(user).write(name);
</span><span class="boring">
</span><span class="boring">            self.total_names.write(total_names + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Free function
</span><span class="boring">    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        self.total_names.__base_address__
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<h2 id="3-private-functions"><a class="header" href="#3-private-functions">3. Private Functions</a></h2>
<p>Functions that are not defined with the <code>#[external(v0)]</code> attribute or inside a
block annotated with the <code>#[abi(embed_v0)]</code> attribute are private functions
(also called internal functions). They can only be called from within the
contract.</p>
<p>They can be grouped in a dedicated impl block (e.g., in components, to easily
import internal functions all at once in the embedding contracts) or just be
added as free functions inside the contract module. Note that these 2 methods
are equivalent. Just choose the one that makes your code more readable and easy
to use.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait INameRegistry&lt;TContractState&gt; {
</span><span class="boring">    fn store_name(ref self: TContractState, name: felt252);
</span><span class="boring">    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod NameRegistry {
</span><span class="boring">    use starknet::storage::{
</span><span class="boring">        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
</span><span class="boring">    };
</span><span class="boring">    use starknet::{ContractAddress, get_caller_address};
</span><span class="boring">
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {
</span><span class="boring">        names: Map&lt;ContractAddress, felt252&gt;,
</span><span class="boring">        total_names: u128,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, Serde, starknet::Store)]
</span><span class="boring">    pub struct Person {
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        name: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[constructor]
</span><span class="boring">    fn constructor(ref self: ContractState, owner: Person) {
</span><span class="boring">        self.names.entry(owner.address).write(owner.name);
</span><span class="boring">        self.total_names.write(1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Public functions inside an impl block
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
</span><span class="boring">        fn store_name(ref self: ContractState, name: felt252) {
</span><span class="boring">            let caller = get_caller_address();
</span><span class="boring">            self._store_name(caller, name);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
</span><span class="boring">            self.names.entry(address).read()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Standalone public function
</span><span class="boring">    #[external(v0)]
</span><span class="boring">    fn get_contract_name(self: @ContractState) -&gt; felt252 {
</span><span class="boring">        'Name Registry'
</span><span class="boring">    }
</span><span class="boring">
</span>    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        self.total_names.__base_address__
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Wait, what is this <code>#[generate_trait]</code> attribute? Where is the trait
definition for this implementation? Well, the <code>#[generate_trait]</code> attribute is
a special attribute that tells the compiler to generate a trait definition for
the implementation block. This allows you to get rid of the boilerplate code
of defining a trait with generic parameters and implementing it for the
implementation block. With this attribute, we can simply define the
implementation block directly, without any generic parameter, and use
<code>self: ContractState</code> in our functions.</p>
</blockquote>
<p>The <code>#[generate_trait]</code> attribute is mostly used to define private impl blocks.
It might also be used in addition to <code>#[abi(per_item)]</code> to define the various
entrypoints of a contract (see <a href="./ch101-02-contract-functions.html#abiper_item-attribute">next section</a>).</p>
<blockquote>
<p>Note: using <code>#[generate_trait]</code> in addition to the <code>#[abi(embed_v0)]</code>
attribute for a public impl block is not recommended, as it will result in a
failure to generate the corresponding ABI. Public functions should only be
defined in an impl block annotated with <code>#[generate_trait]</code> if this block is
also annotated with the <code>#[abi(per_item)]</code> attribute.</p>
</blockquote>
<h2 id="abiper_item-attribute"><a class="header" href="#abiper_item-attribute"><code>[abi(per_item)]</code> Attribute</a></h2>
<p>You can also define the entrypoint type of functions individually inside an impl
block using the<code>#[abi(per_item)]</code> attribute on top of your impl. It is often
used with the <code>#[generate_trait]</code> attribute, as it allows you to define
entrypoints without an explicit interface. In this case, the functions will not
be grouped under an impl in the ABI. Note that when using <code>#[abi(per_item)]</code>
attribute, public functions need to be annotated with the <code>#[external(v0)]</code>
attribute - otherwise, they will not be exposed and will be considered as
private functions.</p>
<p>Here is a short example:</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod ContractExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl SomeImpl of SomeTrait {
        #[constructor]
        // this is a constructor function
        fn constructor(ref self: ContractState) {}

        #[external(v0)]
        // this is a public function
        fn external_function(ref self: ContractState, arg1: felt252) {}

        #[l1_handler]
        // this is a l1_handler function
        fn handle_message(ref self: ContractState, from_address: felt252, arg: felt252) {}

        // this is an internal function
        fn internal_function(self: @ContractState) {}
    }
}
</code></pre>
<p>In the case of <code>#[abi(per_item)]</code> attribute usage without <code>#[generate_trait]</code>,
it will only be possible to include <code>constructor</code>, <code>l1-handler</code> and <code>internal</code>
functions in the trait implementation. Indeed, <code>#[abi(per_item)]</code> only works
with a trait that is not defined as a Starknet interface. Hence, it will be
mandatory to create another trait defined as interface to implement public
functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-events"><a class="header" href="#contract-events">Contract Events</a></h1>
<p>Events are a way for smart contracts to inform the outside world of any changes
that occur during their execution. They play a critical role in the integration
of smart contracts into real-world applications.</p>
<p>Technically speaking, an event is a custom data structure emitted by a smart
contract during its execution and stored in the corresponding transaction
receipt, allowing any external tool to parse and index it (most commonly, a
<a href="https://docs.starknet.io/tools/overview/">Starknet SDK</a> such as
<a href="https://starknetjs.com/docs/guides/contracts/events/">Starknet.js</a>).</p>
<h2 id="defining-events"><a class="header" href="#defining-events">Defining Events</a></h2>
<p>The events of a smart contract are defined in an enum annotated with the
attribute <code>#[event]</code>. This enum must be named <code>Event</code>.</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IEventExample&lt;TContractState&gt; {
</span><span class="boring">    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
</span><span class="boring">    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
</span><span class="boring">    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
</span><span class="boring">    fn remove_book(ref self: TContractState, id: u32);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod EventExample {
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {}
</span><span class="boring">
</span>    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }
<span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct BookAdded {
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub title: felt252,
</span><span class="boring">        #[key]
</span><span class="boring">        pub author: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub enum FieldUpdated {
</span><span class="boring">        Title: UpdatedTitleData,
</span><span class="boring">        Author: UpdatedAuthorData,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct UpdatedTitleData {
</span><span class="boring">        #[key]
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub new_title: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct UpdatedAuthorData {
</span><span class="boring">        #[key]
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub new_author: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct BookRemoved {
</span><span class="boring">        pub id: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl EventExampleImpl of super::IEventExample&lt;ContractState&gt; {
</span><span class="boring">        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
</span><span class="boring">            // ... logic to add a book in the contract storage ...
</span><span class="boring">            self.emit(BookAdded { id, title, author });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
</span><span class="boring">            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
</span><span class="boring">            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn remove_book(ref self: ContractState, id: u32) {
</span><span class="boring">            self.emit(BookRemoved { id });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>Each variant, like <code>BookAdded</code> or <code>FieldUpdated</code> represents an event that can be
emitted by the contract. The variant data represents the data associated to an
event. It can be any <code>struct</code> or <code>enum</code> that implements the <code>starknet::Event</code>
trait. This can be simply achieved by adding a <code>#[derive(starknet::Event)]</code>
attribute on top of your type definition.</p>
<p>Each event data field can be annotated with the attribute <code>#[key]</code>. Key fields
are then stored separately than data fields to be used by external tools to
easily filter events on these keys.</p>
<p>Let's look at the full event definition of this example to add, update and
remove books:</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IEventExample&lt;TContractState&gt; {
</span><span class="boring">    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
</span><span class="boring">    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
</span><span class="boring">    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
</span><span class="boring">    fn remove_book(ref self: TContractState, id: u32);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod EventExample {
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {}
</span><span class="boring">
</span>    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookAdded {
        pub id: u32,
        pub title: felt252,
        #[key]
        pub author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub enum FieldUpdated {
        Title: UpdatedTitleData,
        Author: UpdatedAuthorData,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedTitleData {
        #[key]
        pub id: u32,
        pub new_title: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedAuthorData {
        #[key]
        pub id: u32,
        pub new_author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookRemoved {
        pub id: u32,
    }
<span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl EventExampleImpl of super::IEventExample&lt;ContractState&gt; {
</span><span class="boring">        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
</span><span class="boring">            // ... logic to add a book in the contract storage ...
</span><span class="boring">            self.emit(BookAdded { id, title, author });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
</span><span class="boring">            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
</span><span class="boring">            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn remove_book(ref self: ContractState, id: u32) {
</span><span class="boring">            self.emit(BookRemoved { id });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>In this example:</p>
<ul>
<li>There are 3 events: <code>BookAdded</code>, <code>FieldUpdated</code> and <code>BookRemoved</code>,</li>
<li><code>BookAdded</code> and <code>BookRemoved</code> events use a simple <code>struct</code> to store their data
while the <code>FieldUpdated</code> event uses an <code>enum</code> of structs,</li>
<li>In the <code>BookAdded</code> event, the <code>author</code> field is a key field and will be used
outside of the smart contract to filter <code>BookAdded</code> events by <code>author</code>, while
<code>id</code> and <code>title</code> are data fields.</li>
</ul>
<blockquote>
<p>The <strong>variant</strong> and its associated data structure can be named differently,
although it's common practice to use the same name. The <strong>variant name</strong> is
used internally as the <strong>first event key</strong> to represent the name of the event
and to help filter events, while the <strong>variant data name</strong> is used in the
smart contract to <strong>build the event</strong> before it is emitted.</p>
</blockquote>
<h3 id="the-flat-attribute"><a class="header" href="#the-flat-attribute">The #[flat] attribute</a></h3>
<p>Sometimes you may have a complex event structure with some nested enums like the
<code>FieldUpdated</code> event in the previous example. In this case, you can flatten this
structure using the <code>#[flat]</code> attribute, which means that the inner variant name
is used as the event name instead of the variant name of the annotated enum. In
the previous example, because the <code>FieldUpdated</code> variant is annotated with
<code>#[flat]</code>, when you emit a <code>FieldUpdated::Title</code> event, its name will be <code>Title</code>
instead of <code>FieldUpdated</code>. If you have more than 2 nested enums, you can use the
<code>#[flat]</code> attribute on multiple levels.</p>
<h2 id="emitting-events"><a class="header" href="#emitting-events">Emitting Events</a></h2>
<p>Once you have defined your list of events, you want to emit them in your smart
contracts. This can be simply achieved by calling <code>self.emit()</code> with an event
data structure in parameter.</p>
<pre><code class="language-cairo noplayground"><span class="boring">#[starknet::interface]
</span><span class="boring">pub trait IEventExample&lt;TContractState&gt; {
</span><span class="boring">    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
</span><span class="boring">    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
</span><span class="boring">    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
</span><span class="boring">    fn remove_book(ref self: TContractState, id: u32);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::contract]
</span><span class="boring">mod EventExample {
</span><span class="boring">    #[storage]
</span><span class="boring">    struct Storage {}
</span><span class="boring">
</span><span class="boring">    #[event]
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub enum Event {
</span><span class="boring">        BookAdded: BookAdded,
</span><span class="boring">        #[flat]
</span><span class="boring">        FieldUpdated: FieldUpdated,
</span><span class="boring">        BookRemoved: BookRemoved,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct BookAdded {
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub title: felt252,
</span><span class="boring">        #[key]
</span><span class="boring">        pub author: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub enum FieldUpdated {
</span><span class="boring">        Title: UpdatedTitleData,
</span><span class="boring">        Author: UpdatedAuthorData,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct UpdatedTitleData {
</span><span class="boring">        #[key]
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub new_title: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct UpdatedAuthorData {
</span><span class="boring">        #[key]
</span><span class="boring">        pub id: u32,
</span><span class="boring">        pub new_author: felt252,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Drop, starknet::Event)]
</span><span class="boring">    pub struct BookRemoved {
</span><span class="boring">        pub id: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[abi(embed_v0)]
</span><span class="boring">    impl EventExampleImpl of super::IEventExample&lt;ContractState&gt; {
</span>        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
            // ... logic to add a book in the contract storage ...
            self.emit(BookAdded { id, title, author });
        }

        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
        }

        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
        }

        fn remove_book(ref self: ContractState, id: u32) {
            self.emit(BookRemoved { id });
        }
<span class="boring">
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>To have a better understanding of what happens under the hood, let's see two
examples of emitted events and how they are stored in the transaction receipt:</p>
<h3 id="example-1-add-a-book"><a class="header" href="#example-1-add-a-book">Example 1: Add a book</a></h3>
<p>In this example, we send a transaction invoking the <code>add_book</code> function with
<code>id</code> = 42, <code>title</code> = 'Misery' and <code>author</code> = 'S. King'.</p>
<p>If you read the "events" section of the transaction receipt, you will get
something like:</p>
<pre><code class="language-json">"events": [
    {
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
      "keys": [
        "0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc",
        "0x532e204b696e67"
      ],
      "data": [
        "0x2a",
        "0x4d6973657279"
      ]
    }
  ]
</code></pre>
<p>In this receipt:</p>
<ul>
<li><code>from_address</code> is the address of your smart contract,</li>
<li><code>keys</code> contains the key fields of the emitted <code>BookAdded</code> event, serialized in
an array of <code>felt252</code>.
<ul>
<li>The first key
<code>0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc</code> is the
selector of the event name, which is the variant name in the <code>Event</code> enum,
so <code>selector!("BookAdded")</code>,</li>
<li>The second key <code>0x532e204b696e67 = 'S. King'</code> is the <code>author</code> field of your
event as it has been defined using the <code>#[key]</code> attribute,</li>
</ul>
</li>
<li><code>data</code> contains the data fields of the emitted <code>BookAdded</code> event, serialized
in an array of <code>felt252</code>. The first item <code>0x2a = 42</code> is the <code>id</code> data field
and <code>0x4d6973657279 = 'Misery'</code> is the <code>title</code> data field.</li>
</ul>
<h3 id="example-2-update-a-book-author"><a class="header" href="#example-2-update-a-book-author">Example 2: Update a book author</a></h3>
<p>Now we want to change the author name of the book, so we send a transaction
invoking <code>change_book_author</code> with <code>id</code> = <code>42</code> and <code>new_author</code> = 'Stephen
King'.</p>
<p>This <code>change_book_author</code> call emits a <code>FieldUpdated</code> event with the event data
<code>FieldUpdated::Author(UpdatedAuthorData { id: 42, title: author: 'Stephen King' })</code>.
If you read the "events" section of the transaction receipt, you will get
something like:</p>
<pre><code class="language-json">"events": [
    {
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
      "keys": [
        "0x1b90a4a3fc9e1658a4afcd28ad839182217a69668000c6104560d6db882b0e1",
        "0x2a"
      ],
      "data": [
        "0x5374657068656e204b696e67"
      ]
    }
  ]
</code></pre>
<p>As the <code>FieldUpdated</code> variant in <code>Event</code> enum has been annotated with the
<code>#[flat]</code> attribute, this is the inner variant <code>Author</code> that is used as event
name, instead of <code>FieldUpdated</code>. So:</p>
<ul>
<li>the first key is <code>selector!("Author")</code>,</li>
<li>the second key is the <code>id</code> field, annotated with <code>#[key]</code>,</li>
<li>the data field is <code>0x5374657068656e204b696e67 = 'Stephen King'</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-starknet-contracts"><a class="header" href="#interacting-with-starknet-contracts">Interacting with Starknet Contracts</a></h1>
<p>A smart contract cannot execute itself without an external trigger. It needs to
be called by an external entity, such as a user or another smart contract. The
possibility for smart contracts to interact with each other enables the creation
of sophisticated applications, where the scope of each contract is restricted to
a specific functionality.</p>
<p>This chapter sheds light on how to interact with smart contracts and make them
interact with each other. Specifically, you'll learn what the <em>Application
Binary Interface (ABI)</em> is, how to call a smart contract, and how to make
contracts communicate with each other. You will also learn how to properly use
classes as <em>libraries</em>, and when to use them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-class-abi"><a class="header" href="#contract-class-abi">Contract Class ABI</a></h1>
<p>The Contract Class <em>Application Binary Interface (ABI)</em> is the high-level
specification of the interface of a contract. It describes the functions that
can be called, their expected parameters and return values, along with the types
of these parameters and return values. It allows external sources, both from
outside the blockchain and other contracts, to communicate with the contract, by
encoding and decoding data according to the contract's interface.</p>
<p>Sources outside the blockchain typically use a JSON representation of the ABI to
interact with the contract. This JSON representation is generated from the
contract class, and contains an array of items that are either types, functions,
or events.</p>
<p>Contracts, on the other hand, use the ABI of another contract directly in Cairo
through the <em>dispatcher</em> pattern, which is a specific type that implements
methods to call the functions of another contract. These methods are
auto-generated, and contain the entire logic required to encode and decode the
data to be sent to the contract.</p>
<p>When you interact with a smart contract using a block explorer like
<a href="https://voyager.online/">Voyager</a> or <a href="https://starkscan.co/">Starkscan</a>, the JSON ABI is used to properly
encode the data you send to the contract and decode the data it returns.</p>
<h2 id="entrypoints"><a class="header" href="#entrypoints">Entrypoints</a></h2>
<p>All the functions exposed in the ABI of a contract are called <em>entrypoints</em>. An
entrypoint is a function that can be called from outside the contract class.</p>
<p>There are 3 different types of entrypoints in a Starknet contract:</p>
<ul>
<li><a href="./ch101-02-contract-functions.html#2-public-functions">Public functions</a>, the most common entrypoints, exposed
either as <code>view</code> or <code>external</code> depending on their state mutability.</li>
</ul>
<blockquote>
<p>Note: An entrypoint can be marked as <code>view</code>, but might still modify the
contract's state when invoked along with a transaction, if the contract uses
low-level calls whose immutability is not enforced by the compiler.</p>
</blockquote>
<ul>
<li>
<p>An optional unique <a href="./ch101-02-contract-functions.html#1-constructors"><em>constructor</em></a>, which is a specific
entrypoint that will be called only once during the deployment of the
contract.</p>
</li>
<li>
<p>L1-Handlers, functions that can only be triggered by the sequencer after
receiving a <a href="./ch103-04-L1-L2-messaging.html">message</a> from the L1 network whose payload
contains an instruction to call a contract.</p>
</li>
</ul>
<p>A function entrypoint is represented by a <em>selector</em> and a <code>function_idx</code> in a
Cairo contract class.</p>
<h2 id="function-selector"><a class="header" href="#function-selector">Function Selector</a></h2>
<p>While functions are defined with a name, entrypoints are identified by their
<em>selector</em>. The selector is a unique identifier derived from the function name,
and is simply computed as <code>sn_keccak(function_name)</code>. As overloading a function
with different parameters is not possible in Cairo, the hash of the function
name is sufficient to uniquely identify the function to be called.</p>
<p>While this process is often abstracted by libraries and when using dispatchers,
know that it's possible to call a function directly by providing its selector,
for example when using a low-level system call like
<code>starknet::call_contract_syscall</code> or when interacting with an RPC.</p>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<p>Smart contracts are written in a high-level language like Cairo, using strong
types to inform us about the data manipulated. However, the code executed on the
blockchain is compiled into a sequence of low-level CASM instructions. The base
data type in Starknet is <code>felt252</code>, and that's the only data manipulated at the
CASM level. As such, all data must be serialized into <code>felt252</code> before being
sent to the contract. The ABI specifies how types can be encoded into a sequence
of <code>felt252</code>, and decoded back into their original form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-another-contract"><a class="header" href="#interacting-with-another-contract">Interacting with Another Contract</a></h1>
<p>In the previous section, we introduced the dispatcher pattern for contract
interactions. This chapter will explore this pattern in depth and demonstrate
how to use it.</p>
<p>The dispatcher pattern allows us to call functions on another contract by using
a struct that wraps the contract address and implements the dispatcher trait
generated by the compiler from the contract class ABI. This leverages Cairo's
trait system to provide a clean and type-safe way to interact with other
contracts.</p>
<p>When a <a href="./ch100-00-introduction-to-smart-contracts.html#the-interface-the-contracts-blueprint">contract interface</a> is defined, the compiler automatically
generates and exports multiple dispatchers. For instance, for an <code>IERC20</code>
interface, the compiler will generate the following dispatchers:</p>
<ul>
<li><em>Contract Dispatchers</em>: <code>IERC20Dispatcher</code> and <code>IERC20SafeDispatcher</code></li>
<li><em>Library Dispatchers</em>: <code>IERC20LibraryDispatcher</code> and
<code>IERC20SafeLibraryDispatcher</code></li>
</ul>
<p>These dispatchers serve different purposes:</p>
<ul>
<li>Contract dispatchers wrap a contract address and are used to call functions on
other contracts.</li>
<li>Library dispatchers wrap a class hash and are used to call functions on
classes. Library dispatchers will be discussed in the next chapter,
<a href="./ch102-03-executing-code-from-another-class.html">"Executing code from another class"</a>.</li>
<li><em>'Safe'</em> dispatchers allow the caller to handle potential errors during the
execution of the call.</li>
</ul>
<p>Under the hood, these dispatchers use the low-level
<a href="./appendix-08-system-calls.html"><code>contract_call_syscall</code></a>, which allows us to call functions on other
contracts by passing the contract address, the function selector, and the
function arguments. The dispatcher abstracts away the complexity of this
syscall, providing a clean and type-safe way to interact with other contracts.</p>
<p>To effectively break down the concepts involved, we will use the <code>ERC20</code>
interface as an illustration.</p>
<h2 id="the-dispatcher-pattern"><a class="header" href="#the-dispatcher-pattern">The Dispatcher Pattern</a></h2>
<p>We mentioned that the compiler would automatically generate the dispatcher
struct and the dispatcher trait for a given interface. Listing
16-1 shows an example of the generated items for
an <code>IERC20</code> interface that exposes a <code>name</code> view function and a <code>transfer</code>
external function:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

trait IERC20DispatcherTrait&lt;T&gt; {
    fn name(self: T) -&gt; felt252;
    fn transfer(self: T, recipient: ContractAddress, amount: u256);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IERC20Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IERC20DispatcherImpl of IERC20DispatcherTrait&lt;IERC20Dispatcher&gt; {
    fn name(self: IERC20Dispatcher) -&gt; felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address, selector!("name"), core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
            __dispatcher_return_data__,
        );
        core::option::OptionTrait::expect(
            core::serde::Serde::&lt;felt252&gt;::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
    fn transfer(self: IERC20Dispatcher, recipient: ContractAddress, amount: u256) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::&lt;ContractAddress&gt;::serialize(@recipient, ref __calldata__);
        core::serde::Serde::&lt;u256&gt;::serialize(@amount, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("transfer"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
            __dispatcher_return_data__,
        );
        ()
    }
}
</code></pre>
<p>16-1: A simplified example of the
<code>IERC20Dispatcher</code> and its associated trait and impl</span></p>
<p>As you can see, the contract dispatcher is a simple struct that wraps a contract
address and implements the <code>IERC20DispatcherTrait</code> generated by the compiler.
For each function, the implementation of the trait will contain the following
elements:</p>
<ul>
<li>A serialization of the function arguments into a <code>felt252</code> array,
<code>__calldata__</code>.</li>
<li>A low-level contract call using <code>contract_call_syscall</code> with the contract
address, the function selector, and the <code>__calldata__</code> array.</li>
<li>A deserialization of the returned value into the expected return type.</li>
</ul>
<h2 id="calling-contracts-using-the-contract-dispatcher"><a class="header" href="#calling-contracts-using-the-contract-dispatcher">Calling Contracts Using the Contract Dispatcher</a></h2>
<p>To illustrate the use of the contract dispatcher, let's create a simple contract
that interacts with an ERC20 contract. This wrapper contract will allow us to
call the <code>name</code> and <code>transfer_from</code> functions on the ERC20 contract, as shown in
Listing 16-2:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait IERC20&lt;TContractState&gt; {
</span><span class="boring">    fn name(self: @TContractState) -&gt; felt252;
</span><span class="boring">
</span><span class="boring">    fn symbol(self: @TContractState) -&gt; felt252;
</span><span class="boring">
</span><span class="boring">    fn decimals(self: @TContractState) -&gt; u8;
</span><span class="boring">
</span><span class="boring">    fn total_supply(self: @TContractState) -&gt; u256;
</span><span class="boring">
</span><span class="boring">    fn balance_of(self: @TContractState, account: ContractAddress) -&gt; u256;
</span><span class="boring">
</span><span class="boring">    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -&gt; u256;
</span><span class="boring">
</span><span class="boring">    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    fn transfer_from(
</span><span class="boring">        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256,
</span><span class="boring">    ) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[starknet::interface]
</span><span class="boring">trait ITokenWrapper&lt;TContractState&gt; {
</span><span class="boring">    fn token_name(self: @TContractState, contract_address: ContractAddress) -&gt; felt252;
</span><span class="boring">
</span><span class="boring">    fn transfer_token(
</span><span class="boring">        ref self: TContractState,
</span><span class="boring">        address: ContractAddress,
</span><span class="boring">        recipient: ContractAddress,
</span><span class="boring">        amount: u256,
</span><span class="boring">    ) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>//**** Specify interface here ****//
#[starknet::contract]
mod TokenWrapper {
    use starknet::{ContractAddress, get_caller_address};
    use super::ITokenWrapper;
    use super::{IERC20Dispatcher, IERC20DispatcherTrait};

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl TokenWrapper of ITokenWrapper&lt;ContractState&gt; {
        fn token_name(self: @ContractState, contract_address: ContractAddress) -&gt; felt252 {
            IERC20Dispatcher { contract_address }.name()
        }

        fn transfer_token(
            ref self: ContractState,
            address: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) -&gt; bool {
            let erc20_dispatcher = IERC20Dispatcher { contract_address: address };
            erc20_dispatcher.transfer_from(get_caller_address(), recipient, amount)
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests;
</span><span class="boring">
</span></code></pre>
<p>16-2: A sample contract which uses the dispatcher
pattern to call another contract</span></p>
<p>In this contract, we import the <code>IERC20Dispatcher</code> struct and the
<code>IERC20DispatcherTrait</code> trait. We then wrap the address of the ERC20 contract in
an instance of the <code>IERC20Dispatcher</code> struct. This allows us to call the <code>name</code>
and <code>transfer</code> functions on the ERC20 contract.</p>
<p>Calling <code>transfer_token</code> external function will modify the state of the contract
deployed at <code>contract_address</code>.</p>
<h2 id="handling-errors-with-safe-dispatchers"><a class="header" href="#handling-errors-with-safe-dispatchers">Handling Errors with Safe Dispatchers</a></h2>
<p>As mentioned earlier, 'Safe' dispatchers, like <code>IERC20SafeDispatcher</code>, allow the
calling contract to gracefully handle potential errors that occur during the
execution of the called function.</p>
<p>When a function called via a safe dispatcher panics, the execution returns to
the caller contract, and the safe dispatcher returns a <code>Result::Err</code> containing
the panic reason. This allows developers to implement custom error handling
logic within their contracts.</p>
<p>Consider the following example using a hypothetical <code>IFailableContract</code>
interface:</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
pub trait IFailableContract&lt;TState&gt; {
    fn can_fail(self: @TState) -&gt; u32;
}

#[feature("safe_dispatcher")]
fn interact_with_failable_contract() -&gt; u32 {
    let contract_address = 0x123.try_into().unwrap();
    // Use the Safe Dispatcher
    let faillable_dispatcher = IFailableContractSafeDispatcher { contract_address };
    let response: Result&lt;u32, Array&lt;felt252&gt;&gt; = faillable_dispatcher.can_fail();

    // Match the result to handle success or failure
    match response {
        Result::Ok(x) =&gt; x, // Return the value on success
        Result::Err(_panic_reason) =&gt; {
            // Handle the error, e.g., log it or return a default value
            // The panic_reason is an array of felts detailing the error
            0 // Return 0 in case of failure
        },
    }
}
</code></pre>
<p>16-3: Handling errors using a Safe Dispatcher</span></p>
<p>In this code, we first obtain an instance of <code>IFailableContractSafeDispatcher</code>
for the target contract address. Calling the <code>can_fail()</code> function using this
safe dispatcher returns a <code>Result&lt;u32, Array&lt;felt252&gt;&gt;</code>, which encapsulates
either the successful <code>u32</code> result or the failure information. We can then
properly handle this result, as seen in <a href="./ch09-00-error-handling.html">Chapter 9: Error
Handling</a>.</p>
<blockquote>
<p>It's important to note that some scenarios still lead to an immediate
transaction revert, meaning the error cannot be caught by the caller using a
safe dispatcher. These include:</p>
<ul>
<li>Failure in a Cairo Zero contract call.</li>
<li>Library call with a non-existent class hash.</li>
<li>Contract call to a non-existent contract address.</li>
<li>Failure within the <code>deploy</code> syscall (e.g., panic in the constructor,
deploying to an existing address).</li>
<li>Using the <code>deploy</code> syscall with a non-existent class hash.</li>
<li>Using the <code>replace_class</code> syscall with a non-existent class hash.</li>
</ul>
<p>These cases are expected to be handled in future Starknet versions.</p>
</blockquote>
<h2 id="calling-contracts-using-low-level-calls"><a class="header" href="#calling-contracts-using-low-level-calls">Calling Contracts using Low-Level Calls</a></h2>
<p>Another way to call other contracts is to directly use the
<code>call_contract_syscall</code>. While less convenient than using the dispatcher
pattern, this syscall provides more control over the serialization and
deserialization process and allows for more customized error handling.</p>
<p>Listing 16-4 shows an example demonstrating how to call the
<code>transfer_from</code> function of an <code>ERC20</code> contract with a low-level
<code>call_contract_sycall</code> syscall:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
trait ITokenWrapper&lt;TContractState&gt; {
    fn transfer_token(
        ref self: TContractState,
        address: ContractAddress,
        recipient: ContractAddress,
        amount: u256,
    ) -&gt; bool;
}

#[starknet::contract]
mod TokenWrapper {
    use starknet::{ContractAddress, SyscallResultTrait, get_caller_address, syscalls};
    use super::ITokenWrapper;

    #[storage]
    struct Storage {}

    impl TokenWrapper of ITokenWrapper&lt;ContractState&gt; {
        fn transfer_token(
            ref self: ContractState,
            address: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) -&gt; bool {
            let mut call_data: Array&lt;felt252&gt; = array![];
            Serde::serialize(@get_caller_address(), ref call_data);
            Serde::serialize(@recipient, ref call_data);
            Serde::serialize(@amount, ref call_data);

            let mut res = syscalls::call_contract_syscall(
                address, selector!("transfer_from"), call_data.span(),
            )
                .unwrap_syscall();

            Serde::&lt;bool&gt;::deserialize(ref res).unwrap()
        }
    }
}
</code></pre>
<p>contract using <code>call_contract_sycall</code> syscall</span></p>
<p>To use this syscall, we passed in the contract address, the selector of the
function we want to call and the call arguments. The call arguments must be
provided as an array of arguments, serialized to a <code>Span&lt;felt252&gt;</code>. To serialize
the arguments, we can simply use the <code>Serde</code> trait, provided that the types
being serialized implement this trait. The call returns an array of serialized
values, which we'll need to deserialize ourselves!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executing-code-from-another-class"><a class="header" href="#executing-code-from-another-class">Executing Code from Another Class</a></h1>
<p>In previous chapters, we explored how to call external <em>contracts</em> to execute
their logic and update their state. But what if we want to execute code from
another class without updating the state of another contract? Starknet makes
this possible with <em>library calls</em>, which allow a contract to execute the logic
of another class in its own context, updating its own state.</p>
<h2 id="library-calls"><a class="header" href="#library-calls">Library calls</a></h2>
<p>The key differences between <em>contract calls</em> and <em>library calls</em> lie in the
execution context of the logic defined in the class. While contract calls are
used to call functions from deployed <strong>contracts</strong>, library calls are used to
call stateless <strong>classes</strong> in the context of the caller.</p>
<p>To illustrate this, let's consider two contracts <em>A</em> and <em>B</em>.</p>
<p>When A performs a <em>contract call</em> to the <strong>contract</strong> B, the execution context
of the logic defined in B is that of B. As such, the value returned by
<code>get_caller_address()</code> in B will return the address of A,
<code>get_contract_address()</code> in B will return the address of B, and any storage
updates in B will update the storage of B.</p>
<p>However, when A uses a <em>library call</em> to call the <strong>class</strong> of B, the execution
context of the logic defined in B is that of A. This means that the value
returned by <code>get_caller_address()</code> in B will be the address of the caller of A,
<code>get_contract_address()</code> in B's class will return the address of A, and updating
a storage variable in B's class will update the storage of A.</p>
<p>Library calls can be performed using the dispatcher pattern presented in the
previous chapter, only with a class hash instead of a contract address.</p>
<p>Listing 16-5 describes the library dispatcher and
its associated <code>IERC20DispatcherTrait</code> trait and impl using the same <code>IERC20</code>
example:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

trait IERC20DispatcherTrait&lt;T&gt; {
    fn name(self: T) -&gt; felt252;
    fn transfer(self: T, recipient: ContractAddress, amount: u256);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IERC20LibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait&lt;IERC20LibraryDispatcher&gt; {
    fn name(
        self: IERC20LibraryDispatcher,
    ) -&gt; felt252 { // starknet::syscalls::library_call_syscall  is called in here
    }
    fn transfer(
        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: u256,
    ) { // starknet::syscalls::library_call_syscall  is called in here
    }
}
</code></pre>
<p>16-5: A simplified example of the
<code>IERC20DLibraryDispatcher</code> and its associated trait and impl</span></p>
<p>One notable difference with the contract dispatcher is that the library
dispatcher uses <code>library_call_syscall</code> instead of <code>call_contract_syscall</code>.
Otherwise, the process is similar.</p>
<p>Let's see how to use library calls to execute the logic of another class in the
context of the current contract.</p>
<h2 id="using-the-library-dispatcher"><a class="header" href="#using-the-library-dispatcher">Using the Library Dispatcher</a></h2>
<p>Listing 16-6 defines two contracts: <code>ValueStoreLogic</code>,
which defines the logic of our example, and <code>ValueStoreExecutor</code>, which simply
executes the logic of <code>ValueStoreLogic</code>'s class.</p>
<p>We first need to import the <code>IValueStoreDispatcherTrait</code> and
<code>IValueStoreLibraryDispatcher</code> which were generated from our interface by the
compiler. Then, we can create an instance of <code>IValueStoreLibraryDispatcher</code>,
passing in the <code>class_hash</code> of the class we want to make library calls to. From
there, we can call the functions defined in that class, executing its logic in
the context of our contract.</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait IValueStore&lt;TContractState&gt; {
    fn set_value(ref self: TContractState, value: u128);
    fn get_value(self: @TContractState) -&gt; u128;
}

#[starknet::contract]
mod ValueStoreLogic {
    use starknet::ContractAddress;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        value: u128,
    }

    #[abi(embed_v0)]
    impl ValueStore of super::IValueStore&lt;ContractState&gt; {
        fn set_value(ref self: ContractState, value: u128) {
            self.value.write(value);
        }

        fn get_value(self: @ContractState) -&gt; u128 {
            self.value.read()
        }
    }
}

#[starknet::contract]
mod ValueStoreExecutor {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ClassHash, ContractAddress};
    use super::{IValueStoreDispatcherTrait, IValueStoreLibraryDispatcher};

    #[storage]
    struct Storage {
        logic_library: ClassHash,
        value: u128,
    }

    #[constructor]
    fn constructor(ref self: ContractState, logic_library: ClassHash) {
        self.logic_library.write(logic_library);
    }

    #[abi(embed_v0)]
    impl ValueStoreExecutor of super::IValueStore&lt;ContractState&gt; {
        fn set_value(ref self: ContractState, value: u128) {
            IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }
                .set_value((value));
        }

        fn get_value(self: @ContractState) -&gt; u128 {
            IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }.get_value()
        }
    }

    #[external(v0)]
    fn get_value_local(self: @ContractState) -&gt; u128 {
        self.value.read()
    }
}
</code></pre>
<p>16-6: An example contract using a Library
Dispatcher</span></p>
<p>When we call the <code>set_value</code> function on <code>ValueStoreExecutor</code>, it will make a
library call to the <code>set_value</code> function defined in <code>ValueStoreLogic</code>. Because
we are using a library call, <code>ValueStoreExecutor</code>'s storage variable <code>value</code>
will be updated. Similarly, when we call the <code>get_value</code> function, it will make
a library call to the <code>get_value</code> function defined in <code>ValueStoreLogic</code>,
returning the value of the storage variable <code>value</code> - still in the context of
<code>ValueStoreExecutor</code>.</p>
<p>As such, both <code>get_value</code> and <code>get_value_local</code> return the same value, as they
are reading the same storage slot.</p>
<h2 id="calling-classes-using-low-level-calls"><a class="header" href="#calling-classes-using-low-level-calls">Calling Classes using Low-Level Calls</a></h2>
<p>Another way to call classes is to directly use <code>library_call_syscall</code>. While
less convenient than using the dispatcher pattern, this syscall provides more
control over the serialization and deserialization process and allows for more
customized error handling.</p>
<p>Listing 16-7 shows an example demonstrating how to use a
<code>library_call_syscall</code> to call the <code>set_value</code> function of <code>ValueStore</code>
contract:</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod ValueStore {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ClassHash, SyscallResultTrait, syscalls};

    #[storage]
    struct Storage {
        logic_library: ClassHash,
        value: u128,
    }

    #[constructor]
    fn constructor(ref self: ContractState, logic_library: ClassHash) {
        self.logic_library.write(logic_library);
    }

    #[external(v0)]
    fn set_value(ref self: ContractState, value: u128) -&gt; bool {
        let mut call_data: Array&lt;felt252&gt; = array![];
        Serde::serialize(@value, ref call_data);

        let mut res = syscalls::library_call_syscall(
            self.logic_library.read(), selector!("set_value"), call_data.span(),
        )
            .unwrap_syscall();

        Serde::&lt;bool&gt;::deserialize(ref res).unwrap()
    }

    #[external(v0)]
    fn get_value(self: @ContractState) -&gt; u128 {
        self.value.read()
    }
}
</code></pre>
<p>16-7: A sample contract using <code>library_call_syscall</code> system
call</span></p>
<p>To use this syscall, we passed in the class hash, the selector of the function
we want to call and the call arguments. The call arguments must be provided as
an array of arguments, serialized to a <code>Span&lt;felt252&gt;</code>. To serialize the
arguments, we can simply use the <code>Serde</code> trait, provided that the types being
serialized implement this trait. The call returns an array of serialized values,
which we'll need to deserialize ourselves!</p>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>Congratulations for finishing this chapter! You have learned a lot of new
concepts:</p>
<ul>
<li>How <em>Contracts</em> differ from <em>Classes</em> and how the ABI describes them for
external sources</li>
<li>How to call functions from other contracts and classes using the <em>Dispatcher</em>
pattern</li>
<li>How to use <em>Library calls</em> to execute the logic of another class in the
context of the caller</li>
<li>The two syscalls that Starknet provides to interact with contracts and classes</li>
</ul>
<p>You now have all the required tools to develop complex applications with logic
spread across multiple contracts and classes. In the next chapter, we will
explore more advanced topics that will help you unleash the full potential of
Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-of-cairo-types"><a class="header" href="#serialization-of-cairo-types">Serialization of Cairo types</a></h1>
<p>The field element (<code>felt252</code>), which contains 252 bits, is the only actual type
in the Cairo VM, so
<a href="ch102-04-serialization-of-cairo-types.html#data-types-using-at-most-252-bits">all data types that fit in 252 bits</a> are
represented by a single felt and
<a href="ch102-04-serialization-of-cairo-types.html#data-types-using-more-than-252-bits">all data types that are larger than 252 bits</a>
are represented by a list of felts. Therefore, in order to interact with a
contract, you must know how to
<a href="ch102-04-serialization-of-cairo-types.html#serialization-of-data-types-using-more-than-252-bits">serialize any arguments that are larger than 252 bits to lists of felts</a>
so you can correctly formulate the calldata in the transaction.</p>
<blockquote>
<p>Note: For any developers that are not developing a Starknet library or SDK
developer, using either one of the existing
<a href="https://docs.starknet.io/tools/overview/">Starknet SDKs</a> or the
<a href="https://foundry-rs.github.io/starknet-foundry/starknet/calldata-transformation.html#using---arguments"><code>--argument</code> flag of Starknet Foundry's <code>sncast</code></a>
is highly recommend to greatly simply the serialization process. From <code>sncast</code>
v0.43.0, results of <code>sncast call</code> are also parsed into readable information,
demonstrated in the following example:</p>
<pre><code>sncast call \
  --contract-address=0x00e270c8396d333f88556edf143ac751240f050d907e5190525accbe275f2348 \
  --function=get_order \
  --network=sepolia
response: Order {
  position_id: PositionId { value: 1_u32 },
  base_asset_id: AssetId { value: 0x3 },
  base_amount: -10_i64,
  quote_asset_id: AssetId { value: 0x2d },
  fee_asset_id: AssetId { value: 0x4d2 },
  fee_amount: 0_u64,
  expiration: Timestamp { seconds: 12341432_u64 },
  salt: 0x0,
  name: "This is my order"
}
</code></pre>
</blockquote>
<h2 id="data-types-using-at-most-252-bits"><a class="header" href="#data-types-using-at-most-252-bits">Data types using at most 252 bits</a></h2>
<p>The following Cairo data types are using at most 252 bits:</p>
<ul>
<li><code>ContractAddress</code></li>
<li><code>EthAddress</code></li>
<li><code>StorageAddress</code></li>
<li><code>ClassHash</code></li>
<li>Unsigned integers using at most 252 bits: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>,
and <code>usize</code></li>
<li><code>bytes31</code></li>
<li><code>felt252</code></li>
<li>Signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, and <code>i128</code>
<blockquote>
<p>Note: A negative value, \( -x \), is serialized as \( P-x \), where \(
P = 2^{251} + 17*2^{192} + 1 \)</p>
</blockquote>
</li>
</ul>
<p>For these types, each value is serialized as a single-member list that contains
one <code>felt252</code> value.</p>
<h2 id="data-types-using-more-than-252-bits"><a class="header" href="#data-types-using-more-than-252-bits">Data types using more than 252 bits</a></h2>
<p>The following Cairo data types use more than 252 bits and therefore have
non-trivial serialization:</p>
<ul>
<li>Unsigned integers larger than 252 bits: <code>u256</code> and <code>u512</code></li>
<li>Arrays and spans</li>
<li>Enums</li>
<li>Structs and tuples</li>
<li>Byte arrays (which represent strings)</li>
</ul>
<h2 id="serialization-of-data-types-using-more-than-252-bits"><a class="header" href="#serialization-of-data-types-using-more-than-252-bits">Serialization of data types using more than 252 bits</a></h2>
<h3 id="serialization-of-u256"><a class="header" href="#serialization-of-u256">Serialization of <code>u256</code></a></h3>
<p>A <code>u256</code> value in Cairo is represented by two <code>felt252</code> values, as follows:</p>
<ul>
<li>The first <code>felt252</code> value contains the 128 least significant bits, usually
referred to as the low part of the original <code>u256</code> value.</li>
<li>The second <code>felt252</code> value contains the 128 most significant bits, usually
referred to as the high part of the original <code>u256</code> value.</li>
</ul>
<p>For example:</p>
<ul>
<li>
<p>A <code>u256</code> variable whose decimal value is 2 is serialized as <code>[2,0]</code>. To
understand why, examine the binary representation of 2 and split it into two
128-bit parts, as follows:</p>
<ul>
<li>128 high bits: \(0 \cdots 0 \)</li>
<li>128 low bits: \( 0 \cdots 10 \)</li>
</ul>
</li>
<li>
<p>A <code>u256</code> variable whose decimal value is \( 2^{128} \) is serialized as
<code>[0,1]</code>. To understand why, examine the binary representation of \( 2^{128}
\) and split it into two 128-bit parts, as follows:</p>
<ul>
<li>128 high bits: \( 0 \cdots 01 \)</li>
<li>128 low bits: \(0 \cdots 0 \)</li>
</ul>
</li>
<li>
<p>A <code>u256</code> variable whose decimal value is \( 2^{129}+2^{128}+20 \), is
serialized as <code>[20,3]</code>. To understand why, examine the binary representation
of the \( 2^{129}+2^{128}+20 \) and split it into two 128-bit parts, as
follows:</p>
<ul>
<li>128 high bits: \( 0 \cdots 011 \)</li>
<li>128 high bits: \( 0 \cdots 10100 \)</li>
</ul>
</li>
</ul>
<h3 id="serialization-of-u512"><a class="header" href="#serialization-of-u512">Serialization of <code>u512</code></a></h3>
<p>The <code>u512</code> type in Cairo is a struct containing four <code>felt252</code> members, each
representing a 128-bit limb of the original integer, similar to the <code>u256</code> type.</p>
<h3 id="serialization-of-arrays-and-spans"><a class="header" href="#serialization-of-arrays-and-spans">Serialization of arrays and spans</a></h3>
<p>Arrays and spans are serialized as follows:</p>
<p><code>&lt;array/span_length&gt;, &lt;first_serialized_member&gt;,..., &lt;last_serialized_member&gt;</code></p>
<p>For example, consider the following array of <code>u256</code> values:</p>
<pre><code class="language-cairo  noplayground">let POW_2_128: u256 = 0x100000000000000000000000000000000
let array: Array&lt;u256&gt; = array![10, 20, POW_2_128]
</code></pre>
<p>Each <code>u256</code> value in the array is represented by two <code>felt252</code> values. So the
array above is serialized as follows:</p>
<ol>
<li><code>3</code>: number of array members</li>
<li><code>10,0</code>: serialized first member</li>
<li><code>20,0</code>: serialized second member</li>
<li><code>0,1</code>: serialized third member</li>
</ol>
<p>Combining the above, the array is serialized as <code>[3,10,0,20,0,0,1]</code>.</p>
<h3 id="serialization-of-enums"><a class="header" href="#serialization-of-enums">Serialization of enums</a></h3>
<p>An enum is serialized as follows:</p>
<p><code>&lt;index_of_enum_variant&gt;,&lt;serialized_variant&gt;</code></p>
<p>Note that enum variants indices are 0-based, not to confuse with their storage
layout, which is 1-based, to distinguish the first variant from an uninitialized
storage slot.</p>
<p><strong>Enum serialization example #1</strong></p>
<p>Consider the following definition of an enum named <code>Week</code>:</p>
<pre><code class="language-cairo noplayground">enum Week {
    Sunday: (), // Index=0. The variant type is the unit type (0-tuple).
    Monday: u256, // Index=1. The variant type is u256.
}
</code></pre>
<p>Now consider instantiations of the <code>Week</code> enum's variants as shown in the table
below:</p>
<div class="table-wrapper"><table><thead><tr><th>Instance</th><th>Index</th><th>Type</th><th>Serialization</th></tr></thead><tbody>
<tr><td><code>Week::Sunday</code></td><td><code>0</code></td><td>unit</td><td><code>[0]</code></td></tr>
<tr><td><code>Week::Monday(5)</code></td><td><code>1</code></td><td><code>u256</code></td><td><code>[1,5,0]</code></td></tr>
</tbody></table>
</div>
<p><strong>Enum serialization example #2</strong></p>
<p>Consider the following definition of an enum named <code>MessageType</code>:</p>
<pre><code class="language-cairo noplayground">enum MessageType {
    A,
    #[default]
    B: u128,
    C
}
</code></pre>
<p>Now consider instantiations of the <code>MessageType</code> enum's variants as shown in the
table below:</p>
<div class="table-wrapper"><table><thead><tr><th>Instance</th><th>Index</th><th>Type</th><th>Serialization</th></tr></thead><tbody>
<tr><td><code>MessageType::A</code></td><td><code>1</code></td><td>unit</td><td><code>[0]</code></td></tr>
<tr><td><code>MessageType::B(6)</code></td><td><code>0</code></td><td><code>u128</code></td><td><code>[1,6]</code></td></tr>
<tr><td><code>MessageType::C</code></td><td><code>2</code></td><td>unit</td><td><code>[2]</code></td></tr>
</tbody></table>
</div>
<p>As you can see about, the <code>#[default]</code> attribute does not affect serialization.
It only affects the storage layout of <code>MessageType</code>, where the default variant
<code>B</code> will be stored as <code>0</code>.</p>
<h3 id="serialization-of-structs-and-tuples"><a class="header" href="#serialization-of-structs-and-tuples">Serialization of structs and tuples</a></h3>
<p>Structs and tuples are serialized by serializing their members one at a time.</p>
<p>A struct's members are serialized in the order in which they appear in its
definition.</p>
<p>For example, consider the following definition of the struct <code>MyStruct</code>:</p>
<pre><code class="language-cairo noplayground">struct MyStruct {
    a: u256,
    b: felt252,
    c: Array&lt;felt252&gt;
}
</code></pre>
<p>The serialization is the same for both of the following instantiations of the
struct's members:</p>
<pre><code class="language-cairo noplayground">let my_struct = MyStruct {
    a: 2, b: 5, c: [1,2,3]
};

let my_struct = MyStruct {
    b: 5, c: [1,2,3], a: 2
};
</code></pre>
<p>The serialization of <code>MyStruct</code> is determined as shown in the following table:</p>
<p>| Member       | Type                      | Serialization |
| ------------ | ------------------------- | ------------- | -------------------------------------------- |
| <code>a: 2</code>       | <code>u256</code>                    | <code>[2,0]</code>       | For information on serializing <code>u256</code> values |
| <code>b: 5</code>       | <code>felt252</code>                 | <code>5</code>           |
| <code>c: [1,2,3]</code> | <code>felt252</code> array of size 3 | <code>[3,1,2,3]</code>   |</p>
<p>Combining the above, the struct is serialized as <code>[2,0,5,3,1,2,3]</code>.</p>
<h3 id="serialization-of-byte-arrays"><a class="header" href="#serialization-of-byte-arrays">Serialization of byte arrays</a></h3>
<p>A string is represented in Cairo as a <code>ByteArray</code> type. A byte array is actually
a struct with the following members:</p>
<ul>
<li><code>data: Array&lt;felt252&gt;</code>: Contains 31-byte chunks of the byte array. Each
<code>felt252</code> value has exactly 31 bytes. If the number of bytes in the byte array
is less than 31, then this array is empty.</li>
<li><code>pending_word: felt252</code>: The bytes that remain after filling the <code>data</code> array
with full 31-byte chunks. The pending word consists of at most 30 bytes.</li>
<li><code>pending_word_len: usize</code>: The number of bytes in <code>pending_word</code>.</li>
</ul>
<p><strong>Example #1: A string shorter than 31 characters</strong></p>
<p>Consider the string <code>hello</code>, whose ASCII encoding is the 5-byte hex value
<code>0x68656c6c6f</code>. The resulting byte array is serialized as follows:</p>
<pre><code class="language-cairo noplayground">0, // Number of 31-byte words in the data array.
0x68656c6c6f, // Pending word
5 // Length of the pending word, in bytes
</code></pre>
<p><strong>Example 2: A string longer than 31 bytes</strong></p>
<p>Consider the string <code>Long string, more than 31 characters.</code>, which is
represented by the following hex values:</p>
<ul>
<li><code>0x4c6f6e6720737472696e672c206d6f7265207468616e203331206368617261</code> (31-byte
word)</li>
<li><code>0x63746572732e</code> (6-byte pending word)</li>
</ul>
<p>The resulting byte array is serialized as follows:</p>
<pre><code class="language-cairo noplayground">1, // Number of 31-byte words in the array construct.
0x4c6f6e6720737472696e672c206d6f7265207468616e203331206368617261, // 31-byte word.
0x63746572732e, // Pending word
6 // Length of the pending word, in bytes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-advanced-starknet-smart-contracts"><a class="header" href="#building-advanced-starknet-smart-contracts">Building Advanced Starknet Smart Contracts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-storage-costs"><a class="header" href="#optimizing-storage-costs">Optimizing Storage Costs</a></h1>
<p>Bit-packing is a simple concept: use as few bits as possible to store a piece of
data. When done well, it can significantly reduce the size of the data you need
to store. This is especially important in smart contracts, where storage is
expensive.</p>
<p>When writing Cairo smart contracts, it is important to optimize storage usage to
reduce gas costs. Indeed, most of the cost associated with a transaction is
related to storage updates; and each storage slot costs gas to write to. This
means that by packing multiple values into fewer slots, you can decrease the gas
cost incurred by the users of your smart contract.</p>
<h2 id="integer-structure-and-bitwise-operators"><a class="header" href="#integer-structure-and-bitwise-operators">Integer Structure and Bitwise Operators</a></h2>
<p>An integer is coded on a certain number of bits, depending on its size (For
example, a <code>u8</code> integer is coded on 8 bits).</p>
<div align="center">
    <img src="integer_in_bits.png" alt="a u8 integer in bits" width="500px"/>
<div align="center">
</div>
    <span class="caption">Representation of a u8 integer in bits</span>
</div>
<p>Intuitively, several integers can be combined into a single integer if the size
of this single integer is greater than or equal to the sum of the sizes of the
integers (For example, two <code>u8</code> and one <code>u16</code> in one <code>u32</code>).</p>
<p>But, to do that, we need some bitwise operators:</p>
<ul>
<li>multiplying or dividing an integer by a power of 2 shifts the integer value to
the left or to the right respectively</li>
</ul>
<div align="center">
    <img src="shift.png" alt="shift operators" width="500px"/>
<div align="center">
</div>
    <span class="caption">Shifting to the left or to the right an integer value</span>
</div>
<ul>
<li>applying a mask (<code>AND</code> operator) on an integer value isolates some bits of
this integer</li>
</ul>
<div align="center">
    <img src="mask.png" alt="applying a mask" width="500px"/>
<div align="center">
</div>
    <span class="caption">Isolate bits with a mask</span>
</div>
<ul>
<li>adding (<code>OR</code> operator) two integers will combine both values into a single
one.</li>
</ul>
<div align="center">
    <img src="combine.png" alt="combining two values" width="500px"/>
<div align="center">
</div>
    <span class="caption">Combining two integers</span>
</div>
<p>With these bitwise operators, let's see how to combine two <code>u8</code> integers into a
single <code>u16</code> integer (called <code>packing</code>) and reversely (called <code>unpacking</code>) in
the following example:</p>
<div align="center">
    <img src="pack.png" alt="packing and unpacking integer values" width="500px"/>
<div align="center">
</div>
    <span class="caption">Packing and unpacking integer values</span>
</div>
<h2 id="bit-packing-in-cairo"><a class="header" href="#bit-packing-in-cairo">Bit-packing in Cairo</a></h2>
<p>The storage of a Starknet smart contract is a map with 2<sup>251</sup> slots,
where each slot is a <code>felt252</code> which is initialized to 0.</p>
<p>As we saw earlier, to reduce gas costs due to storage updates, we have to use as
few bits as possible, so we have to organize stored variables by packing them.</p>
<p>For example, consider the following <code>Sizes</code> struct with 3 fields of different
types: one <code>u8</code>, one <code>u32</code> and one <code>u64</code>. The total size is 8 + 32 + 64 = 104
bits. This is less than a slot size (i.e 251 bits) so we can pack them together
to be stored into a single slot.</p>
<p>Note that, as it also fits in a <code>u128</code>, it's a good practice to use the smallest
type to pack all your variables, so here a <code>u128</code> should be used.</p>
<pre><code class="language-cairo noplayground">struct Sizes {
    tiny: u8,
    small: u32,
    medium: u64,
}
</code></pre>
<p>To pack these 3 variables into a <code>u128</code> we have to successively shift them to
the left, and finally sum them.</p>
<div align="center">
    <img src="sizes-packing.png" alt="Sizes packing" width="800px"/>
<div align="center">
</div>
    <span class="caption">Sizes packing</span>
</div>
<p>To unpack these 3 variables from a <code>u128</code> we have to successively shift them to
the right and use a mask to isolate them.</p>
<div align="center">
    <img src="sizes-unpacking.png" alt="Sizes unpacking" width="800px"/>
<div align="center">
</div>
    <span class="caption">Sizes unpacking</span>
</div>
<h2 id="the-storepacking-trait"><a class="header" href="#the-storepacking-trait">The <code>StorePacking</code> Trait</a></h2>
<p>Cairo provides the <code>StorePacking</code> trait to enable packing struct fields into
fewer storage slots. <code>StorePacking&lt;T, PackedT&gt;</code> is a generic trait taking the
type you want to pack (<code>T</code>) and the destination type (<code>PackedT</code>) as parameters.
It provides two functions to implement: <code>pack</code> and <code>unpack</code>.</p>
<p>Here is the implementation of the example of the previous chapter:</p>
<pre><code class="language-cairo noplayground">use starknet::storage_access::StorePacking;

#[derive(Drop, Serde)]
struct Sizes {
    tiny: u8,
    small: u32,
    medium: u64,
}

const TWO_POW_8: u128 = 0x100;
const TWO_POW_40: u128 = 0x10000000000;

const MASK_8: u128 = 0xff;
const MASK_32: u128 = 0xffffffff;

impl SizesStorePacking of StorePacking&lt;Sizes, u128&gt; {
    fn pack(value: Sizes) -&gt; u128 {
        value.tiny.into() + (value.small.into() * TWO_POW_8) + (value.medium.into() * TWO_POW_40)
    }

    fn unpack(value: u128) -&gt; Sizes {
        let tiny = value &amp; MASK_8;
        let small = (value / TWO_POW_8) &amp; MASK_32;
        let medium = (value / TWO_POW_40);

        Sizes {
            tiny: tiny.try_into().unwrap(),
            small: small.try_into().unwrap(),
            medium: medium.try_into().unwrap(),
        }
    }
}

#[starknet::contract]
mod SizeFactory {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::Sizes;
    use super::SizesStorePacking; //don't forget to import it!

    #[storage]
    struct Storage {
        remaining_sizes: Sizes,
    }

    #[abi(embed_v0)]
    fn update_sizes(ref self: ContractState, sizes: Sizes) {
        // This will automatically pack the
        // struct into a single u128
        self.remaining_sizes.write(sizes);
    }


    #[abi(embed_v0)]
    fn get_sizes(ref self: ContractState) -&gt; Sizes {
        // this will automatically unpack the
        // packed-representation into the Sizes struct
        self.remaining_sizes.read()
    }
}
</code></pre>
<div align="center">
    <span class="caption">Optimizing storage by implementing the `StorePacking` trait.</span>
</div>
<p>In this code snippet, you see that:</p>
<ul>
<li><code>TWO_POW_8</code> and <code>TWO_POW_40</code> are used to shift left in the <code>pack</code> function and
shift right in the <code>unpack</code>function,</li>
<li><code>MASK_8</code> and <code>MASK_32</code> are used to isolate a variable in the <code>unpack</code>
function,</li>
<li>all the variables from the storage are converted to <code>u128</code> to be able to use
bitwise operators.</li>
</ul>
<p>This technique can be used for any group of fields that fit within the bit size
of the packed storage type. For example, if you have a struct with multiple
fields whose bit sizes add up to 256 bits, you can pack them into a single
<code>u256</code> variable. If the bit sizes add up to 512 bits, you can pack them into a
single <code>u512</code> variable, and so on. You can define your own structs and logic to
pack and unpack them.</p>
<p>The rest of the work is done magically by the compiler - if a type implements
the <code>StorePacking</code> trait, then the compiler will know it can use the
<code>StoreUsingPacking</code> implementation of the <code>Store</code> trait in order to pack before
writing and unpack after reading from storage. One important detail, however, is
that the type that <code>StorePacking::pack</code> spits out also has to implement <code>Store</code>
for <code>StoreUsingPacking</code> to work. Most of the time, we will want to pack into a
felt252 or u256 - but if you want to pack into a type of your own, make sure
that this one implements the <code>Store</code> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-lego-like-building-blocks-for-smart-contracts"><a class="header" href="#components-lego-like-building-blocks-for-smart-contracts">Components: Lego-Like Building Blocks for Smart Contracts</a></h1>
<p>Developing contracts sharing a common logic and storage can be painful and
bug-prone, as this logic can hardly be reused and needs to be reimplemented in
each contract. But what if there was a way to snap in just the extra
functionality you need inside your contract, separating the core logic of your
contract from the rest?</p>
<p>Components provide exactly that. They are modular add-ons encapsulating reusable
logic, storage, and events that can be incorporated into multiple contracts.
They can be used to extend a contract's functionality, without having to
reimplement the same logic over and over again.</p>
<p>Think of components as Lego blocks. They allow you to enrich your contracts by
plugging in a module that you or someone else wrote. This module can be a simple
one, like an ownership component, or more complex like a full-fledged ERC20
token.</p>
<p>A component is a separate module that can contain storage, events, and
functions. Unlike a contract, a component cannot be declared or deployed. Its
logic will eventually be part of the contract’s bytecode it has been embedded
in.</p>
<h2 id="whats-in-a-component"><a class="header" href="#whats-in-a-component">What's in a Component?</a></h2>
<p>A component is very similar to a contract. It can contain:</p>
<ul>
<li>Storage variables</li>
<li>Events</li>
<li>External and internal functions</li>
</ul>
<p>Unlike a contract, a component cannot be deployed on its own. The component's
code becomes part of the contract it's embedded to.</p>
<h2 id="creating-components"><a class="header" href="#creating-components">Creating Components</a></h2>
<p>To create a component, first define it in its own module decorated with a
<code>#[starknet::component]</code> attribute. Within this module, you can declare a
<code> Storage</code> struct and <code>Event</code> enum, as usually done in
<a href="./ch100-00-introduction-to-smart-contracts.html#">contracts</a>.</p>
<p>The next step is to define the component interface, containing the signatures of
the functions that will allow external access to the component's logic. You can
define the interface of the component by declaring a trait with the
<code>#[starknet::interface]</code> attribute, just as you would with contracts. This
interface will be used to enable external access to the component's functions
using the <a href="./ch102-02-interacting-with-another-contract.html">dispatcher</a> pattern.</p>
<p>The actual implementation of the component's external logic is done in an <code>impl</code>
block marked as <code>#[embeddable_as(name)]</code>. Usually, this <code>impl</code> block will be an
implementation of the trait defining the interface of the component.</p>
<blockquote>
<p>Note: <code>name</code> is the name that we’ll be using in the contract to refer to the
component. It is different than the name of your impl.</p>
</blockquote>
<p>You can also define internal functions that will not be accessible externally,
by simply omitting the <code>#[embeddable_as(name)]</code> attribute above the internal
<code>impl</code> block. You will be able to use these internal functions inside the
contract you embed the component in, but not interact with it from outside, as
they're not a part of the abi of the contract.</p>
<p>Functions within these <code>impl</code> block expect arguments like
<code>ref self: ComponentState&lt;TContractState&gt;</code> (for state-modifying functions) or
<code>self: @ComponentState&lt;TContractState&gt;</code> (for view functions). This makes the
impl generic over <code>TContractState</code>, allowing us to use this component in any
contract.</p>
<h3 id="example-an-ownable-component"><a class="header" href="#example-an-ownable-component">Example: an Ownable Component</a></h3>
<blockquote>
<p>⚠️ The example shown below has not been audited and is not intended for
production use. The authors are not responsible for any damages caused by the
use of this code.</p>
</blockquote>
<p>The interface of the Ownable component, defining the methods available
externally to manage ownership of a contract, would look like this:</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait IOwnable&lt;TContractState&gt; {
    fn owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TContractState);
}
</code></pre>
<p>The component itself is defined as:</p>
<pre><code class="language-cairo noplayground">#[starknet::component]
pub mod OwnableComponent {
    use core::num::traits::Zero;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ContractAddress, get_caller_address};
    use super::Errors;

    #[storage]
    pub struct Storage {
        owner: ContractAddress,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        OwnershipTransferred: OwnershipTransferred,
    }

    #[derive(Drop, starknet::Event)]
    struct OwnershipTransferred {
        previous_owner: ContractAddress,
        new_owner: ContractAddress,
    }

    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
        fn owner(self: @ComponentState&lt;TContractState&gt;) -&gt; ContractAddress {
            self.owner.read()
        }

        fn transfer_ownership(
            ref self: ComponentState&lt;TContractState&gt;, new_owner: ContractAddress,
        ) {
            assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);
            self.assert_only_owner();
            self._transfer_ownership(new_owner);
        }

        fn renounce_ownership(ref self: ComponentState&lt;TContractState&gt;) {
            self.assert_only_owner();
            self._transfer_ownership(Zero::zero());
        }
    }

    #[generate_trait]
    pub impl InternalImpl&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of InternalTrait&lt;TContractState&gt; {
        fn initializer(ref self: ComponentState&lt;TContractState&gt;, owner: ContractAddress) {
            self._transfer_ownership(owner);
        }

        fn assert_only_owner(self: @ComponentState&lt;TContractState&gt;) {
            let owner: ContractAddress = self.owner.read();
            let caller: ContractAddress = get_caller_address();
            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);
            assert(caller == owner, Errors::NOT_OWNER);
        }

        fn _transfer_ownership(
            ref self: ComponentState&lt;TContractState&gt;, new_owner: ContractAddress,
        ) {
            let previous_owner: ContractAddress = self.owner.read();
            self.owner.write(new_owner);
            self
                .emit(
                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner },
                );
        }
    }
}
</code></pre>
<p>This syntax is actually quite similar to the syntax used for contracts. The only
differences relate to the <code>#[embeddable_as]</code> attribute above the impl and the
genericity of the impl block that we will dissect in details.</p>
<p>As you can see, our component has two <code>impl</code> blocks: one corresponding to the
implementation of the interface trait, and one containing methods that should
not be exposed externally and are only meant for internal use. Exposing the
<code>assert_only_owner</code> as part of the interface wouldn't make sense, as it's only
meant to be used internally by a contract embedding the component.</p>
<h2 id="a-closer-look-at-the-impl-block"><a class="header" href="#a-closer-look-at-the-impl-block">A Closer Look at the <code>impl</code> Block</a></h2>
<pre><code class="language-cairo noplayground">    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p>The <code>#[embeddable_as]</code> attribute is used to mark the impl as embeddable inside a
contract. It allows us to specify the name of the impl that will be used in the
contract to refer to this component. In this case, the component will be
referred to as <code>OwnableImpl</code> in contracts embedding it.</p>
<p>The implementation itself is generic over <code>ComponentState&lt;TContractState&gt;</code>, with
the added restriction that <code>TContractState</code> must implement the <code>HasComponent&lt;T&gt;</code>
trait. This allows us to use the component in any contract, as long as the
contract implements the <code>HasComponent</code> trait. Understanding this mechanism in
details is not required to use components, but if you're curious about the inner
workings, you can read more in the <a href="./ch103-02-01-under-the-hood.html">"Components Under the
Hood"</a> section.</p>
<p>One of the major differences from a regular smart contract is that access to
storage and events is done via the generic <code>ComponentState&lt;TContractState&gt;</code> type
and not <code>ContractState</code>. Note that while the type is different, accessing
storage or emitting events is done similarly via <code>self.storage_var_name.read()</code>
or <code>self.emit(...).</code></p>
<blockquote>
<p>Note: To avoid confusion, follow OpenZeppelin’s pattern: keep the <code>Impl</code>
suffix in the embeddable name and in the contract’s impl alias (e.g.,
<code>OwnableImpl</code>), while the local component impl is named after the trait
without the suffix (e.g., <code>impl Ownable&lt;...&gt;</code>).</p>
</blockquote>
<h2 id="migrating-a-contract-to-a-component"><a class="header" href="#migrating-a-contract-to-a-component">Migrating a Contract to a Component</a></h2>
<p>Since both contracts and components share a lot of similarities, it's actually
very easy to migrate from a contract to a component. The only changes required
are:</p>
<ul>
<li>Adding the <code>#[starknet::component]</code> attribute to the module.</li>
<li>Adding the <code>#[embeddable_as(name)]</code> attribute to the <code>impl</code> block that will be
embedded in another contract.</li>
<li>Adding generic parameters to the <code>impl</code> block:
<ul>
<li>Adding <code>TContractState</code> as a generic parameter.</li>
<li>Adding <code>+HasComponent&lt;TContractState&gt;</code> as an impl restriction.</li>
</ul>
</li>
<li>Changing the type of the <code>self</code> argument in the functions inside the <code>impl</code>
block to <code>ComponentState&lt;TContractState&gt;</code> instead of <code>ContractState</code>.</li>
</ul>
<p>For traits that do not have an explicit definition and are generated using
<code>#[generate_trait]</code>, the logic is the same - but the trait is generic over
<code>TContractState</code> instead of <code>ComponentState&lt;TContractState&gt;</code>, as demonstrated in
the example with the <code>InternalTrait</code>.</p>
<h2 id="using-components-inside-a-contract"><a class="header" href="#using-components-inside-a-contract">Using Components Inside a Contract</a></h2>
<p>The major strength of components is how it allows reusing already built
primitives inside your contracts with a restricted amount of boilerplate. To
integrate a component into your contract, you need to:</p>
<ol>
<li>
<p>Declare it with the <code>component!()</code> macro, specifying</p>
<ol>
<li>The path to the component <code>path::to::component</code>.</li>
<li>The name of the variable in your contract's storage referring to this
component's storage (e.g. <code>ownable</code>).</li>
<li>The name of the variant in your contract's event enum referring to this
component's events (e.g. <code>OwnableEvent</code>).</li>
</ol>
</li>
<li>
<p>Add the path to the component's storage and events to the contract's
<code>Storage</code> and <code>Event</code>. They must match the names provided in step 1 (e.g.
<code>ownable: ownable_component::Storage</code> and
<code>OwnableEvent: ownable_component::Event</code>).</p>
<p>The storage variable <strong>MUST</strong> be annotated with the <code>#[substorage(v0)]</code>
attribute.</p>
</li>
<li>
<p>Embed the component's logic defined inside your contract, by instantiating
the component's generic impl with a concrete <code>ContractState</code> using an impl
alias. This alias must be annotated with <code>#[abi(embed_v0)]</code> to externally
expose the component's functions.</p>
<p>As you can see, the InternalImpl is not marked with <code>#[abi(embed_v0)]</code>.
Indeed, we don't want to expose externally the functions defined in this
impl. However, we might still want to access them internally.</p>
</li>
</ol>
<p>For example, to embed the <code>Ownable</code> component defined above, we would do the
following:</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod OwnableCounter {
    use listing_01_ownable::component::OwnableComponent;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;

    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        counter: u128,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
    }


    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        OwnableEvent: OwnableComponent::Event,
    }


    #[abi(embed_v0)]
    fn foo(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.counter.write(self.counter.read() + 1);
    }
}
</code></pre>
<p>The component's logic is now seamlessly part of the contract! We can interact
with the components functions externally by calling them using the
<code>IOwnableDispatcher</code> instantiated with the contract's address.</p>
<pre><code class="language-cairo">#[starknet::interface]
trait IOwnable&lt;TContractState&gt; {
    fn owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TContractState);
}
</code></pre>
<h2 id="stacking-components-for-maximum-composability"><a class="header" href="#stacking-components-for-maximum-composability">Stacking Components for Maximum Composability</a></h2>
<p>The composability of components really shines when combining multiple of them
together. Each adds its features onto the contract. You can rely on
<a href="https://github.com/OpenZeppelin/cairo-contracts">Openzeppelin's</a> implementation of components to
quickly plug-in all the common functionalities you need a contract to have.</p>
<p>Developers can focus on their core contract logic while relying on battle-tested
and audited components for everything else.</p>
<p>Components can even <a href="./ch103-02-02-component-dependencies.html">depend</a> on other components by
restricting the <code>TContractstate</code> they're generic on to implement the trait of
another component. Before we dive into this mechanism, let's first look at <a href="./ch103-02-01-under-the-hood.html">how
components work under the hood</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-under-the-hood"><a class="header" href="#components-under-the-hood">Components: Under the Hood</a></h1>
<p>Components provide powerful modularity to Starknet contracts. But how does this
magic actually happen behind the scenes?</p>
<p>This chapter will dive deep into the compiler internals to explain the
mechanisms that enable component composability.</p>
<h2 id="a-primer-on-embeddable-impls"><a class="header" href="#a-primer-on-embeddable-impls">A Primer on Embeddable Impls</a></h2>
<p>Before digging into components, we need to understand <em>embeddable impls</em>.</p>
<p>An impl of a Starknet interface trait (marked with <code>#[starknet::interface]</code>) can
be made embeddable. Embeddable impls can be injected into any contract, adding
new entry points and modifying the ABI of the contract.</p>
<p>Let's look at an example to see this in action:</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait SimpleTrait&lt;TContractState&gt; {
    fn ret_4(self: @TContractState) -&gt; u8;
}

#[starknet::embeddable]
impl SimpleImpl&lt;TContractState&gt; of SimpleTrait&lt;TContractState&gt; {
    fn ret_4(self: @TContractState) -&gt; u8 {
        4
    }
}

#[starknet::contract]
mod simple_contract {
    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl MySimpleImpl = super::SimpleImpl&lt;ContractState&gt;;
}
</code></pre>
<p>By embedding <code>SimpleImpl</code>, we externally expose <code>ret4</code> in the contract's ABI.</p>
<p>Now that we’re more familiar with the embedding mechanism, we can now see how
components build on this.</p>
<h2 id="inside-components-generic-impls"><a class="header" href="#inside-components-generic-impls">Inside Components: Generic Impls</a></h2>
<p>Recall the impl block syntax used in components:</p>
<pre><code class="language-cairo noplayground">    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p>The key points:</p>
<ul>
<li>
<p>The generic impl <code>Ownable</code> requires the implementation of the
<code>HasComponent&lt;TContractState&gt;</code> trait by the underlying contract, which is
automatically generated with the <code>component!()</code> macro when using a component
inside a contract.</p>
<p>The compiler will generate an embeddable impl that wraps any function in
<code>Ownable</code>, replacing the <code>self: ComponentState&lt;TContractState&gt;</code> argument with
<code>self: TContractState</code>, where access to the component state is made via the
<code>get_component</code> function in the <code>HasComponent&lt;TContractState&gt;</code> trait.</p>
<p>For each component, the compiler generates a <code>HasComponent</code> trait. This trait
defines the interface to bridge between the actual <code>TContractState</code> of a
generic contract, and <code>ComponentState&lt;TContractState&gt;</code>.</p>
<pre><code class="language-cairo noplayground">// generated per component
trait HasComponent&lt;TContractState&gt; {
    fn get_component(self: @TContractState) -&gt; @ComponentState&lt;TContractState&gt;;
    fn get_component_mut(ref self: TContractState) -&gt; ComponentState&lt;TContractState&gt;;
    fn get_contract(self: @ComponentState&lt;TContractState&gt;) -&gt; @TContractState;
    fn get_contract_mut(ref self: ComponentState&lt;TContractState&gt;) -&gt; TContractState;
    fn emit&lt;S, impl IntoImp: traits::Into&lt;S, Event&gt;&gt;(ref self: ComponentState&lt;TContractState&gt;, event: S);
}
</code></pre>
<p>In our context <code>ComponentState&lt;TContractState&gt;</code> is a type specific to the
ownable component, i.e. it has members based on the storage variables defined
in <code>ownable_component::Storage</code>. Moving from the generic <code>TContractState</code> to
<code>ComponentState&lt;TContractState&gt;</code> will allow us to embed <code>OwnableImpl</code> in any
contract that wants to use it. The opposite direction
(<code>ComponentState&lt;TContractState&gt;</code> to <code>ContractState</code>) is useful for
dependencies (see the <code>Upgradeable</code> component depending on an <code>IOwnable</code>
implementation example in the
<a href="./ch103-02-02-component-dependencies.html">Components dependencies </a> section).</p>
<p>To put it briefly, one should think of an implementation of the above
<code>HasComponent&lt;T&gt;</code> as saying: <strong>“Contract whose state T has the upgradeable
component”.</strong></p>
</li>
<li>
<p><code>Ownable</code> is annotated with the <code>embeddable_as(&lt;name&gt;)</code> attribute:</p>
<p><code>embeddable_as</code> is similar to <code>embeddable</code>; it only applies to impls of
<code>starknet::interface</code> traits and allows embedding this impl in a contract
module. That said, <code>embeddable_as(&lt;name&gt;)</code> has another role in the context of
components. Eventually, when embedding <code>OwnableImpl</code> in some contract, we
expect to get an impl with the following functions:</p>
<pre><code class="language-cairo noplayground">    fn owner(self: @TContractState) -&gt; ContractAddress;
  fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
  fn renounce_ownership(ref self: TContractState);
</code></pre>
<p>Note that while starting with a function receiving the generic type
<code>ComponentState&lt;TContractState&gt;</code>, we want to end up with a function receiving
<code>ContractState</code>. This is where <code>embeddable_as(&lt;name&gt;)</code> comes in. To see the
full picture, we need to see what is the impl generated by the compiler due to
the <code>embeddable_as(OwnableImpl)</code> annotation:</p>
</li>
</ul>
<pre><code class="language-cairo noplayground">#[starknet::embeddable]
impl OwnableImpl&lt;
    TContractState, +HasComponent&lt;TContractState&gt;, impl TContractStateDrop: Drop&lt;TContractState&gt;,
&gt; of super::IOwnable&lt;TContractState&gt; {
    fn owner(self: @TContractState) -&gt; ContractAddress {
        let component = HasComponent::get_component(self);
        Ownable::owner(component)
    }

    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress) {
        let mut component = HasComponent::get_component_mut(ref self);
        Ownable::transfer_ownership(ref component, new_owner)
    }

    fn renounce_ownership(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Ownable::renounce_ownership(ref component)
    }
}
</code></pre>
<p>Note that thanks to having an impl of <code>HasComponent&lt;TContractState&gt;</code>, the
compiler was able to wrap our functions in a new impl that doesn’t directly know
about the <code>ComponentState</code> type. <code>OwnableImpl</code>, whose name we chose when writing
<code>embeddable_as(OwnableImpl)</code>, is the impl that we will embed in a contract that
wants ownership.</p>
<h2 id="contract-integration"><a class="header" href="#contract-integration">Contract Integration</a></h2>
<p>We've seen how generic impls enable component reusability. Next let's see how a
contract integrates a component.</p>
<p>The contract uses an <strong>impl alias</strong> to instantiate the component's generic impl
with the concrete <code>ContractState</code> of the contract.</p>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;

    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;
</code></pre>
<p>The above lines use the Cairo impl embedding mechanism alongside the impl alias
syntax. We’re instantiating the embeddable generated impl
<code>OwnableImpl&lt;TContractState&gt;</code> with the concrete type <code>ContractState</code>. Recall
that the generic impl is <code>Ownable&lt;TContractState&gt;</code>, and the <code>component!</code> macro
provides <code>HasComponent&lt;TContractState&gt;</code> so the wrapper can delegate to it.</p>
<p>Note that only the using contract could have implemented this trait since only
it knows about both the contract state and the component state.</p>
<p>This glues everything together to inject the component logic into the contract.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li>Embeddable impls allow injecting components logic into contracts by adding
entry points and modifying the contract ABI.</li>
<li>The compiler automatically generates a <code>HasComponent</code> trait implementation
when a component is used in a contract. This creates a bridge between the
contract's state and the component's state, enabling interaction between the
two.</li>
<li>Components encapsulate reusable logic in a generic, contract-agnostic way.
Contracts integrate components through impl aliases and access them via the
generated <code>HasComponent</code> trait.</li>
<li>Components build on embeddable impls by defining generic component logic that
can be integrated into any contract wanting to use that component. Impl
aliases instantiate these generic impls with the contract's concrete storage
types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-dependencies"><a class="header" href="#component-dependencies">Component Dependencies</a></h1>
<p>Working with components becomes more complex when we try to use one component
inside another. As mentioned earlier, a component can only be embedded within a
contract, meaning that it's not possible to embed a component within another
component. However, this doesn't mean that we can't use one component inside
another. In this section, we will see how to use a component as a dependency of
another component.</p>
<p>Consider a component called <code>OwnableCounter</code> whose purpose is to create a
counter that can only be incremented by its owner. This component can be
embedded in any contract, so that any contract that uses it will have a counter
that can only be incremented by its owner.</p>
<p>The first way to implement this is to create a single component that contains
both counter and ownership features from within a single component. However,
this approach is not recommended: our goal is to minimize the amount of code
duplication and take advantage of component reusability. Instead, we can create
a new component that <em>depends</em> on the <code>Ownable</code> component for the ownership
features, and internally defines the logic for the counter.</p>
<p>Listing 17-1 shows the complete implementation, which
we'll break down right after:</p>
<pre><code class="language-cairo noplayground">
#[starknet::interface]
trait IOwnableCounter&lt;TContractState&gt; {
    fn get_counter(self: @TContractState) -&gt; u32;
    fn increment(ref self: TContractState);
}

#[starknet::component]
pub mod OwnableCounterComponent {
    use listing_03_component_dep::owner::OwnableComponent;
    use listing_03_component_dep::owner::OwnableComponent::InternalImpl;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        value: u32,
    }

    #[embeddable_as(OwnableCounterImpl)]
    impl OwnableCounter&lt;
        TContractState,
        +HasComponent&lt;TContractState&gt;,
        +Drop&lt;TContractState&gt;,
        impl Owner: OwnableComponent::HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnableCounter&lt;ComponentState&lt;TContractState&gt;&gt; {
        fn get_counter(self: @ComponentState&lt;TContractState&gt;) -&gt; u32 {
            self.value.read()
        }

        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }
    }
}
</code></pre>
<p>17-1: An OwnableCounter Component</span></p>
<h2 id="specificities"><a class="header" href="#specificities">Specificities</a></h2>
<h3 id="specifying-dependencies-on-another-component"><a class="header" href="#specifying-dependencies-on-another-component">Specifying Dependencies on Another Component</a></h3>
<pre><code class="language-cairo noplayground">    impl OwnableCounter&lt;
        TContractState,
        +HasComponent&lt;TContractState&gt;,
        +Drop&lt;TContractState&gt;,
        impl Owner: OwnableComponent::HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnableCounter&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p>In <a href="./ch08-02-traits-in-cairo.html">chapter 8</a>, we introduced trait bounds, which are used to
specify that a generic type must implement a certain trait. In the same way, we
can specify that a component depends on another component by restricting the
<code>impl</code> block to be available only for contracts that contain the required
component. In our case, this is done by adding a restriction
<code>impl Owner: ownable_component::HasComponent&lt;TContractState&gt;</code>, which indicates
that this <code>impl</code> block is only available for contracts that contain an
implementation of the <code>ownable_component::HasComponent</code> trait. This essentially
means that the `TContractState' type has access to the ownable component. See
<a href="ch103-02-01-under-the-hood.html#inside-components-generic-impls">Components under the hood</a> for more information.</p>
<p>Although most of the trait bounds were defined using <a href="./ch08-01-generic-data-types.html#anonymous-generic-implementation-parameter--operator">anonymous
parameters</a>, the dependency on the <code>Ownable</code>
component is defined using a named parameter (here, <code>Owner</code>). We will need to
use this explicit name when accessing the <code>Ownable</code>component within the<code>impl</code>
block.</p>
<p>While this mechanism is verbose and may not be easy to approach at first, it is
a powerful leverage of the trait system in Cairo. The inner workings of this
mechanism are abstracted away from the user, and all you need to know is that
when you embed a component in a contract, all other components in the same
contract can access it.</p>
<h3 id="using-the-dependency"><a class="header" href="#using-the-dependency">Using the Dependency</a></h3>
<p>Now that we have made our <code>impl</code> depend on the <code>Ownable</code> component, we can
access its functions, storage, and events within the implementation block. To
bring the <code>Ownable</code> component into scope, we have two choices, depending on
whether we intend to mutate the state of the <code>Ownable</code> component or not. If we
want to access the state of the <code>Ownable</code> component without mutating it, we use
the <code>get_dep_component!</code> macro. If we want to mutate the state of the <code>Ownable</code>
component (for example, change the current owner), we use the
<code>get_dep_component_mut!</code> macro. Both macros take two arguments: the first is
<code>self</code>, either as a snapshot or by reference depending on mutability,
representing the state of the component using the dependency, and the second is
the component to access.</p>
<pre><code class="language-cairo noplayground">        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }
</code></pre>
<p>In this function, we want to make sure that only the owner can call the
<code>increment</code> function. We need to use the <code>assert_only_owner</code> function from the
<code>Ownable</code> component. We'll use the <code>get_dep_component!</code> macro which will return
a snapshot of the requested component state, and call <code>assert_only_owner</code> on it,
as a method of that component.</p>
<p>For the <code>transfer_ownership</code> function, we want to mutate that state to change
the current owner. Because we know the contract embedding this component
implements the <code>OwnableComponent</code> trait, there's no need to define this function
in the <code>OwnableCounterComponent</code> component: the host contract will expose it
through the <code>OwnableComponent</code>.</p>
<p>The final host contract is shown in Listing 17-2.</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod OwnableCounter {
    use listing_03_component_dep::counter::OwnableCounterComponent;
    use listing_03_component_dep::owner::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableCounterComponent, storage: counter, event: CounterEvent);
    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    #[abi(embed_v0)]
    impl OwnableCounterImpl =
        OwnableCounterComponent::OwnableCounterImpl&lt;ContractState&gt;;

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        counter: OwnableCounterComponent::Storage,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CounterEvent: OwnableCounterComponent::Event,
        OwnableEvent: OwnableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }
}
</code></pre>
<p>Contract</span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-components"><a class="header" href="#testing-components">Testing Components</a></h1>
<p>Testing components is a bit different than testing contracts. Contracts need to
be tested against a specific state, which can be achieved by either deploying
the contract in a test, or by simply getting the <code>ContractState</code> object and
modifying it in the context of your tests.</p>
<p>Components are a generic construct, meant to be integrated in contracts, that
can't be deployed on their own and don't have a <code>ContractState</code> object that we
could use. So how do we test them?</p>
<p>Let's consider that we want to test a very simple component called "Counter",
that will allow each contract to have a counter that can be incremented. The
component is defined in Listing 17-3:</p>
<pre><code class="language-cairo  noplayground">#[starknet::component]
pub mod CounterComponent {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        value: u32,
    }

    #[embeddable_as(CounterImpl)]
    pub impl Counter&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::ICounter&lt;ComponentState&lt;TContractState&gt;&gt; {
        fn get_counter(self: @ComponentState&lt;TContractState&gt;) -&gt; u32 {
            self.value.read()
        }

        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            self.value.write(self.value.read() + 1);
        }
    }
}
</code></pre>
<p>A simple Counter component</span></p>
<h2 id="testing-the-component-by-deploying-a-mock-contract"><a class="header" href="#testing-the-component-by-deploying-a-mock-contract">Testing the Component by Deploying a Mock Contract</a></h2>
<p>The easiest way to test a component is to integrate it within a mock contract.
This mock contract is only used for testing purposes, and only integrates the
component you want to test. This allows you to test the component in the context
of a contract, and to use a Dispatcher to call the component's entry points.</p>
<p>We can define such a mock contract as follows:</p>
<pre><code class="language-cairo  noplayground">#[starknet::contract]
mod MockContract {
    use super::counter::CounterComponent;

    component!(path: CounterComponent, storage: counter, event: CounterEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        counter: CounterComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CounterEvent: CounterComponent::Event,
    }

    #[abi(embed_v0)]
    impl CounterImpl = CounterComponent::CounterImpl&lt;ContractState&gt;;
}
</code></pre>
<p>This contract is entirely dedicated to testing the <code>Counter</code> component. It
embeds the component with the <code>component!</code> macro, exposes the component's entry
points by annotating the impl aliases with <code>#[abi(embed_v0)]</code>.</p>
<p>We also need to define an interface that will be required to interact externally
with this mock contract.</p>
<pre><code class="language-cairo  noplayground">#[starknet::interface]
pub trait ICounter&lt;TContractState&gt; {
    fn get_counter(self: @TContractState) -&gt; u32;
    fn increment(ref self: TContractState);
}
</code></pre>
<p>We can now write tests for the component by deploying this mock contract and
calling its entry points, as we would with a typical contract.</p>
<pre><code class="language-cairo  noplayground">use starknet::SyscallResultTrait;
use starknet::syscalls::deploy_syscall;
use super::MockContract;
use super::counter::{ICounterDispatcher, ICounterDispatcherTrait};

fn setup_counter() -&gt; ICounterDispatcher {
    let (address, _) = deploy_syscall(
        MockContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false,
    )
        .unwrap_syscall();
    ICounterDispatcher { contract_address: address }
}

#[test]
fn test_constructor() {
    let counter = setup_counter();
    assert_eq!(counter.get_counter(), 0);
}

#[test]
fn test_increment() {
    let counter = setup_counter();
    counter.increment();
    assert_eq!(counter.get_counter(), 1);
}
</code></pre>
<h2 id="testing-components-without-deploying-a-contract"><a class="header" href="#testing-components-without-deploying-a-contract">Testing Components Without Deploying a Contract</a></h2>
<p>In <a href="./ch103-02-01-under-the-hood.html">Components under the hood</a>, we saw that components
leveraged genericity to define storage and logic that could be embedded in
multiple contracts. If a contract embeds a component, a <code>HasComponent</code> trait is
created in this contract, and the component methods are made available.</p>
<p>This informs us that if we can provide a concrete <code>TContractState</code> that
implements the <code>HasComponent</code> trait to the <code>ComponentState</code> struct, should be
able to directly invoke the methods of the component using this concrete
<code>ComponentState</code> object, without having to deploy a mock.</p>
<p>Let's see how we can do that by using type aliases. We still need to define a
mock contract - let's use the same as above - but this time, we won't need to
deploy it.</p>
<p>First, we need to define a concrete implementation of the generic
<code>ComponentState</code> type using a type alias. We will use the
<code>MockContract::ContractState</code> type to do so.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use CounterComponent::Counter;
</span><span class="boring">use super::MockContract;
</span><span class="boring">use super::counter::CounterComponent;
</span><span class="boring">
</span>type TestingState = CounterComponent::ComponentState&lt;MockContract::ContractState&gt;;

// You can derive even `Default` on this type alias
impl TestingStateDefault of Default&lt;TestingState&gt; {
    fn default() -&gt; TestingState {
        CounterComponent::component_state_for_testing()
    }
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_increment() {
</span><span class="boring">    let mut counter: TestingState = Default::default();
</span><span class="boring">
</span><span class="boring">    counter.increment();
</span><span class="boring">    counter.increment();
</span><span class="boring">
</span><span class="boring">    assert_eq!(counter.get_counter(), 2);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>We defined the <code>TestingState</code> type as an alias of the
<code>CounterComponent::ComponentState&lt;MockContract::ContractState&gt;</code> type. By passing
the <code>MockContract::ContractState</code> type as a concrete type for <code>ComponentState</code>,
we aliased a concrete implementation of the <code>ComponentState</code> struct to
<code>TestingState</code>.</p>
<p>Because <code>MockContract</code> embeds <code>CounterComponent</code>, the methods of
<code>CounterComponent</code> defined in the <code>Counter</code> impl block (exposed via the
<code>CounterImpl</code> embeddable alias) can now be used on a <code>TestingState</code> object.</p>
<p>Now that we have made these methods available, we need to instantiate an object
of type <code>TestingState</code>, that we will use to test the component. We can do so by
calling the <code>component_state_for_testing</code> function, which automatically infers
that it should return an object of type <code>TestingState</code>.</p>
<p>We can even implement this as part of the <code>Default</code> trait, which allows us to
return an empty <code>TestingState</code> with the <code>Default::default()</code> syntax.</p>
<p>Let's summarize what we've done so far:</p>
<ul>
<li>We defined a mock contract that embeds the component we want to test.</li>
<li>We defined a concrete implementation of <code>ComponentState&lt;TContractState&gt;</code> using
a type alias with <code>MockContract::ContractState</code>, that we named <code>TestingState</code>.</li>
<li>We defined a function that uses <code>component_state_for_testing</code> to return a
<code>TestingState</code> object.</li>
</ul>
<p>We can now write tests for the component by calling its functions directly,
without having to deploy a mock contract. This approach is more lightweight than
the previous one, and it allows testing internal functions of the component that
are not exposed to the outside world trivially.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">use CounterComponent::Counter;
</span><span class="boring">use super::MockContract;
</span><span class="boring">use super::counter::CounterComponent;
</span><span class="boring">
</span><span class="boring">type TestingState = CounterComponent::ComponentState&lt;MockContract::ContractState&gt;;
</span><span class="boring">
</span><span class="boring">// You can derive even `Default` on this type alias
</span><span class="boring">impl TestingStateDefault of Default&lt;TestingState&gt; {
</span><span class="boring">    fn default() -&gt; TestingState {
</span><span class="boring">        CounterComponent::component_state_for_testing()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_increment() {
    let mut counter: TestingState = Default::default();

    counter.increment();
    counter.increment();

    assert_eq!(counter.get_counter(), 2);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgradeable-contracts"><a class="header" href="#upgradeable-contracts">Upgradeable Contracts</a></h1>
<p>Starknet has native upgradeability through a syscall that updates the contract
source code, removing the need for proxies.</p>
<blockquote>
<p><strong>⚠️ WARNING</strong> Make sure you follow the security recommendations before
upgrading.</p>
</blockquote>
<h2 id="how-upgradeability-works-in-starknet"><a class="header" href="#how-upgradeability-works-in-starknet">How Upgradeability Works in Starknet</a></h2>
<p>To better comprehend how upgradeability works in Starknet, it's important to
understand the difference between a contract and its contract class.</p>
<p><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash">Contract Classes</a> represent the source code of a program. All
contracts are associated to a class, and many contracts can be instances of the
same one. Classes are usually represented by a <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash">class hash</a>, and
before a contract of a class can be deployed, the class hash needs to be
declared.</p>
<p>A contract instance is a deployed contract corresponding to a class, with its
own storage.</p>
<h2 id="replacing-contract-classes"><a class="header" href="#replacing-contract-classes">Replacing Contract Classes</a></h2>
<h3 id="the-replace_class_syscall"><a class="header" href="#the-replace_class_syscall">The <code>replace_class_syscall</code></a></h3>
<p>The <code>replace_class</code> <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/">syscall</a> allows a contract to update its
source code by replacing its class hash once deployed.</p>
<p>To upgrade a contract, expose an entry point that executes
<code>replace_class_syscall</code> with the new class hash as an argument:</p>
<pre><code class="language-cairo noplayground">use core::num::traits::Zero;
use starknet::{ClassHash, syscalls};

fn upgrade(new_class_hash: ClassHash) {
    assert!(!new_class_hash.is_zero(), "Class hash cannot be zero");
    syscalls::replace_class_syscall(new_class_hash).unwrap();
}
</code></pre>
<p>Exposing <code>replace_class_syscall</code> to update the contract's class</span></p>
<blockquote>
<p><strong>📌 Note</strong>: If a contract is deployed without this mechanism, its class hash
can still be replaced through
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#library_call">library calls</a>.</p>
</blockquote>
<blockquote>
<p><strong>⚠️ WARNING</strong>: Thoroughly review changes and potential impacts before
upgrading, as it's a delicate procedure with security implications. Don't
allow arbitrary addresses to upgrade your contract.</p>
</blockquote>
<h2 id="openzeppelins-upgradeable-component"><a class="header" href="#openzeppelins-upgradeable-component">OpenZeppelin's Upgradeable Component</a></h2>
<p>OpenZeppelin Contracts for Cairo provides the <code>Upgradeable</code> component that can
be embedded into your contract to make it upgradeable. This component is a
simple way to add upgradeability to your contract while relying on an audited
library.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Upgrades are often very sensitive operations, and some form of access control is
usually required to avoid unauthorized upgrades. The <code>Ownable</code> component is used
in this example to restrict the upgradeability to a single address, so that the
contract owner has the exclusive right to upgrade the contract.</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ClassHash, ContractAddress};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable&lt;ContractState&gt; {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            self.ownable.assert_only_owner();

            // Replace the class hash upgrading the contract
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
</code></pre>
<p>17-5 Integrating OpenZeppelin's Upgradeable component
in a contract</span></p>
<p>The <code>UpgradeableComponent</code> provides:</p>
<ul>
<li>An internal <code>upgrade</code> function that safely performs the class replacement</li>
<li>An <code>Upgraded</code> event emitted when the upgrade is successful</li>
<li>Protection against upgrading to a zero class hash</li>
</ul>
<p>For more information, please refer to the <a href="https://docs.openzeppelin.com/contracts-cairo/0.18.0/upgrades">OpenZeppelin docs API
reference</a>.</p>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<p>Upgrades can be very sensitive operations, and security should always be top of
mind while performing one. Please make sure you thoroughly review the changes
and their consequences before upgrading. Some aspects to consider are:</p>
<ul>
<li><strong>API changes</strong> that might affect integration. For example, changing an
external function's arguments might break existing contracts or offchain
systems calling your contract.</li>
<li><strong>Storage changes</strong> that might result in lost data (e.g. changing a storage
slot name, making existing storage inaccessible), or data corruption (e.g.
changing a storage slot type, or the organization of a struct stored in
storage).</li>
<li><strong>Storage collisions</strong> (e.g. mistakenly reusing the same storage slot from
another component) are also possible, although less likely if best practices
are followed, for example prepending storage variables with the component's
name.</li>
<li>Always check for backwards compatibility before upgrading between versions of
OpenZeppelin Contracts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="l1-l2-messaging"><a class="header" href="#l1-l2-messaging">L1-L2 Messaging</a></h1>
<p>A crucial feature of a Layer 2 is its ability to interact with Layer 1.</p>
<p>Starknet has its own <code>L1-L2</code> messaging system, which is different from its
consensus mechanism and the submission of state updates on L1. Messaging is a
way for smart-contracts on L1 to interact with smart-contracts on L2 (or the
other way around), allowing us to do "cross-chain" transactions. For example, we
can do some computations on one chain and use the result of this computation on
the other chain.</p>
<p>Bridges on Starknet all use <code>L1-L2</code> messaging. Let's say that you want to bridge
tokens from Ethereum to Starknet. You will simply have to deposit your tokens
into the L1 bridge contract, which will automatically trigger the minting of the
same token on L2. Another good use case for <code>L1-L2</code> messaging would be <a href="https://starkware.co/resource/defi-pooling/">DeFi
pooling</a>.</p>
<p>On Starknet, it's important to note that the messaging system is
<strong>asynchronous</strong> and <strong>asymmetric</strong>.</p>
<ul>
<li><strong>Asynchronous</strong>: this means that in your contract code (being Solidity or
Cairo), you can't await the result of the message being sent on the other
chain within your contract code execution.</li>
<li><strong>Asymmetric</strong>: sending a message from Ethereum to Starknet (<code>L1-&gt;L2</code>) is
fully automated by the Starknet sequencer, which means that the message is
being automatically delivered to the target contract on L2. However, when
sending a message from Starknet to Ethereum (<code>L2-&gt;L1</code>), only the hash of the
message is sent to L1 by the Starknet sequencer. You must then consume the
message manually via a transaction on L1.</li>
</ul>
<p>Let's dive into the details.</p>
<h2 id="the-starknetmessaging-contract"><a class="header" href="#the-starknetmessaging-contract">The StarknetMessaging Contract</a></h2>
<p>The crucial component of the <code>L1-L2</code> Messaging system is the
<a href="https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4"><code>StarknetCore</code></a> contract. It is a set of Solidity
contracts deployed on Ethereum that allows Starknet to function properly. One of
the contracts of <code>StarknetCore</code> is called <code>StarknetMessaging</code> and it is the
contract responsible for passing messages between Starknet and Ethereum.
<code>StarknetMessaging</code> follows an <a href="https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6">interface</a> with functions
allowing to send messages to L2, receiving messages on L1 from L2 and canceling
messages.</p>
<pre><code class="language-js">interface IStarknetMessaging is IStarknetMessagingEvents {

    function sendMessageToL2(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload
    ) external returns (bytes32);

    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)
        external
        returns (bytes32);

    function startL1ToL2MessageCancellation(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external;

    function cancelL1ToL2Message(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external;
}
</code></pre>
<p><span class="caption"> Starknet messaging contract interface</span></p>
<p>In the case of <code>L1-&gt;L2</code> messages, the Starknet sequencer is constantly listening
to the logs emitted by the <code>StarknetMessaging</code> contract on Ethereum. Once a
message is detected in a log, the sequencer prepares and executes an
<code>L1HandlerTransaction</code> to call the function on the target L2 contract. This
takes up to 1-2 minutes to be done (few seconds for ethereum block to be mined,
and then the sequencer must build and execute the transaction).</p>
<p><code>L2-&gt;L1</code> messages are prepared by contract's execution on L2 and are part of the
block produced. When the sequencer produces a block, it sends the hash of each
message prepared by the contract's execution to the <code>StarknetCore</code> contract on
L1, where they can then be consumed once the block they belong to is proven and
verified on Ethereum (which for now is around 3-4 hours).</p>
<h2 id="sending-messages-from-ethereum-to-starknet"><a class="header" href="#sending-messages-from-ethereum-to-starknet">Sending Messages from Ethereum to Starknet</a></h2>
<p>If you want to send messages from Ethereum to Starknet, your Solidity contracts
must call the <code>sendMessageToL2</code> function of the <code>StarknetMessaging</code> contract. To
receive these messages on Starknet, you will need to annotate functions that can
be called from L1 with the <code>#[l1_handler]</code> attribute.</p>
<p>Let's take a simple contract taken from <a href="https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol">this tutorial</a>
where we want to send a message to Starknet. The <code>_snMessaging</code> is a state
variable already initialized with the address of the <code>StarknetMessaging</code>
contract. You can check all Starknet contract and sequencer addresses
<a href="https://docs.starknet.io/documentation/tools/important_addresses/">here</a>.</p>
<pre><code class="language-js">// Sends a message on Starknet with a single felt.
function sendMessageFelt(
    uint256 contractAddress,
    uint256 selector,
    uint256 myFelt
)
    external
    payable
{
    // We "serialize" here the felt into a payload, which is an array of uint256.
    uint256[] memory payload = new uint256[](1);
    payload[0] = myFelt;

    // msg.value must always be &gt;= 20_000 wei.
    _snMessaging.sendMessageToL2{value: msg.value}(
        contractAddress,
        selector,
        payload
    );
}
</code></pre>
<p>The function sends a message with a single felt value to the <code>StarknetMessaging</code>
contract. Be aware that your Cairo contract will only understand <code>felt252</code> data
type, so if you want to send more complex data, you must ensure that the data
serialization into the <code>uint256</code> array follows the Cairo serialization scheme.</p>
<p>It's important to note that we have <code>{value: msg.value}</code>. In fact, the minimum
value we have to send here is <code>20k wei</code>, due to the fact that the
<code>StarknetMessaging</code> contract will register the hash of our message in the
storage of Ethereum.</p>
<p>In addition to those <code>20k wei</code>, since the <code>L1HandlerTransaction</code> executed by the
sequencer is not tied to any account (the message originates from L1), you must
also ensure that you pay enough fees on L1 for your message to be deserialized
and processed on L2.</p>
<p>The fees of the <code>L1HandlerTransaction</code> are computed in a regular manner as it
would be done for an <code>Invoke</code> transaction. For this, you can profile the gas
consumption using <code>starkli</code> or <code>snforge</code> to estimate the cost of your message
execution.</p>
<p>The signature of the <code>sendMessageToL2</code> is:</p>
<pre><code class="language-js">function sendMessageToL2(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload
    ) external override returns (bytes32);
</code></pre>
<p>The parameters are as follows:</p>
<ul>
<li><code>toAddress</code>: The contract address on L2 that will be called.</li>
<li><code>selector</code>: The selector of the function of this contract at <code>toAddress</code>. This
selector (function) must have the <code>#[l1_handler]</code> attribute to be callable.</li>
<li><code>payload</code>: The payload is always an array of <code>felt252</code> (which are represented
by <code>uint256</code> in Solidity). For this reason we've inserted the input <code>myFelt</code>
into the array. This is why we need to insert the input data into an array.</li>
</ul>
<p>On the Starknet side, to receive this message, we have:</p>
<pre><code class="language-cairo noplayground">    #[l1_handler]
    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {
        assert!(from_address == self.allowed_message_sender.read(), "Invalid message sender");

        // You can now use the data, automatically deserialized from the message payload.
        assert!(my_felt == 123, "Invalid value");
    }
</code></pre>
<p>We need to add the <code>#[l1_handler]</code> attribute to our function. L1 handlers are
special functions that can only be executed by an <code>L1HandlerTransaction</code>. There
is nothing particular to do to receive transactions from L1, as the message is
relayed by the sequencer automatically. In your <code>#[l1_handler]</code> functions, it is
important to verify the sender of the L1 message to ensure that our contract can
only receive messages from a trusted L1 contract.</p>
<h2 id="sending-messages-from-starknet-to-ethereum"><a class="header" href="#sending-messages-from-starknet-to-ethereum">Sending Messages from Starknet to Ethereum</a></h2>
<p>When sending messages from Starknet to Ethereum, you will have to use the
<code>send_message_to_l1</code> syscall in your Cairo contracts. This syscall allows you to
send messages to the <code>StarknetMessaging</code> contract on L1. Unlike <code>L1-&gt;L2</code>
messages, <code>L2-&gt;L1</code> messages must be consumed manually, which means that you will
need your Solidity contract to explicitly call the <code>consumeMessageFromL2</code>
function of the <code>StarknetMessaging</code> contract in order to consume the message.</p>
<p>To send a message from L2 to L1, what we would do on Starknet is:</p>
<pre><code class="language-cairo noplayground">        fn send_message_felt(ref self: ContractState, to_address: EthAddress, my_felt: felt252) {
            // Note here, we "serialize" my_felt, as the payload must be
            // a `Span&lt;felt252&gt;`.
            syscalls::send_message_to_l1_syscall(to_address.into(), array![my_felt].span())
                .unwrap();
        }
</code></pre>
<p>We simply build the payload and pass it, along with the L1 contract address, to
the syscall function.</p>
<p>On L1, the important part is to build the same payload sent by the L2. Then in
your Solidity contract, you can call <code>consumeMessageFromL2</code> by passing the L2
contract address and the payload. Please be aware that the L2 contract address
expected by the <code>consumeMessageFromL2</code> is the address of the contract that sends
the message on the L2 by calling <code>send_message_to_l1_syscall</code>.</p>
<pre><code class="language-js">function consumeMessageFelt(
    uint256 fromAddress,
    uint256[] calldata payload
)
    external
{
    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);

    // You can use the message hash if you want here.

    // We expect the payload to contain only a felt252 value (which is a uint256 in Solidity).
    require(payload.length == 1, "Invalid payload");

    uint256 my_felt = payload[0];

    // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.
    require(my_felt &gt; 0, "Invalid value");
}
</code></pre>
<p>As you can see, in this context we don't have to verify which contract from L2
is sending the message (as we do on the L2 to verify which contract from L1 is
sending the message). But we are actually using the <code>consumeMessageFromL2</code> of
the <code>StarknetCore</code> contract to validate the inputs (the contract address on L2
and the payload) to ensure we are only consuming valid messages.</p>
<blockquote>
<p><strong>Note:</strong> The <code>consumeMessageFromL2</code> function of the <code>StarknetCore</code> contract
is expected to be called from a Solidity contract, and not directly on the
<code>StarknetCore</code> contract. The reason for that is because the <code>StarknetCore</code>
contract is using <code>msg.sender</code> to actually compute the hash of the message.
And this <code>msg.sender</code> must correspond to the <code>to_address</code> field that is given
to the function <code>send_message_to_l1_syscall</code> that is called on Starknet.</p>
</blockquote>
<h2 id="cairo-serde"><a class="header" href="#cairo-serde">Cairo Serde</a></h2>
<p>Before sending messages between L1 and L2, you must remember that Starknet
contracts, written in Cairo, can only understand serialized data. And serialized
data is always an array of <code>felt252</code>. In Solidity we have <code>uint256</code> type, and
<code>felt252</code> is approximately 4 bits smaller than <code>uint256</code>. So we have to pay
attention to the values contained in the payload of the messages we are sending.
If, on L1, we build a message with values above the maximum <code>felt252</code>, the
message will be stuck and never consumed on L2.</p>
<p>So for instance, an actual <code>uint256</code> value in Cairo is represented by a struct
like:</p>
<pre><code class="language-cairo does_not_compile">struct u256 {
    low: u128,
    high: u128,
}
</code></pre>
<p>which will be serialized as <strong>TWO</strong> felts, one for <code>low</code>, and one for <code>high</code>.
This means that to send only one <code>u256</code> to Cairo, you'll need to send a payload
from L1 with <strong>TWO</strong> values.</p>
<pre><code class="language-js">uint256[] memory payload = new uint256[](2);
// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.
payload[0] = 1;
payload[1] = 0;
</code></pre>
<p>If you want to learn more about the messaging mechanism, you can visit the
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/">Starknet documentation</a>.</p>
<p>You can also find a <a href="https://github.com/glihm/starknet-messaging-dev">detailed guide here</a> to test the
messaging system locally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle-interactions"><a class="header" href="#oracle-interactions">Oracle Interactions</a></h1>
<p>This section focuses on the concept of bringing off-chain data to the Starknet
blockchain using oracles. Oracles are third-party services that serve as
intermediaries, securely transmitting external data, such as asset prices,
weather information, or other real-world data, to blockchains and smart
contracts. It also provides practical examples and code snippets, including how
to use
<a href="https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data">Pragma price feeds</a>
and <a href="https://github.com/cartridge-gg/vrf">Cartridge VRF</a> for verifiable random
numbers in games.</p>
<p>For further reading:</p>
<ul>
<li>Pragma Oracle price feeds:
https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data</li>
<li>Cartridge VRF overview and usage: https://github.com/cartridge-gg/vrf</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="price-feeds"><a class="header" href="#price-feeds">Price Feeds</a></h1>
<p>Price feeds enabled by an oracle serve as a bridge between real-world data feed
and the blockchain. They provide real time pricing data that is aggregated from
multiple trusted external sources ( e.g. crypto exchanges, financial data
providers, etc. ) to the blockchain network.</p>
<p>For the example in this book section, we will use Pragma Oracle to read the
price feed for <code>ETH/USD</code> asset pair and also showcase a mini application that
utilizes this feed.</p>
<p><a href="https://www.pragma.build/">Pragma Oracle</a> is a leading zero knowledge oracle
that provides access to off-chain data on Starknet blockchain in a verifiable
way.</p>
<h2 id="setting-up-your-contract-for-price-feeds"><a class="header" href="#setting-up-your-contract-for-price-feeds">Setting Up Your Contract for Price Feeds</a></h2>
<h3 id="add-pragma-as-a-project-dependency"><a class="header" href="#add-pragma-as-a-project-dependency">Add Pragma as a Project Dependency</a></h3>
<p>To get started with integrating Pragma on your Cairo smart contract for price
feed data, edit your project's <code>Scarb.toml</code> file to include the path to use
Pragma.</p>
<pre><code class="language-toml">[dependencies]
pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }
</code></pre>
<h3 id="creating-a-price-feed-contract"><a class="header" href="#creating-a-price-feed-contract">Creating a Price Feed Contract</a></h3>
<p>After adding the required dependencies for your project, you'll need to define a
contract interface that includes the required pragma price feed entry point.</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
pub trait IPriceFeedExample&lt;TContractState&gt; {
    fn buy_item(ref self: TContractState);
    fn get_asset_price(self: @TContractState, asset_id: felt252) -&gt; u128;
}
</code></pre>
<p>Of the two public functions exposed in the <code>IPriceFeedExample</code>, the one
necessary to interact with the pragma price feed oracle is the <code>get_asset_price</code>
function, a view function that takes in the <code>asset_id</code> argument and returns a
<code>u128</code> value.</p>
<h3 id="import-pragma-dependencies"><a class="header" href="#import-pragma-dependencies">Import Pragma Dependencies</a></h3>
<pre><code class="language-cairo noplayground">    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};
    use starknet::contract_address::contract_address_const;
    use starknet::get_caller_address;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, IPriceFeedExample};

    const ETH_USD: felt252 = 19514442401534788;
    const EIGHT_DECIMAL_FACTOR: u256 = 100000000;

    #[storage]
    struct Storage {
        pragma_contract: ContractAddress,
        product_price_in_usd: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
        self.pragma_contract.write(pragma_contract);
        self.product_price_in_usd.write(100);
    }

    #[abi(embed_v0)]
    impl PriceFeedExampleImpl of IPriceFeedExample&lt;ContractState&gt; {
        fn buy_item(ref self: ContractState) {
            let caller_address = get_caller_address();
            let eth_price = self.get_asset_price(ETH_USD).into();
            let product_price = self.product_price_in_usd.read();

            // Calculate the amount of ETH needed
            let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;

            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::&lt;
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                &gt;() // ETH Contract Address
            };

            // Transfer the ETH to the caller
            eth_dispatcher
                .transfer_from(
                    caller_address,
                    contract_address_const::&lt;
                        0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
                    &gt;(),
                    eth_needed,
                );
        }

        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
    }
}


</code></pre>
<p>The snippet above shows the necessary imports you need to add to your contract
module in order to interact with the Pragma oracle.</p>
<h3 id="required-price-feed-function-impl-in-contract"><a class="header" href="#required-price-feed-function-impl-in-contract">Required Price Feed Function Impl in Contract</a></h3>
<pre><code class="language-cairo noplayground">        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
</code></pre>
<p>The <code>get_asset_price</code> function is responsible for retrieving the price of the
asset specified by the <code>asset_id</code> argument from Pragma Oracle. The
<code>get_data_median</code> method is called from the <code>IPragmaDispatcher</code> instance by
passing the <code>DataType::SpotEntry(asset_id)</code> as an argument and its output is
assigned to a variable named <code>output</code> of type <code>PragmaPricesResponse</code>. Finally,
the function returns the price of the requested asset as a <code>u128</code>.</p>
<h2 id="example-application-using-pragma-price-feed"><a class="header" href="#example-application-using-pragma-price-feed">Example Application Using Pragma Price Feed</a></h2>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod PriceFeedExample {
    use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};
    use starknet::contract_address::contract_address_const;
    use starknet::get_caller_address;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, IPriceFeedExample};

    const ETH_USD: felt252 = 19514442401534788;
    const EIGHT_DECIMAL_FACTOR: u256 = 100000000;

    #[storage]
    struct Storage {
        pragma_contract: ContractAddress,
        product_price_in_usd: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
        self.pragma_contract.write(pragma_contract);
        self.product_price_in_usd.write(100);
    }

    #[abi(embed_v0)]
    impl PriceFeedExampleImpl of IPriceFeedExample&lt;ContractState&gt; {
        fn buy_item(ref self: ContractState) {
            let caller_address = get_caller_address();
            let eth_price = self.get_asset_price(ETH_USD).into();
            let product_price = self.product_price_in_usd.read();

            // Calculate the amount of ETH needed
            let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;

            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::&lt;
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                &gt;() // ETH Contract Address
            };

            // Transfer the ETH to the caller
            eth_dispatcher
                .transfer_from(
                    caller_address,
                    contract_address_const::&lt;
                        0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
                    &gt;(),
                    eth_needed,
                );
        }

        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Pragma returns the value of different token pairs using the decimal
factor of 6 or 8. You can convert the value to the required decimal factor by
dividing the value by \( {10^{n}} \), where <code>n</code> is the decimal factor.</p>
</blockquote>
<p>The code above is an example implementation of an applications consuming a price
feed from the Pragma oracle. The contract imports necessary modules and
interfaces, including the <code>IPragmaABIDispatcher</code> for interacting with the Pragma
oracle contract and the <code>ERC20ABIDispatcher</code> for interacting with the ETH ERC20
token contract.</p>
<p>The contract has a <code>const</code> that stores the token pair ID of <code>ETH/USD</code>, and a
<code>Storage</code> struct that holds two fields <code>pragma_contract</code> and
<code>product_price_in_usd</code>. The constructor function initializes the
<code>pragma_contract</code> address and sets the <code>product_price_in_usd</code> to 100.</p>
<p>The <code>buy_item</code> function is the main entry point for a user to purchase an item.
It retrieves the caller's address. It calls the <code>get_asset_price</code> function to
get the current price of ETH in USD using the <code>ETH_USD</code> asset ID. It calculates
the amount of ETH needed to buy the product based on the product price in USD at
the corresponding ETH price. It then checks if the caller has enough ETH by
calling the <code>balance_of</code> method on the ERC20 ETH contract. If the caller has
enough ETH, it calls the <code>transfer_from</code> method of the <code>eth_dispatcher</code> instance
to transfer the required amount of ETH from the caller to another contract
address.</p>
<p>The <code>get_asset_price</code> function is the entry point to interact with the Pragma
oracle and has been explained in the section above.</p>
<p>You can get a detailed guide on consuming data using Pragma price feeds on their
<a href="https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="randomness"><a class="header" href="#randomness">Randomness</a></h1>
<p>Since all blockchains are fundamentally deterministic and most are public
ledgers, generating truly unpredictatable randomness on-chain presents a
challenge. This randomness is crucial for fair outcomes in gaming, lotteries,
and unique generation of NFTs. To address this, verifiable random functions
(VRFs) provided by oracles offer a solution. VRFs guarantee that the randomness
can't be predicted or tampered with, ensuring trust and transparency in these
applications.</p>
<h2 id="overview-on-vrfs"><a class="header" href="#overview-on-vrfs">Overview on VRFs</a></h2>
<p>VRFs use a secret key and a nonce (a unique input) to generate an output that
appears random. While technically 'pseudo-random', it's practically impossible
for another party to predict the outcome without knowing the secret key.</p>
<p>VRFs produce not only the random number but also a proof that anyone can use to
independently verify that the result was generated correctly according to the
function's parameters.</p>
<h2 id="generating-randomness-with-cartridge-vrf"><a class="header" href="#generating-randomness-with-cartridge-vrf">Generating Randomness with Cartridge VRF</a></h2>
<p><a href="https://github.com/cartridge-gg/vrf">Cartridge VRF</a> provides synchronous,
onchain verifiable randomness designed for games on Starknet - although it can
be used for other purposes. It uses a simple flow: a transaction prefixes a
<code>request_random</code> call to the VRF provider, then your contract calls
<code>consume_random</code> to obtain a verified random value within the same transaction.</p>
<h3 id="add-cartridge-vrf-as-a-dependency"><a class="header" href="#add-cartridge-vrf-as-a-dependency">Add Cartridge VRF as a Dependency</a></h3>
<p>Edit your Cairo project's <code>Scarb.toml</code> file to include Cartridge VRF.</p>
<pre><code class="language-toml">[dependencies]
cartridge_vrf = { git = "https://github.com/cartridge-gg/vrf" }
</code></pre>
<h3 id="define-the-contract-interface"><a class="header" href="#define-the-contract-interface">Define the Contract Interface</a></h3>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait IVRFGame&lt;TContractState&gt; {
    fn get_last_random_number(self: @TContractState) -&gt; felt252;
    fn settle_random(ref self: TContractState);
    fn set_vrf_provider(ref self: TContractState, new_vrf_provider: ContractAddress);
}

#[starknet::interface]
pub trait IDiceGame&lt;TContractState&gt; {
    fn guess(ref self: TContractState, guess: u8);
    fn toggle_play_window(ref self: TContractState);
    fn get_game_window(self: @TContractState) -&gt; bool;
    fn process_game_winners(ref self: TContractState);
}
</code></pre>
<p>17-6 shows interfaces for integrating Cartridge VRF
with a simple dice game.</span></p>
<h3 id="cartridge-vrf-flow-and-key-entrypoints"><a class="header" href="#cartridge-vrf-flow-and-key-entrypoints">Cartridge VRF Flow and Key Entrypoints</a></h3>
<p>Cartridge VRF works in a single transaction using two calls:</p>
<ol>
<li><code>request_random(caller, source)</code> — Must be the first call in the
transaction's multicall. It signals that your contract at <code>caller</code> will
consume a random value using the specified <code>source</code>.</li>
<li><code>consume_random(source)</code> — Called by your game contract to synchronously
retrieve the random value. The VRF proof is verified onchain, and the value
is immediately available for use.</li>
</ol>
<p>Common <code>source</code> choices:</p>
<ul>
<li><code>Source::Nonce(ContractAddress)</code> — Uses the provider’s internal nonce for the
provided address, ensuring a unique random value per request.</li>
<li><code>Source::Salt(felt252)</code> — Uses a static salt. Using the same salt will return
the same random value.</li>
</ul>
<h2 id="dice-game-contract"><a class="header" href="#dice-game-contract">Dice Game Contract</a></h2>
<p>This dice game contract allows players to guess a number between 1 &amp; 6 during an
active game window. The contract owner can toggle the game window to disable new
guesses. To determine the winning number, the contract owner calls
<code>settle_random</code>, which consumes a random value from the Cartridge VRF provider
and stores it in <code>last_random_number</code>. Each player then calls
<code>process_game_winners</code> to determine if they have won or lost. The stored
<code>last_random_number</code> is reduced to a number between 1 &amp; 6 and compared to the
player's guess, emitting either <code>GameWinner</code> or <code>GameLost</code>.</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod DiceGame {
    use cartridge_vrf::Source;

    // Cartridge VRF consumer component and types
    use cartridge_vrf::vrf_consumer::vrf_consumer_component::VrfConsumerComponent;
    use openzeppelin::access::ownable::OwnableComponent;
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address, get_contract_address};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VrfConsumerComponent, storage: vrf_consumer, event: VrfConsumerEvent);

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
    impl InternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // Expose VRF consumer helpers
    #[abi(embed_v0)]
    impl VrfConsumerImpl = VrfConsumerComponent::VrfConsumerImpl&lt;ContractState&gt;;
    impl VrfConsumerInternalImpl = VrfConsumerComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        user_guesses: Map&lt;ContractAddress, u8&gt;,
        game_window: bool,
        last_random_number: felt252,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vrf_consumer: VrfConsumerComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        GameWinner: ResultAnnouncement,
        GameLost: ResultAnnouncement,
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VrfConsumerEvent: VrfConsumerComponent::Event,
    }

    #[derive(Drop, starknet::Event)]
    struct ResultAnnouncement {
        caller: ContractAddress,
        guess: u8,
        random_number: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, vrf_provider: ContractAddress, owner: ContractAddress) {
        self.ownable.initializer(owner);
        self.vrf_consumer.initializer(vrf_provider);
        self.game_window.write(true);
    }

    #[abi(embed_v0)]
    impl DiceGame of super::IDiceGame&lt;ContractState&gt; {
        fn guess(ref self: ContractState, guess: u8) {
            assert!(self.game_window.read(), "GAME_INACTIVE");
            assert!(guess &gt;= 1 &amp;&amp; guess &lt;= 6, "INVALID_GUESS");

            let caller = get_caller_address();
            self.user_guesses.entry(caller).write(guess);
        }

        fn toggle_play_window(ref self: ContractState) {
            self.ownable.assert_only_owner();

            let current: bool = self.game_window.read();
            self.game_window.write(!current);
        }

        fn get_game_window(self: @ContractState) -&gt; bool {
            self.game_window.read()
        }

        fn process_game_winners(ref self: ContractState) {
            assert!(!self.game_window.read(), "GAME_ACTIVE");
            assert!(self.last_random_number.read() != 0, "NO_RANDOM_NUMBER_YET");

            let caller = get_caller_address();
            let user_guess: u8 = self.user_guesses.entry(caller).read();
            let reduced_random_number: u256 = self.last_random_number.read().into() % 6 + 1;

            if user_guess == reduced_random_number.try_into().unwrap() {
                self
                    .emit(
                        Event::GameWinner(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            } else {
                self
                    .emit(
                        Event::GameLost(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            }
        }
    }

    #[abi(embed_v0)]
    impl VRFGame of super::IVRFGame&lt;ContractState&gt; {
        fn get_last_random_number(self: @ContractState) -&gt; felt252 {
            self.last_random_number.read()
        }

        // Settle randomness for the current round using Cartridge VRF.
        // Requires the caller to prefix the multicall with:
        //   VRF.request_random(caller: &lt;this contract&gt;, source: Source::Nonce(&lt;this contract&gt;))
        fn settle_random(ref self: ContractState) {
            self.ownable.assert_only_owner();
            // Consume a random value tied to this contract's own nonce
            let random = self.vrf_consumer.consume_random(Source::Nonce(get_contract_address()));
            self.last_random_number.write(random);
        }

        fn set_vrf_provider(ref self: ContractState, new_vrf_provider: ContractAddress) {
            self.ownable.assert_only_owner();
            self.vrf_consumer.set_vrf_provider(new_vrf_provider);
        }
    }
}
</code></pre>
<p>Simple Dice Game Contract using Cartridge VRF.</span></p>
<h4 id="calling-pattern-for-cartridge-vrf"><a class="header" href="#calling-pattern-for-cartridge-vrf">Calling Pattern for Cartridge VRF</a></h4>
<p>When you call your <code>settle_random</code> entrypoint from an account, prefix the
transaction’s multicall with a call to the VRF provider’s <code>request_random</code> using
the same <code>source</code> that the contract will pass to <code>consume_random</code> (in this
example, <code>Source::Nonce(&lt;dice_contract&gt;)</code>). For example:</p>
<ol>
<li><code>VRF.request_random(caller: &lt;dice_contract&gt;, source: Source::Nonce(&lt;dice_contract&gt;))</code></li>
<li><code>&lt;dice_contract&gt;.settle_random()</code></li>
</ol>
<p>This ensures the VRF server can submit and verify the proof onchain and that the
random value is available to your contract during execution.</p>
<h4 id="deployments"><a class="header" href="#deployments">Deployments</a></h4>
<ul>
<li>Mainnet
<ul>
<li>Class hash:
https://voyager.online/class/0x00be3edf412dd5982aa102524c0b8a0bcee584c5a627ed1db6a7c36922047257</li>
<li>Contract:
https://voyager.online/contract/0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f</li>
</ul>
</li>
<li>Sepolia
<ul>
<li>Class hash:
https://sepolia.voyager.online/class/0x00be3edf412dd5982aa102524c0b8a0bcee584c5a627ed1db6a7c36922047257</li>
<li>Contract:
https://sepolia.voyager.online/contract/0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f</li>
</ul>
</li>
</ul>
<p>Use the network’s VRF provider address as the <code>vrf_provider</code> constructor
argument (or via <code>set_vrf_provider</code>) in the example contract.</p>
<p>More details and updates: see the
<a href="https://github.com/cartridge-gg/vrf">Cartridge VRF repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-examples"><a class="header" href="#other-examples">Other Examples</a></h1>
<p>This section contains additional examples of Starknet smart contracts, utilizing
various features of the Cairo programming language. Your contributions are
welcome and encouraged, as we aim to gather as many diverse examples as
possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-and-interacting-with-a-voting-contract"><a class="header" href="#deploying-and-interacting-with-a-voting-contract">Deploying and Interacting with a Voting contract</a></h1>
<p>The <strong><code>Vote</code></strong> contract in Starknet begins by registering voters through the
contract's constructor. Three voters are initialized at this stage, and their
addresses are passed to an internal function <strong><code>_register_voters</code></strong>. This
function adds the voters to the contract's state, marking them as registered and
eligible to vote.</p>
<p>Within the contract, the constants <strong><code>YES</code></strong> and <strong><code>NO</code></strong> are defined to
represent the voting options (1 and 0, respectively). These constants facilitate
the voting process by standardizing the input values.</p>
<p>Once registered, a voter is able to cast a vote using the <strong><code>vote</code></strong> function,
selecting either the 1 (YES) or 0 (NO) as their vote. When voting, the state of
the contract is updated, recording the vote and marking the voter as having
voted. This ensures that the voter is not able to cast a vote again within the
same proposal. The casting of a vote triggers the <strong><code>VoteCast</code></strong> event, logging
the action.</p>
<p>The contract also monitors unauthorized voting attempts. If an unauthorized
action is detected, such as a non-registered user attempting to vote or a user
trying to vote again, the <strong><code>UnauthorizedAttempt</code></strong> event is emitted.</p>
<p>Together, these functions, states, constants, and events create a structured
voting system, managing the lifecycle of a vote from registration to casting,
event logging, and result retrieval within the Starknet environment. Constants
like <strong><code>YES</code></strong> and <strong><code>NO</code></strong> help streamline the voting process, while events
play a vital role in ensuring transparency and traceability.</p>
<p>Listing 17-8 shows the <code>Vote</code> contract in detail:</p>
<pre><code class="language-cairo noplayground">/// Core Library Imports for the Traits outside the Starknet Contract
use starknet::ContractAddress;

/// Trait defining the functions that can be implemented or called by the Starknet Contract
#[starknet::interface]
trait VoteTrait&lt;T&gt; {
    /// Returns the current vote status
    fn get_vote_status(self: @T) -&gt; (u8, u8, u8, u8);
    /// Checks if the user at the specified address is allowed to vote
    fn voter_can_vote(self: @T, user_address: ContractAddress) -&gt; bool;
    /// Checks if the specified address is registered as a voter
    fn is_voter_registered(self: @T, address: ContractAddress) -&gt; bool;
    /// Allows a user to vote
    fn vote(ref self: T, vote: u8);
}

/// Starknet Contract allowing three registered voters to vote on a proposal
#[starknet::contract]
mod Vote {
    use starknet::storage::{
        Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
        StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    const YES: u8 = 1_u8;
    const NO: u8 = 0_u8;

    #[storage]
    struct Storage {
        yes_votes: u8,
        no_votes: u8,
        can_vote: Map&lt;ContractAddress, bool&gt;,
        registered_voter: Map&lt;ContractAddress, bool&gt;,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        voter_1: ContractAddress,
        voter_2: ContractAddress,
        voter_3: ContractAddress,
    ) {
        self._register_voters(voter_1, voter_2, voter_3);

        self.yes_votes.write(0_u8);
        self.no_votes.write(0_u8);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        VoteCast: VoteCast,
        UnauthorizedAttempt: UnauthorizedAttempt,
    }

    #[derive(Drop, starknet::Event)]
    struct VoteCast {
        voter: ContractAddress,
        vote: u8,
    }

    #[derive(Drop, starknet::Event)]
    struct UnauthorizedAttempt {
        unauthorized_address: ContractAddress,
    }

    #[abi(embed_v0)]
    impl VoteImpl of super::VoteTrait&lt;ContractState&gt; {
        fn get_vote_status(self: @ContractState) -&gt; (u8, u8, u8, u8) {
            let (n_yes, n_no) = self._get_voting_result();
            let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage();
            (n_yes, n_no, yes_percentage, no_percentage)
        }

        fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -&gt; bool {
            self.can_vote.read(user_address)
        }

        fn is_voter_registered(self: @ContractState, address: ContractAddress) -&gt; bool {
            self.registered_voter.read(address)
        }

        fn vote(ref self: ContractState, vote: u8) {
            assert!(vote == NO || vote == YES, "VOTE_0_OR_1");
            let caller: ContractAddress = get_caller_address();
            self._assert_allowed(caller);
            self.can_vote.write(caller, false);

            if (vote == NO) {
                self.no_votes.write(self.no_votes.read() + 1_u8);
            }
            if (vote == YES) {
                self.yes_votes.write(self.yes_votes.read() + 1_u8);
            }

            self.emit(VoteCast { voter: caller, vote: vote });
        }
    }

    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _register_voters(
            ref self: ContractState,
            voter_1: ContractAddress,
            voter_2: ContractAddress,
            voter_3: ContractAddress,
        ) {
            self.registered_voter.write(voter_1, true);
            self.can_vote.write(voter_1, true);

            self.registered_voter.write(voter_2, true);
            self.can_vote.write(voter_2, true);

            self.registered_voter.write(voter_3, true);
            self.can_vote.write(voter_3, true);
        }
    }

    #[generate_trait]
    impl AssertsImpl of AssertsTrait {
        fn _assert_allowed(ref self: ContractState, address: ContractAddress) {
            let is_voter: bool = self.registered_voter.read((address));
            let can_vote: bool = self.can_vote.read((address));

            if (!can_vote) {
                self.emit(UnauthorizedAttempt { unauthorized_address: address });
            }

            assert!(is_voter, "USER_NOT_REGISTERED");
            assert!(can_vote, "USER_ALREADY_VOTED");
        }
    }

    #[generate_trait]
    impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {
        fn _get_voting_result(self: @ContractState) -&gt; (u8, u8) {
            let n_yes: u8 = self.yes_votes.read();
            let n_no: u8 = self.no_votes.read();

            (n_yes, n_no)
        }

        fn _get_voting_result_in_percentage(self: @ContractState) -&gt; (u8, u8) {
            let n_yes: u8 = self.yes_votes.read();
            let n_no: u8 = self.no_votes.read();

            let total_votes: u8 = n_yes + n_no;

            if (total_votes == 0_u8) {
                return (0, 0);
            }
            let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);
            let no_percentage: u8 = (n_no * 100_u8) / (total_votes);

            (yes_percentage, no_percentage)
        }
    }
}
</code></pre>
<p>17-8: A voting smart contract</span></p>
<h2 id="deploying-calling-and-invoking-the-voting-contract"><a class="header" href="#deploying-calling-and-invoking-the-voting-contract">Deploying, Calling and Invoking the Voting Contract</a></h2>
<p>Part of the Starknet experience is deploying and interacting with smart
contracts.</p>
<p>Once the contract is deployed, we can interact with it by calling and invoking
its functions:</p>
<ul>
<li>Calling contracts: Interacting with external functions that only read from the
state. These functions do not alter the state of the network, so they don't
require fees or signing.</li>
<li>Invoking contracts: Interacting with external functions that can write to the
state. These functions do alter the state of the network and require fees and
signing.</li>
</ul>
<p>We will setup a local development node using <code>katana</code> to deploy the voting
contract. Then, we'll interact with the contract by calling and invoking its
functions. You can also use the Goerli Testnet instead of <code>katana</code>. However, we
recommend using <code>katana</code> for local development and testing. You can find the
complete tutorial for <code>katana</code> in the <a href="https://docs.starknet.io/quick-start/using_devnet/">"Using a development
network"</a> chapter of the Starknet Docs.</p>
<h3 id="the-katana-local-starknet-node"><a class="header" href="#the-katana-local-starknet-node">The <code>katana</code> Local Starknet Node</a></h3>
<p><code>katana</code> is designed to support local development by the <a href="https://book.dojoengine.org/toolchain/katana">Dojo
team</a>. It will allow you to do everything you need to do with
Starknet, but locally. It is a great tool for development and testing.</p>
<p>To install <code>katana</code> from the source code, please refer to the <a href="https://book.dojoengine.org/toolchain/katana#getting-started">"Using
Katana"</a> chapter of the Dojo Engine.</p>
<blockquote>
<p>Note: Please verify that the version of <code>katana</code> match the specified version
provided below.</p>
<pre><code class="language-bash">$ katana --version
katana 1.0.9-dev (38b3c2a6)
</code></pre>
<p>To upgrade <code>katana</code> version, refer to the <a href="https://book.dojoengine.org/toolchain/katana#getting-started">"Using
Katana"</a> chapter of the Dojo Engine.</p>
</blockquote>
<p>Once you have <code>katana</code> installed, you can start the local Starknet node with:</p>
<pre><code class="language-bash">katana
</code></pre>
<p>This command will start a local Starknet node with predeployed accounts. We will
use these accounts to deploy and interact with the voting contract:</p>
<pre><code class="language-bash">...
PREFUNDED ACCOUNTS
==================

| Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0
| Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600
| Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e

| Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c
| Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b
| Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d

| Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5
| Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c
| Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc
...
</code></pre>
<p>Before we can interact with the voting contract, we need to prepare the voter
and admin accounts on Starknet. Each voter account must be registered and
sufficiently funded for voting. For a more detailed understanding of how
accounts operate with Account Abstraction, refer to the <a href="https://docs.starknet.io/architecture-and-concepts/accounts/introduction/#account_abstraction">"Account
Abstraction"</a> chapter of the Starknet Docs.</p>
<h3 id="smart-wallets-for-voting"><a class="header" href="#smart-wallets-for-voting">Smart Wallets for Voting</a></h3>
<p>Aside from Scarb you will need to have Starkli installed. Starkli is a command
line tool that allows you to interact with Starknet. You can find the
installation instructions in the <a href="https://docs.starknet.io/quick-start/environment-setup/">"Setting up Starkli"</a>
chapter of the Starknet Docs.</p>
<blockquote>
<p>Note: Please verify that the version of <code>starkli</code> match the specified version
provided below.</p>
<pre><code class="language-bash">$ starkli --version
0.3.6 (8d6db8c)
</code></pre>
<p>To upgrade <code>starkli</code> to <code>0.3.6</code>, use the <code>starkliup -v 0.3.6</code> command, or
simply <code>starkliup</code> which installed the latest stable version.</p>
</blockquote>
<p>You can retrieve the smart wallet class hash (it will be the same for all your
smart wallets) with the following command. Notice the use of the <code>--rpc</code> flag
and the RPC endpoint provided by <code>katana</code>:</p>
<pre><code>starkli class-hash-at &lt;SMART_WALLET_ADDRESS&gt; --rpc http://0.0.0.0:5050
</code></pre>
<h3 id="contract-deployment"><a class="header" href="#contract-deployment">Contract Deployment</a></h3>
<p>Before deploying, we need to declare the contract. We can do this with the
<code>starkli declare</code> command:</p>
<pre><code class="language-bash">starkli declare target/dev/listing_99_12_vote_contract_Vote.contract_class.json --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>If the compiler version you're using is older than the one used by Starkli and
you encounter a <code>compiler-version</code> error while using the command above, you can
specify a compiler version to use in the command by adding the
<code>--compiler-version x.y.z</code> flag.</p>
<p>If you're still encountering issues with the compiler version, try upgrading
Starkli using the command: <code>starkliup</code> to make sure you're using the latest
version of starkli.</p>
<p>The class hash of the contract is:
<code>0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52</code>. You can
declare this contract on Sepolia testnet and see that the class hash will
correspond.</p>
<p>The <code>--rpc</code> flag specifies the RPC endpoint to use (the one provided by
<code>katana</code>). The <code>--account</code> flag specifies the account to use for signing the
transaction.</p>
<p>Since we are using a local node, the transaction will achieve finality
immediately. If you are using the Goerli Testnet, you will need to wait for the
transaction to be final, which usually takes a few seconds.</p>
<p>The following command deploys the voting contract and registers voter_0,
voter_1, and voter_2 as eligible voters. These are the constructor arguments, so
add a voter account that you can later vote with.</p>
<pre><code class="language-bash">starkli deploy &lt;class_hash_of_the_contract_to_be_deployed&gt; &lt;voter_0_address&gt; &lt;voter_1_address&gt; &lt;voter_2_address&gt; --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>An example command:</p>
<pre><code class="language-bash">starkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>In this case, the contract has been deployed at an specific address:
<code>0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349</code>. This
address will be different for you. We will use this address to interact with the
contract.</p>
<h3 id="voter-eligibility-verification"><a class="header" href="#voter-eligibility-verification">Voter Eligibility Verification</a></h3>
<p>In our voting contract, we have two functions to validate voter eligibility,
<code>voter_can_vote</code> and <code>is_voter_registered</code>. These are external read functions,
which mean they don't alter the state of the contract but only read the current
state.</p>
<p>The <code>is_voter_registered</code> function checks whether a particular address is
registered as an eligible voter in the contract. The <code>voter_can_vote</code> function,
on the other hand, checks whether the voter at a specific address is currently
eligible to vote, i.e., they are registered and haven't voted already.</p>
<p>You can call these functions using the <code>starkli call</code> command. Note that the
<code>call</code> command is used for read functions, while the <code>invoke</code> command is used
for functions that can also write to storage. The <code>call</code> command does not
require signing, while the <code>invoke</code> command does.</p>
<pre><code class="language-bash+">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050
</code></pre>
<p>First we added the address of the contract, then the function we want to call,
and finally the input for the function. In this case, we are checking whether
the voter at the address
<code>0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0</code> can vote.</p>
<p>Since we provided a registered voter address as an input, the result is 1
(boolean true), indicating the voter is eligible to vote.</p>
<p>Next, let's call the <code>is_voter_registered</code> function using an unregistered
account address to observe the output:</p>
<pre><code class="language-bash">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050
</code></pre>
<p>With an unregistered account address, the terminal output is 0 (i.e., false),
confirming that the account is not eligible to vote.</p>
<h3 id="casting-a-vote"><a class="header" href="#casting-a-vote">Casting a Vote</a></h3>
<p>Now that we have established how to verify voter eligibility, we can vote! To
vote, we interact with the <code>vote</code> function, which is flagged as external,
necessitating the use of the <code>starknet invoke</code> command.</p>
<p>The <code>invoke</code> command syntax resembles the <code>call</code> command, but for voting, we
submit either <code>1</code> (for Yes) or <code>0</code> (for No) as our input. When we invoke the
<code>vote</code> function, we are charged a fee, and the transaction must be signed by the
voter; we are writing to the contract's storage.</p>
<pre><code class="language-bash">//Voting Yes
starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0

//Voting No
starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>You will be prompted to enter the password for the signer. Once you enter the
password, the transaction will be signed and submitted to the Starknet network.
You will receive the transaction hash as output. With the starkli transaction
command, you can get more details about the transaction:</p>
<pre><code class="language-bash">starkli transaction &lt;TRANSACTION_HASH&gt; --rpc http://0.0.0.0:5050
</code></pre>
<p>This returns:</p>
<pre><code class="language-bash">{
  "transaction_hash": "0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd",
  "max_fee": "0x430e81",
  "version": "0x1",
  "signature": [
    "0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57",
    "0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51"
  ],
  "nonce": "0x3",
  "type": "INVOKE",
  "sender_address": "0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0",
  "calldata": [
    "0x1",
    "0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349",
    "0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41",
    "0x0",
    "0x1",
    "0x1",
    "0x1"
  ]
}
</code></pre>
<p>If you try to vote twice with the same signer you will get an error:</p>
<pre><code class="language-bash">Error: code=ContractError, message="Contract error"
</code></pre>
<p>The error is not very informative, but you can get more details when looking at
the output in the terminal where you started <code>katana</code> (our local Starknet node):</p>
<pre><code class="language-bash">...
Transaction execution error: "Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):
    Error at pc=0:81:
    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \"USER_ALREADY_VOTED\".
    ...
</code></pre>
<p>The key for the error is <code>USER_ALREADY_VOTED</code>.</p>
<pre><code class="language-bash">assert!(can_vote, "USER_ALREADY_VOTED");
</code></pre>
<p>We can repeat the process to create Signers and Account Descriptors for the
accounts we want to use for voting. Remember that each Signer must be created
from a private key, and each Account Descriptor must be created from a public
key, a smart wallet address, and the smart wallet class hash (which is the same
for each voter).</p>
<pre><code class="language-bash">starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0

starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<h3 id="visualizing-vote-outcomes"><a class="header" href="#visualizing-vote-outcomes">Visualizing Vote Outcomes</a></h3>
<p>To examine the voting results, we invoke the <code>get_vote_status</code> function, another
view function, through the <code>starknet call</code> command.</p>
<pre><code class="language-bash">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050
</code></pre>
<p>The output reveals the tally of "Yes" and "No" votes along with their relative
percentages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-erc20-tokens"><a class="header" href="#working-with-erc20-tokens">Working with ERC20 Tokens</a></h1>
<p>The ERC20 standard on Starknet provides a uniform interface for fungible tokens.
This ensures that any fungible token can be used in a predictable way across the
ecosystem. This section explores how to create ERC20 tokens using OpenZeppelin
Contracts for Cairo, which is an audited implementation of the standard.</p>
<blockquote>
<p>Note: While the Openzeppelin components are audited, you should always test
and ensure that your code cannot be exploited. Examples provided in this
section are for educational purposes only and cannot be used in production.</p>
</blockquote>
<p>First, we will build a basic ERC20 token with a fixed supply. This contract
demonstrates the core structure for creating a token using OpenZeppelin's
components.</p>
<h2 id="the-basic-erc20-contract"><a class="header" href="#the-basic-erc20-contract">The Basic ERC20 Contract</a></h2>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod BasicERC20 {
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_supply: u256, recipient: ContractAddress) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }
}
</code></pre>
<p>basic ERC20 token implementation using OpenZeppelin</span></p>
<h3 id="understanding-the-implementation"><a class="header" href="#understanding-the-implementation">Understanding the Implementation</a></h3>
<p>This contract is built using OpenZeppelin's component system. It embeds the
<code>ERC20Component</code>, which contains all the core logic for an ERC20 token,
including functions for transfers, approvals, and balance tracking. To make
these functions directly available on the contract, we implement the
<code>ERC20MixinImpl</code> trait. This pattern avoids the need to write boilerplate code
for each function in the ERC20 interface.</p>
<p>When the contract is deployed, its constructor is called. The constructor first
initializes the token's metadata—its name and symbol—by calling the
<code>initializer</code> function on the ERC20 component. It then mints the entire initial
supply and assigns it to the address that deployed the contract. Since there are
no other functions to create new tokens, the total supply is fixed from the
moment of deployment.</p>
<p>The contract's storage is minimal, and only contains the state of the
<code>ERC20Component</code>. This includes mappings to track token balances and allowances,
as well as the token's name, symbol, and total supply, but is abstracted from
the perspective of the contract.</p>
<p>The contract we just implemented is rather simple: it is a fixed-supply token,
with no additional features. But we can also use the OpenZeppelin components
libraries to build more complex tokens!</p>
<p>The following examples show how to add new functionalities while maintaining
compliance with the ERC20 standard.</p>
<h3 id="mintable-and-burnable-token"><a class="header" href="#mintable-and-burnable-token">Mintable and Burnable Token</a></h3>
<p>This extension adds functions to mint new tokens and burn existing ones,
allowing the token supply to change after deployment. This is useful for tokens
whose supply needs to be adjusted based on protocol activity or governance.</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod MintableBurnableERC20 {
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        let name = "MintableBurnableToken";
        let symbol = "MBT";

        self.erc20.initializer(name, symbol);
        self.ownable.initializer(owner);
    }

    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        // Only owner can mint new tokens
        self.ownable.assert_only_owner();
        self.erc20.mint(recipient, amount);
    }

    #[external(v0)]
    fn burn(ref self: ContractState, amount: u256) {
        // Any token holder can burn their own tokens
        let caller = starknet::get_caller_address();
        self.erc20.burn(caller, amount);
    }
}
</code></pre>
<p>17-10: ERC20 with mint and burn capabilities</span></p>
<p>This contract introduces the <code>OwnableComponent</code> to manage access control. The
address that deploys the contract becomes its owner. The <code>mint</code> function is
restricted to the owner, who can create new tokens and assign them to any
address, thereby increasing the total supply.</p>
<p>The <code>burn</code> function allows any token holder to destroy their own tokens. This
action permanently removes the tokens from circulation and reduces the total
supply.</p>
<p>To make these functions exposed to the public, we simply mark them as
<code>#[external]</code> in the contract. They become part of the contract's entrypoint,
and anyone can call them.</p>
<h3 id="pausable-token-with-access-control"><a class="header" href="#pausable-token-with-access-control">Pausable Token with Access Control</a></h3>
<p>This second extension introduces a more complex security model with role-based
permissions and an emergency pause feature. This pattern is useful for protocols
that need fine-grained control over operations and a way to halt activities
during a crisis (e.g. a security incident).</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod PausableERC20 {
    use openzeppelin::access::accesscontrol::AccessControlComponent;
    use openzeppelin::introspection::src5::SRC5Component;
    use openzeppelin::security::pausable::PausableComponent;
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component};
    use starknet::ContractAddress;

    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl&lt;ContractState&gt;;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl&lt;ContractState&gt;;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl&lt;ContractState&gt;;

    // Pausable
    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl&lt;ContractState&gt;;
    impl PausableInternalImpl = PausableComponent::InternalImpl&lt;ContractState&gt;;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        PausableEvent: PausableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    // ERC20 Hooks implementation
    impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait&lt;ContractState&gt; {
        fn before_update(
            ref self: ERC20Component::ComponentState&lt;ContractState&gt;,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) {
            let contract_state = self.get_contract();
            // Check that the contract is not paused
            contract_state.pausable.assert_not_paused();
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState, admin: ContractAddress) {
        let name = "PausableToken";
        let symbol = "PST";

        self.erc20.initializer(name, symbol);

        // Grant admin role
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(AccessControlComponent::DEFAULT_ADMIN_ROLE, admin);

        // Grant specific roles to admin
        self.accesscontrol._grant_role(PAUSER_ROLE, admin);
        self.accesscontrol._grant_role(MINTER_ROLE, admin);
    }

    #[external(v0)]
    fn pause(ref self: ContractState) {
        self.accesscontrol.assert_only_role(PAUSER_ROLE);
        self.pausable.pause();
    }

    #[external(v0)]
    fn unpause(ref self: ContractState) {
        self.accesscontrol.assert_only_role(PAUSER_ROLE);
        self.pausable.unpause();
    }

    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }
}
</code></pre>
<p>ERC20 with pausable transfers and role-based access control</span></p>
<p>This implementation combines four components: <code>ERC20Component</code> for token
functions, <code>AccessControlComponent</code> for managing roles, <code>PausableComponent</code> for
the emergency stop mechanism, and <code>SRC5Component</code> for interface detection. The
contract defines two roles: <code>PAUSER_ROLE</code>, which can pause and unpause the
contract, and <code>MINTER_ROLE</code>, which can create new tokens.</p>
<p>Unlike a single owner, this role-based system allows for the separation of
administrative duties. The main administrator can grant the <code>PAUSER_ROLE</code> to a
security team and the <code>MINTER_ROLE</code> to a treasury manager.</p>
<p>The pause functionality is integrated into the token's transfer logic using a
hook system. The contract implements the <code>ERC20HooksTrait</code>, and its
<code>before_update</code> function is automatically called before any token transfer or
approval. This function checks if the contract is paused. If an address with the
<code>PAUSER_ROLE</code> has paused the contract, all transfers are blocked until it is
unpaused. This hook system is an elegant way of extending the base
functionalities of the ERC20 standard functions, without re-defining them.</p>
<p>At deployment, the constructor grants all roles to the deployer, who can then
delegate these roles to other addresses as needed.</p>
<p>These extended implementations show how OpenZeppelin's components can be
combined to build complex and secure contracts. By starting with standard,
audited components, developers can add custom features without compromising on
security or standards compliance.</p>
<p>For more advanced features and detailed documentation, refer to the
<a href="https://docs.openzeppelin.com/contracts-cairo/">OpenZeppelin Contracts for Cairo documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-smart-contracts-security"><a class="header" href="#starknet-smart-contracts-security">Starknet Smart Contracts Security</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-recommendations"><a class="header" href="#general-recommendations">General Recommendations</a></h1>
<p>We've been focusing so far on learning how to write Cairo Code, which is the
minimum for your programs to come to life; but writing <em>secure</em> code is just as
important. This chapter distills was written inspired from a large corpus of
real Cairo/Starknet audits compiled into concrete instructions you can use while
coding, testing, and reviewing your contracts.</p>
<p>We'll focus on:</p>
<ul>
<li>Access control and upgrades</li>
<li>Safe ERC20 token integrations</li>
<li>Cairo-specific pitfalls that could lead to vulnerabilities</li>
<li>Cross-domain/bridging safety</li>
<li>Economic/DoS must-knowns on Starknet</li>
</ul>
<h2 id="access-control-upgrades--initializers"><a class="header" href="#access-control-upgrades--initializers">Access Control, Upgrades &amp; Initializers</a></h2>
<p>The most common criticals in Starknet audits are still “who can call this?” and
“can this be (re)initialized?” issues. Cairo has great simple building blocks
whose logic you should reuse to focus on the core security aspects of your
program.</p>
<h3 id="own-your-privileged-paths"><a class="header" href="#own-your-privileged-paths">Own your privileged paths</a></h3>
<p>Always make sure that upgrades can only be done by authorized roles. If a
non-authorized user can upgrade your contract, it can replace the class with
anything and get full control over the contract. The same applies for
pause/resume functions, bridge handlers (who can call this contract from L1),
and meta-execution. All these critical functions should be guarded using the
OwnableComponent from OpenZeppelin.</p>
<pre><code class="language-cairo  noplayground">// components
component!(path: OwnableComponent, storage: ownable);
component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

#[abi(embed_v0)]
impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
impl InternalUpgradeableImpl = UpgradeableComponent::InternalImpl&lt;ContractState&gt;;

#[event]
fn Upgraded(new_class_hash: felt252) {}

fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
    self.ownable.assert_only_owner();
    self.upgradeable._upgrade(new_class_hash);
    Upgraded(new_class_hash); // emit explicit upgrade event
}
</code></pre>
<p><strong>Why emit events?</strong> Incident response and indexers depend on them. Emit for
upgrades, configuration changes, pausing, liquidations, and any privileged
action; include addresses (e.g., token) to remove ambiguity.</p>
<h3 id="initializers-should-only-be-called-once"><a class="header" href="#initializers-should-only-be-called-once">Initializers should only be called once</a></h3>
<p>A frequent vulnerability vector is a publicly exposed initializer that can be
called post-deploy. The purpose of an initializer is to de-couple the deployment
and the initialization of the contract. However, if the initializer can be
called multiple times, it can have unexpected consequences. Make sure the
behavior is idempotent.</p>
<pre><code class="language-cairo  noplayground">#[storage]
struct Storage {
    _initialized: u8,
    // ...
}

fn initializer(ref self: ContractState, owner: ContractAddress) {
    assert!(self._initialized.read() == 0, "ALREADY_INIT");
    self._initialized.write(1);
    self.ownable.initialize(owner);
    // init the rest…
}
</code></pre>
<blockquote>
<p>Rule: if it <em>must</em> be external during deployment, make sure it can only be
called once; if it doesn't need to be external, keep it internal.</p>
</blockquote>
<h2 id="token-integrations"><a class="header" href="#token-integrations">Token Integrations</a></h2>
<h3 id="always-check-boolean-returns"><a class="header" href="#always-check-boolean-returns">Always check boolean returns</a></h3>
<p>While the OpenZeppelin ERC20 implementation reverts on failure, it is not all
ERC-20 implementations that do. Some might return <code>false</code> instead, without
panicking. The <code>transfer</code> and <code>transfer_from</code> return boolean flags; verify them
to ensure the transfers were successful.</p>
<h3 id="camelcase--snake_case-dual-interfaces"><a class="header" href="#camelcase--snake_case-dual-interfaces">CamelCase / snake_case dual interfaces</a></h3>
<p>Most ERC20 tokens on starknet should use the <code>snake_case</code> naming style. However,
for legacy reasons, some old ERC20 tokens have <code>camelCase</code> entrypoints, which
might cause issues if your contracts calls them expecting to find <code>snake_case</code>.
Handling both naming styles is cumbersome; but you should at least ensure that
most tokens you'll be interacting with use the <code>snake_case</code> naming style, or
adapt your contracts.</p>
<h2 id="cairo-specific-pitfalls"><a class="header" href="#cairo-specific-pitfalls">Cairo-Specific Pitfalls</a></h2>
<p>The Cairo language itself does not have very complicated semantics that could
introduce vulnerabilities, but there are some regular programming patterns that
could lead to unwanted behavior.</p>
<h3 id="operator-precedence-in-expressions"><a class="header" href="#operator-precedence-in-expressions">Operator precedence in expressions</a></h3>
<p>In Cairo, <code>&amp;&amp;</code> has higher precedence than <code>||</code>. Make sure that combined
expressions are properly parenthesized to force precedence between operators.</p>
<pre><code class="language-cairo  noplayground">// ❌ buggy: ctx.coll_ok and ctx.debt_ok are only required in Recovery
assert!(
    mode == Mode::None || mode == Mode::Recovery &amp;&amp; ctx.coll_ok &amp;&amp; ctx.debt_ok,
    "EMERGENCY_MODE"
);

// ✅ fixed
assert!(
    (mode == Mode::None || mode == Mode::Recovery) &amp;&amp; (ctx.coll_ok &amp;&amp; ctx.debt_ok),
    "EMERGENCY_MODE"
);
</code></pre>
<h3 id="unsigned-loop-underflow"><a class="header" href="#unsigned-loop-underflow">Unsigned loop underflow</a></h3>
<p>Using a <code>u32</code> for a loop counter could lead to an underflow panic if that
counter is decremented past 0. If the counter is supposed to handle negative
values, use a <code>i32</code> instead.</p>
<pre><code class="language-cairo  noplayground">// ✅ prefer signed counters or explicit break
let mut i: i32 = (n.try_into().unwrap()) - 1;
while i &gt;= 0 { // This would never trigger if `i` was a u32.
    // ...
    i -= 1;
}
</code></pre>
<h3 id="bit-packing-into-felt252"><a class="header" href="#bit-packing-into-felt252">Bit-packing into <code>felt252</code></a></h3>
<p>Packing multiple fields into one <code>felt252</code> is great for optimizations, but it is
also common and dangerous without tight bounds. Make sure to check the bounds of
the fields before packing them into a <code>felt252</code>. Notably, the sum of the size of
the values packed should not exceed 251 bits.</p>
<pre><code class="language-cairo  noplayground">fn pack_order(book_id: u256, tick_u24: u256, index_u40: u256) -&gt; felt252 {
    // width checks
    assert!(book_id &lt; (1_u256 * POW_2_187), "BOOK_OVER");
    assert!(tick_u24 &lt; (1_u256 * POW_2_24),  "TICK_OVER");
    assert!(index_u40 &lt; (1_u256 * POW_2_40), "INDEX_OVER");

    let packed: u256 =
        (book_id * POW_2_64) + (tick_u24 * POW_2_40) + index_u40;
    packed.try_into().expect("PACK_OVERFLOW")
}
</code></pre>
<p><span class="caption"> A bit packing that could fail if the values are too big.
</span></p>
<h3 id="deploy_syscalldeploy_from_zerotrue-collisions"><a class="header" href="#deploy_syscalldeploy_from_zerotrue-collisions"><code>deploy_syscall(deploy_from_zero=true)</code> collisions</a></h3>
<p>Deterministic deployment from zero enables could lead to collisions if two
contracts are attempted to be deployed with the same calldata. Make sure to set
<code>deploy_from_zero</code> to <code>false</code> unless you are sure you want to deploy from zero.</p>
<h3 id="dont-check-get_caller_addressis_zero"><a class="header" href="#dont-check-get_caller_addressis_zero">Don’t check <code>get_caller_address().is_zero()</code></a></h3>
<p>Inherited from Solidity are zero-address checks. On Starknet,
<code>get_caller_address()</code> is never the zero address. Thus, these checks are
useless.</p>
<h2 id="cross-domain--bridging-safety"><a class="header" href="#cross-domain--bridging-safety">Cross-Domain / Bridging Safety</a></h2>
<p>L1-L2 interactions are specific to how Starknet works, and can be a source of
mistakes.</p>
<h3 id="l1-handler-must-validate-the-caller-address"><a class="header" href="#l1-handler-must-validate-the-caller-address">L1 handler must validate the caller address</a></h3>
<p>The <code>#[l1_handler]</code> attribute marks an entrypoint as callable from a contract on
L1. In most cases, you will want to ensure that the source of that call is a
trusted L1 contract - and as such, you should validate the caller address.</p>
<pre><code class="language-cairo  noplayground">#[l1_handler]
fn handle_deposit(
    ref self: ContractState,
    from_address: ContractAddress,
    account: ContractAddress,
    amount: u256
) {
    let l1_bridge = self._l1_bridge.read();
    assert!(!l1_bridge.is_zero(), 'UNINIT_BRIDGE');
    assert!(from_address == l1_bridge, 'ONLY_L1_BRIDGE');
    // credit account…
}
</code></pre>
<h2 id="economicdos--griefing"><a class="header" href="#economicdos--griefing">Economic/DoS &amp; Griefing</a></h2>
<h3 id="unbounded-loops"><a class="header" href="#unbounded-loops">Unbounded loops</a></h3>
<p>User-controlled iterations (claims, batch withdrawals, order sweeps) can exceed
the Starknet steps limit. Make sure to cap the number of iterations and/or use a
pagination pattern to split the work into multiple transactions.</p>
<p>Notably, imagine that you are implementing a system in which when called, a
function will iterate over a list of items in storage and process them. If the
list is not bounded, an attacker could increase the amount of items in that
list, such that the function will never terminate as it will reach the execution
step limit of Starknet.</p>
<p>In that case, the contract is bricked: It will not be possible for <em>anyone</em> to
interact with it anymore, as any interaction will trigger the step limit.</p>
<p>To bypass that, you could for example use a pagination pattern, where the
function will process a maximum number of items at a time, and return the next
cursor to the caller. The caller can then call the function again with the next
cursor to process the next batch of items.</p>
<pre><code class="language-cairo  noplayground">fn claim_withdrawals(ref self: ContractState, start: u64, max: u64) -&gt; u64 {
    let mut i = start;
    let end = core::cmp::min(self.pending_count.read(), start + max);
    while i &lt; end {
        self._process(i);
        i += 1;
    }
    end // next cursor
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-smart-contracts"><a class="header" href="#testing-smart-contracts">Testing Smart Contracts</a></h1>
<p>Testing smart contracts is a critical part of the development process. It is
important to ensure that smart contracts behave as expected and that they are
secure.</p>
<p>In a previous section of the Cairo Book, we learned how to write and structure
our tests for Cairo programs. We demonstrated how these tests could be run using
the <code>scarb</code> command-line tool. While this approach is useful for testing
standalone Cairo programs and functions, it lacks functionality for testing
smart contracts that require control over the contract state and execution
context. Therefore, in this section, we will introduce how to use Starknet
Foundry, a smart contract development toolchain for Starknet, to test your Cairo
contracts.</p>
<p>Throughout this chapter, we will be using as an example the <code>PizzaFactory</code>
contract in Listing 18-1 to demonstrate how to write tests
with Starknet Foundry.</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait IPizzaFactory&lt;TContractState&gt; {
    fn increase_pepperoni(ref self: TContractState, amount: u32);
    fn increase_pineapple(ref self: TContractState, amount: u32);
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn change_owner(ref self: TContractState, new_owner: ContractAddress);
    fn make_pizza(ref self: TContractState);
    fn count_pizza(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
pub mod PizzaFactory {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ContractAddress, get_caller_address};
    use super::IPizzaFactory;

    #[storage]
    pub struct Storage {
        pepperoni: u32,
        pineapple: u32,
        pub owner: ContractAddress,
        pizzas: u32,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.pepperoni.write(10);
        self.pineapple.write(10);
        self.owner.write(owner);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PizzaEmission: PizzaEmission,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PizzaEmission {
        pub counter: u32,
    }

    #[abi(embed_v0)]
    impl PizzaFactoryimpl of super::IPizzaFactory&lt;ContractState&gt; {
        fn increase_pepperoni(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pepperoni.write(self.pepperoni.read() + amount);
        }

        fn increase_pineapple(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pineapple.write(self.pineapple.read() + amount);
        }

        fn make_pizza(ref self: ContractState) {
            assert!(self.pepperoni.read() &gt; 0, "Not enough pepperoni");
            assert!(self.pineapple.read() &gt; 0, "Not enough pineapple");

            let caller: ContractAddress = get_caller_address();
            let owner: ContractAddress = self.get_owner();

            assert!(caller == owner, "Only the owner can make pizza");

            self.pepperoni.write(self.pepperoni.read() - 1);
            self.pineapple.write(self.pineapple.read() - 1);
            self.pizzas.write(self.pizzas.read() + 1);

            self.emit(PizzaEmission { counter: self.pizzas.read() });
        }

        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
            self.set_owner(new_owner);
        }

        fn count_pizza(self: @ContractState) -&gt; u32 {
            self.pizzas.read()
        }
    }

    #[generate_trait]
    pub impl InternalImpl of InternalTrait {
        fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
            let caller: ContractAddress = get_caller_address();
            assert!(caller == self.get_owner(), "Only the owner can set ownership");

            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p><span class="caption">Listing 18-1: A pizza factory that needs
to be tested</span></p>
<h2 id="configuring-your-scarb-project-with-starknet-foundry"><a class="header" href="#configuring-your-scarb-project-with-starknet-foundry">Configuring your Scarb project with Starknet Foundry</a></h2>
<p>The settings of your Scarb project can be configured in the <code>Scarb.toml</code> file.
To use Starknet Foundry as your testing tool, you will need to add it as a dev
dependency in your <code>Scarb.toml</code> file. Adapt the version you use to the latest
version.</p>
<pre><code class="language-toml noplayground">[dev-dependencies]
snforge_std = "0.51.1"

[scripts]
test = "snforge test"

[tool.scarb]
allow-prebuilt-plugins = ["snforge_std"]
</code></pre>
<p>The <code>scarb test</code> command is configured to execute <code>snforge test</code> by default.
This allows us to run our tests using Starknet Foundry when we run the
<code>scarb test</code> command.</p>
<p>Once your project is configured, you will need to install Starknet Foundry by
following the installation guide from the
<a href="https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html">Starknet Foundry Documentation</a>.
As usual, we recommend to use <code>asdf</code> to manage versions of your development
tools.</p>
<h2 id="testing-smart-contracts-with-starknet-foundry"><a class="header" href="#testing-smart-contracts-with-starknet-foundry">Testing Smart Contracts with Starknet Foundry</a></h2>
<p>The usual command to run your tests using Starknet Foundry is <code>snforge test</code>.
The <code>scarb test</code> command is an alias that executes <code>snforge test</code> under the
hood. Therefore, during the rest of this chapter, we will use the <code>scarb test</code>
command, which runs <code>snforge test</code>.</p>
<p>The usual testing flow of a contract is as follows:</p>
<ol>
<li>Declare the class of the contract to test, identified by its name</li>
<li>Serialize the constructor calldata into an array</li>
<li>Deploy the contract and retrieve its address</li>
<li>Interact with the contract's entrypoint to test various scenarios</li>
</ol>
<h3 id="deploying-the-contract-to-test"><a class="header" href="#deploying-the-contract-to-test">Deploying the Contract to Test</a></h3>
<p>In Listing 18-2, we wrote a function that deploys the
<code>PizzaFactory</code> contract and sets up the dispatcher for interactions.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span>fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-2: Deploying the
contract to test</span></p>
<h3 id="testing-our-contract"><a class="header" href="#testing-our-contract">Testing our Contract</a></h3>
<p>Determining the behavior that your contract should respect is the first step in
writing tests. In the <code>PizzaFactory</code> contract, we determined that the contract
should have the following behavior:</p>
<ul>
<li>Upon deployment, the contract owner should be set to the address provided in
the constructor, and the factory should have 10 units of pepperoni and
pineapple, and no pizzas created.</li>
<li>If someone tries to make a pizza and they are not the owner, the operation
should fail. Otherwise, the pizza count should be incremented, and an event
should be emitted.</li>
<li>If someone tries to take ownership of the contract and they are not the owner,
the operation should fail. Otherwise, the owner should be updated.</li>
</ul>
<h4 id="accessing-storage-variables-with-load"><a class="header" href="#accessing-storage-variables-with-load">Accessing Storage Variables with <code>load</code></a></h4>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-3: Testing the initial
state by loading storage variables </span></p>
<p>Once our contract is deployed, we want to assert that the initial values are set
as expected. If our contract has an entrypoint that returns the value of a
storage variable, we can call this entrypoint. Otherwise, we can use the <code>load</code>
function from <code>snforge</code> to load the value of a storage variable inside our
contract, even if not exposed by an entrypoint.</p>
<h4 id="mocking-the-caller-address-with-start_cheat_caller_address"><a class="header" href="#mocking-the-caller-address-with-start_cheat_caller_address">Mocking the Caller Address with <code>start_cheat_caller_address</code></a></h4>
<p>The security of our factory relies on the owner being the only one able to make
pizzas and transfer ownership. To test this, we can use the
<code>start_cheat_caller_address</code> function to mock the caller address and assert that
the contract behaves as expected.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>ownership of the contract by mocking the caller address </span></p>
<p>Using <code>start_cheat_caller_address</code>, we call the <code>change_owner</code> function first as
the owner, and then as a different address. We assert that the operation fails
when the caller is not the owner, and that the owner is updated when the caller
is the owner.</p>
<h4 id="capturing-events-with-spy_events"><a class="header" href="#capturing-events-with-spy_events">Capturing Events with <code>spy_events</code></a></h4>
<p>When a pizza is created, the contract emits an event. To test this, we can use
the <code>spy_events</code> function to capture the emitted events and assert that the
event was emitted with the expected parameters. Naturally, we can also assert
that the pizza count was incremented, and that only the owner can make a pizza.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-5: Testing the
events emitted when a pizza is created</span></p>
<h4 id="accessing-internal-functions-with-contract_state_for_testing"><a class="header" href="#accessing-internal-functions-with-contract_state_for_testing">Accessing Internal Functions with <code>contract_state_for_testing</code></a></h4>
<p>All the tests we have seen so far have been using a workflow that involves
deploying the contract and interacting with the contract's entrypoints. However,
sometimes we may want to test the internals of the contract directly, without
deploying the contract.</p>
<p>Recall the struct <code>ContractState</code>, which is used as a parameter to all the
entrypoints of a contract. This struct contains zero-sized fields corresponding
to the storage variables of the contract. The only purpose of these fields is to
allow the Cairo compiler to generate the correct code for accessing the storage
variables. If we could create an instance of this struct, we could access these
storage variables directly, without deploying the contract.</p>
<p>This is exactly what the <code>contract_state_for_testing</code> function does. When you
define a contract with <code>#[starknet::contract]</code>, the Cairo compiler automatically
generates a <code>contract_state_for_testing</code> function in the contract's module
namespace. This function creates an instance of the <code>ContractState</code> struct,
allowing you to call any function that takes a <code>ContractState</code> parameter without
deploying the contract.</p>
<p>To use this approach, you need to import a few things:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span>use starknet::storage::StoragePointerReadAccess;
use starknet::{ContractAddress, contract_address_const};
use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
<span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-6: Imports needed for
testing internals </span></p>
<p>These imports give us:</p>
<ul>
<li><code>StoragePointerReadAccess</code> - to read storage variables directly</li>
<li><code>InternalTrait</code> - to access internal functions like <code>set_owner</code></li>
<li><code>PizzaFactory</code> - to access <code>contract_state_for_testing()</code></li>
</ul>
<p>Now we can write a test that interacts with the contract state directly:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_storage_direct_access() {
    // Get a ContractState instance without deploying the contract
    let mut state = PizzaFactory::contract_state_for_testing();

    // Access storage directly - read initial value (default is 0)
    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());

    // Call internal function directly
    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    // Note: set_owner checks caller == current owner. Since both are zero address
    // initially (no deployment context), this check passes.
    state.set_owner(owner);

    // Verify storage was updated
    assert_eq!(state.owner.read(), owner);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-7: Unit testing our contract
without deployment</span></p>
<p>The test creates a <code>ContractState</code> instance using
<code>PizzaFactory::contract_state_for_testing()</code>, then directly reads and writes
storage variables and calls internal functions.</p>
<blockquote>
<p><strong>Important</strong>: When using <code>contract_state_for_testing</code>, there is no actual
contract deployment context. Functions like <code>get_caller_address()</code> will return
the zero address. In the example above, <code>set_owner</code> checks that the caller
equals the current owner - since both are initially zero, the check passes.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: The two approaches cannot be mixed in the same test. If you deploy
the contract, you interact with it using the dispatcher. If you test internal
functions, you interact with the <code>ContractState</code> object directly.</p>
</blockquote>
<pre><code class="language-bash noplayground">Running 6 test(s) from src/
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_storage_direct_access (l1_gas: ~0, l1_data_gas: ~160, l2_gas: ~77820)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_panic_when_not_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~437290)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_panic_when_not_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~515170)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_increment_pizza_counter (l1_gas: ~0, l1_data_gas: ~480, l2_gas: ~692240)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_constructor (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~360820)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_change_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~637040)
Tests: 6 passed, 0 failed, 0 ignored, 0 filtered out

</code></pre>
<p>The output of the tests shows that all the tests passed successfully, along with
an estimation of the gas consumed by each test.</p>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<p>In this chapter, we learned how to test smart contracts using Starknet Foundry.
We demonstrated how to deploy a contract and interact with it using the
dispatcher. We also showed how to test the contract's behavior by mocking the
caller address and capturing events. Finally, we demonstrated how to test the
internal functions of the contract directly, without deploying the contract.</p>
<p>To learn more about Starknet Foundry, refer to the
<a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-analysis-tools"><a class="header" href="#static-analysis-tools">Static Analysis Tools</a></h1>
<p>Static analysis refers to the process of examining code without its execution,
focusing on its structure, syntax, and properties. It involves analyzing the
source code to identify potential issues, vulnerabilities, or violations of
specified rules.</p>
<p>By defining rules, such as coding conventions or security guidelines, developers
can utilize static analysis tools to automatically check the code against these
standards.</p>
<p>Reference:</p>
<ul>
<li><a href="https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0">Semgrep Cairo 1.0 support</a></li>
<li><a href="https://github.com/crytic/caracal">Caracal, a Starknet static analyzer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-1"><a class="header" href="#appendix-1">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your
Starknet journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a---system-calls"><a class="header" href="#appendix-a---system-calls">Appendix A - System Calls</a></h1>
<p>This chapter is based on the Starknet documentation available at
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/">Starknet Docs</a>.</p>
<p>Writing smart contracts requires various associated operations, such as calling
another contract or accessing the contract’s storage, that standalone programs
do not require.</p>
<p>The Starknet contract language supports these operations by using system calls.
System calls enable a contract to require services from the Starknet OS. You can
use system calls in a function to get information that depends on the broader
state of Starknet, which would otherwise be inaccessible, rather than local
variables that appear in the function’s scope.</p>
<p>Here is a list of the system calls available in Cairo 1.0:</p>
<ul>
<li><a href="appendix-08-system-calls.html#get_block_hash">get_block_hash</a></li>
<li><a href="appendix-08-system-calls.html#get_execution_info">get_execution_info</a></li>
<li><a href="appendix-08-system-calls.html#call_contract">call_contract</a></li>
<li><a href="appendix-08-system-calls.html#deploy">deploy</a></li>
<li><a href="appendix-08-system-calls.html#emit_event">emit_event</a></li>
<li><a href="appendix-08-system-calls.html#library_call">library_call</a></li>
<li><a href="appendix-08-system-calls.html#send_message_to_l1">send_message_to_L1</a></li>
<li><a href="appendix-08-system-calls.html#get_class_hash_at">get_class_hash_at</a></li>
<li><a href="appendix-08-system-calls.html#replace_class">replace_class</a></li>
<li><a href="appendix-08-system-calls.html#storage_read">storage_read</a></li>
<li><a href="appendix-08-system-calls.html#storage_write">storage_write</a></li>
<li><a href="appendix-08-system-calls.html#keccak">keccak</a></li>
<li><a href="appendix-08-system-calls.html#sha256_process_block">sha256_process_block</a></li>
</ul>
<h2 id="get_block_hash"><a class="header" href="#get_block_hash"><code>get_block_hash</code></a></h2>
<h4 id="syntax"><a class="header" href="#syntax">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_block_hash_syscall(
    block_number: u64,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p>Gets the hash of a specific Starknet block within the range of
<code>[first_v0_12_0_block, current_block - 10]</code>.</p>
<h4 id="return-values"><a class="header" href="#return-values">Return Values</a></h4>
<p>Returns the hash of the given block.</p>
<h4 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h4>
<ul>
<li><code>Block number out of range</code>: <code>block_number</code> is greater than
<em><code>current_block</code></em><code>- 10</code>.</li>
<li><code>0</code>: <code>block_number</code> is less than the first block number of v0.12.0.</li>
</ul>
<h4 id="common-library"><a class="header" href="#common-library">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37">syscalls.cairo</a></li>
</ul>
<h2 id="get_execution_info"><a class="header" href="#get_execution_info"><code>get_execution_info</code></a></h2>
<h4 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_execution_info_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-1"><a class="header" href="#description-1">Description</a></h4>
<p>Gets information about the original transaction.</p>
<p>In Cairo 1.0, all block/transaction/execution context getters are batched into
this single system call.</p>
<h4 id="arguments"><a class="header" href="#arguments">Arguments</a></h4>
<p>None.</p>
<h4 id="return-values-1"><a class="header" href="#return-values-1">Return Values</a></h4>
<p>Returns a
<a href="https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8">struct</a>
containing the execution info.</p>
<h4 id="common-library-1"><a class="header" href="#common-library-1">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35">syscalls.cairo</a></li>
</ul>
<h2 id="call_contract"><a class="header" href="#call_contract"><code>call_contract</code></a></h2>
<h4 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn call_contract_syscall(
    address: ContractAddress, entry_point_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-2"><a class="header" href="#description-2">Description</a></h4>
<p>Calls a given contract. This system call expects the address of the called
contract, a selector for a function within that contract, and call arguments.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>An internal call can’t return Err(_) as this is not handled by the sequencer
and the Starknet OS.</p>
<p>If call_contract_syscall fails, this can’t be caught and will therefore result
in the entire transaction being reverted.</p>
</blockquote>
<h4 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h4>
<ul>
<li><em><code>address</code></em>: The address of the contract you want to call.</li>
<li><em><code>entry_point_selector</code></em>: A selector for a function within that contract, can
be computed with the <code>selector!</code> macro.</li>
<li><em><code>calldata</code></em>: The calldata array.</li>
</ul>
<h4 id="return-values-2"><a class="header" href="#return-values-2">Return Values</a></h4>
<p>The call response, of type <code>SyscallResult&lt;Span&lt;felt252&gt;&gt;</code>.</p>
<h4 id="common-library-2"><a class="header" href="#common-library-2">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10">syscalls.cairo</a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> This is considered a lower-level syntax for calling contracts. If
the interface of the called contract is available, then you can use a more
straightforward syntax.</p>
</blockquote>
<h2 id="deploy"><a class="header" href="#deploy"><code>deploy</code></a></h2>
<h4 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn deploy_syscall(
    class_hash: ClassHash,
    contract_address_salt: felt252,
    calldata: Span&lt;felt252&gt;,
    deploy_from_zero: bool,
) -&gt; SyscallResult&lt;(ContractAddress, Span&lt;felt252&gt;)&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-3"><a class="header" href="#description-3">Description</a></h4>
<p>Deploys a new instance of a previously declared class.</p>
<h4 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h4>
<ul>
<li><em><code>class_hash</code></em>: The class hash of the contract to be deployed.</li>
<li><em><code>contract_address_salt</code></em>: The salt, an arbitrary value provided by the
sender. It is used in the computation of the contract’s address.</li>
<li><em><code>calldata</code></em>: The constructor’s calldata. An array of felts.</li>
<li><em><code>deploy_from_zero</code></em>: A flag used for the contract address computation. If not
set, the caller address will be used as the new contract’s deployer address,
otherwise 0 is used.</li>
</ul>
<h4 id="return-values-3"><a class="header" href="#return-values-3">Return Values</a></h4>
<p>A tuple wrapped with SyscallResult where:</p>
<ul>
<li>
<p>The first element is the address of the deployed contract, of type
<code>ContractAddress</code>.</p>
</li>
<li>
<p>The second element is the response array from the contract’s constructor, of
type <code>Span::&lt;felt252&gt;</code>.</p>
</li>
</ul>
<h4 id="common-library-3"><a class="header" href="#common-library-3">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22">syscalls.cairo</a></li>
</ul>
<h2 id="emit_event"><a class="header" href="#emit_event"><code>emit_event</code></a></h2>
<h4 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn emit_event_syscall(
    keys: Span&lt;felt252&gt;, data: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-4"><a class="header" href="#description-4">Description</a></h4>
<p>Emits an event with a given set of keys and data.</p>
<p>For more information and a higher-level syntax for emitting events, see
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/">Starknet events</a>.</p>
<h4 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h4>
<ul>
<li>
<p><em><code>keys</code></em>: The event’s keys. These are analogous to Ethereum’s event topics,
you can use the starknet_getEvents method to filter by these keys.</p>
</li>
<li>
<p><em><code>data</code></em>: The event’s data.</p>
</li>
</ul>
<h4 id="return-values-4"><a class="header" href="#return-values-4">Return Values</a></h4>
<p>None.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>The following example emits an event with two keys, the strings <code>status</code> and
<code>deposit</code> and three data elements: <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<pre><code class="language-cairo noplayground">let keys = ArrayTrait::new();
keys.append('key');
keys.append('deposit');
let values = ArrayTrait::new();
values.append(1);
values.append(2);
values.append(3);
emit_event_syscall(keys, values).unwrap_syscall();
</code></pre>
<h4 id="common-library-4"><a class="header" href="#common-library-4">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30">syscalls.cairo</a></li>
</ul>
<h2 id="library_call"><a class="header" href="#library_call"><code>library_call</code></a></h2>
<h4 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn library_call_syscall(
    class_hash: ClassHash, function_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-5"><a class="header" href="#description-5">Description</a></h4>
<p>Calls the requested function in any previously declared class. The class is only
used for its logic.</p>
<p>This system call replaces the known delegate call functionality from Ethereum,
with the important difference that there is only one contract involved.</p>
<h4 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h4>
<ul>
<li>
<p><em><code>class_hash</code></em>: The hash of the class you want to use.</p>
</li>
<li>
<p><em><code>function_selector</code></em>: A selector for a function within that class, can be
computed with the <code>selector!</code> macro.</p>
</li>
<li>
<p><em><code>calldata</code></em>: The calldata.</p>
</li>
</ul>
<h4 id="return-values-5"><a class="header" href="#return-values-5">Return Values</a></h4>
<p>The call response, of type <code>SyscallResult&lt;Span&lt;felt252&gt;&gt;</code>.</p>
<h4 id="common-library-5"><a class="header" href="#common-library-5">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43">syscalls.cairo</a></li>
</ul>
<h2 id="send_message_to_l1"><a class="header" href="#send_message_to_l1"><code>send_message_to_L1</code></a></h2>
<h4 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn send_message_to_l1_syscall(
    to_address: felt252, payload: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-6"><a class="header" href="#description-6">Description</a></h4>
<p>Sends a message to L1.</p>
<p>This system call includes the message parameters as part of the proof’s output
and exposes these parameters to the <code>StarknetCore</code> contract on L1 once the state
update, including the transaction, is received.</p>
<p>For more information, see Starknet’s
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/">messaging mechanism</a>.</p>
<h4 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h4>
<ul>
<li>
<p><em><code>to_address</code></em>: The recipient’s L1 address.</p>
</li>
<li>
<p><em><code>payload</code></em>: The array containing the message payload.</p>
</li>
</ul>
<h4 id="return-values-6"><a class="header" href="#return-values-6">Return Values</a></h4>
<p>None.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<p>The following example sends a message whose content is <code>(1,2)</code> to the L1
contract whose address is <code>3423542542364363</code>.</p>
<pre><code class="language-cairo noplayground">let payload = ArrayTrait::new();
payload.append(1);
payload.append(2);
send_message_to_l1_syscall(payload).unwrap_syscall();
</code></pre>
<h4 id="common-library-6"><a class="header" href="#common-library-6">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51">syscalls.cairo</a></li>
</ul>
<h2 id="get_class_hash_at"><a class="header" href="#get_class_hash_at"><code>get_class_hash_at</code></a></h2>
<h4 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_class_hash_at_syscall(
    contract_address: ContractAddress,
) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-7"><a class="header" href="#description-7">Description</a></h4>
<p>Gets the class hash of the contract at the given address.</p>
<h4 id="arguments-6"><a class="header" href="#arguments-6">Arguments</a></h4>
<ul>
<li><em><code>contract_address</code></em>: The address of the deployed contract.</li>
</ul>
<h4 id="return-values-7"><a class="header" href="#return-values-7">Return Values</a></h4>
<p>The class hash of the contract's originating code.</p>
<h4 id="common-library-7"><a class="header" href="#common-library-7">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L99">syscalls.cairo</a></li>
</ul>
<h2 id="replace_class"><a class="header" href="#replace_class"><code>replace_class</code></a></h2>
<h4 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn replace_class_syscall(
    class_hash: ClassHash,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-8"><a class="header" href="#description-8">Description</a></h4>
<p>Once <code>replace_class</code> is called, the class of the calling contract (i.e. the
contract whose address is returned by <code>get_contract_address</code> at the time the
syscall is called) will be replaced by the class whose hash is given by the
class_hash argument.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>After calling <code>replace_class</code>, the code currently executing from the old class
will finish running.</p>
<p>The new class will be used from the next transaction onwards or if the
contract is called via the <code>call_contract</code> syscall in the same transaction
(after the replacement).</p>
</blockquote>
<h4 id="arguments-7"><a class="header" href="#arguments-7">Arguments</a></h4>
<ul>
<li><em><code>class_hash</code></em>: The hash of the class you want to use as a replacement.</li>
</ul>
<h4 id="return-values-8"><a class="header" href="#return-values-8">Return Values</a></h4>
<p>None.</p>
<h4 id="common-library-8"><a class="header" href="#common-library-8">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77">syscalls.cairo</a></li>
</ul>
<h2 id="storage_read"><a class="header" href="#storage_read"><code>storage_read</code></a></h2>
<h4 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn storage_read_syscall(
    address_domain: u32, address: StorageAddress,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-9"><a class="header" href="#description-9">Description</a></h4>
<p>Gets the value of a key in the storage of the calling contract.</p>
<p>This system call provides direct access to any possible key in storage, in
contrast with <code>var.read()</code>, which enables you to read storage variables that are
defined explicitly in the contract.</p>
<p>For information on accessing storage by using the storage variables, see
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables">storage variables</a>.</p>
<h4 id="arguments-8"><a class="header" href="#arguments-8">Arguments</a></h4>
<ul>
<li>
<p><em><code>address_domain</code></em>: The domain of the key, used to separate between different
data availability modes. This separation is used in Starknet to offer
different data availability modes. Currently, only the onchain mode (where all
updates go to L1), indicated by domain <code>0</code>, is supported. Other address
domains which will be introduced in the future will behave differently in
terms of publication (in particular, they will not be posted on L1, creating a
tradeoff between cost and security).</p>
</li>
<li>
<p><em><code>address</code></em>: The requested storage address.</p>
</li>
</ul>
<h4 id="return-values-9"><a class="header" href="#return-values-9">Return Values</a></h4>
<p>The value of the key, of type <code>SyscallResult&lt;felt252&gt;</code>.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><code class="language-cairo noplayground">use starknet::storage_access::storage_base_address_from_felt252;

...

let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453)
storage_read_syscall(0, storage_address).unwrap_syscall()
</code></pre>
<h4 id="common-library-9"><a class="header" href="#common-library-9">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60">syscalls.cairo</a></li>
</ul>
<h2 id="storage_write"><a class="header" href="#storage_write"><code>storage_write</code></a></h2>
<h4 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn storage_write_syscall(
    address_domain: u32, address: StorageAddress, value: felt252,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-10"><a class="header" href="#description-10">Description</a></h4>
<p>Sets the value of a key in the storage of the calling contract.</p>
<p>This system call provides direct access to any possible key in storage, in
contrast with <code>var.write()</code>, which enables you to write to storage variables
that are defined explicitly in the contract.</p>
<p>For information on accessing storage by using the storage variables, see
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables">storage variables</a>.</p>
<h4 id="arguments-9"><a class="header" href="#arguments-9">Arguments</a></h4>
<ul>
<li>
<p><em><code>address_domain</code></em>: The domain of the key, used to separate between different
data availability modes. This separation is used in Starknet to offer
different data availability modes. Currently, only the onchain mode (where all
updates go to L1), indicated by domain <code>0</code>, is supported. Other address
domains which will be introduced in the future will behave differently in
terms of publication (in particular, they will not be posted on L1, creating a
tradeoff between cost and security).</p>
</li>
<li>
<p><em><code>address</code></em>: The requested storage address.</p>
</li>
<li>
<p><em><code>value</code></em>: The value to write to the key.</p>
</li>
</ul>
<h4 id="return-values-10"><a class="header" href="#return-values-10">Return Values</a></h4>
<p>None.</p>
<h4 id="common-library-10"><a class="header" href="#common-library-10">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70">syscalls.cairo</a></li>
</ul>
<h2 id="keccak"><a class="header" href="#keccak"><code>keccak</code></a></h2>
<h4 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn keccak_syscall(
    input: Span&lt;u64&gt;,
) -&gt; SyscallResult&lt;u256&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-11"><a class="header" href="#description-11">Description</a></h4>
<p>Computes the Keccak-256 hash of a given input.</p>
<h4 id="arguments-10"><a class="header" href="#arguments-10">Arguments</a></h4>
<ul>
<li><em><code>input</code></em>: A <code>Span&lt;u64&gt;</code> Keccak-256 input.</li>
</ul>
<h4 id="return-values-11"><a class="header" href="#return-values-11">Return Values</a></h4>
<p>Returns the hash result as a <code>u256</code>.</p>
<h4 id="common-library-11"><a class="header" href="#common-library-11">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L107">syscalls.cairo</a></li>
</ul>
<h2 id="sha256_process_block"><a class="header" href="#sha256_process_block"><code>sha256_process_block</code></a></h2>
<h4 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn sha256_process_block_syscall(
    state: core::sha256::Sha256StateHandle, input: Box&lt;[u32; 16]&gt;
) -&gt; SyscallResult&lt;core::sha256::Sha256StateHandle&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="description-12"><a class="header" href="#description-12">Description</a></h4>
<p>Computes the next SHA-256 state of the input with the given state.</p>
<p>This syscall computes the next SHA-256 state by combining the current <code>state</code>
with a 512-bit block of <code>input</code> data.</p>
<h4 id="arguments-11"><a class="header" href="#arguments-11">Arguments</a></h4>
<ul>
<li><em><code>state</code></em>: The current SHA-256 state.</li>
<li><em><code>input</code></em>: The value to be processed into SHA-256.</li>
</ul>
<h4 id="return-values-12"><a class="header" href="#return-values-12">Return Values</a></h4>
<p>Returns a new SHA-256 state of the <code>input</code> data.</p>
<h4 id="common-library-12"><a class="header" href="#common-library-12">Common Library</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/3540731e5b0e78f2f5b1a51d3611418121c19e54/corelib/src/starknet/syscalls.cairo#L106">syscalls.cairo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sierra"><a class="header" href="#sierra">Sierra</a></h1>
<p>Starting with Starknet Alpha v0.11.0, the contract class resulting from
compiling Cairo include instructions in an intermediate representation called
Safe Intermediate Representation, <em>Sierra</em> for short. This new contract class is
then compiled by the sequencer, via the Sierra → Casm compiler, to generate
the Cairo assembly associated with this class. The Casm code is then executed by
the Starknet OS.</p>
<h2 id="why-do-we-need-casm"><a class="header" href="#why-do-we-need-casm">Why do we need Casm?</a></h2>
<p>Starknet is a validity rollup, which means that the execution inside every block
needs to be proven, and this is where STARKs come in handy. However, STARK
proofs can address statements that are formulated in the language of polynomial
constraints, and have no knowledge of smart contract execution. To overcome this
gap, we developed Cairo.</p>
<p>Cairo instructions, previously referred to as Casm, are translated to polynomial
constraints that enforce the correct execution of a program according to the
Cairo semantics defined in
<a href="https://github.com/starknet-io/starknet-stack-resources/blob/main/Cairo/Cairo%20%E2%80%93%20a%20Turing-complete%20STARK-friendly%20CPU%20architecture.pdf"><em>Cairo-a Turing-complete STARK-friendly CPU architecture</em></a>.</p>
<p>Thanks to Cairo, we can formulate the statement "This Starknet block is valid"
in a way that we can prove. Be aware that we can only prove things about Casm.
That is, regardless of what the user sends to the Starknet sequencer, what's
proven is the correct Casm execution.</p>
<p>This means that we need a way to translate Sierra into Casm, and this is
achieved with the Sierra -&gt; Casm compiler.</p>
<h2 id="why-do-we-need-sierra"><a class="header" href="#why-do-we-need-sierra">Why do we need Sierra?</a></h2>
<p>To understand why we chose to add an additional layer between the code that the
user writes and the code that is being proven (Casm), we need to consider more
components in the system, and the limitations of Cairo.</p>
<h3 id="reverted-transactions-unsatisfiable-airs-and-dos-attacks"><a class="header" href="#reverted-transactions-unsatisfiable-airs-and-dos-attacks">Reverted transactions, unsatisfiable AIRs, and DoS attacks</a></h3>
<p>A crucial property of every decentralized L2 is that the sequencers are
guaranteed to be compensated for the work they do. The notion of reverted
transactions is a good example: even if the user's transaction failed mid
execution, the sequencer should be able to include it in a block and charge
execution fees up to the point of failure.</p>
<p>If the sequencer cannot charge for such transactions, then sending transactions
that will eventually fail (after a lot of computation steps) is an obvious DoS
attack on the sequencer. The sequencer cannot look at a transaction and conclude
that it would fail without actually doing the work (this is equivalent to
solving the halting problem).</p>
<p>The obvious solution to the above predicament is to include such transactions in
the block, similar to Ethereum. However, this may not be as simple to do in a
validity rollup. With Cairo Zero, there is no separating layer between user code
and what is being proven.</p>
<p>This means that users can write code which is unprovable in some cases. In fact,
such code is very easy to write, e.g. <code>assert 0=1</code> is a valid Cairo instruction
that cannot be proven, as it translates to polynomial constraints that are not
satisfiable. Any Casm execution that contains this instruction cannot be proven.
Sierra is the layer between user code and the provable statement, that allows us
to make sure all transactions are eventually provable.</p>
<h3 id="safe-casm"><a class="header" href="#safe-casm">Safe Casm</a></h3>
<p>The method by which Sierra guarantees that user code is always provable is by
compiling Sierra instructions to a subset of Casm, which we call "safe Casm".
The important property that we require from safe Casm is being provable for all
inputs. A canonical example for safe Casm is using <code>if/else</code> instructions
instead of <code>assert</code>, that is, making sure all failures are graceful.</p>
<p>To better understand the considerations that go into designing the Sierra →
Casm compiler, consider the <code>find_element</code> function from the common library of
Cairo Zero:</p>
<pre><code>func find_element{range_check_ptr}(array_ptr: felt*, elm_size, n_elms, key) -&gt; (elm_ptr: felt*) {
    alloc_locals;
    local index;
    %{
        ...
    %}
    assert_nn_le(a=index, b=n_elms - 1);
    tempvar elm_ptr = array_ptr + elm_size * index;
    assert [elm_ptr] = key;
    return (elm_ptr=elm_ptr);
}
</code></pre>
<blockquote>
<p>Below we abuse the "Casm" notation by not distinguishing Cairo Zero from Casm
and referring to the above as Casm (while we actually refer to the compilation
result of the above).</p>
</blockquote>
<p>For brevity, we have omitted the hint in the above snippet, but it's clear that
this function can only execute correctly if the requested element exists in the
array (otherwise it would fail for every possible hint - there is nothing we can
substitute <code>index</code> for, that makes the following lines run successfully).</p>
<p>Such Casm cannot be generated by the Sierra-&gt;Casm compiler. Furthermore, simply
replacing the assertion with an if/else statement doesn't do, as this results in
non-deterministic execution. That is, for the same input, different hint values
can yield different results. A malicious prover can use this freedom to harm the
user - in this example, they are able to make it seem as if an element isn't
part of the array, even though it actually is.</p>
<p>The safe Casm for finding an element in an array behaves like the above snippet
in the happy flow (element is there): an index is given in a hint, and we verify
that the array at the hinted index contains the requested element. However, in
the unhappy flow (element isn't there), we <em>must</em> go over the entire array to
verify this.</p>
<p>This was not the case in Cairo 0, as we were fine with certain paths not being
provable (in the above snippet, the unhappy flow in which the element isn't in
the array is never provable).</p>
<blockquote>
<p>Sierra's gas metering adds further complications to the above example. Even
looking through the array to verify that the element isn't there may leave
some flexibility to the prover.</p>
</blockquote>
<p>If we take gas limitations into consideration, the user may have enough gas for
the happy flow, but not for the unhappy one, making the execution stop
mid-search, and allowing the prover to get away with lying about the element not
being present.</p>
<p>The way we plan to handle this is by requiring the user to have enough gas for
the unhappy flow before actually calling <code>find_element</code>.</p>
<h3 id="hints-in-cairo"><a class="header" href="#hints-in-cairo">Hints in Cairo</a></h3>
<p>Smart contracts written with Cairo cannot contain user defined hints. This is
already true with Cairo Zero contracts (only whitelisted hints are accepted),
but with Cairo the hints in use are determined by the Sierra → Casm
compiler. Since this compilation is there to ensure that only "safe" Casm is
generated, there is no room for hints that are not generated by the compiler.</p>
<p>In the future, native Cairo may contain hint syntax similar to Cairo 0, but it
will not be available in Starknet smart contracts
(<a href="https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f">L3s</a>
on top of Starknet may make use of such functionality). Note that this is
currently not part of Starknet's roadmap.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Ever wondered how your Cairo programs were executed?</p>
<p>First, they are compiled by the Cairo Compiler, then executed by the Cairo
Virtual Machine, or <em>Cairo VM</em> for short, which generates a trace of execution,
used by the Prover to generate a STARK proof of that execution. This proof can
later be verified by a Verifier.</p>
<p>The following chapters will go deep inside the inner workings of the Cairo VM.
We'll cover its architecture, its memory model, and its execution model. Next,
we'll explore builtins and hints, their purpose, and how they work. Finally,
we'll look at the runner, which orchestrates the execution of a Cairo program.</p>
<p>But first, what do we mean by "virtual machine"?</p>
<h2 id="virtual-machine"><a class="header" href="#virtual-machine">Virtual Machine</a></h2>
<p>Virtual Machines (VMs) are software emulations of physical computers. They
provide a complete programming environment through an API which includes
everything required for the correct execution of programs above it.</p>
<p>Every virtual machine API includes an instruction set architecture (ISA) in
which to express programs. It could be the same instruction set as some physical
machine (e.g. RISC-V), or a dedicated one implemented in the VM (e.g. Cairo
assembly, CASM).</p>
<p>Those that emulate an OS are called <em>System Virtual Machines</em>, such as Xen and
VMWare. We're not interested in them here.</p>
<p>The other ones we're interested in are <em>Process Virtual Machines</em>. They provide
the environment needed by a single user-level process.</p>
<p>The most well-known process VM might be the Java Virtual Machine (JVM).</p>
<ul>
<li>Given a Java program <code>prgm.java</code>, it is compiled into a class <code>prgm.class</code>,
containing <em>Java bytecode</em> (JVM instructions and metadata).</li>
<li>The JVM verifies that the bytecode is safe to run.</li>
<li>The bytecode is either interpreted (slow) or compiled to machine code just in
time (JIT, fast).</li>
<li>If using JIT, the bytecode is translated to machine code while executing the
program.</li>
<li>Java programs could also be directly compiled to a specific CPU architecture
(read machine code) through a process called <em>ahead-of-time compilation</em>
(AOT).</li>
</ul>
<p>The Cairo VM is also a process VM, similar to the JVM, with one significant
difference: Java and its JVM are designed for (platform-independent)
general-purpose computing, while Cairo and its Cairo VM are specifically
designed for (platform-independent) <em>provable</em> general-purpose computing.</p>
<ul>
<li>A Cairo program <code>prgm.cairo</code> is compiled into compilation artifacts
<code>prgm.json</code>, containing <em>Cairo bytecode</em> (encoded CASM, the Cairo instruction
set, and extra data).</li>
<li>As seen in the <a href="ch00-00-introduction.html">introduction</a>, Cairo Zero directly
compiles to CASM while Cairo first compiles to <em>Sierra</em> and then to a safe
subset of CASM.</li>
<li>The Cairo VM <em>interprets</em> the provided CASM and generates a trace of the
program execution.</li>
<li>The obtained trace data can be fed to the Cairo Prover in order to generate a
STARK proof, allowing to prove the correct execution of the program. Creating
this <em>validity proof</em> is the main purpose of Cairo.</li>
</ul>
<p>Here is a high-level flow diagram showing how a Java program and a Cairo one are
executed with their respective compiler and VM. The proof generation of a Cairo
program is included.</p>
<div align="center">
  <img src="java-cairo-execution-flow.png" alt="Java and Cairo execution flow" width="800px"/>
</div>
<div align="center">
  <span class="caption">Java and Cairo program high-level execution flow diagram</span>
</div>
<p>An ongoing project, <a href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> works on providing Sierra to
machine code compilation, including JIT and AOT, for executing Cairo programs.</p>
<p>Even though the high-level flow of both VMs is similar, their actual
architectures are extremely different: the instruction set, the memory model,
Cairo's non-determinism and the output.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>Michael L. Scott, in Programming Language Pragmatics, 2015</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Cairo is a STARK-friendly Von Neumann architecture capable of generating
validity proofs for arbitrary computations. Being STARK-friendly means that
Cairo's design is optimized for the STARK proof system, while remaining
compatible with other proof system backends. It implements a Turing-complete
process virtual machine.</p>
<p>Cairo consists of three main components:</p>
<ol>
<li>The Cairo compiler</li>
<li>The Cairo Virtual Machine (CairoVM)</li>
<li>The Cairo prover and verifier</li>
</ol>
<p>The Cairo compiler transforms Cairo source code into Cairo bytecode (encoded
instructions and metadata). The compiler's output is commonly referred to as the
<em>compilation artifacts</em>.</p>
<p>The CairoVM implements the theoretical <em>Cairo machine</em>, processing the
compilation artifacts and executing the instructions to produce two key outputs
required for proof generation and verification: the <em>AIR (Arithmetic
Intermediate Representation) private input</em> (witness) and <em>AIR public input</em>:</p>
<ul>
<li>The AIR private input comprises the <em>execution trace</em> (or simply "trace") and
the <em>memory</em>.</li>
<li>The AIR public input includes the <em>initial and final states</em> (first and last
entries of the trace), the <em>public memory</em> (a subset of the memory), and
configuration data (e.g., layout) of the execution.</li>
</ul>
<p>The prover takes the AIR's private and public inputs to generate a proof of the
corresponding program execution. The verifier can then verify the proof's
correctness asynchronously, given the proof and the AIR public input.</p>
<p>What are AIRs, though?</p>
<h2 id="arithmetic-intermediate-representation---air"><a class="header" href="#arithmetic-intermediate-representation---air">Arithmetic Intermediate Representation - AIR</a></h2>
<p>AIR stands for <em>Arithmetic Intermediate Representation</em>, which is an
arithmetization technique. Arithmetization is the foundation of every proof
system: STARK uses AIRs, while other proof systems might rely on different
techniques (e.g., R1CS, PLONKish arithmetization). It allows converting a
computational statement into a set of polynomial equations. These polynomial
equations then represent the constraints of your system: if they all hold while
following the proof system protocol, then the proof is valid; otherwise, it's
invalid.</p>
<p>At its core, Cairo is a set of AIRs that represent a Turing-complete machine for
the Cairo ISA: the <em>Cairo machine</em>. This enables proving any statement (i.e.,
arbitrary code) through the Cairo machine.</p>
<p>The Cairo machine abstracts away the need to write AIRs for the program you
would like to prove, and Cairo, as a language, provides a human-readable
interface to use the Cairo machine.</p>
<p>Each component of the Cairo machine has its corresponding AIR: the CPU, the
Memory, the Builtins...</p>
<p>Good AIRs are critical to the performance of proof generation and verification.
While there can be many ways to express a computational statement into
polynomials, not all are equally efficient. Writing optimal AIRs is a strong
factor of performance.</p>
<p>We won't go any further on AIRs here, but it's good to know that the CairoVM's
purpose is to provide the required inputs to the Cairo prover for it to generate
proof of the given Cairo program. In a nutshell, the Cairo prover and verifier
job is to verify that the constraints defined by the Cairo AIR holds for the
CairoVM outputs.</p>
<h2 id="cairo-machine"><a class="header" href="#cairo-machine">Cairo Machine</a></h2>
<p>The Cairo machine is the theoretical model that defines the Von Neumann
architecture to prove arbitrary computation.</p>
<p>The machine is defined by two core models:</p>
<ul>
<li>CPU, or Execution model - The Instruction Set Architecture (ISA)</li>
<li>Memory model - Non-deterministic Read-only Memory</li>
</ul>
<p>The Execution model specifies the ISA through three key components:</p>
<ul>
<li>The instruction set</li>
<li>The registers (<code>pc</code>, <code>ap</code>, <code>fp</code>)</li>
<li>The state transition algorithm</li>
</ul>
<p>Unlike general-purpose ISAs such as RISC-V, Cairo implements its own ISA
specifically optimized for proof generation and verification—a custom
zero-knowledge ISA (ZK-ISA). The Memory model defines how the CPU interacts with
the memory. Following Von Neumann architecture principles, a single memory
stores both program and instruction data.</p>
<p>The Cairo machine exists in two versions:</p>
<ol>
<li>The <em>deterministic machine</em> (used by the prover)</li>
<li>The <em>non-deterministic machine</em> (used by the verifier)</li>
</ol>
<p>Why are there two versions of the Cairo machine, one for the prover and one for
the verifier?</p>
<h3 id="deterministic-and-non-deterministic-cairo-machine"><a class="header" href="#deterministic-and-non-deterministic-cairo-machine">Deterministic and Non-deterministic Cairo Machine</a></h3>
<p>The deterministic machine takes a trace (a sequence of states) and the whole
memory (a memory function), and verifies that the transition between two
consecutive states is valid. It returns <code>accept</code> if all state transitions are
valid and <code>reject</code> otherwise. This machine does not perform any computation, it
only asserts the validity of a trace and its memory.</p>
<p>The non-deterministic machine relies on the deterministic one: it only takes the
initial state, the final state, and a partial memory function (i.e. the public
memory) and returns <code>accept</code> if there exists a sequence of states (a trace) with
the same initial and final states and a memory function that extends the partial
memory (a whole memory that includes the public-memory) which is accepted by the
deterministic machine.</p>
<p>The deterministic machine allows the prover to generate a proof, while the
non-deterministic machine allows the verifier to verify the proof succinctly in
a zero-knowledge way (some data can be kept private from the verifier).</p>
<p>The CairoVM is the implementation of this theoretical machine, including some
functionalities to benefit from its design (<em>builtins</em> &amp; <em>hints</em>). Among the
various implementations of the CairoVM, what we call the <em>Cairo Runner</em> is the
entrypoint for running a Cairo program and generating the AIR inputs needed for
proof.</p>
<p>When a Cairo program is executed by the CairoVM, we could view the memory model
as a Write-Once one.</p>
<h4 id="recap---differences-between-the-two-cairo-machines"><a class="header" href="#recap---differences-between-the-two-cairo-machines">Recap - Differences between the two Cairo machines</a></h4>
<p>We could recap in a table the key differences between the deterministic Cairo
machine, and the non-deterministic one.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Deterministic Cairo Machine</th><th>Non-Deterministic Cairo Machine</th></tr></thead><tbody>
<tr><td>Usage</td><td>Prover</td><td>Verifier</td></tr>
<tr><td>Hints</td><td>Executed</td><td>Not aware of them</td></tr>
<tr><td>Memory</td><td>Complete memory</td><td>Public memory only</td></tr>
<tr><td>Trace</td><td>Full execution trace</td><td>Initial &amp; Final states only</td></tr>
</tbody></table>
</div>
<h2 id="cairo-virtual-machine-architecture-diagram"><a class="header" href="#cairo-virtual-machine-architecture-diagram">Cairo Virtual Machine Architecture Diagram</a></h2>
<p>The following diagram represent the architecture of the CairoVM, to generate the
AIR inputs for the proof system.</p>
<div align="center">
  <img src="cairo-vm-architecture.png" alt="CairoVM architecture" width="800px"/>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>In most computing systems, memory is primarily used to store temporary values
during program execution. However, in CairoVM, the memory model also plays a
crucial role in proof generation by defining how memory accesses are recorded in
trace cells. To optimize proof generation, Cairo's memory model is designed to
efficiently represent memory values, streamlining the STARK proving process.</p>
<p>In this chapter, we will explore Cairo's unique memory model and examine how its
structure enhances proof generation process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-deterministic-read-only-memory"><a class="header" href="#non-deterministic-read-only-memory">Non-Deterministic Read-only Memory</a></h1>
<p>From the Cairo whitepaper, it states that Cairo uses a non-deterministic
read-only memory model.</p>
<p>Let's break down the two core properties:</p>
<ol>
<li><strong>Non-determinism</strong></li>
</ol>
<ul>
<li>In Cairo, non-determinism refers to the idea that the memory addresses and
their values are not determined by a typical memory management system.
Instead, the prover asserts the location and the values that are stored at
those addresses. For example, instead of manually writing and reading a value
at a particular address as in traditional read-write memory models, the prover
asserts that at memory address x, the value 7 is stored. This way, we do not
need to explicitly check whether the value 7 exists at address x.</li>
</ul>
<ol start="2">
<li><strong>Read-only</strong></li>
</ol>
<ul>
<li>This means that when a Cairo program runs, the value in memory does not
change.</li>
</ul>
<p>These two properties effectively make the memory model a write-once memory
model. Once a value is assigned to a memory address, it cannot be overwritten.
Subsequent operations are limited to reading or verifying the value at that
address. Moreover, the memory address space is contiguous, meaning if the
program accesses memory address x and y, it cannot skip an address in between.</p>
<p>This approach differs significantly from other virtual machines, like the
Ethereum Virtual Machine (EVM), which uses a read-write memory model. In
contrast, Cairo's memory model prioritizes efficiency in proof generation. As a
result, it requires only 5 trace cells per memory access.</p>
<p>Another way to think about this is that the effective cost of using Cairo's
memory is from the number of memory accesses, rather than the number of memory
addresses used. Consequently, rewriting to an existing memory cell incurs a
similar cost to writing to a new one.</p>
<p>This memory model is particularly useful for proving the correctness of a
program. It's easier to describe constraints on the values of memory when these
values can only be set once, rather than expressing the same constraints on a
read-write memory model, where the value of a memory cell is dependent on the
"execution time".</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-segments"><a class="header" href="#introduction-to-segments">Introduction to Segments</a></h1>
<p>Cairo ensures that allocated memory remains immutable after being written to,
while allowing dynamic expansion of memory segments at runtime. All this is
possible with organizing memory addresses into <strong>segments</strong>.</p>
<p>The process of organizing memory addresses into segments is as follows:</p>
<ol>
<li>
<p>During runtime, It groups allocated memory addresses into segments with a
unique segment identifier and an offset to indicate the continuation of the
memory addresses belonging to each segment, <code>&lt;segment_id&gt;:&lt;offset&gt;</code>. This
temporary value that we are marking to each memory address is called a
<strong>relocatable value</strong>.</p>
</li>
<li>
<p>At the end of execution, the relocatable values are transformed into a
single, contiguous memory address space and a separate <strong>relocation table</strong>
is created to give context to the linear memory address space.</p>
</li>
</ol>
<h2 id="segment-values"><a class="header" href="#segment-values">Segment Values</a></h2>
<p>Cairo's memory model contains the following segments:</p>
<ul>
<li><strong>Program Segment</strong> = Stores the bytecode of Cairo program. Another way to say
is it stores the instructions of a cairo program. Program Counter, <code>pc</code> starts
at the beginning of this segment.</li>
<li><strong>Execution Segment</strong> = Stores any data while executing a Cairo program
(temporary variables, function call frames, and pointers). Allocation pointer,
<code>ap</code> and frame pointer, <code>fp</code> starts on this segment.</li>
<li><strong>Builtin Segment</strong> = Stores builtins that is actively used by the Cairo
program. Each Cairo builtin has its own dedicated segment, allocated
dynamically based on the builtins used in the program. Check out
<a href="ch204-00-builtins.html">Builtin Section</a> to learn more about individual
builtins.</li>
<li><strong>User Segment</strong> = Stores program outputs, arrays, and dynamically allocated
data structures.</li>
</ul>
<p><em>Every segment except Program Segment has a dynamic address space which means
that the length of the allocated memory address space is unknown until the
program has finished executing. The Program Segment is an exception as it is
used to store the bytecode of the Cairo program which has a fixed size during
execution.</em></p>
<h2 id="segment-layout"><a class="header" href="#segment-layout">Segment Layout</a></h2>
<p>The layout of Cairo memory is ordered by segments in the following order:</p>
<ol>
<li><strong>Segment 0</strong> = Program Segment</li>
<li><strong>Segment 1</strong> = Execution Segment</li>
<li><strong>Segment 2 to x</strong> = Builtin Segments</li>
<li><strong>Segment x + 1 to y</strong> = User Segments</li>
</ol>
<p><em>The number of builtin and user segments are dynamic and depends on the type of
program.</em></p>
<h1 id="relocation"><a class="header" href="#relocation">Relocation</a></h1>
<p>To understand the overall process of how memory is handled throughout the
execution of a Cairo program, we will be looking at an example of Cairo Zero
program and how its segments are defined during runtime with relocatable values
and how the memory addresses are relocated to one contiguous memory address
space at the end of execution.</p>
<p><strong>Cairo Zero program:</strong></p>
<pre><code class="language-cairo">%builtins output

func main(output_ptr: felt*) -&gt; (output_ptr: felt*) {

    // We are allocating three different values to segment 1.
    [ap] = 10, ap++;
    [ap] = 100, ap++;
    [ap] = [ap - 2] + [ap - 1], ap++;

    // We set value of output_ptr to the address of where the output will be stored.
    // This is part of the output builtin requirement.
    [ap] = output_ptr, ap++;

    // Asserts that output_ptr equals to 110.
    assert [output_ptr] = 110;

    // Returns the output_ptr + 1 as the next unused memory address.
    return (output_ptr=output_ptr + 1);
}
</code></pre>
<p><em>The output builtin allows the final output to be stored in a new segment.</em></p>
<p>The Cairo Zero program stores three values which are <code>10</code>, <code>100</code> and
<code>110</code>(addition of <code>10</code> and <code>100</code>) and these values are stored in three different
memory addresses under Segment 1.</p>
<p>Using the output builtin, the final output is stored in a new segment in
Segment 2.</p>
<p><strong>The relocatable values are :</strong></p>
<pre><code>Addr  Value
-----------

// Segment 0

0:0   5189976364521848832
0:1   10
0:2   5189976364521848832
0:3   100
0:4   5201798304953696256
0:5   5191102247248822272
0:6   5189976364521848832
0:7   110
0:8   4612389708016484351
0:9   5198983563776458752
0:10  1
0:11  2345108766317314046
⋮
// Segment 1

1:0   2:0
1:1   3:0
1:2   4:0
1:3   10
1:4   100
1:5   110
1:6   2:0
1:7   110
1:8   2:1
⋮
// Segment 2

2:0   110

</code></pre>
<p>Once the program is finished executing,the relocatable values turn into one
contiguous memory address space with the help of the relocation table to give
context to the linear memory address space.</p>
<p><strong>From relocation value to one contiguous memory address space:</strong></p>
<pre><code>Addr  Value
-----------
1     5189976364521848832
2     10
3     5189976364521848832
4     100
5     5201798304953696256
6     5191102247248822272
7     5189976364521848832
8     110
9     4612389708016484351
10    5198983563776458752
11    1
12    2345108766317314046
13    22
14    23
15    23
16    10
17    100
18    110
19    22
20    110
21    23
22    110
</code></pre>
<p><strong>Relocation table:</strong></p>
<pre><code>segment_id  starting_index
----------------------------
0            1
1            13
2            22
3            23
4            23
</code></pre>
<p>The relocation table gives context for the prover on which index a new segment
starts by labeling the segment identifier with its own starting index.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h1>
<p>The CPU architecture of the Cairo VM defines how the VM processes instructions
and changes its state. It's directly analogous to the Central Processing Unit
(CPU) in a physical computer. In the Cairo VM, the CPU follows the principles of
a Von Neumann architecture, where both program instructions and data reside in
the same memory space. The VM's execution model is implemented as a repeating
loop, known as the <strong>fetch-decode-execute cycle</strong>, which dictates how the
machine advances from one state to the next.</p>
<p>The execution model is defined by its registers, a unique instruction set
architecture, and the VM's state transition function.</p>
<h2 id="registers"><a class="header" href="#registers">Registers</a></h2>
<p>In any CPU architecture, registers are small, high-speed storage locations that
hold the most immediately needed data for processing. The Cairo VM has three
dedicated registers that are used to manage the program's flow and memory
context. The state of the VM at any given moment is defined entirely by the
values of these three registers, which are part of the execution trace that gets
proven.</p>
<ul>
<li>The <strong><code>pc</code> (Program Counter)</strong> holds the memory address of the next
instruction to be fetched and executed. After most instructions, it is
incremented to point to the subsequent one, but jump and call instructions can
modify it directly to continue from a different instruction.</li>
<li>The <strong><code>ap</code> (Allocation Pointer)</strong> functions as a stack pointer, conventionally
pointing to the next free (unwritten) memory cell. Many instructions increment
<code>ap</code> by 1, but this is not typically enforced.</li>
<li>The <strong><code>fp</code> (Frame Pointer)</strong> provides a stable reference point for the current
function's execution context, or "stack frame." When a function is called,
<code>fp</code> is set to the current value of <code>ap</code>. This allows the function to reliably
access its arguments and its return address, which are located at fixed
negative offsets relative to <code>fp</code>, regardless of how many local variables are
allocated on the stack using <code>ap</code>.</li>
</ul>
<h2 id="instructions-and-opcodes"><a class="header" href="#instructions-and-opcodes">Instructions and Opcodes</a></h2>
<p>A Cairo <strong>instruction</strong> is the complete computational unit for a single step,
encoded as a 64-bit field element. This single word contains three 16-bit signed
offsets (<code>off_dst</code>, <code>off_op0</code>, <code>off_op1</code>) and 15 different boolean flags, used
to know which registers to use for addressing, what arithmetic operations to
perform, and how to update the <code>pc</code>, <code>ap</code>, and <code>fp</code> registers for the next
state.</p>
<p>The three offsets determine which memory cells the instruction reads/writes
relative to the registers. The 15 flags encode what operation to perform and how
to update registers. For example, flag groups include <code>dst_reg</code> (whether to
write the result to <code>fp</code>, <code>ap</code>, or <code>pc</code>), <code>op0_reg</code>/<code>op1_reg</code> (whether operands
come from <code>fp</code>, <code>ap</code>, or are immediate), arithmetic/logic operations, and
control for jumps.</p>
<p>While there are many different instructions in the Cairo VM, the VM itself only
supports three opcodes:</p>
<ol>
<li><strong><code>CALL</code></strong>: Initiates a function call, saving the current context (<code>fp</code> and
the return <code>pc</code>) to the stack.</li>
<li><strong><code>RET</code></strong>: Executes a function return, restoring the caller's context from
the stack.</li>
<li><strong><code>ASSERT_EQ</code></strong>: Enforces an equality constraint.</li>
</ol>
<h2 id="cairo-assembly-casm"><a class="header" href="#cairo-assembly-casm">Cairo Assembly (CASM)</a></h2>
<p>CASM is the human-readable assembly language for Cairo. It is the direct textual
representation of the machine's instructions. A developer writes logic in the
high-level Cairo language, and the compiler's final step is to translate this
logic into a sequence of CASM instructions. However, one can also write CASM
instructions by hand. Each valid line of CASM, such as <code>[fp + 1] = [ap - 2] + 5</code>
or <code>jmp rel 17 if [ap] != 0</code>, corresponds to a specific instruction.</p>
<h2 id="state-transition"><a class="header" href="#state-transition">State Transition</a></h2>
<p>The state of the Cairo VM at any step (i) is fully captured by the tuple
((pc<em>i, ap_i, fp_i)). The <strong>state transition function</strong> is the deterministic
set of rules that computes the next state, ((pc</em>{i+1}, ap*{i+1}, fp*{i+1})),
based on the current state and the instruction fetched from memory. This process
perfectly mirrors the classic fetch-decode-execute cycle of a physical CPU.</p>
<p>The entire cycle, from fetching the instruction to asserting its correctness and
updating the registers, is a single, atomic step in the Cairo VM. This process
is part of what is encoded into the polynomial constraints of the Cairo AIR,
guaranteeing that every single step of a program's execution adheres to the
rules of the VM and can be proven.</p>
<p>Conceptually, each step checks one instruction and enforces its semantics as
algebraic constraints. For example, a typical instruction will load values from
memory at addresses <code>pc + off_op0</code> and <code>pc + off_op1</code> (relative to registers),
compute a result (add, multiply, sub), and then write it to memory at
<code>pc + off_dst</code>. It will also set the next <code>pc</code>, possibly increment <code>ap</code>, and
leave <code>fp</code> unchanged or restore it on return of a function call.</p>
<p>These rules are fully deterministic: given the current state and memory, there
is exactly one valid next state for the Cairo VM. The key point is that for
every instruction, there exists a set of algebraic constraints in the AIR that
must be satisfied. If at any step the constraints cannot be satisfied (for
example, the VM executes an illegal state transition), the execution cannot be
proven.</p>
<p>Conversely, if all steps pass, then, it is possible to generate a proof from
this execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins"><a class="header" href="#builtins">Builtins</a></h1>
<p>The Cairo whitepaper defines builtins as "predefined optimized low-level
execution units".</p>
<p>In other words, builtins are logic blocks embedded in the Cairo architecture to
significantly enhance performance compared to defining the same logic using
Cairo's instruction set.</p>
<p>Builtins can be compared to Ethereum precompiles, primitive operations
implemented in the client's implementation language rather than using EVM
opcodes.</p>
<p>The Cairo architecture does not specify a specific set of builtins, they can be
added or removed depending on our needs, which is why different layouts exist.
Builtins are adding constraints to the CPU AIR, which will increase the
verification time.</p>
<p>In this chapter, we'll see how builtins work, the builtins that exist and their
purposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-builtins-work"><a class="header" href="#how-builtins-work">How Builtins Work</a></h1>
<p>A builtin enforces some constraints on the Cairo memory to perform specific
tasks, such as computing a hash.</p>
<p>Each builtin works on a dedicated memory segment, which represents in the end a
fixed address range. This communication method is called <em>memory-mapped I/O</em>:
specific ranges of memory addresses dedicated to builtins.</p>
<p>For a Cairo program to interact with a builtin, it simply needs to read or write
to the corresponding memory cells.</p>
<p>There are two main types of builtin constraints that we'll refer as <em>validation
property</em> and <em>deduction property</em>. The builtins with a deduction property are
usually split in block of cells where some cells are constrained by a validation
property</p>
<p>If the defined property doesn't hold, then the Cairo VM will panic.</p>
<h2 id="validation-property"><a class="header" href="#validation-property">Validation Property</a></h2>
<p>A validation property defines constraints a value must hold for it to be written
to a builtin memory cell.</p>
<p>For example, the <em>Range Check</em> builtin only accepts felts and verify that such a
felt is within the range <code>[0, 2**128)</code>. A program can write a value to the Range
Check builtin only if those two constraints hold. Those two constraints
represent the validation property of the Range Check builtin.</p>
<div align="center">
  <img src="range-check-validation-property.png" alt="Diagram snapshot Cairo memory using the Range Check builtin" width="800px"/>
</div>
<div align="center">
  <span class="caption">Diagram of the Cairo VM memory using the Range Check builtin</span>
</div>
<h2 id="deduction-property"><a class="header" href="#deduction-property">Deduction Property</a></h2>
<p>A deduction property defines constraints on a block of cells, when reading or
writing to a cell.</p>
<p>A block of cells has two categories of cells:</p>
<ul>
<li><em>Input cells</em> - cells the program can write to, their constraints are similar
to a validation property.</li>
<li><em>Output cells</em> - cells the program must read, and their value is computed
based on the deduction property and the input cells value.</li>
</ul>
<p>A program that only writes to the input cells, without ever reading the output
cell, is valid as long as the constraints on those cells hold. Though, it is
useless.</p>
<p>For example, the <em>Pedersen</em> builtin works with triplets of cells:</p>
<ul>
<li>Two input cells to store two felts, <code>a</code> and <code>b</code>.</li>
<li>One output cell which will store <code>Pedersen(a, b)</code>.</li>
</ul>
<p>To compute the Pedersen hash of <code>a</code> and <code>b</code>, the program must:</p>
<ul>
<li>Write <code>a</code> to the first cell</li>
<li>Write <code>b</code> to the second cell</li>
<li>Read the third cell, which will compute and write `Pedersen(a, b) to it.</li>
</ul>
<p>In the following diagram, the Pedersen builtin is used, highlighting its
deduction property: the output cell <code>2:2</code> being read when writing its value to
the cell <code>1:5</code>.</p>
<div align="center">
  <img src="pedersen-deduction-property.png" alt="Diagram of Cairo VM memory Pedersen builtins" width="800px"/>
</div>
<div align="center">
  <span class="caption">Diagram of the Cairo VM memory using the Pedersen builtin</span>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins-list"><a class="header" href="#builtins-list">Builtins List</a></h1>
<p>The following table lists the different builtins implemented in the Cairo VM and
gives a brief description of their purpose. For each builtin, a specific section
details how it works, its cells organization if any, and references their actual
implementation in different implementations of the Cairo VM.</p>
<p>Additional resources related to the operation performed by the builtin are
provided if relevant.</p>
<div class="table-wrapper"><table><thead><tr><th>Builtin</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="ch204-02-00-output.html">Output</a></td><td>Stores all the public memory needed to generate a STARK proof (input &amp; output values, builtin pointers...)</td></tr>
<tr><td><a href="ch204-02-01-pedersen.html">Pedersen</a></td><td>Computes the Pedersen hash <code>h</code> of two felts <code>a</code> and <code>b</code>. <code>h = Pedersen(a, b)</code></td></tr>
<tr><td><a href="ch204-02-02-range-check.html">Range Check</a></td><td>Verify that a felt <code>x</code> is within the bounds <code>[0, 2**128)</code>.</td></tr>
<tr><td><a href="ch204-02-03-ecdsa.html">ECDSA</a></td><td>Verify that the ECDSA signature of a given public key <code>pub</code> on a message <code>m</code> equals <code>sig</code>, previously stored. Only used by Cairo Zero.</td></tr>
<tr><td><a href="ch204-02-04-bitwise.html">Bitwise</a></td><td>Computes the bitwise AND, XOR and OR of two felts <code>a</code> and <code>b</code>. <code>a &amp; b</code>, <code>a ^ b</code> and <code>a | b</code>.</td></tr>
<tr><td><a href="ch204-02-05-ec-op.html">EC OP</a></td><td>Performs Elliptic Curve OPerations - For two points on the STARK curve <code>P</code>, <code>Q</code> and a scalar <code>m</code>, computes <code>R = P + mQ</code>.</td></tr>
<tr><td><a href="ch204-02-06-keccak.html">Keccak</a></td><td>Computes the new state <code>s'</code> after applying the 24 rounds of the keccak-f1600 block permutation on a given state <code>s</code>.</td></tr>
<tr><td><a href="ch204-02-07-poseidon.html">Poseidon</a></td><td>Computes the new state <code>s'</code> after applying the 91 rounds of the hades block permutation on a given state <code>s</code>.</td></tr>
<tr><td><a href="ch204-02-08-range-check-96.html">Range Check96</a></td><td>Verify that a felt <code>x</code> is within the bounds <code>[0, 2**96)</code>.</td></tr>
<tr><td><a href="ch204-02-09-add-mod.html">AddMod</a></td><td>Arithmetic Circuit Support - Computes the modular addition <code>c</code> of two felts <code>a</code>, <code>b</code> by batches. <code>c ≡ a + b mod(p)</code></td></tr>
<tr><td><a href="ch204-02-10-mul-mod.html">MulMod</a></td><td>Arithmetic Circuit Support - Computes the modular multiplication <code>c</code> of two felts <code>a</code>, <code>b</code> by batches. <code>c ≡ a * b mod(p)</code></td></tr>
<tr><td><a href="ch204-02-11-segment-arena.html">Segment Arena</a></td><td>Manages the Cairo dictionaries Not used in Cairo Zero.</td></tr>
<tr><td><a href="ch204-02-12-gas.html">Gas</a></td><td>Manages the available gas during the run. Used by Starknet to handle its gas usage and avoid DoS.</td></tr>
<tr><td><a href="ch204-02-13-system.html">System</a></td><td>Manages the Starknet syscalls &amp; cheatcodes.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="output-builtin"><a class="header" href="#output-builtin">Output Builtin</a></h1>
<p>In the Cairo Virtual Machine (VM), the <strong>Output Builtin</strong> is a built-in
component that manages the output segment of the memory via the <code>output_ptr</code>.
It's used as a bridge between a Cairo program's execution and the external
world, using <strong>public memory</strong> to produce verifiable outputs.</p>
<p>Represented by the <code>output_ptr</code>, the output builtin handles a dedicated memory
region where a program writes its outputs. Its primary role is to store any
value that must be made available in the proof system for verification, in what
we call <strong>public memory</strong>. This segment grows as the program writes values.</p>
<h2 id="memory-organization"><a class="header" href="#memory-organization">Memory Organization</a></h2>
<p>The output segment is a contiguous block of cells starting at a base address.
All cells in the output segment are inherently public, accessible to verifiers.
It's interactions are quite simple: it can be written to, and read from, without
any specific requirements.</p>
<h2 id="role-in-stark-proofs"><a class="header" href="#role-in-stark-proofs">Role in STARK Proofs</a></h2>
<p>The Output Builtin’s integration with public memory is required for STARK proof
construction and verification:</p>
<ol>
<li><strong>Public Commitment</strong>: Values written to <code>output_ptr</code> become part of the
public memory, committing the program to those outputs in the proof.</li>
<li><strong>Proof Structure</strong>: The output segment is included in the public input of a
trace, with its boundaries tracked (e.g., <code>begin_addr</code> and <code>stop_ptr</code>) for
verification.</li>
<li><strong>Verification Process</strong>: The verifier extracts and hashes the output
segment. Typically, all cells in the output segment are hashed together,
creating a commitment which allows efficient verification without
re-execution.</li>
</ol>
<h2 id="implementation-references"><a class="header" href="#implementation-references">Implementation References</a></h2>
<p>These implementation references of the Output Builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/output.ts#L4">TypeScript Output Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/vm/output_builtin_runner.py">Python Output Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-builtin"><a class="header" href="#pedersen-builtin">Pedersen Builtin</a></h1>
<p>The <em>Pedersen</em> builtin is dedicated to computing the Pedersen hash of two field
elements (felts). It provides an efficient, native implementation of this
cryptographic hash function within the Cairo VM. For a guide on using hashes in
Cairo programs, see section 11.4 <a href="ch12-04-hash.html">Working with Hashes</a>.</p>
<h2 id="cells-organization"><a class="header" href="#cells-organization">Cells Organization</a></h2>
<p>The Pedersen builtin has its own dedicated segment during a Cairo VM run. It
follows a deduction property pattern and is organized in <em>triplets of cells</em> -
two input cells and one output cell:</p>
<ul>
<li><strong>Input cells</strong>: Must store field elements (felts); relocatable values
(pointers) are forbidden. This restriction makes sense because computing the
hash of a memory address is not well-defined in this context.</li>
<li><strong>Output cell</strong>: The value is deduced from the input cells. When an
instruction tries to read this cell, the VM computes the Pedersen hash of the
two input cells and writes the result to the output cell.</li>
</ul>
<p>Let's examine two snapshots of a Pedersen segment during the execution of a
program by the Cairo VM:</p>
<p>In the first snapshot, we see two triplets in different states:</p>
<div align="center">
  <img src="pedersen-builtin-valid.png" alt="valid pedersen builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Snapshot 1 - Pedersen builtin segment with valid inputs</span>
</div>
<ul>
<li><strong>First triplet</strong> (cells 3:0, 3:1, 3:2): All three cells contain felts. The
value in cell 3:2 (output) has been computed because this cell has been read
during program execution, which triggered the Pedersen hash computation of
inputs 15 and 35.</li>
<li><strong>Second triplet</strong> (cells 3:3, 3:4, 3:5): Only the input cells have been
filled with values 93 and 5. The output cell 3:5 remains empty because it
hasn't been read yet, so the Pedersen hash of 93 and 5 hasn't been computed
yet.</li>
</ul>
<p>In the second snapshot, we see two cases that would cause errors when attempting
to read the output cell:</p>
<div align="center">
  <img src="pedersen-builtin-error.png" alt="Invalid pedersen builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Snapshot 2 - Pedersen builtin segment with invalid inputs</span>
</div>
<ol>
<li>
<p><strong>First triplet</strong>: Reading cell 3:2 would throw an error because one of the
input cells (3:0) is empty. The VM cannot compute a hash with missing input
data.</p>
</li>
<li>
<p><strong>Second triplet</strong>: Reading cell 3:5 would throw an error because one of the
input cells (3:4) contains a relocatable value pointing to cell 1:7. The
Pedersen builtin can only hash field elements, not memory addresses.</p>
</li>
</ol>
<p>Note that these errors only manifest when the output cell is read. For the
second case, a more robust implementation could validate the input cells when
they're written, rejecting relocatable values immediately rather than waiting
until the hash computation is attempted.</p>
<h2 id="implementation-references-1"><a class="header" href="#implementation-references-1">Implementation References</a></h2>
<p>These implementation references of the Pedersen builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/pedersen.ts#L4">TypeScript Pedersen Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/hash/hash_builtin_runner.py">Python Pedersen Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/hash.rs">Rust Pedersen Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/hash.zig">Zig Pedersen Builtin</a></li>
</ul>
<h2 id="resources-on-pedersen-hash"><a class="header" href="#resources-on-pedersen-hash">Resources on Pedersen Hash</a></h2>
<p>If you're interested in the Pedersen hash function and its applications in
cryptography:</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#pedersen-hash">Hash Functions - Pedersen Hash</a></li>
<li>nccgroup,
<a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Breaking Pedersen Hashes in Practice</a>,
2023, March 22</li>
<li>Ryan S.,
<a href="https://rya-sge.github.io/access-denied/2024/05/07/pedersen-hash-function/">Pedersen Hash Function Overview</a>,
2024, May 07</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-check-builtin"><a class="header" href="#range-check-builtin">Range Check Builtin</a></h1>
<p>The <em>Range Check</em> builtin verifies that field elements fall within a specific
range. This builtin is fundamental to Cairo's integer types and comparisons,
ensuring that values satisfy bounded constraints.</p>
<p>Two variants of this builtin exist:</p>
<ul>
<li>Standard Range Check: Verifies values in the range \([0, 2^{128}-1]\)</li>
<li>Range Check 96: Verifies values in the range \([0, 2^{96}-1]\)</li>
</ul>
<p>This section focuses on the standard variant, though the same principles apply
to both.</p>
<h2 id="purpose-and-importance"><a class="header" href="#purpose-and-importance">Purpose and Importance</a></h2>
<p>While it's possible to implement range checking using pure Cairo code (for
example, by decomposing a number into its binary representation and verifying
each bit), using the builtin is significantly more efficient. A pure Cairo
implementation would require at least 384 instructions to verify a single range
check, whereas the builtin achieves the same result with computational cost
equivalent to about 1.5 instructions. This efficiency makes the Range Check
builtin essential for the implementation of bounded integer arithmetic and other
operations that require value range verification.</p>
<h2 id="cells-organization-1"><a class="header" href="#cells-organization-1">Cells Organization</a></h2>
<p>The Range Check builtin operates on a dedicated memory segment with a validation
property pattern:</p>
<div class="table-wrapper"><table><thead><tr><th>Characteristic</th><th>Description</th></tr></thead><tbody>
<tr><td>Valid values</td><td>Field elements in range \([0, 2^{128}-1]\)</td></tr>
<tr><td>Error conditions</td><td>Values ≥ 2^128 or relocatable addresses</td></tr>
<tr><td>Validation timing</td><td>Immediate (upon cell write)</td></tr>
</tbody></table>
</div>
<p>Unlike builtins with deduction properties, the Range Check builtin validates
values at write time rather than read time. This immediate validation provides
early error detection for out-of-range values.</p>
<h3 id="valid-operation-example"><a class="header" href="#valid-operation-example">Valid Operation Example</a></h3>
<div align="center">
  <img src="range-check-builtin-valid.png" alt="valid range_check builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Range Check builtin segment with valid values</span>
</div>
<p>In this example, a program successfully writes three values to the Range Check
segment:</p>
<ul>
<li><code>0</code>: The minimum allowed value</li>
<li><code>256</code>: A typical small integer value</li>
<li><code>2^128-1</code>: The maximum allowed value</li>
</ul>
<p>All three values fall within the permitted range \([0, 2^{128}-1]\), so the
operations succeed.</p>
<h3 id="out-of-range-error-example"><a class="header" href="#out-of-range-error-example">Out-of-Range Error Example</a></h3>
<div align="center">
  <img src="range-check-builtin-error1.png" alt="invalid range_check builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Range Check error: Value exceeds maximum range</span>
</div>
<p>In this example, the program attempts to write <code>2^128</code> to cell <code>2:2</code>, which
exceeds the maximum allowed value. The VM immediately throws an out-of-range
error and aborts execution.</p>
<h3 id="invalid-type-error-example"><a class="header" href="#invalid-type-error-example">Invalid Type Error Example</a></h3>
<div align="center">
  <img src="range-check-builtin-error2.png" alt="invalid range_check builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Range Check error: Value is a relocatable address</span>
</div>
<p>In this example, the program attempts to write a relocatable address (pointer to
cell <code>1:7</code>) to the Range Check segment. Since the builtin only accepts field
elements, the VM throws an error and aborts execution.</p>
<h2 id="implementation-references-2"><a class="header" href="#implementation-references-2">Implementation References</a></h2>
<p>These implementation references of the Range Check builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/rangeCheck.ts">TypeScript Range Check Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/range_check/range_check_builtin_runner.py">Python Range Check Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/range_check.rs">Rust Range Check Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/range_check.zig">Zig Range Check Builtin</a></li>
</ul>
<h2 id="resources-on-range-check"><a class="header" href="#resources-on-range-check">Resources on Range Check</a></h2>
<p>If you're interested in how the Range Check builtin works and its usage in the
Cairo VM:</p>
<ul>
<li>Starknet,
<a href="https://docs.cairo-lang.org/how_cairo_works/builtins.html#range-checks">CairoZero documentation, Range Checks section of Builtins and implicit arguments</a></li>
<li>Lior G., Shahar P., Michael R.,
<a href="https://eprint.iacr.org/2021/1063.pdf">Cairo Whitepaper, Sections 2.8 and 8</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/cairo/common/math.cairo">StarkWare Range Check implementation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecdsa-builtin"><a class="header" href="#ecdsa-builtin">ECDSA Builtin</a></h1>
<p>The <em>ECDSA</em> (Elliptic Curve Digital Signature Algorithm) builtin verifies
cryptographic signatures on the STARK curve. This builtin is primarily used to
validate that a message hash was signed by the holder of a specific private key.</p>
<h2 id="memory-organization-1"><a class="header" href="#memory-organization-1">Memory Organization</a></h2>
<p>The ECDSA builtin has a unique memory structure with two interconnected
components:</p>
<ol>
<li><strong>Memory Segment</strong>: A dedicated segment that stores public keys and message
hashes as field elements</li>
<li><strong>Signature Dictionary</strong>: A mapping that associates public key offsets with
their corresponding signatures</li>
</ol>
<h3 id="cell-layout-in-the-memory-segment"><a class="header" href="#cell-layout-in-the-memory-segment">Cell Layout in the Memory Segment</a></h3>
<p>The ECDSA segment arranges cells in pairs:</p>
<ul>
<li><strong>Even offsets</strong> (0, 2, 4, ...) store public keys</li>
<li><strong>Odd offsets</strong> (1, 3, 5, ...) store message hashes</li>
</ul>
<p>Each public key at offset <code>2n</code> is associated with a message hash at offset
<code>2n+1</code>. For example, public key at offset 0 pairs with the hash at offset 1.</p>
<h3 id="signature-verification-process"><a class="header" href="#signature-verification-process">Signature Verification Process</a></h3>
<p>Before using the ECDSA builtin, signatures must be explicitly registered in the
signature dictionary. The VM performs signature verification when the program
writes values to the ECDSA segment:</p>
<ol>
<li>When a public key is written at offset <code>2n</code>, the VM checks if it matches the
key used to create the signature registered at that offset</li>
<li>When a message hash is written at offset <code>2n+1</code>, the VM verifies that it
matches the hash that was signed</li>
</ol>
<p>If either check fails, the VM throws an error immediately - this is different
from some other builtins that defer validation until output access.</p>
<h3 id="valid-usage-example"><a class="header" href="#valid-usage-example">Valid Usage Example</a></h3>
<div align="center">
  <img src="ecdsa-full.png" alt="Valid ECDSA builtin segment with signatures"/>
</div>
<div align="center">
  <span class="caption">Example of valid ECDSA segment usage</span>
</div>
<p>In this example:</p>
<ul>
<li>Public key_0 at offset 0 and hash_0 at offset 1 are verified against the
signature stored at dictionary key 0</li>
<li>Public key_1 at offset 2 and hash_1 at offset 3 are verified against the
signature stored at dictionary key 2</li>
<li>All verifications pass because the public keys and hashes match what was
originally signed</li>
</ul>
<h3 id="error-conditions"><a class="header" href="#error-conditions">Error Conditions</a></h3>
<h4 id="invalid-hash-error"><a class="header" href="#invalid-hash-error">Invalid Hash Error</a></h4>
<div align="center">
  <img src="ecdsa-invalid-hash.png" alt="ECDSA error due to invalid hash"/>
</div>
<div align="center">
  <span class="caption">Error: Hash doesn't match the signed message</span>
</div>
<p>When a program writes hash "1324" at offset 5, but the signature at dictionary
key 4 was created for hash "2025", the VM throws an error because the hash
doesn't match what was originally signed with that public key.</p>
<h4 id="invalid-public-key-error"><a class="header" href="#invalid-public-key-error">Invalid Public Key Error</a></h4>
<div align="center">
  <img src="ecdsa-invalid-key.png" alt="ECDSA error due to invalid public key"/>
</div>
<div align="center">
  <span class="caption">Error: Public key doesn't match the signing key</span>
</div>
<p>When a program writes public key "0000" at offset 4, but the signature at
dictionary key 4 was created using public key "1515", the VM throws an error
because the public key doesn't match the one used to create the signature.</p>
<h2 id="implementation-references-3"><a class="header" href="#implementation-references-3">Implementation References</a></h2>
<p>These implementation references of the ecdsa builtin might not be exhaustive.</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/ecdsa.ts">TypeScript Signature Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/signature/signature_builtin_runner.py">Python Signature Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/signature.rs">Rust Signature Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/signature.zig">Zig Signature Builtin</a></li>
</ul>
<h2 id="resources-on-ecdsa-signature"><a class="header" href="#resources-on-ecdsa-signature">Resources on ECDSA signature</a></h2>
<p>If you're interested about the ecdsa signature and its use, take a look at those
references:</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/">STARK curve</a></li>
<li>Svetlin Nakov,
<a href="https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages">ECDSA: Elliptic Curve Signatures</a>,
2020</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitwise-builtin"><a class="header" href="#bitwise-builtin">Bitwise Builtin</a></h1>
<p>In the Cairo VM, the <em>Bitwise Builtin</em> enables bitwise operations—specifically
AND (<code>&amp;</code>), XOR (<code>^</code>), and OR (<code>|</code>)—on field elements. As a builtin, it’s an
integral part of the VM’s architecture, designed to support specific tasks where
bit-level manipulation is needed. In Cairo, these bitwise operations complement
the base instruction set of the VM by making it easier to perform tasks like bit
masking or combining values in particular use cases.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>The Bitwise builtin operates on a dedicated memory segment. Each operation uses
a block of 5 cells:</p>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Description</th><th>Role</th></tr></thead><tbody>
<tr><td>0</td><td>x value</td><td>Input</td></tr>
<tr><td>1</td><td>y value</td><td>Input</td></tr>
<tr><td>2</td><td>x &amp; y result</td><td>Output</td></tr>
<tr><td>3</td><td>x ^ y result</td><td>Output</td></tr>
<tr><td>4</td><td>x | y result</td><td>Output</td></tr>
</tbody></table>
</div>
<p>For instance, if <code>x = 5</code> (binary <code>101</code>) and <code>y = 3</code> (binary <code>011</code>), the outputs
are:</p>
<ul>
<li><code>5 &amp; 3 = 1</code> (binary <code>001</code>)</li>
<li><code>5 ^ 3 = 6</code> (binary <code>110</code>)</li>
<li><code>5 | 3 = 7</code> (binary <code>111</code>)</li>
</ul>
<p>This structure ensures efficient, native computation of bitwise operations when
needed, with strict validation to prevent errors (e.g., inputs exceeding the bit
limit).</p>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>Here’s a simple Cairo function using the Bitwise Builtin. We demonstrate it
using Cairo Zero, which is closer to machine code, and allows visual
representation of the low-level operations.</p>
<pre><code class="language-cairo">from starkware.cairo.common.cairo_builtins import BitwiseBuiltin

func bitwise_ops{bitwise_ptr: BitwiseBuiltin*}(x: felt, y: felt) -&gt; (and: felt, xor: felt, or: felt) {
    assert [bitwise_ptr] = x;        // Input x
    assert [bitwise_ptr + 1] = y;    // Input y
    let and = [bitwise_ptr + 2];     // x &amp; y
    let xor = [bitwise_ptr + 3];     // x ^ y
    let or = [bitwise_ptr + 4];      // x | y
    let bitwise_ptr = bitwise_ptr + 5;
    return (and, xor, or);
}
</code></pre>
<h2 id="implementation-references-4"><a class="header" href="#implementation-references-4">Implementation References</a></h2>
<p>These implementation references of the Bitwise Builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/bitwise/bitwise_builtin_runner.py">Python Bitwise Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-op-builtin"><a class="header" href="#ec-op-builtin">EC OP Builtin</a></h1>
<p>The <em>EC OP</em> (Elliptic Curve OPeration) builtin performs elliptic curve
operations on the STARK curve. Specifically, it computes R = P + mQ, where P and
Q are points on the curve and m is a scalar multiplier. Each point (P, Q and R)
is represented by a pair of field elements for its x and y coordinates.</p>
<p>This builtin enables efficient implementation of cryptographic algorithms that
require elliptic curve arithmetic, providing significant performance advantages
over implementing these operations directly in Cairo code.</p>
<h2 id="cells-organization-2"><a class="header" href="#cells-organization-2">Cells Organization</a></h2>
<p>The EC OP builtin has its own dedicated segment during a Cairo VM run. Each
operation is represented by a block of 7 cells:</p>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Description</th><th>Role</th></tr></thead><tbody>
<tr><td>0</td><td>P.x coordinate</td><td>Input</td></tr>
<tr><td>1</td><td>P.y coordinate</td><td>Input</td></tr>
<tr><td>2</td><td>Q.x coordinate</td><td>Input</td></tr>
<tr><td>3</td><td>Q.y coordinate</td><td>Input</td></tr>
<tr><td>4</td><td>m scalar value</td><td>Input</td></tr>
<tr><td>5</td><td>R.x coordinate</td><td>Output</td></tr>
<tr><td>6</td><td>R.y coordinate</td><td>Output</td></tr>
</tbody></table>
</div>
<p>The first five cells are inputs that must be written by the program, while the
last two cells are outputs that will be computed by the VM when read.</p>
<h3 id="valid-operation-example-1"><a class="header" href="#valid-operation-example-1">Valid Operation Example</a></h3>
<p>In this example, we can see a correctly configured EC OP builtin operation:</p>
<div align="center">
  <img src="ecop-segment.png" alt="EC OP builtin segment" width="450px"/>
</div>
<div align="center">
  <span class="caption">Snapshot 1 - Valid EC OP segment with complete input values</span>
</div>
<p>The program has properly set:</p>
<ul>
<li>Point P coordinates</li>
<li>Point Q coordinates</li>
<li>Scalar m value</li>
</ul>
<p>When the program reads cells at offsets 5 and 6, the VM computes R = P + mQ and
returns the result coordinates.</p>
<h3 id="error-condition-example"><a class="header" href="#error-condition-example">Error Condition Example</a></h3>
<p>In this example, we see an error condition when trying to read the result with
incomplete inputs:</p>
<div align="center">
  <img src="ecop-invalid-inputs.png" alt="Incomplete input values in EC OP builtin segment" width="450px"/>
</div>
<div align="center">
  <span class="caption">Snapshot 2 - Error due to incomplete input values</span>
</div>
<p>The program attempts to read the output cells at offsets 5 and 6, but the VM
cannot compute R = P + mQ because:</p>
<ul>
<li>Point P coordinates are properly set</li>
<li>Point Q coordinates are missing (both cells are empty)</li>
<li>Scalar m value is set</li>
</ul>
<p>Since the coordinates of point Q are missing, the VM cannot perform the
calculation and will throw an error when attempting to read the output cells.</p>
<p>If any input value is invalid (not a field element) or missing, the EC OP
builtin will fail when its output is accessed. All five input cells must contain
valid field elements before reading the output.</p>
<h2 id="implementation-references-5"><a class="header" href="#implementation-references-5">Implementation References</a></h2>
<p>These implementation references of the EC OP builtin might not be exhaustive:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/ecop.ts">TypeScript EC OP Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/ec/ec_op_builtin_runner.py">Python EC OP Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/ec_op.rs">Rust EC OP Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/ec_op.zig">Zig EC OP Builtin</a></li>
</ul>
<h2 id="resources-on-elliptic-curve-operations"><a class="header" href="#resources-on-elliptic-curve-operations">Resources on Elliptic Curve Operations</a></h2>
<p>If you're interested in elliptic curve operations and their cryptographic
applications:</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/">STARK Curve</a></li>
<li>Andrea Corbellini,
<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-builtin"><a class="header" href="#keccak-builtin">Keccak Builtin</a></h1>
<p>The <em>Keccak</em> builtin implements the core functionality of the SHA-3 family of
hash functions. It computes the new state <code>s'</code> by applying the 24 rounds of the
keccak-f1600 permutation to an input state <code>s</code>. This builtin is particularly
important for Ethereum compatibility, as Ethereum uses Keccak-256 for various
cryptographic operations.</p>
<h2 id="cells-organization-3"><a class="header" href="#cells-organization-3">Cells Organization</a></h2>
<p>The Keccak builtin uses a dedicated memory segment organized in blocks of 16
consecutive cells:</p>
<div class="table-wrapper"><table><thead><tr><th>Cell Range</th><th>Purpose</th><th>Description</th></tr></thead><tbody>
<tr><td>First 8 cells</td><td>Input state <code>s</code></td><td>Each cell stores 200 bits of the 1600-bit input state</td></tr>
<tr><td>Next 8 cells</td><td>Output state <code>s'</code></td><td>Each cell stores 200 bits of the 1600-bit output state</td></tr>
</tbody></table>
</div>
<p>The builtin processes each block independently, applying the following rules:</p>
<ol>
<li><strong>Input validation</strong>: Each input cell must contain a valid field element not
exceeding 200 bits (0 ≤ value &lt; 2^200)</li>
<li><strong>Lazy computation</strong>: The output state is only computed when any output cell
is accessed</li>
<li><strong>Caching</strong>: Once computed, results are cached to avoid redundant
calculations if other output cells from the same block are accessed</li>
</ol>
<h3 id="example-operation"><a class="header" href="#example-operation">Example Operation</a></h3>
<div align="center">
  <img src="keccak-segment.png" alt="keccak builtin segment"/>
</div>
<div align="center">
  <span class="caption">Keccak builtin segment with a complete operation</span>
</div>
<p>In this example:</p>
<ul>
<li>The program has written input values [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]
to the first 8 cells</li>
<li>Upon reading any of the output cells, the VM computes the keccak-f1600
permutation on the entire state</li>
<li>The resulting output state is stored in the next 8 cells</li>
<li>The computation happens only once per block and is cached</li>
</ul>
<h3 id="error-conditions-1"><a class="header" href="#error-conditions-1">Error Conditions</a></h3>
<p>The Keccak builtin will throw an error in the following scenarios:</p>
<ul>
<li>If any input cell contains a value that exceeds 200 bits (≥ 2^200)</li>
<li>If any input cell contains a relocatable value (pointer) instead of a field
element</li>
<li>If an output cell is read before all eight input cells have been initialized</li>
</ul>
<h2 id="implementation-references-6"><a class="header" href="#implementation-references-6">Implementation References</a></h2>
<p>These implementation references of the Keccak builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/keccak.ts">TypeScript Keccak Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/keccak/keccak_builtin_runner.py">Python Keccak Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/keccak.rs">Rust Keccak Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/keccak.zig">Zig Keccak Builtin</a></li>
</ul>
<h2 id="resources-on-keccak-hash"><a class="header" href="#resources-on-keccak-hash">Resources on Keccak Hash</a></h2>
<p>If you're interested in the Keccak hash function and its applications:</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#starknet_keccak">Hash Functions - Starknet Keccak</a></li>
<li>NIST,
<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions</a></li>
<li>Wikipedia,
<a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3 (Secure Hash Algorithm 3)</a></li>
<li>Keccak Team, <a href="https://keccak.team/keccak_specs_summary.html">Keccak Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-builtin"><a class="header" href="#poseidon-builtin">Poseidon Builtin</a></h1>
<p>The <em>Poseidon</em> builtin computes cryptographic hashes using the Poseidon hash
function, which is specifically optimized for zero-knowledge proofs and
efficient computation in algebraic circuits. As a core component in Cairo's
cryptographic operations, it uses the Hades permutation strategy that combines
full rounds and partial rounds to achieve both security and performance within
STARK proofs.</p>
<p>Poseidon is particularly important for Cairo applications because it offers:</p>
<ul>
<li>Better performance than Pedersen for multiple inputs</li>
<li>ZK-friendly design (optimized for constraints in ZK proof systems)</li>
<li>Strong cryptographic security properties</li>
</ul>
<h2 id="cells-organization-4"><a class="header" href="#cells-organization-4">Cells Organization</a></h2>
<p>The Poseidon builtin operates with a dedicated memory segment and follows a
deduction property pattern:</p>
<div class="table-wrapper"><table><thead><tr><th>Cells</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Input cells [0-2]</td><td>Store input state for Hades permutation</td></tr>
<tr><td>Output cells [3-5]</td><td>Store computed permutation results</td></tr>
</tbody></table>
</div>
<p>Each operation works with 6 consecutive cells - a block of 3 inputs followed by
3 outputs. When a program reads any output cell, the VM applies the Hades
permutation to the input cells and populates all three output cells with the
results.</p>
<h3 id="single-value-hashing-example"><a class="header" href="#single-value-hashing-example">Single Value Hashing Example</a></h3>
<div align="center">
  <img src="poseidon-builtin-valid.png" alt="valid poseidon builtin segment" width="600px"/>
</div>
<div align="center">
  <span class="caption">Poseidon builtin segment with valid inputs</span>
</div>
<p>For hashing a single value (42) in the first instance:</p>
<ol>
<li>The program writes the value to the first input cell (position 3:0)</li>
<li>The other input cells remain at their default value (0)</li>
<li>When reading the output cell (3:3), the VM:
<ul>
<li>Takes the initial state (42, 0, 0)</li>
<li>Applies padding: (42+1, 0, 0) = (43, 0, 0)</li>
<li>Computes the Hades permutation</li>
<li>Stores the result in output cell 3:3</li>
</ul>
</li>
</ol>
<p>The permutation result's first component becomes the hash output when hashing a
single value.</p>
<h3 id="sequence-hashing-example"><a class="header" href="#sequence-hashing-example">Sequence Hashing Example</a></h3>
<p>For hashing a sequence of values (73, 91) in the second instance:</p>
<ol>
<li>The program writes values to the first two input cells (positions 3:6 and
3:7)</li>
<li>Upon reading any output cell, the VM:
<ul>
<li>Takes the state (73, 91, 0)</li>
<li>Applies appropriate padding: (73, 91+1, 0)</li>
<li>Computes the Hades permutation</li>
<li>Stores all three results in the output cells (3:9, 3:10, 3:11)</li>
</ul>
</li>
</ol>
<p>When hashing sequences, all three output state components may be used for
further computation or chaining in multi-round hashing.</p>
<h3 id="error-condition"><a class="header" href="#error-condition">Error Condition</a></h3>
<div align="center">
  <img src="poseidon-builtin-error.png" alt="invalid poseidon builtin segment" width="300px"/>
</div>
<div align="center">
  <span class="caption">Poseidon builtin segment with invalid input</span>
</div>
<p>In this error example:</p>
<ul>
<li>The program attempts to write a relocatable value (pointer to cell 7:1) to
input cell 3:0</li>
<li>When trying to read output cell 3:3, the VM throws an error</li>
<li>The error occurs because the Poseidon builtin can only operate on field
elements, not memory addresses</li>
</ul>
<p>Input validation occurs at the time the output is read, rather than when inputs
are written, which is consistent with the deduction property pattern.</p>
<h2 id="implementation-references-7"><a class="header" href="#implementation-references-7">Implementation References</a></h2>
<p>These implementation references of the Poseidon builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/poseidon.ts">TypeScript Poseidon Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/poseidon/poseidon_builtin_runner.py">Python Poseidon Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/052e7cef977b336305c869fccbf24e1794b116ff/vm/src/vm/runners/builtin_runner/poseidon.rs">Rust Poseidon Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/poseidon.zig">Zig Poseidon Builtin</a></li>
</ul>
<h2 id="resources-on-poseidon-hash"><a class="header" href="#resources-on-poseidon-hash">Resources on Poseidon Hash</a></h2>
<p>If you're interested in the Poseidon hash function and its applications:</p>
<ul>
<li><a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#poseidon-hash">StarkNet - Hash Functions: Poseidon Hash</a></li>
<li><a href="https://github.com/starkware-industries/poseidon/tree/main">StarkWare - Poseidon Implementation</a></li>
<li><a href="https://eprint.iacr.org/2019/458.pdf">Poseidon: A New Hash Function for Zero-Knowledge Proof Systems</a>
(original paper)</li>
<li><a href="https://www.poseidon-hash.info/">Poseidon: ZK-friendly Hashing</a></li>
<li><a href="https://autoparallel.github.io/overview/index.html">Poseidon Journal</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-builtin"><a class="header" href="#mod-builtin">Mod Builtin</a></h1>
<p>In the Cairo Virtual Machine (VM), the <em>Mod Builtin</em> is a specialized builtin to
handle modular arithmetic operations—specifically addition and multiplication—on
field elements, or felts, within a given modulus. It’s built to compute
expressions like <code>a + b (mod p)</code> and <code>a * b (mod p)</code> efficiently.</p>
<p>To do this, it comes in two derivations: <code>AddModBuiltin</code> for addition and
<code>MulModBuiltin</code> for multiplication.</p>
<p>This builtin is a requirement for tasks like cryptographic applications or
computations heavy with modular arithmetic, especially when dealing with large
integers like <code>UInt384</code>.</p>
<h2 id="why-we-need-it"><a class="header" href="#why-we-need-it">Why We Need It</a></h2>
<p>Modular arithmetic is at the heart of many cryptographic protocols and
zero-knowledge proof systems. If you tried to implement these operations in pure
Cairo code, you’d quickly run into a wall of computational overhead—repeated
divisions and remainder checks considerably increasing the step count. The Mod
Builtin offers an optimized solution for handling these operations efficiently.
In practice, when manipulating
<a href="./ch12-10-arithmetic-circuits.html">Arithmetic Circuits</a>, you're using the Mod
Builtin under the hood.</p>
<h2 id="how-its-structured"><a class="header" href="#how-its-structured">How It’s Structured</a></h2>
<p>Every instance starts with seven input cells. Four of them—<code>p0</code>, <code>p1</code>, <code>p2</code>, and
<code>p3</code>—define the modulus <code>p</code> as a multi-word integer, typically split into four
96-bit chunks for <code>UInt384</code> compatibility. Then, the operands and results are
stored in the <code>values_ptr</code>, and <code>offsets_ptr</code> points to another table that tells
the builtin where to read or write those values, relative to the <code>values_ptr</code>.
Finally, <code>n</code> specifies how many operations to perform, and it needs to be a
multiple of the batch size.</p>
<p>The builtin’s core trick is deduction. Give it two parts of the triplet—like <code>a</code>
and <code>b</code>—and it figures out the third, <code>c</code>, based on the operation and modulus.
Or, if you provide <code>c</code> and one operand, it can solve for the other. It processes
these triplets in batches (often just one at a time), ensuring that
<code>op(a, b) = c + k * p</code> holds true, where <code>k</code> is a quotient within a specific
bound—small for addition, larger for multiplication. In practice, you set this
up with the <code>run_mod_p_circuit</code> function, which ties it all together. The values
table often overlaps with the <code>range_check96_ptr</code> segment to keep each word
under <code>2^96</code>, and offsets are defined as program literals using <code>dw</code> directives.</p>
<h2 id="putting-it-to-work-modular-addition"><a class="header" href="#putting-it-to-work-modular-addition">Putting It to Work: Modular Addition</a></h2>
<p>Let’s walk through an example of using the <code>AddMod</code> builtin to compute
<code>x + y (mod p)</code> for two <code>UInt384</code> values. This Cairo Zero code shows how the Mod
Builtin fits into a real program.</p>
<pre><code class="language-cairo">from starkware.cairo.common.cairo_builtins import UInt384, ModBuiltin
from starkware.cairo.common.modulo import run_mod_p_circuit
from starkware.cairo.lang.compiler.lib.registers import get_fp_and_pc

func add{range_check96_ptr: felt*, add_mod_ptr: ModBuiltin*, mul_mod_ptr: ModBuiltin*}(
    x: UInt384*, y: UInt384*, p: UInt384*
) -&gt; UInt384* {
    let (_, pc) = get_fp_and_pc();

    // Define pointers to the offsets tables, which come later in the code
    pc_label:
    let add_mod_offsets_ptr = pc + (add_offsets - pc_label);
    let mul_mod_offsets_ptr = pc + (mul_offsets - pc_label);

    // Load x and y into the range_check96 segment, which doubles as our values table
    // x takes slots 0-3, y takes 4-7—each UInt384 is 4 words of 96 bits
    assert [range_check96_ptr + 0] = x.d0;
    assert [range_check96_ptr + 1] = x.d1;
    assert [range_check96_ptr + 2] = x.d2;
    assert [range_check96_ptr + 3] = x.d3;
    assert [range_check96_ptr + 4] = y.d0;
    assert [range_check96_ptr + 5] = y.d1;
    assert [range_check96_ptr + 6] = y.d2;
    assert [range_check96_ptr + 7] = y.d3;

    // Fire up the modular circuit: 1 addition, no multiplications
    // The builtin deduces c = x + y (mod p) and writes it to offsets 8-11
    run_mod_p_circuit(
        p=[p],
        values_ptr=cast(range_check96_ptr, UInt384*),
        add_mod_offsets_ptr=add_mod_offsets_ptr,
        add_mod_n=1,
        mul_mod_offsets_ptr=mul_mod_offsets_ptr,
        mul_mod_n=0,
    );

    // Bump the range_check96_ptr forward: 8 input words + 4 output words = 12 total
    let range_check96_ptr = range_check96_ptr + 12;

    // Return a pointer to the result, sitting in the last 4 words
    return cast(range_check96_ptr - 4, UInt384*);

    // Offsets for AddMod: point to x (0), y (4), and the result (8)
    add_offsets:
    dw 0;  // x starts at offset 0
    dw 4;  // y starts at offset 4
    dw 8;  // result c starts at offset 8

    // No offsets needed for MulMod here
    mul_offsets:
}
</code></pre>
<p>In this function, we take two <code>UInt384</code> values, <code>x</code> and <code>y</code>, and a modulus <code>p</code>.
We write <code>x</code> and <code>y</code> into the values table starting at <code>range_check96_ptr</code>, then
use offsets—<code>[0, 4, 8]</code>—to tell the builtin where <code>x</code>, <code>y</code>, and the result <code>c</code>
live. The <code>run_mod_p_circuit</code> call triggers the <code>AddMod</code> builtin to compute
<code>x + y (mod p)</code> and store the result at offset 8. After adjusting the pointer,
we return a pointer to that result. It's a straightforward setup, but the
builtin handles the modular reduction for us, saving a ton of manual work.</p>
<p>Imagine a simple case with <code>n_words = 1</code> and <code>batch_size = 1</code>. If <code>p = 5</code>,
<code>x = 3</code>, and <code>y = 4</code>, the values table might hold <code>[3, 4, 2]</code>. The offsets
<code>[0, 1, 2]</code> point to <code>a = 3</code>, <code>b = 4</code>, and <code>c = 2</code>. The builtin checks:
<code>3 + 4 = 7</code>, and <code>7 mod 5 = 2</code>, which matches <code>c</code>. Everything checks out.</p>
<p>If things go wrong—say <code>x</code> is missing a word—the builtin flags a
<code>MissingOperand</code> error. For <code>MulMod</code>, if <code>b</code> and <code>p</code> aren't coprime and <code>a</code> is
unknown, you'll get a <code>ZeroDivisor</code> error. And if any word exceeds <code>2^96</code>, the
range check fails. These safeguards keep the operation reliable.</p>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under the Hood</a></h2>
<p>Let’s take a closer look at how the Mod Builtin is designed and why it’s built
the way it is. The goal here is efficiency—making modular arithmetic fast and
reliable in Cairo’s virtual machine—while keeping it practical for real-world
use, like cryptographic programs. To understand that, we’ll explore a few key
pieces of its structure and the thinking behind them.</p>
<p>First, why does it break numbers into 96-bit chunks, typically four of them for
a <code>UInt384</code>? That’s not an arbitrary choice. The Cairo VM already has a built-in
system for checking that numbers stay within certain bounds, called
<code>range_check96</code>, which works with 96-bit values. By aligning the Mod Builtin’s
word size with that system, it can lean on the VM’s existing machinery to ensure
each chunk of a number stays below <code>2^96</code>. For a <code>UInt384</code>, four 96-bit words
add up to 384 bits, which is big enough for most cryptographic applications.</p>
<p>Now, consider the difference between <code>AddMod</code> and <code>MulMod</code>. When you add two
numbers close to the modulus <code>p</code>, the result tops out at <code>2p - 2</code>. That’s why
<code>AddMod</code> limits its quotient <code>k</code>—the number of times <code>p</code> gets subtracted to wrap
the result—to just 2. If <code>a + b</code> is, say, <code>1.5p</code>, then <code>k = 1</code> and
<code>c = a + b - p</code> keeps everything in check. It’s a tight constraint because
addition doesn’t produce wildly large numbers. Multiplication, though, is
different. With <code>MulMod</code>, <code>a * b</code> could be enormous—think <code>p * p</code> or more—so the
default quotient bound is set way higher, up to <code>2^384</code>. This ensures it can
handle even the biggest products without running out of room to adjust.</p>
<p>The real cleverness comes in how the builtin figures out missing values, a
process called deduction. Instead of always starting from scratch, it works with
what’s already in memory. For <code>AddMod</code>, if you give it <code>a</code> and <code>b</code>, it computes
<code>c = a + b (mod p)</code>. If you give it <code>c</code> and <code>b</code>, it solves <code>a + b = c + k * p</code>
to find <code>a</code>, testing <code>k = 0</code> or <code>1</code>.</p>
<p>For <code>MulMod</code>, it’s trickier—multiplication isn’t as straightforward to reverse.
Here, it uses a mathematical tool called the extended GCD algorithm to solve
<code>a * b = c (mod p)</code>. If <code>b</code> and <code>p</code> share factors (their greatest common divisor
isn’t 1), there’s no unique solution, and it flags a <code>ZeroDivisor</code> error.
Otherwise, it finds the smallest <code>a</code> that fits.</p>
<p>Another design choice is the batch size, which is often just 1 in practice. The
builtin can process multiple operations at once—<code>batch_size</code> triplets of <code>a</code>,
<code>b</code>, and <code>c</code>—but keeping it at 1 simplifies things for most cases. It’s like
handling one addition or multiplication at a time, which is plenty for many
programs, though the option to scale up is there if you need it.</p>
<p>Why tie the values table to <code>range_check96_ptr</code>? It’s about efficiency again.
The VM’s range-checking system is already set up to monitor that segment, so
using it for the builtin’s values—like <code>a</code>, <code>b</code>, and <code>c</code>—means those numbers get
validated automatically.</p>
<h2 id="implementation-references-8"><a class="header" href="#implementation-references-8">Implementation References</a></h2>
<p>These implementation references of the Mod Builtin in various Cairo VM
implementations:</p>
<ul>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/modulo/mod_builtin_runner.py">Python Mod Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-arena-builtin"><a class="header" href="#segment-arena-builtin">Segment Arena Builtin</a></h1>
<p>The <em>Segment Arena</em> extends Cairo VM's memory handling by tracking segment
endpoints. This approach simplifies memory operations where segments need to be
allocated and finalized.</p>
<h2 id="cells-organization-5"><a class="header" href="#cells-organization-5">Cells Organization</a></h2>
<p>Each Segment Arena builtin instance works with blocks of 3 cells that maintain
the state of dictionaries:</p>
<ul>
<li>First cell: Contains the base address of the info pointer</li>
<li>Second cell: Contains the current number of allocated segments</li>
<li>Third cell: Contains the current number of squashed/finalized segments</li>
</ul>
<p>This structure works in close conjunction with an Info segment, which is also
organized in blocks of 3 cells:</p>
<ul>
<li>First cell: Base address of the segment</li>
<li>Second cell: End address of the segment (when squashed)</li>
<li>Third cell: Current number of squashed segments (squashing index)</li>
</ul>
<div align="center">
  <img src="segment-arena.png" alt="segment arena builtin segment"/>
</div>
<div align="center">
  <span class="caption">Segment Arena builtin segment</span>
</div>
<p>Let's take a look at two snapshots of a Segment Arena segment, during the
execution of a dummy program by the Cairo VM.</p>
<p>In the first snapshot, Let's look at first case when a dictionary is allocated:</p>
<ul>
<li><code>info_ptr</code> points to new info segment</li>
<li><code>n_dicts</code> increments to 1</li>
<li>Info segment created with three cells</li>
<li>Dictionary gets new segment <code>&lt;3:0&gt;</code></li>
</ul>
<p>Now, In the second case one more dictionary is allocated:</p>
<ul>
<li>Info segment grows by three cells per dictionary</li>
<li>Squashed dictionaries have end addresses set</li>
<li>Squashing indices assigned sequentially</li>
<li>Unfinished dictionaries have <code>0</code> end address</li>
</ul>
<div align="center">
  <img src="segment-arena-valid.png" alt="valid segment arena builtin segment"/>
</div>
<div align="center">
  <span class="caption">Snapshot 1 - Valid Segment Arena builtin segment</span>
</div>
<p>The second snapshot shows two error conditions. In the first case, an invalid
state occurs when <code>info_ptr</code> contains the <em>non-relocatable</em> value <code>ABC</code>. The
error is triggered when accessing the info segment. In the second case, the
error occurs when there's an inconsistent state as shown in the snapshot,
<code>n_squashed</code> is greater than <code>n_segments</code>.</p>
<div align="center">
  <img src="segment-arena-error.png" alt="invalid segment arena builtin segment"/>
</div>
<div align="center">
  <span class="caption">Snapshot 2 - Invalid Segment Arena builtin segment</span>
</div>
<h3 id="key-validation-rules"><a class="header" href="#key-validation-rules">Key Validation Rules</a></h3>
<p>The builtin enforces several rules:</p>
<ul>
<li>Each segment must be allocated and finalized exactly once</li>
<li>All cell values must be valid field elements</li>
<li>Segment sizes must be non-negative</li>
<li>Squashing operations must maintain sequential order</li>
<li>Info segment entries must correspond to segment allocations</li>
</ul>
<h2 id="implementation-references-9"><a class="header" href="#implementation-references-9">Implementation References</a></h2>
<p>These implementation references of the Segment Arena builtin might not be
exhaustive.</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/segmentArena.ts">TypeScript Segment Arena Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/segment_arena.rs">Rust Segment Arena Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/segment_arena.zig">Zig Segment Arena Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hints"><a class="header" href="#hints">Hints</a></h1>
<p>Cairo supports nondeterministic programming by allowing the prover to run extra
code to arbitrarily set values in memory during the execution of the program.
This mechanism is called "hints".</p>
<p>In practice, hints are mainly used to accelerate some operations that can be
verified for cheaper than they can be executed. For example, remember that our
ISA is primarily made of multiplication and addition. Computing the square root
of 25 using only field arithmetic, addition, and multiplication, would be very
expensive. However, it's trivial to ask the prover to fill the memory with the
expected result, that he can compute in any way that he wants, and simply
<em>constrain</em> the result to be the square root of 25.</p>
<p>The important part here is the <em>constraint</em>: When we let the prover fill the
memory with random values, we need to ensure that the prover was honest when
filling this memory cell. Failing to do so would lead to an "underconstrained
program", which is a security issue, as the proof is no longer sound. In our
example of the square root, it is sufficient to constrain that, when squared,
the provided result is equal to 25.</p>
<p>This technique is widely used in the Cairo standard library for typical
operations, and provide a significiative advantage to the proving system.</p>
<p>Hints are not part of the proved trace, so any work they do is “free” from the
verifier’s perspective. Hints are typically written in any programming language,
since they are only used by the prover’s runner.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runner"><a class="header" href="#runner">Runner</a></h1>
<p>The Cairo Runner is the main executable program that orchestrates the execution
of a compiled Cairo program. It is the practical implementation of the
theoretical Cairo machine, bringing together the memory model, execution model,
builtins, and hints.</p>
<p>Its current implementation is written in Rust, developed by
<a href="https://github.com/lambdaclass/cairo-vm">LambdaClass</a> and it is available as a
standalone binary, as well as a library.</p>
<h2 id="runner-modes"><a class="header" href="#runner-modes">Runner Modes</a></h2>
<p>The Cairo Runner can operate in different modes depending on the intended
purpose of execution. It takes compiled Cairo bytecode (plus hints) and produces
an execution trace and memory, preparing inputs for the STARK prover.</p>
<p>In <strong>Execution Mode</strong>, the runner simply runs the program to completion,
executing hints and the state transition function of the Cairo VM. This mode is
mostly useful to debug or test program logic without the overhead of proof
generation. It fully executes the program step-by-step, using hints to fill in
nondeterministic values and then applies each instruction's transitions to build
the full state trace and final memory. The output includes the trace, the chosen
memory, and the initial/final register states (<code>pc</code>, <code>ap</code>, <code>fp</code>). If any hint or
instruction check fails, the runner halts with failure.</p>
<p>In <strong>Proof Mode</strong>, the runner not only executes the program but also prepares
the inputs needed for proof generation. This is the primary mode for production
use, when one wants to generate a proof of execution. As the runner executes the
program, it records the VM state at each step, and builds the "execution trace"
and final memory state. After the execution completes, it is possible to extract
a dump of the memory, and the sequential register states, composing the
execution trace.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>

        <script>
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>

    </div>
</body>

</html>
