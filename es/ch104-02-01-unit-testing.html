<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Unit Testing - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch104-02-01-unit-testing.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch104-02-01-unit-testing.html"><strong aria-hidden="true">18.2.1.</strong> Unit Testing</a></li><li class="chapter-item "><a href="ch104-02-02-integration-testing.html"><strong aria-hidden="true">18.2.2.</strong> Integration Testing</a></li><li class="chapter-item "><a href="ch104-02-03-fuzz-testing.html"><strong aria-hidden="true">18.2.3.</strong> Property-Based Testing</a></li><li class="chapter-item "><a href="ch104-02-04-fork-testing.html"><strong aria-hidden="true">18.2.4.</strong> Fork Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("es");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch104-02-01-unit-testing.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-02-01-unit-testing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h1>
<p>You've written a smart contract. How do you know it works?</p>
<p>The most direct way is to test individual functions in isolation. That's what
<em>unit testing</em> is: you pick a function, give it some inputs, and check that it
does what you expect. If your <code>transfer</code> function should move tokens between
accounts, you write a test that calls it and verifies the balances changed
correctly.</p>
<p>In this section, we'll explore two approaches Cairo gives us for unit testing,
when to use each, and the tools that make testing practical.</p>
<h2 id="two-ways-to-test-a-contract"><a class="header" href="#two-ways-to-test-a-contract">Two Ways to Test a Contract</a></h2>
<p>Cairo offers two approaches to unit testing:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>What You're Testing</th><th>When to Use It</th></tr></thead><tbody>
<tr><td><code>contract_state_for_testing</code></td><td>Internal functions</td><td>Logic not in the ABI</td></tr>
<tr><td>Deploy + dispatcher</td><td>External interface (ABI)</td><td>What users actually call</td></tr>
</tbody></table>
</div>
<p>Both test a single contract in isolation. The difference is whether you're
testing through the public interface or reaching into the internals.</p>
<h2 id="testing-internal-functions"><a class="header" href="#testing-internal-functions">Testing Internal Functions</a></h2>
<p>Sometimes the function you want to test isn't in the contract's public
interface. Maybe it's a helper function in a private <code>impl</code> block, or it uses
<code>#[generate_trait]</code>. You could test it indirectly through public functions, but
that makes tests harder to write and failures harder to diagnose.</p>
<p>Cairo's <code>contract_state_for_testing</code> function gives you direct access. It
creates a <code>ContractState</code> without actually deploying anything, so you can call
internal functions and inspect storage.</p>
<h3 id="example-testing-a-private-setter"><a class="header" href="#example-testing-a-private-setter">Example: Testing a Private Setter</a></h3>
<p>Let's say we have a <code>PizzaFactory</code> contract with an internal <code>set_owner</code>
function that we don't expose publicly:</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait IPizzaFactory&lt;TContractState&gt; {
    fn increase_pepperoni(ref self: TContractState, amount: u32);
    fn increase_pineapple(ref self: TContractState, amount: u32);
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn change_owner(ref self: TContractState, new_owner: ContractAddress);
    fn make_pizza(ref self: TContractState);
    fn count_pizza(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
pub mod PizzaFactory {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ContractAddress, get_caller_address};
    use super::IPizzaFactory;

    #[storage]
    pub struct Storage {
        pepperoni: u32,
        pineapple: u32,
        pub owner: ContractAddress,
        pizzas: u32,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.pepperoni.write(10);
        self.pineapple.write(10);
        self.owner.write(owner);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PizzaEmission: PizzaEmission,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PizzaEmission {
        pub counter: u32,
    }

    #[abi(embed_v0)]
    impl PizzaFactoryimpl of super::IPizzaFactory&lt;ContractState&gt; {
        fn increase_pepperoni(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pepperoni.write(self.pepperoni.read() + amount);
        }

        fn increase_pineapple(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pineapple.write(self.pineapple.read() + amount);
        }

        fn make_pizza(ref self: ContractState) {
            assert!(self.pepperoni.read() &gt; 0, "Not enough pepperoni");
            assert!(self.pineapple.read() &gt; 0, "Not enough pineapple");

            let caller: ContractAddress = get_caller_address();
            let owner: ContractAddress = self.get_owner();

            assert!(caller == owner, "Only the owner can make pizza");

            self.pepperoni.write(self.pepperoni.read() - 1);
            self.pineapple.write(self.pineapple.read() - 1);
            self.pizzas.write(self.pizzas.read() + 1);

            self.emit(PizzaEmission { counter: self.pizzas.read() });
        }

        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
            self.set_owner(new_owner);
        }

        fn count_pizza(self: @ContractState) -&gt; u32 {
            self.pizzas.read()
        }
    }

    #[generate_trait]
    pub impl InternalImpl of InternalTrait {
        fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
            let caller: ContractAddress = get_caller_address();
            assert!(caller == self.get_owner(), "Only the owner can set ownership");

            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p>18-1: A PizzaFactory contract with internal
functions</span></p>
<p>The <code>InternalTrait</code> contains <code>set_owner</code>, which isn't part of the ABI. To test
it, we import the trait and call it directly on a test state:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_storage_direct_access() {
    // Get a ContractState instance without deploying the contract
    let mut state = PizzaFactory::contract_state_for_testing();

    // Access storage directly - read initial value (default is 0)
    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());

    // Call internal function directly
    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    // Note: set_owner checks caller == current owner. Since both are zero address
    // initially (no deployment context), this check passes.
    state.set_owner(owner);

    // Verify storage was updated
    assert_eq!(state.owner.read(), owner);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-2: Testing internal
functions with contract_state_for_testing</span></p>
<p>We import <code>InternalTrait</code> to access <code>set_owner</code> and <code>StoragePointerReadAccess</code>
to read storage. Since there's no deployment, the test runs instantly.</p>
<h2 id="testing-the-external-interface"><a class="header" href="#testing-the-external-interface">Testing the External Interface</a></h2>
<p>Most of your tests will deploy the contract and interact through its public
interface. This is closer to how users will actually interact with your
contract, which means these tests catch real-world bugs.</p>
<h3 id="the-deploy-and-test-pattern"><a class="header" href="#the-deploy-and-test-pattern">The Deploy-and-Test Pattern</a></h3>
<p>The pattern is straightforward: declare the contract class, deploy it with
constructor arguments, and interact through a dispatcher.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span>fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-3: Deploying a contract for
unit testing</span></p>
<p>This helper function handles the boilerplate: declaring, preparing calldata,
deploying, and returning a dispatcher you can use in tests.</p>
<h2 id="testing-with-cheatcodes"><a class="header" href="#testing-with-cheatcodes">Testing with Cheatcodes</a></h2>
<p>Here's where things get interesting. Real smart contracts don't run in a vacuum.
They check who's calling them (<code>get_caller_address</code>), what time it is
(<code>get_block_timestamp</code>), and other context that's hard to control in tests.</p>
<p>Starknet Foundry provides <em>cheatcodes</em> that let you manipulate this context.
Think of them as ways to set up the exact scenario you want to test.</p>
<h3 id="mocking-the-caller"><a class="header" href="#mocking-the-caller">Mocking the Caller</a></h3>
<p>Access control is everywhere in smart contracts. An <code>only_owner</code> function needs
to know who's calling it. In tests, you control this with
<code>start_cheat_caller_address</code>:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-4: Testing access control
by mocking the caller</span></p>
<p>We deploy the contract, then use <code>start_cheat_caller_address</code> to impersonate the
owner. Now <code>get_caller_address()</code> returns the owner's address for all calls to
this contract.</p>
<blockquote>
<p>Test both paths: the happy path where an authorized caller succeeds, and the
rejection path where an unauthorized caller fails. Many security bugs come
from forgetting to check permissions in some code path.</p>
</blockquote>
<h3 id="verifying-events"><a class="header" href="#verifying-events">Verifying Events</a></h3>
<p>When your contract emits events, off-chain systems like indexers and frontends
depend on them being correct. Use <code>spy_events</code> to capture and check them:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-5: Capturing and verifying
events</span></p>
<p>Create the spy before the action that emits events, then use
<code>spy.assert_emitted</code> to check what was emitted.</p>
<h3 id="reading-storage-directly"><a class="header" href="#reading-storage-directly">Reading Storage Directly</a></h3>
<p>Sometimes you need to verify storage values that don't have public getters. The
<code>load</code> function reads raw storage:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, EventSpyAssertionsTrait, declare, load, spy_events,
</span><span class="boring">    start_cheat_caller_address, stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::storage::StoragePointerReadAccess;
</span><span class="boring">use starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use crate::pizza::PizzaFactory::{Event as PizzaEvents, InternalTrait, PizzaEmission};
</span><span class="boring">use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_storage_direct_access() {
</span><span class="boring">    // Get a ContractState instance without deploying the contract
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">
</span><span class="boring">    // Access storage directly - read initial value (default is 0)
</span><span class="boring">    assert_eq!(state.owner.read(), contract_address_const::&lt;0&gt;());
</span><span class="boring">
</span><span class="boring">    // Call internal function directly
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    // Note: set_owner checks caller == current owner. Since both are zero address
</span><span class="boring">    // initially (no deployment context), this check passes.
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">
</span><span class="boring">    // Verify storage was updated
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-6: Reading storage
directly to verify initial state</span></p>
<p>Pass the contract address, a storage key (use <code>selector!("variable_name")</code>), and
how many felts to read.</p>
<h2 id="cheatcode-reference"><a class="header" href="#cheatcode-reference">Cheatcode Reference</a></h2>
<p>Here are the cheatcodes you'll use most often:</p>
<div class="table-wrapper"><table><thead><tr><th>Cheatcode</th><th>What It Does</th><th>Common Use Case</th></tr></thead><tbody>
<tr><td><code>start_cheat_caller_address</code></td><td>Mock <code>get_caller_address</code></td><td>Testing access control</td></tr>
<tr><td><code>stop_cheat_caller_address</code></td><td>Stop mocking caller</td><td>Reset after test</td></tr>
<tr><td><code>start_cheat_block_timestamp</code></td><td>Mock block timestamp</td><td>Time-dependent logic</td></tr>
<tr><td><code>start_cheat_block_number</code></td><td>Mock block number</td><td>Block-dependent logic</td></tr>
<tr><td><code>spy_events</code></td><td>Capture emitted events</td><td>Verify event data</td></tr>
<tr><td><code>load</code></td><td>Read raw storage</td><td>Verify internal state</td></tr>
<tr><td><code>store</code></td><td>Write raw storage</td><td>Set up test preconditions</td></tr>
</tbody></table>
</div>
<p>For the full list, see the
<a href="https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html">Starknet Foundry cheatcode documentation</a>.</p>
<h2 id="choosing-your-approach"><a class="header" href="#choosing-your-approach">Choosing Your Approach</a></h2>
<div class="table-wrapper"><table><thead><tr><th>What You're Testing</th><th>Use</th></tr></thead><tbody>
<tr><td>Internal helper function</td><td><code>contract_state_for_testing</code></td></tr>
<tr><td>Pure calculation logic</td><td><code>contract_state_for_testing</code></td></tr>
<tr><td>Access control</td><td>Deploy + cheatcodes</td></tr>
<tr><td>Events</td><td>Deploy + spy_events</td></tr>
<tr><td>Constructor logic</td><td>Deploy + assertions</td></tr>
<tr><td>Public function behavior</td><td>Deploy + dispatcher</td></tr>
</tbody></table>
</div>
<p>One thing to know: you can't mix approaches in the same test. If you deploy and
get a dispatcher, use the dispatcher. If you use <code>contract_state_for_testing</code>,
work with that state object directly.</p>
<h2 id="writing-good-tests"><a class="header" href="#writing-good-tests">Writing Good Tests</a></h2>
<p>A few patterns make tests easier to write and maintain:</p>
<p><strong>One behavior per test.</strong> When a test fails, you want to know exactly what
broke. A test named <code>test_transfer</code> that checks balances, events, and error
cases is hard to debug. Split it:</p>
<pre><code class="language-cairo noplayground">// Each test checks one thing
#[test]
fn test_transfer_updates_balances() { /* ... */ }

#[test]
fn test_transfer_emits_event() { /* ... */ }

// Not this - too much in one test
#[test]
fn test_transfer() {
    // Checks balances AND events AND error cases...
}
</code></pre>
<p><strong>Name tests so failures tell you what's wrong.</strong> Use
<code>test_&lt;function&gt;_&lt;expected_behavior&gt;</code>:</p>
<ul>
<li><code>test_transfer_updates_balances</code></li>
<li><code>test_transfer_fails_on_insufficient_balance</code></li>
<li><code>test_change_owner_requires_current_owner</code></li>
</ul>
<p><strong>Clean up cheatcodes.</strong> Always pair <code>start_cheat_*</code> with the corresponding
<code>stop_cheat_*</code>:</p>
<pre><code class="language-cairo noplayground">start_cheat_caller_address(address, owner());
// ... test logic ...
stop_cheat_caller_address(address);
</code></pre>
<p><strong>Test edge cases.</strong> Unit tests are perfect for boundary conditions: zero
values, maximum values like <code>u256::MAX</code>, empty arrays, and off-by-one scenarios.</p>
<h2 id="when-unit-tests-arent-enough"><a class="header" href="#when-unit-tests-arent-enough">When Unit Tests Aren't Enough</a></h2>
<p>Unit tests verify single-contract behavior. When your contract talks to other
contracts, you'll want
<a href="./ch104-02-02-integration-testing.html">integration testing</a> to test those
interactions.</p>
<p>For testing that properties hold across many random inputs, see
<a href="./ch104-02-03-fuzz-testing.html">property-based testing</a>. And when you need to
test against real deployed contracts like AMMs or lending protocols,
<a href="./ch104-02-04-fork-testing.html">fork testing</a> lets you do that.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Unit testing in Cairo means testing one contract at a time. You have two
approaches:</p>
<ul>
<li>
<p><strong><code>contract_state_for_testing</code></strong> for internal functions: fast, no deployment,
direct access to contract state.</p>
</li>
<li>
<p><strong>Deploy + dispatcher + cheatcodes</strong> for the public interface: tests what
users actually experience, with tools to control caller identity, timestamps,
and more.</p>
</li>
</ul>
<p>Start with the public interface tests. They catch more real bugs. Reach for
<code>contract_state_for_testing</code> when you have internal logic that's worth testing
directly.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch104-02-testing-smart-contracts.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch104-02-02-integration-testing.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch104-02-testing-smart-contracts.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch104-02-02-integration-testing.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
