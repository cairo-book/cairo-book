# Interacting with other contracts and classes using Dispatchers and syscalls

Each time a contract interface is defined, two dispatchers are automatically created and exported by the compiler. Let's consider an interface that we named IERC20, these would be:

1. The Contract Dispatcher `IERC20Dispatcher`
2. The Library Dispatcher `IERC20LibraryDispatcher`

The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to call the functions defined in the interface on the dispatcher struct.

In this chapter, we are going to discuss what these are, how they work and how to use them.

To effectively break down the concepts in this chapter, we are going to be using the IERC20 interface from the previous chapter (refer to Listing 99-4):

## Contract Dispatcher

As mentioned previously, traits annotated with the `#[starknet::interface]` attribute automatically generate a dispatcher and a trait on compilation.
Our `IERC20` interface is expanded into something like this:

**Note:** The expanded code for our IERC20 interface is a lot longer, but to keep this chapter concise and straight to the point, we focused on one view function `name`, and one external function `transfer`.

```rust,noplayground
{{#include ../listings/ch99-starknet-smart-contracts/listing_99_05_dispatcher_trait/src/lib.cairo}}
```

<span class="caption">Listing 99-5: An expanded form of the IERC20 trait</span>

As you can see, the "classic" dispatcher is just a struct that wraps a contract address and implements the `DispatcherTrait` generated by the compiler, allowing us to call functions from another contract. This means that we can instantiate a struct with the address of the contract we want to call, and then simply call the functions defined in the interface on the dispatcher struct as if they were methods of that type.

It's also worthy of note that all these are abstracted behind the scenes thanks to the power of Cairo plugins.

### Calling Contracts using the Contract Dispatcher

This is an example of a contract named `TokenWrapper` using a dispatcher to call functions defined on an ERC-20 token. Calling `transfer_token` will modify the state of the contract deployed at `contract_address`.

```rust,noplayground
{{#rustdoc_include ../listings/ch99-starknet-smart-contracts/listing_99_06_sample_contract/src/lib.cairo:here}}
```

<span class="caption">Listing 99-6: A sample contract which uses the Contract Dispatcher</span>

As you can see, we had to first import `IERC20DispatcherTrait` and `IERC20Dispatcher` generated by the compiler, which allows us to make calls to the methods implemented for the `IERC20Dispatcher` struct (`name`, `transfer`, etc), passing in the `contract_address` of the contract we want to call in the `IERC20Dispatcher` struct.

## Library Dispatcher

The key difference between the contract dispatcher and the library dispatcher lies in the execution context of the logic defined in the class. While regular dispatchers are used to call functions from **contracts** (with an associated state), library dispatchers are used to call **classes** (stateless).

Let's consider two contracts A and B.

When A uses `IBDispatcher` to call functions from the **contract** B, the execution context of the logic defined in B is that of B. This means that the value returned by `get_caller_address()` in B will return the address of A, and updating a storage variable in B will update the storage of B.

When A uses `IBLibraryDispatcher` to call functions from the **class** of B, the execution context of the logic defined in B's class is that of A. This means that the value returned by `get_caller_address()` variable in B will return the address of the caller of A, and updating a storage variable in B's class will update the storage of A (remember that the **class** of B is stateless; there is no state that can be updated!)

The expanded form of the struct and trait generated by the compiler look like:

```rust,noplayground
{{#include ../listings/ch99-starknet-smart-contracts/listing_99_07_library_dispatcher/src/lib.cairo}}
```

Notice that the main difference between the regular contract dispatcher and the library dispatcher is that the former uses `call_contract_syscall` while the latter uses `library_call_syscall`.

<span class="caption">Listing 99-7: An expanded form of the IERC20 trait</span>

### Calling Contracts using the Library Dispatcher

Below's a sample code for calling contracts using the Library Dispatcher.

```rust,noplayground
{{#include ../listings/ch99-starknet-smart-contracts/listing_99_08_using_library_dispatcher/src/lib.cairo:here}}
```

<span class="caption">Listing 99-8: A sample contract using the Library Dispatcher</span>

As you can see, we had to first import in our contract the `IContractBDispatcherTrait` and `IContractBLibraryDispatcher` which were generated from our interface by the compiler. Then, we can create an instance of `IContractBLibraryDispatcher` passing in the `class_hash` of the class we want to make library calls to. From there, we can call the functions defined in that class, executing its logic in the context of our contract. When we call `set_value` on ContractA, it will make a library call to the `set_value` function in ContractB, updating the value of the storage variable `value` in ContractA.

## Using low-level syscalls

Another way to call other contracts and classes is to use the `starknet::call_contract_syscall`and `starknet::library_call_syscall` system calls. The dispatchers we described in the previous sections are high-level syntaxes for these low-level system calls.

Using these syscalls can be handy for customized error handling or to get more control over the serialization/deserialization of the call data and the returned data. Here's an example demonstrating how to use a `call_contract_sycall` to call the `transfer` function of an ERC20 contract:

```rust,noplayground
{{#include ../listings/ch99-starknet-smart-contracts/listing_99_09_call_contract_syscall/src/lib.cairo}}
```

<span class="caption">Listing 99-9: A sample contract using syscalls</span>

To use this syscall, we passed in the contract address, the selector of the function we want to call, and the call arguments.

The call arguments must be provided as an array of `felt252`. To build this array, we serialize the expected function parameters into an `Array<felt252>` using the `Serde` trait, and then pass this array as calldata. At the end, we are returned a serialized value which we'll need to deserialize ourselves!
