# Interacting with Another Contract

We explained in the previous section that the definition of entrypoints contained in the ABI allows anyone to create a valid call to a contract. But how does it work regarding interaction between contracts?

This is where [contract interfaces][interfaces] come into play. They define all the functions a contract exposes publicly, except the standalone public functions. Note that one contract can implement multiple interfaces.

Each time a contract interface is defined, multiple _dispatchers_ are automatically created and exported by the compiler. For example, in the case of the standard `ERC20` contract, importing the `ERC20` interface provides a direct access to:

- The Contract Dispatcher `IERC20Dispatcher` and the Safe Contract Dispatcher `IERC20SafeDispatcher`.
- The Library Dispatcher `IERC20LibraryDispatcher` and the Safe Library Dispatcher `IERC20SafeLibraryDispatcher`.

These dispatchers are actually structs that contain only one field:

- `contract_address` for contract dispatchers and safe contract dispatchers used to interact with a contract.
- `class_hash` for library dispatchers and safe library dispatchers used to borrow code from another contract class.

These structs have associated methods, defined in their respective traits. To continue with our `ERC20` example:

- `IERC20DispatcherTrait` and `IERC20SafeDispatcherTrait` define functions used to interact with an `ERC20` contract instance deployed on Starknet network.
- `IERC20LibraryDispatcherTrait` and `IERC20SafeLibraryDispatcherTrait` define functions used to borrow code from a `ERC20` contract class.

Implementations of these traits use [syscalls][syscalls] under the hood, and more specifically `call_contract_syscall`.

> **Important Note**: safe dispatchers and safe library dispatchers are currently unavailable on Starknet mainnet and testnet. For now, you should not use them. The difference between regular contract dispatchers and safe dispatchers is that regular dispatchers call `unwrap_syscall` method on the `SyscallResult` and panic if the contract call fails, while safe dispatchers are returning the `SyscallResult` without unwrapping it. The Cairo test runner allows to propagate errors to the calling contract when safe dispatchers are used, but this is not possible on Starknet! This will change in the future, allowing safe dispatchers to be used on Starknet.

In this chapter, we are going to focus on cross-contract interaction using contract dispatchers. To effectively break down the concepts involved, we will use the `ERC20` interface as an illustration.

We will discuss library dispatchers in the [next chapter][library dispatcher].

[interfaces]: ./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-contracts-blueprint
[syscalls]: ./appendix-08-system-calls.md
[library dispatcher]: ./ch15-03-borrowing-code-from-another-contract-class.md

## Contract Dispatcher and Trait

As mentioned previously, traits annotated with the `#[starknet::interface]` attribute automatically generate multiple dispatchers and their associated traits on compilation, including the contract dispatcher and the contract dispatcher trait.

Listing {{#ref expanded-ierc20dispatcher}} shows an example using a simplified version of the `IERC20` interface, including only the `name` view function and the `transfer` external function:

```rust,noplayground
{{#include ../listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/src/lib.cairo}}
```

{{#label expanded-ierc20dispatcher}}
<span class="caption">Listing {{#ref expanded-ierc20dispatcher}}: A simplified example of the `IERC20Dispatcher` and its associated trait and impl</span>

As you can see, the contract dispatcher is a simple struct that wraps a contract address and implements the `DispatcherTrait` generated by the compiler using syscalls, allowing us to call functions on a specific contract instance. This means that we can instantiate a struct with the address of the contract we want to call, and then simply call the functions defined in the interface on the dispatcher struct as if they were methods of that type.

## Calling Contracts Using the Contract Dispatcher

Let's see how to effectively call another contract using a contract dispatcher. Listing {{#ref contract-dispatcher}} shows a contract named `TokenWrapper` that uses a contract dispatcher to call functions defined in a `ERC20` contract:

```rust,noplayground
{{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:here}}
```

{{#label contract-dispatcher}}
<span class="caption">Listing {{#ref contract-dispatcher}}: A sample contract which uses the contract dispatcher to call another contract</span>

In order to be able to call functions on the `ERC20` contract, what you need to do is:

- importing both `IERC20Dispatcher` struct and `IERC20DispatcherTrait` trait. Indeed, both of them are required in the scope to call a method on the struct. This is with the following line:

```rust,noplayground
{{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:import}}
```

- calling the desired method on an instance of the struct. This can be achieved without defining a local variable to store the instance of the struct, like this:

```rust,noplayground
{{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:no_local_variable}}
```

If you are going to use multiple times the contract dispatcher struct to make external call or for better lisibility, you can define a local variable to store the instance:

```rust,noplayground
{{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:local_variable}}
```

Calling `transfer_token` external function will modify the state of the contract deployed at `contract_address`.

> Note: if the variable name is `contract_address`, you don't need to write `contract_address: contract_address` when instantiating the contract dispatcher struct. Simply doing `IERC20Dispatcher { contract_address }` will work.

## Calling Contracts Using `call_contract_syscall` Low-level System Calls

Another way to call other contracts is to directly use the `call_contract_syscall` Starknet system call. This syscall is an equivalent of the functionality provided by `call` opcode in Solidity smart contracts.

Using this syscall can be handy for customized error handling or to get more control over the serialization/deserialization of the call data and the returned data. Listing {{#ref syscalls}} shows an example demonstrating how to use a `call_contract_sycall` syscall to call the `transfer` function of an `ERC20` contract:

```rust,noplayground
{{#include ../listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/src/lib.cairo}}
```

{{#label syscalls}}
<span class="caption">Listing {{#ref syscalls}}: A sample contract using `call_contract_sycall` syscall</span>

To use this syscall, we passed in the contract address, the selector of the function we want to call and the call arguments.
The call arguments must be provided as an span of `felt252`. To build this span, we serialize the expected function parameters into an `Array<felt252>` using the `Serde` trait, and then convert this array into a span and pass it as calldata. At the end, we are returned a serialized value which we'll need to deserialize ourselves!
