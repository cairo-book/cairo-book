msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-12-11 02:32+0900\n"
"Last-Translator: cryptonerdcn <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:1
msgid "The Cairo Programming Language"
msgstr "Cairo编程语言"

#: src/SUMMARY.md:4
msgid "Foreword"
msgstr "前言"

#: src/SUMMARY.md:5
msgid "Introduction"
msgstr "介绍"

#: src/SUMMARY.md:7
msgid "Getting Started"
msgstr "入门"

#: src/SUMMARY.md:11
msgid "Installation"
msgstr "安装"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr "Hello，world！"

#: src/SUMMARY.md:14
msgid "Common Programming Concepts"
msgstr "常见的编程概念"

#: src/SUMMARY.md:17
msgid "Variables and Mutability"
msgstr "变量与可变性"

#: src/SUMMARY.md:18
msgid "Data Types"
msgstr "数据类型"

#: src/SUMMARY.md:19
msgid "Functions"
msgstr "函数"

#: src/SUMMARY.md:20
msgid "Comments"
msgstr "注释"

#: src/SUMMARY.md:21
msgid "Control Flow"
msgstr "控制流"

#: src/SUMMARY.md:23
msgid "Common Collections"
msgstr "常见集合"

#: src/SUMMARY.md:26
msgid "Arrays"
msgstr "数组"

#: src/SUMMARY.md:27
msgid "Dictionaries"
msgstr "字典"

#: src/SUMMARY.md:28
msgid "Custom Data Structures"
msgstr "自定义数据结构"

#: src/SUMMARY.md:30
msgid "Understanding Ownership"
msgstr "认识所有权"

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr "什么是所有权？"

#: src/SUMMARY.md:34
msgid "References and Snapshots"
msgstr "引用和快照"

#: src/SUMMARY.md:36
msgid "Using Structs to Structure Related Data"
msgstr "使用结构体组织相关联的数据"

#: src/SUMMARY.md:39
msgid "Defining and Instantiating Structs"
msgstr "结构体的定义和实例化"

#: src/SUMMARY.md:40
msgid "An Example Program Using Structs"
msgstr "结构体实例程序"

#: src/SUMMARY.md:41
msgid "Method Syntax"
msgstr "方法语法"

#: src/SUMMARY.md:43
msgid "Enums and Pattern Matching"
msgstr "枚举和模式匹配"

#: src/SUMMARY.md:43
msgid "Enums"
msgstr "枚举的定义"

#: src/SUMMARY.md:47
msgid "The Match Control Flow Construct"
msgstr "Match控制流结构"

#: src/SUMMARY.md:49
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "使用包、Crate 和模块管理Cairo项目"

#: src/SUMMARY.md:53
msgid "Packages and Crates"
msgstr "包和 Crate"

#: src/SUMMARY.md:54
msgid "Defining Modules to Control Scope"
msgstr "定义模块以控制作用域"

#: src/SUMMARY.md:55
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "引用模块项目的路径"

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "使用 ‘use’ 关键字将路径引入作用域"

#: src/SUMMARY.md:57
msgid "Separating Modules into Different Files"
msgstr "将模块拆分成多个文件"

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr "泛型"

#: src/SUMMARY.md:63
msgid "Generic Functions"
msgstr "在函数定义中使用泛型"

#: src/SUMMARY.md:64
msgid "Traits in Cairo"
msgstr "Cairo中的Trait"

#: src/SUMMARY.md:66
msgid "Testing Cairo Programs"
msgstr "测试Cairo 程序"

#: src/SUMMARY.md:70
msgid "How To Write Tests"
msgstr "如何编写测试"

#: src/SUMMARY.md:71
msgid "Testing Organization"
msgstr "测试的组织结构"

#: src/SUMMARY.md:73
msgid "Error Handling"
msgstr "错误处理"

#: src/SUMMARY.md:77
msgid "Unrecoverable Errors with panic"
msgstr "用panic处理不可恢复的错误"

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr "用Result处理可恢复的错误"

#: src/SUMMARY.md:80
msgid "Advanced Features"
msgstr "高级特性"

#: src/SUMMARY.md:84
msgid "Operator Overloading"
msgstr "操作符重载"

#: src/SUMMARY.md:85
msgid "Macros"
msgstr "宏"

#: src/SUMMARY.md:86
msgid "Working with Hashes"
msgstr "使用哈希"

#: src/SUMMARY.md:90
msgid "Starknet Smart Contracts"
msgstr "Starknet智能合约"

#: src/SUMMARY.md:92
msgid "Introduction to smart-contracts"
msgstr "智能合约简介"

#: src/SUMMARY.md:93
msgid "A simple contract"
msgstr "一份简单的合约"

#: src/SUMMARY.md:94
msgid "A deeper dive into contracts"
msgstr "深入了解合约"

#: src/SUMMARY.md:96
msgid "Contract Storage"
msgstr "存储变量"

#: src/SUMMARY.md:97
msgid "Contract Functions"
msgstr "合约函数"

#: src/SUMMARY.md:98
msgid "Contract Events"
msgstr "合约的事件"

#: src/SUMMARY.md:99
msgid "Reducing boilerplate"
msgstr "减少冗余模板代码"

#: src/SUMMARY.md:100
msgid "Optimizing storage costs"
msgstr "优化存储成本"

#: src/SUMMARY.md:102
msgid "Components"
msgstr "组件"

#: src/SUMMARY.md:104
msgid "Under the hood"
msgstr "深入了解组件"

#: src/SUMMARY.md:105
msgid "Component dependencies"
msgstr "组件依赖"

#: src/SUMMARY.md:106
msgid "Testing components"
msgstr "测试组件"

#: src/SUMMARY.md:108
msgid "ABIs and Cross-contract Interactions"
msgstr "ABI和跨合约交互"

#: src/SUMMARY.md:110
msgid "ABIs and Interfaces"
msgstr "ABI和接口"

#: src/SUMMARY.md:111
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr "合约调度器、库调度器和系统调用"

#: src/SUMMARY.md:113
msgid "Other examples"
msgstr "其他例子"

#: src/SUMMARY.md:115
msgid "Deploying and Interacting with a Voting contract"
msgstr "部署投票合约并与之交互"

#: src/SUMMARY.md:117
msgid "L1 <> L2 Messaging"
msgstr "L1 <> L2 间信息传递"

#: src/SUMMARY.md:118
msgid "Security Considerations"
msgstr "安全考量"

#: src/SUMMARY.md:120
msgid "Appendix"
msgstr "附录"

#: src/SUMMARY.md:122
msgid "A - Keywords"
msgstr "A - 关键字"

#: src/SUMMARY.md:123
msgid "B - Operators and Symbols"
msgstr "B - 运算符和符号"

#: src/SUMMARY.md:124
msgid "C - Derivable Traits"
msgstr "C - 可派生的 Trait"

#: src/SUMMARY.md:125
msgid "D - Useful Development Tools"
msgstr "D - 实用开发工具"

#: src/SUMMARY.md:126
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr "E - 常见类型和trait以及Cairo Prelude"

#: src/SUMMARY.md:127
msgid "F - Installing Cairo binaries"
msgstr "F - 安装Cairo二进制文件"

#: src/title-page.md:1
msgid "# The Cairo Programming Language"
msgstr "# Cairo编程语言"

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-book.github.io). Special thanks to [Starkware](https://starkware.co/) through [OnlyDust](https://www."
"onlydust.xyz/), and [Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""
"由Cairo社区和它的[贡献者们](https://github.com/cairo-book/cairo-book.github.io)创作。特别感谢[Starkware](https://starkware.co/)通过[OnlyDust](https://www.onlydust.xyz/)和[Voyager]"
"(https://voyager.online/)支持这本书的创作。\n"
"中文版由[StarknetAstro](https://starknet-astro.super.site/)翻译。"

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo Compiler](https://github.com/starkware-libs/cairo) [version 2.2.0](https://github.com/starkware-libs/cairo/releases). See the "
"“Installation” section of Chapter 1 to install or update Cairo."
msgstr "本版本假设你使用的是 Cairo v2.2.0，请参阅第一章的 \"安装 \"部分来安装或更新 Cairo。"

#: src/title-page.md:7 src/appendix-06-cairo-binaries.md:205
msgid "<footer id=\"last-change\">Last change: 2023-09-15</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-15</footer>"

#: src/ch00-01-foreword.md:1
msgid "# Foreword"
msgstr "# 前言"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language supporting verifiable computation. Cairo started as an assembly language and gradually became more "
"expressive. The learning curve was initially steep, as Cairo 0.x was a low-level language that did not entirely abstract the underlying cryptographic primitives required to build a "
"proof for the execution of a program."
msgstr ""
"2020年，StarkWare发布了Cairo 0，这是一种支持可验证计算的图灵完备编程语言。Cairo最初是一种汇编语言，后来逐渐变得更具表现力。因为Cairo 0.x是一种低级语言，没有完全抽象出为程序的执行建立"
"证明所需的底层加密原语，所以最初的学习曲线很陡峭。"

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably improved, abstracting away the underlying immutable memory model of the Cairo architecture where possible. "
"Strongly inspired by Rust, Cairo 1 has been built to help you create provable programs without specific knowledge of its underlying architecture so that you can focus on the program "
"itself, increasing the overall security of Cairo programs. Powered by a Rust VM, the execution of Cairo programs is now _blazingly_ fast, allowing you to build an extensive test "
"suite without compromising on performance."
msgstr ""
"随着Cairo 1的发布，由于尽可能地对Cairo架构底层的不可变内存模型进行了抽象，开发者的体验有了很大的改善。受到Rust的强烈启发，Cairo 1是为了帮助你无需具体了解其底层架构就创建可证明的程序而"
"生，这样你就可以专注于程序本身，这提高Cairo程序的整体安全性。在Rust虚拟机的支持下，Cairo程序的执行速度现在快得惊人，允许你在不影响性能的情况下建立一个广泛的测试套件。"

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code their smart contracts. This allows the Starknet OS to generate "
"execution traces for transactions to be proved by a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet."
msgstr ""
"想在Starknet上部署合约的区块链开发者将使用Cairo编程语言来编写他们的智能合约。这允许Starknet操作系统生成交易的执行跟踪，以供证明者生成证明，然后在更新Starknet的状态根之前在Ethereum L1"
"上由验证者验证该证明。"

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one "
"computer and verified on other machines with lower hardware requirements."
msgstr "然而，Cairo不仅仅适用于区块链开发者。作为一种通用的编程语言，它可以用于任何需要在一台计算机上生成证明并在其他硬件要求较低的机器上验证的计算场景。"

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of programming concepts. It is a friendly and approachable text intended to help you level up your knowledge of Cairo, "
"but also help you develop your programming skills in general. So, dive in and get ready to learn all there is to know about Cairo!"
msgstr ""
"本书是为对编程概念有基本了解的开发人员设计的。它是一本友好而平易近人的书本，旨在帮助你提高你的Cairo知识水平，同时也帮助你提高你的通用编程技能。因此，请潜下心来，并准备好学习所有关于"
"Cairo的知识!"

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr "— Cairo社区"

#: src/ch00-01-foreword.md:15
msgid "<footer id=\"last-change\">Last change: 2023-04-16</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-04-16</footer>"

#: src/ch00-00-introduction.md:1
msgid "# Introduction"
msgstr "#  介绍"

#: src/ch00-00-introduction.md:3
msgid "## What is Cairo?"
msgstr "## 什么是Cairo？"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. The unique aspect of this processor is that it was not created for the physical constraints of our world "
"but for cryptographic ones, making it capable of efficiently proving the execution of any program running on it. This means that you can perform time consuming operations on a "
"machine you don't trust, and check the result very quickly on a cheaper machine.\n"
"While Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo 1 is a more high level language. It first compiles to Sierra, an intermediate representation of "
"Cairo which will compile later down to a safe subset of CASM. The point of Sierra is to ensure your CASM will always be provable, even when the computation fails."
msgstr ""
"Cairo是一种为同名的虚拟CPU设计的编程语言。这种虚拟处理器的独特之处在于，它不是为我们世界的物理法则而创造的，而是为密码学法则而创造的，这使得它能够有效地证明在其上运行的任何程序。这意"
"味着你可以在一台你不信任的机器上进行耗时的操作，而在一台更便宜的机器上非常迅速地检查结果。\n"
"虽然Cairo 0曾经直接编译成CASM，即Cairo CPU汇编，但Cairo 1是一种更高级的语言。它首先编译到Cairo的一个中间表示，Sierra，接着会编译成CASM的一个安全子集。Sierra的意义在于确保你的CASM总是"
"可以证明的，即使计算失败。"

#: src/ch00-00-introduction.md:8
msgid "## What can you do with it?"
msgstr "## 你能用它做什么？"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a decentralized blockchain platform "
"that enables the creation of decentralized applications where every single interaction between a user and a d-app is verified by all the participants. Starknet is a Layer 2 built on "
"top of Ethereum. Instead of having all the participants of the network to verify all user interactions, only one node, called the prover, executes the programs and generates proofs "
"that the computations were done correctly. These proofs are then verified by an Ethereum smart contract, requiring significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and reduced transaction costs while preserving Ethereum security."
msgstr ""
"Cairo允许你在不被信任的机器上计算值得信任的值。一个主要的用例是Starknet，这是一个针对Ethereum扩展的解决方案。以太坊是一个去中心化的区块链平台，它可以创建去中心化的应用程序，用户和d-"
"app之间的每一次交互都会被所有参与者验证。Starknet是一个建立在以太坊之上的Layer 2。不同于以太坊让网络的所有参与者来验证所有的用户的交互，Starknet只让一个被称为验证者(prover)的节点来执"
"行程序，并生成计算正确的证明。这些证明再由以太坊智能合约来验证，与执行交互本身相比，需要的计算能力要少得多。这种方法增加了吞吐量和降低交易成本，但保留了以太坊的安全性。"

#: src/ch00-00-introduction.md:12
msgid "## What are the differences with other programming languages?"
msgstr "## 与其他编程语言有什么区别？"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially when it comes to overhead costs and its primary advantages. Your program can be executed in two different "
"ways:"
msgstr "Cairo与传统的编程语言，尤其是在额外的性能开销和语言的主要优势方面，有很大不同。你的程序可以通过两种不同的方式执行："

#: src/ch00-00-introduction.md:16
msgid ""
"- When executed by the prover, it is similar to any other language. Because Cairo is virtualized, and because the operations were not specifically designed for maximum efficiency, "
"this can lead to some performance overhead but it is not the most relevant part to optimize.\n"
"\n"
"- When the generated proof is verified by a verifier, it is a bit different. This has to be as cheap as possible since it could potentially be verified on many very small machines. "
"Fortunately verifying is faster than computing and Cairo has some unique advantages to improve it even more. A notable one is non-determinism. This is a topic you will cover in more "
"detail later in this book, but the idea is that you can theoretically use a different algorithm for verifying than for computing. Currently, writing custom non-deterministic code is "
"not supported for the developers, but the standard library leverages non-determinism for improved performance. For example sorting an array in Cairo costs the same price as copying "
"it. Because the verifier doesn't sort the array, it just checks that it is sorted, which is cheaper."
msgstr ""
"- 当被证明器（prover）执行时，它与其他的编程语言类似。因为Cairo是虚拟化的，而且其操作并未设计为效率最大化，因此可能会导致一些额外性能开销，但这并不是最需要优化的部分。\n"
"\n"
"- 当生成的证明被验证器验证时，情况就有点不同了。这一步必须是尽可能的少消耗计算资源，因为它有可能需要在许多非常慢的机器上进行验证。幸运的是，验证比计算更快，而且Cairo有一些独特的优势，"
"可以进一步提高验证速度。一个值得注意的是非确定性，这是一个将在本书后面详细介绍的话题。其设计理念是，理论上你无需在计算时和验证时使用同一种算法（译注：即在验证时你可以使用比生成证明时"
"更快的算法来减少时间消耗）。目前开发者还不能编写自定义的非确定性代码，但标准库利用非确定性来提高性能。例如，在Cairo中对一个数组进行排序的成本与复制它的成本相同，这是因为验证器只是检查"
"它是否被排序而不是真的对数组进行排序，所以可以减少计算资源消耗。"

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, memory access is immutable, meaning that once a value is written to memory, it cannot be changed. Cairo 1 "
"provides abstractions that help developers work with these constraints, but it does not fully simulate mutability. Therefore, developers must think carefully about how they manage "
"memory and data structures in their programs to optimize performance."
msgstr ""
"使该语言与众不同的另一个方面是其内存模型。在Cairo中，内存访问是不可改变的，这意味着一旦一个值被写入内存，它就不能被改变。Cairo 1提供了帮助开发者处理这些约束的抽象，但它并没有完全模拟"
"可变性。因此，开发人员必须仔细考虑如何在他们的程序中管理内存和数据结构以优化性能。"

#: src/ch00-00-introduction.md:22
msgid "## References"
msgstr "## 参考文献"

#: src/ch00-00-introduction.md:24
msgid ""
"- Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>\n"
"- Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>\n"
"- State of non determinism: <https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""
"- Cairo CPU架构：<https://eprint.iacr.org/2021/1063>\n"
"- Cairo, Sierra and Casm：<https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>\n"
"- 非确定性的状态：<https://twitter.com/PapiniShahar/status/1638203716535713798>"

#: src/ch00-00-introduction.md:28
msgid "<footer id=\"last-change\">Last change: 2023-06-07</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-06-07</footer>"

#: src/ch01-00-getting-started.md:1
msgid "# Getting Started"
msgstr "# 入门"

#: src/ch01-00-getting-started.md:3
msgid "<footer id=\"last-change\">Last change: 2023-07-04</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-07-04</footer>"

#: src/ch01-01-installation.md:1
msgid "# Installation"
msgstr "# 安装"

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading [Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo compiler and the Cairo language server together in an easy-to-"
"install package so that you can start writing Cairo code right away."
msgstr ""
"只需下载 [Scarb](https://docs.swmansion.com/scarb/docs)，即可安装 Cairo。Scarb 将 Cairo 编译器和 Cairo 语言服务器捆绑在一个易于安装的软件包中，这样你就可以立即开始编写 Cairo 代码了。"

#: src/ch01-01-installation.md:5
msgid "Scarb is also Cairo's package manager and is heavily inspired by [Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package manager."
msgstr "Scarb同样是Cairo的软件包管理器，在很大程度上受到[Cargo](https://doc.rust-lang.org/cargo/)的启发，Rust的构建系统和软件包管理器。"

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries, "
"and provides LSP support for the VSCode Cairo 1 extension."
msgstr "Scarb会为你处理很多任务，比如构建你的代码（纯Cairo或Starknet合约），为你下载你的代码所依赖的库并构建他们，以及为VSCode Cairo 1扩展提供LSP支持。"

#: src/ch01-01-installation.md:9
msgid "As you write more complex Cairo programs, you might add dependencies, and if you start a project using Scarb, managing external code and dependencies will be a lot easier to do."
msgstr "如果你使用 Scarb 启动项目，管理外部代码和依赖关系就会容易得多。"

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "让我们从安装Scarb开始。"

#: src/ch01-01-installation.md:13
msgid "## Installing Scarb"
msgstr "## 安装Scarb"

#: src/ch01-01-installation.md:15
msgid "### Requirements"
msgstr "### 要求"

#: src/ch01-01-installation.md:17
msgid "Scarb requires a Git executable to be available in the `PATH` environment variable."
msgstr "Scarb需要`PATH`环境变量里有一个Git可执行文件。"

#: src/ch01-01-installation.md:19
msgid "### Installation"
msgstr "### 安装"

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We strongly recommend that you install\n"
"Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis.\n"
"This will ensure that the version of Scarb you use to work on a project always matches the one defined in the project settings, avoiding problems lead to version mismatch.\n"
"Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb."
msgstr ""
"要安装 Scarb，请参阅 [安装说明](https://docs.swmansion.com/scarb/download)。我们强烈建议您通过 [asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf) 来安装Scarb 。\n"
"这一个 CLI 工具，可以按项目管理多个语言运行时版本。\n"
"这将确保您用于处理项目的 Scarb 版本始终与项目设置中定义的版本匹配，从而避免导致版本不匹配的问题。\n"
"否则，您只需在终端中运行以下命令，然后按照屏幕上的说明进行操作即可。这将安装 Scarb 的最新稳定版本。"

#: src/ch01-01-installation.md:26
msgid ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"

#: src/ch01-01-installation.md:30
msgid ""
"- Verify installation by running the following command in new terminal session, it should print both Scarb and Cairo language versions, e.g:\n"
"\n"
"  ```bash\n"
"  $ scarb --version\n"
"  scarb 2.3.0-rc1 (58cc88efb 2023-08-23)\n"
"  cairo: 2.2.0 (https://crates.io/crates/cairo-lang-compiler/2.2.0)\n"
"  sierra: 1.3.0\n"
"  ```"
msgstr ""
"- 在新的终端Session里输入以下命令来验证是否安装成功, 终端应该同时打印出Scarb 和 Cairo 的版本号, 比如:\n"
"\n"
"  ```bash\n"
"  $ scarb --version\n"
"  scarb 2.4.0 (58cc88efb 2023-08-23)\n"
"  cairo: 2.2.0 (https://crates.io/crates/cairo-lang-compiler/2.2.0)\n"
"  sierra: 1.3.0\n"
"  ```"

#: src/ch01-01-installation.md:39
msgid "## Installing the VSCode extension"
msgstr "## 安装 VSCode 扩展"

#: src/ch01-01-installation.md:41
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You can install it from the [VSCode Marketplace](https://marketplace."
"visualstudio.com/items?itemName=starkware.cairo1).\n"
"Once installed, go into the extension settings, and make sure to tick the `Enable Language Server` and `Enable Scarb` options."
msgstr ""
"Cairo 有一个 VSCode 扩展，它提供了语法突出显示、代码完成和其他有用的功能。您可以从 [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)安装它。\n"
"安装后，进入扩展设置，并确保勾选`Enable Language Server` 和`Enable Scarb`选项。"

#: src/ch01-01-installation.md:44
msgid "<footer id=\"last-change\">Last change: 2023-11-05</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-05</footer>"

#: src/ch01-02-hello-world.md:1
msgid "## Hello, World"
msgstr "## Hello, World"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first Cairo program.\n"
"It’s traditional when learning a new language to write a little program that\n"
"prints the text `Hello, world!` to the screen, so we’ll do the same here!"
msgstr ""
"现在你已经通过Scarb安装了Cairo，是时候编写你的第一个Cairo程序了。\n"
"在学习一门新语言时，传统的做法是写一个小程序\n"
"将文字`Hello, world!`打印到屏幕上，所以我们在这里也要这样做!"

#: src/ch01-02-hello-world.md:7
msgid ""
"> Note: This book assumes basic familiarity with the command line. Cairo makes\n"
"> no specific demands about your editing or tooling or where your code lives, so\n"
"> if you prefer to use an integrated development environment (IDE) instead of\n"
"> the command line, feel free to use your favorite IDE. The Cairo team has developed\n"
"> a VSCode extension for the Cairo language that you can use to get the features from\n"
"> the language server and code highlighting. See [Appendix D][devtools]\n"
"> for more details."
msgstr ""
"> 注意：本书假定对你命令行有基本的了解。Cairo对\n"
"> 对你用什么编辑代码或使用什么开发工具或把你的代码放在哪没有特殊要求，所以\n"
"> 如果你喜欢使用集成开发环境（IDE）而不是\n"
"> 命令行，你完全可以使用你喜欢的IDE。Cairo团队已经开发了\n"
"> Cairo语言的VSCode扩展，你可以用它来获得来自\n"
"> 语言服务器和代码高亮。参见[附录D][devtools]来获取更多细节。"

#: src/ch01-02-hello-world.md:15
msgid "### Creating a Project Directory"
msgstr "### 创建一个项目目录"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t matter\n"
"to Cairo where your code lives, but for the exercises and projects in this book,\n"
"we suggest making a _cairo_projects_ directory in your home directory and keeping all\n"
"your projects there."
msgstr ""
"你首先要做一个目录来存储你的Cairo代码。对于Cairo来说，你的代码放在哪里并不重要。\n"
"但对于本书中的练习和项目来说，我们建议在你的主目录下建立一个 _cairo_projects_ 目录，并将你的所有项目存放在这里。"

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ directory\n"
"and a directory for the “Hello, world!” project within the _cairo_projects_ directory."
msgstr ""
"打开一个终端，输入以下命令，建立一个 _cairo_projects_ 目录\n"
"并在 _cairo_projects_ 目录下为 \"Hello, world!\"项目建立一个目录。"

#: src/ch01-02-hello-world.md:25
msgid ""
"> Note: From now on, for each example shown in the book, we assume that\n"
"> you will be working from a Scarb project directory. If you are not using Scarb, and try to run the examples from a different directory, you might need to adjust the commands "
"accordingly or create a Scarb project."
msgstr ""
"> 注意：从现在起，对于书中显示的每个示例，我们都假定\n"
"> 你都是在 Scarb 项目目录中进行编码。如果您没有使用 Scarb，并试图从其他目录运行示例，可能需要相应调整命令或创建一个 Scarb 项目。"

#: src/ch01-02-hello-world.md:28
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "对于Linux、macOS和Windows上的PowerShell，输入："

#: src/ch01-02-hello-world.md:30
msgid ""
"```shell\n"
"mkdir ~/cairo_projects\n"
"cd ~/cairo_projects\n"
"```"
msgstr ""
"```shell\n"
"mkdir ~/cairo_projects\n"
"cd ~/cairo_projects\n"
"```"

#: src/ch01-02-hello-world.md:35
msgid "For Windows CMD, enter this:"
msgstr "对于Windows CMD，请输入以下内容："

#: src/ch01-02-hello-world.md:37
msgid ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\cairo_projects\"\n"
"> cd /d \"%USERPROFILE%\\cairo_projects\"\n"
"```"
msgstr ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\cairo_projects\"\n"
"> cd /d \"%USERPROFILE%\\cairo_projects\"\n"
"```"

#: src/ch01-02-hello-world.md:42
msgid "### Creating a Project with Scarb"
msgstr "### 用Scarb创建一个项目"

#: src/ch01-02-hello-world.md:44
msgid "Let’s create a new project using Scarb."
msgstr "让我们使用 Scarb 创建一个新项目。"

#: src/ch01-02-hello-world.md:46
msgid "Navigate to your projects directory (or wherever you decided to store your code). Then run the following:"
msgstr "导航到你的项目目录（或你决定放代码的地方）。然后运行以下命令："

#: src/ch01-02-hello-world.md:48
msgid ""
"```bash\n"
"scarb new hello_world\n"
"```"
msgstr ""
"```bash\n"
"scarb new hello_world\n"
"```"

#: src/ch01-02-hello-world.md:52
msgid "It creates a new directory and project called `hello_world`. We’ve named our project `hello_world`, and Scarb creates its files in a directory of the same name."
msgstr "它创建了一个新的目录和项目，名为`hello_world`。我们把我们的项目命名为`hello_world`，因此Scarb会在同名的目录下创建它的文件。"

#: src/ch01-02-hello-world.md:54
msgid ""
"Go into the `hello_world` directory with the command `cd hello_world`. You’ll see that Scarb has generated two files and one directory for us: a `Scarb.toml` file and a src directory "
"with a `lib.cairo` file inside."
msgstr "用`cd hello_world`命令进入`hello_world`目录。你会看到Scarb已经为我们生成了两个文件和一个目录：一个`Scarb.toml`文件和一个src目录，里面有一个`lib.cairo`文件。"

#: src/ch01-02-hello-world.md:56
msgid "It has also initialized a new Git repository along with a `.gitignore` file"
msgstr "它还初始化了一个新的Git仓库和一个`.gitignore`文件"

#: src/ch01-02-hello-world.md:58
msgid ""
"> Note: Git is a common version control system. You can stop using version control system by using the `--vcs` flag.\n"
"> Run `scarb new -help` to see the available options."
msgstr ""
"> 注意：Git是一个常见的版本控制系统。你可以通过使用`--vcs`标志停止使用版本控制系统。\n"
"> 运行`scarb new -help`以查看可用选项。"

#: src/ch01-02-hello-world.md:61
msgid "Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-2."
msgstr "在你选择的文本编辑器中打开 _Scarb.toml_ 。它看起来应该与示例1-2中的代码相似。"

#: src/ch01-02-hello-world.md:63
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr "<span class=\"filename\">文件名：Scarb.toml</span>"

#: src/ch01-02-hello-world.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-02-hello-world.md:76
msgid "<span class=\"caption\">Listing 1-2: Contents of Scarb.toml generated by `scarb new`</span>"
msgstr "<span class=\"caption\">示例1-2：由`scarb new`生成的Scarb.toml的内容</span>"

#: src/ch01-02-hello-world.md:78
msgid "This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal Language) format, which is Scarb’s configuration format."
msgstr "这个文件是[TOML](https://toml.io/)（Tom's Obvious, Minimal Language）的格式，是Scarb的配置文件格式。"

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other "
"sections."
msgstr "第一行，`[package]`，是一个章节标题，表示下面的语句是在配置一个包。随着我们向这个文件添加更多的信息，我们将添加其他章节。"

#: src/ch01-02-hello-world.md:82
msgid "The next two lines set the configuration information Scarb needs to compile your program: the name and the version of Scarb to use."
msgstr "接下来的两行设置了Scarb在编译你的程序时需要的配置信息：名称和要使用的Scarb版本。"

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list any of your project’s dependencies. In Cairo, packages of code are referred to as crates. We won’t need any "
"other crates for this project."
msgstr "最后一行，`[dependencies]`，是一个章节的开始，该章节供你列出你的项目的所有依赖。在Cairo中，代码包被称为crate。在这个项目中，我们不需要任何其他的crate。"

#: src/ch01-02-hello-world.md:86
msgid ""
"> Note: If you're building contracts for Starknet, you will need to add the `starknet` dependency as mentioned in the [Scarb documentation](https://docs.swmansion.com/scarb/docs/"
"extensions/starknet/starknet-package.html)."
msgstr "> 注意：如果你要为Starknet构建合约，你需要添加[Scarb文档](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)中提到的`starknet`依赖关系。"

#: src/ch01-02-hello-world.md:88
msgid "The other file created by Scarb is `src/lib.cairo`, let's delete all the content and put in the following content, we will explain the reason later."
msgstr "Scarb创建的另一个文件是`src/lib.cairo`，让我们删除其中所有的内容，放入以下内容，我们将在后面解释原因。"

#: src/ch01-02-hello-world.md:90
msgid ""
"```rust,noplayground\n"
"mod hello_world;\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod hello_world;\n"
"```"

#: src/ch01-02-hello-world.md:94
msgid "Then create a new file called `src/hello_world.cairo` and put the following code in it:"
msgstr "然后创建一个名为`src/hello_world.cairo`的新文件，并将以下代码放入其中："

#: src/ch01-02-hello-world.md:96
msgid "<span class=\"filename\">Filename: src/hello_world.cairo</span>"
msgstr "<span class=\"filename\">文件名： src/hello_world.cairo</span>"

#: src/ch01-02-hello-world.md:98
msgid ""
"```rust,file=hello_world.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, World!'.print();\n"
"}\n"
"```"
msgstr ""
"```rust,file=hello_world.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, World!'.print();\n"
"}\n"
"```"

#: src/ch01-02-hello-world.md:105
msgid ""
"We have just created a file called `lib.cairo`, which contains a module declaration referencing another module named `hello_world`, as well as the file `hello_world.cairo`, "
"containing the implementation details of the `hello_world` module."
msgstr "我们刚刚创建了一个名为`lib.cairo`的文件，其中包含一个模块声明，引用了另一个名为 `hello_world`的模块，以及包含 `hello_world`模块的实现细节的文件`hello_world.cairo`。"

#: src/ch01-02-hello-world.md:107
msgid "Scarb requires your source files to be located within the `src` directory."
msgstr "Scarb要求你的源文件位于src目录中。"

#: src/ch01-02-hello-world.md:109
msgid ""
"The top-level project directory is reserved for README files, license information, configuration files, and any other non-code-related content.\n"
"Scarb ensures a designated location for all project components, maintaining a structured organization."
msgstr ""
"顶层项目目录是为README文件、许可证信息、配置文件和任何其他与代码无关的内容保留的。\n"
"Scarb确保所有项目组件都有一个指定的位置，维持一个结构化的组织架构。"

#: src/ch01-02-hello-world.md:112
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a project that does use Scarb. Move the project code into the src directory and create an appropriate `Scarb."
"toml` file."
msgstr "如果你启动了一个不使用Scarb的项目，你可以把它转换成一个使用Scarb的项目。将项目代码移到src目录下，并创建一个适当的`Scarb.toml`文件。"

#: src/ch01-02-hello-world.md:114
msgid "### Building a Scarb Project"
msgstr "### 编译Scarb项目"

#: src/ch01-02-hello-world.md:116
msgid "From your `hello_world` directory, build your project by entering the following command:"
msgstr "在你的`hello_world`目录中，通过输入以下命令来编译你的项目："

#: src/ch01-02-hello-world.md:118
msgid ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"
msgstr ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"

#: src/ch01-02-hello-world.md:124
msgid "This command creates a `sierra` file in `target/dev`, let's ignore the `sierra` file for now."
msgstr "这个命令在`target/dev`中创建了一个`sierra`文件，现在我们先忽略`sierra`文件。"

#: src/ch01-02-hello-world.md:126
msgid "If you have installed Cairo correctly, you should be able to run and see the following output:"
msgstr "如果你正确安装了Cairo，你应该能够运行并看到以下输出："

#: src/ch01-02-hello-world.md:128
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"running hello_world ...\n"
"[DEBUG] Hello, World!                   (raw: 0x48656c6c6f2c20776f726c6421\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"running hello_world ...\n"
"[DEBUG] Hello, World!                   (raw: 0x48656c6c6f2c20776f726c6421\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch01-02-hello-world.md:136
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print to\n"
"the terminal."
msgstr "无论你的操作系统如何，终端里都应该打印出字符串`Hello, world!`。"

#: src/ch01-02-hello-world.md:139
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a Cairo\n"
"program. That makes you a Cairo programmer—welcome!"
msgstr ""
"如果 \"Hello，world！\"打印出来了，那么恭喜你！你已经正式写了一个Cairo程序！\n"
"你已经成为了一名Cairo程序员--欢迎!"

#: src/ch01-02-hello-world.md:142
msgid "### Anatomy of a Cairo Program"
msgstr "### 解析Cairo程序"

#: src/ch01-02-hello-world.md:144
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece of\n"
"the puzzle:"
msgstr "让我们详细回顾一下这个 \"Hello，world！\"程序。这里有拼图的第一部分："

#: src/ch01-02-hello-world.md:147
msgid ""
"```rust,noplayground\n"
"fn main() {\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn main() {\n"
"\n"
"}\n"
"```"

#: src/ch01-02-hello-world.md:153
msgid ""
"These lines define a function named `main`. The `main` function is special: it\n"
"is always the first code that runs in every executable Cairo program. Here, the\n"
"first line declares a function named `main` that has no parameters and returns\n"
"nothing. If there were parameters, they would go inside the parentheses `()`."
msgstr ""
"这些代码定义了一个名为 `main`的函数。`main`函数很特别：它总是每个可执行的Cairo程序中运行的第一个代码。\n"
"这里，第一行声明了一个名为 `main`的函数，没有参数，也不返回。如果有参数，它们会被放在括号`()`里。"

#: src/ch01-02-hello-world.md:158
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around all\n"
"function bodies. It’s good style to place the opening curly bracket on the same\n"
"line as the function declaration, adding one space in between."
msgstr ""
"函数主体被包裹在\"{}\"中。Cairo要求在所有的函数体周围加上大括号\n"
"将开头的左大括号与函数声明放在同一行是很好的编码风格。\n"
"别忘了在它们中间加一个空格。"

#: src/ch01-02-hello-world.md:162
msgid ""
"> Note: If you want to stick to a standard style across Cairo projects, you can\n"
"> use the automatic formatter tool available with `scarb fmt` to format your code in a\n"
"> particular style (more on `scarb fmt` in\n"
"> [Appendix D][devtools]). The Cairo team has included this tool\n"
"> with the standard Cairo distribution, as `cairo-run` is, so it should already be\n"
"> installed on your computer!"
msgstr ""
"> 注意：如果你想在Cairo项目中使用一个统一代码风格标准，你可以\n"
"> 使用自动格式化工具`scarb fmt`来将你的代码格式化为\n"
"> 特定的代码风格（更多关于`scarb fmt`的信息见\n"
"> [附录D][devtools]）。Cairo团队已经将这个工具\n"
"> 包含在标准的Cairo发行版中，就像`cairo-run`一样，所以它应该已经被\n"
"> 已经安装在你的计算机上了!"

#: src/ch01-02-hello-world.md:169
msgid ""
"Prior to the main function declaration, The line `use debug::PrintTrait;` is responsible for importing an item defined in another module. In this case, we are importing the "
"`PrintTrait` item from the Cairo core library. By doing so, we gain the ability to use the `print()` method on data types that are compatible with printing."
msgstr ""
"在主函数声明之前，`use debug::PrintTrait;`一行负责导入另一个模块中定义的项目。在这个例子中，我们从Cairo核心库中导入了`PrintTrait`项目。通过这样做，我们获得了在可以打印的数据类型上使用"
"`print()`方法的能力。"

#: src/ch01-02-hello-world.md:171
msgid "The body of the `main` function holds the following code:"
msgstr "`main`函数的主体包含以下代码："

#: src/ch01-02-hello-world.md:173
msgid ""
"```rust,noplayground\n"
"    'Hello, World!'.print();\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    'Hello, World!'.print();\n"
"```"

#: src/ch01-02-hello-world.md:177
msgid ""
"This line does all the work in this little program: it prints text to the\n"
"screen. There are four important details to notice here."
msgstr "这一行完成了这个小程序的所有工作：将文本打印到屏幕上。这里有四个重要的细节需要注意。"

#: src/ch01-02-hello-world.md:180
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "首先，Cairo的风格是用四个空格缩进，而不是用制表符。"

#: src/ch01-02-hello-world.md:182
msgid ""
"Second, the `print()` function called is a method from the trait `PrintTrait`. This trait is imported from the Cairo core library, and it defines how to print values to the screen "
"for different data types. In our case, our text is defined as a \"short string\", which is an ASCII string that can fit in Cairo's basic data type, which is the `felt252` type. By "
"calling `Hello, world!'.print()`, we're calling the `print()` method of the `felt252` implementation of the `PrintTrait` trait."
msgstr ""
"第二，调用的`print()`函数是来自trait`PrintTrait`的一个方法。这个trait是从Cairo核心库中导入的，它定义了如何将不同数据类型的值打印到屏幕上。在我们的例子中，我们的文本被定义为 \"short "
"string\"，这是一个ASCII字符串，可以适合Cairo的基本数据类型，即`felt252`类型。通过调用`'Hello, world!'.print()`，我们正在调用`PrintTrait`trait的`felt252`实现的`print()`方法。"

#: src/ch01-02-hello-world.md:184
msgid ""
"Third, you see the `'Hello, World!'` short string. We pass this short string as an argument\n"
"to `print()`, and the short string is printed to the screen."
msgstr "第三，看见了`'Hello, world!'`短字符串么。我们把这个短字符串作为一个参数传递给`print()`，因此短字符串被打印到屏幕上。"

#: src/ch01-02-hello-world.md:187
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this\n"
"expression is over and the next one is ready to begin. Most lines of Cairo code\n"
"end with a semicolon."
msgstr "第四，我们用分号（`;`）来结束这一行，这表示这个表达式已经结束，下一个表达式准备开始。大多数Cairo的代码行以分号结束。"

#: src/ch01-02-hello-world.md:193
msgid "### Running tests"
msgstr "## 运行测试"

#: src/ch01-02-hello-world.md:195
msgid ""
"To run all the tests associated with a particular package, you can use the `scarb test` command.\n"
"It is not a test runner by itself, but rather delegates work to a testing solution of choice. Scarb comes with preinstalled `scarb cairo-test` extension, which bundles Cairo's native "
"test runner. It is the default test runner used by scarb test.\n"
"To use third-party test runners, please refer to [Scarb's documentation](https://docs.swmansion.com/scarb/docs/extensions/testing.html#using-third-party-test-runners)."
msgstr ""
"要运行与特定软件包相关的所有测试，可以使用`scarb test`命令。\n"
"它本身并不是一个测试运行工具，而是将测试工作委托给所选的测试工具。Scarb预装了`scarb cairo-test`扩展，它捆绑了Cairo的本地测试运行器。它也是scarb test默认使用的测试运行器。\n"
"要使用第三方测试运行器，请参考[Scarb文档](https://docs.swmansion.com/scarb/docs/extensions/testing.html#using-third-party-test-runners)。"

#: src/ch01-02-hello-world.md:199
msgid "Test functions are marked with the `#[test]` attributes, and running `scarb test` will run all test functions in your codebase under the `src/` directory."
msgstr "测试函数用`#[test]`属性标记，运行`scarb test`将运行代码库中`src/`目录下的所有测试函数。"

#: src/ch01-02-hello-world.md:201
msgid ""
"```txt\n"
"├── Scarb.toml\n"
"├── src\n"
"│   ├── lib.cairo\n"
"│   └── file.cairo\n"
"```"
msgstr ""
"```txt\n"
"├── Scarb.toml\n"
"├── src\n"
"│   ├── lib.cairo\n"
"│   └── file.cairo\n"
"```"

#: src/ch01-02-hello-world.md:208
msgid "<span class=\"caption\"> A sample Scarb project structure</span>"
msgstr "<span class=\"caption\">Scarb 项目结构示例</span>"

#: src/ch01-02-hello-world.md:210
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "让我们回顾一下到目前为止我们所了解到的关于Scarb的情况："

#: src/ch01-02-hello-world.md:212
msgid ""
"- We can create a project using `scarb new`.\n"
"- We can build a project using `scarb build` to generate the compiled Sierra code.\n"
"- We can define custom scripts in `Scarb.toml` and call them with the `scarb run` command.\n"
"- We can run tests using the `scarb test` command."
msgstr ""
"- 我们可以使用 `scarb new` 创建项目。\n"
"- 我们可以使用 `scarb build` 生成编译后的 Sierra 代码。\n"
"- 我们可以在 `Scarb.toml` 中定义自定义脚本，并使用 `scarb run` 命令调用它们。\n"
"- 我们可以使用 `scarb test` 命令运行测试。"

#: src/ch01-02-hello-world.md:217
msgid ""
"An additional advantage of using Scarb is that the commands are the same no matter which operating system you’re working on. So, at this point, we’ll no longer provide specific "
"instructions for Linux and macOS versus Windows."
msgstr "使用Scarb的另一个好处是，无论你在哪个操作系统上工作，命令都是一样的。所以我们将不再提供Linux和macOS与Windows的具体说明。"

#: src/ch01-02-hello-world.md:220
msgid "# Summary"
msgstr "# 总结"

#: src/ch01-02-hello-world.md:222
msgid "You’re already off to a great start on your Cairo journey! In this chapter, you’ve learned how to:"
msgstr "你的Cairo之旅已经有了一个很好的开始！在本章中，你已经学会了如何："

#: src/ch01-02-hello-world.md:224
msgid ""
"- Install the latest stable version of Cairo\n"
"- Write and run a “Hello, Scarb!” program using `scarb` directly\n"
"- Create and run a new project using the conventions of Scarb\n"
"- Execute tests using the `scarb test` command"
msgstr ""
"- 安装最新稳定版本的 Cairo\n"
"- 直接使用 `scarb` 编写并运行 “Hello, world!”程序\n"
"- 使用 Scarb 的默认设置创建并运行一个新项目\n"
"- 使用 `scarb test` 命令执行测试"

#: src/ch01-02-hello-world.md:229
msgid "This is a great time to build a more substantial program to get used to reading and writing Cairo code."
msgstr "是时候通过建立更多实用程序来熟悉阅读和编写Cairo代码了。"

#: src/ch01-02-hello-world.md:231
msgid "<footer id=\"last-change\">Last change: 2023-10-03</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-03</footer>"

#: src/ch02-00-common-programming-concepts.md:1
msgid "# Common Programming Concepts"
msgstr "# 常见的编程概念"

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the "
"concepts presented in this chapter are unique to Cairo, but we’ll discuss them in the context of Cairo and explain the conventions around using these concepts."
msgstr ""
"本章涵盖了几乎所有编程语言中出现的概念，以及它们在Cairo的工作原理。许多编程语言的核心都有很多共同点。本章介绍的概念没有一个是Cairo独有的，但我们会在Cairo的背景下讨论它们，并解释使用这"
"些概念的惯例。"

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give "
"you a strong core to start from."
msgstr "具体来说，你将学习到变量、基本类型、函数、注释和控制流。这些基础将出现在每个Cairo程序中，尽早学习它们将给你一个强大的核心来开启旅程。"

#: src/ch02-00-common-programming-concepts.md:6
msgid "<footer id=\"last-change\">Last change: 2023-04-04</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-04-04</footer>"

#: src/ch02-01-variables-and-mutability.md:1
msgid "## Variables and Mutability"
msgstr "## 变量和可变性"

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is written to,\n"
"it can't be overwritten but only read from. To reflect this immutable memory model,\n"
"variables in Cairo are immutable by default.\n"
"However, the language abstracts this model and gives you the option to make your\n"
"variables mutable. Let’s explore how and why Cairo enforces immutability, and how\n"
"you can make your variables mutable."
msgstr ""
"Cairo使用一个不可改变的内存模型，这意味着一旦一个内存单元被写入就不能被覆盖，\n"
"只能被读出。为了反映这种不可变的内存模型，变量在Cairo中默认是不可变的。\n"
"然而，该语言对这种模式进行了抽象，让你可以选择变量是否可变。让我们来\n"
"探讨一下Cairo是如何以及为什么要强行规定变量不可变，以及如何使变量成为可变的。"

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t change\n"
"that value. To illustrate this, generate a new project called _variables_ in\n"
"your _cairo_projects_ directory by using `scarb new variables`."
msgstr ""
"当一个变量是不可变的，一旦一个值被绑定到一个名字上，你就不能改变该值。\n"
"为了展示这一点，在你的 _cairo_projects_ 目录下，使用`scarb new variables`生成一个名为 _variables_ 的新项目。"

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its\n"
"code with the following code, which won’t compile just yet:"
msgstr "然后，在你新的 _variables_ 目录下，打开 _src/lib.cairo_ 并将其替换为下面的代码，这段代码还不会被编译："

#: src/ch02-01-variables-and-mutability.md:17 src/ch02-01-variables-and-mutability.md:77 src/ch02-01-variables-and-mutability.md:155 src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58 src/ch02-05-control-flow.md:90 src/ch02-05-control-flow.md:130 src/ch04-01-what-is-ownership.md:252 src/ch04-01-what-is-ownership.md:294
#: src/ch04-01-what-is-ownership.md:347 src/ch04-02-references-and-snapshots.md:23 src/ch04-02-references-and-snapshots.md:134 src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26 src/ch05-01-defining-and-instantiating-structs.md:48 src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:120 src/ch05-02-an-example-program-using-structs.md:7 src/ch05-02-an-example-program-using-structs.md:48
#: src/ch05-02-an-example-program-using-structs.md:74 src/ch05-02-an-example-program-using-structs.md:103 src/ch05-02-an-example-program-using-structs.md:136
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:93 src/ch05-03-method-syntax.md:135 src/ch05-03-method-syntax.md:192 src/ch05-03-method-syntax.md:231
#: src/ch07-02-defining-modules-to-control-scope.md:78 src/ch07-02-defining-modules-to-control-scope.md:130 src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62 src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38 src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131 src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18 src/ch09-01-how-to-write-tests.md:28 src/ch09-01-how-to-write-tests.md:62 src/ch09-01-how-to-write-tests.md:118
#: src/ch09-01-how-to-write-tests.md:141 src/ch09-01-how-to-write-tests.md:207 src/ch09-01-how-to-write-tests.md:305 src/ch09-01-how-to-write-tests.md:394
#: src/ch09-01-how-to-write-tests.md:489 src/ch09-01-how-to-write-tests.md:527 src/ch09-01-how-to-write-tests.md:563 src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr "<span class=\"filename\">文件名： src/lib.cairo</span>"

#: src/ch02-01-variables-and-mutability.md:19
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"\n"
"```"

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an error message\n"
"regarding an immutability error, as shown in this output:"
msgstr "保存并使用`scarb cairo-run`运行该程序。你应该收到一条关于不可变性的错误，如下所示："

#: src/ch02-01-variables-and-mutability.md:33
msgid ""
"```shell\n"
"error: Cannot assign to an immutable variable.\n"
" --> lib.cairo:5:5\n"
"    x = 6;\n"
"    ^***^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""
"```shell\n"
"error: Cannot assign to an immutable variable.\n"
" --> lib.cairo:5:5\n"
"    x = 6;\n"
"    ^***^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs.\n"
"Compiler errors can be frustrating, but really they only mean your program\n"
"isn’t safely doing what you want it to do yet; they do _not_ mean that you’re\n"
"not a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"这个例子显示了编译器如何帮助你发现程序中的错误。\n"
"编译错误可能令人沮丧，但实际上它们只意味着你的程序\n"
"还没有安全地完成你想做的事情；它们并不意味着你不是一个好的程序员。\n"
"即使有经验的Caironautes仍然会遇到编译错误。"

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.`\n"
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"你收到的错误信息是 `Cannot assign to an immutable variable.`。\n"
"因为你试图给不可变的`x`变量分配第二个值。"

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a\n"
"value that’s designated as immutable because this specific situation can lead to\n"
"bugs. If one part of our code operates on the assumption that a value will\n"
"never change and another part of our code changes that value, it’s possible\n"
"that the first part of the code won’t do what it was designed to do. The cause\n"
"of this kind of bug can be difficult to track down after the fact, especially\n"
"when the second piece of code changes the value only _sometimes_. The Cairo\n"
"compiler guarantees that when you state that a value won’t change, it really\n"
"won’t change, so you don’t have to keep track of it yourself. Your code is thus\n"
"easier to reason through."
msgstr ""
"在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。\n"
"如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，\n"
"第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 _有时_ 会改变值。\n"
"Cairo 编译器保证，如果声明一个值不会变，它就真的不会变，所以你不必自己跟踪它。这意味着你的代码更易于推导。"

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"But mutability can be very useful, and can make code more convenient to write.\n"
"Although variables are immutable by default, you can make them mutable by\n"
"adding `mut` in front of the variable name. Adding `mut` also conveys\n"
"intent to future readers of the code by indicating that other parts of the code\n"
"will be changing this variable’s value."
msgstr ""
"不过可变性也是非常有用的，可以用来更方便地编写代码。尽管变量默认是不可变的，你仍然可以在变量名前添加 `mut` 来使其可变。`mut` 也向阅读代码的人表明了其他代码将会改变这个变量值的意图。"

#: src/ch02-01-variables-and-mutability.md:67
msgid ""
"However, you might be wondering at this point what exactly happens when a variable\n"
"is declared as `mut`, as we previously mentioned that Cairo's memory is immutable.\n"
"The answer is that Cairo's memory is immutable, but the memory address the variable points\n"
"to can be changed. Upon examining the low-level Cairo Assembly code, it becomes clear that\n"
"variable mutation is implemented as syntactic sugar, which translates mutation operations\n"
"into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo\n"
"level, the variable is not redeclared so its type cannot change."
msgstr ""
"然而，你可能想知道，当一个变量被声明为 `mut` 时，究竟会发生什么？因为我们之前提到Cairo的内存是不可改变的。\n"
"答案是，Cairo的内存是不可改变的，但变量指向的内存地址可以被改变。在检查了低级别的Cairo汇编代码后，\n"
"我们可以清楚地发现变量可变性是以语法糖的形式实现的，它将变量可变性操作转化为一系列的步骤，等同于变量的隐藏（variable shadowing）。\n"
"唯一的区别是，在Cairo，变量没有被重新声明，所以它的类型不能改变。"

#: src/ch02-01-variables-and-mutability.md:75
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "例如，让我们把 _src/lib.cairo_ 改为以下内容："

#: src/ch02-01-variables-and-mutability.md:79
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:89
msgid "When we run the program now, we get this:"
msgstr "当我们现在运行该程序时，我们得到了这个结果："

#: src/ch02-01-variables-and-mutability.md:91
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                (raw: 5)\n"
"\n"
"[DEBUG]                                (raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                (raw: 5)\n"
"\n"
"[DEBUG]                                (raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch02-01-variables-and-mutability.md:100
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is\n"
"used. Ultimately, deciding whether to use mutability or not is up to you and\n"
"depends on what you think is clearest in that particular situation."
msgstr ""
"当使用 `mut` 时，我们将在`x`绑定的值从`5`改为 `6` 。\n"
"最终，决定是否使用可变性取决于你自己以及你认为在特定情况下什么是最清楚的。"

#: src/ch02-01-variables-and-mutability.md:104
msgid "### Constants"
msgstr "### 常量"

#: src/ch02-01-variables-and-mutability.md:106
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name and\n"
"are not allowed to change, but there are a few differences between constants\n"
"and variables."
msgstr "类似于不可变变量，常量 (constants) 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。"

#: src/ch02-01-variables-and-mutability.md:110
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just\n"
"immutable by default—they’re always immutable. You declare constants using the\n"
"`const` keyword instead of the `let` keyword, and the type of the value _must_\n"
"be annotated. We’ll cover types and type annotations in the next section,\n"
"[“Data Types”][data-types], so don’t worry about the details\n"
"right now. Just know that you must always annotate the type."
msgstr ""
"首先，不允许对常量使用 `mut`。常量不仅仅是默认不可变—它总是不可变。声明常量使用 `const` 关键字而不是 `let`，并且 _必须_ 注明值的类型。在下一部分，[“数据类型”][data-types]中会介绍类型"
"和类型注解，现在无需关心这些细节，记住总是标注类型即可。"

#: src/ch02-01-variables-and-mutability.md:117
msgid ""
"Constants can only be declared in the global scope, which makes\n"
"them useful for values that many parts of code need to know about."
msgstr "常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。"

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"The last difference is that constants may be set only to a constant expression,\n"
"not the result of a value that could only be computed at runtime. Only literal constants\n"
"are currently supported."
msgstr "最后一个区别是，常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。目前只支持字面常量。"

#: src/ch02-01-variables-and-mutability.md:124
msgid "Here’s an example of a constant declaration:"
msgstr "下面是一个声明常量的例子："

#: src/ch02-01-variables-and-mutability.md:126
msgid ""
"```rust, noplayground\n"
"const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
"```"
msgstr ""
"```rust, noplayground\n"
"const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
"```"

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"Cairo's naming convention for constants is to use all uppercase with\n"
"underscores between words."
msgstr "Cairo的常量命名规则是使用所有大写字母，单词之间使用下划线。"

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Constants are valid for the entire time a program runs, within the scope in\n"
"which they were declared. This property makes constants useful for values in\n"
"your application domain that multiple parts of the program might need to know\n"
"about, such as the maximum number of points any player of a game is allowed to\n"
"earn, or the speed of light."
msgstr ""
"在声明它的作用域之中，常量在整个程序生命周期中都有效，\n"
"此属性使得常量可以作为多处代码使用的全局范围的固定数值，例如一个游戏中玩家可以获取的最高分，或者光速。"

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"Naming hardcoded values used throughout your program as constants is useful in\n"
"conveying the meaning of that value to future maintainers of the code. It also\n"
"helps to have only one place in your code you would need to change if the\n"
"hardcoded value needed to be updated in the future."
msgstr ""
"将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。\n"
"如果将来需要修改硬编码值，也只需修改汇此处的硬编码值。"

#: src/ch02-01-variables-and-mutability.md:144
msgid "### Shadowing"
msgstr "### 隐藏"

#: src/ch02-01-variables-and-mutability.md:146
msgid ""
"Variable shadowing refers to the declaration of a\n"
"new variable with the same name as a previous variable. Caironautes say that the\n"
"first variable is _shadowed_ by the second, which means that the second\n"
"variable is what the compiler will see when you use the name of the variable.\n"
"In effect, the second variable overshadows the first, taking any uses of the\n"
"variable name to itself until either it itself is shadowed or the scope ends.\n"
"We can shadow a variable by using the same variable’s name and repeating the\n"
"use of the `let` keyword as follows:"
msgstr ""
"变量隐藏指的是声明一个与之前变量同名的新的变量。\n"
"当Caironautes 说第一个变量被第二个变量所 _隐藏_ 时，这意味着当您使用变量的名称时，编译器看到的是第二个变量。\n"
"实际上，第二个变量“遮蔽”了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，\n"
"直到第二个变量自己也被隐藏或第二个变量的作用域结束。\n"
"可以用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏，如下所示："

#: src/ch02-01-variables-and-mutability.md:157
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    let x = x + 1;\n"
"    {\n"
"        let x = x * 2;\n"
"        'Inner scope x value is:'.print();\n"
"        x.print()\n"
"    }\n"
"    'Outer scope x value is:'.print();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    let x = x + 1;\n"
"    {\n"
"        let x = x * 2;\n"
"        'Inner scope x value is:'.print();\n"
"        x.print()\n"
"    }\n"
"    'Outer scope x value is:'.print();\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:172
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new variable\n"
"`x` by repeating `let x =`, taking the original value and adding `1` so the\n"
"value of `x` is then `6`. Then, within an inner scope created with the curly\n"
"brackets, the third `let` statement also shadows `x` and creates a new\n"
"variable, multiplying the previous value by `2` to give `x` a value of `12`.\n"
"When that scope is over, the inner shadowing ends and `x` returns to being `6`.\n"
"When we run this program, it will output the following:"
msgstr ""
"这个程序首先将 `x` 绑定到值 `5` 上。接着通过 `let x =` 创建了一个新变量 `x` ，获取初始值并加 `1` ，这样 `x` 的值就变成 `6` 了。然后，在使用花括号创建的内部作用域内，第三个 `let` 语句"
"也隐藏了 `x` 并创建了一个新的变量，将之前的值乘以 `2` ， `x` 得到的值是 `12`。当该作用域结束时，内部 shadowing 的作用域也结束了， `x` 又返回到 `6`。运行这个程序，它会有如下输出："

#: src/ch02-01-variables-and-mutability.md:180
msgid ""
"```shell\n"
"scarb cairo-run\n"
"[DEBUG] Inner scope x value is:         (raw: 7033328135641142205392067879065573688897582790068499258)\n"
"\n"
"[DEBUG]\n"
"                                       (raw: 12)\n"
"\n"
"[DEBUG] Outer scope x value is:         (raw: 7610641743409771490723378239576163509623951327599620922)\n"
"\n"
"[DEBUG]                                (raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```shell\n"
"scarb cairo-run\n"
"[DEBUG] Inner scope x value is:         (raw: 7033328135641142205392067879065573688897582790068499258)\n"
"\n"
"[DEBUG]\n"
"                                       (raw: 12)\n"
"\n"
"[DEBUG] Outer scope x value is:         (raw: 7610641743409771490723378239576163509623951327599620922)\n"
"\n"
"[DEBUG]                                (raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch02-01-variables-and-mutability.md:194
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a\n"
"compile-time error if we accidentally try to reassign to this variable without\n"
"using the `let` keyword. By using `let`, we can perform a few transformations\n"
"on a value but have the variable be immutable after those transformations have\n"
"been completed."
msgstr ""
"隐藏与将变量标记为 `mut` 是有区别的。\n"
"当不小心尝试对变量重新赋值时，如果没有使用 `let` 关键字，就会导致编译时错误。\n"
"通过使用 `let`，我们可以用这个新值进行一些计算，不过计算完之后变量仍然是不可变的。"

#: src/ch02-01-variables-and-mutability.md:200
msgid ""
"Another distinction between `mut` and shadowing is that when we use the `let` keyword again,\n"
"we are effectively creating a new variable, which allows us to change the type of the\n"
"value while reusing the same name. As mentioned before, variable shadowing and mutable variables\n"
"are equivalent at the lower level.\n"
"The only difference is that by shadowing a variable, the compiler will not complain\n"
"if you change its type. For example, say our program performs a type conversion between the\n"
"`u64` and `felt252` types."
msgstr ""
"`mut` 与隐藏的另一个区别是，当再次使用 `let` 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。\n"
"如前所述，变量隐藏和可变量在较低层次上是等同的。\n"
"唯一的区别是，通过隐藏变量，即使你改变它的类型。编译器也不会检测到错误\n"
"例如，假设我们的程序在`u64` 和 `felt252` 类型之间进行转换。"

#: src/ch02-01-variables-and-mutability.md:208
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x: u64 = 2;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x: u64 = 2;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.\n"
"    x.print()\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:219
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a `felt252` type.\n"
"Shadowing thus spares us from having to come up with different names, such as `x_u64`\n"
"and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we try to use\n"
"`mut` for this, as shown here, we’ll get a compile-time error:"
msgstr ""
"第一个 `x` 变量的类型是 `u64`，而第二个 `x` 变量的类型是 `felt252`。\n"
"因此，隐藏使我们不必想出不同的名字，例如 `x_u64` 和 `x_felt252`；\n"
"相反，我们可以重新使用更简单的 `x` 名称。然而，如果我们试图使用\n"
"`mut` 来实现，我们会得到一个编译时错误，如下所示："

#: src/ch02-01-variables-and-mutability.md:224
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut x: u64 = 2;\n"
"    x.print();\n"
"    x = 100_felt252;\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut x: u64 = 2;\n"
"    x.print();\n"
"    x = 100_felt252;\n"
"    x.print()\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:235
msgid "The error says we were expecting a `u64` (the original type) but we got a different type:"
msgstr "这个错误表示我们预期得到一个 `u64` 类型（原始类型），但实际得到了不同的类型："

#: src/ch02-01-variables-and-mutability.md:237
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"

#: src/ch02-01-variables-and-mutability.md:247
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types they\n"
"can have."
msgstr "现在我们已经了解了变量如何工作，让我们看看变量可以被赋予的其他数据类型。"

#: src/ch02-01-variables-and-mutability.md:252
msgid "<footer id=\"last-change\">Last change: 2023-09-04</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-04</footer>"

#: src/ch02-02-data-types.md:1
msgid "## Data Types"
msgstr "## 数据类型"

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what kind of\n"
"data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds."
msgstr ""
"在 Cairo 中，每一个值都属于某一个数据类型（data type），\n"
"这告诉 Cairo 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。"

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that it\n"
"must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases\n"
"when many types are possible, we can use a cast method where we specify the desired output type."
msgstr ""
"记住，Cairo 是静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。\n"
"在可能存在多种类型的情况下，我们可以使用一种称为“类型转换”的方法，在其中指定所需的输出类型。"

#: src/ch02-02-data-types.md:10
msgid ""
"```rust\n"
"fn main() {\n"
"    let x: felt252 = 3;\n"
"    let y: u32 = x.try_into().unwrap();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let x: felt252 = 3;\n"
"    let y: u32 = x.try_into().unwrap();\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr "你会看到其它数据类型的各种类型注解。"

#: src/ch02-02-data-types.md:19
msgid "### Scalar Types"
msgstr "### 标量类型"

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar types:\n"
"felts, integers, and booleans. You may recognize\n"
"these from other programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"一个 _标量_ （scalar）类型表示一个单一的值。Cairo 有三种主要的标量类型：\n"
"felts、整数（integers）和布尔值（booleans）。你可能在其他语言中见过它们。\n"
"让我们深入了解它们在 Cairo 中是如何工作的。"

#: src/ch02-02-data-types.md:25
msgid "#### Felt Type"
msgstr "#### Felt 类型"

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword `felt252`. In the context of Cairo, when we say “a "
"field element” we mean an integer in the range `0 <= x < P`,\n"
"where `P` is a very large prime number currently equal to `P = 2^{251} + 17 * 2^{192}+1`. When adding, subtracting, or multiplying, if the result falls outside the specified range of "
"the prime number, an overflow occurs, and an appropriate multiple of P is added or subtracted to bring the result back within the range (i.e., the result is computed modulo P)."
msgstr ""
"在 Cairo 中，如果你没有指定一个变量或参数的类型，它的类型默认为一个字段元素，由关键字 `felt252` 表示。在 Cairo 中，当我们说 \"一个字段元素 \"时，我们指的是范围为 `0 <= x < P` 的整"
"数、\n"
"其中 `P` 是一个非常大的素数，目前为 `P = 2^{251} + 17 * 2^{192}+1`。当加减乘时，如果结果超出了素数的指定范围，就会发生溢出，然后再加上或减去 P 的适当倍数，使结果回到范围内（也就是说，"
"结果是以 P 为模数计算的）。"

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where\n"
"integer division `x / y` is defined as `[x/y]` where the integer part of the quotient is returned (so you get `7 / 3 = 2`) and it may or may not satisfy the equation `(x / y) * y == "
"x`,\n"
"depending on the divisibility of `x` by `y`."
msgstr ""
"整数和字段元素之间最重要的区别是除法：字段元素的除法（以及 Cairo 的除法）与普通 CPU 的除法不同，其中整数除法 `x / y` 被定义为`[x/y]`，\n"
"其中商的整数部分被返回（所以你得到`7 / 3 = 2`），它可能满足或不满足方程式 `(x / y) * y == x`，这取决于 `x` 是否能被 `y` 除。"

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation `(x / y) * y == x`. If y divides x as integers, you will get the expected result in Cairo (for example `6 / "
"2`\n"
"will indeed result in `3`).\n"
"But when y does not divide x, you may get a surprising result: For example, since `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, the value of `1 / 2` in Cairo is `(P+1)/2` (and not 0 or 0.5), as "
"it satisfies the above equation."
msgstr ""
"在 Cairo，`x/y` 的结果被定义为总是满足方程式 `(x / y) * y == x`。如果 y 作为整数可以整除 x ，你将得到 Cairo 的预期结果（例如�����`6 / 2` 确实会得到`3`）。\n"
"但是当 y 不能整除 x 时，你可能会得到一个令人惊讶的结果：\n"
"例如，由于 `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`，在 Cairo 中 `1 / 2` 的值是 `(P+1)/2`（而不是0或0.5），因为它满足上述公式。"

#: src/ch02-02-data-types.md:38
msgid "#### Integer Types"
msgstr "#### 整数类型"

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating all types in the core library.\n"
"However, it is highly recommended for programmers to use the integer types instead of the `felt252` type whenever possible, as the `integer` types come with added security features "
"that provide extra protection against potential vulnerabilities in the code, such as overflow checks. By using these integer types, programmers can ensure that their programs are "
"more secure and less susceptible to attacks or other security threats.\n"
"An _integer_ is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer.\n"
"Table 3-1 shows\n"
"the built-in integer types in Cairo. We can use any of these variants to declare\n"
"the type of an integer value."
msgstr ""
"所谓的felt252 类型是一个基本类型，是创建核心库中所有类型的基础。\n"
"然而，我们强烈建议程序员尽可能使用整数类型而不是 `felt252` 类型，因为 `integer` 类型带有额外的安全功能，\n"
"对代码中的潜在漏洞提供额外保护，如溢出检查。通过使用这些整数类型，程序员可以确保他们的程序更加安全，不容易受到攻击或其他安全威胁。\n"
"一个 _integer_ 是一个没有小数部分的数字。这个类型声明指出了该类型可以用来存储整数的比特位。\n"
"表3-1显示了Cairo中内建的整数类型。我们可以使用这些变体中的任何一种来声明一个整数值的类型。"

#: src/ch02-02-data-types.md:47
msgid "<span class=\"caption\">Table 3-1: Integer Types in Cairo</span>"
msgstr "<span class=\"caption\">表格3-1： Cairo 的整数类型</span>"

#: src/ch02-02-data-types.md:49
msgid ""
"| Length  | Unsigned |\n"
"| ------- | -------- |\n"
"| 8-bit   | `u8`     |\n"
"| 16-bit  | `u16`    |\n"
"| 32-bit  | `u32`    |\n"
"| 64-bit  | `u64`    |\n"
"| 128-bit | `u128`   |\n"
"| 256-bit | `u256`   |\n"
"| 32-bit  | `usize`  |"
msgstr ""
"| 长度  | 无符号 |\n"
"| ------- | -------- |\n"
"| 8-bit   | `u8`     |\n"
"| 16-bit  | `u16`    |\n"
"| 32-bit  | `u32`    |\n"
"| 64-bit  | `u64`    |\n"
"| 128-bit | `u128`   |\n"
"| 256-bit | `u256`   |\n"
"| 32-bit  | `usize`  |"

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is just an alias for `u32`; however, it might be useful when in the future Cairo can be compiled to MLIR.\n"
"As variables are unsigned, they can't contain a negative number. This code will cause the program to panic:"
msgstr ""
"每个变量都有一个明确的大小。注意，现在，`usize `类型只是 `u32` 的别名；然而，当将来 Cairo 可以被编译为 MLIR 时，它可能会很有用。\n"
"由于变量是无符号的，它们不能包含一个负数。这段代码会引起程序出现错误："

#: src/ch02-02-data-types.md:62
msgid ""
"```rust\n"
"fn sub_u8s(x: u8, y: u8) -> u8 {\n"
"    x - y\n"
"}\n"
"\n"
"fn main() {\n"
"    sub_u8s(1, 3);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn sub_u8s(x: u8, y: u8) -> u8 {\n"
"    x - y\n"
"}\n"
"\n"
"fn main() {\n"
"    sub_u8s(1, 3);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for `u256` which needs 4 more bits to be stored. Under the hood, `u256` is basically a struct with 2 fields: `u256 "
"{low: u128, high: u128}`"
msgstr "前面提到的所有整数类型都适合`felt252`，但`u256`除外，它需要存储 4 个以上的位。在内部原理中，`u256`基本上是一个包含 2 个字段的结构体：`u256 {low: u128, high: u128}`"

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note\n"
"that number literals that can be multiple numeric types allow a type suffix,\n"
"such as `57_u8`, to designate the type."
msgstr ""
"你可以用表 3-2 中的任何一种形式编写数字字面值。\n"
"请注意可以是多种数字类型的数字字面值允许使用类型后缀，\n"
"例如像 `57_u8` 这样指定类型。"

#: src/ch02-02-data-types.md:78
msgid "<span class=\"caption\">Table 3-2: Integer Literals in Cairo</span>"
msgstr "<span class=\"caption\">表3-2：Cairo 的整数类型字面值</span>"

#: src/ch02-02-data-types.md:80
msgid ""
"| Numeric literals | Example   |\n"
"| ---------------- | --------- |\n"
"| Decimal          | `98222`   |\n"
"| Hex              | `0xff`    |\n"
"| Octal            | `0o04321` |\n"
"| Binary           | `0b01`    |"
msgstr ""
"| 数字字面值 | 例子   |\n"
"| ---------------- | --------- |\n"
"| Decimal(十进制)          | `98222`   |\n"
"| Hex (十六进制)              | `0xff`    |\n"
"| Octal (八进制)            | `0o04321` |\n"
"| Binary (二进制)           | `0b01`    |"

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size.\n"
"The primary situation in which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"那么，你如何知道要使用哪种类型的整数？试着估计你用的 int 的最大值，然后选择合适的大小。\n"
" `usize` 的主要是用在为某种集合做索引时。"

#: src/ch02-02-data-types.md:90
msgid "#### Numeric Operations"
msgstr "#### 数值运算"

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the integer\n"
"types: addition, subtraction, multiplication, division, and remainder. Integer\n"
"division truncates toward zero to the nearest integer. The following code shows\n"
"how you’d use each numeric operation in a `let` statement:"
msgstr ""
"Cairo 支持所有整数类型的基本数学运算：\n"
"加法、减法、乘法、除法和取余。\n"
"整数除法将向最接近0的整数截断。以下代码展示了如何在 `let` 语句中使用它们："

#: src/ch02-02-data-types.md:97
msgid ""
"```rust\n"
"fn main() {\n"
"    // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and evaluates\n"
"to a single value, which is then bound to a variable."
msgstr "这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。"

#: src/ch02-02-data-types.md:120
msgid "[Appendix B][appendix_b] contains a list of all operators that Cairo provides."
msgstr "[附录 B][appendix_b] 包含了一个Cairo中所有操作符的列表。"

#: src/ch02-02-data-types.md:122
msgid "#### The Boolean Type"
msgstr "#### 布尔类型"

#: src/ch02-02-data-types.md:124
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two possible\n"
"values: `true` and `false`. Booleans are one felt252 in size. The Boolean type in\n"
"Cairo is specified using `bool`. For example:"
msgstr ""
"正如其他大部分编程语言一样，Cairo 中的布尔类型有两个可能的值：`true` 和  `false`。布尔型的大小为一个 felt252。\n"
"布尔类型在 Cairo 中是用 `bool` 来指定的。例如："

#: src/ch02-02-data-types.md:128
msgid ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:136
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if`\n"
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control\n"
"Flow”][control-flow] section."
msgstr ""
"使用布尔值的主要方式是通过条件语句，如 `if` 表达式。\n"
"我们将在[\"控制流”][control-flow]部分介绍 `if` 表达式在 Cairo 中的工作原理。"

#: src/ch02-02-data-types.md:140
msgid "#### The Short String Type"
msgstr "#### 短字符串类型"

#: src/ch02-02-data-types.md:142
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters forming what we call a \"short string\" inside `felt252`s. A short string has a max length of 31 chars. "
"This is to ensure that it can fit in a single felt (a felt is 252 bits, one ASCII char is 8 bits).\n"
"Here are some examples of declaring values by putting them between single quotes:"
msgstr ""
"Cairo 没有字符串（String）的原生类型，但你可以在 `felt252` 中存储短字符，形成我们所说的 \"短字符串\"。一个短字符串的最大长度为 31 个字符。这是为了确保它能装入一个 felt （一个 felt 是"
"252位，一个 ASCII 字符是 8 位）。\n"
"可以通过把值放在单引号之间来声明短字符串，下面是一些例子："

#: src/ch02-02-data-types.md:145
msgid ""
"```rust\n"
"# fn main() {\n"
"    let my_first_char = 'C';\n"
"    let my_first_string = 'Hello world';\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# fn main() {\n"
"    let my_first_char = 'C';\n"
"    let my_first_string = 'Hello world';\n"
"# }\n"
"```"

#: src/ch02-02-data-types.md:152
msgid "### Type casting"
msgstr "### 类型转换"

#: src/ch02-02-data-types.md:154
msgid "In Cairo, you can convert types scalar types from one type to another by using the `try_into` and `into` methods provided by the `TryInto` and `Into` traits, respectively."
msgstr "在 Cairo 中，你可以使用 `TryInto` 和 `Into` 特性提供的 `try_into` 和 `into` 方法在标量类型之间进行显式类型转换。"

#: src/ch02-02-data-types.md:156
msgid ""
"The `try_into` method allows for safe type casting when the target type might not fit the source value. Keep in mind that `try_into` returns an `Option<T>` type, which you'll need to "
"unwrap to access the new value."
msgstr "`try_into` 方法允许在目标类型可能不适合源值时进行安全的类型转换。请记住，`try_into` 会返回一个 `Option<T>` 类型，你需要解开（unwrap）这个类型来访问新的值。"

#: src/ch02-02-data-types.md:158
msgid "On the other hand, the `into` method can be used for type casting when success is guaranteed, such as when the source type is smaller than the destination type."
msgstr "另一方面，当转换必然成功时，如源类型小于目标类型时，`into` 方法可用于类型转换。"

#: src/ch02-02-data-types.md:160
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the source value to cast it to another type. The new variable's type must be explicitly defined, as demonstrated "
"in the example below."
msgstr "为了进行转换，在源值上调用 `var.into()` 或 `var.try_into()` 来将其转换为另一种类型。新变量的类型必须被明确定义，如下面的例子所示。"

#: src/ch02-02-data-types.md:162
msgid ""
"```rust\n"
"fn main() {\n"
"    let my_felt252 = 10;\n"
"    // Since a felt252 might not fit in a u8, we need to unwrap the Option<T> type\n"
"    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
"    let my_u16: u16 = my_u8.into();\n"
"    let my_u32: u32 = my_u16.into();\n"
"    let my_u64: u64 = my_u32.into();\n"
"    let my_u128: u128 = my_u64.into();\n"
"    // As a felt252 is smaller than a u256, we can use the into() method\n"
"    let my_u256: u256 = my_felt252.into();\n"
"    let my_usize: usize = my_felt252.try_into().unwrap();\n"
"    let my_other_felt252: felt252 = my_u8.into();\n"
"    let my_third_felt252: felt252 = my_u16.into();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let my_felt252 = 10;\n"
"    // Since a felt252 might not fit in a u8, we need to unwrap the Option<T> type\n"
"    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
"    let my_u16: u16 = my_u8.into();\n"
"    let my_u32: u32 = my_u16.into();\n"
"    let my_u64: u64 = my_u32.into();\n"
"    let my_u128: u128 = my_u64.into();\n"
"    // As a felt252 is smaller than a u256, we can use the into() method\n"
"    let my_u256: u256 = my_felt252.into();\n"
"    let my_usize: usize = my_felt252.try_into().unwrap();\n"
"    let my_other_felt252: felt252 = my_u8.into();\n"
"    let my_third_felt252: felt252 = my_u16.into();\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:179
msgid "### The Tuple Type"
msgstr "### 元组类型"

#: src/ch02-02-data-types.md:181
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a\n"
"variety of types into one compound type. Tuples have a fixed length: once\n"
"declared, they cannot grow or shrink in size."
msgstr ""
"_元组_ 是一个将多个其他类型的值组合进一个复合类型的主要方式。\n"
"元组长度固定：一旦声明，其长度不会增大或缩小。"

#: src/ch02-02-data-types.md:185
msgid ""
"We create a tuple by writing a comma-separated list of values inside\n"
"parentheses. Each position in the tuple has a type, and the types of the\n"
"different values in the tuple don’t have to be the same. We’ve added optional\n"
"type annotations in this example:"
msgstr ""
"我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。\n"
"元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。\n"
"这个例子中使用了可选的类型注解："

#: src/ch02-02-data-types.md:190
msgid ""
"```rust\n"
"fn main() {\n"
"    let tup: (u32, u64, bool) = (10, 20, true);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let tup: (u32, u64, bool) = (10, 20, true);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:196
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a\n"
"single compound element. To get the individual values out of a tuple, we can\n"
"use pattern matching to destructure a tuple value, like this:"
msgstr ""
"`tup` 变量绑定到整个元组上，因为元组是一个单独的复合元素。\n"
"为了从元组中获取单个值，可以使用模式匹配（pattern matching）\n"
"来解构（destructure）元组值，像这样："

#: src/ch02-02-data-types.md:200
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let tup = (500, 6, true);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    if y == 6 {\n"
"        'y is six!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let tup = (500, 6, true);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    if y == 6 {\n"
"        'y is six!'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:213
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It then\n"
"uses a pattern with `let` to take `tup` and turn it into three separate\n"
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks\n"
"the single tuple into three parts. Finally, the program prints `y is six` as the value of\n"
"`y` is `6`."
msgstr ""
"程序首先创建了一个元组并绑定到 `tup` 变量上。\n"
"接着使用了 `let` 和一个模式将 `tup` 分成了三个不同的变量，\n"
" `x`、`y` 和 `z`。这叫做解构（destructuring），\n"
"因为它将一个元组拆成了三个部分。最后，程序打印出了 `y` 的值，\n"
"也就是 `6`。"

#: src/ch02-02-data-types.md:219
msgid ""
"We can also declare the tuple with value and types at the same time.\n"
"For example:"
msgstr ""
"我们也可以同时用 value 和 name 来声明元组。\n"
"比如说："

#: src/ch02-02-data-types.md:222
msgid ""
"```rust\n"
"fn main() {\n"
"    let (x, y): (felt252, felt252) = (2, 3);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let (x, y): (felt252, felt252) = (2, 3);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:228
msgid "### The unit type ()"
msgstr "### unit类型 ()"

#: src/ch02-02-data-types.md:230
msgid ""
"A _unit type_ is a type which has only one value `()`.\n"
"It is represented by a tuple with no elements.\n"
"Its size is always zero, and it is guaranteed to not exist in the compiled code."
msgstr ""
"一个 _unit 类型_ 是一个只有一个值 `()` 的类型。\n"
"它由一个没有元素的元组来表示。\n"
"它的大小总是为零，并且它在编译后的代码中一定不存在。"

#: src/ch02-02-data-types.md:237
msgid "<footer id=\"last-change\">Last change: 2023-09-28</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-28</footer>"

#: src/ch02-03-functions.md:1
msgid "## Functions"
msgstr "## 函数"

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most\n"
"important functions in the language: the `main` function, which is the entry\n"
"point of many programs. You’ve also seen the `fn` keyword, which allows you to\n"
"declare new functions."
msgstr ""
"函数在 Cairo 代码中非常普遍。你已经见过语言中最重要的函数之一：\n"
" `main` 函数，它是很多程序的入口点。\n"
"你也见过 `fn` 关键字，它用来声明新函数。"

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and variable\n"
"names, in which all letters are lowercase and underscores separate words.\n"
"Here’s a program that contains an example function definition:"
msgstr ""
"Cairo代码使用 *蛇形命名法（ _snake case_  ）* 作为函数和变量名称的常规样式。\n"
"所有的字母都是小写的，并以下划线分隔单词。\n"
"这里有一个程序，包含一个函数定义的例子："

#: src/ch02-03-functions.md:12
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn another_function() {\n"
"    'Another function.'.print();\n"
"}\n"
"\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"    another_function();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn another_function() {\n"
"    'Another function.'.print();\n"
"}\n"
"\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"    another_function();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:25
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name and a\n"
"set of parentheses. The curly brackets tell the compiler where the function\n"
"body begins and ends."
msgstr "在 Cairo 中，我们通过输入 `fn` 和函数名称以及一组括号来定义一个函数。大括号告诉编译器函数体的开始和结束位置。"

#: src/ch02-03-functions.md:29
msgid ""
"We can call any function we’ve defined by entering its name followed by a set\n"
"of parentheses. Because `another_function` is defined in the program, it can be\n"
"called from inside the `main` function. Note that we defined `another_function`\n"
"_before_ the `main` function in the source code; we could have defined it after\n"
"as well. Cairo doesn’t care where you define your functions, only that they’re\n"
"defined somewhere in a scope that can be seen by the caller."
msgstr ""
"可以使用函数名后跟圆括号来调用我们定义过的任意函数。\n"
"因为程序中已定义 `another_function` 函数，所以可以在 `main` 函数中调用它。\n"
"注意，源码中 `another_function` 定义在 `main` 函数 *之前* ；当然我们也可以定义在其之后。\n"
"Cairo 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。"

#: src/ch02-03-functions.md:36
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions\n"
"further. Place the `another_function` example in _src/lib.cairo_ and run it. You\n"
"should see the following output:"
msgstr ""
"让我们用 Scarb 启动一个名为 _functions_ 的新项目来进一步探索函数。\n"
"更进一步。把 `another_function` 的例子写入 _src/lib.cairo_ 中并运行它。你应该看到以下输出："

#: src/ch02-03-functions.md:40
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)\n"
"[DEBUG] Another function.            (raw: 22265147635379277118623944509513687592494)\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)\n"
"[DEBUG] Another function.            (raw: 22265147635379277118623944509513687592494)\n"
"```"

#: src/ch02-03-functions.md:46
msgid ""
"The lines execute in the order in which they appear in the `main` function.\n"
"First the “Hello, world!” message prints, and then `another_function` is called\n"
"and its message is printed."
msgstr ""
"这几行是按照它们在 `main` 函数中出现的顺序执行的。\n"
"首先打印 \"Hello, world!\" 信息，然后调用 `another_function`，并打印其信息。"

#: src/ch02-03-functions.md:50
msgid "### Parameters"
msgstr "### 参数"

#: src/ch02-03-functions.md:52
msgid ""
"We can define functions to have _parameters_, which are special variables that\n"
"are part of a function’s signature. When a function has parameters, you can\n"
"provide it with concrete values for those parameters. Technically, the concrete\n"
"values are called _arguments_, but in casual conversation, people tend to use\n"
"the words _parameter_ and _argument_ interchangeably for either the variables\n"
"in a function’s definition or the concrete values passed in when you call a\n"
"function."
msgstr ""
"我们可以定义为拥有 *参数（ _parameters_ ）* 的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。\n"
"技术上讲，这些具体值被称为 *参数*（ _arguments_ ），但是在日常交流中，人们倾向于不区分使用 _parameters_ 和 _arguments_ 来表示函数定义中的变量或调用函数时传入的具体值。"

#: src/ch02-03-functions.md:60
msgid "In this version of `another_function` we add a parameter:"
msgstr "在这个版本的 `another_function` 中，我们添加了一个参数："

#: src/ch02-03-functions.md:62
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: felt252) {\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: felt252) {\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:74
msgid "Try running this program; you should get the following output:"
msgstr "尝试运行这个程序；你应该得到以下输出："

#: src/ch02-03-functions.md:76 src/ch02-03-functions.md:276
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                 (raw: 5)\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                 (raw: 5)\n"
"```"

#: src/ch02-03-functions.md:81
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type of\n"
"`x` is specified as `felt252`. When we pass `5` in to `another_function`, the\n"
"`.print()` function outputs `5` in the console."
msgstr ""
"`another_function` 的声明有一个名为 `x` 的参数。\n"
"`x` 的类型被指定为 `felt252`。当我们把 `5` 传给 `another_function` 时，`.print()`函数在控制台中会输出 `5`。"

#: src/ch02-03-functions.md:85
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This is\n"
"a deliberate decision in Cairo’s design: requiring type annotations in function\n"
"definitions means the compiler almost never needs you to use them elsewhere in\n"
"the code to figure out what type you mean. The compiler is also able to give\n"
"more helpful error messages if it knows what types the function expects."
msgstr ""
"在函数签名中，你 _必须_ 声明每个参数的类型。\n"
"这是 Cairo 设计中一个经过慎重考虑的决定：\n"
"要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的\n"
"其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，\n"
"编译器就能够给出更有用的错误消息。"

#: src/ch02-03-functions.md:91
msgid ""
"When defining multiple parameters, separate the parameter declarations with\n"
"commas, like this:"
msgstr ""
"当定义多个参数时，用逗号分隔。\n"
"像这样："

#: src/ch02-03-functions.md:94
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5, 6);\n"
"}\n"
"\n"
"fn another_function(x: felt252, y: felt252) {\n"
"    x.print();\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5, 6);\n"
"}\n"
"\n"
"fn another_function(x: felt252, y: felt252) {\n"
"    x.print();\n"
"    y.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:107
msgid ""
"This example creates a function named `another_function` with two\n"
"parameters. The first parameter is named `x` and is an `felt252`. The second is\n"
"named `y` and is type `felt252` too. The function then prints the content of the felt `x` and then the content of the felt `y`."
msgstr ""
"这个例子创建了一个名为 `another_function` 的函数，它有两个\n"
"参数。第一个参数被命名为 `x`，类型是 `felt252`。第二个参数被命名为 `y`，也是 `felt252` 类型。然后，该函数打印了 `x` 的内容，然后打印 `y` 的内容。"

#: src/ch02-03-functions.md:111
msgid ""
"Let’s try running this code. Replace the program currently in your _functions_\n"
"project’s _src/lib.cairo_ file with the preceding example and run it using `scarb cairo-run`:"
msgstr ""
"让我们试着运行这段代码。用前面的示例替换当前在你的 _functions_\n"
"项目的 _src/lib.cairo_ 文件中的程序，然后使用 `scarb cairo-run` 运行它："

#: src/ch02-03-functions.md:114
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                 (raw: 5)\n"
"[DEBUG]                                 (raw: 6)\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"[DEBUG]                                 (raw: 5)\n"
"[DEBUG]                                 (raw: 6)\n"
"```"

#: src/ch02-03-functions.md:120
msgid ""
"Because we called the function with `5` as the value for `x` and `6` as\n"
"the value for `y`, the program output contains those values."
msgstr ""
"因为我们在调用函数时，将 `5` 作为 `x` 的值，将 `6` 作为 `y` 的值。\n"
"程序输出包含这些值。"

#: src/ch02-03-functions.md:123
msgid "#### Named parameters"
msgstr "### 命名参数"

#: src/ch02-03-functions.md:125
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the function calls more readable and self-descriptive.\n"
"If you want to use named parameters, you need to specify the name of the parameter and the value you want to pass to it. The syntax is `parameter_name: value`. If you pass a variable "
"that has the same name as the parameter, you can simply write `:parameter_name` instead of `parameter_name: variable_name`."
msgstr ""
"在 Cairo 中，命名参数允许您在调用函数时指定参数的名称。这使得函数调用更具可读性和自描述性。\n"
"如果你想使用命名参数，你需要指定参数的名称和你想传递给它的值。语法是 `parameter_name: value`。如果你传递的变量与参数名称相同，你可以简写为 `:parameter_name`，而不是 `parameter_name: "
"variable_name`。"

#: src/ch02-03-functions.md:128
msgid "Here is an example:"
msgstr "下面是一个例子："

#: src/ch02-03-functions.md:130
msgid ""
"```rust\n"
"fn foo(x: u8, y: u8) {}\n"
"\n"
"fn main() {\n"
"    let first_arg = 3;\n"
"    let second_arg = 4;\n"
"    foo(x: first_arg, y: second_arg);\n"
"    let x = 1;\n"
"    let y = 2;\n"
"    foo(:x, :y)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn foo(x: u8, y: u8) {}\n"
"\n"
"fn main() {\n"
"    let first_arg = 3;\n"
"    let second_arg = 4;\n"
"    foo(x: first_arg, y: second_arg);\n"
"    let x = 1;\n"
"    let y = 2;\n"
"    foo(:x, :y)\n"
"}\n"
"```"

#: src/ch02-03-functions.md:143
msgid "### Statements and Expressions"
msgstr "### 语句和表达式"

#: src/ch02-03-functions.md:145
msgid ""
"Function bodies are made up of a series of statements optionally ending in an\n"
"expression. So far, the functions we’ve covered haven’t included an ending\n"
"expression, but you have seen an expression as part of a statement. Because\n"
"Cairo is an expression-based language, this is an important distinction to\n"
"understand. Other languages don’t have the same distinctions, so let’s look at\n"
"what statements and expressions are and how their differences affect the bodies\n"
"of functions."
msgstr ""
"函数体由一系列的语句和一个可选的结尾表达式构成。\n"
"目前为止，我们提到的函数还不包含结尾表达式，\n"
"不过你已经见过作为语句一部分的表达式。因为 Cairo 是一门基于表达式\n"
"（expression-based）的语言，这是一个需要理解的（不同于其他语言）\n"
"重要区别。其他语言并没有这样的区别，所以让我们看看语句与表达式有什么区别以及这些区别是如何影响函数体的。"

#: src/ch02-03-functions.md:153
msgid ""
"- **Statements** are instructions that perform some action and do not return\n"
"  a value.\n"
"- **Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""
"- **语句**（Statements）是执行一些操作但不返回值的指令。\n"
"- **表达式**（Expressions）计算并产生一个值。让我们看一些例子。"

#: src/ch02-03-functions.md:157
msgid ""
"We’ve actually already used statements and expressions. Creating a variable and\n"
"assigning a value to it with the `let` keyword is a statement. In Listing 2-1,\n"
"`let y = 6;` is a statement."
msgstr ""
"实际上，我们已经使用过语句和表达式。\n"
"使用 `let` 关键字创建变量并绑定一个值是一个语句。在示例 2-1 中，`let y = 6;`; 是一个语句。"

#: src/ch02-03-functions.md:161
msgid ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"

#: src/ch02-03-functions.md:167
msgid "<span class=\"caption\">Listing 2-1: A `main` function declaration containing one statement</span>"
msgstr "<span class=\"caption\">示例2-1：一个包含一条语句的 `main` 函数声明</span>"

#: src/ch02-03-functions.md:169
msgid ""
"Function definitions are also statements; the entire preceding example is a\n"
"statement in itself."
msgstr "函数定义也是语句，上面整个例子本身就是一个语句。"

#: src/ch02-03-functions.md:172
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` statement\n"
"to another variable, as the following code tries to do; you’ll get an error:"
msgstr ""
"语句不返回值。因此，不能把 `let` 语句赋值给另一个变量，比如下面的例子尝试做\n"
"的，会产生一个错误："

#: src/ch02-03-functions.md:175
msgid ""
"```rust, noplayground\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"
msgstr ""
"```rust, noplayground\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"

#: src/ch02-03-functions.md:181
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "当你运行这个程序时，你将得到的错误看起来是这样："

#: src/ch02-03-functions.md:183
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Missing token TerminalRParen.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"                      ^\n"
"\n"
"error: Skipped tokens. Expected: statement.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Missing token TerminalRParen.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"                      ^\n"
"\n"
"error: Skipped tokens. Expected: statement.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"```"

#: src/ch02-03-functions.md:205
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything for\n"
"`x` to bind to. This is different from what happens in other languages, such as\n"
"C and Ruby, where the assignment returns the value of the assignment. In those\n"
"languages, you can write `x = y = 6` and have both `x` and `y` have the value\n"
"`6`; that is not the case in Cairo."
msgstr ""
"语句 `let y = 6` 没有返回一个值，所以没有任何东西让 `x` 与之绑定。这与其他语言\n"
"中的情况不同，比如说 C 和 Ruby，其中赋值会返回赋值的值。\n"
"在这些语言中，你可以写 `x = y = 6`，让 `x`和 `y` 都有值 `6`；但在 Cairo 中不是这样的。"

#: src/ch02-03-functions.md:211
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code that\n"
"you’ll write in Cairo. Consider a math operation, such as `5 + 6`, which is an\n"
"expression that evaluates to the value `11`. Expressions can be part of\n"
"statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an\n"
"expression that evaluates to the value `6`. Calling a function is an\n"
"expression. A new scope block created with\n"
"curly brackets is an expression, for example:"
msgstr ""
"表达式会计算出一个值，并且你编写的大部分 Cairo 代码将是由表达式组成的。\n"
"考虑一个数学运算，比如 `5 + 6` ，这是一个表达式并计算出值 `11`。\n"
"表达式可以是语句的一部分：在示例 2-1 中，语句 `let y = 6;` 中的 `6` 是一个表达式，它计算出的值是 `6` 。\n"
"函数调用是一个表达式。宏调用也是一个表达式。用大括号创建的一个新的块作用域同样也是一个表达式，例如："

#: src/ch02-03-functions.md:219
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    y.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:231
msgid "This expression:"
msgstr "这个表达式："

#: src/ch02-03-functions.md:233
msgid ""
"```rust, noplayground\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"```"
msgstr ""
"```rust, noplayground\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"```"

#: src/ch02-03-functions.md:240
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to `y`\n"
"as part of the `let` statement. Note that the `x + 1` line doesn’t have a\n"
"semicolon at the end, which is unlike most of the lines you’ve seen so far.\n"
"Expressions do not include ending semicolons. If you add a semicolon to the end\n"
"of an expression, you turn it into a statement, and it will then not return a\n"
"value. Keep this in mind as you explore function return values and expressions\n"
"next."
msgstr ""
"是一个代码块，它的值是 `4`。这个值作为 `let` 语句的一部分被绑定到 `y` 上。注意\n"
" `x + 1` 这一行在结尾没有分号，与你见过的大部分代码行不同。表达式的结尾没有\n"
"分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。\n"
"在接下来学习具有返回值的函数和表达式时要谨记这一点。"

#: src/ch02-03-functions.md:248
msgid "### Functions with Return Values"
msgstr "### 具有返回值的函数"

#: src/ch02-03-functions.md:250
msgid ""
"Functions can return values to the code that calls them. We don’t name return\n"
"values, but we must declare their type after an arrow (`->`). In Cairo, the\n"
"return value of the function is synonymous with the value of the final\n"
"expression in the block of the body of a function. You can return early from a\n"
"function by using the `return` keyword and specifying a value, but most\n"
"functions return the last expression implicitly. Here’s an example of a\n"
"function that returns a value:"
msgstr ""
"函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头(`->`)后声明它\n"
"的类型。在 Cairo 中，函数的返回值等同于函数体最后一个表达式的值。使用 \n"
"`return` 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。\n"
"这是一个有返回值的函数的例子："

#: src/ch02-03-functions.md:258
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn five() -> u32 {\n"
"    5\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn five() -> u32 {\n"
"    5\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:271
msgid ""
"There are no function calls, or even `let` statements in the `five`\n"
"function—just the number `5` by itself. That’s a perfectly valid function in\n"
"Cairo. Note that the function’s return type is specified too, as `-> u32`. Try\n"
"running this code; the output should look like this:"
msgstr ""
"在 five 函数中没有函数调用、宏、甚至没有 `let` 语句 —— 只有数字 `5`。这在\n"
" Cairo 中是一个完全有效的函数。注意，也指定了函数返回值的类型，就是\n"
" `-> u32`。尝试运行代码；输出应该看起来像这样："

#: src/ch02-03-functions.md:281
msgid ""
"The `5` in `five` is the function’s return value, which is why the return type\n"
"is `u32`. Let’s examine this in more detail. There are two important bits:\n"
"first, the line `let x = five();` shows that we’re using the return value of a\n"
"function to initialize a variable. Because the function `five` returns a `5`,\n"
"that line is the same as the following:"
msgstr ""
"`five` 函数的返回值是 `5` ，所以返回值类型是 `u32`。让我们仔细检查一下这段代\n"
"码。有两个重要的部分：首先，`let x = five();` 这一行表明我们使用函数的返回值初\n"
"始化一个变量。因为 `five` 函数返回 `5`，这一行与如下代码相同："

#: src/ch02-03-functions.md:287
msgid ""
"```rust, noplayground\n"
"let x = 5;\n"
"```"
msgstr ""
"```rust, noplayground\n"
"let x = 5;\n"
"```"

#: src/ch02-03-functions.md:291
msgid ""
"Second, the `five` function has no parameters and defines the type of the\n"
"return value, but the body of the function is a lonely `5` with no semicolon\n"
"because it’s an expression whose value we want to return.\n"
"Let’s look at another example:"
msgstr ""
"第二，`five` 函数没有参数并定义了返回值的类型。不过函数体只有单单一个 `5` 也没\n"
"有分号，因为这是一个表达式，我们想要返回它的值。\n"
"让我们看看另一个例子："

#: src/ch02-03-functions.md:296
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1\n"
"}\n"
"```"

#: src/ch02-03-functions.md:310
msgid ""
"Running this code will print `[DEBUG]                    (raw: 6)`. But if we place a\n"
"semicolon at the end of the line containing `x + 1`, changing it from an\n"
"expression to a statement, we’ll get an error:"
msgstr ""
"运行这段代码将打印 `[DEBUG] (raw: 6)`。但是如果在包含 `x + 1` 的行尾放置一个\n"
"分号，把它从一个表达式变成一个语句，我们会看到一个错误："

#: src/ch02-03-functions.md:314
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1;\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1;\n"
"}\n"
"```"

#: src/ch02-03-functions.md:328
msgid "Compiling this code produces an error, as follows:"
msgstr "编译这段代码会产生一个错误，如下所示："

#: src/ch02-03-functions.md:330
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"
msgstr ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"

#: src/ch02-03-functions.md:334
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue with this\n"
"code. The definition of the function `plus_one` says that it will return an\n"
"`u32`, but statements don’t evaluate to a value, which is expressed by `()`,\n"
"the unit type. Therefore, nothing is returned, which contradicts the function\n"
"definition and results in an error."
msgstr ""
"主要的错误信息 `Unexpected return type` 揭示了该代码的核心问题。\n"
"函数`plus_one` 的定义说它将返回一个 `u32` 类型的值，但是语句并不会返回一个值，而是给出了一个 `()`unit 类型。\n"
"因此，没有返回值与函数的定义相矛盾，导致了错误发生。"

#: src/ch02-03-functions.md:340 src/appendix-01-keywords.md:87
msgid "<footer id=\"last-change\">Last change: 2023-09-18</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-18</footer>"

#: src/ch02-04-comments.md:1
msgid "# Comments"
msgstr "# 注释"

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using comments. To create a comment, use the // syntax, after which any text on the same line will be ignored by "
"the compiler."
msgstr ""
"在 Cairo 程序中，你可以使用注释在代码中加入解释性的文本。\n"
"要创建一个注释，请使用 // 语法，之后同一行的任何文本都会被编译器忽略。"

#: src/ch02-04-comments.md:5
msgid ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"

#: src/ch02-04-comments.md:12 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:121 src/ch99-01-03-02-contract-functions.md:110 src/appendix-04-useful-development-tools.md:36
msgid "<footer id=\"last-change\">Last change: 2023-08-10</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-08-10</footer>"

#: src/ch02-05-control-flow.md:1
msgid "## Control Flow"
msgstr "## 控制流"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming "
"languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops."
msgstr ""
"根据条件是否为真来决定是否执行某些代码，以及根据条件是否为真来重复运行一段\n"
"代码的能力是大部分编程语言的基本组成部分。Cairo 代码中最常见的用来控制执行\n"
"流的结构是 `if` 表达式和循环。"

#: src/ch02-05-control-flow.md:5
msgid "### `if` Expressions"
msgstr "### `if`表达式"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You provide a condition and then state, “If this condition is met, run this block of code. If the condition "
"is not met, do not run this block of code.”"
msgstr ""
"`if` 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满\n"
"足，运行这段代码；如果条件不满足，不运行这段代码。”"

#: src/ch02-05-control-flow.md:11
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    } else {\n"
"        'condition was false'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    } else {\n"
"        'condition was false'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks whether or not the variable `number` has a value equal to 5. We place "
"the block of code to execute if the condition is `true` immediately after the condition inside curly brackets."
msgstr ""
"所有的 `if` 表达式都以关键字 `if` 开始，其后跟一个条件。在这个例子中，条件检查\n"
"变量 `number` 的值是否等于 5。在条件为 `true` 时希望执行的代码块位于紧跟条件\n"
"之后的大括号中。"

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to `false`. "
"If you don’t provide an `else` expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit of code."
msgstr ""
"另外，我们也可以包含一个可选的 `else` 表达式来提供一个在条件为 `false` 时应当执行的代码块，这里我们就这么做了。如果不提供 `else` 表达式并且条件为 `false` 时，程序会直接忽略 `if` 代码"
"块并继续执行下面的代码。"

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "尝试运行这段代码；你应该看到以下输出："

#: src/ch02-05-control-flow.md:31
msgid ""
"```shell\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was false\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was false\n"
"```"

#: src/ch02-05-control-flow.md:36
msgid "Let’s try changing the value of `number` to a value that makes the condition `true` to see what happens:"
msgstr "让我们试着改变 `number` 的值使条件为 `true` 时看看会发生什么："

#: src/ch02-05-control-flow.md:38
msgid ""
"```rust, noplayground\n"
"    let number = 5;\n"
"```"
msgstr ""
"```rust, noplayground\n"
"    let number = 5;\n"
"```"

#: src/ch02-05-control-flow.md:42
msgid ""
"```shell\n"
"$ cairo-run main.cairo\n"
"condition was true\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-run main.cairo\n"
"condition was true\n"
"```"

#: src/ch02-05-control-flow.md:47
msgid "It’s also worth noting that the condition in this code must be a bool. If the condition isn’t a bool, we’ll get an error."
msgstr "还值得注意的是，这段代码中的条件必须是一个 `bool` 值。如果该条件不是 `bool` 值，我们会得到一个错误。"

#: src/ch02-05-control-flow.md:49
msgid ""
"```shell\n"
"$ cairo-run main.cairo\n"
"thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. Error: Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId { id: 1, debug_name: "
"None })]. Error: Provided generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/utils.rs:256:9\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-run main.cairo\n"
"thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. Error: Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId { id: 1, debug_name: "
"None })]. Error: Provided generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/utils.rs:256:9\n"
"```"

#: src/ch02-05-control-flow.md:54
msgid "### Handling Multiple Conditions with `else if`"
msgstr "### 用`else if`处理多个条件"

#: src/ch02-05-control-flow.md:56
msgid "You can use multiple conditions by combining if and else in an else if expression. For example:"
msgstr "你可以通过在一个 else if 表达式中结合 if 和 else 来使用多个条件。比如说："

#: src/ch02-05-control-flow.md:60
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 12 {\n"
"        'number is 12'.print();\n"
"    } else if number == 3 {\n"
"        'number is 3'.print();\n"
"    } else if number - 2 == 1 {\n"
"        'number minus 2 is 1'.print();\n"
"    } else {\n"
"        'number not found'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 12 {\n"
"        'number is 12'.print();\n"
"    } else if number == 3 {\n"
"        'number is 3'.print();\n"
"    } else if number - 2 == 1 {\n"
"        'number minus 2 is 1'.print();\n"
"    } else {\n"
"        'number not found'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:78
msgid "This program has four possible paths it can take. After running it, you should see the following output:"
msgstr "这个程序有四种可能的路径。运行后，你应该看到以下输出："

#: src/ch02-05-control-flow.md:80
msgid ""
"```shell\n"
"[DEBUG]\tnumber is 3\n"
"```"
msgstr ""
"```shell\n"
"[DEBUG]\tnumber is 3\n"
"```"

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is "
"`true`, we don’t see the output `number minus 2 is 1'.print()`, nor do we see the `number not found` text from the `else` block. That’s because Cairo only executes the block for the "
"first true condition, and once it finds one, it doesn’t even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want "
"to refactor your code. [Chapter 6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo branching construct called `match` for these cases."
msgstr ""
"执行该程序时，它会依次检查每个 `if` 表达式，并执行条件求值为 `true` 的第一个体。请注意，即使 `number - 2 == 1` 是 `true`，我们也看不到输出 `number minus 2 is 1'.print()` ，也看不到 "
"`else` 块中的 `number not found` 文本。这是因为 Cairo 只执行第一个真条件的代码块，一旦找到一个真条件，就不会再检查其他条件。使用过多的 `else if` 表达式会使代码变得杂乱无章，所以如果你"
"有一个以上的 `else if` 表达式，你可能需要重构你的代码。[Chapter 6](./ch06-02-the-match-control-flow-construct.md) 介绍了一种强大的Cairo语言分支结构，称为 \"match\"，用于处理这些情况。"

#: src/ch02-05-control-flow.md:86
msgid "### Using `if` in a `let` statement"
msgstr "### 在 `let` 语句中使用 `if`"

#: src/ch02-05-control-flow.md:88
msgid "Because if is an expression, we can use it on the right side of a let statement to assign the outcome to a variable."
msgstr "因为 if 是一个表达式，我们可以在 let 语句的右边使用它，将结果分配给一个变量。"

#: src/ch02-05-control-flow.md:92
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition {\n"
"        5\n"
"    } else {\n"
"        6\n"
"    };\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition {\n"
"        5\n"
"    } else {\n"
"        6\n"
"    };\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:109
msgid ""
"```shell\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was true\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was true\n"
"```"

#: src/ch02-05-control-flow.md:114
msgid "The `number` variable will be bound to a value based on the outcome of the `if` expression. Which will be 5 here."
msgstr "`number` 变量将会绑定到表示 `if` 表达式结果的值上。这里将是 5。"

#: src/ch02-05-control-flow.md:116
msgid "### Repetition with Loops"
msgstr "### 使用循环重复执行"

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and "
"then start immediately back at the beginning. To experiment with loops, let’s create a new project called loops."
msgstr ""
"多次执行同一段代码是很常用的，Cairo 为此提供了多种 循环（loops）。一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行。为了实验一下循环，让我们新建一个叫做 loops 的项目。"

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr "Cairo 目前只有一种循环：`loop`。"

#: src/ch02-05-control-flow.md:122
msgid "#### Repeating Code with `loop`"
msgstr "#### 使用 `loop` 重复执行代码"

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over again\n"
"forever or until you explicitly tell it to stop."
msgstr "`loop` 关键字告诉 Cairo 一遍又一遍地执行一段代码直到你明确要求停止。"

#: src/ch02-05-control-flow.md:127
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to look\n"
"like this:"
msgstr "作为一个例子，将你的_loops_目录下的_src/lib.cairo_文件修改如下："

#: src/ch02-05-control-flow.md:132
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break;\n"
"        }\n"
"        'again!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ;\n"
"        }\n"
"        'again!'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `again!` printed over and over continuously\n"
"until we stop the program manually, because the stop condition is never reached.\n"
"While the compiler prevents us from writing programs without a stop condition (`break` statement),\n"
"the stop condition might never be reached, resulting in an infinite loop.\n"
"Most terminals support the keyboard shortcut <span class=\"keystroke\">ctrl-c</span> to interrupt a program that is\n"
"stuck in a continual loop. Give it a try:"
msgstr ""
"当运行这个程序时，我们会看到程序不停的反复打印 `again!`，直到我们手动停止程序，因为程序从未达到停止条件。\n"
"虽然编译器阻止我们编写没有停止条件（`break`语句）的程序，但该停止条件可能永远不会达到，从而会程序导致无限循环。\n"
"大多数终端支持键盘快捷键 <span class=“keystroke”>ctrl-c</span> 来中断卡在无限循环的程序。试一试吧："

#: src/ch02-05-control-flow.md:152
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"Run panicked with err values: [375233589013918064796019]\n"
"Remaining gas: 1050\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run --available-gas=20000000\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"Run panicked with err values: [375233589013918064796019]\n"
"Remaining gas: 1050\n"
"```"

#: src/ch02-05-control-flow.md:166
msgid ""
"> Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a "
"program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. In this case, the program panicked because it ran out of gas, as the stop condition was never reached.\n"
"> It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network.\n"
"> If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program."
msgstr ""
"> 注意：Cairo通过包含一个 gas 计量器来防止我们运行无限循环的程序。 gas 计量器是一种限制程序中可进行的计算量的机制。通过给 `--available-gas` 标志设置一个值，我们可以设置程序的最大可用 "
"gas 量。gas 是一个计量单位，表示一条指令的计算成本。当设置的最大gas值耗尽时，程序将停止。在这种情况下，程序会抛出 gas 耗尽的错误(panic)，尽管从未达到停止条件。\n"
"> 对于部署在 Starknet 上的智能合约，它特别重要，因为它可以防止在网络上运行无限循环。\n"
"> 如果你正在编写一个需要运行循环的程序，你需要在执行时将 `--available-gas` 标志设置为一个足够大的值来运行该程序。"

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break` statement within the loop to tell the program when to stop\n"
"executing the loop. Let's fix the infinite loop by adding a making the stop condition `i > 10` reachable."
msgstr ""
"要退出循环，您可以在循环内部放置 `break` 语句，告诉程序何时停止循环。\n"
"我们可以通过在这个程序里加入可达的停止条件 `i > 10` ，来修复无限循环。"

#: src/ch02-05-control-flow.md:173
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break;\n"
"        }\n"
"        'again'.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break;\n"
"        }\n"
"        'again'.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:187
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration. Let's add a `continue` statement to our loop to "
"skip the `print` statement when `i` is equal to `5`."
msgstr "关键字 `continue` 告诉程序进入循环的下一个迭代，并跳过现在这个迭代中的其他代码。让我们给我们的循环添加一个`continue`语句，使得当`i`等于`5`时跳过`print`语句。"

#: src/ch02-05-control-flow.md:189
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break;\n"
"        }\n"
"        if i == 5 {\n"
"            i += 1;\n"
"            continue;\n"
"        }\n"
"        i.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break;\n"
"        }\n"
"        if i == 5 {\n"
"            i += 1;\n"
"            continue;\n"
"        }\n"
"        i.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:207
msgid "Executing this program will not print the value of `i` when it is equal to `5`."
msgstr "当`i`等于`5`时，执行这个程序将不会打印`i`的值。"

#: src/ch02-05-control-flow.md:209
msgid "#### Returning Values from Loops"
msgstr "#### 从循环中返回值"

#: src/ch02-05-control-flow.md:211
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, such\n"
"as checking whether an operation has succeeded. You might also need to pass\n"
"the result of that operation out of the loop to the rest of your code. To do\n"
"this, you can add the value you want returned after the `break` expression you\n"
"use to stop the loop; that value will be returned out of the loop so you can\n"
"use it, as shown here:"
msgstr ""
"`loop` 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你\n"
"可能会需要将操作的结果传递给其它的代码。如果将返回值加入你用来停止循环的 \n"
"`break` 表达式，它会被停止的循环返回，如下所示："

#: src/ch02-05-control-flow.md:218
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"        counter += 1;\n"
"    };\n"
"\n"
"    'The result is '.print();\n"
"    result.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"        counter += 1;\n"
"    };\n"
"\n"
"    'The result is '.print();\n"
"    result.print();\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:235
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to\n"
"`0`. Then we declare a variable named `result` to hold the value returned from\n"
"the loop. On every iteration of the loop, we check whether the `counter` is equal to `10`, and then add `1` to the `counter` variable.\n"
"When the condition is met, we use the `break` keyword with the value `counter * 2`. After the loop, we use a\n"
"semicolon to end the statement that assigns the value to `result`. Finally, we\n"
"print the value in `result`, which in this case is `20`."
msgstr ""
"在循环之前，我们声明一个名为 `counter` 的变量，并将其初始化为 `0`。然后我们声明一个名为 `result` 的变量，用来保存从循环中返回的值。\n"
"在循环的每一次迭代中，我们检查 `counter` 是否等于 `10`，然后在 `counter` 变量中加 `1`。当条件得到满足时，我们使用 `break` 关键字，其值为 `counter * 2`。在循环之后，我们用一个\n"
"分号来结束给`result`赋值的语句。最后，我们打印`result`中的值，在本例中是`20`。"

#: src/ch02-05-control-flow.md:242 src/ch03-02-dictionaries.md:528 src/ch03-03-custom-data-structures.md:214 src/ch05-03-method-syntax.md:286
#: src/ch07-05-separating-modules-into-different-files.md:98
msgid "## Summary"
msgstr "## 总结"

#: src/ch02-05-control-flow.md:244
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data types, functions, comments,\n"
"`if` expressions and loops! To practice with the concepts discussed in this chapter,\n"
"try building programs to do the following:"
msgstr ""
"你成功了！这一章很重要：你学到了变量、数据类型、函数、注释、\n"
"`if` 表达式和循环！要练习本章讨论的概念、\n"
"尝试编写程序来完成下列操作："

#: src/ch02-05-control-flow.md:248
msgid ""
"- Generate the _n_-th Fibonacci number.\n"
"- Compute the factorial of a number _n_."
msgstr ""
"- 产生第 _n_ 个斐波那契数。\n"
"- 计算一个数字的阶乘 _n_ 。"

#: src/ch02-05-control-flow.md:251
msgid "Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr "现在，我们将在下一章回顾 Cairo 中常见的集合类型。"

#: src/ch02-05-control-flow.md:253 src/ch03-01-arrays.md:160 src/ch03-03-custom-data-structures.md:222 src/ch08-00-generic-types-and-traits.md:13 src/ch08-01-generic-data-types.md:315
#: src/ch08-02-traits-in-cairo.md:225 src/ch10-01-unrecoverable-errors-with-panic.md:122 src/ch11-02-macros.md:39 src/appendix-05-common-types-and-traits-and-cairo-prelude.md:47
msgid "<footer id=\"last-change\">Last change: 2023-11-19</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-19</footer>"

#: src/ch03-00-common-collections.md:1
msgid "## Common Collections"
msgstr "## 常见集合"

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store and manipulate data. These collections are designed to be efficient, flexible, and easy to use. This section "
"introduces the primary collection types available in Cairo: Arrays and Dictionaries."
msgstr "Cairo 提供了一组常用的集合类型，可用于存储和处理数据。这些集合设计得高效、灵活、易于使用。本节将介绍 Cairo 中可用的主要集合类型：数组和字典。"

#: src/ch03-00-common-collections.md:5 src/ch03-02-dictionaries.md:534 src/ch04-00-understanding-ownership.md:10 src/ch04-01-what-is-ownership.md:372
#: src/ch04-02-references-and-snapshots.md:224 src/ch05-00-using-structs-to-structure-related-data.md:7 src/ch05-01-defining-and-instantiating-structs.md:152
#: src/ch05-02-an-example-program-using-structs.md:165 src/ch05-03-method-syntax.md:297 src/ch06-01-enums.md:204
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:41 src/ch07-01-packages-and-crates.md:47 src/ch07-02-defining-modules-to-control-scope.md:200
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:81 src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:245
#: src/ch07-05-separating-modules-into-different-files.md:108 src/ch09-00-testing-cairo-programs.md:3 src/ch10-00-error-handling.md:5 src/ch11-00-advanced-features.md:5
#: src/ch11-01-operator-overloading.md:36 src/ch99-01-03-04-reducing-boilerplate.md:49 src/appendix-03-derivable-traits.md:185
msgid "<footer id=\"last-change\">Last change: 2023-09-20</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-20</footer>"

#: src/ch03-01-arrays.md:1
msgid "## Arrays"
msgstr "## 数组"

#: src/ch03-01-arrays.md:3
msgid "An array is a collection of elements of the same type. You can create and use array methods by importing the `array::ArrayTrait` trait."
msgstr "一个数组是相同类型元素的集合。你可以通过导入`array::ArrayTrait`trait来创建和使用数组方法。"

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified.\n"
"This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items "
"from the front using `pop_front`."
msgstr ""
"需要注意的一个重要问题是，数组的修改选项有限。这里的数组实际上是以队列的形式存储的，其值不能被直接修改。\n"
"这与这样一个事实有关：一旦一个内存槽被写入，它就不能被覆盖，而只能从其中读出。你只能用`pop_front`将项目追加到数组的末端，并从前面删除项目。"

#: src/ch03-01-arrays.md:8
msgid "### Creating an Array"
msgstr "### 创建一个数组"

#: src/ch03-01-arrays.md:10
msgid "Creating an Array is done with the `ArrayTrait::new()` call. Here is an example of the creation of an array to which we append 3 elements:"
msgstr "创建一个数组是通过调用`ArrayTrait::new()`完成的。下面是一个创建3个元素的数组的例子："

#: src/ch03-01-arrays.md:12
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"}\n"
"```"

#: src/ch03-01-arrays.md:21
msgid "When required, you can pass the expected type of items inside the array when instantiating the array like this, or explicitly define the type of the variable."
msgstr "需要时，你可以在实例化数组时像下面这样传递数组内部元素的预期类型，或者明确定义变量的类型。"

#: src/ch03-01-arrays.md:23
msgid ""
"```rust, noplayground\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"```"
msgstr ""
"```rust, noplayground\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"```"

#: src/ch03-01-arrays.md:27
msgid ""
"```rust, noplayground\n"
"let mut arr:Array<u128> = ArrayTrait::new();\n"
"```"
msgstr ""
"```rust, noplayground\n"
"let mut arr:Array<u128> = ArrayTrait::new();\n"
"```"

#: src/ch03-01-arrays.md:31
msgid "### Updating an Array"
msgstr "### 更新一个数组"

#: src/ch03-01-arrays.md:33
msgid "#### Adding Elements"
msgstr "#### 添加元素"

#: src/ch03-01-arrays.md:35
msgid "To add an element to the end of an array, you can use the `append()` method:"
msgstr "要在一个数组的末尾添加一个元素，可以使用`append()`方法："

#: src/ch03-01-arrays.md:37
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let mut a = ArrayTrait::new();\n"
"#     a.append(0);\n"
"#     a.append(1);\n"
"    a.append(2);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# fn main() {\n"
"#     let mut a = ArrayTrait::new();\n"
"#     a.append(0);\n"
"#     a.append(1);\n"
"    a.append(2);\n"
"# }\n"
"```"

#: src/ch03-01-arrays.md:46
msgid "#### Removing Elements"
msgstr "#### 移除元素"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the `pop_front()` method.\n"
"This method returns an `Option` containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"要从一个数组的前面移除一个元素，你可以使用`pop_front()`方法。\n"
"该方法返回一个包含被移除元素的`Option`。如果数组为空，则返回`Option::None`。"

#: src/ch03-01-arrays.md:51
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"

#: src/ch03-01-arrays.md:65
msgid "The above code will print `10` as we remove the first element that was added."
msgstr "上面的代码将打印`10`，因为我们删除了第一个被添加的元素。"

#: src/ch03-01-arrays.md:67
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once they've been added. You can only add elements to the end of an array and "
"remove elements from the front of an array. These operations do not require memory mutation, as they involve updating pointers rather than directly modifying the memory cells."
msgstr ""
"在Cairo中，内存是不可改变的，这意味着一旦数组中的元素被添加，就不可能修改它们。你只能将元素添加到数组的末端，并从数组的前端移除元素。这些操作不需要内存突变，因为它们涉及到更新指针而不"
"是直接修改内存单元。"

#: src/ch03-01-arrays.md:69
msgid "### Reading Elements from an Array"
msgstr "### 从数组中读取元素"

#: src/ch03-01-arrays.md:71
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that return different types. Using `arr.at(index)` is equivalent to using the subscripting operator `arr[index]`."
msgstr "为了访问数组元素，你可以使用`get()`或`at()`数组方法，它们返回不同的类型。使用`arr.at(index)`等同于使用下标操作符`arr[index]`。"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified "
"index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the "
"array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the [References and Snapshots](ch04-02-references-and-snapshots."
"md) chapter."
msgstr ""
"函数 `get` 返回一个 `Option<Box<@T>>` ，这意味着它返回一个 Box 类型（Cairo的智能指针类型）的选项，其中包含指定索引处元素的快照（如果该元素存在于数组中）。如果元素不存在，`get`返回"
"`None`。当你希望访问的索引可能不在数组的边界内，并希望优雅地处理这种情况而不引起panic时，该方法就非常有用。快照将在[引用和快照](ch04-02-references-and-snapshots.md)一章中详细解释。"

#: src/ch03-01-arrays.md:75
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the "
"index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent "
"unexpected behavior."
msgstr ""
"另一方面，`at`函数直接返回一个快照到指定索引的元素，使用`unbox()`操作符来提取存储在一个盒子里的值。如果索引超出了范围，就会抛出错误(panic)。你应该只在希望索引超出数组的边界时抛出"
"`panic`时，使用 `at`，这样可以防止意外的行为。"

#: src/ch03-01-arrays.md:77
msgid "In summary, use `at` when you want to panic on out-of-bounds access attempts, and use `get` when you prefer to handle such cases gracefully without panicking."
msgstr "总之，当你想对越界访问尝试进行恐慌时，请使用`at`，而当你想优雅地处理这种情况而不恐慌时，请使用`get`。"

#: src/ch03-01-arrays.md:79
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"\n"
"    let first = *a.at(0);\n"
"    let second = *a.at(1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"\n"
"    let first = *a.at(0);\n"
"    let second = *a.at(1);\n"
"}\n"
"```"

#: src/ch03-01-arrays.md:90
msgid ""
"In this example, the variable named `first` will get the value `0` because that\n"
"is the value at index `0` in the array. The variable named `second` will get\n"
"the value `1` from index `1` in the array."
msgstr ""
"在这个例子中，名为`first'的变量将得到`0'的值，因为那是数组中索引`0'的值。\n"
"是数组中索引为`0'的值。名为`second'的变量将得到\n"
"从数组中的索引`1`处获得数值`1'。"

#: src/ch03-01-arrays.md:94
msgid "Here is an example with the `get()` method:"
msgstr "下面是一个使用`get()`方法的例子："

#: src/ch03-01-arrays.md:96
msgid ""
"```rust\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100);\n"
"    let index_to_access =\n"
"        1; // Change this value to see different results, what would happen if the index doesn't exist?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x\n"
"                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
"        },\n"
"        Option::None => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100);\n"
"    let index_to_access =\n"
"        1; // Change this value to see different results, what would happen if the index doesn't exist?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x\n"
"                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
"        },\n"
"        Option::None => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch03-01-arrays.md:117
msgid "### Size related methods"
msgstr "### 数组大小相关的方法"

#: src/ch03-01-arrays.md:119
msgid "To determine the number of elements in an array, use the `len()` method. The return is of type `usize`."
msgstr "要确定一个数组中的元素数量，请使用`len()`方法。其返回值为`usize`类型。"

#: src/ch03-01-arrays.md:121
msgid "If you want to check if an array is empty or not, you can use the `is_empty()` method, which returns `true` if the array is empty and `false` otherwise."
msgstr "如果你想检查一个数组是否为空，你可以使用`is_empty()`方法，如果数组为空，返回`true`，否则返回`false`。"

#: src/ch03-01-arrays.md:123
msgid "### Storing multiple types with Enums"
msgstr "### 用Enums存储多种类型"

#: src/ch03-01-arrays.md:125
msgid ""
"If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail "
"in the [Enums and Pattern Matching](ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""
"如果你想在一个数组中存储不同类型的元素，你可以使用`Enum`来定义一个可以容纳多种类型的自定义数据类型。更多关于Enum的细节见 [Enums and Pattern Matching](ch06-00-enums-and-pattern-"
"matching.md) 这一章节。"

#: src/ch03-01-arrays.md:127
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"enum Data {\n"
"    Integer: u128,\n"
"    Felt: felt252,\n"
"    Tuple: (u32, u32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut messages: Array<Data> = ArrayTrait::new();\n"
"    messages.append(Data::Integer(100));\n"
"    messages.append(Data::Felt('hello world'));\n"
"    messages.append(Data::Tuple((10, 30)));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"enum Data {\n"
"    Integer: u128,\n"
"    Felt: felt252,\n"
"    Tuple: (u32, u32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut messages: Array<Data> = ArrayTrait::new();\n"
"    messages.append(Data::Integer(100));\n"
"    messages.append(Data::Felt('hello world'));\n"
"    messages.append(Data::Tuple((10, 30)));\n"
"}\n"
"```"

#: src/ch03-01-arrays.md:143
msgid "### Span"
msgstr "### Span"

#: src/ch03-01-arrays.md:145
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. "
"Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations (cf. [References "
"and Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""
"`Span`是一个结构，代表一个 \"数组 \"的快照（snapshot）。它被设计用来提供对数组元素的安全可控的访问，而不需要修改原始数组。Span对于确保数据的完整性和避免在函数间传递数组或执行只读操作"
"时的借用问题特别有用（参见[引用和快照](ch04-02-references-and-snapshots.md))"

#: src/ch03-01-arrays.md:147
msgid "All methods provided by `Array` can also be used with `Span`, with the exception of the `append()` method."
msgstr "除了 `append()`方法外，`Array`提供的其他所有方法都可以用于 `Span`。"

#: src/ch03-01-arrays.md:149
msgid "#### Turning an Array into span"
msgstr "#### 将一个数组变成span"

#: src/ch03-01-arrays.md:151
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "要创建一个 `Array`的 `Span` ，请调用`span()`方法："

#: src/ch03-01-arrays.md:153
msgid ""
"```rust\n"
"# fn main() {\n"
"#     let mut array: Array<u8> = ArrayTrait::new();\n"
"    array.span();\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# fn main() {\n"
"#     let mut array: Array<u8> = ArrayTrait::new();\n"
"    array.span();\n"
"# }\n"
"```"

#: src/ch03-02-dictionaries.md:1
msgid "## Dictionaries"
msgstr "## 字典"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The `Felt252Dict<T>` data type represents a collection of key-value pairs where each key is unique and associated with a "
"corresponding value. This type of data structure is known differently across different programming languages such as maps, hash tables, associative arrays and many others."
msgstr ""
"Cairo在其核心库中提供了一个类似字典的类型。`Felt252Dict<T>` 数据类型表示键值对的集合，其中每个键都是唯一的，并与相应的值相关联。这种类型的数据结构在不同的编程语言中有不同的名称，如映"
"射、哈希表、关联数组等。"

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a certain way for which using an `Array<T>` and indexing doesn't suffice. Cairo dictionaries also allow the "
"programmer to easily simulate the existence of mutable memory when there is none."
msgstr "`Felt252Dict<T>` 类型在你想以某种方式组织数据而使用`Array<T>`和索引不能满足要求时非常有用。Cairo字典还允许程序员在内存非可变的情况下轻松地模拟可变内存。"

#: src/ch03-02-dictionaries.md:7
msgid "### Basic Use of Dictionaries"
msgstr "### 字典的基本用法"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252` leaving only the "
"possibility to specify the value data type, represented by `T` in `Felt252Dict<T>`."
msgstr "在其他语言中, 当创建一个新的字典时, 通常需要定义键和值的数据类型。在Cairo中，键类型被限制为`felt252`，你只能指定值数据的类型，这在`Felt252Dict<T>`中用`T`表示。"

#: src/ch03-02-dictionaries.md:11
msgid "The core functionality of a `Felt252Dict<T>` is implemented in the trait `Felt252DictTrait` which includes all basic operations. Among them we can find:"
msgstr "`Felt252Dict<T>`的核心功能在trait `Felt252DictTrait`中实现，它包括所有的基本操作。在其中我们可以看到："

#: src/ch03-02-dictionaries.md:13
msgid ""
"1. `insert(felt252, T) -> ()` to write values to a dictionary instance and\n"
"2. `get(felt252) -> T` to read values from it."
msgstr ""
"1. `insert(felt252, T) -> ()`向字典实例写入值，以及\n"
"2. `get(felt252) -> T` 从字典中读取值。"

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other language. In the following example, we create a dictionary to represent a mapping between individuals and their "
"balance:"
msgstr "这些函数允许我们使用其他语言一样的方法来操作字典。在下面的示例中，我们创建一个字典来表示个体及其余额之间的映射："

#: src/ch03-02-dictionaries.md:18
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut balances: Felt252Dict<u64> = Default::default();\n"
"\n"
"    balances.insert('Alex', 100);\n"
"    balances.insert('Maria', 200);\n"
"\n"
"    let alex_balance = balances.get('Alex');\n"
"    assert(alex_balance == 100, 'Balance is not 100');\n"
"\n"
"    let maria_balance = balances.get('Maria');\n"
"    assert(maria_balance == 200, 'Balance is not 200');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut balances: Felt252Dict<u64> = Default::default();\n"
"\n"
"    balances.insert('Alex', 100);\n"
"    balances.insert('Maria', 200);\n"
"\n"
"    let alex_balance = balances.get('Alex');\n"
"    assert(alex_balance == 100, 'Balance is not 100');\n"
"\n"
"    let maria_balance = balances.get('Maria');\n"
"    assert(maria_balance == 200, 'Balance is not 200');\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:33
msgid ""
"The first thing we do is import `Felt252DictTrait` which brings to scope all the methods we need to interact with the dictionary. Next, we create a new instance of `Felt252Dict<u64>` "
"by using the `default` method of the `Default` trait and added two individuals, each one with their own balance, using the `insert` method. Finally, we checked the balance of our "
"users with the `get` method."
msgstr ""
"我们做的第一件事是导入`Felt252DictTrait`，它将我们需要与字典交互的所有方法导入到作用域。接下来，我们使用`Default`trait的`default`方法创建一个新的`Felt252Dict<u64>`实例，并使用`insert`"
"方法添加两个个体，每个个体都有自己的余额。最后，我们使用`get`方法检查了用户的余额。"

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict<T>` type represents a way to overcome "
"this obstacle. We will explain how this is implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""
"在整本书中，我们都在说Cairo的内存是不可变的，这意味着你只能向一个内存单元写入一次，但是 `Felt252Dict<T>` 类型代表了一种克服这一障碍的方法。我们将在后面的[深入Cairo的字典]"
"(#dictionaries-underneath)中解释如何实现。"

#: src/ch03-02-dictionaries.md:37
msgid "Building upon our previous example, let us show a code example where the balance of the same user changes:"
msgstr "在前面示例的基础上，让我们展示一个同一用户的余额产生变化的代码示例："

#: src/ch03-02-dictionaries.md:39
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut balances: Felt252Dict<u64> = Default::default();\n"
"\n"
"    // Insert Alex with 100 balance\n"
"    balances.insert('Alex', 100);\n"
"    // Check that Alex has indeed 100 associated with him\n"
"    let alex_balance = balances.get('Alex');\n"
"    assert(alex_balance == 100, 'Alex balance is not 100');\n"
"\n"
"    // Insert Alex again, this time with 200 balance\n"
"    balances.insert('Alex', 200);\n"
"    // Check the new balance is correct\n"
"    let alex_balance_2 = balances.get('Alex');\n"
"    assert(alex_balance_2 == 200, 'Alex balance is not 200');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut balances: Felt252Dict<u64> = Default::default();\n"
"\n"
"    // Insert Alex with 100 balance\n"
"    balances.insert('Alex', 100);\n"
"    // Check that Alex has indeed 100 associated with him\n"
"    let alex_balance = balances.get('Alex');\n"
"    assert(alex_balance == 100, 'Alex balance is not 100');\n"
"\n"
"    // Insert Alex again, this time with 200 balance\n"
"    balances.insert('Alex', 200);\n"
"    // Check the new balance is correct\n"
"    let alex_balance_2 = balances.get('Alex');\n"
"    assert(alex_balance_2 == 200, 'Alex balance is not 200');\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the _Alex_ individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! "
"`Felt252Dict<T>` effectively allows us to \"rewrite\" the stored value for any given key."
msgstr ""
"注意在这个示例中，我们是添加 _Alex_ 这个个体两次，每次都使用了不同的余额，并且每次我们检查它的余额时，它都显示出了最新的值！`Felt252Dict<T>`使得我们可以 \"重写 \"任何给定的键中所存储"
"值。"

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the scenes all keys have their "
"associated values initialized as zero. This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an error or an undefined value. "
"This also means there is no way to delete data from a dictionary. Something to take into account when incorporating this structure into your code."
msgstr ""
"在继续解释字典是如何实现的之前，值得一提的是，一旦你实例化了一个 `Felt252Dict<T>`，其所有的键值都将被初始化为0。这意味着，例如，如果你试图获取一个不存在的用户的余额，你将得到0，而不是"
"一个错误或未定义的值。这也意味着无法从字典中删除数据。在代码中使用这歌结构纳时你需要考虑到这一点。"

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` and how it mimics the same behavior as the corresponding data structures in any other language, that is, "
"externally of course. Cairo is at its core a non-deterministic Turing-complete programming language, very different from any other popular language in existence, which as a "
"consequence means that dictionaries are implemented very differently as well!"
msgstr ""
"到此为止，我们已经了解了 `Felt252Dict<T>` 的所有基本特性，以及它是如何在外部表现上模仿其他语言中相应数据结构的。Cairo的核心是一种非确定的图灵完备的编程语言，与其他任何流行的语言都有很"
"大的不同，这意味着字典的实现也有很大的不同！"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about `Felt252Dict<T>` inner mechanisms and the compromises that were taken to make them work. After that, we are going "
"to take a look at how to use dictionaries with other data structures as well as use the `entry` method as another way to interact with them."
msgstr ""
"在下面的章节中，我们将深入介绍 `Felt252Dict<T>` 的内部机制以及为使其正常工作而做出的妥协。之后，我们将介绍如何将字典与其他数据结构一起使用，以及使用`entry`方法作为与字典交互的另一种方"
"式。"

#: src/ch03-02-dictionaries.md:65
msgid "### Dictionaries Underneath"
msgstr "### 深入Cairo的字典"

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order to simulate mutability, the language implements `Felt252Dict<T>` as a "
"list of entries. Each of the entries represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three fields:"
msgstr ""
"Cairo的非确定性设计的限制之一是它的内存系统是不可变的，因此为了模拟可变性，语言将`Felt252Dict<T>`实现为一个条目(entry)列表。每个条目代表了字典被读取/更新/写入的时间。一个条目有三个字"
"段："

#: src/ch03-02-dictionaries.md:69
msgid ""
"1. A `key` field that identifies the value for this key-value pair of the dictionary.\n"
"2. A `previous_value` field that indicates which previous value was held at `key`.\n"
"3. A `new_value` field that indicates the new value that is held at `key`."
msgstr ""
"1.一个 `key`字段，用于标识字典中键值对的值。\n"
"2.一个`previous_value`字段，表示`key`所拥有的前一个值。\n"
"3.一个`new_value`字段，用于指明`key`所拥有的新值。"

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would internally define it as `Array<Entry<T>>` where each `Entry<T>` has information about what key-value pair "
"it represents and the previous and new values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"如果我们尝试使用高级结构来实现 `Felt252Dict<T>`，我们将在内部把它定义为 `Array<Entry<T>>` 其中每个 `Entry<T>` 都有关于它代表的键值对的信息，以及它持有的前一个值和新值。`Entry<T>`  的"
"定义如下："

#: src/ch03-02-dictionaries.md:75
msgid ""
"```rust,noplayground\n"
"struct Entry<T> {\n"
"    key: felt252,\n"
"    previous_value: T,\n"
"    new_value: T,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"struct Entry<T> {\n"
"    key: felt252,\n"
"    previous_value: T,\n"
"    new_value: T,\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:83
msgid "For each time we interact with a `Felt252Dict<T>` a new `Entry<T>` will be registered:"
msgstr "每次我们与`Felt252Dict<T>`交互时，都会产生一个新的`Entry<T>`并注册："

#: src/ch03-02-dictionaries.md:85
msgid ""
"- A `get` would register an entry where there is no change in state, and previous and new values are stored with the same value.\n"
"- An `insert` would register a new `Entry<T>` where the `new_value` would be the element being inserted, and the `previous_value` the last element inserted before this. In case it is "
"the first entry for a certain key, then the previous value will be zero."
msgstr ""
"- `get` 将注册一个状态没有发生变化的条目，以前的值和新值以相同的值存储。\n"
"- 一个`insert`将注册一个新的`Entry<T>`，其中`new_value`是被插入的元素，`previous_value`是在此之前插入的最后一个元素。如果这是某个键的第一个条目，那么之前的值将为0。"

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an example of this using the "
"`balances` dictionary from the previous section and inserting the users 'Alex' and 'Maria':"
msgstr "条目列表的使用展示了这里没有任何值的覆盖，只是在每次`Felt252Dict<T>`交互中创建新的存储单元。让我们使用上一节中的 `balances` 字典并插入用户 'Alex' 和 'Maria' 来展示一个例子："

#: src/ch03-02-dictionaries.md:90
msgid ""
"```rust\n"
"# struct Entry<T> {\n"
"#     key: felt252,\n"
"#     previous_value: T,\n"
"#     new_value: T,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let mut balances: Felt252Dict<u64> = Default::default();\n"
"    balances.insert('Alex', 100_u64);\n"
"    balances.insert('Maria', 50_u64);\n"
"    balances.insert('Alex', 200_u64);\n"
"    balances.get('Maria');\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# struct Entry<T> {\n"
"#     key: felt252,\n"
"#     previous_value: T,\n"
"#     new_value: T,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"#     let mut balances: Felt252Dict<u64> = Default::default();\n"
"    balances.insert('Alex', 100_u64);\n"
"    balances.insert('Maria', 50_u64);\n"
"    balances.insert('Alex', 200_u64);\n"
"    balances.get('Maria');\n"
"# }\n"
"```"

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr "这些指令将产生以下条目列表："

#: src/ch03-02-dictionaries.md:108
msgid ""
"|  key  | previous | new |\n"
"| :---: | -------- | --- |\n"
"| Alex  | 0        | 100 |\n"
"| Maria | 0        | 50  |\n"
"| Alex  | 100      | 200 |\n"
"| Maria | 50       | 50  |"
msgstr ""
"|  key  | previous | new |\n"
"| :---: | -------- | --- |\n"
"| Alex  | 0        | 100 |\n"
"| Maria | 0        | 50  |\n"
"| Alex  | 100      | 200 |\n"
"| Maria | 50       | 50  |"

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the `previous` and `current` values are set properly. Also reading from 'Maria' registered an entry with no change "
"from previous to current values."
msgstr "注意，由于'Alex'被插入了两次，所以它出现了两次，并且'previous'和'current'值被正确的设置。从'Maria'中读取的数据也是一个条目，从前值到现值没有发生变化。"

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each read/write operation, there is a scan for the whole entry list in search of the last entry with the same `key`. "
"Once the entry has been found, its `new_value` is extracted and used on the new entry to be added as the `previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in the list."
msgstr ""
"这种实现 `Felt252Dict<T>` 的方法意味着每一次读/写操作，都要扫描整个条目列表，寻找最后一个具有相同 `key`的条目。一旦条目被找到，它的`new_value`就会被提取出来，并作为`previous_value`添"
"加到新的条目中。这意味着与  `Felt252Dict<T>` 交互的最坏情况下的时间复杂度为 `O(n)`，其中 `n` 是列表中的条目数。"

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing `Felt252Dict<T>` you'd surely find them, probably even ditching completely the need for a `previous_value` field, "
"nonetheless, since Cairo is not your normal language this won't work.\n"
"One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and "
"inside the boundaries of Cairo restrictions. One of those boundary checks consists of \"dictionary squashing\" and that requires information on both previous and new values for every "
"entry."
msgstr ""
"如果你花点心思，你肯定会找到其他实现`Felt252Dict<T>`的方法，其中一些方法甚至可能完全抛弃对`previous_value`字段的需求，然而，由于Cairo不是普通的编程语言，这是不可行的。\n"
"Cairo的目的之一是通过STARK证明系统来生成计算完整性的证明。这意味着你需要验证程序的执行是否正确，是否在Cairo的限制范围内。其中一个边界检查包括 \"字典压缩\"，这需要每个条目的前值和新值"
"的信息。"

#: src/ch03-02-dictionaries.md:122
msgid "### Squashing Dictionaries"
msgstr "### 字典压缩"

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct we need to check that there wasn't any illegal tampering with the dictionary. "
"This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution."
msgstr ""
"为了验证使用`Felt252Dict<T>`的Cairo程序执行所生成的证明是否正确，我们需要检查字典是否被非法篡改。这是通过一个名为`squash_dict`的方法来完成的，这个方法会审查条目列表中的每一个条目，并"
"检查字典的访问在整个执行过程中是否保持一致。"

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key `k`, taken in the same order as they were inserted, verify that the ith entry `new_value` is equal to the "
"ith + 1 entry `previous_value`."
msgstr "压缩过程如下：给定所有具有特定键`k`的条目，按照它们被插入的相同顺序，验证第i个条目`new_value`是否等于第i+1个条目`previous_value`。"

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr "例如，给定以下条目列表："

#: src/ch03-02-dictionaries.md:130
msgid ""
"|   key   | previous | new |\n"
"| :-----: | -------- | --- |\n"
"|  Alex   | 0        | 150 |\n"
"|  Maria  | 0        | 100 |\n"
"| Charles | 0        | 70  |\n"
"|  Maria  | 100      | 250 |\n"
"|  Alex   | 150      | 40  |\n"
"|  Alex   | 40       | 300 |\n"
"|  Maria  | 250      | 190 |\n"
"|  Alex   | 300      | 90  |"
msgstr ""
"|   key   | previous | new |\n"
"| :-----: | -------- | --- |\n"
"|  Alex   | 0        | 150 |\n"
"|  Maria  | 0        | 100 |\n"
"| Charles | 0        | 70  |\n"
"|  Maria  | 100      | 250 |\n"
"|  Alex   | 150      | 40  |\n"
"|  Alex   | 40       | 300 |\n"
"|  Maria  | 250      | 190 |\n"
"|  Alex   | 300      | 90  |"

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr "压缩后，条目列表将缩减为："

#: src/ch03-02-dictionaries.md:143
msgid ""
"|   key   | previous | new |\n"
"| :-----: | -------- | --- |\n"
"|  Alex   | 0        | 90  |\n"
"|  Maria  | 0        | 190 |\n"
"| Charles | 0        | 70  |"
msgstr ""
"|   key   | previous | new |\n"
"| :-----: | -------- | --- |\n"
"|  Alex   | 0        | 90  |\n"
"|  Maria  | 0        | 190 |\n"
"| Charles | 0        | 70  |"

#: src/ch03-02-dictionaries.md:149
msgid "In case of a change on any of the values of the first table, squashing would have failed during runtime."
msgstr "如果第一张表中的任何值发生变化，则在运行期间压缩将会失败。"

#: src/ch03-02-dictionaries.md:151
msgid "### Dictionary Destruction"
msgstr "#### 字典的析构"

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of Dictionaries](#basic-use-of-dictionaries) you'd notice that there was never a call to squash dictionary, but the program compiled "
"successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call "
"occurred just before the `balance` dictionary went out of scope."
msgstr ""
"如果你运行[字典的基本用法](#basic-use-of-dictionaries)中的示例，你会发现那些例子从来没有调用过字典压缩，但程序还是编译成功了。这是因为在背后，squash通过`Destruct<T>` trait的"
"`Felt252Dict<T>`实现了被自动调用。这个调用发生在`balance`字典离开作用域之前。"

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main difference between these two is that `Drop<T>` is treated as a no-op "
"operation, meaning it does not generate new CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, "
"for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-destruct)."
msgstr ""
"除 `Drop<T>` 之外，`Destruct<T>` trait代表了另一种将实例移出作用域的方法。这两者之间的主要区别在于 `Drop<T>` 被视为一个 no-op 操作，这意味着它不会产生新的 CASM，而 `Destruct<T>` 没有"
"这个限制。唯一主动使用`Destruct<T>`特性的类型是`Felt252Dict<T>`，对于其他类型`Destruct<T>`和`Drop<T>`是同义词。你可以在[Drop and Destruct](/appendix-03-derivable-traits.md#drop and-"
"destruct)中阅读更多关于这些trait的信息。"

#: src/ch03-02-dictionaries.md:157
msgid "Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), we will have a hands-on example where we implement the `Destruct<T>` trait for a custom type."
msgstr "在 [Dictionaries as Struct Members](#dictionaries-as-struct-members)后面，我们将有一个实践示例，我们将为自定义类型实现 `Destruct<T>` trait。"

#: src/ch03-02-dictionaries.md:159
msgid "### More Dictionaries"
msgstr "### 更多字典范例"

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the functionality of `Felt252Dict<T>` as well as how and why it is implemented in a certain way. If you haven't understood "
"all of it, don't worry because in this section we will have some more examples using dictionaries."
msgstr "到此为止，我们已经全面地介绍了`Felt252Dict<T>`的功能，以及它是如何和为什么以某种方式实现的。如果您还没有完全理解，请不要担心，因为在本节中我们将提供更多使用字典的示例。"

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait<T>` which we didn't mention at the beginning. Soon "
"after, we will see examples of how `Felt252Dict<T>` [interacts](#dictionaries-of-complex-types) with other complex types such as `Array<T>` and how to [implement](#dictionaries-as-"
"struct-members) a struct with a dictionary as a member."
msgstr ""
"我们将首先解释`entry`方法，它是`Felt252DictTrait<T>`中包含的字典基本功能的一部分，我们在开始时没有提到。很快，我们将看到`Felt252Dict<T>`如何与其他复杂类型如`Array<T>`[交互]"
"(#dictionaries-of-complex-types)的例子，以及如何[实现](#dictionaries-as-struct-members)一个以字典为成员的结构体。"

#: src/ch03-02-dictionaries.md:165
msgid "### Entry and Finalize"
msgstr "### 条目(Entry)和最终确定(Finalize)"

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we explained how `Felt252Dict<T>` internally worked. It was a list of entries for each time the dictionary was "
"accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us "
"the tools to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""
"在 [Dictionaries Underneath](#dictionaries-underneath) 部分，我们解释了 `Felt252Dict<T>` 内部是如何工作的。它是每次以任何方式访问字典时的条目列表。它会首先找到给定`key`的最后一个条"
"目，然后根据执行的操作更新它。Cairo语言通过`entry`和`finalize`方法为我们提供了复制这种方式的工具。"

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose of creating a new entry given a certain key. Once called, this method takes ownership of the dictionary and "
"returns the entry to update. The method signature is as follows:"
msgstr "`entry` 方法作为`Felt252DictTrait<T>` 的一部分，目的是在给定键的情况下创建一个新的条目。一旦被调用，该方法将获得字典的所有权并返回要更新的条目。方法签名如下:"

#: src/ch03-02-dictionaries.md:171
msgid ""
"```rust,noplayground\n"
"fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic\n"
"```"

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which "
"is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously."
msgstr "第一个输入参数获得字典的所有权，第二个参数用于创建相应的条目。它返回一个元组，包含一个`Felt252DictEntry<T>`，这是Cairo用来表示字典条目的类型，和一个`T`，代表之前持有的值。"

#: src/ch03-02-dictionaries.md:177
msgid "The next thing to do is to update the entry with the new value. For this, we use the `finalize` method which inserts the entry and returns ownership of the dictionary:"
msgstr "接下来要做的是用新值更新条目。为此，我们使用`finalize`方法插入条目并返回字典的所有权："

#: src/ch03-02-dictionaries.md:179
msgid ""
"```rust,noplayground\n"
"fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T> {\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T> {\n"
"```"

#: src/ch03-02-dictionaries.md:183
msgid "This method receives the entry and the new value as a parameter and returns the updated dictionary."
msgstr "该方法接收条目和新值作为参数，并返回更新后的字典。"

#: src/ch03-02-dictionaries.md:185
msgid "Let us see an example using `entry` and `finalize`. Imagine we would like to implement our own version of the `get` method from a dictionary. We should then do the following:"
msgstr "让我们看一个使用`entry`和`finalize`的例子。想象一下，我们想从字典中实现我们自己版本的`get`方法。我们应该这样做："

#: src/ch03-02-dictionaries.md:187
msgid ""
"1. Create the new entry to add using the `entry` method\n"
"2. Insert back the entry where the `new_value` equals the `previous_value`.\n"
"3. Return the value."
msgstr ""
"1.使用`entry`方法创建要添加的新条目\n"
"2.插入`new_value`等于`previous_value`的条目。\n"
"3.返回值。"

#: src/ch03-02-dictionaries.md:191
msgid "Implementing our custom get would look like this:"
msgstr "实现我们的自定义get将如下所示："

#: src/ch03-02-dictionaries.md:193
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(\n"
"    ref dict: Felt252Dict<T>, key: felt252\n"
") -> T {\n"
"    // Get the new entry and the previous value held at `key`\n"
"    let (entry, prev_value) = dict.entry(key);\n"
"\n"
"    // Store the value to return\n"
"    let return_value = prev_value;\n"
"\n"
"    // Update the entry with `prev_value` and get back ownership of the dictionary\n"
"    dict = entry.finalize(prev_value);\n"
"\n"
"    // Return the read value\n"
"    return_value\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(\n"
"    ref dict: Felt252Dict<T>, key: felt252\n"
") -> T {\n"
"    // Get the new entry and the previous value held at `key`\n"
"    let (entry, prev_value) = dict.entry(key);\n"
"\n"
"    // Store the value to return\n"
"    let return_value = prev_value;\n"
"\n"
"    // Update the entry with `prev_value` and get back ownership of the dictionary\n"
"    dict = entry.finalize(prev_value);\n"
"\n"
"    // Return the read value\n"
"    return_value\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:213
msgid "Implementing the `insert` method would follow a similar workflow, except for inserting a new value when finalizing. If we were to implement it, it would look like the following:"
msgstr "实现`insert`方法将遵循类似的工作流程，除了在最终确定时插入一个新值。如果我们要实现它，它将看起来像下面这样："

#: src/ch03-02-dictionaries.md:215
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_insert<\n"
"    T,\n"
"    impl TDefault: Felt252DictValue<T>,\n"
"    impl TDestruct: Destruct<T>,\n"
"    impl TPrint: PrintTrait<T>,\n"
"    impl TDrop: Drop<T>\n"
">(\n"
"    ref dict: Felt252Dict<T>, key: felt252, value: T\n"
") {\n"
"    // Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exists, _prev_value will\n"
"    // be the default value of T.\n"
"    let (entry, _prev_value) = dict.entry(key);\n"
"\n"
"    // Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
"    dict = entry.finalize(value);\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_insert<\n"
"    T,\n"
"    impl TDefault: Felt252DictValue<T>,\n"
"    impl TDestruct: Destruct<T>,\n"
"    impl TPrint: PrintTrait<T>,\n"
"    impl TDrop: Drop<T>\n"
">(\n"
"    ref dict: Felt252Dict<T>, key: felt252, value: T\n"
") {\n"
"    // Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exists, _prev_value will\n"
"    // be the default value of T.\n"
"    let (entry, _prev_value) = dict.entry(key);\n"
"\n"
"    // Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
"    dict = entry.finalize(value);\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:238
msgid "As a finalizing note, these two methods are implemented in a similar way to how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows some example usage:"
msgstr "最后要说明的是，这两个方法的实现方式类似于`Felt252Dict<T>`的`insert`和`get`的实现方式。这段代码展示了一些使用示例："

#: src/ch03-02-dictionaries.md:240
msgid ""
"```rust\n"
"# use dict::Felt252DictEntryTrait;\n"
"# \n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(\n"
"#     ref dict: Felt252Dict<T>, key: felt252\n"
"# ) -> T {\n"
"#     // Get the new entry and the previous value held at `key`\n"
"#     let (entry, prev_value) = dict.entry(key);\n"
"# \n"
"#     // Store the value to return\n"
"#     let return_value = prev_value;\n"
"# \n"
"#     // Update the entry with `prev_value` and get back ownership of the dictionary\n"
"#     dict = entry.finalize(prev_value);\n"
"# \n"
"#     // Return the read value\n"
"#     return_value\n"
"# }\n"
"# \n"
"# fn custom_insert<\n"
"#     T,\n"
"#     impl TDefault: Felt252DictValue<T>,\n"
"#     impl TDestruct: Destruct<T>,\n"
"#     impl TPrint: PrintTrait<T>,\n"
"#     impl TDrop: Drop<T>\n"
"# >(\n"
"#     ref dict: Felt252Dict<T>, key: felt252, value: T\n"
"# ) {\n"
"#     // Get the last entry associated with `key`\n"
"#     // Notice that if `key` does not exists, _prev_value will\n"
"#     // be the default value of T.\n"
"#     let (entry, _prev_value) = dict.entry(key);\n"
"# \n"
"#     // Insert `entry` back in the dictionary with the updated value,\n"
"#     // and receive ownership of the dictionary\n"
"#     dict = entry.finalize(value);\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut dict: Felt252Dict<u64> = Default::default();\n"
"\n"
"    custom_insert(ref dict, '0', 100);\n"
"\n"
"    let val = custom_get(ref dict, '0');\n"
"\n"
"    assert(val == 100, 'Expecting 100');\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use dict::Felt252DictEntryTrait;\n"
"# \n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(\n"
"#     ref dict: Felt252Dict<T>, key: felt252\n"
"# ) -> T {\n"
"#     // Get the new entry and the previous value held at `key`\n"
"#     let (entry, prev_value) = dict.entry(key);\n"
"# \n"
"#     // Store the value to return\n"
"#     let return_value = prev_value;\n"
"# \n"
"#     // Update the entry with `prev_value` and get back ownership of the dictionary\n"
"#     dict = entry.finalize(prev_value);\n"
"# \n"
"#     // Return the read value\n"
"#     return_value\n"
"# }\n"
"# \n"
"# fn custom_insert<\n"
"#     T,\n"
"#     impl TDefault: Felt252DictValue<T>,\n"
"#     impl TDestruct: Destruct<T>,\n"
"#     impl TPrint: PrintTrait<T>,\n"
"#     impl TDrop: Drop<T>\n"
"# >(\n"
"#     ref dict: Felt252Dict<T>, key: felt252, value: T\n"
"# ) {\n"
"#     // Get the last entry associated with `key`\n"
"#     // Notice that if `key` does not exists, _prev_value will\n"
"#     // be the default value of T.\n"
"#     let (entry, _prev_value) = dict.entry(key);\n"
"# \n"
"#     // Insert `entry` back in the dictionary with the updated value,\n"
"#     // and receive ownership of the dictionary\n"
"#     dict = entry.finalize(value);\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut dict: Felt252Dict<u64> = Default::default();\n"
"\n"
"    custom_insert(ref dict, '0', 100);\n"
"\n"
"    let val = custom_get(ref dict, '0');\n"
"\n"
"    assert(val == 100, 'Expecting 100');\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch03-02-dictionaries.md:293
msgid "### Dictionaries of types not supported natively"
msgstr "### 非远胜支持类型的字典"

#: src/ch03-02-dictionaries.md:295
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`.\n"
"This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary.\n"
"This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` - but it is not implemented for more complex ones types such as arrays, structs "
"(including `u256`), and other types from the core library.\n"
"This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make "
"the data type a valid dictionary value type.\n"
"To compensate this, you can wrap your type inside a `Nullable<T>`."
msgstr ""
"`Felt252Dict<T>`的一个限制我们还没有讨论过，那就是 `Felt252DictValue<T>` trait。\n"
"该trait定义了 `zero_default` 方法，当字典中不存在某个值时，就会调用该方法。\n"
"一些常见的数据类型（如大多数无符号整数、`bool` 和 `felt252`）实现了该方法，但更复杂的数据类型，如数组、结构体（包括 `u256`）和核心库中的其他类型，则没有实现该方法。\n"
"这就意味着，将不受原生支持的类型封装成字典并不是一件简单的事情，因为您需要编写一些trait的实现，才能使这些数据类型成为有效的字典值类型。\n"
"为了弥补这一不足，您可以将您的类型封装在 `Nullable<T>`中。"

#: src/ch03-02-dictionaries.md:301
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It is usually used in Object Oriented Programming Languages when a "
"reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a pointer that can only be manipulated in one place at a time."
msgstr ""
"`Nullable<T>` 是一种智能指针类型，既可以指向一个值，也可以在没有值的情况下为 `null`。当引用不指向任何地方时，它通常用于面向对象编程语言。与 `Option` 不同的是，封装的值存储在 `Box<T>` "
"数据类型中。受 Rust 的启发，`Box<T>` 类型允许我们为我们的类型分配一个新的内存段，并使用一个指针访问该内存段，该指针一次只能在一个地方操作。"

#: src/ch03-02-dictionaries.md:303
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are storing a `Span<T>` and not an "
"`Array<T>` because the latter does not implement the `Copy<T>` trait which is required for reading from a dictionary."
msgstr ""
"让我们来举例说明。我们将尝试在字典中存储一个`Span<felt252>`。为此，我们将使用 `Nullable<T>` 和 `Box<T>`。另外，我们要存储的是一个 `Span<T>` 而不是一个 `Array<T>` ，因为后者没有实现 "
"`Copy<T>` 特性，而从字典中读取数据是需要这个特性的。"

#: src/ch03-02-dictionaries.md:305
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"//...\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"//...\n"
"```"

#: src/ch03-02-dictionaries.md:325
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary `d`. We want it to hold a `Nullable<Span>`. After that, we created an array and filled it with values."
msgstr "在这段代码中，我们首先创建了一个新的字典`d`。我们希望它保存一个`Nullable<Span>`。然后，我们创建了一个数组，并在其中填入值。"

#: src/ch03-02-dictionaries.md:327
msgid "The last step is inserting the array as a span inside the dictionary. Notice that we didn't do that directly, but instead, we took some steps in between:"
msgstr "最后一步是在字典中插入数组。请注意，我们并没有直接这样做，而是在中间采取了一些步骤："

#: src/ch03-02-dictionaries.md:329
msgid ""
"1. We wrapped the array inside a `Box` using the `new` method from `BoxTrait`.\n"
"2. We wrapped the `Box` inside a nullable using the `nullable_from_box` function.\n"
"3. Finally, we inserted the result."
msgstr ""
"1.我们使用`BoxTrait`中的`new`方法将数组封装在`Box`中。\n"
"2.我们使用`nullable_from_box`函数将`Box`封装在nullable中。\n"
"3.最后，我们插入了上面的结果。"

#: src/ch03-02-dictionaries.md:333
msgid "Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. The following code shows how to achieve that:"
msgstr "一旦元素存在字典中，并且我们想获取它，我们将遵循相同的步骤，但顺序相反。下面的代码展示了如何实现这一点："

#: src/ch03-02-dictionaries.md:335
msgid ""
"```rust,noplayground\n"
"//...\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"//...\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:354
msgid "Here we:"
msgstr "我们在这里："

#: src/ch03-02-dictionaries.md:356
msgid ""
"1. Read the value using `get`.\n"
"2. Verified it is non-null using the `match_nullable` function.\n"
"3. Unwrapped the value inside the box and asserted it was correct."
msgstr ""
"1.使用`get`读取值。\n"
"2.使用`match_nullable`函数验证其为非空值。\n"
"3.解压缩Box内的值，并断言它是正确的。"

#: src/ch03-02-dictionaries.md:360
msgid "The complete script would look like this:"
msgstr "完整的脚本如下："

#: src/ch03-02-dictionaries.md:362
msgid ""
"```rust\n"
"\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"\n"
"```"

#: src/ch03-02-dictionaries.md:397
msgid "### Dictionaries as Struct Members"
msgstr "### 作为结构体成员的字典"

#: src/ch03-02-dictionaries.md:399
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly interacting with them may not be entirely seamless. Let's try implementing a custom _user database_ that "
"will allow us to add users and query them. We will need to define a struct to represent the new type and a trait to define its functionality:"
msgstr ""
"在Cairo中可将字典定义为结构体成员，但正确地与它们交互可能不是完全无障碍的。让我们尝试实现一个自定义的_user数据库，它将允许我们添加用户并查询他们。我们需要定义一个struct来表示新的类"
"型，并定义一个trait来定义其功能："

#: src/ch03-02-dictionaries.md:401
msgid ""
"```rust,noplayground\n"
"struct UserDatabase<T> {\n"
"    users_amount: u64,\n"
"    balances: Felt252Dict<T>,\n"
"}\n"
"\n"
"trait UserDatabaseTrait<T> {\n"
"    fn new() -> UserDatabase<T>;\n"
"    fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);\n"
"    fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"struct UserDatabase<T> {\n"
"    users_amount: u64,\n"
"    balances: Felt252Dict<T>,\n"
"}\n"
"\n"
"trait UserDatabaseTrait<T> {\n"
"    fn new() -> UserDatabase<T>;\n"
"    fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);\n"
"    fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:414
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic over the balances of the users, giving major flexibility to whoever uses our data type. Its two members "
"are:"
msgstr "我们的新类型`UserDatabase<T>`表示用户数据库。它用泛型表示用户的余额，给使用我们的数据类型的人提���了很大的灵活性。它的两个成员是："

#: src/ch03-02-dictionaries.md:416
msgid ""
"- `users_amount`, the number of users currently inserted and\n"
"- `balances`, a mapping of each user to its balance."
msgstr ""
"- `users_amount`，当前插入的用户数量。\n"
"- `balances`，每个用户与其余额的映射。"

#: src/ch03-02-dictionaries.md:419
msgid "The database core functionality is defined by `UserDatabaseTrait`. The following methods are defined:"
msgstr "数据库核心功能由`UserDatabaseTrait`定义。定义了以下方法："

#: src/ch03-02-dictionaries.md:421
msgid ""
"- `new` for easily creating new `UserDatabase` types.\n"
"- `add_user` to insert users in the database.\n"
"- `get_balance` to find user's balance in the database."
msgstr ""
"- `new`用于方便创建新的`UserDatabase`类型。\n"
"- `add_user`用于在数据库中插入用户。\n"
"- `get_balance`用于在数据库中查找用户的余额。"

#: src/ch03-02-dictionaries.md:425
msgid ""
"The only remaining step is to implement each of the methods in `UserDatabaseTrait`, but since we are working with [generic types](/src/ch08-00-generic-types-and-traits.md) we also "
"need to correctly establish the requirements of `T` so it can be a valid `Felt252Dict<T>` value type:"
msgstr ""
"剩下的步骤就是实现`UserDatabaseTrait`中的每一个方法，但是由于我们使用的是[泛型](/src/ch08-00-generic-types-and-traits.md)，我们还需要正确地建立`T`的要求，这样它才能成为一个有效的"
"`Felt252Dict<T>`值类型："

#: src/ch03-02-dictionaries.md:427
msgid ""
"1. `T` should implement the `Copy<T>` since it's required for getting values from a `Felt252Dict<T>`.\n"
"2. All value types of a dictionary implement the `Felt252DictValue<T>`, our generic type should do as well.\n"
"3. To insert values, `Felt252DictTrait<T>` requires all value types to be destructible."
msgstr ""
"1.`T` 应该实现 `Copy<T>`，因为从 `Felt252Dict<T>` 获取值需要它。\n"
"2.所有字典的值类型都实现了 `Felt252DictValue<T>`，我们的泛型也应该实现。\n"
"3.为了插入值，`Felt252DictTrait<T>`要求所有的值类型都是可析构的。"

#: src/ch03-02-dictionaries.md:431
msgid "The implementation, with all restriction in place, would be as follow:"
msgstr "在所有限制条件均已实现的情况下，执行情况如下："

#: src/ch03-02-dictionaries.md:433
msgid ""
"```rust,noplayground\n"
"\n"
"\n"
"impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of UserDatabaseTrait<T> {\n"
"    // Creates a database\n"
"    fn new() -> UserDatabase<T> {\n"
"        UserDatabase { users_amount: 0, balances: Default::default() }\n"
"    }\n"
"\n"
"    // Get the user's balance\n"
"    fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {\n"
"        self.balances.get(name)\n"
"    }\n"
"\n"
"    // Add a user\n"
"    fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {\n"
"        self.balances.insert(name, balance);\n"
"        self.users_amount += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"\n"
"\n"
"impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of UserDatabaseTrait<T> {\n"
"    // Creates a database\n"
"    fn new() -> UserDatabase<T> {\n"
"        UserDatabase { users_amount: 0, balances: Default::default() }\n"
"    }\n"
"\n"
"    // Get the user's balance\n"
"    fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {\n"
"        self.balances.get(name)\n"
"    }\n"
"\n"
"    // Add a user\n"
"    fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {\n"
"        self.balances.insert(name, balance);\n"
"        self.users_amount += 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:455
msgid ""
"Our database implementation is almost complete, except for one thing: the compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since it doesn't implement the "
"`Drop<T>` trait, nor the `Destruct<T>` trait.\n"
"Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are forced to implement the `Destruct<T>` trait manually (refer to the [Ownership](ch04-01-what-is-ownership."
"md#the-drop-trait) chapter for more information).\n"
"Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` definition won't work because of the use of [genericity](/src/ch08-00-generic-types-and-traits.md) in the struct "
"definition. We need to code the `Destruct<T>` trait implementation by ourselves:"
msgstr ""
"我们的数据库实现几乎已经完成，除了一点：编译器不知道如何让 `UserDatabase<T>` 脱离作用域，因为它没有实现 `Drop<T>` 特性，也没有实现 `Destruct<T>` 特性。\n"
"由于它有一个 `Felt252Dict<T>` 作为成员，它不能被丢弃，所以我们不得不手动实现 `Destruct<T>` 特性（更多信息请参阅 [所有权](ch04-01-what-is-ownership.md#the-drop-trait) 章节）。\n"
"在 `UserDatabase<T>` 定义之上使用 `#[derive(Destruct)]`是行不通的，因为在 struct 定义中使用了 [泛型](/src/ch08-00-generic-types-and-traits.md) 。我们需要自己编写实现 `Destruct<T>` "
"trait的代码："

#: src/ch03-02-dictionaries.md:459
msgid ""
"```rust,noplayground\n"
"impl UserDatabaseDestruct<\n"
"    T, impl TDrop: Drop<T>, impl TDefault: Felt252DictValue<T>\n"
"> of Destruct<UserDatabase<T>> {\n"
"    fn destruct(self: UserDatabase<T>) nopanic {\n"
"        self.balances.squash();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"impl UserDatabaseDestruct<\n"
"    T, impl TDrop: Drop<T>, impl TDefault: Felt252DictValue<T>\n"
"> of Destruct<UserDatabase<T>> {\n"
"    fn destruct(self: UserDatabase<T>) nopanic {\n"
"        self.balances.squash();\n"
"    }\n"
"}\n"
"```"

#: src/ch03-02-dictionaries.md:469
msgid "Implementing `Destruct<T>` for `UserDatabase` was our last step to get a fully functional database. We can now try it out:"
msgstr "为`UserDatabase`实现`Destruct<T>`是我们得到一个功能齐全的数据库的最后一步。现在我们可以试试了："

#: src/ch03-02-dictionaries.md:471
msgid ""
"```rust\n"
"# struct UserDatabase<T> {\n"
"#     users_amount: u64,\n"
"#     balances: Felt252Dict<T>,\n"
"# }\n"
"# \n"
"# trait UserDatabaseTrait<T> {\n"
"#     fn new() -> UserDatabase<T>;\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;\n"
"# }\n"
"# \n"
"# impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of UserDatabaseTrait<T> {\n"
"#     // Creates a database\n"
"#     fn new() -> UserDatabase<T> {\n"
"#         UserDatabase { users_amount: 0, balances: Default::default() }\n"
"#     }\n"
"# \n"
"#     // Get the user's balance\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {\n"
"#         self.balances.get(name)\n"
"#     }\n"
"# \n"
"#     // Add a user\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {\n"
"#         self.balances.insert(name, balance);\n"
"#         self.users_amount += 1;\n"
"#     }\n"
"# }\n"
"# \n"
"# impl UserDatabaseDestruct<\n"
"#     T, impl TDrop: Drop<T>, impl TDefault: Felt252DictValue<T>\n"
"# > of Destruct<UserDatabase<T>> {\n"
"#     fn destruct(self: UserDatabase<T>) nopanic {\n"
"#         self.balances.squash();\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut db = UserDatabaseTrait::new();\n"
"\n"
"    db.add_user('Alex', 100);\n"
"    db.add_user('Maria', 80);\n"
"\n"
"    db.add_user('Alex', 40);\n"
"    db.add_user('Maria', 0);\n"
"\n"
"    let alex_latest_balance = db.get_balance('Alex');\n"
"    let maria_latest_balance = db.get_balance('Maria');\n"
"\n"
"    assert(alex_latest_balance == 40, 'Expected 40');\n"
"    assert(maria_latest_balance == 0, 'Expected 0');\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# struct UserDatabase<T> {\n"
"#     users_amount: u64,\n"
"#     balances: Felt252Dict<T>,\n"
"# }\n"
"# \n"
"# trait UserDatabaseTrait<T> {\n"
"#     fn new() -> UserDatabase<T>;\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;\n"
"# }\n"
"# \n"
"# impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of UserDatabaseTrait<T> {\n"
"#     // Creates a database\n"
"#     fn new() -> UserDatabase<T> {\n"
"#         UserDatabase { users_amount: 0, balances: Default::default() }\n"
"#     }\n"
"# \n"
"#     // Get the user's balance\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {\n"
"#         self.balances.get(name)\n"
"#     }\n"
"# \n"
"#     // Add a user\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {\n"
"#         self.balances.insert(name, balance);\n"
"#         self.users_amount += 1;\n"
"#     }\n"
"# }\n"
"# \n"
"# impl UserDatabaseDestruct<\n"
"#     T, impl TDrop: Drop<T>, impl TDefault: Felt252DictValue<T>\n"
"# > of Destruct<UserDatabase<T>> {\n"
"#     fn destruct(self: UserDatabase<T>) nopanic {\n"
"#         self.balances.squash();\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut db = UserDatabaseTrait::new();\n"
"\n"
"    db.add_user('Alex', 100);\n"
"    db.add_user('Maria', 80);\n"
"\n"
"    db.add_user('Alex', 40);\n"
"    db.add_user('Maria', 0);\n"
"\n"
"    let alex_latest_balance = db.get_balance('Alex');\n"
"    let maria_latest_balance = db.get_balance('Maria');\n"
"\n"
"    assert(alex_latest_balance == 40, 'Expected 40');\n"
"    assert(maria_latest_balance == 0, 'Expected 0');\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch03-02-dictionaries.md:530
msgid "Well done! You finished this chapter on arrays and dictionaries in Cairo. These data structures may be a bit challenging to grasp, but they are really useful."
msgstr "干得好！你已经完成了Cairo中关于数组和字典的章节。要掌握这些数据结构可能有点难度，但它们确实非常有用。"

#: src/ch03-02-dictionaries.md:532
msgid "When you’re ready to move on, we’ll talk about a concept that Cairo shares with Rust and that _doesn’t_ commonly exist in other programming languages: ownership."
msgstr "当你准备好继续前进时，我们将讨论一个Cairo与Rust共有，而在其他编程语言中通常 _不存在_ 的概念：所有权。"

#: src/ch03-03-custom-data-structures.md:1
msgid "# Custom Data Structures"
msgstr "# 自定义数据结构"

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays\n"
"(`Array<T>`) to store collections of data. However, you will quickly realize\n"
"that arrays have one big limitation - the data stored in them is immutable. Once\n"
"you append a value to an array, you can't modify it."
msgstr ""
"当你第一次在开罗开始编程时，你可能想要使用数组（'Array<T>'） 来存储数据集合。但是，您很快就会意识到\n"
"数组有一个很大的限制 - 存储在其中的数据是不可变的。一旦将值附加到数组中，则无法对其进行修改。"

#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For\n"
"example, say you're making a game where the players have a level, and they can\n"
"level up. You might try to store the level of the players in an array:"
msgstr ""
"当您想要使用可变数据结构时，这可能会令人沮丧。\n"
"例如，假设你正在制作一个游戏，玩家有一个等级属性，他们可以升级。\n"
"您可以尝试将玩家的等级存储在数组中："

#: src/ch03-03-custom-data-structures.md:12
msgid ""
"```rust,noplayground\n"
"let mut level_players = Array::new();\n"
"level_players.append(5);\n"
"level_players.append(1);\n"
"level_players.append(10);\n"
"```"
msgstr ""
"```rust,noplayground\n"
"let mut level_players = Array::new();\n"
"level_players.append(5);\n"
"level_players.append(1);\n"
"level_players.append(10);\n"
"```"

#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once it's\n"
"set. If a player dies, you cannot remove it from the array unless he happens to\n"
"be in the first position."
msgstr ""
"但是接下来你会发觉，一旦给某个特定的索引中玩家设置了等级，它的等级就无法再次提升。\n"
"如果玩家死亡，你也无法将它移出数组，除非他碰巧排在第一位。"

#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary\n"
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to\n"
"simulate the behavior of mutable data structures. Let's first explore how to use\n"
"it to create a dynamic array implementation."
msgstr ""
"幸运的是，Cairo 提供了一个方便的内置 [字典类型]（./ch03-02-dictionaries.md） 称为 `Felt252Dict<T>`，\n"
"允许我们模拟可变数据结构的行为。我们先来探讨一下如何使用它来创建一个动态数组实现。"

#: src/ch03-03-custom-data-structures.md:28
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of the\n"
"book. We recommend you to check out the following chapter first:\n"
"[Structs](ch05-00-using-structs-to-structure-related-data),\n"
"[Methods](./ch05-03-method-syntax.md), [Generic\n"
"types](./ch08-00-generic-types-and-traits.md),\n"
"[Traits](./ch08-02-traits-in-cairo.md)"
msgstr ""
"注意：本章中使用的几个概念将在后面几个章节里详细解释。\n"
"我们建议您先查看以下章节：\n"
"[结构体]（./ch05-00-using-structs-to-structure-related-data），\n"
"[方法]（./ch05-03-method-syntax.md）、\n"
"[泛型]（./ch08-00-generic-types-and-traits.md），\n"
"[Traits]（./ch08-02-traits-in-cairo.md）"

#: src/ch03-03-custom-data-structures.md:35
msgid "## Simulating a dynamic array with dicts"
msgstr "## 使用字典模拟动态数组"

#: src/ch03-03-custom-data-structures.md:37
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. What\n"
"operations should it support?"
msgstr "首先，让我们考虑一下我们希望可变动态数组的行为方式。它需要支持哪些操作？"

#: src/ch03-03-custom-data-structures.md:40
msgid "It should:"
msgstr "它应该："

#: src/ch03-03-custom-data-structures.md:42
msgid ""
"- Allow us to append items at the end\n"
"- Let us access any item by index\n"
"- Allow setting the value of an item at a specific index\n"
"- Return the current length"
msgstr ""
"- 允许我们在末尾附加项\n"
"- 让我们按索引访问任何项\n"
"- 允许在特定索引处设置项的值\n"
"- 返回当前长度"

#: src/ch03-03-custom-data-structures.md:47
msgid "We can define this interface in Cairo like:"
msgstr "我们可以在Cairo中定义这个接口，如下所示："

#: src/ch03-03-custom-data-structures.md:49
msgid ""
"```rust\n"
"trait VecTrait<V, T> {\n"
"    fn new() -> V;\n"
"    fn get(ref self: V, index: usize) -> Option<T>;\n"
"    fn at(ref self: V, index: usize) -> T;\n"
"    fn push(ref self: V, value: T) -> ();\n"
"    fn set(ref self: V, index: usize, value: T);\n"
"    fn len(self: @V) -> usize;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait VecTrait<V, T> {\n"
"    fn new() -> V;\n"
"    fn get(ref self: V, index: usize) -> Option<T>;\n"
"    fn at(ref self: V, index: usize) -> T;\n"
"    fn push(ref self: V, value: T) -> ();\n"
"    fn set(ref self: V, index: usize, value: T);\n"
"    fn len(self: @V) -> usize;\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:60
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We named\n"
"it Vec as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"这为我们的动态数组的实现提供了蓝图。\n"
"我们命名它为Vec，因为它类似于 Rust 中的`Vec<T>` 数据结构。"

#: src/ch03-03-custom-data-structures.md:63
msgid "### Implementing a dynamic array in Cairo"
msgstr "## 在Cairo中实现���态数组"

#: src/ch03-03-custom-data-structures.md:65
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers (felts)\n"
"to values. We'll also store a separate `len` field to track the length."
msgstr ""
"为了存储我们的数据，我们将使用`Felt252Dict<T>` 来映射索引号（felt）到值。\n"
"我们还将存储一个单独的`len`字段来跟踪长度。"

#: src/ch03-03-custom-data-structures.md:68
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable`\n"
"pointer to allow using any type `T` in our data structure, as explained in the\n"
"[Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively)\n"
"section:"
msgstr ""
"下面是我们的结构体的样子。我们将类型`T`包装在`Nullable`指针中，这使得在我们的数据结构中可以使用任何类型的 `T` ，\n"
"如[词典](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) ："

#: src/ch03-03-custom-data-structures.md:73
msgid ""
"```rust\n"
"struct NullableVec<T> {\n"
"    data: Felt252Dict<Nullable<T>>,\n"
"    len: usize\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct NullableVec<T> {\n"
"    data: Felt252Dict<Nullable<T>>,\n"
"    len: usize\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:80
msgid ""
"The key thing that makes this vector mutable is that we can insert values into\n"
"the dictionary to set or update values in our data structure. For example, to\n"
"update a value at a specific index, we do:"
msgstr ""
"使这个向量可变的关键是我们可以将值插入到用于在数据结构中设置或更新值的字典。\n"
"例如，要更新特定索引处的值，我们执行以下操作："

#: src/ch03-03-custom-data-structures.md:84
msgid ""
"```rust,noplayground\n"
"    fn set(ref self: NullableVec<T>, index: usize, value: T) {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.insert(index.into(), nullable_from_box(BoxTrait::new(value)));\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    fn set(ref self: NullableVec<T>, index: usize, value: T) {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.insert(index.into(), nullable_from_box(BoxTrait::new(value)));\n"
"    }\n"
"```"

#: src/ch03-03-custom-data-structures.md:91
msgid "This overwrites the previously existing value at that index in the dictionary."
msgstr "这将覆盖字典中该索引处先前存在的值。"

#: src/ch03-03-custom-data-structures.md:93
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for\n"
"modifiable data structures like vectors."
msgstr "虽然数组是不可变的，但字典提供了我们的可修改的数据结构（如向量）所需要的灵活性。"

#: src/ch03-03-custom-data-structures.md:96
msgid ""
"The implementation of the rest of the interface is straightforward. The\n"
"implementation of all the methods defined in our interface can be done as follow\n"
":"
msgstr ""
"接口其余部分的实现非常简单。\n"
"在我们的接口中定义的所有方法的实现可以按如下方式完成:"

#: src/ch03-03-custom-data-structures.md:100
msgid ""
"```rust\n"
"impl NullableVecImpl<T, impl TDrop: Drop<T>, impl TCopy: Copy<T>> of VecTrait<NullableVec<T>, T> {\n"
"    fn new() -> NullableVec<T> {\n"
"        NullableVec { data: Default::default(), len: 0 }\n"
"    }\n"
"\n"
"    fn get(ref self: NullableVec<T>, index: usize) -> Option<T> {\n"
"        if index < self.len() {\n"
"            Option::Some(self.data.get(index.into()).deref())\n"
"        } else {\n"
"            Option::None\n"
"        }\n"
"    }\n"
"\n"
"    fn at(ref self: NullableVec<T>, index: usize) -> T {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.get(index.into()).deref()\n"
"    }\n"
"\n"
"    fn push(ref self: NullableVec<T>, value: T) -> () {\n"
"        self.data.insert(self.len.into(), nullable_from_box(BoxTrait::new(value)));\n"
"        self.len = integer::u32_wrapping_add(self.len, 1_usize);\n"
"    }\n"
"    fn set(ref self: NullableVec<T>, index: usize, value: T) {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.insert(index.into(), nullable_from_box(BoxTrait::new(value)));\n"
"    }\n"
"    fn len(self: @NullableVec<T>) -> usize {\n"
"        *self.len\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl NullableVecImpl<T, impl TDrop: Drop<T>, impl TCopy: Copy<T>> of VecTrait<NullableVec<T>, T> {\n"
"    fn new() -> NullableVec<T> {\n"
"        NullableVec { data: Default::default(), len: 0 }\n"
"    }\n"
"\n"
"    fn get(ref self: NullableVec<T>, index: usize) -> Option<T> {\n"
"        if index < self.len() {\n"
"            Option::Some(self.data.get(index.into()).deref())\n"
"        } else {\n"
"            Option::None\n"
"        }\n"
"    }\n"
"\n"
"    fn at(ref self: NullableVec<T>, index: usize) -> T {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.get(index.into()).deref()\n"
"    }\n"
"\n"
"    fn push(ref self: NullableVec<T>, value: T) -> () {\n"
"        self.data.insert(self.len.into(), nullable_from_box(BoxTrait::new(value)));\n"
"        self.len = integer::u32_wrapping_add(self.len, 1_usize);\n"
"    }\n"
"    fn set(ref self: NullableVec<T>, index: usize, value: T) {\n"
"        assert(index < self.len(), 'Index out of bounds');\n"
"        self.data.insert(index.into(), nullable_from_box(BoxTrait::new(value)));\n"
"    }\n"
"    fn len(self: @NullableVec<T>) -> usize {\n"
"        *self.len\n"
"    }\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:133
msgid ""
"The full implementation of the `Vec` structure can be found in the\n"
"community-maintained library\n"
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)."
msgstr ""
"“Vec”结构的完整实现可以在社区维护的库\n"
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)里找到。"

#: src/ch03-03-custom-data-structures.md:137
msgid "## Simulating a Stack with dicts"
msgstr "## 使用字典模拟堆栈"

#: src/ch03-03-custom-data-structures.md:139
msgid "We will now look at a second example and its implementation details: a Stack."
msgstr "现在，我们将查看第二个示例及其实现细节：堆栈。"

#: src/ch03-03-custom-data-structures.md:141
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new\n"
"element and removal of an existing element takes place at the same end,\n"
"represented as the top of the stack."
msgstr ""
"堆栈是 LIFO（后进先出）集合。插入新的元素和现有元素的删除发生在同一端，\n"
"表示为堆栈的顶部。"

#: src/ch03-03-custom-data-structures.md:145
msgid "Let us define what operations we need to create a stack :"
msgstr "让我们定义创建堆栈所需的操作："

#: src/ch03-03-custom-data-structures.md:147
msgid ""
"- Push an item to the top of the stack\n"
"- Pop an item from the top of the stack\n"
"- Check whether there are still any elements in the stack."
msgstr ""
"- 将项推到堆栈的顶部\n"
"- 从堆栈顶部弹出一个项\n"
"- 检查堆栈中是否还有元素。"

#: src/ch03-03-custom-data-structures.md:151
msgid "From these specifications we can define the following interface :"
msgstr "根据这些规则我们可以定义以下接口："

#: src/ch03-03-custom-data-structures.md:153
msgid ""
"```rust\n"
"trait StackTrait<S, T> {\n"
"    fn push(ref self: S, value: T);\n"
"    fn pop(ref self: S) -> Option<T>;\n"
"    fn is_empty(self: @S) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait StackTrait<S, T> {\n"
"    fn push(ref self: S, value: T);\n"
"    fn pop(ref self: S) -> Option<T>;\n"
"    fn is_empty(self: @S) -> bool;\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:161
msgid "### Implementing a Mutable Stack in Cairo"
msgstr "### 在Cairo实现可变堆栈"

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"To create a stack data structure in Cairo, we can again use a `Felt252Dict<T>`\n"
"to store the values of the stack along with a `usize` field to keep track of the\n"
"length of the stack to iterate over it."
msgstr ""
"要在Cairo创建堆栈数据结构，我们可以再次使用`Felt252Dict<T>`\n"
"将堆栈的值与`usize`字段一起存储，以跟踪堆栈的长度来迭代它。"

#: src/ch03-03-custom-data-structures.md:167
msgid "The Stack struct is defined as:"
msgstr "堆栈结构定义如下："

#: src/ch03-03-custom-data-structures.md:169
msgid ""
"```rust\n"
"struct NullableStack<T> {\n"
"    data: Felt252Dict<Nullable<T>>,\n"
"    len: usize,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct NullableStack<T> {\n"
"    data: Felt252Dict<Nullable<T>>,\n"
"    len: usize,\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:176
msgid "Next, let's see how our main functions `push` and `pop` are implemented."
msgstr "接下来，让我们看看我们的主要功能`push`和`pop` 是如何实现的。"

#: src/ch03-03-custom-data-structures.md:178
msgid ""
"```rust\n"
"impl NullableStackImpl<\n"
"    T, impl TDrop: Drop<T>, impl TCopy: Copy<T>\n"
"> of StackTrait<NullableStack<T>, T> {\n"
"    fn push(ref self: NullableStack<T>, value: T) {\n"
"        self.data.insert(self.len.into(), nullable_from_box(BoxTrait::new(value)));\n"
"        self.len += 1;\n"
"    }\n"
"\n"
"    fn pop(ref self: NullableStack<T>) -> Option<T> {\n"
"        if self.is_empty() {\n"
"            return Option::None;\n"
"        }\n"
"        self.len -= 1;\n"
"        Option::Some(self.data.get(self.len.into()).deref())\n"
"    }\n"
"\n"
"    fn is_empty(self: @NullableStack<T>) -> bool {\n"
"        *self.len == 0\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl NullableStackImpl<\n"
"    T, impl TDrop: Drop<T>, impl TCopy: Copy<T>\n"
"> of StackTrait<NullableStack<T>, T> {\n"
"    fn push(ref self: NullableStack<T>, value: T) {\n"
"        self.data.insert(self.len.into(), nullable_from_box(BoxTrait::new(value)));\n"
"        self.len += 1;\n"
"    }\n"
"\n"
"    fn pop(ref self: NullableStack<T>) -> Option<T> {\n"
"        if self.is_empty() {\n"
"            return Option::None;\n"
"        }\n"
"        self.len -= 1;\n"
"        Option::Some(self.data.get(self.len.into()).deref())\n"
"    }\n"
"\n"
"    fn is_empty(self: @NullableStack<T>) -> bool {\n"
"        *self.len == 0\n"
"    }\n"
"}\n"
"```"

#: src/ch03-03-custom-data-structures.md:201
msgid ""
"The code uses the `insert` and `get` methods to access the values in the\n"
"`Felt252Dict<T>`. To push an element at the top of the stack, the `push`\n"
"function inserts the element in the dict at index `len` - and increases the\n"
"`len` field of the stack to keep track of the position of the stack top. To\n"
"remove a value, the `pop` function retrieves the last value at position `len-1`\n"
"and then decreases the value of `len` to update the position of the stack top\n"
"accordingly."
msgstr ""
"该代码使用 `insert`和 `get`方法访问`Felt252Dict<T>`。\n"
"要将元素推送到堆栈顶部，使用`push`函数将元素插入字典中的索引 'len' - 并增加\n"
"堆栈的 'len' 字段来跟踪堆栈顶部的位置。\n"
"要删除一个值，使用`pop`函数检索位置`len-1`处的最后一个值\n"
"然后减小 'len' 的值以更新堆栈顶部的位置。"

#: src/ch03-03-custom-data-structures.md:209
msgid ""
"The full implementation of the Stack, along with more data structures that you\n"
"can use in your code, can be found in the community-maintained\n"
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)\n"
"library, in the \"data_structures\" crate."
msgstr ""
"堆栈的完整实现，以及您拥有的更多数据结构\n"
"可以在你的代码中使用，可以在社区维护中的\n"
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)\n"
"库中的`data_structures` crate中找到。"

#: src/ch03-03-custom-data-structures.md:216
msgid ""
"While Cairo's memory model is immutable and can make it difficult to implement\n"
"mutable data structures, we can fortunately use the `Felt252Dict<T>` type to\n"
"simulate mutable data structures. This allows us to implement a wide range of\n"
"data structures that are useful for many applications, effectively hiding the\n"
"complexity of the underlying memory model."
msgstr ""
"虽然 Cairo 的内存模型是不可变的，使其难以实现可变的数据结构，\n"
"但幸运的是，我们可以使用 'Felt252Dict<T>' 类型来模拟可变数据结构。\n"
"这使我们能够实现通用的对应用程序有用的数据结构，有效地隐藏了底层内存模型的复杂性。"

#: src/ch04-00-understanding-ownership.md:1
msgid "# Understanding Cairo's Ownership system"
msgstr "# 了解Cairo的所有权制度"

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to\n"
"statically ensure that in every Cairo program, a value is used exactly once.\n"
"This linear type system helps preventing runtime errors by ensuring that operations that could cause such errors, such as writing twice to a memory cell, are detected at compile "
"time.\n"
"This is achieved by implementing an ownership system\n"
"and forbidding copying and dropping values by default. In this chapter, we’ll\n"
"talk about Cairo's ownership system as well as references and snapshots."
msgstr ""
"Cairo是一种围绕着线性类型系统建立的语言，它允许我们\n"
"静态地确保在每个Cairo程序中，一个值只被使用一次。\n"
"这种线性类型系统有助于防止运行时错误，因为它可以确保在编译时检测到可能导致这种错误的操作，如向一个内存单元写两次。\n"
"这是通过实施一个所有权系统来实现的\n"
"并在默认情况下禁止复制和丢弃数值。在本章中，我们将\n"
"讨论Cairo的所有权系统以及引用和快照（snapshot）。"

#: src/ch04-01-what-is-ownership.md:1
msgid "## What Is Ownership?"
msgstr "## 什么是所有权？"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of its compiled code.\n"
"The ownership mechanism complements the linear type system, which enforces that objects are used exactly once.\n"
"This helps prevent common operations that can produce runtime errors, such as illegal memory address\n"
"references or multiple writes to the same memory address, and ensures the soundness of Cairo programs\n"
"by checking at compile time that all the dictionaries are squashed."
msgstr ""
"Cairo实现了一个所有权系统以确保其编译代码的安全性和正确性。\n"
"所有权机制是对线性类型系统的补充，该系统规定对象只能使用一次。\n"
"这有助于防止可能产生运行时错误的常见操作，如非法的内存地址引用或对同一内存地址的多次写入，\n"
"并通过在编译时检查所有的字典是否被压缩（squash）来确保Cairo程序的正确性。"

#: src/ch04-01-what-is-ownership.md:9
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() {`\n"
"code in examples, so if you’re following along, make sure to put the following\n"
"examples inside a `main` function manually. As a result, our examples will be a\n"
"bit more concise, letting us focus on the actual details rather than\n"
"boilerplate code."
msgstr ""
"既然我们已经掌握了Cairo基本语法，我们将不会在之后的例子中包含 `fn main() {` 代码，\n"
"所以如果你是一路跟过来的，必须手动将之后例子的代码放入一个 `main` 函数中。\n"
"这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。"

#: src/ch04-01-what-is-ownership.md:15
msgid "### Ownership Rules"
msgstr "### 所有权规则"

#: src/ch04-01-what-is-ownership.md:17
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as we\n"
"work through the examples that illustrate them:"
msgstr "首先，让我们看一下所有权规则。请牢记这些规则，我们将通过例子来说明它们："

#: src/ch04-01-what-is-ownership.md:20
msgid ""
"- Each value in Cairo has an _owner_.\n"
"- There can only be one owner at a time.\n"
"- When the owner goes out of scope, the value will be _dropped_."
msgstr ""
"- Cairo的每个值都有一个 _所有者_ 。\n"
"- 在同一时间只能有一个所有者。\n"
"- 当所有者超出作用域（scope）时，该值将被 _丢弃_ 。"

#: src/ch04-01-what-is-ownership.md:24
msgid "### Variable Scope"
msgstr "### 变量作用域"

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some variables. A\n"
"scope is the range within a program for which an item is valid. Take the\n"
"following variable:"
msgstr "在所有权的第一个例子中，我们看看一些变量的 作用域（ _scope_ ）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量："

#: src/ch04-01-what-is-ownership.md:30
msgid ""
"```rust,noplayground\n"
"let s = 'hello';\n"
"```"
msgstr ""
"```rust,noplayground\n"
"let s = 'hello';\n"
"```"

#: src/ch04-01-what-is-ownership.md:34
msgid ""
"The variable `s` refers to a short string, where the value of the string is\n"
"hardcoded into the text of our program. The variable is valid from the point at\n"
"which it’s declared until the end of the current _scope_. Listing 4-1 shows a\n"
"program with comments annotating where the variable `s` would be valid."
msgstr ""
"变量`s`指的是一个短字符串，字符串的值被硬编码到我们的程序文本中。\n"
"这个变量从它被声明的那一刻起，一直到当前 _scope_ 的结束，都是有效的。\n"
"示例4-1的程序中的注释标明了变量 `s` 在何处是有效的。"

#: src/ch04-01-what-is-ownership.md:39
msgid ""
"```rust\n"
"# //TAG: ignore_fmt\n"
"# fn main() {\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer valid\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# //TAG: ignore_fmt\n"
"# fn main() {\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer valid\n"
"# }\n"
"```"

#: src/ch04-01-what-is-ownership.md:50
msgid ""
"<span class=\"caption\">Listing 4-1: A variable and the scope in which it is\n"
"valid</span>"
msgstr "<span class=\"caption\">示例4-1：一个变量和其有效的作用域</span>"

#: src/ch04-01-what-is-ownership.md:53
msgid "In other words, there are two important points in time here:"
msgstr "换句话说，这里有两个重要的时间点："

#: src/ch04-01-what-is-ownership.md:55
msgid ""
"- When `s` comes _into_ scope, it is valid.\n"
"- It remains valid until it goes _out of_ scope."
msgstr ""
"- 当`s`进入 _进入作用域_ 时，它就是有效的。\n"
"- 这一直持续到它 _离开_ 作用域 为止。"

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"At this point, the relationship between scopes and when variables are valid is\n"
"similar to that in other programming languages. Now we’ll build on top of this\n"
"understanding by using the `Array` type we introduced in the [previous chapter](./ch03-01-arrays.md)."
msgstr ""
"目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。\n"
"现在我们在此基础上通过在[前一章](./ch03-01-arrays.md)中介绍的`Array`类型进一步理解。"

#: src/ch04-01-what-is-ownership.md:62
msgid "### Ownership with the `Array` Type"
msgstr "###  `Array` 类型的所有权"

#: src/ch04-01-what-is-ownership.md:64
msgid ""
"To illustrate the rules of ownership, we need a data type that is more complex.\n"
"The types covered in the [Data Types][data-types]<!-- ignore --> section\n"
"of Chapter 2 are of a known size, can be\n"
"quickly and trivially copied to make a new, independent instance if another\n"
"part of code needs to use the same value in a different scope, and can easily\n"
"be dropped when they're no longer used. But what is the behavior with the `Array` type whose size\n"
"is unknown at compile time and which can't be trivially copied?"
msgstr ""
"为了演示所有权的规则，我们需要一个比第二章 [数据类型][data-types]<!-- ignore --> 中讲到的类型都要复杂的数据类型。\n"
"前面介绍的类型都是已知大小的，如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单地复制它们来创建一个新的独立实例，并且当离开作用域时被丢弃。\n"
"那么那些在编译时大小未知，且无法被简单复制的`Array`会怎么样呢？"

#: src/ch04-01-what-is-ownership.md:72
msgid "Here is a short reminder of what an array looks like:"
msgstr "这里简单回忆一下数组的样子："

#: src/ch04-01-what-is-ownership.md:74
msgid ""
"```rust\n"
"# fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(1);\n"
"    arr.append(2);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(1);\n"
"    arr.append(2);\n"
"# }\n"
"```"

#: src/ch04-01-what-is-ownership.md:82
msgid ""
"So, how does the ownership system ensure that each cell is never written to more than once?\n"
"Consider the following code, where we try to pass the same instance of an array in two consecutive\n"
"function calls:"
msgstr ""
"那么，所有权系统如何确保每个内存单元不会被写入超过一次？\n"
"考虑一下下面的代码，我们试图在两个连续的函数调用中传递同一个数组实例："

#: src/ch04-01-what-is-ownership.md:86
msgid ""
"```rust,does_not_compile\n"
"\n"
"fn foo(arr: Array<u128>) {}\n"
"\n"
"fn bar(arr: Array<u128>) {}\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    foo(arr);\n"
"    bar(arr);\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"\n"
"fn foo(arr: Array<u128>) {}\n"
"\n"
"fn bar(arr: Array<u128>) {}\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    foo(arr);\n"
"    bar(arr);\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the functions `foo` and `bar`, which means\n"
"that the parameter used in both function calls is the same instance of the array. If you append a value to the array\n"
"in `foo`, and then try to append another value to the same array in `bar`, what would happen is that\n"
"you would attempt to try to write to the same memory cell twice, which is not allowed in Cairo.\n"
"To prevent this, the ownership of the `arr` variable moves from the `main` function to the `foo` function. When trying\n"
"to call `bar` with `arr` as a parameter, the ownership of `arr` was already moved to the first call. The ownership\n"
"system thus prevents us from using the same instance of `arr` in `foo`."
msgstr ""
"在这种情况下，我们试图将同一个数组实例`arr`通过值传递给函数`foo`和`bar`，这意味着两个函数调用的参数都是同一个数组实例。\n"
"如果你在`foo`中向数组添加一个值，然后再在`bar`中向数组添加一个值，会发生什么呢？\n"
"你会试图向同一个内存单元写两次，这在Cairo中是不允许的。\n"
"为了防止这种情况，`arr`变量的所有权从`main`函数转移到`foo`函数。当试图以`arr`为参数调用`bar`时，`arr`的所有权早已再第一次调用时被转移。\n"
"所有权系统阻止了我们在`foo`中使用相同的`arr`实例。"

#: src/ch04-01-what-is-ownership.md:107
msgid "Running the code above will result in a compile-time error:"
msgstr "运行上面的代码将导致一个编译时错误："

#: src/ch04-01-what-is-ownership.md:109
msgid ""
"```shell\n"
"error: Variable was previously moved. Trait has no implementation in context: core::traits::Copy::<core::array::Array::<core::integer::u128>>\n"
" --> array.cairo:6:9\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"        ^*****^\n"
"```"
msgstr ""
"```shell\n"
"error: Variable was previously moved. Trait has no implementation in context: core::traits::Copy::<core::array::Array::<core::integer::u128>>\n"
" --> array.cairo:6:9\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"        ^*****^\n"
"```"

#: src/ch04-01-what-is-ownership.md:116
msgid "### The `Copy` Trait"
msgstr "### `Copy` Trait"

#: src/ch04-01-what-is-ownership.md:118
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not move the ownership of the value to the function called, but will instead pass a copy of the value.\n"
"You can implement the `Copy` trait on your type by adding the `#[derive(Copy)]` annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the "
"type itself or any of its components don't implement the Copy trait.\n"
"While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be."
msgstr ""
"如果一个类型实现了`Copy`Trait，把它传递给一个函数将不会把值的所有权转移给被调用的函数，而是传递一个值的副本。\n"
"你可以通过在你的类型定义中添加`#[derive(Copy)]`标注来实现`Copy` Trait。然而，如果一个类型本身或其任何组件没有实现Copy Trait，Cairo将不允许该类型被标注为Copy。\n"
"虽然数组和字典不能被复制，但不包含它们的自定义类型可以被复制。"

#: src/ch04-01-what-is-ownership.md:122
msgid ""
"```rust,ignore_format\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) { // do something with p\n"
"}\n"
"```"
msgstr ""
"```rust,ignore_format\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) { // do something with p\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:139
msgid ""
"In this example, we can pass `p1` twice to the foo function because the `Point` type implements the `Copy` trait. This means that when we pass `p1` to `foo`, we are actually passing "
"a copy of `p1`, and the ownership of `p1` remains with the main function.\n"
"If you remove the `Copy` trait derivation from the `Point` type, you will get a compile-time error when trying to compile the code."
msgstr ""
"在这个例子中，我们可以向foo函数传递两次`p1`，因为`Point`类型实现了`Copy`trait。这意味着当我们把`p1`传递给`foo`时，我们实际上是在传递`p1`的副本，而`p1`的所有权仍然属于主函数。\n"
"如果你从`Point`类型中删除`Copy`trait的派生，当你试图编译代码时，你会得到一个编译时错误。"

#: src/ch04-01-what-is-ownership.md:142
msgid "_Don't worry about the `Struct` keyword. We will introduce this in [Chapter 5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr "_不要担心`Struct`关键字。我们将在[第五章](ch05-00-using-structs-to-structure-related-data.md)中介绍_"

#: src/ch04-01-what-is-ownership.md:144
msgid "### The `Drop` Trait"
msgstr "### `Drop` Trait"

#: src/ch04-01-what-is-ownership.md:146
msgid ""
"You may have noticed that the `Point` type in the previous example also implements the `Drop` trait. In Cairo, a value cannot go out of scope unless it has been previously moved.\n"
"For example, the following code will not compile, because the struct `A` is not moved before it goes out of scope:"
msgstr ""
"你可能已经注意到，前面例子中的`Point`类型也实现了`Drop` trait。在Cairo中，一个值不能超出其作用域，除非它之前被移动过。\n"
"例如，下面的代码将无法编译，因为结构体`A`在超出作用域之前没有被移动："

#: src/ch04-01-what-is-ownership.md:149
msgid ""
"```rust,does_not_compile\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:157
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the fact that if a\n"
"statement during the execution of the program is false, no cheating prover can convince an\n"
"honest verifier that it is true. In our case, we want to ensure the consistency of\n"
"consecutive dictionary key updates during program execution, which is only checked when\n"
"the dictionaries are `squashed` - which moves the ownership of the dictionary to the\n"
"`squash` method, thus allowing the dictionary to go out of scope. Unsquashed dictionaries\n"
"are dangerous, as a malicious prover could prove the correctness of inconsistent updates."
msgstr ""
"这是为了确保Cairo程序的健全性。健全性指的是，如果在程序执行过程中的一个语句是假的，任何作弊的验证者都不可能说服一个诚实的验证者相信它是真的。\n"
"在我们的案例中，我们要确保程序执行过程中连续的字典键的更新的一致性。\n"
"这只有在字典被压缩（`squashed`）时才会进行检查--它将字典的所有权转移到了`squash`方法，从而允许字典超出作用域。未被压缩的字典是危险的，因为恶意的证明者可以证明不一致更新的正确性。"

#: src/ch04-01-what-is-ownership.md:165
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of scope without being explicitly moved. When a value of a type that implements the `Drop` trait goes out of "
"scope, the `Drop` implementation is called on the type, which moves the value to the `drop` function, allowing it to go out of scope - This is what we call \"dropping\" a value.\n"
"It is important to note that the implementation of drop is a \"no-op\", meaning that it doesn't perform any actions other than allowing the value to go out of scope."
msgstr ""
"然而，实现了`Drop` trait的类型被允许超出作用域而不被明确移动。当一个实现了`Drop` trait的类型的值超出作用域时，`Drop`的实现会被调用，它将值移动到`drop`函数中，允许它超出作用域--这就是"
"我们所说的 \"丢弃 \"一个值。\n"
"值得注意的是，drop的实现是一个 \"no-op\"，也就是说，除了允许值离开作用域之外，它不执行任何其他操作。"

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be dropped when going out of scope, except for dictionaries (`Felt252Dict`) and types containing "
"dictionaries.\n"
"For example, the following code compiles:"
msgstr ""
"除了字典（`Felt252Dict`）和包含字典的类型外，所有类型都可以派生`Drop`的实现，使得它们可以在超出作用域时被丢弃。\n"
"例如，下面的代码可以正常编译："

#: src/ch04-01-what-is-ownership.md:171
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:180
msgid "### The `Destruct` Trait"
msgstr "### `Destruct` Trait"

#: src/ch04-01-what-is-ownership.md:182
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, and it is easy to forget to do so. To make it easier to use dictionaries, Cairo provides the `Destruct` "
"trait, which allows you to specify the behavior of a type when it goes out of scope. While Dictionaries don't implement the `Drop` trait, they do implement the `Destruct` trait, "
"which allows them to automatically be `squashed` when they go out of scope. This means that you can use dictionaries without having to manually call the `squash` method."
msgstr ""
"手动调用字典上的 `squash` 方法不是很方便，而且很容易忘记这样做。为了方便使用字典，Cairo 提供了 `Destruct` trait，它允许你指定一个类型超出作用域时的行为。虽然字典没有实现`Drop` trait，"
"但它们实现了`Destruct`trait，这允许它们在超出作用域时自动被`squashed`，因此你可以不需要手动调用`squash`方法。"

#: src/ch04-01-what-is-ownership.md:184
msgid "Consider the following example, in which we define a custom type that contains a dictionary:"
msgstr "下面的这个例子中，我们定义了一个包含字典的自定义类型："

#: src/ch04-01-what-is-ownership.md:186
msgid ""
"```rust,does_not_compile\n"
"\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Default::default() };\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Default::default() };\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:197
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "如果你试图运行这段代码，你会得到一个编译时错误："

#: src/ch04-01-what-is-ownership.md:199
msgid ""
"```shell\n"
"error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<temp7::temp7::A>. Trait has no implementation in context: core::traits::Destruct::<temp7::"
"temp7::A>.\n"
" --> temp7.cairo:7:5\n"
"    A {\n"
"    ^*^\n"
"```"
msgstr ""
"```shell\n"
"error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<temp7::temp7::A>. Trait has no implementation in context: core::traits::Destruct::<temp7::"
"temp7::A>.\n"
" --> temp7.cairo:7:5\n"
"    A {\n"
"    ^*^\n"
"```"

#: src/ch04-01-what-is-ownership.md:206
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the `Destruct` trait. To fix this, we can "
"derive the `Destruct` trait implementation for the `A` type:"
msgstr ""
"当A超出作用域时，它不能被丢弃，因为它既没有实现`Drop`（因为它包含一个字典，不能派生`derive(Drop)`）也没有实现`Destruct` trait。为了解决这个问题，我们可以为`A`类型派生出`Destruct` "
"trait的实现："

#: src/ch04-01-what-is-ownership.md:208
msgid ""
"```rust\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Default::default() }; // No error here\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Default::default() }; // No error here\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:219
msgid "Now, when `A` goes out of scope, its dictionary will be automatically `squashed`, and the program will compile."
msgstr "现在，当`A`超出作用域时，它的字典将被自动`squashed`，并且程序将被编译。"

#: src/ch04-01-what-is-ownership.md:221
msgid "### Copy Array data with Clone"
msgstr "### 用Clone复制数组数据"

#: src/ch04-01-what-is-ownership.md:223
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common method called `clone`. We’ll discuss method syntax in Chapter 6, but because methods are a common feature "
"in many\n"
"programming languages, you’ve probably seen them before."
msgstr ""
"如果我们确实想深拷贝一个 \"数组 \"的数据，我们可以使用一个叫做 `clone`的通用方法。\n"
"我们将在第6章中讨论方法的语法，但由于方法是许多编程语言的共同特征，你可能已经见过它们了。"

#: src/ch04-01-what-is-ownership.md:226
msgid "Here’s an example of the `clone` method in action."
msgstr "下面是一个 `clone` 方法的实例。"

#: src/ch04-01-what-is-ownership.md:228
msgid "> Note: in the following example, we need to import the `Clone` trait from the corelib `clone` module, and its implementation for the array type from the `array` module."
msgstr "> 注意：在下面的例子中，我们需要从corelib的`clone`模块中导入`clone`trait，并从`array`模块中导入其对数组类型的实现。"

#: src/ch04-01-what-is-ownership.md:230
msgid ""
"```rust\n"
"use clone::Clone;\n"
"use array::ArrayTCloneImpl;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"    let arr2 = arr1.clone();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use clone::Clone;\n"
"use array::ArrayTCloneImpl;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"    let arr2 = arr1.clone();\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:239
msgid "> Note: you will need to run `scarb cairo-run` with the `--available-gas=2000000` option to run this example, because it uses a loop and must be ran with a gas limit."
msgstr "> 注意：你需要用`--available-gas=2000000`选项运行`scarb cairo-run`来运行这个例子，因为它使用了一个循环，运行时必须有gas限制。"

#: src/ch04-01-what-is-ownership.md:241
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being\n"
"executed and that code may be expensive. It’s a visual indicator that something\n"
"different is going on."
msgstr ""
"当你看到对`clone`的调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。\n"
"你很容易察觉到一些不寻常的事情正在发生。"

#: src/ch04-01-what-is-ownership.md:245
msgid "### Ownership and Functions"
msgstr "### 所有权与函数"

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in the Array section, passing an `Array` as a function parameter transfers its ownership; let's see what "
"happens with other types."
msgstr "将一个变量传递给一个函数，要么移动它，要么复制它。正如在数组部分所看到的，将 `Array` 作为一个函数参数传递同时会传递它的所有权；让我们看看其他类型会发生什么。"

#: src/ch04-01-what-is-ownership.md:249
msgid ""
"Listing 4-3 has an example with some annotations\n"
"showing where variables go into and out of scope."
msgstr "示例4-3使用注释展示变量何时进入和离开作用域。"

#: src/ch04-01-what-is-ownership.md:254
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is okay to still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is okay to still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"

#: src/ch04-01-what-is-ownership.md:280
msgid ""
"<span class=\"caption\">Listing 4-3: Functions with ownership and scope\n"
"annotated</span>"
msgstr "<span class=\"caption\">示例4-3：带有所有权和作用域注释的函数</span>"

#: src/ch04-01-what-is-ownership.md:283
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo would throw a\n"
"compile-time error. These static checks protect us from mistakes. Try adding\n"
"code to `main` that uses `my_struct` and `x` to see where you can use them and where\n"
"the ownership rules prevent you from doing so."
msgstr ""
"如果我们试图在调用`takes_ownership`之后使用`my_struct`，Cairo会抛出一个编译时错误。\n"
"这些静态检查可以保护我们不犯错误。试着在`main`中添加使用`my_struct`和`x`的代码，看看哪里可以使用它们，\n"
"哪里所有权规则将会阻止你这样做。"

#: src/ch04-01-what-is-ownership.md:288
msgid "### Return Values and Scope"
msgstr "### 返回值与作用域"

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example of a\n"
"function that returns some value, with similar annotations as those in Listing\n"
"4-3."
msgstr ""
"返回值也可以转移所有权。示例4-4显示了一个例子\n"
"该函数返回一些值，其注释与示例4-3中的相似。"

#: src/ch04-01-what-is-ownership.md:296
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A {};                        // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A {};                    // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A {};                        // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A {};                    // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:334
msgid ""
"<span class=\"caption\">Listing 4-4: Transferring ownership of return\n"
"values</span>"
msgstr ""
"<span class=\"caption\">示例4-4：转移返回值的所有权\n"
"</span>"

#: src/ch04-01-what-is-ownership.md:337
msgid "When a variable goes out of scope, its value is dropped, unless ownership of the value has been moved to another variable."
msgstr "当一个变量超出作用域时，它的值会被丢弃，除非值的所有权被转移到另一个变量上。"

#: src/ch04-01-what-is-ownership.md:339
msgid ""
"While this works, taking ownership and then returning ownership with every\n"
"function is a bit tedious. What if we want to let a function use a value but\n"
"not take ownership? It’s quite annoying that anything we pass in also needs to\n"
"be passed back if we want to use it again, in addition to any data resulting\n"
"from the body of the function that we might want to return as well."
msgstr ""
"虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。\n"
"如果我们想要函数使用一个值但不获取所有权该怎么办呢？\n"
"除此之外，我们也可能想返回函数体中产生的一些数据。"

#: src/ch04-01-what-is-ownership.md:345
msgid "Cairo does let us return multiple values using a tuple, as shown in Listing 4-5."
msgstr "Cairo的确让我们可以使用一个元组返回多个值，如示例4-5所示。"

#: src/ch04-01-what-is-ownership.md:349
msgid ""
"```rust\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"

#: src/ch04-01-what-is-ownership.md:363
msgid "<span class=\"caption\">Listing 4-5: Returning ownership of parameters</span>"
msgstr "<span class=\"caption\">示例4-5：返回参数的所有权</span>"

#: src/ch04-01-what-is-ownership.md:365
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be\n"
"common. Luckily for us, Cairo has two features for using a value without\n"
"transferring ownership, called _references_ and _snapshots_."
msgstr ""
"但是这未免有些形式主义，而且这种场景应该很常见。\n"
"幸运的是，Cairo提供了两个功能可以在不转移所有权的情况下使用一个值，\n"
"称为 引用（ _references_ ）和 快照（ _snapshots_ ）。"

#: src/ch04-02-references-and-snapshots.md:1
msgid "## References and Snapshots"
msgstr "## 引用和快照"

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the\n"
"`Array` to the calling function so we can still use the `Array` after the\n"
"call to `calculate_length`, because the `Array` was moved into\n"
"`calculate_length`."
msgstr ""
"示例4-5中元组代码的问题是，因为 `Array`的所有权被移到了`calculate_length`中。\n"
"我们必须返回`Array`给调用的函数，这样我们在调用`calculate_length`后才仍然可以使用`Array`。"

#: src/ch04-02-references-and-snapshots.md:8
msgid "### Snapshots"
msgstr "### 快照（Snapshots）"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a snapshot\n"
"is an immutable view of a value at a certain point in time. In the previous chapter,\n"
"we talked about how Cairo's ownership system prevents us from using a value after\n"
"we've moved it, protecting us from potentially writing twice to the same memory cell when\n"
"appending values to arrays. However, it's not very convenient. Let's see how we can retain ownership\n"
"of the value in the calling function using snapshots."
msgstr ""
"不过，我们可以提供一个`Array`值的 _snapshot_ 。在Cairo，一个快照是一个在某个时间点上的不可改变的值的视图。\n"
"在上一章中，我们谈到了Cairo的所有权系统是如何防止我们在移动一个值后使用它，从而防止我们在向数组添加值时不会潜在地多次写入相同的内存单元。\n"
"然而，这不是很方便。让我们看看如何使用快照在调用函数中保留值的所有权。"

#: src/ch04-02-references-and-snapshots.md:17
msgid ""
"Here is how you would define and use a `calculate_length` function that takes a\n"
"snapshot to an array as a parameter instead of taking ownership of the underlying value. In this example,\n"
"the `calculate_length` function returns the length of the array passed as parameter.\n"
"As we're passing it as a snapshot, which is an immutable view of the array, we can be sure that\n"
"the `calculate_length` function will not mutate the array, and ownership of the array is kept in the main function."
msgstr ""
"下面是你如何定义和使用一个`calculate_length` 函数，它以一个快照作为参数，而不是获取底层值的所有权。在这个例子中、\n"
"`calculate_length`函数返回作为参数的数组的长度。\n"
"因为我们是以快照的形式传递的，这是一个不可改变的数组视图，我们可以确定\n"
"`calculate_length`函数不会改变数组，数组的所有权被保留在主函数中。"

#: src/ch04-02-references-and-snapshots.md:25
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"    arr1.append(1); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(\n"
"        first_snapshot\n"
"    ); // Calculate the length of the array when the snapshot was taken\n"
"    //ANCHOR: function_call\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
"    //ANCHOR_END: function_call\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"    arr1.append(1); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(\n"
"        first_snapshot\n"
"    ); // Calculate the length of the array when the snapshot was taken\n"
"    //ANCHOR: function_call\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
"    //ANCHOR_END: function_call\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"

#: src/ch04-02-references-and-snapshots.md:47
msgid ""
"> Note: It is only possible to call the `len()` method on an array snapshot because it is defined as such in the `ArrayTrait` trait. If you try to call a method that is not defined "
"for snapshots on a snapshot, you will get a compilation error. However, you can call methods expecting a snapshot on non-snapshot types."
msgstr ""
"> 注意：只有在数组快照上才能调用 `len()` 方法，因为它在 `ArrayTrait` trait中被定义成这样。如果你试图在一个快照上调用一个没有为快照定义的方法，你会得到一个编译错误。然而，你可以在非快"
"照类型上调用快照的方法。"

#: src/ch04-02-references-and-snapshots.md:49
msgid "The output of this program is:"
msgstr "这个程序的输出是："

#: src/ch04-02-references-and-snapshots.md:51
msgid ""
"```shell\n"
"[DEBUG]\t                               \t(raw: 0)\n"
"\n"
"[DEBUG]\t                              \t(raw: 1)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```shell\n"
"[DEBUG]\t                               \t(raw: 0)\n"
"\n"
"[DEBUG]\t                              \t(raw: 1)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch04-02-references-and-snapshots.md:59
msgid ""
"First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note\n"
"that we pass `@arr1` into `calculate_length` and, in its definition, we take `@Array<u128>` rather than `Array<u128>`."
msgstr ""
"首先，注意到变量声明和函数返回值中的所有元组代码都消失了。\n"
"第二，注意看我们把`@arr1`传入`calculate_length`，因此在它的定义中，我们采用`@Array<u128>`，而不是`Array<u128>`。"

#: src/ch04-02-references-and-snapshots.md:62
msgid "Let’s take a closer look at the function call here:"
msgstr "让我们仔细看一下这里的函数调用："

#: src/ch04-02-references-and-snapshots.md:64
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut arr1 = ArrayTrait::<u128>::new();\n"
"#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"#     arr1.append(1); // Mutate `arr1` by appending a value\n"
"#     let first_length = calculate_length(\n"
"#         first_snapshot\n"
"#     ); // Calculate the length of the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
"#     first_length.print();\n"
"#     second_length.print();\n"
"# }\n"
"# \n"
"# fn calculate_length(arr: @Array<u128>) -> usize {\n"
"#     arr.len()\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut arr1 = ArrayTrait::<u128>::new();\n"
"#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"#     arr1.append(1); // Mutate `arr1` by appending a value\n"
"#     let first_length = calculate_length(\n"
"#         first_snapshot\n"
"#     ); // Calculate the length of the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
"#     first_length.print();\n"
"#     second_length.print();\n"
"# }\n"
"# \n"
"# fn calculate_length(arr: @Array<u128>) -> usize {\n"
"#     arr.len()\n"
"# }\n"
"```"

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because a snapshot is an immutable view of a value, the value it points to cannot be modified through the "
"snapshot, and the value it refers to will not be dropped once the snapshot stops being used."
msgstr "`@arr1`语法让我们为`arr1`中的值创建了一个快照。因为快照是一个值的不可改变的视图，它所指向的值不能通过快照被修改，因此即使快照停止被使用，它所指向的值也不会被丢弃。"

#: src/ch04-02-references-and-snapshots.md:86
msgid "Similarly, the signature of the function uses `@` to indicate that the type of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr "同样，函数的签名使用`@`来表示参数`arr`的类型是一个快照。让我们添加一些解释性的注解："

#: src/ch04-02-references-and-snapshots.md:88
msgid ""
"```rust, noplayground\n"
"fn calculate_length(\n"
"    array_snapshot: @Array<u128>\n"
") -> usize { // array_snapshot is a snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.\n"
"```"
msgstr ""
"```rust, noplayground\n"
"fn calculate_length(\n"
"    array_snapshot: @Array<u128>\n"
") -> usize { // array_snapshot is a snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.\n"
"```"

#: src/ch04-02-references-and-snapshots.md:97
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any function parameter’s scope, but the underlying value of the snapshot is not dropped when `array_snapshot` "
"stops being used. When functions have snapshots as parameters instead of the actual values, we won’t need to return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"变量`array_snapshot`的有效范围与任何函数参数的范围相同，但当`array_snapshot`停止使用时，快照的底层值不会被丢弃。当函数有快照作为参数而不是实际的值时，我们将不需要返回值以归还原始值的"
"所有权，因为我们从未拥有过它。"

#: src/ch04-02-references-and-snapshots.md:99
msgid "#### Desnap Operator"
msgstr "#### Desnap 操作符"

#: src/ch04-02-references-and-snapshots.md:101
msgid ""
"To convert a snapshot back into a regular value, you can use the `desnap` operator `*`, which serves as the opposite of the `@` operator: the snapshot value is copied to a new "
"variable."
msgstr "要将快照转换回常规值，可以使用 `desnap` 操作符 `*`，它的作用与 `@`操作符相反：快照值被复制到一个新变量中。"

#: src/ch04-02-references-and-snapshots.md:103
msgid ""
"It's important to note that during this conversion process, the value it points to is copied into a new variable. This enables multiple uses of the underlying value without concerns "
"about ownership transfers. This also means that the value pointed to by the snapshot must be copyable (which is not the case for Arrays, as they don't implement `Copy`)."
msgstr ""
"值得注意的是，在这个转换过程中，它所指向的值会被复制到一个新变量中。这样就可以多次使用底层值，而不必担心所有权转移。这也意味着快照指向的值必须是可复制的（而数组则不然，因为它们没有实"
"现 `Copy`）。"

#: src/ch04-02-references-and-snapshots.md:105
msgid ""
"In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of the rectangle in the `calculate_area` function, because we might want "
"to use the rectangle again after the function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the rectangle to the function, and then "
"transform the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"在下面的示例中，我们要计算一个矩形的面积，但我们不想在`calculate_area`函数中取得矩形的所有权，因为我们可能想在函数调用后再次使用该矩形。由于我们的函数不会更改矩形实例，因此我们可以将"
"矩形的快照传递给函数，然后使用 `desnap` 操作符 `*` 将快照转换回值。"

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"

#: src/ch04-02-references-and-snapshots.md:131
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? Try the code in\n"
"Listing 4-6. Spoiler alert: it doesn’t work!"
msgstr ""
"但是，如果我们试图修改我们作为快照传递的东西会发生什么？试试下面的代码\n"
"示例4-6。剧透一下：它不起作用!"

#: src/ch04-02-references-and-snapshots.md:136
msgid ""
"```rust,does_not_compile\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    flip(@rec);\n"
"}\n"
"\n"
"fn flip(rec: @Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    flip(@rec);\n"
"}\n"
"\n"
"fn flip(rec: @Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"

#: src/ch04-02-references-and-snapshots.md:155
msgid "<span class=\"caption\">Listing 4-6: Attempting to modify a snapshot value</span>"
msgstr "<span class=\"caption\">示例4-6：试图修改一个快照值</span>"

#: src/ch04-02-references-and-snapshots.md:157
msgid "Here’s the error:"
msgstr "这里有一个错误："

#: src/ch04-02-references-and-snapshots.md:159
msgid ""
"```shell\n"
"error: Invalid left-hand side of assignment.\n"
" --> ownership.cairo:15:5\n"
"    rec.height = rec.width;\n"
"    ^********^\n"
"```"
msgstr ""
"```shell\n"
"error: Invalid left-hand side of assignment.\n"
" --> ownership.cairo:15:5\n"
"    rec.height = rec.width;\n"
"    ^********^\n"
"```"

#: src/ch04-02-references-and-snapshots.md:166
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr "编译器阻止我们修改与快照相关的值。"

#: src/ch04-02-references-and-snapshots.md:168
msgid "### Mutable References"
msgstr "### 可变引用"

#: src/ch04-02-references-and-snapshots.md:170
msgid ""
"We can achieve the behavior we want in Listing 4-6 by using a _mutable reference_ instead of a snapshot. Mutable references are actually mutable values passed to a function that are "
"implicitly returned at the end of the function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution.\n"
"In Cairo, a parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"在示例4-6中，我们也可以通过使用 _mutable reference_ 而不是快照来实现我们想要的行为。可变引用实际上是传递给函数的可变值，在函数结束时被隐式返回，将所有权返回给调用的上下文。通过这样"
"做，它们允许你对传递的值进行改变，同时通过在执行结束时自动返回来保持对它的所有权。\n"
"在Cairo中，一个参数可以使用`ref`修饰符作为 _mutable reference_ 传递。"

#: src/ch04-02-references-and-snapshots.md:173
msgid "> **Note**: In Cairo, a parameter can only be passed as _mutable reference_ using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr "> **注意**：在Cairo中，只有在变量用`mut`声明为可变的情况下，才能使用`ref`修饰符将参数作为可变的引用传递。"

#: src/ch04-02-references-and-snapshots.md:175
msgid "In Listing 4-7, we use a mutable reference to modify the value of the `height` and `width` fields of the `Rectangle` instance in the `flip` function."
msgstr "在示例4-7中，我们使用一个可变的引用来修改`Rectangle`实例在`flip`函数中的`height`和`width`字段的值。"

#: src/ch04-02-references-and-snapshots.md:177
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rec = Rectangle { height: 3, width: 10 };\n"
"    flip(ref rec);\n"
"    rec.height.print();\n"
"    rec.width.print();\n"
"}\n"
"\n"
"fn flip(ref rec: Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rec = Rectangle { height: 3, width: 10 };\n"
"    flip(ref rec);\n"
"    rec.height.print();\n"
"    rec.width.print();\n"
"}\n"
"\n"
"fn flip(ref rec: Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"

#: src/ch04-02-references-and-snapshots.md:199
msgid "<span class=\"caption\">Listing 4-7: Use of a mutable reference to modify a value</span>"
msgstr "<span class=\"caption\">示例 4-7：使用一个可变的引用来修改一个值</span>"

#: src/ch04-02-references-and-snapshots.md:201
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of `rec` into `flip` with `ref rec`, and update the function signature to accept a mutable reference with `ref "
"rec: Rectangle`. This makes it very clear that the `flip` function will mutate the value of the `Rectangle` instance passed as parameter."
msgstr ""
"首先，我们把`rec`改成`mut`。然后我们用 `ref rec` 将 `rec` 的可变引用传入 `flip` ，并更新函数签名，用 `ref rec: Rectangle`接受可变引用。这很清楚地表明，`flip`函数将改变作为参数传递的"
"`Rectangle`实例的值。"

#: src/ch04-02-references-and-snapshots.md:203
msgid "The output of the program is:"
msgstr "程序的输出是："

#: src/ch04-02-references-and-snapshots.md:205
msgid ""
"```shell\n"
"[DEBUG]\n"
"                                (raw: 10)\n"
"\n"
"[DEBUG]\t                        (raw: 3)\n"
"```"
msgstr ""
"```shell\n"
"[DEBUG]\n"
"                                (raw: 10)\n"
"\n"
"[DEBUG]\t                        (raw: 3)\n"
"```"

#: src/ch04-02-references-and-snapshots.md:212
msgid "As expected, the `height` and `width` fields of the `rec` variable have been swapped."
msgstr "正如预期的那样， `rec` 变量的 `height` 和 `width` 字段被调换了。"

#: src/ch04-02-references-and-snapshots.md:214
msgid "### Small recap"
msgstr "### 小结"

#: src/ch04-02-references-and-snapshots.md:216
msgid "Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr "让我们回顾一下我们已经讨论过的关于所有权、快照和引用的内容："

#: src/ch04-02-references-and-snapshots.md:218
msgid ""
"- At any given time, a variable can only have one owner.\n"
"- You can pass a variable by-value, by-snapshot, or by-reference to a function.\n"
"- If you pass-by-value, ownership of the variable is transferred to the function.\n"
"- If you want to keep ownership of the variable and know that your function won’t mutate it, you can pass it as a snapshot with `@`.\n"
"- If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"- 在任何时候，一个变量只能有一个所有者。\n"
"- 你可以将一个变量以值的方式、以快照的方式、或以引用的方式传递给一个函数。\n"
"- 如果你按值传递，变量的所有权就会转移到函数中。\n"
"- 如果你想保留变量的所有权，并且知道你的函数不会改变它，你可以用`@`把它作为一个快照传递。\n"
"- 如果你想保留变量的所有权，并且知道你的函数会改变它，你可以用`ref`把它作为一个可改变的引用来传递。"

#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "# Using Structs to Structure Related Data"
msgstr "# 使用结构体组织相关联的数据"

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you’re familiar with an object-"
"oriented language, a struct is like an object’s data attributes. In this chapter, we’ll compare and contrast tuples with structs to build on what you already know and demonstrate "
"when structs are a better way to group data."
msgstr ""
"结构体（ _struct_ ），或称 _structure_ ，是一种自定义的数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，struct 就像对象中的数据属性。在本"
"章中，我们会对元组和结构体进行比较和对比，并演示什么时候结构体是一种更好的数据分组方式。"

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, especially the kind of associated functions called methods, to specify "
"behavior associated with a struct type. Structs and enums (discussed in the next chapter) are the building blocks for creating new types in your program’s domain to take full "
"advantage of Cairo's compile-time type checking."
msgstr ""
"我们还将演示如何定义和实例化结构体，并讨论如何定义关联函数，特别是被称为 _方法_ 的关联函数，以指定与结构体类型相关的行为。你可以在程序中基于结构体和枚举（enum）（将在下一章讨论）创建"
"新类型，以充分利用 Cairo 的编译时类型检查。"

#: src/ch05-01-defining-and-instantiating-structs.md:1
msgid "# Defining and Instantiating Structs"
msgstr "# 结构体的定义和实例化"

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-types.md) section, in that both hold multiple related values. Like tuples, the pieces of a struct can be "
"different types. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than "
"tuples: you don’t have to rely on the order of the data to specify or access the values of an instance."
msgstr ""
"结构体与[数据类型](ch02-02-data-types.md)一节中讨论的元组类似，它们都包含多个相关的值。和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据以便能清楚的表"
"明其值的意义。由于有了这些命名，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。"

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, "
"inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"定义结构体，需要使用 `struct` 关键字并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分数据的名字和类型，我们称为 字段（field）。例"
"如，示例 5-1 展示了一个存储用户账号信息的结构体。"

#: src/ch05-01-defining-and-instantiating-structs.md:9
msgid ""
"```rust, noplayground\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"```"
msgstr ""
"```rust, noplayground\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"```"

#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "<span class=\"caption\">Listing 5-1: A `User` struct definition</span>"
msgstr "<span class=\"caption\">示例5-1：一个 `User` 结构定义</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that struct by specifying concrete values for each of the fields.\n"
"We create an instance by stating the name of the struct and then add curly brackets containing _key: value_ pairs, where the keys are the names of the fields and the values are the "
"data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a "
"general template for the type, and instances fill in that template with particular data to create values of the type."
msgstr ""
"一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的 *实例*。\n"
"我们创建一个实例需要以结构体的名字开头，接着在大括号中使用 `key: value` 键 - 值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。实例中字段的顺序不需要和它们"
"在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。"

#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 5-2."
msgstr "例如，我们可以如示例5-2所示声明一个特定的用户。"

#: src/ch05-01-defining-and-instantiating-structs.md:28
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"    };\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"    };\n"
"}\n"
"\n"
"```"

#: src/ch05-01-defining-and-instantiating-structs.md:44
msgid "<span class=\"caption\">Listing 5-2: Creating an instance of the `User` struct</span>"
msgstr "<span class=\"caption\">示例5-2：创建一个`User`结构的实例</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:46
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to access this user’s email address, we use `user1.email`. If the instance is mutable, we can change a value "
"by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the `email` field of a mutable `User` instance."
msgstr ""
"为了从结构体中获取某个特定的值，可以使用点号。举个例子，想要用户的邮箱地址，可以用 `user1.email`。如果结构体的实例是可变的，我们可以使用点号并为对应的字段赋值。示例 5-3 展示了如何改变"
"一个可变的 `User` 实例中 `email` 字段的值。"

#: src/ch05-01-defining-and-instantiating-structs.md:50
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"    };\n"
"    user1.email = 'anotheremail@example.com';\n"
"}\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"    };\n"
"    user1.email = 'anotheremail@example.com';\n"
"}\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch05-01-defining-and-instantiating-structs.md:76
msgid "<span class=\"caption\">Listing 5-3: Changing the value in the email field of a `User` instance</span>"
msgstr "<span class=\"caption\">示例5-3：改变`User`实例的电子邮件字段中的值</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:78
msgid "Note that the entire instance must be mutable; Cairo doesn’t allow us to mark only certain fields as mutable."
msgstr "注意，整个实例必须是可变的；Cairo不允许我们只把某些字段标记为可变的。"

#: src/ch05-01-defining-and-instantiating-structs.md:80
msgid "As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance."
msgstr "与任何表达式一样，我们可以在函数主体的最后一个表达式中构造一个新的结构体实例，以隐式返回该新实例。"

#: src/ch05-01-defining-and-instantiating-structs.md:82
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance with the given email and username. The `active` field gets the value of `true`, and the `sign_in_count` gets "
"a value of `1`."
msgstr "示例5-4显示了一个`build_user`函数，该函数返回一个`User`实例，并给出了电子邮件和用户名。`active`字段的值为`true`，`sign_in_count`的值为`1`。"

#: src/ch05-01-defining-and-instantiating-structs.md:86
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"}\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"}\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch05-01-defining-and-instantiating-structs.md:112
msgid "<span class=\"caption\">Listing 5-4: A `build_user` function that takes an email and username and returns a `User` instance</span>"
msgstr "<span class=\"caption\">示例5-4：一个`build_user`函数，接收电子邮件和用户名，并返回一个`User`实例</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:114
msgid ""
"It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the `email` and `username` field names and variables is a bit tedious. If "
"the struct had more fields, repeating each name would get even more annoying. Luckily, there’s a convenient shorthand!"
msgstr ""
"为函数参数起与结构体字段相同的名字是可以理解的，但必须重复`email`和`username`字段的名称和变量就有点乏味了。如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语"
"法！"

#: src/ch05-01-defining-and-instantiating-structs.md:116
msgid "## Using the Field Init Shorthand"
msgstr "## 使用字段初始化简写语法"

#: src/ch05-01-defining-and-instantiating-structs.md:118
msgid ""
"Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field init shorthand syntax to rewrite `build_user` so it behaves exactly "
"the same but doesn’t have the repetition of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"因为示例 5-4 中的参数名与字段名都完全相同，我们可以使用字段初始化简写语法（field init shorthand）来重写 `build_user`。如示例 5-5 所示，重写后其行为与之前完全相同，不过无需重复 "
"`username` 和 `email` 了。"

#: src/ch05-01-defining-and-instantiating-structs.md:122
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"fn build_user_short(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username, email, sign_in_count: 1, }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: 1, }\n"
"# }\n"
"# \n"
"fn build_user_short(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username, email, sign_in_count: 1, }\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch05-01-defining-and-instantiating-structs.md:148
msgid ""
"<span class=\"caption\">Listing 5-5: A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields</span>"
msgstr "<span class=\"caption\">示例5-5: `build_user`函数使用了字段初始化简写语法，因为`username`和`email`参数与结构体字段同名，</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:150
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field named `email`. We want to set the `email` field’s value to the value in the `email` parameter of the "
"`build_user` function. Because the `email` field and the `email` parameter have the same name, we only need to write `email` rather than `email: email`."
msgstr ""
"这里，我们正在创建一个新的 `User` 结构体实例，它有一个名为 `email`的字段。我们希望将`email`字段的值设置为`build_user`函数的`email`参数中的值。因为`email`字段和`email`参数有相同的名"
"字，我们只需要写`email`而不是`email: email`。"

#: src/ch05-02-an-example-program-using-structs.md:1
msgid "# An Example Program Using Structs"
msgstr "# 结构体示例程序"

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that calculates the area of a rectangle. We’ll start by using single variables, and then refactor the program "
"until we’re using structs instead."
msgstr "为了理解何时会需要使用结构体，让我们编写一个计算长方形面积的程序。我们会从单独的变量开始，接着重构程序直到使用结构体替代他们为止。"

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-6 "
"shows a short program with one way of doing exactly that in our project’s _src/lib.cairo_."
msgstr ""
"让我们用Scarb创建一个名为 _rectangles_ 的新项目，它获取以像素为单位的长方形的宽度和高度，并计算出长方形的面积。示例5-6显示了位于项目中的 _src/lib.cairo_ 中的小程序，它刚好实现此功能。"

#: src/ch05-02-an-example-program-using-structs.md:9
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let width = 30;\n"
"    let height = 10;\n"
"    let area = area(width, height);\n"
"    area.print();\n"
"}\n"
"\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"    width * height\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let width = 30;\n"
"    let height = 10;\n"
"    let area = area(width, height);\n"
"    area.print();\n"
"}\n"
"\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"    width * height\n"
"}\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:23
msgid "<span class=\"caption\">Listing 5-6: Calculating the area of a rectangle specified by separate width and height variables</span>"
msgstr "<span class=\"caption\">示例5-6：通过分别指定长方形的宽和高的变量来计算长方形面积</span>"

#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run`:"
msgstr "现在用`scarb cairo-run`运行该程序："

#: src/ch05-02-an-example-program-using-structs.md:27
msgid ""
"```bash\n"
"$ scarb cairo-run\n"
"[DEBUG] ,                               (raw: 300)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```bash\n"
"$ scarb cairo-run\n"
"[DEBUG] ,                               (raw: 300)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:34
msgid "This code succeeds in figuring out the area of the rectangle by calling the `area` function with each dimension, but we can do more to make this code clear and readable."
msgstr "这段代码通过调用每个维度的`area`函数，成功地算出了矩形的面积，但我们仍然可以修改这段代码来使它的意义更加明确，并且增加可读性。"

#: src/ch05-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "这段代码的问题在 `area` 的签名中很明显："

#: src/ch05-02-an-example-program-using-structs.md:38
msgid ""
"```rust,noplayground\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and it’s not clear anywhere in our program that the parameters "
"are related. It would be more readable and more manageable to group width and height together. We’ve already discussed one way we might do that in [Chapter 2](ch02-02-data-types."
"html#the-tuple-type): using tuples."
msgstr ""
"`area`函数应该是计算一个矩形的面积，但是我们写的函数有两个参数，而且在我们的程序中没有任何地方明确说明这些参数的关系。如果把宽度和高度放在一起，会更有可读性，也更容易管理。我们已经在"
"[第二章](ch02-02-data-types.html#the-tuple-type)中讨论了一种我们可以做到的方法：使用元组。"

#: src/ch05-02-an-example-program-using-structs.md:44
msgid "## Refactoring with Tuples"
msgstr "## 使用元组重构"

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr "示例5-7显示了我们使用元组的另一个程序版本。"

#: src/ch05-02-an-example-program-using-structs.md:50
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30, 10);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x, y) = dimension;\n"
"    x * y\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30, 10);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x, y) = dimension;\n"
"    x * y\n"
"}\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:64
msgid "<span class=\"caption\">Listing 5-7: Specifying the width and height of the rectangle with a tuple</span>"
msgstr "<span class=\"caption\">示例5-7：用一个元组指定矩形的宽度和高度</span>"

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one argument. But in another way, this version is less clear: tuples don’t name "
"their elements, so we have to index into the parts of the tuple, making our calculation less obvious."
msgstr ""
"在某种程度上说，这个程序更好一点了。元组帮助我们增加了一些结构性，并且现在只需传一个参数。不过在另一方面，这个版本却有一点不明确了：元组并没有给出元素的名称，所以计算变得更费解了，因"
"为不得不使用索引来获取元组的每一部分。"

#: src/ch05-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but if we want to calculate the difference, it would matter! We would have to keep in mind that `width` is "
"the tuple index `0` and `height` is the tuple index `1`. This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we haven’t "
"conveyed the meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"混淆宽度和高度对于计算面积来说并不重要，但是如果我们想计算差值，那就很重要了。我们必须记住 `width` 是元组索引`0`， `height` 是元组索引`1`。如果其他人要使用这些代码，他们必须要搞清楚这"
"一点，并也要牢记于心。很容易忘记或者混淆这些值而造成错误，因为我们没有在代码中传达数据的意图。"

#: src/ch05-02-an-example-program-using-structs.md:70
msgid "## Refactoring with Structs: Adding More Meaning"
msgstr "## 使用结构体重构：赋予更多意义"

#: src/ch05-02-an-example-program-using-structs.md:72
msgid "We use structs to add meaning by labeling the data. We can transform the tuple we’re using into a struct with a name for the whole as well as names for the parts."
msgstr "我们使用结构体为数据命名来为其赋予意义。我们可以将我们正在使用的元组转换成一个有整体名称而且每个部分也有对应名字的结构体。"

#: src/ch05-02-an-example-program-using-structs.md:76
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:95
msgid "<span class=\"caption\">Listing 5-8: Defining a `Rectangle` struct</span>"
msgstr "<span class=\"caption\">示例 5-8：定义一个`Rectangle`结构</span>"

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly brackets, we defined the fields as `width` and `height`, both of which have type `u64`. Then, in `main`, we "
"created a particular instance of `Rectangle` that has a width of `30` and a height of `10`. Our `area` function is now defined with one parameter, which we’ve named `rectangle` which "
"is of type `Rectangle` struct. We can then access the fields of the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index values "
"of `0` and `1`."
msgstr ""
"这里我们定义了一个结构，并将其命名为 `Rectangle`。在大括号中，我们将字段定义为 `width` 和 `height`，它们的类型都是 `u64`。然后，在`main`中，我们创建了一个`Rectangle`的特殊实例，它的宽"
"度是`30`，高度是`10`。我们的 `area`函数现在定义了一个名为 `rectangle`参数，它是`Rectangle`结构类型。然后我们可以用点符号来访问实例的字段，它给这些值起了描述性的名字，而不是使用`0`和"
"`1`的元组索引值。结构体胜在更清晰明了。"

#: src/ch05-02-an-example-program-using-structs.md:99
msgid "## Adding Useful Functionality with Trait"
msgstr "## 用Trait增加实用功能"

#: src/ch05-02-an-example-program-using-structs.md:101
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re debugging our program and see the values for all its fields. Listing 5-9 tries using the `print` as we have "
"used in previous chapters. This won’t work."
msgstr "在调试程序时打印出 `Rectangle` 实例来查看其所有字段的值非常有用。示例 5-9 像前面章节那样尝试使用 `print`。但这并不管用。"

#: src/ch05-02-an-example-program-using-structs.md:105
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    rectangle.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    rectangle.print();\n"
"}\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:119
msgid "<span class=\"caption\">Listing 5-9: Attempting to print a `Rectangle` instance</span>"
msgstr "<span class=\"caption\">示例 5-9：试图打印一个 `Rectangle`实例</span>"

#: src/ch05-02-an-example-program-using-structs.md:121
msgid "When we compile this code, we get an error with this message:"
msgstr "当我们编译这段代码时，我们得到了一个错误，有这样的信息："

#: src/ch05-02-an-example-program-using-structs.md:123
msgid ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:133
msgid ""
"The `print` trait is implemented for many data types, but not for the `Rectangle` struct. We can fix this by implementing the `PrintTrait` trait on `Rectangle` as shown in Listing "
"5-10.\n"
"To learn more about traits, see [Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""
"许多数据类型都实现了 `print` trait，但 `Rectangle` 结构没有。我们可以通过在`Rectangle`上实现`PrintTrait` trait来解决这个问题，如示例5-10所示。\n"
"要了解更多关于traits的信息，请参阅[Traits in Cairo](ch08-02-traits-in-cairo.md)。"

#: src/ch05-02-an-example-program-using-structs.md:138
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    rectangle.print();\n"
"}\n"
"\n"
"impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
"    fn print(self: Rectangle) {\n"
"        self.width.print();\n"
"        self.height.print();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    rectangle.print();\n"
"}\n"
"\n"
"impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
"    fn print(self: Rectangle) {\n"
"        self.width.print();\n"
"        self.height.print();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:161
msgid "<span class=\"caption\">Listing 5-10: Implementing the `PrintTrait` trait on `Rectangle`</span>"
msgstr "<span class=\"caption\">示例5-10：在`Rectangle`上实现`PrintTrait` trait</span>"

#: src/ch05-02-an-example-program-using-structs.md:163
msgid "Nice! It’s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging."
msgstr "很好!这不是最漂亮的输出，但它显示了这个实例的所有字段的值，这在调试时肯定会有帮助。"

#: src/ch05-03-method-syntax.md:1
msgid "## Method Syntax"
msgstr "## 方法语法(Method Syntax)"

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword and a\n"
"name, they can have parameters and a return value, and they contain some code\n"
"that’s run when the method is called from somewhere else. Unlike functions,\n"
"methods are defined within the context of a type and their first parameter is\n"
"always `self`, which represents the instance of the type the method is being\n"
"called on. For those familiar with Rust, Cairo's approach might be confusing,\n"
"as methods cannot be defined directly on types. Instead, you must define a trait\n"
"and an implementation associated with the type for which the method is intended."
msgstr ""
"_方法_（method）与函数类似：它们使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义，并"
"且它们第一个参数总是 `self`，它代表调用该方法的结构体实例。\n"
"对于那些熟悉Rust的人来说，Cairo的方法可能会令人困惑，因为方法不能被直接定义在类型上。\n"
"相反，你必须定义一个trait和一个与该方法所在类型相关的实现。"

#: src/ch05-03-method-syntax.md:12
msgid "### Defining Methods"
msgstr "### 定义方法"

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a parameter\n"
"and instead make an `area` method defined on the `RectangleTrait` trait, as shown\n"
"in Listing 5-13."
msgstr ""
"让我们把前面实现的获取一个 `Rectangle` 实例作为参数的 `area` 函数，\n"
"改写成一个定义于 `RectangleTrait` trait 上的 `area` 方法，如示例5-13所示。"

#: src/ch05-03-method-syntax.md:20
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"\n"
"    rect1.area().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"\n"
"    rect1.area().print();\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:45
msgid ""
"<span class=\"caption\">Listing 5-13: Defining an `area` method to use on the\n"
"`Rectangle` </span>"
msgstr "<span class=\"caption\">示例5-13：定义一个用在`Rectangle` 上的 `area` 方法 </span>"

#: src/ch05-03-method-syntax.md:48
msgid ""
"To define the function within the context of `Rectangle`, we start by defining a `trait`\n"
"block with the signature of the method that we want to implement. Traits are not linked to\n"
"a specific type; only the `self` parameter of the method defines which type it can be used\n"
"with. Then, we define an `impl` (implementation) block for `RectangleTrait`, that defines\n"
"the behavior of the methods implemented. Everything within this `impl` block will be\n"
"associated with the type of the `self` parameter of the method called. While it is technically\n"
"possible to define methods for multiple types within the same `impl` block, it is not\n"
"a recommended practice, as it can lead to confusion. We recommend that the type of the `self` parameter\n"
"stays consistent within the same `impl` block.\n"
"Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, only)\n"
"parameter to be `self` in the signature and everywhere within the body. In\n"
"`main`, where we called the `area` function and passed `rect1` as an argument,\n"
"we can instead use the _method syntax_ to call the `area` method on our `Rectangle`\n"
"instance. The method syntax goes after an instance: we add a dot followed by\n"
"the method name, parentheses, and any arguments."
msgstr ""
"为了使函数定义于 `Rectangle` 的上下文中，我们开始了一个 `trait` 块，其中包含我们想要实现的方法的签名。\n"
"Traits 并不与一个特定的类型所链接；只有方法的 `self` 参数定义了它可以用于哪种类型。然后，我们为 `RectangleTrait` 定义一个 `impl`（实现）块，它定义了实现的方法的行为。\n"
"这个 `impl` 块中的所有内容都将与被调用方法的 `self` 参数的类型相关。虽然在技术上可以在同一个 `impl` 块中定义多种类型的方法，但这并不是一个值得推荐的做法。\n"
"因为它可能会导致混乱。我们建议`self`参数的类型在同一个 `impl` 块中保持一致。\n"
"然后我们将`area`函数移到`impl`大括号内，并在签名和正文的所有地方将第一个（在本例中是唯一的）参数改为`self`。在`main`中，我们调用`area`函数并传递`rect1`作为参数、\n"
"\n"
"我们可以使用 _method syntax_ 在我们的`Rectangle`实例上调用`area`方法。\n"
"方法语法是：在一个实例的后面，加上一个点号，后跟方法名、圆括号以及任何参数。"

#: src/ch05-03-method-syntax.md:64
msgid ""
"Methods must have a parameter named `self` of the type they will be applied to for their first parameter.\n"
"Note that we used the `@` snapshot operator in front of the `Rectangle` type in the function signature.\n"
"By doing so, we indicate that this method takes an immutable snapshot of the `Rectangle` instance, which is\n"
"automatically created by the compiler when passing the instance to the method.\n"
"Methods can take ownership of `self`, use `self` with snapshots as we’ve done here, or use a mutable reference to `self`\n"
"using the `ref self: T` syntax."
msgstr ""
"方法必须有一个名为 `self` 的类型参数作为它们将要应用的类型的第一个参数。请注意，我们在函数签名中在 `Rectangle` 类型前面使用了 `@` 快照运算符。这样做，我们表示此方法获取 `Rectangle` 实"
"例的不可变快照，编译器在将实例传递给该方法时会自动创建。方法可以获取 `self` 实例的所有权，像我们在这里所做的那样使用快照的 `self`，或使用 `ref self: T` 语法使用 `self` 的可变引用。"

#: src/ch05-03-method-syntax.md:71
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in the function\n"
"version: we don’t want to take ownership, and we just want to read the data in\n"
"the struct, not write to it. If we wanted to change the instance that we’ve\n"
"called the method on as part of what the method does, we’d use `ref self: Rectangle` as\n"
"the first parameter. Having a method that takes ownership of the instance by\n"
"using just `self` as the first parameter is rare; this technique is usually\n"
"used when the method transforms `self` into something else and you want to\n"
"prevent the caller from using the original instance after the transformation."
msgstr ""
"我们在这里选择 `self: @Rectangle` 与函数版本中使用 `@Rectangle` 的原因相同：我们不想要所有权，只是想读取结构体中的数据，而不是对它进行写入。如果我们想要作为方法的一部分更改调用方法的"
"实例，我们将使用 `ref self: Rectangle` 作为第一个参数。通过仅使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 `self` 转换成别的实例的时候，这时我"
"们想要防止调用者在转换之后使用原始的实例。"

#: src/ch05-03-method-syntax.md:80
msgid ""
"Observe the use of the desnap operator `*` within the area method when accessing the struct's members.\n"
"This is necessary because the struct is passed as a snapshot, and all of its field values are of type `@T`,\n"
"requiring them to be desnapped in order to manipulate them."
msgstr ""
"在访问结构体的成员时，请注意在区域方法中使用 _desnap_ 操作符`*`。\n"
"这是必要的，因为该结构是以快照形式传递的，其所有字段值都是`@T`类型、\n"
"需要对它们进行解快照，以便对其进行操作。"

#: src/ch05-03-method-syntax.md:84
msgid ""
"The main reason for using methods instead of functions is for organization and code clarity. We’ve put all the things we can do with an instance of a type in one combination of "
"`trait` & `impl` blocks, rather than making future users\n"
"of our code search for capabilities of `Rectangle` in various places in the\n"
"library we provide. However, we can define multiple combinations of `trait` & `impl` blocks for the same type at different places, which can be useful for a more granular code "
"organization. For example, you could implement\n"
"the `Add` trait for your type in one `impl` block, and the `Sub` trait in another block."
msgstr ""
"使用方法而不是函数的主要原因是为了组织和代码的清晰性。我们把所有我们能对一个类型的实例做的操作都放在一组`trait`和`impl`块的组合中，而不是让未来的用户在我们提供的库中的不同地方搜索 "
"`Rectangle`的函数。\n"
"然而，我们可以在不同的地方为同一类型定义多个`trait`和`impl`块的组合，这对更细化的代码组织很有用。例如，你可以在一个`impl`块中为你的类型实现 `impl` trait ，在另一个块中实现 `Sub` "
"trait 。"

#: src/ch05-03-method-syntax.md:89
msgid ""
"Note that we can choose to give a method the same name as one of the struct’s\n"
"fields. For example, we can define a method on `Rectangle` that is also named\n"
"`width`:"
msgstr "请注意，我们可以选择将方法的名称与结构中的一个字段相同。例如，我们可以在 `Rectangle` 上定义一个方法，并命名为`width`："

#: src/ch05-03-method-syntax.md:95
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool {\n"
"        (*self.width) > 0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"    rect1.width().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool {\n"
"        (*self.width) > 0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"    rect1.width().print();\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:119
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value in\n"
"the instance’s `width` field is greater than `0` and `false` if the value is\n"
"`0`: we can use a field within a method of the same name for any purpose. In\n"
"`main`, when we follow `rect1.width` with parentheses, Cairo knows we mean the\n"
"method `width`. When we don’t use parentheses, Cairo knows we mean the field\n"
"`width`."
msgstr ""
"在这里，我们选择让`width`方法在实例的`width`字段中的值大于0时返回`true`，在值为0时返回`false` ：我们可以在同名方法的字段内使用任何目的。在`main`中，当我们在`rect1.width`后面跟着括号"
"时，Cairo知道我们意思是`width`方法。当我们不使用括号时，Cairo知道我们指的是`width`字段。"

#: src/ch05-03-method-syntax.md:126
msgid "### Methods with More Parameters"
msgstr "### 带有更多参数的方法"

#: src/ch05-03-method-syntax.md:128
msgid ""
"Let’s practice using methods by implementing a second method on the `Rectangle`\n"
"struct. This time we want an instance of `Rectangle` to take another instance\n"
"of `Rectangle` and return `true` if the second `Rectangle` can fit completely\n"
"within `self` (the first `Rectangle`); otherwise, it should return `false`.\n"
"That is, once we’ve defined the `can_hold` method, we want to be able to write\n"
"the program shown in Listing 5-14."
msgstr ""
"让我们通过在`Rectangle`结构体上实现第二个方法来练习使用方法。这次，我们希望让`Rectangle`的实例接收另一个`Rectangle`的实例。如果第二个`Rectangle`可以完全适应`self` （第一个"
"`Rectangle`）就返回 `true` ; 否则，它应该返回`false`。也就是说，一旦我们定义了`can_hold`方法，我们希望能够编写示例5-14中显示的程序。"

#: src/ch05-03-method-syntax.md:137
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"    let rect2 = Rectangle { width: 10, height: 40, };\n"
"    let rect3 = Rectangle { width: 60, height: 45, };\n"
"\n"
"    'Can rect1 hold rect2?'.print();\n"
"    rect1.can_hold(@rect2).print();\n"
"\n"
"    'Can rect1 hold rect3?'.print();\n"
"    rect1.can_hold(@rect3).print();\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50, };\n"
"    let rect2 = Rectangle { width: 10, height: 40, };\n"
"    let rect3 = Rectangle { width: 60, height: 45, };\n"
"\n"
"    'Can rect1 hold rect2?'.print();\n"
"    rect1.can_hold(@rect2).print();\n"
"\n"
"    'Can rect1 hold rect3?'.print();\n"
"    rect1.can_hold(@rect3).print();\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:158
msgid ""
"<span class=\"caption\">Listing 5-14: Using the as-yet-unwritten `can_hold`\n"
"method</span>"
msgstr "<span class=\"caption\">示例5-14：使用尚未编写的`can_hold`方法</span>"

#: src/ch05-03-method-syntax.md:161
msgid ""
"The expected output would look like the following because both dimensions of\n"
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider than\n"
"`rect1`:"
msgstr ""
"预期的输出结果如下，因为`rect2`的两个尺寸都小于`rect1`的尺寸。\n"
"但`rect3`的宽度大于`rect1`："

#: src/ch05-03-method-syntax.md:165
msgid ""
"```text\n"
"$ scarb cairo-run\n"
"[DEBUG]\tCan rec1 hold rect2?           \t(raw: 384675147322001379018464490539350216396261044799)\n"
"\n"
"[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
"\n"
"[DEBUG]\tCan rect1 hold rect3?          \t(raw: 384675147322001384331925548502381811111693612095)\n"
"\n"
"[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
"\n"
"```"
msgstr ""
"```text\n"
"$ scarb cairo-run\n"
"[DEBUG]\tCan rec1 hold rect2?           \t(raw: 384675147322001379018464490539350216396261044799)\n"
"\n"
"[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
"\n"
"[DEBUG]\tCan rect1 hold rect3?          \t(raw: 384675147322001384331925548502381811111693612095)\n"
"\n"
"[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
"\n"
"```"

#: src/ch05-03-method-syntax.md:177
msgid ""
"We know we want to define a method, so it will be within the `trait RectangleTrait`\n"
"and `impl RectangleImpl of RectangleTrait` blocks.\n"
"The method name will be `can_hold`, and it will take a snapshot\n"
"of another `Rectangle` as a parameter. We can tell what the type of the\n"
"parameter will be by looking at the code that calls the method:\n"
"`rect1.can_hold(@rect2)` passes in `@rect2`, which is a snapshot to\n"
"`rect2`, an instance of `Rectangle`. This makes sense because we only need to\n"
"read `rect2` (rather than write, which would mean we’d need a mutable borrow),\n"
"and we want `main` to retain ownership of `rect2` so we can use it again after\n"
"calling the `can_hold` method. The return value of `can_hold` will be a\n"
"Boolean, and the implementation will check whether the width and height of\n"
"`self` are greater than the width and height of the other `Rectangle`,\n"
"respectively. Let’s add the new `can_hold` method to the `trait` and `impl` blocks from\n"
"Listing 5-13, shown in Listing 5-15."
msgstr ""
"我们需要定义一个方法，将它放置在在`trait RectangleTrait`和`impl RectangleImpl of RectangleTrait` 块中。该方法名为 `can_hold`，它将接收另一个`Rectangle`的快照作为参数。我们可以通过查看"
"调用该方法的代码来确定参数的类型：`rect1.can_hold(@rect2)`将`@rect2`作为快照传递给`rect2`，它是`Rectangle`的一个实例。这是有意义的，因为我们只需要读取`rect2`（而不是写入，这意味着我们"
"需要一个可变借用），我们希望`main`保留对`rect2`的所有权，以便在调用`can_hold` 方法后再次使用它。`can_hold` 的返回值将是一个布尔值，实现将检查`self`的宽度和高度是否分别大于另一"
"`Rectangle`的宽度和高度。让我们将新的`can_hold`方法添加到示例5-13中的`trait`和`impl` 块中，如示例5-15所示。"

#: src/ch05-03-method-syntax.md:194 src/ch09-01-how-to-write-tests.md:120
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:211
msgid ""
"<span class=\"caption\">Listing 5-15: Implementing the `can_hold` method on\n"
"`Rectangle` that takes another `Rectangle` instance as a parameter</span>"
msgstr "<span class=\"caption\">示例5-15: 在`Rectangle`上实现`can_hold`方法，该方法接收另一个`Rectangle`实例作为参数</span>"

#: src/ch05-03-method-syntax.md:214
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get our\n"
"desired output. Methods can take multiple parameters that we add to the\n"
"signature after the `self` parameter, and those parameters work just like\n"
"parameters in functions."
msgstr ""
"当我们在示例 5-14中的`main`函数中运行这段代码时，我们将得到我们想要的输出。\n"
"方法可以接收多个参数，我们可以在`self`参数之后在函数签名中添加这些参数，这些参数与函数中的参数工作原理相同。"

#: src/ch05-03-method-syntax.md:219
msgid "### Accessing implementation functions"
msgstr "### 访问实现里的函数"

#: src/ch05-03-method-syntax.md:221
msgid ""
"All functions defined within a `trait` and `impl` block can be directly addressed\n"
"using the `::` operator on the implementation name.\n"
"Functions in traits that aren’t methods are often used for constructors that\n"
"will return a new instance of the struct. These are often called `new`, but\n"
"`new` isn’t a special name and isn’t built into the language. For example, we\n"
"could choose to provide an associated function named `square` that would have\n"
"one dimension parameter and use that as both width and height, thus making it\n"
"easier to create a square `Rectangle` rather than having to specify the same\n"
"value twice:"
msgstr ""
"所有在`trait`和`impl` 块中定义的函数可以直接使用`::` 运算符在实现名称上进行访问。\n"
"在`trait`中的不是方法的函数通常用于构造函数，以返回一个结构体的新实例。\n"
"这些函数通常被称为`new`，但`new`不是一个特殊的名称，也不是内置到语言中的。\n"
"例如，我们可以选择提供一个名为`square` 的关联函数，它将具有一个维度参数，\n"
"并将其用作宽度和高度，从而更容易地创建一个正方形`Rectangle`，而不必指定两次相同的值："

#: src/ch05-03-method-syntax.md:233
msgid ""
"```rust,noplayground\n"
"trait RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle {\n"
"        Rectangle { width: size, height: size }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle {\n"
"        Rectangle { width: size, height: size }\n"
"    }\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:245
msgid ""
"To call this function, we use the `::` syntax with the implementation name;\n"
"`let square = RectangleImpl::square(10);` is an example. This function is namespaced by\n"
"the implementation; the `::` syntax is used for both trait functions and\n"
"namespaces created by modules. We’ll discuss modules in [Chapter 8][modules]<!-- ignore -->."
msgstr ""
"为了调用这个函数，我们在实现的名称后面使用`::`语法；\n"
"比如`let square = RectangleImpl::square(10);` 这个例子。这个函数的位于其实现的命名空间中；`::`语法用于关联trait的函数和模块创建的命名空间。\n"
"我们将在 [Chapter 8][modules]<！--ignore-->中讲到模块。"

#: src/ch05-03-method-syntax.md:250
msgid "> Note: It is also possible to call this function using the trait name, with `RectangleTrait::square(10)`."
msgstr "> 注意：也可以用trait名称 `RectangleTrait::square(10)` 来调用这个函数。"

#: src/ch05-03-method-syntax.md:252
msgid "### Multiple `impl` Blocks"
msgstr "### 多个`impl`块"

#: src/ch05-03-method-syntax.md:254
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For example, Listing\n"
"5-15 is equivalent to the code shown in Listing 5-16, which has each method in\n"
"its own `trait` and `impl` blocks."
msgstr "每个结构体都可以有多个`trait` 和`impl`块。例如，示例5-15等价于示例5-16中展示的代码，其中每个方法都有自己的`trait` 和`impl`块。"

#: src/ch05-03-method-syntax.md:258
msgid ""
"```rust,noplayground\n"
"trait RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"impl RectangleCalcImpl of RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"trait RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleCmpImpl of RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"impl RectangleCalcImpl of RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"trait RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleCmpImpl of RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch05-03-method-syntax.md:279
msgid ""
"<span class=\"caption\">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`\n"
"blocks</span>"
msgstr ""
"<span class=\"caption\">示例5-16：使用多个`impl`重写示例5-15\n"
"块</span>"

#: src/ch05-03-method-syntax.md:282
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` blocks here,\n"
"but this is valid syntax. We’ll see a case in which multiple blocks are\n"
"useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where we discuss generic types and traits."
msgstr ""
"这里没有理由把这些方法分成多个`trait`和`impl`块，\n"
"但这是有效的语法。我们将在[第7章](ch08-00-generic-types-and-traits.md)中看到一个多块的情况，在那里我们讨论泛型和trait。"

#: src/ch05-03-method-syntax.md:288
msgid ""
"Structs let you create custom types that are meaningful for your domain. By\n"
"using structs, you can keep associated pieces of data connected to each other\n"
"and name each piece to make your code clear. In `trait` and `impl` blocks, you can define\n"
"methods, which are functions associated to a type and let you specify the behavior that instances of your\n"
"type have."
msgstr ""
"结构体让你可以创建出在你的领域中有意义的自定义类型。\n"
"通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。\n"
"在`trait`和`impl`块中，你可以定义与你的类型相关联的方法，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。"

#: src/ch05-03-method-syntax.md:294
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to\n"
"Cairo’s enum feature to add another tool to your toolbox."
msgstr "但结构体并不是创建自定义类型的唯一方法：让我们转向 Cairo 的枚举功能，为你的工具箱再添一个工具。"

#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "# Enums and Pattern Matching"
msgstr "# 枚举和模式匹配"

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at *enumerations*, also referred to as *enums*.\n"
"Enums allow you to define a type by enumerating its possible *variants*. First,\n"
"we’ll define and use an enum to show how an enum can encode meaning along with\n"
"data. Next, we’ll explore a particularly useful enum, called `Option`, which\n"
"expresses that a value can be either something or nothing. Finally, we’ll look at\n"
"how pattern matching in the `match` expression makes it easy to run different\n"
"code for different values of an enum."
msgstr ""
"在本章中，我们将介绍 *枚举(enumerations)* ，也称为 *enums* 。\n"
"枚举允许您通过枚举其可能的  *variants*  来定义类型。\n"
"首先我们将定义并使用枚举来展示枚举如何对含义进行编码以及数据。\n"
"接下来，我们将探索一个特别有用的枚举，称为`Option`，\n"
"它的表示值可以是某物，也可以是虚无。\n"
"最后，我们来看看`match`表达式中，如何使用模式匹配，\n"
"使得我们可以很容易的通过不同的枚举值运行不同的代码。"

#: src/ch06-00-enums-and-pattern-matching.md:11
msgid "<footer id=\"last-change\">Last change: 2023-10-13</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-13</footer>"

#: src/ch06-01-enums.md:1
msgid "# Enums"
msgstr "# 枚举"

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type that consists of a fixed set of named values, called _variants_. Enums are useful for representing a "
"collection of related values where each value is distinct and has a specific meaning."
msgstr ""
"本章介绍 \"枚举\"（enumerations），也被称作 enums，是一种自定义数据类型的方式，它由一组固定的命名值成员组成，称为 _variants_ 。枚举对于表示相关值的集合非常有用，其中每个值都是不同的，"
"并且有特定的含义。"

#: src/ch06-01-enums.md:5
msgid "## Enum Variants and Values"
msgstr "## 枚举成员和值"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "下面是一个枚举的简单例子："

#: src/ch06-01-enums.md:9
msgid ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum Direction {\n"
"    North,\n"
"    East,\n"
"    South,\n"
"    West,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum Direction {\n"
"    North,\n"
"    East,\n"
"    South,\n"
"    West,\n"
"}\n"
"```"

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each "
"variant represents a distinct value of the Direction type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:"
msgstr ""
"在本例中，我们定义了一个名为 `Direction` 的枚举，它有四个变量：`North`, `East`, `South` 和 `West`。命名惯例是使用 PascalCase 来命名枚举变量。每个变量代表 Direction 类型的一个不同值。"
"在本示例中，枚举成员没有任何关联值。使用此语法可以实例化一个变量："

#: src/ch06-01-enums.md:21
msgid ""
"```rust\n"
"# #[derive(Drop)]\n"
"# enum Direction {\n"
"#     North,\n"
"#     East,\n"
"#     South,\n"
"#     West,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"    let direction = Direction::North;\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Drop)]\n"
"# enum Direction {\n"
"#     North,\n"
"#     East,\n"
"#     South,\n"
"#     West,\n"
"# }\n"
"# \n"
"# fn main() {\n"
"    let direction = Direction::North;\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a Direction. You can learn more about it "
"on [The Match Control Flow Construct page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""
"我们可以很轻易的写出根据枚举的成员运行不同的流程的代码，在上面这个例子中，是根据方向来运行特定的代码。你可以在 [Match 控制流结构](ch06-02-the-match-control-flow-construct.md)页面上了"
"解更多信息。"

#: src/ch06-01-enums.md:39
msgid "## Enums Combined with Custom Types"
msgstr "## 枚举与自定义类型相结合"

#: src/ch06-01-enums.md:41
msgid "Enums can also be used to store more interesting data associated with each variant. For example:"
msgstr "枚举也可以用来存储与每个成员相关的更有趣的数据。比如说："

#: src/ch06-01-enums.md:43
msgid ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum Message {\n"
"    Quit,\n"
"    Echo: felt252,\n"
"    Move: (u128, u128),\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum Message {\n"
"    Quit,\n"
"    Echo: felt252,\n"
"    Move: (u128, u128),\n"
"}\n"
"```"

#: src/ch06-01-enums.md:52
msgid "In this example, the `Message` enum has three variants: `Quit`, `Echo` and `Move`, all with different types:"
msgstr "在这个例子中，`Message`枚举有三个成员：`Quit`、`Echo`和`Move`，都有不同的类型："

#: src/ch06-01-enums.md:54
msgid ""
"- `Quit` doesn't have any associated value.\n"
"- `Echo` is a single felt.\n"
"- `Move` is a tuple of two u128 values."
msgstr ""
"-  `Quit` 没有任何相关值。\n"
"-  `Echo` 是一个单一的 felt。\n"
"-  `Move`是两个 u128 值组成的的元组。"

#: src/ch06-01-enums.md:58
msgid "You could even use a Struct or another Enum you defined inside one of your Enum variants."
msgstr "你甚至可以在你的一个枚举成员中使用一个结构体或另一个你定义的枚举。"

#: src/ch06-01-enums.md:60
msgid "## Trait Implementations for Enums"
msgstr "## 枚举的Trait实现"

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a "
"trait and implementing it for the previous `Message` enum:"
msgstr "在Cairo中，你可以为你的自定义枚举定义trait并实现它们。这允许你定义与枚举相关的方法和行为。下面是一个定义trait并为之前的 `Message` 枚举实现的例子："

#: src/ch06-01-enums.md:64
msgid ""
"```rust,noplayground\n"
"trait Processing {\n"
"    fn process(self: Message);\n"
"}\n"
"\n"
"impl ProcessingImpl of Processing {\n"
"    fn process(self: Message) {\n"
"        match self {\n"
"            Message::Quit => { 'quitting'.print(); },\n"
"            Message::Echo(value) => { value.print(); },\n"
"            Message::Move((x, y)) => { 'moving'.print(); },\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait Processing {\n"
"    fn process(self: Message);\n"
"}\n"
"\n"
"impl ProcessingImpl of Processing {\n"
"    fn process(self: Message) {\n"
"        match self {\n"
"            Message::Quit => { 'quitting'.print(); },\n"
"            Message::Echo(value) => { value.print(); },\n"
"            Message::Move((x, y)) => { 'moving'.print(); },\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch06-01-enums.md:80
msgid "In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a Quit message:"
msgstr "在这个例子中，我们为`Message`实现了`Processing` trait。下面是如何用它来处理一条退出消息："

#: src/ch06-01-enums.md:82
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Drop)]\n"
"# enum Message {\n"
"#     Quit,\n"
"#     Echo: felt252,\n"
"#     Move: (u128, u128),\n"
"# }\n"
"# \n"
"# trait Processing {\n"
"#     fn process(self: Message);\n"
"# }\n"
"# \n"
"# impl ProcessingImpl of Processing {\n"
"#     fn process(self: Message) {\n"
"#         match self {\n"
"#             Message::Quit => { 'quitting'.print(); },\n"
"#             Message::Echo(value) => { value.print(); },\n"
"#             Message::Move((x, y)) => { 'moving'.print(); },\n"
"#         }\n"
"#     }\n"
"# }\n"
"# fn main() {\n"
"    let msg: Message = Message::Quit;\n"
"    msg.process();\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Drop)]\n"
"# enum Message {\n"
"#     Quit,\n"
"#     Echo: felt252,\n"
"#     Move: (u128, u128),\n"
"# }\n"
"# \n"
"# trait Processing {\n"
"#     fn process(self: Message);\n"
"# }\n"
"# \n"
"# impl ProcessingImpl of Processing {\n"
"#     fn process(self: Message) {\n"
"#         match self {\n"
"#             Message::Quit => { 'quitting'.print(); },\n"
"#             Message::Echo(value) => { value.print(); },\n"
"#             Message::Move((x, y)) => { 'moving'.print(); },\n"
"#         }\n"
"#     }\n"
"# }\n"
"# fn main() {\n"
"    let msg: Message = Message::Quit;\n"
"    msg.process();\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr "运行这段代码会打印出 `quitting`。"

#: src/ch06-01-enums.md:114
msgid "## The Option Enum and Its Advantages"
msgstr "## Option枚举及其优势"

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` indicates that there's a value of "
"type `T`, while `None` represents the absence of a value."
msgstr "Option枚举是一个标准的Cairo枚举，表示一个可选值的概念。它有两个变量：`Some: T` 和 `None: ()`。`Some：T`表示有一个`T`类型的值，而`None`表示没有值。"

#: src/ch06-01-enums.md:118
msgid ""
"```rust,noplayground\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None: (),\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None: (),\n"
"}\n"
"```"

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using "
"`Option` can also help prevent bugs caused by using uninitialized or unexpected `null` values."
msgstr "`Option` 枚举很有用，因为它允许你明确地表示一个值不存在的可能性，使你的代码更具表现力，更容易推理。使用 `Option` 也可以帮助防止因使用未初始化的或意外的 `null` 值而引起的错误。"

#: src/ch06-01-enums.md:127
msgid "To give you an example, here is a function which returns the index of the first element of an array with a given value, or None if the element is not present."
msgstr "为了给你一个例子，这里有一个函数，它返回一个给定值的数组中第一个元素的索引，如果该元素不存在则返回None。"

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr "我们为上述函数演示了两种方法："

#: src/ch06-01-enums.md:131
msgid ""
"- Recursive Approach `find_value_recursive`\n"
"- Iterative Approach `find_value_iterative`"
msgstr ""
"- 递归法 `find_value_recursive`\n"
"- 迭代法 `find_value_iterative`"

#: src/ch06-01-enums.md:134
msgid "> Note: in the future it would be nice to replace this example by something simpler using a loop and without gas related code."
msgstr "> 注意：将来最好能用循环和无需 gas 的相关代码的简单示例替换此示例。"

#: src/ch06-01-enums.md:136
msgid ""
"```rust,noplayground\n"
"fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: usize) -> Option<usize> {\n"
"    if index >= arr.len() {\n"
"        return Option::None;\n"
"    }\n"
"\n"
"    if *arr.at(index) == value {\n"
"        return Option::Some(index);\n"
"    }\n"
"\n"
"    find_value_recursive(arr, value, index + 1)\n"
"}\n"
"\n"
"fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> Option<usize> {\n"
"    let length = arr.len();\n"
"    let mut index = 0;\n"
"    let mut found: Option<usize> = Option::None;\n"
"    loop {\n"
"        if index < length {\n"
"            if *arr.at(index) == value {\n"
"                found = Option::Some(index);\n"
"                break;\n"
"            }\n"
"        } else {\n"
"            break;\n"
"        }\n"
"        index += 1;\n"
"    };\n"
"    return found;\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{find_value_recursive, find_value_iterative};\n"
"\n"
"    #[test]\n"
"    #[available_gas(999999)]\n"
"    fn test_increase_amount() {\n"
"        let mut my_array = ArrayTrait::new();\n"
"        my_array.append(3);\n"
"        my_array.append(7);\n"
"        my_array.append(2);\n"
"        my_array.append(5);\n"
"\n"
"        let value_to_find = 7;\n"
"        let result = find_value_recursive(@my_array, value_to_find, 0);\n"
"        let result_i = find_value_iterative(@my_array, value_to_find);\n"
"\n"
"        match result {\n"
"            Option::Some(index) => { if index == 1 {\n"
"                'it worked'.print();\n"
"            } },\n"
"            Option::None => { 'not found'.print(); },\n"
"        }\n"
"        match result_i {\n"
"            Option::Some(index) => { if index == 1 {\n"
"                'it worked'.print();\n"
"            } },\n"
"            Option::None => { 'not found'.print(); },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: usize) -> Option<usize> {\n"
"    if index >= arr.len() {\n"
"        return Option::None;\n"
"    }\n"
"\n"
"    if *arr.at(index) == value {\n"
"        return Option::Some(index);\n"
"    }\n"
"\n"
"    find_value_recursive(arr, value, index + 1)\n"
"}\n"
"\n"
"fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> Option<usize> {\n"
"    let length = arr.len();\n"
"    let mut index = 0;\n"
"    let mut found: Option<usize> = Option::None;\n"
"    loop {\n"
"        if index < length {\n"
"            if *arr.at(index) == value {\n"
"                found = Option::Some(index);\n"
"                break;\n"
"            }\n"
"        } else {\n"
"            break;\n"
"        }\n"
"        index += 1;\n"
"    };\n"
"    return found;\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{find_value_recursive, find_value_iterative};\n"
"\n"
"    #[test]\n"
"    #[available_gas(999999)]\n"
"    fn test_increase_amount() {\n"
"        let mut my_array = ArrayTrait::new();\n"
"        my_array.append(3);\n"
"        my_array.append(7);\n"
"        my_array.append(2);\n"
"        my_array.append(5);\n"
"\n"
"        let value_to_find = 7;\n"
"        let result = find_value_recursive(@my_array, value_to_find, 0);\n"
"        let result_i = find_value_iterative(@my_array, value_to_find);\n"
"\n"
"        match result {\n"
"            Option::Some(index) => { if index == 1 {\n"
"                'it worked'.print();\n"
"            } },\n"
"            Option::None => { 'not found'.print(); },\n"
"        }\n"
"        match result_i {\n"
"            Option::Some(index) => { if index == 1 {\n"
"                'it worked'.print();\n"
"            } },\n"
"            Option::None => { 'not found'.print(); },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch06-01-enums.md:202
msgid "Running this code would print `it worked`."
msgstr "运行这段代码会打印出 `it worked`。"

#: src/ch06-02-the-match-control-flow-construct.md:1
msgid "# The Match Control Flow Construct"
msgstr "# match控制流结构"

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid "<!-- TODO : update mention of chapter 18 (on patterns and matching chapter) in paragraph below -->"
msgstr "<!-- TODO : update mention of chapter 18 (on patterns and matching chapter) in paragraph below -->"

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that allows you to compare a value against a series of patterns and then execute code based on which pattern "
"matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The power of match comes from the expressiveness of the patterns and the fact "
"that the compiler confirms that all possible cases are handled."
msgstr ""
"Cairo 有一个叫做 `match` 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；第十八章会涉"
"及到所有不同种类的模式以及它们的作用。`match` 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。"

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it "
"encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits”, the value falls into the associated code block to "
"be used during execution."
msgstr ""
"可以把 `match` 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 `match` 的每一个模式，并且在遇到第一个 “符合” 的模式"
"时，值会进入相关联的代码块并在执行中被使用。"

#: src/ch06-02-the-match-control-flow-construct.md:9
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which "
"coin it is and returns its value in cents, as shown in Listing 6-3."
msgstr ""
"因为刚刚提到了硬币，让我们用它们来作为一个使用 `match` 的例子！我们可以编写一个函数来获取一个未知的硬币，并以一种类似验钞机的方式，确定它是何种硬币，并返回其价值（美分），如示例6-3所"
"示。"

#: src/ch06-02-the-match-control-flow-construct.md:11
msgid ""
"```rust,noplayground\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid "Listing 6-3: An enum and a match expression that has the variants of the enum as its patterns"
msgstr "示例6-3：一个枚举和一个将枚举成员作为其模式的 match 表达式"

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list the `match` keyword followed by an expression, which in this case is the value `coin`. This seems very "
"similar to a conditional expression used with if, but there’s a big difference: with if, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of "
"coin in this example is the `Coin` enum that we defined on the first line."
msgstr ""
"拆开 `value_in_cents` 函数中的 `match` 来看。首先，我们列出 `match` 关键字后跟一个表达式，在这个例子中是 coin 的值。这看起来非常像 `if` 所使用的条件表达式，不过这里有一个非常大的区"
"别：对于 `if`，表达式必须返回一个布尔值，而这里它可以是任何类型的。本例中硬币的类型是我们在第一行定义的 `Coin` 枚举。"

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value `Coin::Penny(_)` and then the `=>` operator that "
"separates the pattern and the code to run. The code in this case is just the value `1`. Each arm is separated from the next with a comma."
msgstr ""
"接下来是 `match` 分支。一个分支有两个部分：一个模式和一些代码。这里的第一个分支有一个模式，就是值 `Coin::Penny(_)`，然后是`=>`操作符，把模式和要运行的代码分开。本例中的代码只是值 "
"`1`。每个分支都用逗号与下一个分支隔开。"

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern "
"is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in the above "
"example, our match has four arms."
msgstr ""
"当 `match` 表达式执行时，它将结果值与每个分支的模式进行比较，依次进行。如果一个模式与值匹配，则执行与该模式相关的代码。如果该模式不匹配该值，则继续执行下一个分支，就像验钞机一样。我们"
"可以根据自己的需要有多少个分支：在上面的例子中，我们的匹配有四个分支。"

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr "在 Cairo，分支的顺序必须遵循与枚举相同的顺序。"

#: src/ch06-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression."
msgstr "与每个 match 相关的代码是一个表达式，而 match 分支中表达式的结果值是整个 match 表达式被返回的值。"

#: src/ch06-02-the-match-control-flow-construct.md:41
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it is in our example where each arm just returns a value. If you want to run multiple lines of code in a "
"match arm, you must use curly brackets, with a comma following the arm. For example, the following code prints “Lucky penny!” every time the method is called with a `Coin::Penny`, "
"but still returns the last value of the block, `1`:"
msgstr ""
"如果 match 分支的代码很短，我们通常不使用大括号，就像在我们的示例中一样，每个分支只是返回一个值。如果你想在一个 match 分支中运行多行代码，你必须使用大括号，在 match 分支后面加一个逗"
"号。例如，下面的代码在每次调用 `Coin::Penny` 方法时都会打印出 “Lucky penny!”，但仍然返回区块的最后一个值 `1`："

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid ""
"```rust,noplayground\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => {\n"
"            ('Lucky penny!').print();\n"
"            1\n"
"        },\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => {\n"
"            ('Lucky penny!').print();\n"
"            1\n"
"        },\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid "## Patterns That Bind to Values"
msgstr "## 绑定值的模式"

#: src/ch06-02-the-match-control-flow-construct.md:59
msgid "Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants."
msgstr "另一个match分支的有用的特点是它们可以绑定到值中与模式相匹配的部分。这就是如何从枚举成员中提取数值的方法。"

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 "
"states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our `enum` by changing the `Quarter` variant to include a "
"`UsState` value stored inside it, which we’ve done in Listing 6-4."
msgstr ""
"作为一个例子，让我们修改枚举的一个成员来存放数据。1999 年到 2008 年间，美国在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 "
"25 美分硬币有特殊的价值。我们可以通过改变 `Quarter` 变量，使其包含一个`UsState` 的值，从而将这个信息添加到我们的 `enum` 中，我们在示例6-4中已经这样做了。"

#: src/ch06-02-the-match-control-flow-construct.md:63
msgid ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum UsState {\n"
"    Alabama,\n"
"    Alaska,\n"
"}\n"
"\n"
"#[derive(Drop)]\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter: UsState,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[derive(Drop)]\n"
"enum UsState {\n"
"    Alabama,\n"
"    Alaska,\n"
"}\n"
"\n"
"#[derive(Drop)]\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter: UsState,\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:79
msgid "Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a `UsState` value"
msgstr "列表6-4: 一个 `Coin` 枚举，其中 `Quarter` 变量也持有一个 `UsState` 值"

#: src/ch06-02-the-match-control-flow-construct.md:81
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we’ll also call out the name of the state associated with each "
"quarter so that if it’s one our friend doesn’t have, they can add it to their collection."
msgstr ""
"想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。"

#: src/ch06-02-the-match-control-flow-construct.md:83
msgid ""
"In the match expression for this code, we add a variable called `state` to the pattern that matches values of the variant `Coin::Quarter`. When a `Coin::Quarter` matches, the `state` "
"variable will bind to the value of that quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"在这段代码的match表达式中，我们在模式中添加了一个叫做 `state` 的变量，用来匹配变量 `Coin::Quarter` 的值。当 `Coin::Quarter` 匹配时，`state` 变量将与该季度的状态值绑定。然后我们可以在"
"该分支的代码中使用 `state`，像这样："

#: src/ch06-02-the-match-control-flow-construct.md:85
msgid ""
"```rust,noplayground\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter(state) => {\n"
"            state.print();\n"
"            25\n"
"        },\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter(state) => {\n"
"            state.print();\n"
"            25\n"
"        },\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:99
msgid "To print the value of a variant of an enum in Cairo, we need to add an implementation for the `print` function for the `debug::PrintTrait`:"
msgstr "为了在 Cairo 打印一个枚举的变量的值，我们需要为`debug::PrintTrait` 添加一个 `print` 函数的实现："

#: src/ch06-02-the-match-control-flow-construct.md:101
msgid ""
"```rust,noplayground\n"
"impl UsStatePrintImpl of PrintTrait<UsState> {\n"
"    fn print(self: UsState) {\n"
"        match self {\n"
"            UsState::Alabama => ('Alabama').print(),\n"
"            UsState::Alaska => ('Alaska').print(),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"impl UsStatePrintImpl of PrintTrait<UsState> {\n"
"    fn print(self: UsState) {\n"
"        match self {\n"
"            UsState::Alabama => ('Alabama').print(),\n"
"            UsState::Alaska => ('Alaska').print(),\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:112
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each of the match arms, none of "
"them match until we reach `Coin::Quarter(state)`. At that point, the binding for state will be the value `UsState::Alaska`. We can then use that binding in the `PrintTrait`, thus "
"getting the inner state value out of the `Coin` enum variant for `Quarter`."
msgstr ""
"如果我们调用 `value_in_cents(Coin::quarter(UsState::Alaska))`，`coin` 将是 `Coin::quarter(UsState::Alaska)`。当我们将该值与每个匹配臂进行比较时，没有一个匹配，直到我们到达 `Coin::"
"Quarter(state)`。在这一点上，state 的绑定将是 `UsState::Alaska` 的值。然后我们可以在 `PrintTrait` 中使用该绑定，从而从 `Coin` 枚举变量中获得 `Quarter` 的内部状态值。"

#: src/ch06-02-the-match-control-flow-construct.md:114
msgid "## Matching with Options"
msgstr "## 匹配 Option<T>"

#: src/ch06-02-the-match-control-flow-construct.md:116
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the `Some` case when using `Option<T>`; we can also handle `Option<T>` using `match`, as we did with the `Coin` "
"enum! Instead of comparing coins, we’ll compare the variants of `Option<T>`, but the way the `match` expression works remains the same. You can use Options by importing the `option::"
"OptionTrait` trait."
msgstr ""
"在上一节中，我们想在使用 `Option<T>` 时从 `Some` 情况下得到内部的 `T` 值；我们也可以使用`match` 来处理 `Option<T>`，就像我们对 `Coin` 枚举所做的那样! 只不过这回比较的不再是硬币，而是"
"比较 `Option<T>` 的成员，但 `match` 表达式的工作方式保持不变。你可以通过导入 `option::OptionTrait` trait来使用Option。"

#: src/ch06-02-the-match-control-flow-construct.md:118
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if there’s a value inside, adds `1` to that value. If there isn’t a value inside, the function should return the "
"`None` value and not attempt to perform any operations."
msgstr "假设我们想写一个函数，接收一个 `Option<u8>`，如果里面有一个值，就把 `1` 加到这个值上。如果里面没有一个值，这个函数应该返回 `None` 值，并且不试图执行任何操作。"

#: src/ch06-02-the-match-control-flow-construct.md:120
msgid "This function is very easy to write, thanks to match, and will look like Listing 6-5."
msgstr "这个函数非常容易编写，这要归功于 match，它看起来像示例6-5。"

#: src/ch06-02-the-match-control-flow-construct.md:122
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"        Option::None => Option::None,\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let five: Option<u8> = Option::Some(5);\n"
"    let six: Option<u8> = plus_one(five);\n"
"    six.unwrap().print();\n"
"    let none = plus_one(Option::None);\n"
"    none.unwrap().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"        Option::None => Option::None,\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let five: Option<u8> = Option::Some(5);\n"
"    let six: Option<u8> = plus_one(five);\n"
"    six.unwrap().print();\n"
"    let none = plus_one(Option::None);\n"
"    none.unwrap().print();\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:141
msgid ""
"<span class=\"caption\">Listing 6-5: A function that uses a match\n"
"expression on an `Option<u8>`</span>"
msgstr "示例6-5：一个在`Option<u8>`上使用匹配表达式的函数"

#: src/ch06-02-the-match-control-flow-construct.md:144
msgid "Note that your arms must respect the same order as the enum defined in the `OptionTrait` of the core Cairo lib."
msgstr "注意，你的分支顺序与核心Cairo库的`OptionTrait`中定义的枚举顺序必须相同。"

#: src/ch06-02-the-match-control-flow-construct.md:146 src/ch08-01-generic-data-types.md:167
msgid ""
"```rust,noplayground\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None,\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call `plus_one(five)`, the variable `x` in the body of `plus_one` will have the value `Some(5)`. We then "
"compare that against each match arm:"
msgstr "让我们更详细地看一下 `plus_one` 的第一次执行。当我们调用 `plus_one(five)` 时，`plus_one` 函数体中的变量 `x` 的值是 `Some(5)`。然后我们将其与每个匹配分支进行比较："

#: src/ch06-02-the-match-control-flow-construct.md:155 src/ch06-02-the-match-control-flow-construct.md:163
msgid ""
"```rust,noplayground\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"```"
msgstr ""
"```rust,noplayground\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:159
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! We have the same variant. The `val` binds to the value contained in `Option::Some`, so `val` takes the "
"value `5`. The code in the match arm is then executed, so we add `1` to the value of `val` and create a new `Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""
"`Option::Some(5)` 和`Option::Some(val)`匹配吗？当然匹配！它们是相同的成员。`val` 与 `Option::Some` 中包含的值绑定，所以 `val` 取值为 `5` 。接着匹配分支的代码被执行，所以我们在 `val` "
"的值上加上 `1`，并创建一个新的 `Option::Some` 值，里面有我们的和 `6` 。因为第一个分支就匹配到了，其他的分支将不再进行比较。"

#: src/ch06-02-the-match-control-flow-construct.md:161
msgid "Now let’s consider the second call of `plus_one` in our main function, where `x` is `Option::None`. We enter the match and compare to the first arm:"
msgstr "现在让我们考虑在我们的主函数中对 `plus_one` 的第二次调用，其中 `x` 是`Option::None`。我们进入匹配，并与第一个分支进行比较："

#: src/ch06-02-the-match-control-flow-construct.md:167
msgid "The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so we continue to the next arm:"
msgstr "`Option::Some(val)` 的值不匹配 `Option::None` ，所以我们继续到下一个分支："

#: src/ch06-02-the-match-control-flow-construct.md:169
msgid ""
"```rust\n"
"        Option::None => Option::None,\n"
"```"
msgstr ""
"```rust\n"
"        Option::None => Option::None,\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:173
msgid "It matches! There’s no value to add to, so the program stops and returns the `Option::None` value on the right side of `=>`."
msgstr "它是匹配的!没有值可以添加，所以程序停止，并返回 `=>` 右边的 `Option::None` 值。"

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this pattern a lot in Cairo code: `match` against an enum, bind a variable to the data inside, and then execute "
"code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite."
msgstr ""
"将 `match` 与枚举相结合在很多场景中都是有用的。你会在 Cairo 代码中看到很多这样的模式：`match` 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯"
"了，你会希望所有语言都拥有它！这一直是用户的最爱。"

#: src/ch06-02-the-match-control-flow-construct.md:177
msgid "## Matches Are Exhaustive"
msgstr "## 匹配是穷尽的"

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns must cover all possibilities. Consider this version of our `plus_one` function, which has a bug and won’t "
"compile:"
msgstr "还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。考虑一下 `plus_one` 函数的这个版本，它有一个 bug 并不能编译："

#: src/ch06-02-the-match-control-flow-construct.md:181
msgid ""
"```rust,noplayground\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:189
msgid ""
"```bash\n"
"$ scarb cairo-run\n"
"    error: Unsupported match. Currently, matches require one arm per variant,\n"
"    in the order of variant definition.\n"
"    --> test.cairo:34:5\n"
"        match x {\n"
"        ^*******^\n"
"    Error: failed to compile: ./src/test.cairo\n"
"```"
msgstr ""
"```bash\n"
"$ scarb cairo-run\n"
"    error: Unsupported match. Currently, matches require one arm per variant,\n"
"    in the order of variant definition.\n"
"    --> test.cairo:34:5\n"
"        match x {\n"
"        ^*******^\n"
"    Error: failed to compile: ./src/test.cairo\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility in order for the "
"code to be valid. Especially in the case of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle the `None` case, it protects us from assuming that we have a "
"value when we might have null, thus making the billion-dollar mistake discussed earlier impossible."
msgstr ""
"Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Cairo 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效。特别的在这个 `Option<T>` 的例子中，Cairo 防止我"
"们忘记明确的处理 None 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。"

#: src/ch06-02-the-match-control-flow-construct.md:201
msgid "## Match 0 and the \\_ Placeholder"
msgstr "## Match 0 与 \\_ 占位符"

#: src/ch06-02-the-match-control-flow-construct.md:203
msgid ""
"Using enums, we can also take special actions for a few particular values, but for all other values take one default action. Currently only `0` and the `_`operator are supported."
msgstr "使用枚举，我们也可以对一些特定的值采取特殊的操作，但对所有其他的值采取一个默认的操作。目前只支持 `0` 和 `_` 操作符。"

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 and 7. If you have 0, you win. For all other values you lose. Here's a match that implements that logic, "
"with the number hardcoded rather than a random value."
msgstr ""
"想象一下，我们正在实现一个游戏，你会获得一个 0 到 7 之间的随机数字。如果你有 0，你就赢了。若是任何其他的值，你就输了。这里有一个实现该逻辑的 match，数字是硬编码的，而不是随机值。"

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"```rust,noplayground\n"
"fn did_i_win(nb: felt252) {\n"
"    match nb {\n"
"        0 => ('You won!').print(),\n"
"        _ => ('You lost...').print(),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn did_i_win(nb: felt252) {\n"
"    match nb {\n"
"        0 => ('You won!').print(),\n"
"        _ => ('You lost...').print(),\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-the-match-control-flow-construct.md:216
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that covers every other possible value, the pattern is the character `_`. This code compiles, even though we "
"haven’t listed all the possible values a `felt252` can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that "
"`match` must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would "
"never run, so Cairo will warn us if we add arms after a catch-all!"
msgstr ""
"第一条分支，模式是字面值 0。对于涵盖了所有其他可能的值的最后一条分支，其模式是字符 `_`。尽管我们没有列出 `felt252` 可能具有的所有值，但这段代码仍然可以编译，因为最后一个模式将匹配所有"
"没有特别列出的值。这个通配模式满足了 `match` 必须被穷尽的要求。请注意，我们必须把通配分支放在最后，因为模式是按顺序评估的。如果我们把通配分支放在前面，其他的分支就不会运行，所以如果我"
"们在通配分支之后添加分支，Cairo 会警告我们!"

#: src/ch06-02-the-match-control-flow-construct.md:218
msgid ""
"<!-- TODO : might need to link the end of this chapter to patterns and matching chapter -->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-10-18</footer>"
msgstr ""
"<!-- TODO : might need to link the end of this chapter to patterns and matching chapter -->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-10-18</footer>"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "# Managing Cairo Projects with Packages, Crates and Modules"
msgstr "# 使用包、Crate 和模块管理Cairo项目"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly\n"
"important. By grouping related functionality and separating code with distinct\n"
"features, you’ll clarify where to find code that implements a particular\n"
"feature and where to go to change how a feature works."
msgstr ""
"当你编写大型程序时，组织你的代码将变得越来越重要。\n"
"通过对相关的功能进行分组，并将具有不同功能的代码分开，你就可以清楚地知道在哪里可以找到实现某一特定的代码，以及到哪里去改变一个功能的工作方式。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a\n"
"project grows, you should organize code by splitting it into multiple modules\n"
"and then multiple files. As a package grows, you can extract parts into\n"
"separate crates that become external dependencies. This chapter covers all\n"
"these techniques."
msgstr ""
"到目前为止，我们所写的程序都是在一个文件中的一个模块中。\n"
"伴随着项目的增长，你应该通过将代码分解为多个模块和多个文件来组织代码。\n"
"伴随着包的增长，你可以将包中的部分代码提取出来，做成独立的 crate，这些 crate 则作为外部依赖项。\n"
"本章将会涵盖所有这些概念。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you reuse\n"
"code at a higher level: once you’ve implemented an operation, other code can\n"
"call your code without having to know how the\n"
"implementation works."
msgstr "我们也会讨论封装来实现细节，这可以使你更高级地重用代码：你实现了一个操作后，其他的代码可以通过该代码的公共接口来进行调用，而不需要知道它是如何实现的。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has a\n"
"set of names that are defined as “in scope.” When reading, writing, and\n"
"compiling code, programmers and compilers need to know whether a particular\n"
"name at a particular spot refers to a variable, function, struct, enum, module,\n"
"constant, or other item and what that item means. You can create scopes and\n"
"change which names are in or out of scope. You can’t have two items with the\n"
"same name in the same scope."
msgstr ""
"这里有一个需要说明的概念 “作用域（scope）”：代码所在的嵌套上下文有一组定义为 “in scope” 的名称。当阅读、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否引用了变量、函"
"数、结构体、枚举、模块、常量或者其他有意义的项。你可以创建作用域，以及改变哪些名称在作用域内还是作用域外。同一个作用域内不能拥有两个相同名称的项。"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s\n"
"organization. These features, sometimes\n"
"collectively referred to as the _module system_, include:"
msgstr "Cairo有许多功能可以让你管理代码的组织。这些功能。这有时被称为 “模块系统（the module system）”，包括："

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"- **Packages:** A Scarb feature that lets you build, test, and share crates\n"
"- **Crates:** A tree of modules that corresponds to a single compilation unit.\n"
"  It has a root directory, and a root module defined at the file `lib.cairo` under this directory.\n"
"- **Modules** and **use:** Let you control the organization and scope of items.\n"
"- **Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""
"- **Packages:**  Scarb的一个功能，可以让你建立、测试和分享crates。\n"
"- **Crates:** 一个模块的树形结构，对应于一个单一的编译单元。\n"
"  它有一个根目录，并在该目录下的`lib.cairo`文件中定义了一个根模块。\n"
"- **Modules** 和 **use:** 允许你控制组织结构和作用域。\n"
"- **Paths:** 一个命名例如结构体、函数或模块等项的方式"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, and\n"
"explain how to use them to manage scope. By the end, you should have a solid\n"
"understanding of the module system and be able to work with scopes like a pro!"
msgstr "在这一章中，我们将介绍所有这些特性，讨论它们如何相互作用，以及解释如何使用它们来管理作用域。到最后，你应该对模块系统有一个扎实的理解，并且能够像专家一样使用作用域了！"

#: src/ch07-01-packages-and-crates.md:1
msgid "# Packages and Crates"
msgstr "# 包和 Crate"

#: src/ch07-01-packages-and-crates.md:3
msgid "## What is a crate?"
msgstr "## 什么是crate？"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at a time. Even if you run `cairo-compile` rather than `scarb build` and pass a single source code file, the "
"compiler considers that file to be a crate. Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the "
"subsequent sections."
msgstr ""
"Crate是Cairo在编译时最小的代码单位。即使你运行 `cairo-compile` 而不是 `scarb build` 并传递一个源代码文件，编译器还是会将那个文件认作一个 crate。Crate可以包含模块，这些模块可以在其他文"
"件中定义，并与Crate一起被编译，这将在后面的章节中讨论。"

#: src/ch07-01-packages-and-crates.md:7
msgid "## What is the crate root?"
msgstr "## 什么是crate root？"

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts from and makes up the root module of your crate (we’ll explain modules in depth in the [“Defining Modules "
"to Control Scope”](./ch07-02-defining-modules-to-control-scope.md) section)."
msgstr ""
"Crate root根是`lib.cairo`源文件，Cairo编译器从该文件开始，并构成你的crate的根模块（我们将在[“定义模块来控制作用域”](./ch07-02-defining-modules-to-control-scope.md)部分深入解释模块）。"

#: src/ch07-01-packages-and-crates.md:11
msgid "## What is a package?"
msgstr "## 什么是包？"

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file that describes how to build those crates. This enables the splitting of code into smaller, reusable parts and "
"facilitates more structured dependency management."
msgstr "一个cairo包是一个由一个或多个crate组成的集合，其中的Scarb.toml文件描述如何构建这些板块。这使得代码被分割成更小的、可重复使用的部分，并有利于更有条理的依赖管理。"

#: src/ch07-01-packages-and-crates.md:15
msgid "## Creating a Package with Scarb"
msgstr "## 用Scarb创建一个包"

#: src/ch07-01-packages-and-crates.md:17
msgid "You can create a new Cairo package using the scarb command-line tool. To create a new package, run the following command:"
msgstr "你可以使用scarb命令行工具创建一个新的Cairo包。要创建一个新的软件包，运行以下命令："

#: src/ch07-01-packages-and-crates.md:19
msgid ""
"```bash\n"
"scarb new my_package\n"
"```"
msgstr ""
"```bash\n"
"scarb new my_package\n"
"```"

#: src/ch07-01-packages-and-crates.md:23
msgid "This command will generate a new package directory named `my_package` with the following structure:"
msgstr "该命令将生成一个名为`my_package`的新软件包目录，其结构如下："

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"```\n"
"my_package/\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```\n"
"my_package/\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"- `src/` is the main directory where all the Cairo source files for the package will be stored.\n"
"- `lib.cairo` is the default root module of the crate, which is also the main entry point of the package.\n"
"- `Scarb.toml` is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find "
"documentation about it on the [scarb reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"- `src/`是主目录，包的所有Cairo源代码文件将存放在这里。\n"
"- `lib.cairo`是crate的默认根模块，也是包的主要入口点。\n"
"- `Scarb.toml`是包示例文件，它包含包的元数据和配置选项，如依赖关系、包名称、版本和作者。你可以在[scarb reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)上找到"
"关于它的文档。"

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional `.cairo` files within the `src` directory or "
"its subdirectories."
msgstr "当你开发你的包时，你可能想把你的代码组织成多个Cairo源文件。你可以通过在`src`目录或其子目录下创建额外的`.cairo`文件来做到这一点。"

#: src/ch07-02-defining-modules-to-control-scope.md:1
msgid "## Defining Modules to Control Scope"
msgstr "## 定义模块以控制作用域"

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module system,\n"
"namely _paths_ that allow you to name items and the `use` keyword that brings a\n"
"path into scope."
msgstr "在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 路径（_paths_）；用来将路径引入作用域的`use`关键字。"

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when you’re\n"
"organizing your code in the future. Then we’ll explain each of the rules in\n"
"detail."
msgstr "首先，我们将从一系列的规则开始，在你未来组织代码的时候，这些规则可被用作简单的参考。接下来我们将会详细的解释每条规则。"

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "### Modules Cheat Sheet"
msgstr "### 模块小抄"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` keyword\n"
"work in the compiler, and how most developers organize their\n"
"code. We’ll be going through examples of each of these rules throughout this\n"
"chapter, but this is a great place to refer to as a reminder of how modules\n"
"work. You can create a new Scarb project with `scarb new backyard` to follow along."
msgstr ""
"这里我们提供一个简单的参考，用来解释模块、路径、 `use`关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。我们将在本章节中举例说明每条规则，不过这是一个解释模块工作方式的良"
"好参考。你可以用`scarb new backyard`创建一个新的Scarb项目来跟随。"

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"- **Start from the crate root**: When compiling a crate, the compiler first\n"
"  looks in the crate root file (_src/lib.cairo_) for code to compile.\n"
"- **Declaring modules**: In the crate root file, you can declare new modules;\n"
"  say, you declare a “garden” module with `mod garden;`. The compiler will look\n"
"  for the module’s code in these places:\n"
"\n"
"  - Inline, within curly brackets that replace the semicolon following `mod garden;`.\n"
"\n"
"    ```rust,noplayground\n"
"      // crate root file (src/lib.cairo)\n"
"        mod garden {\n"
"        // code defining the garden module goes here\n"
"        }\n"
"    ```\n"
"\n"
"  - In the file _src/garden.cairo_\n"
"\n"
"- **Declaring submodules**: In any file other than the crate root, you can\n"
"  declare submodules. For example, you might declare `mod vegetables;` in\n"
"  _src/garden.cairo_. The compiler will look for the submodule’s code within the\n"
"  directory named for the parent module in these places:\n"
"\n"
"  - Inline, directly following `mod vegetables`, within curly brackets instead\n"
"    of the semicolon.\n"
"\n"
"    ```rust,noplayground\n"
"    // src/garden.cairo file\n"
"    mod vegetables {\n"
"        // code defining the vegetables submodule goes here\n"
"    }\n"
"    ```\n"
"\n"
"  - In the file _src/garden/vegetables.cairo_\n"
"\n"
"- **Paths to code in modules**: Once a module is part of your crate, you can\n"
"  refer to code in that module from anywhere else in that same crate, using the path\n"
"  to the code. For example, an `Asparagus` type in the garden vegetables module would be found at\n"
"  `backyard::garden::vegetables::Asparagus`.\n"
"- **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts to\n"
"  items to reduce repetition of long paths. In any scope that can refer to\n"
"  `backyard::garden::vegetables::Asparagus`, you can create a shortcut with\n"
"  `use backyard::garden::vegetables::Asparagus;` and from then on you only need to\n"
"  write `Asparagus` to make use of that type in the scope."
msgstr ""
"- **从 crate 根节点开始**：当编译一个 crate, 编译器首先在 crate 根文件（_src/lib.cairo_）中寻找要编译的代码。\n"
"- **声明模块:**：在 crate 根文件中，你可以声明新的模块；\n"
"  例如，你用`mod garden;`声明一个 “garden”模块。编译器会在下列路径中寻找模块代码：\n"
"\n"
"  - 内联，在大括号中，当`mod garden`后方不是一个分号而是一个大括号\n"
"\n"
"    ```rust,noplayground\n"
"      // crate root file (src/lib.cairo)\n"
"        mod garden {\n"
"        // code defining the garden module goes here\n"
"        }\n"
"    ```\n"
"\n"
"- 在文件 _src/garden.cairo_ 中\n"
"- **声明子模块**：在除了 crate 根节点以外的其他文件中，你可以定义子模块。例如，你可以在以下文件中声明 `mod vegetables;`。\n"
"  _src/garden.cairo_ 。编译器会在以父模块命名的目录中寻找子模块代码： \n"
"\n"
"  - 内联，直接跟在`mod vegetables`后面，用大括号代替分号\n"
"\n"
"    ```rust,noplayground\n"
"    // src/garden.cairo file\n"
"    mod vegetables {\n"
"        // code defining the vegetables submodule goes here\n"
"    }\n"
"    ```\n"
"\n"
"  - 在文件 _src/garden/vegetables.cairo_ 中\n"
"\n"
"- **模块中的代码路径**：一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块"
"下的`Asparagus`类型可以在`backyard::garden::vegetables::Asparagus`被找到。\n"
"- **`use`关键字**：在一个作用域内，`use`关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用`backyard::garden::vegetables::Asparagus`的作用域，你可以通过 `use "
"backyard::garden::vegetables::Asparagus;`创建一个快捷方式，然后你就可以在作用域中只写`Asparagus`来使用该类型。"

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The\n"
"crate’s directory, also named `backyard`, contains these files and directories:"
msgstr "这里我们创建一个名为`backyard`的crate 来说明这些规则。该 crate 的路径同样命名为`backyard`，该路径包含了这些文件和目录："

#: src/ch07-02-defining-modules-to-control-scope.md:66
msgid ""
"```text\n"
"backyard/\n"
"├── Scarb.toml\n"
"└── src\n"
"    ├── garden\n"
"    │   └── vegetables.cairo\n"
"    ├── garden.cairo\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```text\n"
"backyard/\n"
"├── Scarb.toml\n"
"└── src\n"
"    ├── garden\n"
"    │   └── vegetables.cairo\n"
"    ├── garden.cairo\n"
"    └── lib.cairo\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "在这种情况下，crate根文件是 _src/lib.cairo_ ，它包含："

#: src/ch07-02-defining-modules-to-control-scope.md:80
msgid ""
"```rust\n"
"use garden::vegetables::Asparagus;\n"
"\n"
"mod garden;\n"
"\n"
"fn main() {\n"
"    let Asparagus = Asparagus {};\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use garden::vegetables::Asparagus;\n"
"\n"
"mod garden;\n"
"\n"
"fn main() {\n"
"    let Asparagus = Asparagus {};\n"
"}\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid "The `mod garden;` line tells the compiler to include the code it finds in _src/garden.cairo_, which is:"
msgstr "`mod garden;`行告诉编译器包括它在 _src/garden.cairo_ 中发现的代码是："

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr "<span class=\"filename\">文件名： src/garden.cairo</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:94
msgid ""
"```rust,noplayground\n"
"mod vegetables;\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod vegetables;\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is\n"
"included too. That code is:"
msgstr "这里，`mod vegetables;`意味着 _src/garden/vegetables.cairo_ 中的代码也被包括在内。这段代码是："

#: src/ch07-02-defining-modules-to-control-scope.md:101
msgid ""
"```rust,noplayground\n"
"#[derive(Copy, Drop)]\n"
"struct Asparagus {}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[derive(Copy, Drop)]\n"
"struct Asparagus {}\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the `Asparagus` type into scope,\n"
"so we can use it in the `main` function."
msgstr "这行`use garden::vecants::Asparagus;`让我们把`Asparagus`类型带入作用域、所以我们可以在`main`函数中使用它。"

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid "Now let’s get into the details of these rules and demonstrate them in action!"
msgstr "现在让我们深入了解这些规则的细节并在实际中演示它们！"

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "### Grouping Related Code in Modules"
msgstr "### 在模块中对相关代码进行分组"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy reuse.\n"
"As an example, let’s write a library crate that provides the functionality of a\n"
"restaurant. We’ll define the signatures of functions but leave their bodies\n"
"empty to concentrate on the organization of the code, rather than the\n"
"implementation of a restaurant."
msgstr ""
"_模块_ 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。\n"
"作为一个例子，让我们写一个crate，提供一个餐馆的机能。我们将定义函数的签名，但将其主体留空，以专注于代码的组织，而不是餐馆的实现。"

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as\n"
"_front of house_ and others as _back of house_. Front of house is where\n"
"customers are; this encompasses where the hosts seat customers, servers take\n"
"orders and payment, and bartenders make drinks. Back of house is where the\n"
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do\n"
"administrative work."
msgstr ""
"在餐饮业，餐馆中会有一些地方被称之为 前台（_front of house_），还有另外一些地方被称之为 后台（_back of house_）。\n"
"前台是招待顾客的地方，在这里，店主可以为顾客安排座位，服务员接受顾客下单和付款，调酒师会制作饮品。\n"
"后台则是由厨师工作的厨房，洗碗工的工作地点，以及经理做行政工作的地方组成。"

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into nested\n"
"modules. Create a new package named `restaurant` by running `scarb new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to\n"
"define some modules and function signatures. Here’s the front of house section:"
msgstr ""
"我们可以将函数放置到嵌套的模块中，来使我们的 crate 结构与实际的餐厅结构相同。\n"
"通过运行 `scarb new restaurant`创建一个名为 `restaurant`的新包；然后将示例7-1中的代码输入 _src/lib.cairo_ ，以定义一些模块和函数签名。这里是前台的部分："

#: src/ch07-02-defining-modules-to-control-scope.md:132
msgid ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid ""
"<span class=\"caption\">Listing 7-1: A `front_of_house` module containing other\n"
"modules that then contain functions</span>"
msgstr "<span class=\"caption\">示例7-1：一个 `front_of_house`模块包含其他的模块，而这些模块又包含了函数</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module\n"
"(in this case, `front_of_house`). The body of the module then goes inside curly\n"
"brackets. Inside modules, we can place other modules, as in this case with the\n"
"modules `hosting` and `serving`. Modules can also hold definitions for other\n"
"items, such as structs, enums, constants, traits, and—as in Listing\n"
"6-1—functions."
msgstr ""
"我们定义一个模块，是以 `mod`关键字为起始，然后指定模块的名字（本例中叫做 `front_of_house`），并且用花括号包围模块的主体。在模块内，我们还可以定义其他的模块，就像本例中的 `hosting` 和 "
"`serving` 模块。模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、以及列表中6-1中展示的函数。"

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why\n"
"they’re related. Programmers using this code can navigate the code based on the\n"
"groups rather than having to read through all the definitions, making it easier\n"
"to find the definitions relevant to them. Programmers adding new functionality\n"
"to this code would know where to place the code to keep the program organized."
msgstr ""
"通过使用模块，我们可以将相关的定义分组到一起，并指出他们为什么相关。程序员可以通过使用这段代码，更加容易地找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的"
"定义。\n"
"程序员向这段代码中添加一个新的功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。"

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate\n"
"root. The reason for this name is that the content of this file form a module named after the crate name at the root of the crate’s module structure,\n"
"known as the _module tree_."
msgstr "在前面我们提到了，_src/lib.cairo_  叫做 crate 根。之所以这样叫它是因为这个文件的内容在 crate 模块结构的根组成了一个名为 crate 的模块，该结构被称为 模块树（ _module tree_ ）。"

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "示例7-2显示了示例7-1中结构的模块树。"

#: src/ch07-02-defining-modules-to-control-scope.md:172
msgid ""
"```text\n"
"restaurant\n"
" └── front_of_house\n"
"     ├── hosting\n"
"     │   ├── add_to_waitlist\n"
"     │   └── seat_at_table\n"
"     └── serving\n"
"         ├── take_order\n"
"         ├── serve_order\n"
"         └── take_payment\n"
"```"
msgstr ""
"```text\n"
"restaurant\n"
" └── front_of_house\n"
"     ├── hosting\n"
"     │   ├── add_to_waitlist\n"
"     │   └── seat_at_table\n"
"     └── serving\n"
"         ├── take_order\n"
"         ├── serve_order\n"
"         └── take_payment\n"
"```"

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid ""
"<span class=\"caption\">Listing 7-2: The module tree for the code in Listing\n"
"6-1</span>"
msgstr "<span class=\"caption\">示例7-2：示例6-1中代码的模块树</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for example,\n"
"`hosting` nests inside `front_of_house`. The tree also shows that some modules\n"
"are _siblings_ to each other, meaning they’re defined in the same module;\n"
"`hosting` and `serving` are siblings defined within `front_of_house`. If module\n"
"A is contained inside module B, we say that module A is the _child_ of module B\n"
"and that module B is the _parent_ of module A. Notice that the entire module\n"
"tree is rooted under the explicit name of the crate `restaurant`."
msgstr ""
"这个树展示了一些模块是如何被嵌入到另一个模块的（例如，`hosting` 嵌套在 `front_of_house` 中）。这个树还展示了一些模块是互为 兄弟（ _siblings_ ）的，这意味着它们定义在同一模块中"
"（ `hosting` 和 `serving` 被一起定义在 _front_of_house_ 中）。继续沿用家庭关系的比喻，如果一个模块 A 被包含在模块 B 中，我们将模块 A 称为模块 B 的 子（ _child_ ），模块 B 则是模块 A "
"的 父（ _parent_ ）。注意，整个模块树都植根于名为 `restaurant` crate的隐式模块下。"

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your\n"
"computer; this is a very apt comparison! Just like directories in a filesystem,\n"
"you use modules to organize your code. And just like files in a directory, we\n"
"need a way to find our modules."
msgstr "这个模块树可能会令你想起电脑上文件系统的目录树；这是一个非常恰当的类比！就像文件系统的目录，你可以使用模块来组织你的代码。并且，就像目录中的文件，我们需要一种方法来找到模块。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "## Paths for Referring to an Item in the Module Tree"
msgstr "## 引用模块项目的路径"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid "To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path."
msgstr "为了告诉Cairo如何在模块树中找到一个项目，我们使用路径的方式，就像在文件系统使用路径一样。为了调用一个函数，我们需要知道它的路径。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "路径可以有两种形式："

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"- An _absolute path_ is the full path starting from a crate root. The absolute path begins with the crate name.\n"
"- A _relative path_ starts from the current module.\n"
"\n"
"  Both absolute and relative paths are followed by one or more identifiers\n"
"  separated by double colons (`::`)."
msgstr ""
"- 绝对路径（ _absolute path_ ）是以 crate 根（root）开头的全路径。绝对路径以 crate 名开头。\n"
"- 相对路径（  _relative path_  ）是从当前模块开始的。\n"
"\n"
"绝对路径和相对路径后面都有一个或多个标识符用双冒号（`::`）分开。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the restaurant we used in the last chapter. We have a crate named `restaurant` in which we have a module named "
"`front_of_house` that contains a module named `hosting`. The `hosting` module contains a function named `add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the `add_to_waitlist` function so it can find it."
msgstr ""
"为了说明这个概念，让我们回到我们在上一章使用的餐厅的例子示例7-1。我们有一个名为 `restaurant`的crate，其中有一个名为`front_of_house`的模块，包含一个名为 `hosting`的模块。`hosting`模块"
"包含一个名为 `add_to_waitlist`的函数。我们想从`eat_at_restaurant`函数中调用`add_to_waitlist`函数。我们需要告诉Cairo `add_to_waitlist`函数的路径，以便它能找到它。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:17
msgid ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid "<span class=\"caption\">Listing 7-3: Calling the `add_to_waitlist` function using absolute and relative paths</span>"
msgstr "<span class=\"caption\">示例7-3：使用绝对和相对路径调用`add_to_waitlist`函数</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,\n"
"we use an absolute path. The `add_to_waitlist` function is defined in the same\n"
"crate as `eat_at_restaurant`. In Cairo, absolute paths start from the crate root, which you need to refer to by using the crate name."
msgstr ""
"我们第一次调用`eat_at_restaurant`中的`add_to_waitlist`函数时、使用了一个绝对路径。`add_to_waitlist`函数与`eat_at_restaurant`定义在同一个crate中。在Cairo中，绝对路径从crate根开始，你需"
"要用crate的名字来引用它。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path starts with `front_of_house`, the name of the module\n"
"defined at the same level of the module tree as `eat_at_restaurant`. Here the\n"
"filesystem equivalent would be using the path\n"
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name means\n"
"that the path is relative to the current module."
msgstr ""
"第二次我们调用 add_to_waitlist时，使用的是相对路径。这个路径以 `front_of_house` 为起始，这个模块在模块树中，与 `eat_at_restaurant` 定义在同一层级。\n"
"与之等价的文件系统路径就是 `./front_of_house/hosting/add_to_waitlist`。以模块名开头意味着该路径是相对路径。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "### Starting Relative Paths with `super`"
msgstr "### 使用 `super` 起始的相对路径"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make\n"
"based on your project, and depends on whether you’re more likely to move item\n"
"definition code separately from or together with the code that uses the item."
msgstr ""
"选择是否使用 `super`将根据你的项目具体情况来决定。\n"
"并取决于你是否更有可能将项目定义的代码是与使用该项目的代码分开还是放在一起。"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:64
msgid ""
"```rust,noplayground\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid "<span class=\"caption\">Listing 7-4: Calling a function using a relative path starting with super</span>"
msgstr "<span class=\"caption\">示例7-4：使用以super开头的相对路径调用一个函数</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid "Here you can see directly that you access a parent's module easily using `super`, which wasn't the case previously."
msgstr "在这里你可以直接看到，和之前的例子不同，在这你可以使用`super`轻松地访问父级的模块。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "# Bringing Paths into Scope with the `use` Keyword"
msgstr "# 使用 `use` 关键字将路径引入作用域"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and repetitive. Fortunately, there’s a way to simplify this process: we can create a shortcut to a path with the "
"`use` keyword once, and then use the shorter name everywhere else in the scope."
msgstr "不得不编写路径来调用函数显得不便且重复。幸运的是，有一种方法可以简化这个过程：我们可以用`use`关键字创建一个路径的快捷方式，然后在作用域内的其他地方使用这个较短的名字。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module into the\n"
"scope of the `eat_at_restaurant` function so we only have to specify\n"
"`hosting::add_to_waitlist` to call the `add_to_waitlist` function in\n"
"`eat_at_restaurant`."
msgstr "在示例7-5中，我们把`restaurant::front_of_house::hosting`模块带入到作用域内，所以我们只需要指定 `hosting::add_to_waitlist` 来调用`eat_at_restaurant`中的`add_to_waitlist` 函数。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:12
msgid ""
"```rust\n"
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section \"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
"\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section \"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
"\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"<span class=\"caption\">Listing 7-5: Bringing a module into scope with\n"
"`use`</span>"
msgstr ""
"<span class=\"caption\">示例 7-5: 用 \"使用 \"将一个模块带入范围。\n"
"使用</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in the filesystem. By adding `use restaurant::front_of_house::hosting` in the crate root, hosting is now a "
"valid name in that scope, just as though the `hosting` module had been defined in the crate root."
msgstr ""
"在作用域中添加 use 和路径类似于在文件系统中创建一个软连接（符号连接，symbolic link）。通过在 crate 根中添加 `use restaurant::front_of_house::hosting`，hosting 现在是该作用域中的一个有"
"效名称，就像在 crate 根中定义了`hosting`模块一样。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a new\n"
"child module named `customer`, which is then a different scope than the `use`\n"
"statement, so the function body won’t compile:"
msgstr "注意 `use`  只能创建 `use`  所在的特定作用域内的短路径。示例 7-6 将 `eat_at_restaurant` 函数移到一个新的子模块中，这又是一个不同于  `use`  语句的作用域，所以函数体不能编译："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:40
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"<span class=\"caption\">Listing 7-6: A `use` statement only applies in the scope\n"
"it’s in</span>"
msgstr "<span class=\"caption\">示例7-6：一个 `use`语句只适用于它所在的作用域</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"The compiler error shows that the shortcut no longer applies within the\n"
"`customer` module:"
msgstr "编译器错误显示短路径不在适用于 `customer`  模块中："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:62
msgid ""
"```shell\n"
"❯ scarb build\n"
"error: Identifier not found.\n"
" --> lib.cairo:11:9\n"
"        hosting::add_to_waitlist();\n"
"        ^*****^\n"
"```"
msgstr ""
"```shell\n"
"❯ scarb build\n"
"error: Identifier not found.\n"
" --> lib.cairo:11:9\n"
"        hosting::add_to_waitlist();\n"
"        ^*****^\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "## Creating Idiomatic `use` Paths"
msgstr "## 创建惯用的 `use` 路径"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use\n"
"restaurant::front_of_house::hosting` and then called `hosting::add_to_waitlist` in\n"
"`eat_at_restaurant` rather than specifying the `use` path all the way out to\n"
"the `add_to_waitlist` function to achieve the same result, as in Listing 7-7."
msgstr ""
"在示例6-5中，你可能想知道为什么我们指定`restaurant::front_of_house::hosting`，然后调用`eat_at_restaurant`中的`hosting::add_to_waitlist`，而不是通过指定一直到\n"
"`add_to_waitlist`函数的 `use` 路径来得到相同的结果，如示例7-7。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:79
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid ""
"<span class=\"caption\">Listing 7-7: Bringing the `add_to_waitlist` function\n"
"into scope with `use`, which is unidiomatic</span>"
msgstr "<span class=\"caption\">示例7-7：使用 `use` 将 `add_to_waitlist` 函数引入作用域，这并不符合习惯</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 6-7 accomplish the same task, Listing 7-5 is\n"
"the idiomatic way to bring a function into scope with `use`. Bringing the\n"
"function’s parent module into scope with `use` means we have to specify the\n"
"parent module when calling the function. Specifying the parent module when\n"
"calling the function makes it clear that the function isn’t locally defined\n"
"while still minimizing repetition of the full path. The code in Listing 7-7 is\n"
"unclear as to where `add_to_waitlist` is defined."
msgstr ""
"尽管示例7-5和7-7都完成了相同的任务，但示例 7-5 是使用 use 将函数引入作用域的习惯用法。要想使用 `use` 将函数的父模块引入作用域，我们必须在调用函数时指定父模块，这样可以清晰地表明函数不"
"是在本地定义的，同时使完整路径的重复度最小化。示例 7-7 中的代码不清楚 `add_to_waitlist` 是在哪里被定义的。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items with `use`,\n"
"it’s idiomatic to specify the full path. Listing 7-8 shows the idiomatic way\n"
"to bring the core library’s `ArrayTrait` trait into the scope."
msgstr "另一方面，使用 `use` 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-8 展示了将核心库的 `ArrayTrait` trait带入作用域。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:108
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid ""
"<span class=\"caption\">Listing 7-8: Bringing `ArrayTrait` into scope in an\n"
"idiomatic way</span>"
msgstr "<span class=\"caption\">示例7-8：将`ArrayTrait`引入作用域的习惯用法式</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that has\n"
"emerged in the Rust community, and folks have gotten used to reading and writing Rust code this way.\n"
"As Cairo shares many idioms with Rust, we follow this convention as well."
msgstr ""
"这种习惯用法背后没有什么硬性要求：它只是一种惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。它只是在Rust社区中出现的惯例。\n"
"由于Cairo与Rust共享许多惯例，我们也遵循这一惯例。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same name\n"
"into scope with `use` statements, because Cairo doesn’t allow that."
msgstr "这个习惯用法有一个例外，那就是我们想使用 `use` 语句将两个具有相同名称的项带入作用域，因为Cairo不允许这样做。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "### Providing New Names with the `as` Keyword"
msgstr "### 使用 as 关键字提供新的名称"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same name\n"
"into the same scope with `use`: after the path, we can specify `as` and a new\n"
"local name, or _alias_, for the type. Listing 7-9 shows how you can rename an import with `as`:"
msgstr ""
"使用 `use` 将两个同名类型引入同一作用域这个问题还有另一个解决办法：在这个类型的路径后面，我们使用 `as` 指定一个新的本地名称或者别名（ _alias_ ）。示例7-9显示了如何用`as`重命名一个导"
"入："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
msgid ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main() {\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main() {\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"<span class=\"caption\">Listing 7-9: Renaming a trait when it’s brought into\n"
"scope with the `as` keyword</span>"
msgstr "<span class=\"caption\">示例 7-9：使用 `as` 关键字重命名引入作用域的类型</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid "Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now access the trait's methods with the `Arr` identifier."
msgstr "在这里，我们用别名`Arr`将`ArrayTrait`带入作用域。现在我们可以用`Arr`标识符来访问该trait的方法。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "### Importing multiple items from the same module"
msgstr "### 从同一模块中导入多个项"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums)\n"
"from the same module in Cairo, you can use curly braces `{}` to list all of\n"
"the items that you want to import. This helps to keep your code clean and easy\n"
"to read by avoiding a long list of individual use statements."
msgstr ""
"当你想从同一个模块中导入多个项（如函数、结构体或枚举）时，\n"
"你可以使用大括号`{}`来列出所有你想导入的项目。\n"
"避免了一长串单独的`use`有助于保持你的代码整洁和便于阅读。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid "The general syntax for importing multiple items from the same module is:"
msgstr "从同一模块导入多个项的常见语法是："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:156
msgid ""
"```rust\n"
"use module::{item1, item2, item3};\n"
"```"
msgstr ""
"```rust\n"
"use module::{item1, item2, item3};\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid "Here is an example where we import three structures from the same module:"
msgstr "下面是一个从同一个模块导入三个结构体的例子："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:162
msgid ""
"```rust\n"
"// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.\n"
"mod shapes {\n"
"    #[derive(Drop)]\n"
"    struct Square {\n"
"        side: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Circle {\n"
"        radius: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Triangle {\n"
"        base: u32,\n"
"        height: u32,\n"
"    }\n"
"}\n"
"\n"
"// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like this:\n"
"use shapes::{Square, Circle, Triangle};\n"
"\n"
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
"fn main() {\n"
"    let sq = Square { side: 5 };\n"
"    let cr = Circle { radius: 3 };\n"
"    let tr = Triangle { base: 5, height: 2 };\n"
"// ...\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.\n"
"mod shapes {\n"
"    #[derive(Drop)]\n"
"    struct Square {\n"
"        side: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Circle {\n"
"        radius: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Triangle {\n"
"        base: u32,\n"
"        height: u32,\n"
"    }\n"
"}\n"
"\n"
"// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like this:\n"
"use shapes::{Square, Circle, Triangle};\n"
"\n"
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
"fn main() {\n"
"    let sq = Square { side: 5 };\n"
"    let cr = Circle { radius: 3 };\n"
"    let tr = Triangle { base: 5, height: 2 };\n"
"// ...\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "<span class=\"caption\">Listing 7-10: Importing multiple items from the same module</span>"
msgstr "<span class=\"caption\">示例 7-10：从同一模块导入多个项</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "## Re-exporting Names in Module Files"
msgstr "## 在模块文件中重导出名称"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available in\n"
"the new scope can be imported as if it had been defined in that code’s scope.\n"
"This technique is called _re-exporting_ because we’re bringing an item into scope,\n"
"but also making that item available for others to bring into their scope."
msgstr ""
"当我们用`use`关键字将一个名字带入作用域时，在新的作用域中也能够正常使用这个名称，就好像它本来就在当前作用域一样。\n"
"这种技术被称为 重导出（ _re-exporting_ ），因为我们将一个项目带入作用域、但同时也使这个项目可以被其他人带入他们的作用域。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid "For example, let's re-export the `add_to_waitlist` function in the restaurant example:"
msgstr "下面这个例子，让我们重新导出餐厅例子中的`add_to_waitlist`函数："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:207
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid ""
"<span class=\"caption\">Listing 7-11: Making a name available for any code to use\n"
"from a new scope with `pub use`</span>"
msgstr "<span class=\"caption\">示例 7-11: 通过 `pub use` 使名称可在新作用域中被导入至任何代码</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist`\n"
"function by using the path\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `use`\n"
"has re-exported the `hosting` module from the root module, external code\n"
"can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"在这个修改之前，外部代码需要使用路径 `restaurant::front_of_house::hosting::add_to_waitlist()` 来调用 `add_to_waitlist` 函数。\n"
"现在这个 `use` 从根模块重导出了 `hosting` 模块，外部代码现在可以使用路径 `restaurant::hosting::add_to_waitlist()` 。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different\n"
"from how programmers calling your code would think about the domain. For\n"
"example, in this restaurant metaphor, the people running the restaurant think\n"
"about “front of house” and “back of house.” But customers visiting a restaurant\n"
"probably won’t think about the parts of the restaurant in those terms. With\n"
"`use`, we can write our code with one structure but expose a different\n"
"structure. Doing so makes our library well organized for programmers working on\n"
"the library and programmers calling the library."
msgstr ""
"当你代码的内部结构与调用你代码的程序员所想象的结构不同时，重导出会很有用。\n"
"例如，在这个餐馆的比喻中，经营餐馆的人会想到“前台”和“后台”。但顾客在光顾一家餐馆时，可能不会以这些术语来考虑餐馆的各个部分。\n"
"使用 `use`，我们可以使用一种结构编写代码，却将不同的结构形式暴露出来。这样做使我们的库井井有条，也使开发这个库的程序员和调用这个库的程序员都更加方便。"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "## Using External Packages in Cairo with Scarb"
msgstr "## 在Cairo使用外部包与Scarb"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid "You might need to use external packages to leverage the functionality provided by the community. To use an external package in your project with Scarb, follow these steps:"
msgstr "你可能需要使用外部包来利用社区提供的功能。要在你的项目中使用Scarb的外部包，请遵循以下步骤："

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid "> The dependencies system is still a work in progress. You can check the official [documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr "> 依赖关系系统仍然是一项正在进行的工作。你可以查看官方的[文档](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)。"

#: src/ch07-05-separating-modules-into-different-files.md:1
msgid "## Separating Modules into Different Files"
msgstr "## 将模块拆分成多个文件"

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one file.\n"
"When modules get large, you might want to move their definitions to a separate\n"
"file to make the code easier to navigate."
msgstr "到目前为止，本章所有的例子都在一个文件中定义多个模块。当模块变得更大时，你可能想要将它们的定义移动到单独的文件中，从而使代码更容易阅读。"

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple\n"
"restaurant modules. We’ll extract modules into files instead of having all the\n"
"modules defined in the crate root file. In this case, the crate root file is\n"
"_src/lib.cairo_."
msgstr "例如，我们从示例7-11中的代码开始，我们会将模块的代码提取到各自的文件中，而不是将所有模块都定义到 crate 根文件中。在这里，crate 根文件是 _src/lib.cairo_ 。"

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the\n"
"code inside the curly brackets for the `front_of_house` module, leaving only\n"
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the code\n"
"shown in Listing 7-12. Note that this won’t compile until we create the\n"
"_src/front_of_house.cairo_ file in Listing 7-13."
msgstr ""
"首先将 `front_of_house` 模块提取到其自己的文件中。删除 `front_of_house`  模块的大括号中的代码，只留下 `mod front_of_house;` 声明，这样 _src/lib.cairo_ 就包含了代码\n"
"如示例7-12所示。注意直到创建示例 7-13 中的 _src/front_of_house.cairo_ 文件之前代码都不能编译。"

#: src/ch07-05-separating-modules-into-different-files.md:20
msgid ""
"```rust,noplayground\n"
"mod front_of_house;\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod front_of_house;\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 7-12: Declaring the `front_of_house` module whose\n"
"body will be in _src/front_of_house.cairo_</span>"
msgstr "<span class=\"caption\">示例7-12：声明`front_of_house` 模块，其主体代码将存放在 _src/front_of_house.cairo_ 中。</span>"

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named\n"
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to look\n"
"in this file because it came across the module declaration in the crate root\n"
"with the name `front_of_house`."
msgstr ""
"接下来将之前大括号内的代码放入一个名叫 _src/front_of_house.cairo_ 的新文件中，如示例 7-13所示。因为编译器找到了 crate 根中名叫 `front_of_house` 的模块声明，它就知道去查看这个文件。"

#: src/ch07-05-separating-modules-into-different-files.md:38 src/ch07-05-separating-modules-into-different-files.md:66
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr "<span class=\"filename\">文件名： src/front_of_house.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:40
msgid ""
"```rust,noplayground\n"
"mod hosting {\n"
"    fn add_to_waitlist() {}\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod hosting {\n"
"    fn add_to_waitlist() {}\n"
"}\n"
"```"

#: src/ch07-05-separating-modules-into-different-files.md:46
msgid ""
"<span class=\"caption\">Listing 7-13: Definitions inside the `front_of_house`\n"
"module in _src/front_of_house.cairo_</span>"
msgstr "<span class=\"caption\">示例 7-13：在 _src/front_of_house.cairo_ 中定义 `front_of_house` 模块。</span>"

#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in your\n"
"module tree. Once the compiler knows the file is part of the project (and knows\n"
"where in the module tree the code resides because of where you’ve put the `mod`\n"
"statement), other files in your project should refer to the loaded file’s code\n"
"using a path to where it was declared, as covered in the [“Paths for Referring\n"
"to an Item in the Module Tree”][paths]<!-- ignore --> section. In other words,\n"
"`mod` is _not_ an “include” operation that you may have seen in other\n"
"programming languages."
msgstr ""
"注意你只需在模块树中的某处使用一次 mod 声明就可以加载这个文件。\n"
"一旦编译器知道了这个文件是项目的一部分（并且通过 mod 语句的位置知道了代码在模块树中的位置），项目中的其他文件应该使用其所声明的位置的路径来引用那个文件的代码，\n"
"这在 [引用模块项目的路径](ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md)部分有讲到。\n"
"换句话说，mod 不是 你可能会在其他编程语言中看到的 “include” 操作。"

#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a bit\n"
"different because `hosting` is a child module of `front_of_house`, not of the\n"
"root module. We’ll place the file for `hosting` in a new directory that will be\n"
"named for its ancestors in the module tree, in this case _src/front_of_house/_."
msgstr ""
"接下来我们同样将 `hosting` 模块提取到自己的文件中。这个过程会有所不同，因为 `hosting` 是 `front_of_house` 的子模块而不是根模块。我们将 `hosting` 的文件放在与模块树中它的父级模块同名的"
"目录中，在这里是 _src/front_of_house/_ 。"

#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain only the\n"
"declaration of the `hosting` module:"
msgstr "为了移动 `hosting`，修改 _src/front_of_house.cairo_  使之仅包含 `hosting` 模块的声明："

#: src/ch07-05-separating-modules-into-different-files.md:68
msgid ""
"```rust,noplayground\n"
"mod hosting;\n"
"```"
msgstr ""
"```rust,noplayground\n"
"mod hosting;\n"
"```"

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ to\n"
"contain the definitions made in the `hosting` module:"
msgstr "接着我们创建一个 _src/front_of_house_ 目录和一个包含 `hosting` 模块定义的 _hosting.cairo_ 文件："

#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr "<span class=\"filename\">文件名： src/front_of_house/hosting.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:77
msgid ""
"```rust,noplayground\n"
"fn add_to_waitlist() {}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn add_to_waitlist() {}\n"
"```"

#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would\n"
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the crate\n"
"root, and not declared as a child of the `front_of_house` module. The\n"
"compiler’s rules for which files to check for which modules’ code means the\n"
"directories and files more closely match the module tree."
msgstr ""
"如果将 _hosting.cairo_ 放在 _src_ 目录，编译器会认为 `hosting` 模块中的 _hosting.cairo_ 的代码声明于 crate 根，而不是声明为 `front_of_house` 的子模块。\n"
"编译器所遵循的哪些文件对应哪些模块的代码的规则，意味着目录和文件更接近于模块树。"

#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree remains\n"
"the same. The function calls in `eat_at_restaurant` will work without any\n"
"modification, even though the definitions live in different files. This\n"
"technique lets you move modules to new files as they grow in size."
msgstr ""
"我们将各个模块的代码移动到独立文件了，同时模块树依旧相同。\n"
"`eat_at_restaurant` 中的函数调用也无需修改继续保持有效，即便其定义存在于不同的文件中。\n"
"这个技巧让你可以在模块代码增长时，将它们移动到新文件中。"

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in\n"
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what files\n"
"are compiled as part of the crate. The `mod` keyword declares modules, and Cairo\n"
"looks in a file with the same name as the module for the code that goes into\n"
"that module."
msgstr ""
"注意，_src/lib.cairo_中的 `use restaurant::front_of_house::hosting` 语句是没有改变的，在文件作为 crate 的一部分而编译时，`use` 不会有任何影响。\n"
"`mod` 关键字声明了模块，Cairo 会在与模块同名的文件中查找模块的代码。"

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules\n"
"so you can refer to items defined in one module from another module. You can do\n"
"this by specifying absolute or relative paths. These paths can be brought into\n"
"scope with a `use` statement so you can use a shorter path for multiple uses of\n"
"the item in that scope. Module code is public by default."
msgstr ""
"Cairo 提供了将包分成多个 crate，将 crate 分成模块，以及通过指定绝对或相对路径从一个模块引用另一个模块中定义的项的方式。\n"
"你可以通过使用 `use` 语句将路径引入作用域，这样在多次使用时可以使用更短的路径。模块定义的代码默认是公有的。"

#: src/ch08-00-generic-types-and-traits.md:1
msgid "# Generic Types and Traits"
msgstr "# 泛型和Trait"

#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the duplication of concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete types or other "
"properties. We can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code."
msgstr ""
"每一个编程语言都有高效处理重复概念的工具。在 Cairo 中其工具之一就是 泛型（generics）。泛型是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关"
"联，而不需要在编写和编译代码时知道他们在这里实际上代表什么。"

#: src/ch08-00-generic-types-and-traits.md:5
msgid "Functions, structs, enums and traits can incorporate generic types as part of their definition instead of a concrete type like `u32` or `ContractAddress`."
msgstr "函数、结构体、枚举和trait可以将泛型作为其定义的一部分，而不是像`u32`或`ContractAddress`这样的具体类型。"

#: src/ch08-00-generic-types-and-traits.md:7
msgid "Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication."
msgstr "泛型允许我们用一个代表多种类型的占位符来替换特定的类型，以消除代码的重复。"

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a new definition, reducing development time for the programmer, but code duplication at compile level still "
"exists. This may be of importance if you are writing Starknet contracts and using a generic for multiple types which will cause contract size to increment."
msgstr ""
"对于每一个取代泛型的具体类型，编译器都会创建一个新的定义，从而减少程序员的开发时间，但在编译层面上的代码重复仍然存在。如果你正在编写Starknet合约，并为多个类型使用一个泛型，这将导致合"
"约大小的增加，这可能是很重要的。"

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to accept only those types that have a "
"particular behavior, as opposed to just any type."
msgstr "之后你将学习 trait，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为只接受拥有特定行为的类型，而不是任意类型。"

#: src/ch08-01-generic-data-types.md:1
msgid "# Generic Data Types"
msgstr "# 泛型数据类型"

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo we can use "
"generics when defining functions, structs, enums, traits, implementations and methods! In this chapter we are going to take a look at how to effectively use generic types with all of "
"them."
msgstr ""
"我们可以使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。在Cairo中，我们可以在定义函数、结构、枚举、trait、实现和方法时使用泛型！在本章中，我们"
"将看看在这些被提到的领域中如何有效地使用泛型。"

#: src/ch08-01-generic-data-types.md:5
msgid "## Generic Functions"
msgstr "## 在函数定义中使用泛型"

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For "
"example, imagine we want to create a function which given two `Array` of items, will return the largest one. If we need to perform this operation for lists of different types, then "
"we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks."
msgstr ""
"当定义一个使用泛型的函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。例如，假设我们想创建一个函数，给定两个 `Array` 项，函数将返回最大的一个。如果我们需要对不同"
"类型的列表进行这种操作，那么我们就必须每次都重新定义这个函数。幸运的是，我们可以使用泛型来实现这个函数，然后继续完成其他任务。"

#: src/ch08-01-generic-data-types.md:9
msgid ""
"```rust\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it "
"will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an `Array<T>` "
"is droppable when executing the `main` function. In order to drop an array of `T`, the compiler must first know how to drop `T`. This can be fixed by specifying in the function "
"signature of `largest_list` that `T` must implement the drop trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"名为`largest_list`函数比较了两个相同类型的列表，返回具有更多元素的那一个，并丢弃另一个。如果你编译前面的代码，你会注意到它会出错，说没有为丢弃一个泛型的数组定义trait。这是因为编译器没"
"有办法保证在执行`main`函数时，`Array<T>`是可以丢弃的。为了丢弃一个`T`的数组，编译器必须首先知道如何丢弃`T`。可以通过在`largest_list`的函数签名中规定`T`必须实现drop trait来解决这个问"
"题。`largest_list`的正确函数定义如下："

#: src/ch08-01-generic-data-types.md:39
msgid ""
"```rust\n"
"fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. The `main` function remains unchanged, "
"the compiler is smart enough to deduce which concrete type is being used and if it implements the `Drop` trait."
msgstr ""
"新的`largest_list`函数在其定义中包含了一个要求，即无论什么泛型被放在那里，它都必须是可丢弃的。`main`函数保持不变，编译器足够聪明，可以得出正在使用的具体类型以及它是否实现了`Drop`这个"
"trait。"

#: src/ch08-01-generic-data-types.md:51
msgid "### Constraints for Generic Types"
msgstr "### 范型的约束"

#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allow us to use them more effectively in a functions logic at "
"the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the compiler's requirements, we can also add constraints to benefit our function logic."
msgstr ""
"在定义泛型的时候，掌握关于它们的信息是很有用的。知道一个泛型实现了哪些trait，可以让我们在函数逻辑中更有效地使用它们，代价是限制了可以与函数一起使用的泛型。我们之前看到了一个例子，就是"
"将`TDrop`的实现作为`largest_list`的泛型参数的一部分。虽然 `TDrop`是为了满足编译器的要求而添加的，但我们也可以添加一些约束条件以有利于我们的函数逻辑。"

#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to find the smallest element among them. Initially, we know that for an element of type `T` to be comparable, "
"it must implement the `PartialOrd` trait. The resulting function would be:"
msgstr "想象一下，我们想，给定一个通用类型`T`的元素列表，找到其中最小的元素。首先，我们知道要使一个`T`类型的元素具有可比性，它必须实现`PartialOrd`这个trait。由此产生的函数将是："

#: src/ch08-01-generic-data-types.md:57
msgid ""
"```rust\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list: Array<u8> = ArrayTrait::new();\n"
"    list.append(5);\n"
"    list.append(3);\n"
"    list.append(10);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3, 0);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list: Array<u8> = ArrayTrait::new();\n"
"    list.append(5);\n"
"    list.append(3);\n"
"    list.append(10);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3, 0);\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:93
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and returns a copy of the smallest "
"element. Because the parameter is of type `@Array<T>`, we no longer need to drop it at the end of the execution and so we don't require to implement the `Drop` trait for `T` as well. "
"Why it does not compile then?"
msgstr ""
"名为`smallest_element`函数使用一个实现了`PartialOrd`的trait的通用类型`T`，接收一个`Array<T>`的快照作为参数并返回其中最小元素的拷贝。因为参数是`@Array<T>`的类型，我们不再需要在执行结束"
"时丢弃它，所以我们不需要为`T`实现`Drop`特性。那为什么它不能编译呢？"

#: src/ch08-01-generic-data-types.md:95
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, unless `PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The `*` operation "
"requires a copy from `@T` to`T`, which means that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now variables with type `T` that "
"need to be dropped, requiring for `T` to implement the `Drop` trait as well. We must then add both `Drop` and `Copy` traits implementation for the function to be correct. After "
"updating the`smallest_element` function the resulting code would be:"
msgstr ""
"当对`list`进行索引时，其结果是对被索引的元素进行快照，除非`@T`实现了`PartialOrd`，否则我们需要使用 `*` 对元素进行解快照。`*` 操作需要从`@T`复制到`T`，这意味着`T`需要实现`Copy`特性。在"
"复制了一个`@T`类型的元素到`T`之后，现在有`T`类型的变量需要被删除，这就要求`T`也要实现`Drop`特性。然后我们必须同时添加`Drop`和`Copy`特性的实现，以使该函数正确。在更新`smallest_element`"
"函数后，产生的代码将是："

#: src/ch08-01-generic-data-types.md:97
msgid ""
"```rust\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl TDrop: Drop<T>>(\n"
"    list: @Array<T>\n"
") -> T {\n"
"    let mut smallest = *list[0];\n"
"    let mut index = 1;\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl TDrop: Drop<T>>(\n"
"    list: @Array<T>\n"
") -> T {\n"
"    let mut smallest = *list[0];\n"
"    let mut index = 1;\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:115
msgid "## Structs"
msgstr "## 结构体定义中的泛型"

#: src/ch08-01-generic-data-types.md:117
msgid ""
"We can also define structs to use a generic type parameter for one or more fields using the `<>` syntax, similar to function definitions. First we declare the name of the type "
"parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The "
"next code example shows the definition `Wallet<T>` which has a `balance` field of type `T`."
msgstr ""
"我们也可以使用类似于函数定义的`<>` 语法来定义结构，它包含一个或多个泛型参数类型字段。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称，接着在结构体定义中可以指定具体数据类型的位"
"置使用泛型类型。下一个代码示例显示了 `Wallet<T>` 的定义，它有一个 `balance`字段，类型为 `T`。"

#: src/ch08-01-generic-data-types.md:119
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:131
msgid "The above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the following code:"
msgstr "上述代码自动为`Wallet`类型派生`Drop` trait。这效果等同于手动编写以下代码："

#: src/ch08-01-generic-data-types.md:133
msgid ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:145
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` implementation. Notice that we must define, just like functions, an "
"additional generic type for `WalletDrop` saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is droppable as long as `T` is also "
"droppable."
msgstr ""
"应该避免使用`derive`宏来实现`Wallet`的`Drop`，而是定义我们自己的`WalletDrop`实现。注意，我们必须像定义函数一样，为`WalletDrop`定义一个额外的泛型`T`并且也实现了`Drop`特性。这基本上是在"
"说，只要`T`也是可丢弃的，那么`钱包<T>`这个结构就是可丢弃的。"

#: src/ch08-01-generic-data-types.md:147
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and we want that field to be different than `T` but generic as well, we can simply add another generic type "
"between the `<>`:"
msgstr "最后，如果我们想给`Wallet`添加一个代表其Cairo地址的字段，并且我们希望这个字段是与`T`不同的另一个泛型，我们可以简单地通过在`<>`之间添加另一个泛型来实现："

#: src/ch08-01-generic-data-types.md:149
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3, address: 14 };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3, address: 14 };\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:161
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign this type to the new field member `address`. Notice that the derive attribute for the `Drop` trait works "
"for `U` as well."
msgstr ""
"我们在`Wallet`结构定义中添加一个新的泛型`U`，然后将这个类型分配给新的字段成员`address`。\n"
"注意派生属性的 `Drop`的trait在新的泛型 `U `上同样起作用。"

#: src/ch08-01-generic-data-types.md:163
msgid "## Enums"
msgstr "## 枚举定义中的泛型"

#: src/ch08-01-generic-data-types.md:165
msgid "As we did with structs, we can define enums to hold generic data types in their variants. For example the `Option<T>` enum provided by the Cairo core library:"
msgstr "和结构体类似，枚举也可以在成员中存放泛型数据类型。例如，Cairo核心库提供的`Option<T>`枚举："

#: src/ch08-01-generic-data-types.md:174
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` and `None` that doesn't hold any value. By using the `Option<T>` enum, "
"it is possible for us to express the abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction with any type."
msgstr ""
"如你所见 `Option<T>` 是一个拥有泛型 `T` 的枚举，它有两个成员：`Some`，它存放了一个类型 `T` 的值，和不存在任何值的`None`。通过 `Option<T>` 枚举可以表达有一个可能的值的抽象概念，同时因"
"为 `Option<T>` 是泛型的，无论这个可能的值是什么类型都可以使用这个抽象。"

#: src/ch08-01-generic-data-types.md:176
msgid "Enums can use multiple generic types as well, like definition of the `Result<T, E>` enum that the core library provides:"
msgstr "枚举也可以拥有多个泛型类型，比如核心库提供的`Result<T, E>`枚举的定义："

#: src/ch08-01-generic-data-types.md:178 src/ch10-02-recoverable-errors.md:11
msgid ""
"```rust,noplayground\n"
"enum Result<T, E> {\n"
"    Ok: T,\n"
"    Err: E,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"enum Result<T, E> {\n"
"    Ok: T,\n"
"    Err: E,\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:185 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition "
"makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"`Result<T, E>`枚举有两个泛型类型，`T`和`E`，以及两个成员：`Ok`，存放`T`类型的值，`Err`，存放`E`类型的值。这个定义使得我们可以在任何地方使用`Result`枚举，该操作可能成功（返回`T`类型的"
"值）或失败（返回`E`类型的值）。"

#: src/ch08-01-generic-data-types.md:187
msgid "## Generic Methods"
msgstr "## 方法定义中的泛型"

#: src/ch08-01-generic-data-types.md:189
msgid ""
"We can implement methods on structs and enums, and use the generic types in their definition, too. Using our previous definition of `Wallet<T>` struct, we define a `balance` method "
"for it:"
msgstr "我们可以在结构和枚举上实现方法，也可以在其定义中使用泛型。在之前定义的`Wallet<T>`结构体上为其定义一个`balance` 方法："

#: src/ch08-01-generic-data-types.md:191
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:213
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which defines a method that returns a snapshot of the field `balance` from `Wallet`. Then we give an implementation "
"for the trait in `WalletImpl<T>`. Note that you need to include a generic type in both definitions of the trait and the implementation."
msgstr ""
"我们首先定义了`WalletTrait<T>`trait，使用一个泛型`T`，它定义了一个方法，从`Wallet`中返回字段`balance`的快照。然后我们在`WalletImpl<T>`中给出该trait的实现。请注意，你需要在trait的定义"
"和实现中都包含一个泛型。"

#: src/ch08-01-generic-data-types.md:215
msgid ""
"We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for `Wallet<u128>` instances rather than "
"`Wallet<T>`. In the code example we define an implementation for wallets which have a concrete type of `u128` for the `balance` field."
msgstr ""
"在定义类型上的方法时，我们也可以指定对泛型的约束。例如，我们可以只为`Wallet<u128>`实例而不是`Wallet<T>`实现方法。在代码示例中，我们为钱包定义了一个实现，这些钱包的`balance`字段的具体"
"类型为`u128`。"

#: src/ch08-01-generic-data-types.md:217
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"/// Generic trait for wallets\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"/// Trait for wallets of type u128\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"\n"
"    w.receive(100);\n"
"    assert(w.balance() == 150, 0);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"/// Generic trait for wallets\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"/// Trait for wallets of type u128\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"\n"
"    w.receive(100);\n"
"    assert(w.balance() == 150, 0);\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:254
msgid ""
"The new method `receive` increments the size of the balance of any instance of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a mutable variable in order for "
"it to be able to update its balance. If we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile."
msgstr ""
"新的方法`receive`增加了`Wallet<u128>`的实例的余额大小。请注意，我们改变了`main`函数，使`w`成为一个可变的变量，以便它能够更新其余额。如果我们通过改变`balance`的类型来改变`w`的初始化，"
"那么之前的代码就不能编译了。"

#: src/ch08-01-generic-data-types.md:256
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from `Wallet<U, V>` we are going to define a trait that picks two wallets of "
"different generic types and create a new one with a generic type of each. First, let's rewrite the struct definition:"
msgstr "Cairo也允许我们在泛型trait中定义泛型方法。在之前的 `Wallet<U, V>`的实现上定义一个trait，用来选取两个不同泛型的钱包，并创建一个拥有两者泛型新的钱包。首先，让我们重写结构体定义："

#: src/ch08-01-generic-data-types.md:258
msgid ""
"```rust,noplayground\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:265
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr "接下来，我们将初步地定义混合trait和其实现："

#: src/ch08-01-generic-data-types.md:267
msgid ""
"```rust,noplayground\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,noplayground\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch08-01-generic-data-types.md:281
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new `Wallet<T1, U2>`. As "
"`mixup` signature specify, both `self` and `other` are getting dropped at the end of the function, which is the reason for this code not to compile. If you have been following from "
"the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the `Drop` trait in order for the compiler to know how "
"to drop instances of `Wallet<T, U>`. The updated implementation is as follow:"
msgstr ""
"我们正在创建一个trait`WalletMixTrait<T1, U1>`，其中有`mixup<T2, U2>`方法，给定一个`Wallet<T1, U1>`和`Wallet<T2, U2>`的实例，创建一个新的`Wallet<T1, U2>`。正如`mixup`签名所指定的，"
"`self`和`other`都在函数的结尾处被丢弃，这就是这段代码不能编译的原因。如果你从开始到现在都跟上了课程，你会知道我们必须为所有的泛型添加一个`Drop` trait的实现，以便编译器知道如何丢弃"
"`Wallet<T, U>`的实例。更新后的实现如下："

#: src/ch08-01-generic-data-types.md:283
msgid ""
"```rust\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` signature. We can now "
"try the `mixup` function:"
msgstr "我们在 `WalletMixImpl`\"的声明中添加了 `T1`和 `U1`的可丢弃trait。然后我们对`T2`和`U2`做同样的处理，这次是作为`mixup`签名的一部分。现在我们可以尝试使用`mixup` 函数了："

#: src/ch08-01-generic-data-types.md:301
msgid ""
"```rust,noplayground\n"
"fn main() {\n"
"    let w1 = Wallet { balance: true, address: 10 };\n"
"    let w2 = Wallet { balance: 32, address: 100 };\n"
"\n"
"    let w3 = w1.mixup(w2);\n"
"\n"
"    assert(w3.balance == true, 0);\n"
"    assert(w3.address == 100, 0);\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn main() {\n"
"    let w1 = Wallet { balance: true, address: 10 };\n"
"    let w2 = Wallet { balance: 32, address: 100 };\n"
"\n"
"    let w3 = w1.mixup(w2);\n"
"\n"
"    assert(w3.balance == true, 0);\n"
"    assert(w3.address == 100, 0);\n"
"}\n"
"```"

#: src/ch08-01-generic-data-types.md:313
msgid "We first create two instances: one of `Wallet<bool, u128>` and the other of `Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, u8>` instance."
msgstr "我们首先创建两个实例：一个是 `Wallet<bool, u128>`，另一个是`Wallet<felt252, u8>`。然后，我们调用`mixup`并创建一个新的`Wallet<bool, u8>`实例。"

#: src/ch08-02-traits-in-cairo.md:1
msgid "# Traits in Cairo"
msgstr "# Cairo中的Trait"

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The blueprint specification includes a set of function signatures containing type annotations for the parameters and "
"return value. This sets a standard to implement the specific functionality."
msgstr ""
"Trait（译注：也被称为特性，但本译文中将跟随rust中文的习惯，直接使用英文原单词）定义了可以实现的功能蓝图的规范。蓝图规范包括一组包含参数和返回值类型注释的函数签名。这为实现特定的功能设"
"定了一个标准。（译注：trait 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。）"

#: src/ch08-02-traits-in-cairo.md:5
msgid "## Defining a Trait"
msgstr "## 定义一个Trait"

#: src/ch08-02-traits-in-cairo.md:7
msgid "To define a trait, you use the keyword `trait` followed by the name of the trait in `PascalCase` then the function signatures in a pair of curly braces."
msgstr "要定义一个Trait，你可以使用关键字`trait`，后面是以`PascalCase`书写的trait名称，然后是一对大括号内的函数签名。"

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We want our application to be able to perform geometry operations on these shapes, So we define a trait "
"`ShapeGeometry` that contains a blueprint to implement geometry operations on a shape like this:"
msgstr "例如，假设我们有多个代表形状的结构体。我们希望我们的应用程序能够对这些形状进行几何操作，所以我们定义了一个trait`ShapeGeometry`，它包含一个蓝图来实现对形状的几何操作："

#: src/ch08-02-traits-in-cairo.md:11
msgid ""
"```rust,noplayground\n"
"trait ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64;\n"
"    fn area(self: Rectangle) -> u64;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64;\n"
"    fn area(self: Rectangle) -> u64;\n"
"}\n"
"```"

#: src/ch08-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods `boundary` and `area`. When implemented, both these functions should return a `u64` and accept parameters as "
"specified by the trait."
msgstr "这里我们的trait `ShapeGeometry`声明了两个方法的签名`boundary`和`area`。当编写实现时，这两个函数都应该返回一个`u64`，并接受trait所规定的参数。"

#: src/ch08-02-traits-in-cairo.md:20
msgid "## Implementing a Trait"
msgstr "## 实现一个trait"

#: src/ch08-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your implementation followed by `of` then the name of trait being implemented. Here's an example implementing "
"`ShapeGeometry` trait."
msgstr "一个trait可以用`impl`关键字来实现，在你的实现名称后面加上`of`，然后是被实现的trait的名称。下面是一个实现`ShapeGeometry`trait的例子。"

#: src/ch08-02-traits-in-cairo.md:24
msgid ""
"```rust,noplayground\n"
"impl RectangleGeometry of ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"impl RectangleGeometry of ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"```"

#: src/ch08-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` defining what the methods `boundary` and `area` should do. Note that the function parameters and return "
"value types are identical to the trait specification."
msgstr "在上面的代码中，`RectangleGeometry`实现了`ShapeGeometry`的trait，定义了`boundary`和`area`方法应该做什么。请注意，函数参数和返回值的类型与trait所定义的规范是相同的。"

#: src/ch08-02-traits-in-cairo.md:37
msgid "## Implementing a trait, without writing its declaration."
msgstr "## trait的无声明实现。"

#: src/ch08-02-traits-in-cairo.md:39
msgid ""
"You can write implementations directly without defining the corresponding trait. This is made possible by using the `#[generate_trait]` attribute within the implementation, which "
"will make the compiler generate the trait corresponding to the implementation automatically. Remember to add `Trait` as a suffix to your trait name, as the compiler will create the "
"trait by adding a `Trait` suffix to the implementation name."
msgstr ""
"你可以直接编写实现而不需要定义相应的trait。这可以通过在实现上使用 `#[generate_trait]`属性来实现，它将使编译器自动生成与实现相对应的trait。记住在你的 trait 的名称后添加 `Trait` 作为后"
"缀，因为编译器会通过在实现名称后添加 `Trait` 后缀来创建 trait。"

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"```rust,noplayground\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[generate_trait]\n"
"impl RectangleGeometry of RectangleGeometryTrait {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[generate_trait]\n"
"impl RectangleGeometry of RectangleGeometryTrait {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"```"

#: src/ch08-02-traits-in-cairo.md:58
msgid ""
"In the aforementioned code, there is no need to manually define the trait. The compiler will automatically handle its definition, dynamically generating and updating it as new "
"functions are introduced."
msgstr "在上述代码中，无需手动定义trait。编译器将自动处理它的定义，在引入新函数时动态生成和更新它。"

#: src/ch08-02-traits-in-cairo.md:60
msgid "## Parameter `self`"
msgstr "## 参数  `self`"

#: src/ch08-02-traits-in-cairo.md:62
msgid ""
"In the example above, `self` is a special parameter. When a parameter with name `self` is used, the implemented functions are also [attached to the instances of the type as methods]"
"(ch05-03-method-syntax.md#defining-methods). Here's an illustration,"
msgstr "在上面的例子中，`self`是一个特殊参数。当使用名称为`self`的���数时，实现的函数也会[作为方法附加到类型的实例上](ch05-03-method-syntax.md#defining-methods)。下面是一个演示、"

#: src/ch08-02-traits-in-cairo.md:64
msgid "When the `ShapeGeometry` trait is implemented, the function `area` from the `ShapeGeometry` trait can be called in two ways:"
msgstr "当 \"ShapeGeometry \"trait被实现时，\"ShapeGeometry \"trait中的函数 \"area \"可以通过两种方式被调用："

#: src/ch08-02-traits-in-cairo.md:66
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# #[derive(Drop, Copy)]\n"
"# struct Rectangle {\n"
"#     height: u64,\n"
"#     width: u64,\n"
"# }\n"
"# \n"
"# trait ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64;\n"
"#     fn area(self: Rectangle) -> u64;\n"
"# }\n"
"# \n"
"# impl RectangleGeometry of ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64 {\n"
"#         2 * (self.height + self.width)\n"
"#     }\n"
"#     fn area(self: Rectangle) -> u64 {\n"
"#         self.height * self.width\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 10 }; // Rectangle instantiation\n"
"\n"
"    // First way, as a method on the struct instance\n"
"    let area1 = rect.area();\n"
"    // Second way, from the implementation\n"
"    let area2 = RectangleGeometry::area(rect);\n"
"    // Third way, from the trait\n"
"    let area3 = ShapeGeometry::area(rect);\n"
"\n"
"    // `area1` has same value as `area2` and `area3`\n"
"    area1.print();\n"
"    area2.print();\n"
"    area3.print();\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# #[derive(Drop, Copy)]\n"
"# struct Rectangle {\n"
"#     height: u64,\n"
"#     width: u64,\n"
"# }\n"
"# \n"
"# trait ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64;\n"
"#     fn area(self: Rectangle) -> u64;\n"
"# }\n"
"# \n"
"# impl RectangleGeometry of ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64 {\n"
"#         2 * (self.height + self.width)\n"
"#     }\n"
"#     fn area(self: Rectangle) -> u64 {\n"
"#         self.height * self.width\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 10 }; // Rectangle instantiation\n"
"\n"
"    // First way, as a method on the struct instance\n"
"    let area1 = rect.area();\n"
"    // Second way, from the implementation\n"
"    let area2 = RectangleGeometry::area(rect);\n"
"    // Third way, from the trait\n"
"    let area3 = ShapeGeometry::area(rect);\n"
"\n"
"    // `area1` has same value as `area2` and `area3`\n"
"    area1.print();\n"
"    area2.print();\n"
"    area3.print();\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch08-02-traits-in-cairo.md:108
msgid "And the implementation of the `area` method will be accessed via the `self` parameter."
msgstr "之后我们可以通过 `self`参数访问`area`方法的实现。"

#: src/ch08-02-traits-in-cairo.md:110
msgid "## Generic Traits"
msgstr "## 泛型Traits"

#: src/ch08-02-traits-in-cairo.md:112
msgid ""
"Usually we want to write a trait when we want multiple types to implement a functionality in a standard way. However, in the example above the signatures are static and cannot be "
"used for multiple types. To do this, we use generic types when defining traits."
msgstr "通常情况下，当我们希望多个类型以标准的方式实现一个功能时，我们要写一个trait。然而，在上面的例子中，签名是静态的，不能用于多种类型。为了做到这一点，我们在定义trait时使用泛型。"

#: src/ch08-02-traits-in-cairo.md:114
msgid "In the example below, we use generic type `T` and our method signatures can use this alias which can be provided during implementation."
msgstr "在下面的例子中，我们使用泛型`T`，我们的方法签名可以使用由实现提供这个别名。"

#: src/ch08-02-traits-in-cairo.md:116
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Circle {\n"
"    radius: u64\n"
"}\n"
"\n"
"// Here T is an alias type which will be provided during implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2 * 314 * self.radius) / 100\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314 * self.radius * self.radius) / 100\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Circle {\n"
"    radius: u64\n"
"}\n"
"\n"
"// Here T is an alias type which will be provided during implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2 * 314 * self.radius) / 100\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314 * self.radius * self.radius) / 100\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"

#: src/ch08-02-traits-in-cairo.md:169
msgid "## Managing and using external trait implementations"
msgstr "## 管理和使用外部trait的实现"

#: src/ch08-02-traits-in-cairo.md:171
msgid ""
"To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In the code above we imported `PrintTrait` from `debug` with `use debug::PrintTrait;` "
"to use the `print()` methods on supported types."
msgstr ""
"要使用trait的方法，你需要确保导入了正确的 traits以及它的实现。在上面的代码中，我们从`debug`中导入了`PrintTrait`，并使用`use debug::PrintTrait;`以在支持的类型上使用`print()`方法。"

#: src/ch08-02-traits-in-cairo.md:173
msgid ""
"In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules.\n"
"If `CircleGeometry` was in a separate module/file `circle` then to use `boundary` on `circ: Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr ""
"在某些情况下，如果它们被声明在不同的模块中，你可能不仅需要导入trait，还需要导入实现。\n"
"如果`CircleGeometry`是在一个单独的模块/文件`circle`中，那么要在`circ: Circle`上使用`boundary`，我们就需要在 `ShapeGeometry`之外再导入 `CircleGeometry`。"

#: src/ch08-02-traits-in-cairo.md:176
msgid ""
"If the code was organized into modules like this, where the implementation of a trait was defined in a different module than the trait itself, explicitly importing the relevant "
"implementation is required."
msgstr "如果代码被组织成类似这样的模块，其中trait的实现被定义在与trait本身不同的模块中时，则需要显式导入相关的实现。"

#: src/ch08-02-traits-in-cairo.md:178
msgid ""
"```rust,noplayground\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    let circ = Circle { radius: 5 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    let circ = Circle { radius: 5 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"

#: src/ch08-02-traits-in-cairo.md:213
msgid "To make it work, in addition to,"
msgstr "为了使其发挥作用，除此之外、"

#: src/ch08-02-traits-in-cairo.md:215
msgid ""
"```rust\n"
"use geometry::ShapeGeometry;\n"
"```"
msgstr ""
"```rust\n"
"use geometry::ShapeGeometry;\n"
"```"

#: src/ch08-02-traits-in-cairo.md:219
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not need to import `RectangleGeometry`, as it is defined in the same module as the imported trait, and thus is "
"automatically resolved."
msgstr "您需要明确地导入 `CircleGeometry`。请注意，您不需要导入 `RectangleGeometry`，因为它与导入的 trait 定义在同一个模块中，因此会自动解析。"

#: src/ch08-02-traits-in-cairo.md:221
msgid ""
"```rust\n"
"use circle::CircleGeometry\n"
"```"
msgstr ""
"```rust\n"
"use circle::CircleGeometry;\n"
"```"

#: src/ch09-00-testing-cairo-programs.md:1
msgid "# Testing Cairo Programs"
msgstr "# 测试Cairo 程序"

#: src/ch09-01-how-to-write-tests.md:1
msgid "# How To Write Tests"
msgstr "# 如何编写测试"

#: src/ch09-01-how-to-write-tests.md:3
msgid "## The Anatomy of a Test Function"
msgstr "## 测试函数的剖析"

#: src/ch09-01-how-to-write-tests.md:5
msgid "Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:"
msgstr "测试是Cairo函数，用于验证非测试代码是否以预期方式运行。测试函数的主体通常执行这三个动作："

#: src/ch09-01-how-to-write-tests.md:7
msgid ""
"- Set up any needed data or state.\n"
"- Run the code you want to test.\n"
"- Assert the results are what you expect."
msgstr ""
"- 设置任何需要的数据或状态。\n"
"- 运行你想测试的代码。\n"
"- 断言结果与你期望的一样。"

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests that take these actions, which include the `test` attribute, the `assert` function, and the `should_panic` "
"attribute."
msgstr "让我们看看Cairo专门为编写执行这些动作的测试所提供的功能，其中包括`test`属性、`assert`函数和`should_panic`属性。"

#: src/ch09-01-how-to-write-tests.md:13
msgid "### The Anatomy of a Test Function"
msgstr "### 一个测试函数的剖析"

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the `test` attribute. Attributes are metadata about pieces of Cairo code; one example is the derive attribute we "
"used with structs in Chapter 5. To change a function into a test function, add `#[test]` on the line before `fn`. When you run your tests with the `scarb cairo-test` command, Scarb "
"runs Cairo's test runner binary that runs the annotated functions and reports on whether each test function passes or fails."
msgstr ""
"最简单的Cairo中的测试是一个带有`test`属性注释的函数。属性是关于Cairo代码片段的元数据；一个例子是我们在第5章中对结构体使用的derive属性。要把一个函数变成测试函数，在 `fn`前的一行加上 "
"`#[test]`。当你用`cairo-test`命令运行你的测试时，Cairo会建立一个测试运行器的二进制文件，运行被标注了的函数，并报告每个测试函数的通过或失败。"

#: src/ch09-01-how-to-write-tests.md:17
msgid "Let's create a new project called `adder` that will add two numbers using Scarb with the command `scarb new adder`:"
msgstr "让我们创建一个名为 `adder`的将两个数字相加的新项目，用`scarb new adder`”命令："

#: src/ch09-01-how-to-write-tests.md:19
msgid ""
"```shell\n"
"adder\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```shell\n"
"adder\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"

#: src/ch09-01-how-to-write-tests.md:26
msgid "In _lib.cairo_, let's remove the existing content and add a first test, as shown in Listing 9-1."
msgstr "在 _lib.cairo_ 中，让我们添加第一个测试，如示例9-1所示。"

#: src/ch09-01-how-to-write-tests.md:30
msgid ""
"```rust\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"

#: src/ch09-01-how-to-write-tests.md:38
msgid "<span class=\"caption\">Listing 9-1: A test module and function</span>"
msgstr "<span class=\"caption\">示例9-1：一个测试模块和其函数</span>"

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the `#[test]` annotation: this attribute indicates this is a test function, so the test runner knows to treat "
"this function as a test. We might also have non-test functions in the tests module to help set up common scenarios or perform common operations, so we always need to indicate which "
"functions are tests."
msgstr ""
"现在，让我们忽略最上面的两行，专注于这个函数。注意`#[test]`标注：这个属性表明这是一个测试函数，所以测试运行器知道要把这个函数当作一个测试。我们可能在测试模块中也有非测试函数，以帮助设"
"置常见的场景或执行常见的操作，所以我们总是需要指出哪些函数是测试的。"

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert` function, which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. "
"Let’s run it to see that this test passes."
msgstr "这个例子的函数体使用了`assert`函数，它包含了2和2相加的结果，等于4。这个断言是一个典型测试格式范例。让我们运行它，看看这个测试是否通过。"

#: src/ch09-01-how-to-write-tests.md:44
msgid "The `scarb cairo-test` command runs all tests founds in our project, as shown in Listing 9-2."
msgstr "用`scarb cairo-test`命令运行我们项目中的所有测试，如示例9-2所示。"

#: src/ch09-01-how-to-write-tests.md:46
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder...\n"
"running 1 tests\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"testing adder...\n"
"running 1 tests\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:54
msgid "<span class=\"caption\">Listing 9-2: The output from running a test</span>"
msgstr "<span class=\"caption\">示例9-2：运行测试后的输出</span>"

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 tests`. The next line shows the name of the test function, called `it_works`, and that the result of running "
"that test is `ok`. The overall summary `test result: ok.` means that all the tests passed, and the portion that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""
"`scarb cairo-test`编译并运行了测试。我们看到一行`running 1 tests`。下一行显示了生成的测试函数的名称，叫做`it_works`，运行该测试的结果是`ok`。总体摘要`test result: ok.`意味着所有的测试"
"都通过了，`1 passed; 0 failed` 的部分展示了通过或失败的测试的总数。"

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically Requested](#ignoring-some-tests-"
"unless-specifically-requested) section later in this chapter. Because we haven’t done that here, the summary shows `0 ignored`. We can also pass an argument to the `scarb cairo-test` "
"command to run only a test whose name matches a string; this is called filtering and we’ll cover that in the [Running Single Tests](#running-single-tests) section. We also haven’t "
"filtered the tests being run, so the end of the summary shows `0 filtered out`."
msgstr ""
"我们可以把一个测试标记为忽略，这样它就不会在一个特定的实例中运行；我们将在本章后面的[忽略一些测试，除非特别要求](#ignoring-some-tests-unless-specifically-requested)一节中介绍。因为我"
"们在这里没有这样做，所以摘要中显示 `0 ignored`。我们也可以给`cairo-test`命令传递一个参数，只运行名称与某个字符串相匹配的测试；这叫做过滤，我们将在[运行单个测试](#running-single-test)"
"一节中介绍。我们也没有对正在运行的测试进行过滤，所以总结的最后显示`0 filtered out`。"

#: src/ch09-01-how-to-write-tests.md:60
msgid "Let’s start to customize the test to our own needs. First change the name of the `it_works` function to a different name, such as `exploration`, like so:"
msgstr "让我们开始根据我们自己的需要定制测试。首先将`it_works`函数的名称改为不同的名称，例如`exploration`，像这样："

#: src/ch09-01-how-to-write-tests.md:64
msgid ""
"```rust\n"
"    #[test]\n"
"    fn exploration() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[test]\n"
"    fn exploration() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"

#: src/ch09-01-how-to-write-tests.md:72
msgid "Then run `scarb cairo-test` again. The output now shows `exploration` instead of `it_works`:"
msgstr "然后再次运行`scarb cairo-test`。现在输出显示的是 `exploration`而不是`it_works`："

#: src/ch09-01-how-to-write-tests.md:74
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::exploration … ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main "
"thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named `another`, so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr ""
"现在我们将添加另一个测试，但这次我们要做一个失败的测试! 当测试函数中的某些东西发生panic时，测试就会失败。每个测试都在一个新的线程中运行，当主线程看到一个测试线程死亡时，该测试被标记为"
"失败。将新的测试作为一个名为`another`的函数输入，因此你的 _src/lib.cairo_ 文件看起来像示例9-3里一样。"

#: src/ch09-01-how-to-write-tests.md:83
msgid ""
"```rust\n"
"    #[test]\n"
"    fn another() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 6, 'Make this test fail');\n"
"    }\n"
"\n"
"```"
msgstr ""
"```rust\n"
"    #[test]\n"
"    fn another() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 6, 'Make this test fail');\n"
"    }\n"
"\n"
"```"

#: src/ch09-01-how-to-write-tests.md:92
msgid "<span class=\"caption\">Listing 9-3: Adding a second test that will fail</span>"
msgstr "<span class=“caption”>示例9-3：添加第二个测试（会失败的测试）</span>"

#: src/ch09-01-how-to-write-tests.md:94
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test adder::lib::tests::another ... fail\n"
"failures:\n"
"    adder::lib::tests::another - panicked with [1725643816656041371866211894343434536761780588 ('Make this test fail'), ].\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::exploration … ok\n"
"test adder::lib::tests::another … fail\n"
"failures:\n"
"    adder::lib::tests::another - panicked with [1725643816656041371866211894343434536761780588 (‘Make this test fail’), ].\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch09-01-how-to-write-tests.md:104
msgid "<span class=\"caption\">Listing 9-4: Test results when one test passes and one test fails</span>"
msgstr "<span class=“caption”>示例9-4：一个测试通过，一个测试失败时的测试结果</span>"

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new section appears between the individual results and the summary. It displays the detailed reason for each "
"test failure. In this case, we get the details that `another` failed because it panicked with `[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` in the _src/"
"lib.cairo_ file."
msgstr ""
"`adder::lib::test::another`这一行没有显示`ok`，而是显示`fail`。在单个结果和摘要之间出现了一个新的部分。它显示了每个测试失败的详细原因。在这个例子中，我们得到的细节在是 _src/lib.cairo_"
"文件中`another`失败了，因为它发生了panic `[1725643816656041371866211894343434536761780588 (‘Make this test fail’), ]`。"

#: src/ch09-01-how-to-write-tests.md:108
msgid "The summary line displays at the end: overall, our test result is `FAILED`. We had one test pass and one test fail."
msgstr "摘要行显示在最后：总的来说，我们的测试结果是`FAILED`。我们有一个测试通过，一个测试失败。"

#: src/ch09-01-how-to-write-tests.md:110
msgid "Now that you’ve seen what the test results look like in different scenarios, let’s look at some functions that are useful in tests."
msgstr "现在你已经看到了不同场景下的测试结果，让我们看看一些在测试中有用的函数。"

#: src/ch09-01-how-to-write-tests.md:112
msgid "## Checking Results with the assert function"
msgstr "## 用断言函数检查结果"

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to `true`. We give the `assert` function a first argument that "
"evaluates to a Boolean. If the value is `true`, nothing happens and the test passes. If the value is `false`, the assert function calls `panic()` to cause the test to fail with a "
"message we defined as the second argument of the `assert` function. Using the `assert` function helps us check that our code is functioning in the way we intend."
msgstr ""
"Cairo提供的`assert`函数，在你想确保测试中的某些条件一定为`true`时非常有用。我们给`assert`函数的第一个参数是一个布尔值。如果该值为`true`，则不会发生任何事情，测试通过。如果值是 "
"`false`，assert函数调用 `panic()`，导致测试失败，我们定义的信息是 `assert`函数的第二个参数。使用`assert`函数可以帮助我们检查我们的代码是否按照我们的意图运行。"

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-15](ch05-03-method-syntax.md#multiple-impl-blocks), we used a `Rectangle` struct and a `can_hold` method, which are repeated here in Listing 9-5. Let’s put "
"this code in the _src/lib.cairo_ file, then write some tests for it using the `assert` function."
msgstr ""
"在[第5章，示例5-15](ch05-03-method-syntax.md#multiple-impl-blocks)中，我们使用了一个`Rectangle`结构和一个`can_hold`方法，在示例9-5中重复了这些。让我们把这段代码放在_src/lib.cairo_文件"
"中，然后用`assert`函数为它写一些测试。"

#: src/ch09-01-how-to-write-tests.md:137
msgid "<span class=\"caption\">Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from Chapter 5</span>"
msgstr "<span class=“caption”>示例9-5：使用第五章中的 `Rectangle`结构及其`can_hold`方法</span>"

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case for the assert function. In Listing 9-6, we write a test that exercises the `can_hold` method by creating "
"a `Rectangle` instance that has a width of `8` and a height of `7` and asserting that it can hold another `Rectangle` instance that has a width of `5` and a height of `1`."
msgstr ""
"返回值为`bool`的`can_hold`方法是assert函数的一个完美用例。在示例9-6中，我们写了一个测试，通过创建一个宽度为`8`、高度为`7`的`Rectangle`实例，并断言它可以容纳另一个宽度为`5`、高度为`1`"
"的`Rectangle`实例，来测试`can_hold`方法。"

#: src/ch09-01-how-to-write-tests.md:143
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width && *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle { height: 7, width: 8, };\n"
"        let smaller = Rectangle { height: 1, width: 5, };\n"
"\n"
"        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"    }\n"
"# \n"
"#     #[test]\n"
"#     fn smaller_cannot_hold_larger() {\n"
"#         let larger = Rectangle { height: 7, width: 8, };\n"
"#         let smaller = Rectangle { height: 1, width: 5, };\n"
"# \n"
"#         assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width && *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle { height: 7, width: 8, };\n"
"        let smaller = Rectangle { height: 1, width: 5, };\n"
"\n"
"        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"    }\n"
"# \n"
"#     #[test]\n"
"#     fn smaller_cannot_hold_larger() {\n"
"#         let larger = Rectangle { height: 7, width: 8, };\n"
"#         let smaller = Rectangle { height: 1, width: 5, };\n"
"# \n"
"#         assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch09-01-how-to-write-tests.md:192
msgid "<span class=\"caption\">Listing 9-6: A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle</span>"
msgstr "<span class=“caption”>示例 9-6: `can_hold`的测试，检查一个较大的矩形是否真的可以容纳一个较小的矩形</span>"

#: src/ch09-01-how-to-write-tests.md:194
msgid ""
"Note that we’ve added two new lines inside the tests module: `use super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a regular module that follows the usual "
"visibility rules. Because the tests module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module."
msgstr ""
"注意，我们在测试模块中加入了两行新的内容：`use super::Rectangle;`和`use super::RectangleTrait;`。测试模块是一个常规模块，遵循通常的可见性规则。因为测试模块是一个内部模块，我们需要将外"
"部模块中的被测代码引入内部模块的范围。"

#: src/ch09-01-how-to-write-tests.md:196
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two `Rectangle` instances that we need. Then we called the assert function and passed it the result of calling "
"`larger.can_hold(@smaller)`. This expression is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"我们将我们的测试命名为`larger_can_hold_smaller`，并且创建了我们需要的两个`Rectangle`实例。然后我们调用了assert函数，并将调用`larger.can_hold(@smaller)`的结果传给它。这个表达式应该返"
"回 `true`，所以我们的测试应该通过。让我们拭目以待吧!"

#: src/ch09-01-how-to-write-tests.md:198
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:205
msgid "It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:"
msgstr "它确实通过了!让我们再增加���个测试，这次是断言一个较小的矩形不能容纳一个较大的矩形："

#: src/ch09-01-how-to-write-tests.md:209
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width && *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"#     #[test]\n"
"#     fn larger_can_hold_smaller() {\n"
"#         let larger = Rectangle { height: 7, width: 8, };\n"
"#         let smaller = Rectangle { height: 1, width: 5, };\n"
"# \n"
"#         assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"#     }\n"
"# \n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle { height: 7, width: 8, };\n"
"        let smaller = Rectangle { height: 1, width: 5, };\n"
"\n"
"        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width && *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"#     #[test]\n"
"#     fn larger_can_hold_smaller() {\n"
"#         let larger = Rectangle { height: 7, width: 8, };\n"
"#         let smaller = Rectangle { height: 1, width: 5, };\n"
"# \n"
"#         assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"#     }\n"
"# \n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle { height: 7, width: 8, };\n"
"        let smaller = Rectangle { height: 1, width: 5, };\n"
"\n"
"        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch09-01-how-to-write-tests.md:258
msgid ""
"Because the correct result of the `can_hold` function in this case is `false`, we need to negate that result before we pass it to the assert function. As a result, our test will pass "
"if `can_hold` returns false:"
msgstr "因为在这种情况下，`can_hold`函数的正确结果是`false`，我们需要在传递给assert函数之前否定这个结果。因此，如果`can_hold`返回false，我们的测试将通过："

#: src/ch09-01-how-to-write-tests.md:260
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"    running 2 tests\n"
"    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"    running 2 tests\n"
"    test adder::lib::tests::smaller_cannot_hold_larger … ok\n"
"    test adder::lib::tests::larger_can_hold_smaller … ok\n"
"    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:268
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the `can_hold` method by replacing the "
"greater-than sign with a less-than sign when it compares the widths:"
msgstr "两个测试都通过了!现在让我们看看当我们在代码中引入一个错误时，我们的测试结果会怎样。我们将改变`can_hold`方法的实现，当它比较宽度时，将大于号替换为小于号："

#: src/ch09-01-how-to-write-tests.md:270
msgid ""
"```rust\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width < *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width < *other.width && *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:282
msgid "Running the tests now produces the following:"
msgstr "现在运行测试产生以下结果："

#: src/ch09-01-how-to-write-tests.md:284
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"test adder::lib::tests::larger_can_hold_smaller ... fail\n"
"failures:\n"
"   adder::lib::tests::larger_can_hold_smaller - panicked with [167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ].\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::smaller_cannot_hold_larger … ok\n"
"test adder::lib::tests::larger_can_hold_smaller … fail\n"
"failures:\n"
"   adder::lib::tests::larger_can_hold_smaller - panicked with [167190012635530104759003347567405866263038433127524 (‘rectangle cannot hold’), ].\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch09-01-how-to-write-tests.md:295
msgid "Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` is not less than `5`."
msgstr "我们的测试发现了这个错误! 因为`larger.width`是`8`，`smaller.width`是`5`，`can_hold`中的宽度比较现在返回`false`：因为`8`不比`5`小。"

#: src/ch09-01-how-to-write-tests.md:297
msgid "## Checking for panics with `should_panic`"
msgstr "## 用`should_panic`检查panic情况"

#: src/ch09-01-how-to-write-tests.md:299
msgid ""
"In addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the Guess type in Listing 9-8. Other code "
"that uses `Guess` depends on the guarantee that `Guess` instances will contain only values between `1` and `100`. We can write a test that ensures that attempting to create a `Guess` "
"instance with a value outside that range panics."
msgstr ""
"除了检查返回值之外，检查我们的代码是否按照我们所期望的那样处理错误条件也很重要。例如，考虑示例9-8中的Guess类型。其他使用`Guess`的代码依赖于保证`Guess`实例只包含`1`和`100`之间的值。我"
"们可以写一个测试，以确保试图创建的`Guess`实例的值不在这个范围内时，会发生panic。"

#: src/ch09-01-how-to-write-tests.md:301
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t "
"panic."
msgstr "我们通过在我们的测试函数中添加属性`should_panic`来做到这一点。如果函数中的代码出现panic，则测试通过；如果函数中的代码没有出现panic，则测试失败。"

#: src/ch09-01-how-to-write-tests.md:303
msgid "Listing 9-8 shows a test that checks that the error conditions of `GuessTrait::new` happen when we expect them to."
msgstr "示例9-8显示了一个测试，检查`GuessTrait::new`的错误条件是否在我们期望的时候发生。"

#: src/ch09-01-how-to-write-tests.md:307
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Guess {\n"
"    value: u64,\n"
"}\n"
"\n"
"trait GuessTrait {\n"
"    fn new(value: u64) -> Guess;\n"
"}\n"
"\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 || value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Guess {\n"
"    value: u64,\n"
"}\n"
"\n"
"trait GuessTrait {\n"
"    fn new(value: u64) -> Guess;\n"
"}\n"
"\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 || value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:341
msgid "<span class=\"caption\">Listing 9-8: Testing that a condition will cause a panic</span>"
msgstr "<span class=“caption”>示例9-8：测试一个条件是否会导致panic</span>"

#: src/ch09-01-how-to-write-tests.md:343
msgid "We place the `#[should_panic]` attribute after the `#[test]` attribute and before the test function it applies to. Let’s look at the result when this test passes:"
msgstr "我们把`#[should_panic]`属性放在`#[test]`属性之后和它适用的测试函数之前。让我们看一下这个测试通过后的结果："

#: src/ch09-01-how-to-write-tests.md:345
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 … ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:352
msgid "Looks good! Now let’s introduce a bug in our code by removing the condition that the new function will panic if the value is greater than `100`:"
msgstr "看起来不错! 现在让我们在代码中引入一个错误，删除新函数在值大于`100`时将发生panic的条件："

#: src/ch09-01-how-to-write-tests.md:354
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64,\n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64,\n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch09-01-how-to-write-tests.md:379
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr "当我们运行示例9-8中的测试时，它将失败："

#: src/ch09-01-how-to-write-tests.md:381
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - expected panic but finished successfully.\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - expected panic but finished successfully.\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch09-01-how-to-write-tests.md:390
msgid ""
"We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with `#[should_panic]`. The failure we got means that the code in "
"the test function did not cause a panic."
msgstr "在这种情况下，我们没有得到一个非常有用的消息，但是当我们看测试函数时，我们看到它被注解为`#[should_panic]`。我们得到的失败意味着测试函数中的代码并没有引起panic。"

#: src/ch09-01-how-to-write-tests.md:392
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would pass even if the test panics for a different reason from the one we were expecting. To make `should_panic` "
"tests more precise, we can add an optional expected parameter to the `should_panic` attribute. The test harness will make sure that the failure message contains the provided text. "
"For example, consider the modified code for `Guess` in Listing 9-9 where the new function panics with different messages depending on whether the value is too small or too large."
msgstr ""
"使用`should_panic`的测试可能是不精确的。即使测试的panic原因与我们所期望的不同, 但只要发生了panic，一个`should_panic`测试就一定会通过。为了使`should_panic`测试更加精确，我们可以在"
"`should_panic`属性中添加一个可选的预期参数。该测试限制将确保故障信息包含所提供的文本。例如，考虑示例9-9中`Guess`的修改后的代码，新函数根据数值过小或过大的情况，以不同的消息进行恐慌。"

#: src/ch09-01-how-to-write-tests.md:396
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64,\n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"# impl GuessImpl of GuessTrait {\n"
"#     fn new(value: u64) -> Guess {\n"
"#         if value < 1 {\n"
"#             panic_with_felt252('Guess must be >= 1');\n"
"#         } else if value > 100 {\n"
"#             panic_with_felt252('Guess must be <= 100');\n"
"#         }\n"
"# \n"
"#         Guess { value, }\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Guess;\n"
"#     use super::GuessTrait;\n"
"# \n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100',))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64,\n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"# impl GuessImpl of GuessTrait {\n"
"#     fn new(value: u64) -> Guess {\n"
"#         if value < 1 {\n"
"#             panic_with_felt252('Guess must be >= 1');\n"
"#         } else if value > 100 {\n"
"#             panic_with_felt252('Guess must be <= 100');\n"
"#         }\n"
"# \n"
"#         Guess { value, }\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Guess;\n"
"#     use super::GuessTrait;\n"
"# \n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100',))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch09-01-how-to-write-tests.md:433
msgid "<span class=\"caption\">Listing 9-9: Testing for a panic with a panic message containing the error message string</span>"
msgstr "<span class=“caption”>示例9-9：用包含错误信息字符串的恐慌信息来测试panic</span>"

#: src/ch09-01-how-to-write-tests.md:435
msgid ""
"This test will pass because the value we put in the `should_panic` attribute’s expected parameter is the array of string of the message that the `Guess::new` function panics with. We "
"need to specify the entire panic message that we expect."
msgstr "这个测试将通过，因为我们放在`should_panic`属性的预期参数中的值是`Guess::new`函数panic信息的字符串阵列。我们需要指定我们期望的整个panic信息。"

#: src/ch09-01-how-to-write-tests.md:437
msgid ""
"To see what happens when a `should_panic` test with an expected message fails, let’s again introduce a bug into our code by swapping the bodies of the if `value < 1` and the else if "
"`value > 100` blocks:"
msgstr "为了看看当一个带有预期信息的 `should_panic` 测试失败时会发生什么，让我们再次把if `value < 1`和else if `value > 100`块的主体互换，从而在我们的代码中引入一个错误："

#: src/ch09-01-how-to-write-tests.md:439
msgid ""
"```rust\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1');\n"
"            panic(data);\n"
"        } else if value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100',))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1');\n"
"            panic(data);\n"
"        } else if value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100',))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:469
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "这一次，当我们运行`should_panic`测试时，它将失败："

#: src/ch09-01-how-to-write-tests.md:471
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - panicked with [6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 … fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - panicked with [6224920189561486601619856539731839409791025 (‘Guess must be >= 1’), ].\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch09-01-how-to-write-tests.md:481
msgid ""
"The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this "
"case was `Guess must be >= 1`. Now we can start figuring out where our bug is!"
msgstr ""
"失败信息表明，这个测试确实像我们预期的那样发生了panic，但是panic信息不包括预期的字符串。在这种情况下，我们得到的panic信息是 `Guess must be >= 1`。现在我们可以开始找出我们的错误所在了!"

#: src/ch09-01-how-to-write-tests.md:483
msgid "## Running Single Tests"
msgstr "## 运行单一测试"

#: src/ch09-01-how-to-write-tests.md:485
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you might want to run only the tests pertaining to that code. You can "
"choose which tests to run by passing `scarb cairo-test` an option `-f` (for \"filter\"), followed by the name of the test you want to run as an argument."
msgstr ""
"有时，运行一个完整的测试套件可能需要很长的时间。如果你正在处理某个特定领域的代码，你可能只想运行与该代码有关的测试。你可以通过传递`scarb cairo-test`以及`-f`(“filter”)你想运行的测试名"
"称作为参数来选择运行哪些测试。"

#: src/ch09-01-how-to-write-tests.md:487
msgid "To demonstrate how to run a single test, we’ll first create two tests functions, as shown in Listing 9-10, and choose which ones to run."
msgstr "为了演示如何运行一个测试，我们将首先创建两个测试函数，如示例9-10所示，并选择运行哪一个。"

#: src/ch09-01-how-to-write-tests.md:491
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        let result = 3 + 2;\n"
"        assert(result == 5, 'result is not 5');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, ‘result is not 4’);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        let result = 3 + 2;\n"
"        assert(result == 5, ‘result is not 5’);\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:508
msgid "<span class=\"caption\">Listing 9-10: Two tests with two different names</span>"
msgstr "<span class=“caption”>示例9-10：两个不同名称的测试</span>"

#: src/ch09-01-how-to-write-tests.md:510
msgid "We can pass the name of any test function to `cairo-test` to run only that test using the `-f` flag:"
msgstr "我们可以将任何测试函数的名称传递给`cairo-test`，以使用`-f` 标志只运行该测试："

#: src/ch09-01-how-to-write-tests.md:512
msgid ""
"```shell\n"
"$ scarb cairo-test -f add_two_and_two\n"
"running 1 tests\n"
"test adder::lib::tests::add_two_and_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test -f add_two_and_two\n"
"running 1 tests\n"
"test adder::lib::tests::add_two_and_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:519
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t match that name. The test output lets us know we had one more test that didn’t run by displaying 1 filtered "
"out at the end."
msgstr "只有名称为`add_two_and_two` 的测试被运行了，其他的测试不符合这个名称。测试输出最后显示了1个测试被过滤掉，让我们知道我们还有一个测试没有运行。"

#: src/ch09-01-how-to-write-tests.md:521
msgid "We can also specify part of a test name, and any test whose name contains that value will be run."
msgstr "我们还可以指定测试名称的一部分，任何名称包含该值的测试都将被运行。"

#: src/ch09-01-how-to-write-tests.md:523
msgid "## Ignoring Some Tests Unless Specifically Requested"
msgstr "## 在非特别指定时，忽略一些测试"

#: src/ch09-01-how-to-write-tests.md:525
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of `scarb cairo-test`. Rather than listing as arguments all "
"tests you do want to run, you can instead annotate the time-consuming tests using the `ignore` attribute to exclude them, as shown here:"
msgstr ""
"有时一些特定的测试执行起来非常耗时，所以你可能想在大多数`scarb cairo-test`的运行中排除它们。与其将所有你想运行的测试列为参数，不如使用`ignore` 属性对耗时的测试进行注释，将其排除在外，"
"如图所示："

#: src/ch09-01-how-to-write-tests.md:529
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() { // code that takes an hour to run\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() { // code that takes an hour to run\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:545
msgid "After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr "对于想要排除的测试，我们在 `#[test]`之后，添加了 `#[ignore]`行。现在，当我们运行我们的测试时，`it_works`会运行，但`expensive_test`不会："

#: src/ch09-01-how-to-write-tests.md:547
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::expensive_test ... ignored\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::expensive_test ... ignored\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
"```"

#: src/ch09-01-how-to-write-tests.md:555
msgid "The `expensive_test` function is listed as ignored."
msgstr "`expensive_test`函数被列为`ignored`。"

#: src/ch09-01-how-to-write-tests.md:557
msgid ""
"When you’re at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run `scarb cairo-test --include-ignored` to "
"run all tests whether they’re ignored or not."
msgstr "当你到了需要检查被忽略的测试结果的时候，而且你有时间等待测试结果，你可以运行`scarb cairo-test --include-ignored`来运行所有的测试，无论它们是否被标记忽略。"

#: src/ch09-01-how-to-write-tests.md:559
msgid "## Testing recursive functions or loops"
msgstr "## 测试递归函数或循环"

#: src/ch09-01-how-to-write-tests.md:561
msgid ""
"When testing recursive functions or loops, you must provide the test with a maximum amount of gas that it can consume. This prevents running infinite loops or consuming too much gas, "
"and can help you benchmark the efficiency of your implementations. To do so, you must add the `#[available_gas(<Number>)]` attribute on the test function. The following example shows "
"how to use it:"
msgstr ""
"在测试递归函数或循环时，必须为测试提供可消耗的最大gas。这样可以防止运行无限循环或消耗过多gas，还可以帮助对您的代码实现效率进行基准测试。为此，必须在测试函数中添加 "
"`#[available_gas(<Number>)]` 属性。下面的示例展示了如何使用该属性："

#: src/ch09-01-how-to-write-tests.md:565
msgid ""
"```rust\n"
"fn sum_n(n: usize) -> usize {\n"
"    let mut i = 0;\n"
"    let mut sum = 0;\n"
"    loop {\n"
"        if i == n {\n"
"            sum += i;\n"
"            break;\n"
"        };\n"
"        sum += i;\n"
"        i += 1;\n"
"    };\n"
"    sum\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod test {\n"
"    use super::sum_n;\n"
"    #[test]\n"
"    #[available_gas(2000000)]\n"
"    fn test_sum_n() {\n"
"        let result = sum_n(10);\n"
"        assert(result == 55, 'result is not 55');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn sum_n(n: usize) -> usize {\n"
"    let mut i = 0;\n"
"    let mut sum = 0;\n"
"    loop {\n"
"        if i == n {\n"
"            sum += i;\n"
"            break;\n"
"        };\n"
"        sum += i;\n"
"        i += 1;\n"
"    };\n"
"    sum\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod test {\n"
"    use super::sum_n;\n"
"    #[test]\n"
"    #[available_gas(2000000)]\n"
"    fn test_sum_n() {\n"
"        let result = sum_n(10);\n"
"        assert(result == 55, 'result is not 55');\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:592
msgid "## Benchmarking the gas usage of a specific operation"
msgstr "## 测定特定操作的gas使用量"

#: src/ch09-01-how-to-write-tests.md:594
msgid "When you want to benchmark the gas usage of a specific operation, you can use the following pattern in your test function."
msgstr "如果要对特定操作的gas用量进行基准测试，可以在测试函数中使用以下模式。"

#: src/ch09-01-how-to-write-tests.md:596
msgid ""
"```rust\n"
"let initial = testing::get_available_gas();\n"
"gas::withdraw_gas().unwrap();\n"
"    /// code we want to bench.\n"
"(testing::get_available_gas() - x).print();\n"
"```"
msgstr ""
"```rust\n"
"let initial = testing::get_available_gas();\n"
"gas::withdraw_gas().unwrap();\n"
"    /// code we want to bench.\n"
"(testing::get_available_gas() - x).print();\n"
"```"

#: src/ch09-01-how-to-write-tests.md:603
msgid "The following example shows how to use it to test the gas function of the `sum_n` function above."
msgstr "下面的示例展示了如何使用它来测试上述 `sum_n` 函数的gas用量。"

#: src/ch09-01-how-to-write-tests.md:605
msgid ""
"```rust\n"
"fn sum_n(n: usize) -> usize {\n"
"    let mut i = 0;\n"
"    let mut sum = 0;\n"
"    loop {\n"
"        if i == n {\n"
"            sum += i;\n"
"            break;\n"
"        };\n"
"        sum += i;\n"
"        i += 1;\n"
"    };\n"
"    sum\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod test {\n"
"    use super::sum_n;\n"
"    use debug::PrintTrait;\n"
"    #[test]\n"
"    #[available_gas(2000000)]\n"
"    fn benchmark_sum_n_gas() {\n"
"        let initial = testing::get_available_gas();\n"
"        gas::withdraw_gas().unwrap();\n"
"        /// code we want to bench.\n"
"        let result = sum_n(10);\n"
"        (initial - testing::get_available_gas()).print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn sum_n(n: usize) -> usize {\n"
"    let mut i = 0;\n"
"    let mut sum = 0;\n"
"    loop {\n"
"        if i == n {\n"
"            sum += i;\n"
"            break;\n"
"        };\n"
"        sum += i;\n"
"        i += 1;\n"
"    };\n"
"    sum\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod test {\n"
"    use super::sum_n;\n"
"    use debug::PrintTrait;\n"
"    #[test]\n"
"    #[available_gas(2000000)]\n"
"    fn benchmark_sum_n_gas() {\n"
"        let initial = testing::get_available_gas();\n"
"        gas::withdraw_gas().unwrap();\n"
"        /// code we want to bench.\n"
"        let result = sum_n(10);\n"
"        (initial - testing::get_available_gas()).print();\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-how-to-write-tests.md:636
msgid "The value printed when running `scarb cairo-test` is the amount of gas that was consumed by the operation benchmarked."
msgstr "运行 \"scarb cairo-test \"时打印的值是基准运行所消耗的gas。"

#: src/ch09-01-how-to-write-tests.md:638
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"testing no_listing_09_benchmark_gas ...\n"
"running 1 tests\n"
"[DEBUG]\t                               \t(raw: 0x179f8\n"
"\n"
"test no_listing_09_benchmark_gas::benchmark_sum_n_gas ... ok (gas usage est.: 98030)\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-test\n"
"testing no_listing_09_benchmark_gas ...\n"
"running 1 tests\n"
"[DEBUG]\t                               \t(raw: 0x179f8\n"
"\n"
"test no_listing_09_benchmark_gas::benchmark_sum_n_gas ... ok (gas usage est.: 98030)\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"\n"
"```"

#: src/ch09-01-how-to-write-tests.md:649
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation of the hex number). The total amount consumed by the test is slightly higher at 98030, due to some extra "
"steps required to run the entire test function."
msgstr "这里，\"sum_n \"函数的gas用量为 96760（十六进制数的十进制表示法）。由于运行整个测试功能需要一些额外步骤，因此测试消耗的gas总量略高，为 98030。"

#: src/ch09-01-how-to-write-tests.md:651 src/ch09-02-test-organization.md:97
msgid "<footer id=\"last-change\">Last change: 2023-09-22</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-22</footer>"

#: src/ch09-02-test-organization.md:1
msgid "# Testing Organization"
msgstr "# 测试的组织结构"

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can "
"test private functions. Although Cairo doesn't implement the concept of public/private functions/fields yet, it's good practice to start organizing your code as if it were. "
"Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test."
msgstr ""
"我们把测试主要分成两类：单元测试和集成测试。单元测试小而专注，每次测试一个模块，可以测试私有函数。虽然 Cairo 还没有实现公有/私有函数/字段的概念，但像这样组织代码是一个很好的习惯。集成"
"测试像其他任何外部代码一样使用您的代码，只使用公共接口，并在每个测试中可能使用多个模块。"

#: src/ch09-02-test-organization.md:5
msgid "Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together."
msgstr "为了保证你的库能够按照你的预期运行，从独立和整体的角度编写这两类测试都是非常重要的。"

#: src/ch09-02-test-organization.md:7
msgid "## Unit Tests"
msgstr "## 单元测试"

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests "
"in the `src` directory in each file with the code that they’re testing."
msgstr ""
"单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确地验证某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。"

#: src/ch09-02-test-organization.md:11
msgid "The convention is to create a module named tests in each file to contain the test functions and to annotate the module with `cfg(test)`."
msgstr "规范是在每个文件中创建包含测试函数的 tests 模块，并使用 `cfg(test)` 标注模块。"

#: src/ch09-02-test-organization.md:13
msgid "### The Tests Module and `#[cfg(test)]`"
msgstr "### 测试模块和`#[cfg(test)]`"

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run `scarb cairo-test`, not when you run `cairo-run`. This saves compile "
"time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You’ll see that because integration tests go in a "
"different directory, they don’t need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to specify that they "
"shouldn’t be included in the compiled result."
msgstr ""
"测试模块的 `#[cfg(test)]`注解告诉 Cairo 只在执行`scarb cairo-test` 时才编译和运行测试代码，而在运行 `cairo-run` 时不这么做。这在只希望构建库的时候可以节省编译时间，并且因为它们并没有"
"包含测试，所以能减少编译产生的文件的大小。与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 `#[cfg(test)]`注解。然而单元测试位于与源码相同的文件中，所以你需要使用 "
"`#[cfg(test)]` 来指定他们不应该被包含进编译结果中。"

#: src/ch09-02-test-organization.md:17
msgid "Recall that when we created the new `adder` project in the first section of this chapter, we wrote this first test:"
msgstr "回顾一下，当我们在本章第一节创建新的`adder`项目时，我们写了这个测试："

#: src/ch09-02-test-organization.md:19
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"

#: src/ch09-02-test-organization.md:30 src/ch09-02-test-organization.md:59
msgid "<span class=\"caption\">Filename: src/lib.cairo</span>"
msgstr "<span class=\"caption\">文件名: src/lib.cairo</span>"

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration "
"option is `test`, which is provided by Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we actively run the tests with `scarb "
"cairo-test`. This includes any helper functions that might be within this module, in addition to the functions annotated with `#[test]`."
msgstr ""
"`cfg`属性代表配置，告诉Cairo只有在给定的配置选项的情况下才应该包含下面的项目。在本例中，配置选项是`test`，它由Cairo提供，用于编译和运行测试。通过使用`cfg`属性，Cairo只有在我们用"
"`scarb cairo-test`主动运行测试时才会编译我们的测试代码。这包括任何可能在这个模块中的辅助函数，以及用`#[test]`标注的函数。"

#: src/ch09-02-test-organization.md:34
msgid "## Integration Tests"
msgstr "## 集成测试"

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work "
"correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""
"集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正"
"确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。为了创建集成测试，你需要先创建一个 `tests` 目录。"

#: src/ch09-02-test-organization.md:38
msgid "### The `tests` Directory"
msgstr "### `tests`目录"

#: src/ch09-02-test-organization.md:40
msgid ""
"```shell\n"
"adder\n"
"├── Scarb.toml\n"
"├── src\n"
"│   ├── lib.cairo\n"
"│   ├── tests\n"
"│   │   └── integration_test.cairo\n"
"│   └── tests.cairo\n"
"```"
msgstr ""
"```shell\n"
"adder\n"
"├── Scarb.toml\n"
"├── src\n"
"│   ├── lib.cairo\n"
"│   ├── tests\n"
"│   │   └── integration_test.cairo\n"
"│   └── tests.cairo\n"
"```"

#: src/ch09-02-test-organization.md:50
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests;\n"
"\n"
"fn it_adds_two(a: u8, b: u8) -> u8 {\n"
"    a + b\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests;\n"
"\n"
"fn it_adds_two(a: u8, b: u8) -> u8 {\n"
"    a + b\n"
"}\n"
"```"

#: src/ch09-02-test-organization.md:61
msgid ""
"```rust\n"
"#[cfg(tests)]\n"
"mod integration_tests;\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(tests)]\n"
"mod integration_tests;\n"
"```"

#: src/ch09-02-test-organization.md:66
msgid "<span class=\"caption\">Filename: src/tests.cairo</span>"
msgstr "<span class=\"caption\">文件名：src/tests.cairo</span>"

#: src/ch09-02-test-organization.md:68
msgid "Enter the code in Listing 9-11 into the _src/tests/integration_test.cairo_ file:"
msgstr "将示例9-11中的代码输入到 _src/tests/integration_test.cairo_ 文件："

#: src/ch09-02-test-organization.md:70
msgid ""
"```rust\n"
"use adder::it_adds_two;\n"
"\n"
"#[test]\n"
"#[available_gas(2000000)]\n"
"fn internal() {\n"
"    assert(it_adds_two(2, 2) == 4, 'internal_adder failed');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use adder::it_adds_two;\n"
"\n"
"#[test]\n"
"#[available_gas(2000000)]\n"
"fn internal() {\n"
"    assert(it_adds_two(2, 2) == 4, 'internal_adder failed');\n"
"}\n"
"```"

#: src/ch09-02-test-organization.md:80
msgid "<span class=\"caption\">Filename: src/tests/integration_test.cairo</span>"
msgstr "<span class=\"caption\">文件名：src/tests/integration_test.cairo</span>"

#: src/ch09-02-test-organization.md:82
msgid "We need to bring our tested functions into each test file scope. For that reason we add `use adder::it_adds_two` at the top of the code, which we didn’t need in the unit tests."
msgstr "我们需要在每个测试文件的作用域中引入被测试的函数。出于这个原因，我们在代码的顶部添加了`use adder::it_adds_two`，在单元测试中我们不需要这个。"

#: src/ch09-02-test-organization.md:84
msgid "Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains \"integration_tests\"."
msgstr "然后，为了运行我们所有的集成测试，我们可以添加一个过滤器来仅运行路径包含“integration_tests”的测试。"

#: src/ch09-02-test-organization.md:86
msgid ""
"```shell\n"
"$ scarb test -f integration_tests\n"
"Running cairo-test adder\n"
"testing adder ...\n"
"running 1 tests\n"
"test adder::tests::integration_tests::internal ... ok (gas usage est.: 3770)\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ scarb test -f integration_tests\n"
"Running cairo-test adder\n"
"testing adder ...\n"
"running 1 tests\n"
"test adder::tests::integration_tests::internal ... ok (gas usage est.: 3770)\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch09-02-test-organization.md:95
msgid "The result of the tests is the same as what we've been seeing: one line for each test."
msgstr "测试的结果与我们之前看到的相同：每个测试一行。"

#: src/ch10-00-error-handling.md:1
msgid "# Error handling"
msgstr "# 错误处理"

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you to address potential issues in your code, but also make it easier to "
"create programs that are adaptable and maintainable. By examining different approaches to managing errors, such as pattern matching with the Result enum, using the ? operator for "
"more ergonomic error propagation, and employing the unwrap or expect methods for handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. "
"These concepts are crucial for building robust applications that can effectively handle unexpected situations, ensuring your code is ready for production."
msgstr ""
"在本章中，我们将探讨Cairo提供的各种错误处理技术，这些技术不仅能让你解决代码中的潜在问题，还能让你更容易创建易适应和易维护的程序。通过研究管理错误的不同方法，如用Result枚举进行模式匹"
"配，使用 ?  操作符进行更人性化的错误传播，以及采用unwrap或expect方法来处理可恢复的错误，你将对Cairo的错误处理功能有更深入的了解。这些概念对于构建强大的应用程序至关重要，它可以有效地处"
"理意外情况，确保你的代码可以用于生产环境。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "# Unrecoverable Errors with panic"
msgstr "# 无法恢复的错误与恐慌（panic）"

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in runtime errors. While the panic function from the core library doesn't provide a resolution for these "
"errors, it does acknowledge their occurrence and terminates the program. There are two primary ways that a panic can be triggered in Cairo: inadvertently, through actions causing the "
"code to panic (e.g., accessing an array beyond its bounds), or deliberately, by invoking the panic function."
msgstr ""
"在Cairo中，程序执行过程中可能会出现意外问题，导致运行时错误。虽然核心库中的panic函数并没有为这些错误提供解决方案，但它确实承认这些错误的发生并终止程序。在Cairo中，有两种主要的方式可以"
"触发panic：无意地通过导致代码panic的行为（例如，访问一个超出其界限的数组），或故意地，通过调用panic函数。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The `panic` function takes an array as an argument, which can be used to provide an error message and performs "
"an unwind process where all variables are dropped and dictionaries squashed to ensure the soundness of the program to safely terminate the execution."
msgstr ""
"当发生恐慌时，它会导致程序突然终止。`panic` 函数接受一个数组作为参数，可以用来提供错误消息，并执行一个解除过程，在这个过程中所有变量都会被丢弃，字典被压缩，以确保程序的健全性，安全地"
"终止执行。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid "Here is how we can `panic` from inside a program and return the error code `2`:"
msgstr "下面是我们如何在一个程序中`panic`并返回错误代码`2`："

#: src/ch10-01-unrecoverable-errors-with-panic.md:11
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append(2);\n"
"    if true == true {\n"
"        panic(data);\n"
"    }\n"
"    'This line isn\\'t reached'.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append(2);\n"
"    if true == true {\n"
"        panic(data);\n"
"    }\n"
"    'This line isn\\'t reached'.print();\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:24
msgid "Running the program will produce the following output:"
msgstr "运行该程序将产生以下输出："

#: src/ch10-01-unrecoverable-errors-with-panic.md:26
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"Run panicked with [2 (''), ].\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"Run panicked with [2 (''), ].\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid "As you can notice in the output, the print statement is never reached, as the program terminates after encountering the `panic` statement."
msgstr "正如你在输出中所注意到的，打印语句没有被执行，因为程序在遇到`panic`语句后就终止了。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use the `panic_with_felt252` function. This function serves as an abstraction of the array-defining process "
"and is often preferred due to its clearer and more concise expression of intent. By using `panic_with_felt252`, developers can panic in a one-liner by providing a felt252 error "
"message as an argument, making the code more readable and maintainable."
msgstr ""
"Cairo 中处理恐慌的另一种更符合习惯的方法是使用 `panic_with_felt252` 函数。这个函数作为定义数组过程的抽象，通常更受欢迎，因为它表达意图更清晰、更简洁。通过使用 `panic_with_felt252`，开"
"发者可以通过提供一个 felt252 类型的错误消息作为参数，在一行代码中实现恐慌，使代码更易读和可维护。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:35
msgid "Let's consider an example:"
msgstr "让我们来考察一个例子："

#: src/ch10-01-unrecoverable-errors-with-panic.md:37
msgid ""
"```rust\n"
"fn main() {\n"
"    panic_with_felt252(2);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    panic_with_felt252(2);\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that case, if there is no need for an array and multiple values to be returned within the error, so "
"`panic_with_felt252` is a more succinct alternative."
msgstr "执行这个程序会产生和之前一样的错误信息。在这种情况下，如果在返回错误是不需要一个数组和多个值，那么`panic_with_felt252`是一个更简洁的选择。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "## nopanic notation"
msgstr "## nopanic记号"

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid "You can use the `nopanic` notation to indicate that a function will never panic. Only `nopanic` functions can be called in a function annotated as `nopanic`."
msgstr "你可以使用`nopanic`记号来表示一个函数永远不会恐慌。只有 `nopanic`函数可以在标注为 `nopanic`的函数中被调用。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:49 src/ch10-01-unrecoverable-errors-with-panic.md:84 src/appendix-03-derivable-traits.md:17 src/appendix-03-derivable-traits.md:42
#: src/appendix-03-derivable-traits.md:63 src/appendix-03-derivable-traits.md:85 src/appendix-03-derivable-traits.md:118 src/appendix-03-derivable-traits.md:155
msgid "Example:"
msgstr "例子:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:51
msgid ""
"```rust,noplayground\n"
"fn function_never_panic() -> felt252 nopanic {\n"
"    42\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn function_never_panic() -> felt252 nopanic {\n"
"    42\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:57
msgid "Wrong example:"
msgstr "错误的例子："

#: src/ch10-01-unrecoverable-errors-with-panic.md:59
msgid ""
"```rust,noplayground\n"
"fn function_never_panic() nopanic {\n"
"    assert(1 == 1, 'what');\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn function_never_panic() nopanic {\n"
"    assert(1 == 1, 'what');\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:65
msgid "If you write the following function that includes a function that may panic you will get the following error:"
msgstr "如果你写了以下函数，其中包括一个可能会panic的函数，你会得到以下错误："

#: src/ch10-01-unrecoverable-errors-with-panic.md:67
msgid ""
"```shell\n"
"error: Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:12\n"
"    assert(1 == 1, 'what');\n"
"           ^****^\n"
"Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:5\n"
"    assert(1 == 1, 'what');\n"
"    ^********************^\n"
"```"
msgstr ""
"```shell\n"
"error: Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:12\n"
"    assert(1 == 1, 'what');\n"
"           ^****^\n"
"Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:5\n"
"    assert(1 == 1, 'what');\n"
"    ^********************^\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:78
msgid "Note that there are two functions that may panic here, assert and equality."
msgstr "请注意，有两个函数可能会在这里发生panic，即断言和相等比较。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:80
msgid "## panic_with attribute"
msgstr "## panic_with 属性"

#: src/ch10-01-unrecoverable-errors-with-panic.md:82
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an `Option` or `Result`. This attribute takes two arguments, which are the data that is passed as the panic "
"reason as well as the name for a wrapping function. It will create a wrapper for your annotated function which will panic if the function returns `None` or `Err`, the panic function "
"will be called with the given data."
msgstr ""
"您可以使用 `panic_with` 属性来标记返回 `Option` 或 `Result` 的函数。该属性需要两个参数，即作为 panic 原因传递的数据以及包装函数的名称。它将为您标注的函数创建一个封装函数，如果函数返"
"回 `None` 或 `Err`，该封装函数将被调用，并使用给定的数据。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:86
msgid ""
"```rust\n"
"#[panic_with('value is 0', wrap_not_zero)]\n"
"fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
"    if value == 0 {\n"
"        Option::None\n"
"    } else {\n"
"        Option::Some(value)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    wrap_if_not_zero(0); // this returns None\n"
"    wrap_not_zero(0); // this panic with 'value is 0'\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[panic_with('value is 0', wrap_not_zero)]\n"
"fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
"    if value == 0 {\n"
"        Option::None\n"
"    } else {\n"
"        Option::Some(value)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    wrap_if_not_zero(0); // this returns None\n"
"    wrap_not_zero(0); // this panic with 'value is 0'\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:102
msgid "## Using assert"
msgstr "## 使用断言(assert)"

#: src/ch10-01-unrecoverable-errors-with-panic.md:104
msgid ""
"The assert function from the Cairo core library is actually a utility function based on panics. It asserts that a boolean expression is true at runtime, and if it is not, it calls "
"the panic function with an error value. The assert function takes two arguments: the boolean expression to verify, and the error value. The error value is specified as a felt252, so "
"any string passed must be able to fit inside a felt252."
msgstr ""
"Cairo核心库中的assert函数实际上是一个基于panic的实用函数。它断言一个布尔表达式在运行时是真的，如果不是，它就会调用带有错误值的panic函数。assert函数需要两个参数：要验证的布尔表达式，以"
"及错误值。错误值被指定为felt252，所以任何传递的字符串都必须能够容纳在felt252中。"

#: src/ch10-01-unrecoverable-errors-with-panic.md:106
msgid "Here is an example of its usage:"
msgstr "下面是它的一个使用例子："

#: src/ch10-01-unrecoverable-errors-with-panic.md:108
msgid ""
"```rust\n"
"fn main() {\n"
"    let my_number: u8 = 0;\n"
"\n"
"    assert(my_number != 0, 'number is zero');\n"
"\n"
"    100 / my_number;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let my_number: u8 = 0;\n"
"\n"
"    assert(my_number != 0, 'number is zero');\n"
"\n"
"    100 / my_number;\n"
"}\n"
"```"

#: src/ch10-01-unrecoverable-errors-with-panic.md:118
msgid ""
"We are asserting in main that `my_number` is not zero to ensure that we're not performing a division by 0.\n"
"In this example, `my_number` is zero so the assertion will fail, and the program will panic\n"
"with the string 'number is zero' (as a felt252) and the division will not be reached."
msgstr ""
"我们在`main`中断言`my_number`不是0，以确保我们没有进行除以0的操作。\n"
"在这个例子中，`my_number`是零，所以断言会失败，程序会panic，\n"
"并给出 'number is zero'的字符串结果（以felt252的形式），除法将不会被执行。"

#: src/ch10-02-recoverable-errors.md:1
msgid "# Recoverable Errors with `Result`"
msgstr "# 可恢复的错误与 `Result`"

#: src/ch10-02-recoverable-errors.md:3 src/ch10-02-recoverable-errors.md:56
msgid "<br />"
msgstr "<br />"

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to. For "
"example, if you try to add two large integers and the operation overflows because the sum exceeds the maximum representable value, you might want to return an error or a wrapped "
"result instead of causing undefined behavior or terminating the process."
msgstr ""
"大多数错误并没有严重到需要程序完全停止的程度。有时，当一个函数失败时，它的原因是你可以很容易地解释和应对的。例如，如果你试图将两个大的整数相加，而操作溢出，因为总和超过了最大的可表示"
"值，你可能想返回一个错误或一个包装好的结果，而不是引起未定义行为或终止程序。"

#: src/ch10-02-recoverable-errors.md:7
msgid "## The `Result` enum"
msgstr "## `Result`枚举"

#: src/ch10-02-recoverable-errors.md:9
msgid "Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows:"
msgstr "回顾第8章中的[“通用数据类型”](ch08-01-generic-data-types.md#enums) 一节中，`Result` 枚举被定义为具有两个变体，即 `Ok` 和 `Err`，如下所示："

#: src/ch10-02-recoverable-errors.md:20
msgid "## The `ResultTrait`"
msgstr "## `ResultTrait`"

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` enum, such as unwrapping values, checking whether the `Result` is `Ok` or `Err`, and panicking with a "
"custom message. The `ResultTraitImpl` implementation defines the logic of these methods."
msgstr "`ResultTrait`trait提供了处理`Result<T, E>`枚举的方法，例如解包值，检查`Result`是`Ok`还是`Err`，以及用自定义的消息进行panic。`ResultTraitImpl`实现定义了这些方法的逻辑。"

#: src/ch10-02-recoverable-errors.md:24
msgid ""
"```rust,noplayground\n"
"trait ResultTrait<T, E> {\n"
"    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> T;\n"
"\n"
"    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
"\n"
"    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -> E;\n"
"\n"
"    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
"\n"
"    fn is_ok(self: @Result<T, E>) -> bool;\n"
"\n"
"    fn is_err(self: @Result<T, E>) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait ResultTrait<T, E> {\n"
"    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> T;\n"
"\n"
"    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
"\n"
"    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -> E;\n"
"\n"
"    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
"\n"
"    fn is_ok(self: @Result<T, E>) -> bool;\n"
"\n"
"    fn is_err(self: @Result<T, E>) -> bool;\n"
"}\n"
"```"

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` variant. If the `Result` is "
"`Ok(x)`, both methods return the value `x`. However, the key difference between the two methods lies in their behavior when the `Result` is in the `Err` variant. The `expect` method "
"allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the "
"`unwrap` method panics with a default error message, providing less information about the cause of the panic."
msgstr ""
"`expect`和`unwrap`方法类似，它们都试图从`Result<T, E>`中提取`T`类型的值，当它处于`Ok`变体时。如果`Result`是 `Ok(x)`，两个方法都返回值 \"x\"。然而，这两个方法的关键区别在于当`Result`是"
"`Err`变量时的行为。`expect`方法允许你提供一个自定义的错误信息（作为`felt252`值）在panic时使用，从而让你获取更多对panic相关的控制和上下文。另一方面，`unwrap`方法用一个默认的错误信息进"
"行panic，提供的关于panic原因的信息较少。"

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two "
"methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more "
"control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic."
msgstr ""
"`expect_err`和`unwrap_err`的行为完全相反。如果`Result`是`Err(x)`，两个方法都返回值`x`。然而，这两个方法的关键区别是在`Result::Ok()`的情况下。`expect_err`方法允许你提供一个自定义的错误"
"信息（作为`felt252`值），在panic时使用，从而让你获取更多对panic相关的控制和上下文。另一方面，`unwrap_err`方法用一个默认的错误信息进行panic，提供的关于panic原因的信息较少。"

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl EDrop: Drop<E>>` in the first four methods signatures. This syntax represents generic type constraints in the "
"Cairo language. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""
"细心的读者可能已经注意到前四个方法签名中的`<impl TDrop: Drop<T>>` and `<impl EDrop: Drop<E>>`。这种语法代表了Cairo语言中的通用类型约束。这些约束表示相关的函数需要分别对通用类型`T`和"
"`E`的`Drop`特性进行实现。"

#: src/ch10-02-recoverable-errors.md:46
msgid "Finally, the `is_ok` and `is_err` methods are utility functions provided by the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr "最后，`is_ok`和`is_err`方法是`ResultTrait`trait提供的实用函数，用于检查`Result`枚举值的成员。"

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Ok` variant, meaning the operation was successful. If the `Result` is the `Err` variant, "
"it returns `false`."
msgstr "`is_ok`获取一个`Result<T, E>`值的快照，如果`Result`是`Ok`成员，则返回`true`，意味着操作成功。如果`Result`是`Err`成员，则返回`false`。"

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` "
"variant, it returns `false`."
msgstr "`is_err`接收一个对`Result<T, E>`值的引用，如果`Result`是`Err`成员，意味着操作遇到了错误，则返回`true`。如果 `Result`是 `Ok`成员，则返回 `false`。"

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of an operation without consuming the Result value, allowing you to perform additional operations or make "
"decisions based on the variant without unwrapping it."
msgstr "当你想在不消耗结果值的情况下检查一个操作的成功或失败时，这些方法很有帮助，允许你执行额外的操作或根据枚举成员做出决定，而不用解开（unwrap）它。"

#: src/ch10-02-recoverable-errors.md:54
msgid "You can find the implementation of the `ResultTrait` [here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr "你可以在[这里](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)找到 `ResultTrait` 的实现。"

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr "有例子总是更容易理解。"

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr "请看一下这个函数签名："

#: src/ch10-02-recoverable-errors.md:62
msgid ""
"```rust,noplayground\n"
"fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
"```"

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the "
"overflowed value if the addition does overflow."
msgstr "它接收两个u128整数，a和b，并返回一个`Result<u128, u128>`，如果加法没有溢出，`Ok`成员存储加法的和，如果加法溢出，`Err’成员存储溢出的值。"

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "现在，我们可以在其他地方使用这个函数。比如说："

#: src/ch10-02-recoverable-errors.md:70
msgid ""
"```rust,noplayground\n"
"fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
"    match u128_overflowing_add(a, b) {\n"
"        Result::Ok(r) => Option::Some(r),\n"
"        Result::Err(r) => Option::None,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
"    match u128_overflowing_add(a, b) {\n"
"        Result::Ok(r) => Option::Some(r),\n"
"        Result::Err(r) => Option::None,\n"
"    }\n"
"}\n"
"```"

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the "
"addition operation. The match expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is "
"`Err(r)`, it returns `Option::None` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow."
msgstr ""
"这里，它接受两个 u128 整数，a 和 b，返回一个 `Option<u128>`。它使用 `u128_overflowing_add` 返回的 `Result` 来确定加法操作的成功或失败。匹配表达式检查 `u128_overflowing_add` 的 "
"`Result`。如果结果是 `Ok(r)`，它返回 `Option::Some(r)`，其中包含求和结果。如果结果是 `Err(r)`，它返回 `Option::None`，表示操作因为溢出而失败。如果发生溢出，该函数不会引发恐慌。"

#: src/ch10-02-recoverable-errors.md:81
msgid ""
"Let's take another example demonstrating the use of `unwrap`.\n"
"First we import the necessary modules:"
msgstr ""
"让我们再举一个例子，演示一下`unwrap`的使用。\n"
"首先我们导入必要的模块："

#: src/ch10-02-recoverable-errors.md:84
msgid ""
"```rust,noplayground\n"
"use core::traits::Into;\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"use result::ResultTrait;\n"
"use result::ResultTraitImpl;\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use core::traits::Into;\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"use result::ResultTrait;\n"
"use result::ResultTraitImpl;\n"
"```"

#: src/ch10-02-recoverable-errors.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::"
"Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`."
msgstr ""
"在这个例子中，`parse_u8`函数接收一个`felt252`的整数，并尝试用`try_into`方法将其转换为`u8`的整数。如果成功，它返回`Result::Ok(value)`，否则它返回`Result::Err('Invalid integer')`。"

#: src/ch10-02-recoverable-errors.md:94
msgid ""
"```rust,noplayground\n"
"fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"    match s.try_into() {\n"
"        Option::Some(value) => Result::Ok(value),\n"
"        Option::None => Result::Err('Invalid integer'),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"    match s.try_into() {\n"
"        Option::Some(value) => Result::Ok(value),\n"
"        Option::None => Result::Err('Invalid integer'),\n"
"    }\n"
"}\n"
"```"

#: src/ch10-02-recoverable-errors.md:103
msgid "<span class=\"caption\">Listing 10-1: Using the Result type</span>"
msgstr "<span class=“caption”>示例10-1：使用Result 类型</span>"

#: src/ch10-02-recoverable-errors.md:105
msgid "Our two test cases are:"
msgstr "我们的两个测试案例是："

#: src/ch10-02-recoverable-errors.md:107
msgid ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::parse_u8;\n"
"    #[test]\n"
"    fn test_felt252_to_u8() {\n"
"        let number: felt252 = 5_felt252;\n"
"        // should not panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_felt252_to_u8_panic() {\n"
"        let number: felt252 = 256_felt252;\n"
"        // should panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::parse_u8;\n"
"    #[test]\n"
"    fn test_felt252_to_u8() {\n"
"        let number: felt252 = 5_felt252;\n"
"        // should not panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_felt252_to_u8_panic() {\n"
"        let number: felt252 = 256_felt252;\n"
"        // should panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the "
"`u8` range, expecting the `unwrap` method to panic with the error message 'Invalid integer'."
msgstr "第一个测试函数是测试从`felt252`到`u8`的有效转换，期望`unwrap`方法不要panic。第二个测试函数试图转换一个超出`u8`范围的值，期望`unwrap`方法panic，错误信息是 'Invalid integer'。"

#: src/ch10-02-recoverable-errors.md:139
msgid "> We could have also used the #[should_panic] attribute here."
msgstr "> 我们也可以在这里使用 #[should_panic] 属性。"

#: src/ch10-02-recoverable-errors.md:141
msgid "### The `?` operator ?"
msgstr "### `?`运算符?"

#: src/ch10-02-recoverable-errors.md:143
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator is used for more idiomatic and concise error handling. When you use the `?` operator on a `Result` or "
"`Option` type, it will do the following:"
msgstr "我们要谈的最后一个操作符是`?`操作符。`?`运算符用于更成文和简明的错误处理。当你在 `Result`或 `Option`类型上使用`?`运算符时，它将做以下事情："

#: src/ch10-02-recoverable-errors.md:145
msgid ""
"- If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly.\n"
"- If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately returning from the function."
msgstr ""
"- 如果值是`Result::Ok(x)`或`Option::Some(x)`，它将直接返回内部值`x`。\n"
"- 如果值是`Result::Err(e)`或`Option::None`，它将通过立即从函数返回来传播错误或`None`。"

#: src/ch10-02-recoverable-errors.md:148
msgid "The `?` operator is useful when you want to handle errors implicitly and let the calling function deal with them."
msgstr "当你想隐式处理错误并让调用函数处理它们时，`?`操作符很有用。"

#: src/ch10-02-recoverable-errors.md:150
msgid "Here is an example."
msgstr "下面是一个例子。"

#: src/ch10-02-recoverable-errors.md:152
msgid ""
"```rust,noplayground\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"

#: src/ch10-02-recoverable-errors.md:161
msgid "<span class=\"caption\">Listing 10-1: Using the `?` operator</span>"
msgstr "<span class=“caption”>示例 10-1: 使用 `?` 操作符</span>"

#: src/ch10-02-recoverable-errors.md:163
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8`. The `?` operator is used to propagate the error, if any, or unwrap the successful value."
msgstr "`do_something_with_parse_u8`函数接收一个`felt252`值作为输入并调用`parse_u8`。`?`操作符用来传播错误，如果有的话，或者unwrap成功的值。"

#: src/ch10-02-recoverable-errors.md:165
msgid "And with a little test case:"
msgstr "这里还有一个小的测试案例："

#: src/ch10-02-recoverable-errors.md:167
msgid ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"#     let input_to_u8: u8 = parse_u8(input)?;\n"
"#     // DO SOMETHING\n"
"#     let res = input_to_u8 - 1;\n"
"#     Result::Ok(res)\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::do_something_with_parse_u8;\n"
"#     use debug::PrintTrait;\n"
"    #[test]\n"
"    fn test_function_2() {\n"
"        let number: felt252 = 258_felt252;\n"
"        match do_something_with_parse_u8(number) {\n"
"            Result::Ok(value) => value.print(),\n"
"            Result::Err(e) => e.print()\n"
"        }\n"
"    }\n"
"# }\n"
"# \n"
"```"
msgstr ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"#     let input_to_u8: u8 = parse_u8(input)?;\n"
"#     // DO SOMETHING\n"
"#     let res = input_to_u8 - 1;\n"
"#     Result::Ok(res)\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::do_something_with_parse_u8;\n"
"#     use debug::PrintTrait;\n"
"    #[test]\n"
"    fn test_function_2() {\n"
"        let number: felt252 = 258_felt252;\n"
"        match do_something_with_parse_u8(number) {\n"
"            Result::Ok(value) => value.print(),\n"
"            Result::Err(e) => e.print()\n"
"        }\n"
"    }\n"
"# }\n"
"# \n"
"```"

#: src/ch10-02-recoverable-errors.md:198
msgid "The console will print the error \"Invalid Integer\"."
msgstr "控制台将打印错误  “Invalid Integer”。"

#: src/ch10-02-recoverable-errors.md:200
msgid "<br/>"
msgstr "<br/>"

#: src/ch10-02-recoverable-errors.md:202
msgid "### Summary"
msgstr "### 总结"

#: src/ch10-02-recoverable-errors.md:204
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types `T` and `E` "
"representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, checking if the result is "
"`Ok` or `Err`, and panicking with custom messages."
msgstr ""
"我们看到，可恢复的错误可以在Cairo中使用结果枚举来处理，它有两个变体：`Ok`和`Err`。`Result<T, E>`枚举是通用的，其类型`T`和`E`分别代表成功和错误值。`ResultTrait`提供了处理`Result<T, E>`"
"的方法，例如解包值，检查结果是`Ok`还是`Err`，以及用自定义消息进行panic。"

#: src/ch10-02-recoverable-errors.md:206
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use pattern matching to handle the success or failure of an operation. The `?` operator can be used to "
"implicitly handle errors by propagating the error or unwrapping the successful value. This allows for more concise and clear error handling, where the caller is responsible for "
"managing errors raised by the called function."
msgstr ""
"为了处理可恢复的错误，一个函数可以返回一个`Result`类型，并使用模式匹配来处理操作的成功或失败。`?`操作符可用于通过传播错误或解包成功的值来隐含地处理错误。这使得错误处理更加简洁明了，调"
"用者负责管理由被调用函数引发的错误。"

#: src/ch10-02-recoverable-errors.md:208 src/ch99-01-01-introduction-to-smart-contracts.md:73 src/ch99-01-02-a-simple-contract.md:124
msgid "<footer id=\"last-change\">Last change: 2023-11-21</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-21</footer>"

#: src/ch11-00-advanced-features.md:1
msgid "# Advanced Features"
msgstr "# 高级特性"

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr "现在，让我们来了解 Cairo 提供的更多高级功能。"

#: src/ch11-01-operator-overloading.md:1
msgid "# Operator Overloading"
msgstr "# 操作符重载"

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows the redefinition of standard operators, such as addition (+), subtraction (-), multiplication (\\*), and "
"division (/), to work with user-defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"操作符重载是一些编程语言的一个特点，它允许在用户自定义的类型上重新定义标准操作符，如加法（+）、减法（-）、乘法（\\*）和除法（/）。这可以使代码的语法更加直观，因为它使对用户字定义类型"
"的操作与对原始类型的操作表达方式相同。"

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of specific traits. Each operator has an associated trait, and overloading that operator involves providing an "
"implementation of that trait for a custom type.\n"
"However, it's essential to use operator overloading judiciously. Misuse can lead to confusion, making the code more difficult to maintain, for example when there is no semantic "
"meaning to the operator being overloaded."
msgstr ""
"在Cairo中，操作符重载是通过实现特定的trait来实现的。每个操作符都有一个相关的traits，操作符重载涉及到需为一个自定义类型提供该trait的实现。\n"
"然而，明智地使用操作符重载是非常重要的。误用会导致混乱，使代码更难维护，比如当被重载的操作符的语义与操作符原有的语义毫不相干的时候。"

#: src/ch11-01-operator-overloading.md:8
msgid "Consider an example where two `Potions` need to be combined. `Potions` have two data fields, mana and health. Combining two `Potions` should add their respective fields."
msgstr "让我看一个例子，两个 `Potions` 需要合并。`Potions` 有两个数据字段，法力(mana)和健康(health)。合并两个`Potions` 应该是让它们各自的两个字段相加。"

#: src/ch11-01-operator-overloading.md:10
msgid ""
"```rust\n"
"struct Potion {\n"
"    health: felt252,\n"
"    mana: felt252\n"
"}\n"
"\n"
"impl PotionAdd of Add<Potion> {\n"
"    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
"        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana, }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
"    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
"    let super_potion: Potion = health_potion + mana_potion;\n"
"    // Both potions were combined with the `+` operator.\n"
"    assert(super_potion.health == 100, '');\n"
"    assert(super_potion.mana == 100, '');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Potion {\n"
"    health: felt252,\n"
"    mana: felt252\n"
"}\n"
"\n"
"impl PotionAdd of Add<Potion> {\n"
"    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
"        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana, }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
"    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
"    let super_potion: Potion = health_potion + mana_potion;\n"
"    // Both potions were combined with the `+` operator.\n"
"    assert(super_potion.health == 100, '');\n"
"    assert(super_potion.mana == 100, '');\n"
"}\n"
"```"

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. The add function takes two arguments: `lhs` and `rhs` (left and right-hand side). The function body "
"returns a new `Potion` instance, its field values being a combination of `lhs` and `rhs`."
msgstr ""
"在上面的代码中，我们为 `Potion`类型实现`Add`特性。Add函数需要两个参数：`lhs` 和 `rhs`（左手端和右手端，分别表示在运算式的左边还是右边）。函数主体返回一个新的`Potion`实例，其字段值是"
"`lhs`和`rhs`的组合。"

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires specification of the concrete type being overloaded. The overloaded generic trait is `Add<T>`, and we define a "
"concrete implementation for the type `Potion` with `Add<Potion>`."
msgstr "正如例子中所说明的，重载一个操作符需要指定被重载的具体类型。这里被重载用泛型表示的trait是 `Add<Potion>`，所以我们将用 `Add<Potion>`为 ‘Potion`类型定义一个具体的实现。"

#: src/ch11-02-macros.md:1
msgid "# Macros"
msgstr "# 宏"

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their code. They are called `inline_macros` and are a way of writing code that generates other code. In Cairo, "
"there are only two `macros`: `array![]` and `consteval_int!()`."
msgstr ""
"Cairo语言有一些插件可以让开发人员简化代码。它们被称为 `内联宏`（inline_macros），是一种可以生成其他代码的代码编写方式。在Cairo语言中，只有两个 `宏`：\"array![]\"和 \"consteval_int!"
"()\"。"

#: src/ch11-02-macros.md:5
msgid "### Let's start by `array!`"
msgstr "### 让我们从 `array!` 宏开始"

#: src/ch11-02-macros.md:7
msgid ""
"Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing that is redundant. You would first declare the array and then append "
"each value one by one. `array!` is a simpler way of doing this task by combining the two steps.\n"
"At compile-time, the compiler will create an array and append all values passed to the `array!` macro sequentially."
msgstr ""
"有时候，我们需要用在编译时已经知道的值来创建数组。这件事的基本做法是很不优雅且多余的。你需要首先声明数组，然后逐一为数组追加每个值。`array!` 是一种更简单的方法，它将这两个步骤合并在一"
"起。\n"
"在编译时，编译器将创建一个数组，并按顺序追加传递给 `array!` 宏的所有值。"

#: src/ch11-02-macros.md:10
msgid "Without `array!`:"
msgstr "不使用 `array!`:"

#: src/ch11-02-macros.md:12
msgid ""
"```rust\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"    arr.append(2);\n"
"    arr.append(3);\n"
"    arr.append(4);\n"
"    arr.append(5);\n"
"```"
msgstr ""
"```rust\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"    arr.append(2);\n"
"    arr.append(3);\n"
"    arr.append(4);\n"
"    arr.append(5);\n"
"```"

#: src/ch11-02-macros.md:21
msgid "With `array!`:"
msgstr "使用 `array!`:"

#: src/ch11-02-macros.md:23
msgid ""
"```rust\n"
"    let arr = array![1, 2, 3, 4, 5];\n"
"```"
msgstr ""
"```rust\n"
"    let arr = array![1, 2, 3, 4, 5];\n"
"```"

#: src/ch11-02-macros.md:27
msgid "### `consteval_int!`"
msgstr "### `consteval_int!`"

#: src/ch11-02-macros.md:29
msgid ""
"In some situations, a developer might need to declare a constant that is the result of a computation of integers. To compute a constant expression and use its result at compile time, "
"it is required to use the `consteval_int!` macro."
msgstr "在某些情况下，开发人员可能需要声明一个常量，该常量是整数计算的结果。为了在编译时计算常量表达式并使用其结果，需要使用`consteval_int!` 宏。"

#: src/ch11-02-macros.md:31
msgid "Here is an example of `consteval_int!`:"
msgstr "下面是 `consteval_int!`的示例："

#: src/ch11-02-macros.md:33
msgid ""
"```rust\n"
"const a: felt252 = consteval_int!(2 * 2 * 2);\n"
"```"
msgstr ""
"```rust\n"
"const a: felt252 = consteval_int!(2 * 2 * 2);\n"
"```"

#: src/ch11-02-macros.md:37
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "编译器将解释为 `const a: felt252 = 8`"

#: src/ch11-03-hash.md:1
msgid "# Hashes"
msgstr "# 哈希"

#: src/ch11-03-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called a message) of any length into a fixed-size value, typically referred to as a \"hash.\" This transformation "
"is deterministic, meaning that the same input will always produce the same hash value. Hash functions are a fundamental component in various fields, including data storage, "
"cryptography, and data integrity verification - and are very often when developing smart contracts, especially when working with Merkle trees."
msgstr ""
"哈希本质上是一个将任意长度的输入数据（通常称为消息）转换为固定大小值的过程，该值通常称为“哈希”。这种转换是确定性的，这意味着相同的输入将始终生成相同的哈希值。哈希函数是各种领域的基"
"石，包括数据存储、密码学和数据完整性验证 - 并且在开发智能合约时经常使用，尤其是在使用 Merkle 树时。"

#: src/ch11-03-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented in natively in the Cairo library : `Poseidon` and `Pedersen`. We will discuss about when and how to use them, and "
"see examples with cairo programs."
msgstr "本章，我们将介绍 Cairo 库中原生实现的两种哈希函数：Poseidon 和 Pedersen。我们将讨论何时以及如何使用它们，并通过 Cairo 程序展示示例。"

#: src/ch11-03-hash.md:7
msgid "### Hash functions in Cairo"
msgstr "### Cairo中的哈希函数"

#: src/ch11-03-hash.md:9
msgid "The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr "Cairo 核心库提供了两种哈希函数：Pedersen 和 Poseidon。"

#: src/ch11-03-hash.md:11
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on elliptic curve cryptography. These functions perform operations on points along an elliptic curve — essentially, "
"doing math with the locations of these points — which are easy to do in one direction and hard to undo. This one-way difficulty is based on the Elliptic Curve Discrete Logarithm "
"Problem (ECDLP), which is a problem so hard to solve that it ensures the security of the hash function. The difficulty of reversing these operations is what makes the Pedersen hash "
"function secure and reliable for cryptographic purposes."
msgstr ""
"Pedersen 哈希函数是一种基于椭圆曲线密码学的加密算法。这些函数对椭圆曲线上的点进行操作——本质上是使用这些点的位置进行数学运算——这在一个方向上很容易做到，但却很难反过来操作。这种单向性是"
"基于椭圆曲线离散对数问题 (ECDLP)，它是一个很难的问题，可以确保哈希函数的安全性。无法逆转这些操作的困难性使 Pedersen 哈希函数在加密用途上安全可靠。"

#: src/ch11-03-hash.md:13
msgid ""
"Poseidon is a family of hash functions designed for being very efficient as algebraic circuits. Its design is particularly efficient for Zero-Knowledge proof systems, including "
"STARKs (so, Cairo). Poseidon uses a method called a 'sponge construction,' which soaks up data and transforms it securely using a process known as the Hades permutation. Cairo's "
"version of Poseidon is based on a three element state permutation with [specific parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)"
msgstr ""
"Poseidon 是一系列哈希函数，作为代数电路非常高效。它的设计特别适用于零知识证明系统，包括 STARKs (所以也适用于 Cairo)。Poseidon 使用一种称为“sponge construction”的方法，该方法吸收数据并"
"使用称为 Hades 置换的过程安全地转换数据。Cairo 版本的 Poseidon 基于具有三元素状态置换和 [特定参数](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)的设计。"

#: src/ch11-03-hash.md:15
msgid "#### When to use them ?"
msgstr "#### 何时使用它们？"

#: src/ch11-03-hash.md:17
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to compute the addresses of variables in storage (for example, `LegacyMap` uses Pedersen to hash the keys of "
"a storage mapping on Starknet). However, as Poseidon is cheaper and faster than Pedersen when working with STARK proofs system, it's now the recommended hash function to use in Cairo "
"programs."
msgstr ""
"Pedersen 是 Starknet 上最初使用的哈希函数，现在仍用于计算存储中变量的地址（例如，`LegacyMap` 使用 Pedersen 对 Starknet 上存储映射的键进行哈希）。然而，由于 Poseidon 在处理 STARK 证明"
"系统时比 Pedersen 更便宜，更快，因此现在它已成为 Cairo 程序中推荐使用的哈希函数。"

#: src/ch11-03-hash.md:19
msgid "### Working with Hashes"
msgstr "### 使用哈希函数"

#: src/ch11-03-hash.md:21
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is implemented for all types that can be converted to `felt252`, including `felt252` itself. For more complex "
"types like structs, deriving `Hash` allows them to be hashed easily using the hash function of your choice - given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such as `Array<T>` or a `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""
"核心库使哈希操作变得简单。`Hash` trait适用于所有可以转换为 `felt252`的类型，包括 `felt252`本身。对于像结构体这样更复杂的类型，派生 `Hash`允许它们使用您选择的哈希函数进行哈希 - 只要结"
"构体的所有字段本身都是可哈希的。即使 `T`1 本身可哈希，您也无法在包含不可哈希值的结构体上派生 `Hash`trait，例如 `Array<T>` 或 `Felt252Dict<T>`。"

#: src/ch11-03-hash.md:23
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` that defines the basic methods to work with hashes. They allow you to initialize a hash state that will contain the temporary "
"values of the hash after each application of the hash function; update the hash state, and finalize it when the computation is completed. `HashStateTrait` is defined as follows:"
msgstr ""
"`Hash`trait伴随着 `HashStateTrait`，它定义了用于处理哈希的基本方法。它们允许您初始化一个哈希状态，其中将包含哈希函数每次应用后哈希的临时值；更新哈希状态，并在计算完成后将其最终确定。"
"`HashStateTrait`定义如下："

#: src/ch11-03-hash.md:25
msgid ""
"```rust\n"
"\n"
"/// A trait for hash state accumulators.\n"
"trait HashStateTrait<S> {\n"
"    fn update(self: S, value: felt252) -> S;\n"
"    fn finalize(self: S) -> felt252;\n"
"}\n"
"\n"
"/// A trait for values that can be hashed.\n"
"trait Hash<T, S, +HashStateTrait<S>> {\n"
"    /// Updates the hash state with the given value.\n"
"    fn update_state(state: S, value: T) -> S;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"\n"
"/// A trait for hash state accumulators.\n"
"trait HashStateTrait<S> {\n"
"    fn update(self: S, value: felt252) -> S;\n"
"    fn finalize(self: S) -> felt252;\n"
"}\n"
"\n"
"/// A trait for values that can be hashed.\n"
"trait Hash<T, S, +HashStateTrait<S>> {\n"
"    /// Updates the hash state with the given value.\n"
"    fn update_state(state: S, value: T) -> S;\n"
"}\n"
"```"

#: src/ch11-03-hash.md:40
msgid ""
"To use hashes in your code, you must first import the relevant traits and functions. In the following example, we will demonstrate how to hash a struct using both the Pedersen and "
"Poseidon hash functions."
msgstr "要在代码中使用哈希，您必须首先导入相关的trait和函数。在以下示例中，我们将演示如何使用 Pedersen 和 Poseidon 哈希函数对结构体进行哈希处理。"

#: src/ch11-03-hash.md:42
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() -> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending on which hash function we want "
"to work with. Then the hash state can be updated with the `update(self: HashState, value: felt252) -> HashState` or `update_with(self: S, value: T) -> S` functions as many times as "
"required. Then the function `finalize(self: HashState) -> felt252` is called on the hash state and it returns the value of the hash as a `felt252`."
msgstr ""
"首先，需要根据我们想要使用的哈希函数，使用 `PoseidonTrait::new() -> HashState` 或 `PedersenTrait::new(base: felt252) -> HashState` 初始化哈希状态。然后，可以使用 `update(self: "
"HashState, value: felt252) -> HashState` 或 `update_with(self: S, value: T) -> S` 函数多次更新哈希状态，具体更新次数取决于需要。最后，使用 `finalize(self: HashState) -> felt252` 函数"
"完成哈希计算并返回哈希值。"

#: src/ch11-03-hash.md:44
msgid ""
"```rust\n"
"use pedersen::PedersenTrait;\n"
"use poseidon::PoseidonTrait;\n"
"use hash::{HashStateTrait, HashStateExTrait};\n"
"```"
msgstr ""
"```rust\n"
"use pedersen::PedersenTrait;\n"
"use poseidon::PoseidonTrait;\n"
"use hash::{HashStateTrait, HashStateExTrait};\n"
"```"

#: src/ch11-03-hash.md:50
msgid ""
"```rust\n"
"#[derive(Drop, Hash)]\n"
"struct StructForHash {\n"
"    first: felt252,\n"
"    second: felt252,\n"
"    third: (u32, u32),\n"
"    last: bool,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop, Hash)]\n"
"struct StructForHash {\n"
"    first: felt252,\n"
"    second: felt252,\n"
"    third: (u32, u32),\n"
"    last: bool,\n"
"}\n"
"```"

#: src/ch11-03-hash.md:60
msgid "As our struct derives the trait HashTrait, we can call the function as follow for Poseidon hashing :"
msgstr "由于我们的结构体派生了 HashTrait 这个trait，我们可以使用以下方式调用 Poseidon 哈希函数："

#: src/ch11-03-hash.md:62
msgid ""
"```rust\n"
"# use pedersen::PedersenTrait;\n"
"# use poseidon::PoseidonTrait;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop, Hash)]\n"
"# struct StructForHash {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: (u32, u32),\n"
"#     last: bool,\n"
"# }\n"
"# \n"
"fn main() -> felt252 {\n"
"    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };\n"
"\n"
"    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();\n"
"    hash\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use pedersen::PedersenTrait;\n"
"# use poseidon::PoseidonTrait;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop, Hash)]\n"
"# struct StructForHash {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: (u32, u32),\n"
"#     last: bool,\n"
"# }\n"
"# \n"
"fn main() -> felt252 {\n"
"    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };\n"
"\n"
"    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();\n"
"    hash\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch11-03-hash.md:85
msgid "And as follow for Pedersen hashing :"
msgstr "同样地，我们也可以使用以下方式调用 Pedersen 哈希函数："

#: src/ch11-03-hash.md:87
msgid ""
"```rust\n"
"# use pedersen::PedersenTrait;\n"
"# use poseidon::PoseidonTrait;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop, Hash)]\n"
"# struct StructForHash {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: (u32, u32),\n"
"#     last: bool,\n"
"# }\n"
"# \n"
"fn main() -> felt252 {\n"
"    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };\n"
"\n"
"    let hash = PedersenTrait::new(0).update_with(struct_to_hash).finalize();\n"
"    hash\n"
"}\n"
"# \n"
"# \n"
"\n"
"```"
msgstr ""
"```rust\n"
"# use pedersen::PedersenTrait;\n"
"# use poseidon::PoseidonTrait;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop, Hash)]\n"
"# struct StructForHash {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: (u32, u32),\n"
"#     last: bool,\n"
"# }\n"
"# \n"
"fn main() -> felt252 {\n"
"    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };\n"
"\n"
"    let hash = PedersenTrait::new(0).update_with(struct_to_hash).finalize();\n"
"    hash\n"
"}\n"
"# \n"
"# \n"
"\n"
"```"

#: src/ch11-03-hash.md:111
msgid "### Advanced Hashing: Hashing arrays with Poseidon"
msgstr "### 高级哈希：使用 Poseidon 哈希数组"

#: src/ch11-03-hash.md:113
msgid ""
"Let us look at an example of hashing a function that contains an `Span<felt252>`.\n"
"To hash a `Span<felt252>` or a struct that contains a `Span<felt252>` you can use the build-in function in poseidon\n"
"` poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly you can hash `Array<felt252>` by calling `poseidon_hash_span` on its span."
msgstr ""
"让我们来看一个哈希包含 `Span<felt252>`.的函数的例子。\n"
"要哈希 `Span<felt252>` 或包含 `Span<felt252>` 的结构体，您可以使用 poseidon 中的内置函数 ` poseidon_hash_span(mut span: Span<felt252>) -> felt252`。同样，您可以通过对其 span 调用 "
"`poseidon_hash_span` 来哈希 `Array<felt252>`。"

#: src/ch11-03-hash.md:117
msgid "First let us import the following trait and function :"
msgstr "首先，让我们引入以下trait和函数："

#: src/ch11-03-hash.md:119
msgid ""
"```rust\n"
"use poseidon::PoseidonTrait;\n"
"use poseidon::poseidon_hash_span;\n"
"use hash::{HashStateTrait, HashStateExTrait};\n"
"```"
msgstr ""
"```rust\n"
"use poseidon::PoseidonTrait;\n"
"use poseidon::poseidon_hash_span;\n"
"use hash::{HashStateTrait, HashStateExTrait};\n"
"```"

#: src/ch11-03-hash.md:125
msgid ""
"Now we define the structure, as you might have notice we didn't derived the Hash trait. If you try to derive the\n"
"Hash trait on this structure it will rise an error because the structure contains a field not hashable."
msgstr "现在，我们来定义结构体。正如您可能注意到的，我们没有派生 Hash trait。如果您尝试在这个结构体上派生 Hash trait，它会引发错误，因为结构体包含一个不可哈希的字段。"

#: src/ch11-03-hash.md:128
msgid ""
"```rust, noplayground\n"
"#[derive(Drop)]\n"
"struct StructForHashArray {\n"
"    first: felt252,\n"
"    second: felt252,\n"
"    third: Array<felt252>,\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust, noplayground\n"
"#[derive(Drop)]\n"
"struct StructForHashArray {\n"
"    first: felt252,\n"
"    second: felt252,\n"
"    third: Array<felt252>,\n"
"}\n"
"\n"
"```"

#: src/ch11-03-hash.md:138
msgid ""
"In this example, we initialized a HashState (`hash`) and updated it and then called the function `finalize()` on the\n"
"HashState to get the computed hash `hash_felt252`. We used the `poseidon_hash_span` on the `Span` of the `Array<felt252>` to compute its hash."
msgstr ""
"在这个例子中，我们初始化了一个 HashState (`hash`) 并更新了它，然后在 HashState 上调用了函数 `finalize()` 以获得计算出的哈希 `hash_felt252`。我们使用 `poseidon_hash_span` 对 "
"`Array<felt252>` 的 `Span` 进行哈希计算，以计算其哈希值。"

#: src/ch11-03-hash.md:141
msgid ""
"```rust\n"
"# use poseidon::PoseidonTrait;\n"
"# use poseidon::poseidon_hash_span;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop)]\n"
"# struct StructForHashArray {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: Array<felt252>,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };\n"
"\n"
"    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);\n"
"    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();\n"
"}\n"
"# \n"
"# \n"
"\n"
"```"
msgstr ""
"```rust\n"
"# use poseidon::PoseidonTrait;\n"
"# use poseidon::poseidon_hash_span;\n"
"# use hash::{HashStateTrait, HashStateExTrait};\n"
"# \n"
"# #[derive(Drop)]\n"
"# struct StructForHashArray {\n"
"#     first: felt252,\n"
"#     second: felt252,\n"
"#     third: Array<felt252>,\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };\n"
"\n"
"    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);\n"
"    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();\n"
"}\n"
"# \n"
"# \n"
"\n"
"```"

#: src/ch11-03-hash.md:164
msgid "<footer id=\"last-change\">Last change: 2023-12-01</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-12-01</footer>"

#: src/ch99-00-starknet-smart-contracts.md:1
msgid "# Starknet Smart Contracts"
msgstr "# Starknet智能合约"

#: src/ch99-00-starknet-smart-contracts.md:3
msgid "All through the previous sections, you've mostly written programs with a `main` entrypoint. In the coming sections, you will learn to write and deploy Starknet contracts."
msgstr "在前面的章节中，你主要是用`main`入口来编写程序。在接下来的章节中，你将学习如何编写和部署Starknet合约。"

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts for the Starknet network. Starknet is a permissionless network that leverages zk-STARKs technology for "
"scalability. As a Layer-2 scalability solution for Ethereum, Starknet's goal is to offer fast, secure, and low-cost transactions. It functions as a Validity Rollup (commonly known as "
"a zero-knowledge Rollup) and is built on top of the Cairo language and the Starknet VM."
msgstr ""
"Cairo语言的一个应用是编写用于Starknet网络的智能合约。Starknet是一个无许可网络，利用zk-STARKs技术实现可扩展性。作为以太坊的二层可扩展性解决方案，Starknet的目标是提供快速、安全和低成本"
"的交易。它作为一个有效性Rollup（通常称为零知识Rollup）运行，并构建在Cairo语言和Starknet虚拟机之上。"

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the Starknet VM. Since they run on the VM, they have access to Starknet’s persistent state, can alter or modify "
"variables in Starknet’s states, communicate with other contracts, and interact seamlessly with the underlying L1."
msgstr ""
"简单来说，Starknet合约就是可以在Starknet虚拟机上运行的程序。由于它们在虚拟机上运行，它们可以访问Starknet的持久性状态，可以改变或修改Starknet状态中的变量，与其他合约沟通，并与底层的L1"
"无缝交互。"

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive deeper into this in the next sections.\n"
"If you want to learn more about the Starknet network itself, its architecture and the tooling available, you should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""
"Starknet合约由`#[contract]`属性标记。我们将在接下来的部分对此进行深入探讨。如果你想了解更多关于Starknet网络本身，其架构以及可用的工具，你应该阅读[Starknet Book](https://book.starknet."
"io/)。本节将只专注于如何使用Cairo编写智能合约。"

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "#### Scarb"
msgstr "#### Scarb"

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this functionality, you'll need to make some configurations in your `Scarb.toml` file (see [Installation](./ch01-01-"
"installation.md) for how to install Scarb).\n"
"You have to add the `starknet` dependency and add a `[[target.starknet-contract]]` section to enable contract compilation."
msgstr ""
"Scarb支持Starknet的智能合约开发。要启用此功能，您需要在 `Scarb.toml` 文件中进行一些配置（有关如何安装Scarb，请参阅[安装](./ch01-01-installation.md)）。\n"
"你需要添加 `starknet` 依赖项，并添加一个 `[[target.starknet-contract]]` 部分以启用合约编译。"

#: src/ch99-00-starknet-smart-contracts.md:17
msgid "Below is the minimal Scarb.toml file required to compile a crate containing Starknet contracts:"
msgstr "下面是编译包含Starknet合约的crate所需的最小Scarb.toml文件示例："

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please refer to the [Scarb documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#compiling-external-contracts)."
msgstr "有关外部合约依赖等更多配置相关的内容，请参阅 [Scarb 文档](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)。"

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr "本章中的每个示例都可以与 Scarb 一起使用。"

#: src/ch99-00-starknet-smart-contracts.md:34 src/ch99-01-05-01-components-under-the-hood.md:192 src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:270
msgid "<footer id=\"last-change\">Last change: 2023-11-04</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-04</footer>"

#: src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "# Introduction to smart-contracts"
msgstr "# 智能合约简介"

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts are, what are they used for and why would blockchain developers use Cairo and Starknet.\n"
"If you are already familiar with blockchain programming, feel free to skip this chapter. The last part might still be interesting though."
msgstr ""
"本章是一个关于什么是智能合约，它们有什么用途，以及为什么区块链开发者会使用Cairo和Starknet的高度简介。\n"
"如果你已经熟悉了区块链编程，可以跳过这一章。不过最后一部分应该还是有点意思的。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "## Smart-contracts"
msgstr "## 智能合约"

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth of Ethereum. Smart contracts are essentially programs deployed on a blockchain. The term \"smart "
"contract\" is somewhat misleading, as they are neither \"smart\" nor \"contracts\" but rather code and instructions that are executed based on specific inputs. They primarily consist "
"of two components: storage and functions. Once deployed, users can interact with smart contracts by initiating blockchain transactions containing execution data (which function to "
"call and with what input). Smart contracts can modify and read the storage of the underlying blockchain. A smart contract has its own address and is considered a blockchain account, "
"meaning it can hold tokens."
msgstr ""
"随着以太坊的诞生，智能合约得到了普及并变得更加广泛。智能合约本质上是部署在区块链上的程序。术语 \"智能合约 \"有些误导，因为它们既不 \"智能 \"也不是 \"合约\"，而只是根据特定输入执行的代"
"码和指令。它们主要由两部分组成：存储和函数。部署后，用户可以通过启动包含执行数据的区块链交易（调用哪个函数，输入什么参数）与智能合约互动。智能合约可以修改和读取底层区块链的存储。智能"
"合约有自己的地址，因此它是一个区块链账户，意味着它可以持有代币。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem](https://ethereum.org/en/"
"developers/docs/evm/), the most commonly used language is Solidity, while on Starknet, it is Cairo. The way the code is compiled also differs based on the blockchain. On Ethereum, "
"Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then into Cairo Assembly (casm)."
msgstr ""
"用于编写智能合约的编程语言因区块链的不同而不同。例如，在以太坊和[EVM兼容的生态系统](https://ethereum.org/en/developers/docs/evm/)生态系统上，最常用的语言是Solidity，而在Starknet上，是"
"Cairo。代码的编译方式也根据区块链的不同而不同。在Ethereum上，Solidity被编译成字节码。在Starknet上，Cairo被编译成Sierra，然后再编译成Cairo Assembly（casm）。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are **permissionless**, meaning anyone can deploy a smart contract on the network (within the context of a decentralized "
"blockchain, of course). Smart contracts are also **transparent**; the data stored by the smart contract is accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write smart contracts that use other smart contracts. Smart contracts can only access and interact with data from "
"the blockchain they are deployed on. They require third-party software (called `oracles`) to access external data (the price of a token for instance)."
msgstr ""
"智能合约具有几个独特特征。它们是 **无需许可** 的，意味着任何人都可以在网络上部署智能合约（当然是在去中心化的区块链上）。智能合约也是 **透明** 的；由智能合约存储的数据对任何人都是可访"
"问的。构成合约的代码也可以是透明的，从而实现 **可组合性**。这使得开发人员可以编写使用其他智能合约的智能合约。智能合约只能访问和与其部署所在的区块链上的数据进行交互。它们需要第三方软件"
"（被称为 `oracle`）来访问外部数据（例如代币的价格）。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, it is required to know what the other contracts look like. Hence, Ethereum developers started to build "
"standards for smart contract development, the `ERCxx`. The two most used and famous standards are the `ERC20`, used to build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, "
"for NFTs (Non-fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"对于开发者来说，要想建立能够相互互动的智能合约，就必须知道其他合约的是什么样。因此，以太坊开发者建立了一些智能合约开发的标准，即 `ERCxx`。两个最常用和最著名的标准是 `ERC20`，用于建立 "
"`USDC`、`DAI`或 `STARK`等代币，以及 `ERC721`，用于 `CryptoPunks`或 `Everai`等NFT（Non-fungible token）。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "## Use cases"
msgstr "## 使用案例"

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid "There are many possible use cases for smart-contracts. The only limits are the technical constraints of the blockchain and the creativity of developers."
msgstr "智能合约有许多可能的用例。唯一的限制是区块链的技术限制和开发者的创造力。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "#### DeFi"
msgstr "#### DeFi"

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of Ethereum or Bitcoin, which is essentially handling money. In the context of the alternative payment system "
"promised by Bitcoin, smart contracts on Ethereum enable the creation of decentralized financial applications that no longer rely on traditional financial intermediaries. This is what "
"we call DeFi (decentralized finance). DeFi consists of various projects such as lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, stablecoins, "
"decentralized hedge funds, insurance, and many more."
msgstr ""
"眼下，智能合约的主要用例与以太坊或比特币的用例类似，基本上是处理金钱。在比特币承诺的替代支付系统的背景下，我们在以太坊上可以使用智能合约创建去中心化的金融应用，不需要再依赖传统的金融"
"中介机构。这就是我们所说的DeFi（去中心化金融）。DeFi由各种项目组成，如借贷应用、去中心化交易所（DEX）、链上衍生品、稳定币、去中心化对冲基金、保险等等。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "#### Tokenization"
msgstr "#### 代币化"

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such as real estate, art, or precious metals. Tokenization divides an asset into digital tokens, which can be "
"easily traded and managed on blockchain platforms. This can increase liquidity, enable fractional ownership, and simplify the buying and selling process."
msgstr ""
"智能合约可以促进现实世界资产的代币化，如房地产、艺术品或贵金属。代币化将资产划分为数字代币，可以在区块链平台上轻松交易和管理。这可以增加流动性，实现部分所有权，并简化购买和销售过程。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "#### Voting"
msgstr "#### 投票"

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. Votes can be recorded on the blockchain, ensuring immutability and transparency. The smart contract can "
"then automatically tally the votes and declare the results, minimizing the potential for fraud or manipulation."
msgstr "智能合约可用于创建安全和透明的投票系统。投票可以记录在区块链上，确保不可更改性和透明度。然后，智能合约可以自动统计票数并宣布结果，将欺诈或操纵的可能性降到最低。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "#### Royalties"
msgstr "#### 特许权使用费（版税）"

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and other content creators. When a piece of content is consumed or sold, the smart contract can automatically "
"calculate and distribute the royalties to the rightful owners, ensuring fair compensation and reducing the need for intermediaries."
msgstr "智能合约可以为艺术家、音乐家和其他内容创作者自动支付版税。当一段内容被消费或出售时，智能合约可以自动计算并将版税分配给合法的所有者，确保公平的补偿并减少对中间人的需求。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "#### Decentralized identities DIDs"
msgstr "#### 去中心化身份 DIDs"

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, allowing individuals to control their personal information and share it with third parties securely. The smart "
"contract could verify the authenticity of a user's identity and automatically grant or revoke access to specific services based on the user's credentials."
msgstr "智能合约可用于创建和管理数字身份，允许个人控制其个人信息，并与第三方安全地分享。智能合约可以验证用户身份的真实性，并根据用户的凭证自动授予或撤销对特定服务的访问。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:40
msgid ""
"<br/>\n"
"<br/>\n"
"As Ethereum continues to mature, we can expect the use cases and applications of smart contracts to expand further, bringing about exciting new opportunities and reshaping "
"traditional systems for the better."
msgstr ""
"<br/>\n"
"<br/>\n"
"随着以太坊的不断成熟，我们可以预期智能合约的用例和应用将进一步扩大，带来令人兴奋的新机会，并会更好地重塑传统系统。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "## The rise of Starknet and Cairo"
msgstr "##  Starknet和Cairo语言的崛起"

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, became a victim of its own success. With the rapid adoption of some previously mentioned use cases, mainly "
"DeFi, the cost of performing transactions became extremely high, rendering the network almost unusable. Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""
"以太坊作为应用最广泛、弹性最大的智能合约平台，成为了自身成功的牺牲品。随着前面提到的一些用例（主要是DeFi）的快速采用，执行交易的成本变得非常高，使得网络几乎无法使用。生态系统中的工程"
"师和研究人员开始研究解决这一可扩展性问题的方案。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-trilemma)) in the blockchain space states that it is impossible to "
"achieve a high level of scalability, decentralization, and security simultaneously; trade-offs must be made. Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a secure settlement layer, while complex computations would be offloaded to other networks built on top of "
"Ethereum. These are called Layer 2s (L2s)."
msgstr ""
"区块链领域有一个著名的不可能三角（[The Blockchain Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-trilemma)），即不可能同时实现高水平的可扩展性、去中心化"
"和安全性；我们必须做出权衡。以太坊处于去中心化和安全性的交叉点。最终，人们决定以太坊的目的是作为一个安全的结算层，而复杂的计算将被卸载到建立在以太坊之上的其他网络。这些网络被称为二层"
"网络（L2）。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. Both approaches involve compressing and batching numerous transactions together, computing the new state, "
"and settling the result on Ethereum (L1). The difference lies in the way the result is settled on L1. For optimistic rollups, the new state is considered valid by default, but there "
"is a 7-day window for nodes to identify malicious transactions."
msgstr ""
"L2的两种主要类型是乐观rollup和有效性rollup。这两种方法都涉及压缩和批量处理大量交易，计算新状态，并将结果结算在以太坊（L1）上。区别在于在L1上结算结果的方式。对于乐观rollup，默认情况下"
"新状态被认为是有效的，但节点有7天的窗口期来识别恶意交易。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove that the new state has been correctly computed. This is the purpose of STARKs, this cryptographic "
"technology could permit validity rollups to scale significantly more than optimistic rollups. You can learn more about STARKs from Starkware's Medium [article](https://medium.com/"
"starkware/starks-starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"与此相反，有效性rollup（如Starknet）使用加密技术来证明新状态的计算是正确的。这就是STARKs的目的，这种加密技术可以使有效性rollup的扩展能力大大超过乐观rollup。你可以从Starkware的"
"Medium[文章](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a)中了解更多关于STARKs的信息，它是一个很好的入门读物。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"> Starknet's architecture is thoroughly described in the [Starknet Book](https://book.starknet.io/chapter_4/index.html), which is a great resource to learn more about the Starknet "
"network."
msgstr "> Starknet的架构在[Starknet Book](https://book.starknet.io/chapter_4/index.html)中有详细描述，是了解Starknet的重要资源。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work with STARKs and make them general-purpose. With Cairo, we can write **provable code**. In the context of "
"Starknet, this allows proving the correctness of computations from one state to another."
msgstr ""
"还记得Cairo吗？事实上，它是一种专门为STARKs开发的语言，并使其具有通用性。使用Cairo，我们可以编写**可证明的代码**。在 Starknet 中，这可以证明从一个状态到另一个状态的计算的正确性。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM (either as-is or adapted) as a base layer, Starknet employs its own VM. This frees developers from the "
"constraints of the EVM, opening up a broader range of possibilities. Coupled with decreased transaction costs, the combination of Starknet and Cairo creates an exciting playground "
"for developers. Native account abstraction enables more complex logic for accounts, that we call \"Smart Accounts\", and transaction flows. Emerging use cases include **transparent "
"AI** and machine learning applications. Finally, **blockchain games** can be developed entirely **on-chain**. Starknet has been specifically designed to maximize the capabilities of "
"STARK proofs for optimal scalability."
msgstr ""
"大多数（也许不是全部）Starknet的竞争对手都选择使用 EVM（原版或改版）作为基础层，而Starknet则不同，它采用了自己的虚拟机。这使开发人员摆脱了 EVM 的束缚，开辟了更广阔的可能性。加上交易成"
"本的降低，Starknet 与 Cairo 的结合为开发人员创造了一个令人兴奋的乐园。原生账户抽象使我们称之为 \"智能账户\" 的账户和交易流的逻辑更加复杂。新兴用例包括 **透明人工智能** 和机器学习应"
"用。最后，**区块链游戏** 可以完全在 **链上** 开发。Starknet 经过专门设计，可最大限度地发挥 STARK 证明的能力，实现最佳可扩展性。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid "> Learn more about Account Abstraction in the [Starknet Book](https://book.starknet.io/chapter_5/index.html)."
msgstr "> 在[Starknet Book](https://book.starknet.io/chapter_5/index.html)中了解更多关于账户抽象的信息。"

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "## Cairo programs and Starknet contracts: what is the difference?"
msgstr "## Cairo程序和Starknet合约：有何区别？"

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts previously learned in this book are still applicable to write Starknet contracts.\n"
"As you may have already noticed, a Cairo program must always have a function `main` that serves as the entry point for this program:"
msgstr ""
"Starknet合约是Cairo程序的一个特殊子集，所以之前在本书中学到的概念仍然适用于编写Starknet合约。\n"
"你可能已经注意到，一个Cairo程序必须始终有一个函数`main`，作为这个程序的入口："

#: src/ch99-01-01-introduction-to-smart-contracts.md:67
msgid ""
"```rust\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {}\n"
"```"

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, and as such, have access to Starknet's state. For a module to be handled as a contract by the compiler, "
"it must be annotated with the `#[starknet::contract]` attribute."
msgstr "Starknet合约本质上是可以在Starknet操作系统上运行的程序，因此可以访问Starknet的状态。要让编译器把一个模块当作合约来处理，就必须用 `#[starknet::contract]`属性来标注它。"

#: src/ch99-01-02-a-simple-contract.md:1
msgid "# A simple contract"
msgstr "# 一个简单的合约"

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an example of a basic contract. You will learn how to write a simple contract that stores a single number on "
"the blockchain."
msgstr "本章将通过一个基本合约的例子向您介绍Starknet合约的基础知识。您将学习如何编写一个在区块链上存储单个数字的简单合约。"

#: src/ch99-01-02-a-simple-contract.md:5
msgid "## Anatomy of a simple Starknet Contract"
msgstr "## 一个简单Starknet合约剖析"

#: src/ch99-01-02-a-simple-contract.md:7
msgid "Let's consider the following contract to present the basics of a Starknet contract. It might not be easy to understand it all at once, but we will go through it step by step:"
msgstr "让我们通过下面的合约来了解Starknet合约的基本内容。可能一下子很难理解，但是我们将一步一步地进行讲解："

#: src/ch99-01-02-a-simple-contract.md:9
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISimpleStorage<TContractState> {\n"
"    fn set(ref self: TContractState, x: u128);\n"
"    fn get(self: @TContractState) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleStorage {\n"
"    use starknet::get_caller_address;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        stored_data: u128\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISimpleStorage<TContractState> {\n"
"    fn set(ref self: TContractState, x: u128);\n"
"    fn get(self: @TContractState) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleStorage {\n"
"    use starknet::get_caller_address;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        stored_data: u128\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch99-01-02-a-simple-contract.md:38
msgid "<span class=\"caption\">Listing 99-1: A simple storage contract</span>"
msgstr "<span class=\"caption\">示例99-1：一个简单的存储合约</span>"

#: src/ch99-01-02-a-simple-contract.md:40
msgid "> Note: Starknet contracts are defined within [modules](./ch07-02-defining-modules-to-control-scope.md)."
msgstr "> 注意：Starknet合约是在模块（[modules](./ch07-02-defining-modules-to-control-scope.md)）中被定义的。"

#: src/ch99-01-02-a-simple-contract.md:42
msgid "### What is this contract?"
msgstr "## 这是什么合约？"

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called `stored_data` of type `u128` (unsigned integer of 128 bits).\n"
"You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database.\n"
"The contract defines and exposes publicly the functions `set` and `get` that can be used to modify or retrieve the value of that variable."
msgstr ""
"在这个例子中，`Storage` 结构声明了一个名为 `stored_data` 的存储变量，类型为`u128`（128位无符号整数）。\n"
"你可以将它想象成数据库中的一个单独槽位，通过调用管理数据库的代码的函数来查询和修改它。\n"
"该合约定义并公开了 `set` 和 `get` 函数，用于修改或检索该变量的值。"

#: src/ch99-01-02-a-simple-contract.md:48
msgid "### The Interface: the contract's blueprint"
msgstr "### 接口：合约的蓝图"

#: src/ch99-01-02-a-simple-contract.md:50
msgid ""
"```rust,noplayground\n"
"#[starknet::interface]\n"
"trait ISimpleStorage<TContractState> {\n"
"    fn set(ref self: TContractState, x: u128);\n"
"    fn get(self: @TContractState) -> u128;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[starknet::interface]\n"
"trait ISimpleStorage<TContractState> {\n"
"    fn set(ref self: TContractState, x: u128);\n"
"    fn get(self: @TContractState) -> u128;\n"
"}\n"
"```"

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes to the outside world. Here, the interface exposes two functions: `set` and `get`. By leveraging the [traits "
"& impls](./ch08-02-traits-in-cairo.md) mechanism from Cairo, we can make sure that the actual implementation of the contract matches its interface. In fact, you will get a "
"compilation error if your contract doesn’t conform with the declared interface."
msgstr ""
"合约的接口代表了该合约向外界公开的函数。在这里，接口公开了两个函数：`set` 和 `get` 。通过利用Cairo的[traits & impls](./ch08-02-traits-in-cairo.md) 机制，我们可以确保合约的实际实现与其"
"接口匹配。事实上，如果你的合约与声明的接口不符合，将会得到编译错误。"

#: src/ch99-01-02-a-simple-contract.md:60
msgid ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState) {}\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState) {}\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"```"

#: src/ch99-01-02-a-simple-contract.md:70
msgid "<span class=\"caption\">Listing 99-1-bis: A wrong implementation of the interface of the contract. This does not compile.</span>"
msgstr "<span class=\"caption\">示例 99-1-bis: 合约接口的错误实现。无法编译。</span>"

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` argument which is passed by reference to the `set` function. The `self` parameter represents the contract "
"state. Seeing the `self` argument passed to `set` tells us that this function might access the state of the contract, as it is what gives us access to the contract’s storage. The "
"`ref` modifier implies that `self` may be modified, meaning that the storage variables of the contract may be modified inside the `set` function."
msgstr ""
"在接口中，请注意`self`参数的通用类型`TContractState`，它通过引用传递给`set`函数。参数 `self` 代表合约状态。看到 `self` 参数传递给 `set` 告诉我们这个函数可能会访问合约的状态，因为它使"
"我们能够访问合约的存储空间。`ref` 修饰符意味着 `self` 可以被修改，这意味着合约的存储变量可以在 `set` 函数中被修改。"

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which immediately tells us that it does not modify the state (and indeed, the compiler will complain if we try to "
"modify storage inside the `get` function)."
msgstr "另一方面，`get`获取`TContractState`的_snapshot_，这立即告诉我们它不会修改状态（事实上，如果我们试图在`get`函数中修改存储变量，编译器会报错）。"

#: src/ch99-01-02-a-simple-contract.md:76
msgid "### Public functions are defined in an implementation block"
msgstr "#### 在实现里定义public函数"

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr "在我们进一步探讨之前，让我们先定义一些术语。"

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"- In the context of Starknet, a _public function_ is a function that is exposed to the outside world. In the example above, `set` and `get` are public functions. A public function "
"can be called by anyone, and can be called from outside the contract, or from within the contract. In the example above, `set` and `get` are public functions.\n"
"\n"
"- What we call an _external_ function is a public function that is invoked through a transaction and that can mutate the state of the contract. `set` is an external function.\n"
"\n"
"- A _view_ function is a public function that can be called from outside the contract, but that cannot mutate the state of the contract. `get` is a view function."
msgstr ""
"- 在Starknet中，_public function_ （公共函数）是一个对外公开的函数。在上面的例子中，`set`和`get`是公共函数。公有函数可以被任何人调用，可以从合约外部调用，也可以从合约内部调用。在上面"
"的示例中，`set`和`get`是公共函数。\n"
"\n"
"- 我们所说的 _external_ 函数是通过交易唤起的公共函数，它可以改变合约的状态。`set`就是一个外部函数。\n"
"\n"
"- 一个 _view_ 函数是一个公共函数，它可以从合约外部调用，但不能改变合约的状态。`get`是一个视图函数。"

#: src/ch99-01-02-a-simple-contract.md:86
msgid ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl SimpleStorage of super::ISimpleStorage<ContractState> {\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"        fn get(self: @ContractState) -> u128 {\n"
"            self.stored_data.read()\n"
"        }\n"
"    }\n"
"```"

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in order to match the interface, the external functions of the contract\n"
"must be defined in an implementation of this trait — which allows us to make sure that the implementation of the contract matches its interface."
msgstr "由于合约接口被定义为`ISimpleStorage`trait，为了匹配接口，合约的外部函数必须在这个trait的实现中定义--这使我们能够确保合约的实现与其接口相匹配。"

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. The implementation block must be annotated with the `#[external(v0)]` attribute. This attribute exposes "
"the functions defined in this implementation to the outside world — forget to add it and your functions will not be callable from the outside. All functions defined in a block marked "
"as `#[external(v0)]` are consequently _public functions_."
msgstr ""
"然而，仅仅在实现中定义函数是不够的。实现块必须标注上`#[external(v0)]`属性。如果忘记添加该属性，您的函数将无法从外部调用。所有在标记为 `#[external(v0)]`的代码块中定义的函数都是 "
"_public functions_ 。"

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter corresponding to the `self` argument in the trait must be `ContractState`. The `ContractState` type is "
"generated by the compiler, and gives access to the storage variables defined in the `Storage` struct.\n"
"Additionally, `ContractState` gives us the ability to emit events. The name `ContractState` is not surprising, as it’s a representation of the contract’s state, which is what we "
"think of `self` in the contract interface trait."
msgstr ""
"当编写接口的实现时，在trait中对应于`self`参数的泛型参数必须是`ContractState`。`ContractState`类型由编译器生成，它提供了对定义在 \"`Storage`结构中的存储变量的访问。\n"
"此外，`ContractState`还提供了emit事件的能力。不要对`ContractState` 这个名字感到奇怪，因为它是合约状态的表示，也就是我们在合约接口trait中认为的 `self`。"

#: src/ch99-01-02-a-simple-contract.md:106
msgid "### Modifying the contract's state"
msgstr "### 修改合约状态"

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the contract are defined under the implementation of a trait that has a `TContractState` generic parameter, and take "
"a `self: ContractState` parameter.\n"
"This allows us to explicitly pass the `self: ContractState` parameter to the function, allowing access the storage variables of the contract.\n"
"To access a storage variable of the current contract, you add the `self` prefix to the storage variable name, which allows you to use the `read` and `write` methods to either read or "
"write the value of the storage variable."
msgstr ""
"正如你所注意到的，所有需要访问合约状态的函数都被定义在一个有`TContractState`泛型参数的trait的实现下，并接受一个`self：ContractState`参数。\n"
"这允许我们显式地将 `self：ContractState`参数给函数，允许访问合约的存储变量。\n"
"要访问当前合约的存储变量，可以在存储变量名后添加 `self` 前缀，这样就可以使用 `read` 和 `write` 方法读取或写入存储变量的值。"

#: src/ch99-01-02-a-simple-contract.md:112
msgid ""
"```rust,noplayground\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"        fn set(ref self: ContractState, x: u128) {\n"
"            self.stored_data.write(x);\n"
"        }\n"
"```"

#: src/ch99-01-02-a-simple-contract.md:118
msgid "<span class=\"caption\">Using `self` and the `write` method to modify the value of a storage variable</span>"
msgstr "<span class=\"caption\">使用 `self` 和 `write` 方法修改存储变量的值</span>"

#: src/ch99-01-02-a-simple-contract.md:120
msgid "> Note: if the contract state is passed as a snapshot instead of `ref`, attempting to modify will result in a compilation error."
msgstr "> 注意：如果合约状态是作为snapshot而不是`ref`传递的，尝试修改它将导致编译错误。"

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a single number that is accessible by anyone in the world. Anyone could call `set` again with a different value "
"and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the "
"number."
msgstr ""
"除了允许任何人存储世界上任何人都可以访问的单个号码外，该合约没做其他事。任何人都可以用不同的值再次调用`set`覆盖您的号码，但号码仍然存储在区块链的历史中。稍后，您将看到如何施加访问限"
"制，以便只有您可以更改号码。"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "# A deeper dive into contracts"
msgstr "# 深入了解合约"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract written in Cairo. In this section, we'll be taking a deeper look at all the components of a smart "
"contract, step by step."
msgstr "在上一节中，我们给出了一个用Cairo语言编写的智能合约的介绍性示例。在本节中，我们将逐步深入了解智能合约的所有组成部分。"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we specified the difference between _public functions, external functions and view functions_, and we mentioned "
"how to interact with _storage_."
msgstr "在讨论[_interfaces_](./ch99-01-02-a-simple-contract.md)时，我们明确了_public函数、external函数和view函数_ 之间的区别，并提到了如何与 _storage_ 交互。"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr "此时，您应该会想到很多问题："

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid ""
"- How do I define internal/private functions?\n"
"- How can I emit events? How can I index them?\n"
"- Where should I define functions that do not need to access the contract's state?\n"
"- Is there a way to reduce the boilerplate?\n"
"- How can I store more complex data types?"
msgstr ""
"- 如何定义内部/私有函数？\n"
"- 如何发出事件？如何索引事件？\n"
"- 我应该在哪里定义不需要访问合约状态的函数？\n"
"- 有办法减少冗余的模式代码吗？\n"
"- 如何存储更复杂的数据类型？"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid "Luckily, we'll be answering all these questions in this chapter. Let's consider the following example contract that we'll be using throughout this chapter:"
msgstr "幸运的是，我们将在本章中回答所有这些问题。下面是我们在本章中将使用的合约示例："

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:17
msgid ""
"```rust,noplayground\n"
"\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait INameRegistry<TContractState> {\n"
"    fn store_name(\n"
"        ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"    );\n"
"    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"    fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"}\n"
"\n"
"\n"
"#[starknet::contract]\n"
"mod NameRegistry {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"        registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"        total_names: u128,\n"
"        owner: Person\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        StoredName: StoredName,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct StoredName {\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        name: felt252\n"
"    }\n"
"\n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Person {\n"
"        name: felt252,\n"
"        address: ContractAddress\n"
"    }\n"
"\n"
"    #[derive(Drop, Serde, starknet::Store)]\n"
"    enum RegistrationType {\n"
"        finite: u64,\n"
"        infinite\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, owner: Person) {\n"
"        self.names.write(owner.address, owner.name);\n"
"        self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl NameRegistry of super::INameRegistry<ContractState> {\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"        fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"            owner\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn _store_name(\n"
"            ref self: ContractState,\n"
"            user: ContractAddress,\n"
"            name: felt252,\n"
"            registration_type: RegistrationType\n"
"        ) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.registration_type.write(user, registration_type);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(StoredName { user: user, name: name });\n"
"\n"
"        }\n"
"    }\n"
"\n"
"    fn get_contract_name() -> felt252 {\n"
"        'Name Registry'\n"
"    }\n"
"\n"
"    fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait INameRegistry<TContractState> {\n"
"    fn store_name(\n"
"        ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"    );\n"
"    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"    fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"}\n"
"\n"
"\n"
"#[starknet::contract]\n"
"mod NameRegistry {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"        registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"        total_names: u128,\n"
"        owner: Person\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        StoredName: StoredName,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct StoredName {\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        name: felt252\n"
"    }\n"
"\n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Person {\n"
"        name: felt252,\n"
"        address: ContractAddress\n"
"    }\n"
"\n"
"    #[derive(Drop, Serde, starknet::Store)]\n"
"    enum RegistrationType {\n"
"        finite: u64,\n"
"        infinite\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, owner: Person) {\n"
"        self.names.write(owner.address, owner.name);\n"
"        self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl NameRegistry of super::INameRegistry<ContractState> {\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"        fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"            owner\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn _store_name(\n"
"            ref self: ContractState,\n"
"            user: ContractAddress,\n"
"            name: felt252,\n"
"            registration_type: RegistrationType\n"
"        ) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.registration_type.write(user, registration_type);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(StoredName { user: user, name: name });\n"
"\n"
"        }\n"
"    }\n"
"\n"
"    fn get_contract_name() -> felt252 {\n"
"        'Name Registry'\n"
"    }\n"
"\n"
"    fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"    }\n"
"}\n"
"```"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:119
msgid "<span class=\"caption\">Listing 99-1bis: Our reference contract for this chapter</span>"
msgstr "<span class=\"caption\">示例  99-1bis：本章的参考合约</span>"

#: src/ch99-01-03-01-contract-storage.md:1
msgid "# Contract Storage"
msgstr "# 合约存储"

#: src/ch99-01-03-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through storage variables. As stated previously, storage variables allow you to store data that will be stored in the "
"contract's storage that is itself stored on the blockchain. These data are persistent and can be accessed and modified anytime once the contract is deployed."
msgstr ""
"与合约存储进行交互的最常见方式是通过存储变量。正如前面所述，存储变量允许您存储将存储在合约的存储中的数据，而该存储本身存储在区块链上。这些数据是持久的，一旦合约部署后，可以随时访问和"
"修改。"

#: src/ch99-01-03-01-contract-storage.md:5
msgid "Storage variables in Starknet contracts are stored in a special struct called `Storage`:"
msgstr "Starknet合约中的存储变量被存储在一个特殊的结构中，称为`Storage`："

#: src/ch99-01-03-01-contract-storage.md:7
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"        registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"        total_names: u128,\n"
"        owner: Person\n"
"    }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"        registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"        total_names: u128,\n"
"        owner: Person\n"
"    }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:111
msgid "<span class=\"caption\">A Storage Struct</span>"
msgstr "<span class=\"caption\">存储用结构体</span>"

#: src/ch99-01-03-01-contract-storage.md:113
msgid ""
"The storage struct is a [struct](./ch05-00-using-structs-to-structure-related-data.md) like any other,\n"
"except that it **must** be annotated with `#[storage]`. This annotation tells the compiler to generate the required code to interact with the blockchain state, and allows you to read "
"and write data from and to storage. Moreover, this allows you to define storage mappings using the `LegacyMap` type."
msgstr ""
"Storage[结构体](./ch05-00-using-structs-to-structure-related-data.md) 与其他结构体一样，\n"
"只是它 **必须** 带有 `#[storage]` 注解。这个注解告诉编译器生成与区块链状态交互所需的代码，并允许您从存储中读取和写入数据。此外，这还允许您使用 `LegacyMap` 类型定义存储映射。"

#: src/ch99-01-03-01-contract-storage.md:116
msgid ""
"Each variable stored in the storage struct is stored in a different location in the contract's storage. The storage address of a variable is determined by the variable's name, and "
"the eventual keys of the variable if it is a [mapping](#storing-mappings)."
msgstr "存储结构中存储的每个变量都存储在合约存储的不同位置。变量的存储地址由变量名决定，如果是映射，则还由变量的最终键决定。"

#: src/ch99-01-03-01-contract-storage.md:118
msgid "## Storage Addresses"
msgstr "## 存储地址"

#: src/ch99-01-03-01-contract-storage.md:120
msgid "The address of a storage variable is computed as follows:"
msgstr "存储变量的地址计算方式如下："

#: src/ch99-01-03-01-contract-storage.md:122
msgid ""
"- If the variable is a single value (not a mapping), the address is the `sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` is Starknet's version of the "
"Keccak256 hash function, whose output is truncated to 250 bits.\n"
"- If the variable is a [mapping](#storing-mappings), the address of the value at key `k_1,...,k_n` is `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ is the Pedersen "
"hash and the final value is taken `mod (2^251) − 256`.\n"
"- If it is a mapping to complex values (e.g., tuples or structs), then this complex value lies in a continuous segment starting from the address calculated in the previous point. "
"Note that 256 field elements is the current limitation on the maximal size of a complex storage value."
msgstr ""
"- 如果变量是单个值（不是映射），则地址是变量名 ASCII 编码的 `sn_keccak`  哈希值。`sn_keccak`_是 Starknet 的 Keccak256 哈希函数版本，其输出被截断为 250 位。\n"
"- 如果变量是[映射](#storing-mappings),，则键为 `k_1,...,k_n`  的值的地址是 `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`，其中 ℎ 是 Pedersen 哈希，最终值取 `mod (2^251) − "
"256`。\n"
"- 如果它是映射到复杂值（例如，元组或结构），则此复杂值位于从上一点计算的地址开始的连续段中。请注意，256 个域元素是当前复杂存储值最大大小的限制。"

#: src/ch99-01-03-01-contract-storage.md:126
msgid "You can access the address of a storage variable by calling the `address` function on the variable, which returns a `StorageBaseAddress` value."
msgstr "通过在变量上调用 `address` 函数，你可以访问存储变量的地址，该函数返回一个 `StorageBaseAddress` 值。"

#: src/ch99-01-03-01-contract-storage.md:128
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:232
msgid "## Interacting with Storage Variables"
msgstr "## 与存储变量交互"

#: src/ch99-01-03-01-contract-storage.md:234
msgid ""
"Variables stored in the storage struct can be accessed and modified using the `read` and `write` functions, and you can get their address in storage using the `addr` function. These "
"functions are automatically generated by the compiler for each storage variable."
msgstr "存储在存储结构中的变量可以使用 `read` 和 `write` 函数进行访问和修改，还可以使用 `addr` 函数获取它们在存储中的地址。这些函数由编译器为每个存储变量自动生成。"

#: src/ch99-01-03-01-contract-storage.md:236
msgid "To read the value of the `owner` storage variable, which is a single value, we call the `read` function on the `owner` variable, passing in no parameters."
msgstr "要读取 `owner` 存储变量的值，该变量是一个单一值，我们调用 `owner` 变量上的 `read` 函数，不传入任何参数。"

#: src/ch99-01-03-01-contract-storage.md:238
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:342
msgid "<span class=\"caption\">Calling the `read` function on the `owner` variable</span>"
msgstr "<span class=\"caption\">调用 `owner` 变量上的 `read` 函数</span>"

#: src/ch99-01-03-01-contract-storage.md:344
msgid ""
"To read the value of the storage variable `names`, which is a mapping from `ContractAddress` to `felt252`, we call the `read` function on the `names` variable, passing in the key "
"`address` as a parameter. If the mapping had more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"要读取存储变量 `names` 的值，这个变量是从 `ContractAddress` 映射到 `felt252` 的，我们在 `names` 变量上调用 `read` 函数，将键 `address` 作为参数传入。如果这个映射有多个键，我们也会将其"
"他键作为参数传入。"

#: src/ch99-01-03-01-contract-storage.md:346
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:450
msgid "<span class=\"caption\">Calling the `read` function on the `names` variable</span>"
msgstr "<span class=“caption”>调用`names` 变量上的`read` 函数</span>"

#: src/ch99-01-03-01-contract-storage.md:452
msgid ""
"To write a value to a storage variable, we call the `write` function passing in the eventual keys the value as arguments. As with the `read` function, the number of arguments depends "
"on the number of keys - here, we only pass in the value to write to the `owner` variable as it is a simple variable."
msgstr ""
"要将值写入存储变量，我们需要调用 `write` 函数，并将其最终键和值作为参数传递。与 read 函数一样，参数的数量取决于键的数量——这里，我们只需要将要写入 `owner`变量的值作为参数，因为它是一个"
"简单的变量。"

#: src/ch99-01-03-01-contract-storage.md:454
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:558
msgid "<span class=\"caption\">Calling the `write` function on the `owner` variable</span>"
msgstr "<span class=\"caption\">调用`owner` 变量上的`write` 函数</span>"

#: src/ch99-01-03-01-contract-storage.md:560
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:664
msgid "<span class=\"caption\">Calling the `write` function on the `names` variable</span>"
msgstr "<span class=\"caption\">调用 `names` 变量上的 `write`  函数</span>"

#: src/ch99-01-03-01-contract-storage.md:666
msgid "## Storing custom types"
msgstr "## 存储自定义结构体"

#: src/ch99-01-03-01-contract-storage.md:668
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used to specify how a type should be stored in storage. In order for a type to be stored in storage, it must "
"implement the `Store` trait. Most types from the core library, such as unsigned integers (`u8`, `u128`, `u256`...), `felt252`, `bool`, `ContractAddress`, etc. implement the `Store` "
"trait and can thus be stored without further action."
msgstr ""
"`Store` trait，定义在 `starknet::storage_access`  模块中，用于指定类型如何在存储中存储。为了将类型存储在存储中，它必须实现 `Store` trait。大多数来自核心库的类型，例如无符号整数 "
"(`u8`, `u128`, `u256`...),、`felt252`、`bool`、`ContractAddress` 等都实现了 `Store` trait，因此无需进一步操作即可存储。"

#: src/ch99-01-03-01-contract-storage.md:670
msgid "But what if you wanted to store a type that you defined yourself, such as an enum or a struct? In that case, you have to explicitly tell the compiler how to store this type."
msgstr "但是，如果您想存储您自己定义的类型，例如枚举或结构，该怎么办？在这种情况下，您必须明确地告诉编译器如何存储这种类型。"

#: src/ch99-01-03-01-contract-storage.md:672
msgid ""
"In our example, we want to store a `Person` struct in storage, which is possible by implementing the `Store` trait for the `Person` type. This can be achieved by simply adding a "
"`#[derive(starknet::Store)]` attribute on top of our struct definition."
msgstr ""
"在我们的例子中，我们想将 `Person` 结构存储在存储中，这可以通过为 `Person` 类型实现 `Store` 特性来实现。这可以通过在结构体定义顶部简单添加 `#[derive(starknet::Store)]` 属性来实现。"

#: src/ch99-01-03-01-contract-storage.md:674
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Person {\n"
"        name: felt252,\n"
"        address: ContractAddress\n"
"    }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Person {\n"
"        name: felt252,\n"
"        address: ContractAddress\n"
"    }\n"
"# \n"
"#     #[derive(Drop, Serde, starknet::Store)]\n"
"#     enum RegistrationType {\n"
"#         finite: u64,\n"
"#         infinite\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:778
msgid "Similarly, Enums can be written to storage if they implement the `Store` trait, which can be trivially derived as long as all associated types implement the `Store` trait."
msgstr "类似地，枚举也可以在实现 `Store` trait的情况下写入存储，只要所有关联类型也实现 `Store` trait，就可以简单地推导它。"

#: src/ch99-01-03-01-contract-storage.md:780
msgid ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"    #[derive(Drop, Serde, starknet::Store)]\n"
"    enum RegistrationType {\n"
"        finite: u64,\n"
"        infinite\n"
"    }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust, noplayground\n"
"# \n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait INameRegistry<TContractState> {\n"
"#     fn store_name(\n"
"#         ref self: TContractState, name: felt252, registration_type: NameRegistry::RegistrationType\n"
"#     );\n"
"#     fn get_name(self: @TContractState, address: ContractAddress) -> felt252;\n"
"#     fn get_owner(self: @TContractState) -> NameRegistry::Person;\n"
"# }\n"
"# \n"
"# \n"
"# #[starknet::contract]\n"
"# mod NameRegistry {\n"
"#     use starknet::{ContractAddress, get_caller_address};\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         names: LegacyMap::<ContractAddress, felt252>,\n"
"#         registration_type: LegacyMap::<ContractAddress, RegistrationType>,\n"
"#         total_names: u128,\n"
"#         owner: Person\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         StoredName: StoredName,\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct StoredName {\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         name: felt252\n"
"#     }\n"
"# \n"
"#     #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"#     struct Person {\n"
"#         name: felt252,\n"
"#         address: ContractAddress\n"
"#     }\n"
"# \n"
"    #[derive(Drop, Serde, starknet::Store)]\n"
"    enum RegistrationType {\n"
"        finite: u64,\n"
"        infinite\n"
"    }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, owner: Person) {\n"
"#         self.names.write(owner.address, owner.name);\n"
"#         self.total_names.write(1);\n"
"#         self.owner.write(owner);\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl NameRegistry of super::INameRegistry<ContractState> {\n"
"#         fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"#             let caller = get_caller_address();\n"
"#             self._store_name(caller, name, registration_type);\n"
"#         }\n"
"# \n"
"#         fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"#             let name = self.names.read(address);\n"
"#             name\n"
"#         }\n"
"#         fn get_owner(self: @ContractState) -> Person {\n"
"#             let owner = self.owner.read();\n"
"#             owner\n"
"#         }\n"
"#     }\n"
"# \n"
"#     #[generate_trait]\n"
"#     impl InternalFunctions of InternalFunctionsTrait {\n"
"#         fn _store_name(\n"
"#             ref self: ContractState,\n"
"#             user: ContractAddress,\n"
"#             name: felt252,\n"
"#             registration_type: RegistrationType\n"
"#         ) {\n"
"#             let mut total_names = self.total_names.read();\n"
"#             self.names.write(user, name);\n"
"#             self.registration_type.write(user, registration_type);\n"
"#             self.total_names.write(total_names + 1);\n"
"#             self.emit(StoredName { user: user, name: name });\n"
"# \n"
"#         }\n"
"#     }\n"
"# \n"
"#     fn get_contract_name() -> felt252 {\n"
"#         'Name Registry'\n"
"#     }\n"
"# \n"
"#     fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"#         self.owner.address()\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch99-01-03-01-contract-storage.md:884
msgid "### Structs storage layout"
msgstr "### 结构体的存储布局"

#: src/ch99-01-03-01-contract-storage.md:886
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types.\n"
"The elements of the struct are stored in the same order as they are defined in the struct definition. The first element of the struct is stored at the base address of the struct, "
"which is computed as specified in [Storage Addresses](#storage-addresses) and can be obtained by calling `var.address()`, and subsequent elements are stored at addresses contiguous "
"to the first element.\n"
"For example, the storage layout for the `owner` variable of type `Person` will result in the following layout:"
msgstr ""
"在 Starknet 上，结构会被存储为基本类型序列。结构的元素按照结构定义中的顺序进行存储。结构的第一个元素存储在结构的基地址，该地址根据 [存储地址](#storage-addresses) 中的说明计算，可以通"
"过调用 `var.address()` 获取，后面的元素则存储在与第一个元素相邻的地址。\n"
"\n"
"例如，类型为 `Person` 的 `owner` 变量的存储布局将如下所示："

#: src/ch99-01-03-01-contract-storage.md:890
msgid ""
"| Fields  | Address            |\n"
"| ------- | ------------------ |\n"
"| name    | owner.address()    |\n"
"| address | owner.address() +1 |"
msgstr ""
"| Fields  | Address            |\n"
"| ------- | ------------------ |\n"
"| name    | owner.address()    |\n"
"| address | owner.address() +1 |"

#: src/ch99-01-03-01-contract-storage.md:895
msgid "### Enums storage layout"
msgstr "### 枚举的存储布局"

#: src/ch99-01-03-01-contract-storage.md:897
msgid ""
"When you store an enum variant, what you're essentially storing is the variant's index and an eventual associated values. This index starts at 0 for the first variant of your enum "
"and increments by 1 for each subsequent variant.\n"
"If your variant has an associated value, it's stored starting from the address immediately following the base address.\n"
"For example, suppose we have the `RegistrationType` enum with the `finite` variant, which carries an associated limit date. The storage layout would look like this:"
msgstr ""
"当您存储一个枚举变体时，您实际上存储的是变体的索引和最终的关联值。这个索引从您的枚举的第一个变体开始为 0，并为每个后续变体增加 1。\n"
"如果您的变体具有关联值，它会从基地址之后的第一个地址开始存储。\n"
"例如，假设我们有一个带有 `finite` 变体的 `RegistrationType` 枚举，该变体带有关联的截止日期。存储布局将如下所示："

#: src/ch99-01-03-01-contract-storage.md:901
msgid ""
"| Element                           | Address                         |\n"
"| --------------------------------- | ------------------------------- |\n"
"| Variant index (e.g. 1 for finite) | registration_type.address()     |\n"
"| Associated limit date             | registration_type.address() + 1 |"
msgstr ""
"| Element                           | Address                         |\n"
"| --------------------------------- | ------------------------------- |\n"
"| Variant index (e.g. 1 for finite) | registration_type.address()     |\n"
"| Associated limit date             | registration_type.address() + 1 |"

#: src/ch99-01-03-01-contract-storage.md:906
msgid "## Storage mappings"
msgstr "## 存储映射"

#: src/ch99-01-03-01-contract-storage.md:908
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys to values. However, unlike a typical hash table, the key data itself is not stored - only its hash is used "
"to look up the associated value in the contract's storage.\n"
"Mappings do not have a concept of length or whether a key/value pair is set. The only way to remove a mapping is to set its value to the default zero value."
msgstr ""
"存储映射类似于哈希表，它们允许将键映射到值。但是，与典型的哈希表不同，不存储键数据本身 - 仅使用其哈希码在合约的存储中查找关联的值。\n"
"映射没有长度概念，也没有键/值对是否设置的概念。删除映射的唯一方法是将其值设置为默认的零值。"

#: src/ch99-01-03-01-contract-storage.md:911
msgid ""
"Mappings are only used to compute the location of data in the storage of a\n"
"contract given certain keys. They are thus **only allowed as storage variables**.\n"
"They cannot be used as parameters or return parameters of contract functions,\n"
"and cannot be used as types inside structs."
msgstr "映射只用于根据某些键计算合约存储中数据的位置。因此，它们只能作为存储变量使用。它们不能用作合约函数的参数或返回值参数，也不能用作结构体内的类型。"

#: src/ch99-01-03-01-contract-storage.md:916
msgid ""
"<div align=\"center\">\n"
"    <img src=\"mappings.png\" alt=\"mappings\" width=\"500px\"/>\n"
"<div align=\"center\">\n"
"    </div>\n"
"    <span class=\"caption\">Mapping keys to storage values</span>\n"
"</div>"
msgstr ""
"<div align=\"center\">\n"
"    <img src=\"mappings.png\" alt=\"mappings\" width=\"500px\"/>\n"
"<div align=\"center\">\n"
"    </div>\n"
"    <span class=\"caption\">Mapping keys to storage values</span>\n"
"</div>"

#: src/ch99-01-03-01-contract-storage.md:923
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets `<>`,\n"
"specifying the key and value types."
msgstr "要声明一个映射，请使用尖括号 `<>` 包围的 `LegacyMap`类型，指定键和值类型。"

#: src/ch99-01-03-01-contract-storage.md:926
msgid ""
"You can also create more complex mappings with multiple keys. You can find one in Listing 99-2bis like the popular `allowances` storage variable in the ERC20 Standard which maps an "
"`owner` and an allowed `spender` to its `allowance` amount using multiple keys passed inside a tuple:"
msgstr ""
"你还可以创建具有多个键的更复杂的映射。在示例 99-2bis 中可以找到一个示例，就像ERC20标准中的流行的 `allowances` 存储变量一样，它使用多个键将 `owner` 和允许的 `spender` 映射到其 "
"`allowance` 金额，这些键被传递到一个元组中："

#: src/ch99-01-03-01-contract-storage.md:928
msgid ""
"```rust,noplayground\n"
"    #[storage]\n"
"    struct Storage {\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[storage]\n"
"    struct Storage {\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>\n"
"    }\n"
"```"

#: src/ch99-01-03-01-contract-storage.md:935
msgid "<span class=\"caption\">Listing 99-2bis: Storing mappings</span>"
msgstr "<span class=\"caption\">示例99-2bis：存储映射</span>"

#: src/ch99-01-03-01-contract-storage.md:937
msgid ""
"The address in storage of a variable stored in a mapping is computed according to the description in the [Storage Addresses](#storage-addresses) section.\n"
"If the key of a mapping is a struct, each element of the struct constitutes a key. Moreover, the struct should implement the `Hash` trait, which can be derived with the "
"`#[derive(Hash)]` attribute. For example, if you have struct with two fields, the address will be `h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the values of "
"the two fields of the struct."
msgstr ""
"存储在映射中的变量的存储地址根据 [存储地址](#storage-addresses) 部分的描述进行计算。\n"
"\n"
"如果映射的键是一个结构体，则结构体的每个元素都构成一个键。此外，结构体应该实现 `Hash` trait，可以使用 `#[derive(Hash)]`  属性派生。例如，如果您的结构体有两个字段，则地址将是 "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - 其中 `k_1`  和 `k_2`  是结构体这两个字段的值。"

#: src/ch99-01-03-01-contract-storage.md:940
msgid ""
"Similarly, in the case of a nested mapping such as `LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be computed in the same way: `h(h(sn_keccak(variable_name),"
"k_1),k_2)`."
msgstr "类似地，对于嵌套映射，例如 `LegacyMap((ContractAddress, ContractAddress), u8)`，地址将以相同的方式计算：`h(h(sn_keccak(variable_name),k_1),k_2)`。"

#: src/ch99-01-03-01-contract-storage.md:942
msgid ""
"For more details about the contract storage layout in the [Starknet Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/"
"#storage_variables)"
msgstr ""
"如果你想了解更多关于合约存储布局的细节，可以访问 [Starknet 文档](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables)"

#: src/ch99-01-03-01-contract-storage.md:944 src/ch99-01-04-01-voting-contract.md:433
msgid "<footer id=\"last-change\">Last change: 2023-12-03</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-12-03</footer>"

#: src/ch99-01-03-02-contract-functions.md:1
msgid "## Contract Functions"
msgstr "## 合约函数"

#: src/ch99-01-03-02-contract-functions.md:3
msgid "In this section, we are going to be looking at the different types of functions you could encounter in contracts:"
msgstr "在本节中，我们将了解合约中可能遇到的不同类型的函数："

#: src/ch99-01-03-02-contract-functions.md:5
msgid "### 1. Constructors"
msgstr "### 1.构造器（Constructors）"

#: src/ch99-01-03-02-contract-functions.md:7
msgid "Constructors are a special type of function that only runs once when deploying a contract, and can be used to initialize the state of a contract."
msgstr "构造函数是一种特殊类型的函数，只在部署合约时运行一次，可用于初始化合约的状态。"

#: src/ch99-01-03-02-contract-functions.md:9
msgid ""
"```rust,noplayground\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, owner: Person) {\n"
"        self.names.write(owner.address, owner.name);\n"
"        self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, owner: Person) {\n"
"        self.names.write(owner.address, owner.name);\n"
"        self.total_names.write(1);\n"
"        self.owner.write(owner);\n"
"    }\n"
"```"

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr "一些需要注意的重要规则："

#: src/ch99-01-03-02-contract-functions.md:20
msgid ""
"1. Your contract can't have more than one constructor.\n"
"2. Your constructor function must be named `constructor`.\n"
"3. It must be annotated with the `#[constructor]` attribute."
msgstr ""
"1.您的合约不能有一个以上的构造函数。\n"
"2.您的构造函数必须命名为 `constructor`。\n"
"3.它必须使用 `#[constructor]` 属性标注。"

#: src/ch99-01-03-02-contract-functions.md:24
msgid "### 2. Public functions"
msgstr "### 2.公共函数"

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the contract. They must be defined inside an implementation block annotated with the `#[external(v0)]` "
"attribute. This attribute only affects the visibility (public vs private/internal), but it doesn't inform us on the ability of these functions to modify the state of the contract."
msgstr ""
"如前所述，公有函数可以从合约外部访问。它们必须定义在带有`#[external(v0)]`属性注解的实现块中。这个属性只影响可见性（public 或 private/internal），但并不影响这些函数修改合约状态的能力。"

#: src/ch99-01-03-02-contract-functions.md:28
msgid ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl NameRegistry of super::INameRegistry<ContractState> {\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"        fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"            owner\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[external(v0)]\n"
"    impl NameRegistry of super::INameRegistry<ContractState> {\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"        fn get_owner(self: @ContractState) -> Person {\n"
"            let owner = self.owner.read();\n"
"            owner\n"
"        }\n"
"    }\n"
"```"

#: src/ch99-01-03-02-contract-functions.md:47
msgid "#### External functions"
msgstr "### 外部函数"

#: src/ch99-01-03-02-contract-functions.md:49
msgid ""
"External functions are functions that can modify the state of a contract. They are public and can be called by any other contract or externally.\n"
"External functions are _public_ functions where the `self: ContractState` is passed as reference with the `ref` keyword, allowing you to modify the state of the contract."
msgstr ""
"外部函数是可以修改合约状态的函数。它们是公共的，可以被任何其他合约或外部调用。\n"
"外部函数是 _public_ 函数，其中的 `self：ContractState` 以引用的形式通过关键字 `ref` 传递，使得你可以修改合约的状态。"

#: src/ch99-01-03-02-contract-functions.md:52
msgid ""
"```rust,noplayground\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"        fn store_name(ref self: ContractState, name: felt252, registration_type: RegistrationType) {\n"
"            let caller = get_caller_address();\n"
"            self._store_name(caller, name, registration_type);\n"
"        }\n"
"```"

#: src/ch99-01-03-02-contract-functions.md:59
msgid "#### View functions"
msgstr "### 视图函数"

#: src/ch99-01-03-02-contract-functions.md:61
msgid ""
"View functions are read-only functions allowing you to access data from the contract while ensuring that the state of the contract is not modified. They can be called by other "
"contracts or externally.\n"
"View functions are _public_ functions where the `self: ContractState` is passed as snapshot, preventing you from modifying the state of the contract."
msgstr ""
"视图函数是只读函数，允许你访问合约中的数据，同时确保合约的状态不会被修改。它们可以被其他合约或外部调用。\n"
"视图函数是 _public_ 函数，其中 `self.ContractState` 被作为快照传入，这会防止你修改合约的状态。"

#: src/ch99-01-03-02-contract-functions.md:64
msgid ""
"```rust,noplayground\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {\n"
"            let name = self.names.read(address);\n"
"            name\n"
"        }\n"
"```"

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"> **Note:** It's important to note that both external and view functions are public. To create an internal function in a contract, you will need to define it outside of the "
"implementation block annotated with the `#[external(v0)]` attribute."
msgstr ">  **注意：** 外部函数和视图函数都是公共函数，这一点很重要。要在合约中创建内部函数，您需要在使用 `#[external(v0)]`属性标注的实现块之外定义它。"

#: src/ch99-01-03-02-contract-functions.md:73
msgid "### 3. Private functions"
msgstr "### 3.私有函数"

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the `#[external(v0)]` attribute are private functions (also called internal functions). They can only be called from within "
"the contract."
msgstr "未在注有`#[external(v0)]`属性的代码块中定义的函数是私有函数（也称为内部函数）。它们只能在合约内部调用。"

#: src/ch99-01-03-02-contract-functions.md:77 src/ch99-01-03-04-reducing-boilerplate.md:5
msgid ""
"```rust,noplayground\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn _store_name(\n"
"            ref self: ContractState,\n"
"            user: ContractAddress,\n"
"            name: felt252,\n"
"            registration_type: RegistrationType\n"
"        ) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.registration_type.write(user, registration_type);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(StoredName { user: user, name: name });\n"
"\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn _store_name(\n"
"            ref self: ContractState,\n"
"            user: ContractAddress,\n"
"            name: felt252,\n"
"            registration_type: RegistrationType\n"
"        ) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.registration_type.write(user, registration_type);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(StoredName { user: user, name: name });\n"
"\n"
"        }\n"
"    }\n"
"```"

#: src/ch99-01-03-02-contract-functions.md:96
msgid ""
"> Wait, what is this `#[generate_trait]` attribute? Where is the trait definition for this implementation? Well, the `#[generate_trait]` attribute is a special attribute that tells "
"the compiler to generate a trait definition for the implementation block. This allows you to get rid of the boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next section](./ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""
"> 等等，这个`#[generate_trait]`属性是什么？这个实现的trait定义在哪里？嗯，`#[generate_trait]`属性是一个特殊的属性，它告诉编译器为实现块生成一个trait定义。这允许你摆脱为实现块定义trait"
"和实现trait的模板代码。我们将在[下一节](./ch99-01-03-04-reducing-boilerplate.md)中看到更多关于这方面的内容。"

#: src/ch99-01-03-02-contract-functions.md:98
msgid ""
"At this point, you might still be wondering if all of this is really necessary if you don't need to access the contract's state in your function (for example, a helper/library "
"function). As a matter of fact, you can also define internal functions outside of implementation blocks. The only reason why we _need_ to define functions inside impl blocks is if we "
"want to access the contract's state."
msgstr ""
"说到这里，您可能还在想，如果您不需要在您的函数（例如，辅助函数/库函数）中访问合约的状态，所有这些是否真的有必要。事实上，您也可以在实现块之外定义内部函数。我们 _需要_ 在实现块内部定义"
"函数的唯一原因是我们想要访问合约的状态。"

#: src/ch99-01-03-02-contract-functions.md:100
msgid ""
"```rust,noplayground\n"
"    fn get_contract_name() -> felt252 {\n"
"        'Name Registry'\n"
"    }\n"
"\n"
"    fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    fn get_contract_name() -> felt252 {\n"
"        'Name Registry'\n"
"    }\n"
"\n"
"    fn get_owner_storage_address(self: @ContractState) -> starknet::StorageBaseAddress {\n"
"        self.owner.address()\n"
"    }\n"
"```"

#: src/ch99-01-03-03-contract-events.md:1
msgid "## Events"
msgstr "## 事件"

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during execution.\n"
"They provide a way for smart contracts to communicate with the external world by logging information\n"
"about specific occurrences in a contract."
msgstr ""
"事件是定制的数据结构，由智能合约在执行期间发出。\n"
"它们为智能合约提供了一种与外部世界沟通的方式，即记录合约中所发生的特定事情的信息。"

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these are indexed and stored in a "
"database, then displayed to users through the use of these events. Neglecting to include an event within your NFT contract could lead to a bad user experience. This is because users "
"may not see their NFTs appear in their wallets (wallets use these indexers to display a user's NFTs)."
msgstr ""
"事件在智能合约的创建中起着至关重要的作用。以Starknet上铸造的Non-Fungible Tokens（NFTs）为例。所有这些都被索引并存储在数据库中，然后通过使用这些事件显示给用户。忘记在你的NFT合约中编写"
"一个事件可能会导致糟糕的用户体验。这是因为用户可能看不到他们的NFT出现在他们的钱包里（钱包使用这些索引器来显示用户的NFT）。"

#: src/ch99-01-03-03-contract-events.md:9
msgid "### Defining events"
msgstr "### 界定事件"

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, which implements the `starknet::Event` trait, as enum variants. This trait is defined in the core library "
"as follows:"
msgstr "合约中所有不同的事件都定义在 `Event`枚举中，它实现了`starknet::Event`  trait，作为枚举变量。该trait在核心库中定义如下："

#: src/ch99-01-03-03-contract-events.md:13
msgid ""
"```rust,noplayground\n"
"trait Event<T> {\n"
"    fn append_keys_and_data(self: T, ref keys: Array<felt252>, ref data: Array<felt252>);\n"
"    fn deserialize(ref keys: Span<felt252>, ref data: Span<felt252>) -> Option<T>;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"trait Event<T> {\n"
"    fn append_keys_and_data(self: T, ref keys: Array<felt252>, ref data: Array<felt252>);\n"
"    fn deserialize(ref keys: Span<felt252>, ref data: Span<felt252>) -> Option<T>;\n"
"}\n"
"```"

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate an implementation for the above trait,\n"
"instantiated with the Event type, which in our example is the following enum:"
msgstr ""
"属性 `#[derive(starknet::Event)]`会使得编译器为上述trait生成一个实现、\n"
"在我们的例子中，它是下面的枚举："

#: src/ch99-01-03-03-contract-events.md:23
msgid ""
"```rust,noplayground\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        StoredName: StoredName,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct StoredName {\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        name: felt252\n"
"    }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        StoredName: StoredName,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct StoredName {\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        name: felt252\n"
"    }\n"
"```"

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and each variant needs to implement the `starknet::Event` trait itself.\n"
"Moreover, the members of these variants must implement the `Serde` trait (_c.f._ [Appendix C: Serializing with Serde](./appendix-03-derivable-traits.md)), as keys/data are added to "
"the event using a serialization process."
msgstr ""
"每个事件变体成员必须是一个与变体同名的结构体，并且每个变体本身需要实现`starknet::Event`trait。\n"
"此外，这些变体的成员必须实现`Serde`trait(_c.f._ [Appendix C: Serializing with Serde](./appendix-03-derivable-traits.md))，因为键/数据是通过序列化过程添加到事件中的。"

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the `append_keys_and_data` function for each variant of our `Event` enum. The generated implementation will "
"append a single key based on the variant name (`StoredName`), and then recursively call `append_keys_and_data` in the impl of the Event trait for the variant’s type ."
msgstr ""
"`starknet::Event`trait的自动实现将为我们的 `Event`枚举的每个变体成员实现  `append_keys_and_data`函数。生成的实现将根据变量名（`StoredName`）附加一个单独的键，然后递归调用`Event`trait"
"的实现中的`append_keys_and_data`函数。"

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the contract address of the caller and the name stored within the contract, where the `user` field is serialized as "
"a key and the `name` field is serialized as data.\n"
"To index the key of an event, simply annotate it with the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""
"在我们的合约中，我们定义了一个名为 `StoredName` 的事件，该事件将调用者的合约地址和存储在合约中的名称发送出去，其中 `user` 字段序列化为键，而 `name` 字段序列化为数据。\n"
"要索引一个事件的键，只需用`#[key]`注释它，如`user`键的示例所示。"

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name })`, a key corresponding to the name ` StoredName`, specifically `sn_keccak(StoredName)`, is appended to "
"the keys list. `user`is serialized as key, thanks to the `#[key]` attribute, while address is serialized as data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [address]`."
msgstr ""
"当使用 `self.emit(StoredName { user: user, name: name })` 发布事件时，与名称 `StoredName` 相对应的键，特别是 `sn_keccak(StoredName)` 会被添加到键列表中。由于使用了 `#[key]`属性，"
"`user` 被序列化为 key，而地址被序列化为数据。一切处理完毕后，我们将得到以下键和数据：`keys = [sn_keccak(\"StoredName\"),user]` 和 `data = [address]`。"

#: src/ch99-01-03-03-contract-events.md:48
msgid "### Emitting events"
msgstr "### 发射事件"

#: src/ch99-01-03-03-contract-events.md:50
msgid "After defining events, we can emit them using `self.emit`, with the following syntax:"
msgstr "定义事件后，我们可以使用`self.emit`来emit它们，语法如下："

#: src/ch99-01-03-03-contract-events.md:52
msgid ""
"```rust,noplayground\n"
"            self.emit(StoredName { user: user, name: name });\n"
"```"
msgstr ""
"```rust,noplayground\n"
"            self.emit(StoredName { user: user, name: name });\n"
"```"

#: src/ch99-01-03-03-contract-events.md:56
msgid "<footer id=\"last-change\">Last change: 2023-09-06</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-09-06</footer>"

#: src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "# Reducing boilerplate"
msgstr "# 减少冗余模板代码"

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid "In a previous section, we saw this example of an implementation block in a contract that didn't have any corresponding trait."
msgstr "在上一节中，我们看到了这样一个示例：在一个没有任何相应trait的合约中，有一个实现块。"

#: src/ch99-01-03-04-reducing-boilerplate.md:24
msgid ""
"It's not the first time that we encounter this attribute, we already talked about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this section, we'll be taking a deeper "
"look at it and see how it can be used in contracts."
msgstr "这并不是我们第一次遇到这个属性，我们已经在在Cairo中使用 `Traits`(./ch08-02-traits-in-cairo.md) 中讨论过它。在本节中，我们将更深入地研究它，并看看它在合约中的使用方式。"

#: src/ch99-01-03-04-reducing-boilerplate.md:26
msgid ""
"Recall that in order to access the ContractState in a function, this function must be defined in an implementation block whose generic parameter is `ContractState`. This implies that "
"we first need to define a generic trait that takes a `TContractState`, and then implement this trait for the `ContractState` type.\n"
"But by using the `#[generate_trait]` attribute, this whole process can be skipped and we can simply define the implementation block directly, without any generic parameter, and use "
"`self: ContractState` in our functions."
msgstr ""
"回想一下，为了在函数中访问 ContractState，该函数必须定义在泛型参数为 `ContractState` 的实现块中。这意味着我们首先需要定义一个接受`TContractState`的泛型trait，然后为`ContractState`类型"
"实现这个trait。\n"
"但是通过使用 `#[generate_trait]` 属性，我们可以跳过整个过程，从而简单地直接定义实现块，不需要任何泛型参数，并在我们的函数中使用 `self.ContractState` 属性。"

#: src/ch99-01-03-04-reducing-boilerplate.md:29
msgid "If we had to manually define the trait for the `InternalFunctions` implementation, it would look something like this:"
msgstr "如果我们必须手动定义 `InternalFunctions` 所实现的trait，它将看起来像这样："

#: src/ch99-01-03-04-reducing-boilerplate.md:31
msgid ""
"```rust,noplayground\n"
"    trait InternalFunctionsTrait<TContractState> {\n"
"        fn _store_name(ref self: TContractState, user: ContractAddress, name: felt252);\n"
"    }\n"
"    impl InternalFunctions of InternalFunctionsTrait<ContractState> {\n"
"        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(Event::StoredName(StoredName { user: user, name: name }));\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    trait InternalFunctionsTrait<TContractState> {\n"
"        fn _store_name(ref self: TContractState, user: ContractAddress, name: felt252);\n"
"    }\n"
"    impl InternalFunctions of InternalFunctionsTrait<ContractState> {\n"
"        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {\n"
"            let mut total_names = self.total_names.read();\n"
"            self.names.write(user, name);\n"
"            self.total_names.write(total_names + 1);\n"
"            self.emit(Event::StoredName(StoredName { user: user, name: name }));\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"```"

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "## Storage Optimization with `StorePacking`"
msgstr "## 使用`StorePacking`优化存储"

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a piece of data. When done well, it can significantly reduce the size of the data you need to store. This is "
"especially important in smart contracts, where storage is expensive."
msgstr "位压缩是一个简单的概念：使用尽可能少的位数来存储数据。如果做得好，它可以显著减少需要存储的数据大小。这在智能合约中尤为重要，因为存储是昂贵的。"

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage usage to reduce gas costs. Indeed, most of the cost associated with a transaction is related to storage "
"updates; and each storage slot costs gas to write to.\n"
"This means that by packing multiple values into fewer slots, you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""
"在编写Cairo智能合约时，优化存储使用以减少 gas 成本是非常重要的。事实上，与交易相关的大部分成本都与存储更新相关；而每个存储槽位写入都需要 gas 成本。\n"
"这意味着通过将多个值打包到较少的槽位中，你可以减少智能合约的用户所需的 gas 成本。"

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into fewer storage slots. For example, consider a `Sizes` struct with 3 fields of different types. The total "
"size is 8 + 32 + 64 = 104 bits. This is less than the 128 bits of a single `u128`. This means we can pack all 3 fields into a single `u128` variable. Since a storage slot can hold up "
"to 251 bits, our packed value will take only one storage slot instead of 3."
msgstr ""
"Cairo提供了 `StorePacking` trait，以便将结构体字段打包到较少的存储槽位中。例如，考虑一个具有3个不同类型字段的 `Sizes` 结构体。总大小为8 + 32 + 64 = 104位。这比单个 `u128` 的128位要"
"小。这意味着我们可以将这3个字段都打包到一个单独的 `u128` 变量中。由于一个存储槽位最多可以容纳251位，我们打包后的值只需要一个存储槽位，而不是3个。"

#: src/ch99-01-03-05-optimizing-storage.md:10
msgid ""
"```rust\n"
"use starknet::{StorePacking};\n"
"use integer::{u128_safe_divmod, u128_as_non_zero};\n"
"\n"
"#[derive(Drop, Serde)]\n"
"struct Sizes {\n"
"    tiny: u8,\n"
"    small: u32,\n"
"    medium: u64,\n"
"}\n"
"\n"
"const TWO_POW_8: u128 = 0x100;\n"
"const TWO_POW_40: u128 = 0x10000000000;\n"
"\n"
"const MASK_8: u128 = 0xff;\n"
"const MASK_32: u128 = 0xffffffff;\n"
"\n"
"\n"
"impl SizesStorePacking of StorePacking<Sizes, u128> {\n"
"    fn pack(value: Sizes) -> u128 {\n"
"        value.tiny.into() + (value.small.into() * TWO_POW_8) + (value.medium.into() * TWO_POW_40)\n"
"    }\n"
"\n"
"    fn unpack(value: u128) -> Sizes {\n"
"        let tiny = value & MASK_8;\n"
"        let small = (value / TWO_POW_8) & MASK_32;\n"
"        let medium = (value / TWO_POW_40);\n"
"\n"
"        Sizes {\n"
"            tiny: tiny.try_into().unwrap(),\n"
"            small: small.try_into().unwrap(),\n"
"            medium: medium.try_into().unwrap(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SizeFactory {\n"
"    use super::Sizes;\n"
"    use super::SizesStorePacking; //don't forget to import it!\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        remaining_sizes: Sizes\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    fn update_sizes(ref self: ContractState, sizes: Sizes) {\n"
"        // This will automatically pack the\n"
"        // struct into a single u128\n"
"        self.remaining_sizes.write(sizes);\n"
"    }\n"
"\n"
"\n"
"    #[external(v0)]\n"
"    fn get_sizes(ref self: ContractState) -> Sizes {\n"
"        // this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
"        self.remaining_sizes.read()\n"
"    }\n"
"}\n"
"\n"
"\n"
"```"
msgstr ""
"```rust\n"
"use starknet::{StorePacking};\n"
"use integer::{u128_safe_divmod, u128_as_non_zero};\n"
"\n"
"#[derive(Drop, Serde)]\n"
"struct Sizes {\n"
"    tiny: u8,\n"
"    small: u32,\n"
"    medium: u64,\n"
"}\n"
"\n"
"const TWO_POW_8: u128 = 0x100;\n"
"const TWO_POW_40: u128 = 0x10000000000;\n"
"\n"
"const MASK_8: u128 = 0xff;\n"
"const MASK_32: u128 = 0xffffffff;\n"
"\n"
"\n"
"impl SizesStorePacking of StorePacking<Sizes, u128> {\n"
"    fn pack(value: Sizes) -> u128 {\n"
"        value.tiny.into() + (value.small.into() * TWO_POW_8) + (value.medium.into() * TWO_POW_40)\n"
"    }\n"
"\n"
"    fn unpack(value: u128) -> Sizes {\n"
"        let tiny = value & MASK_8;\n"
"        let small = (value / TWO_POW_8) & MASK_32;\n"
"        let medium = (value / TWO_POW_40);\n"
"\n"
"        Sizes {\n"
"            tiny: tiny.try_into().unwrap(),\n"
"            small: small.try_into().unwrap(),\n"
"            medium: medium.try_into().unwrap(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SizeFactory {\n"
"    use super::Sizes;\n"
"    use super::SizesStorePacking; //don't forget to import it!\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        remaining_sizes: Sizes\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    fn update_sizes(ref self: ContractState, sizes: Sizes) {\n"
"        // This will automatically pack the\n"
"        // struct into a single u128\n"
"        self.remaining_sizes.write(sizes);\n"
"    }\n"
"\n"
"\n"
"    #[external(v0)]\n"
"    fn get_sizes(ref self: ContractState) -> Sizes {\n"
"        // this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
"        self.remaining_sizes.read()\n"
"    }\n"
"}\n"
"\n"
"\n"
"```"

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "<span class=\"caption\">Optimizing storage by implementing the `StorePacking` trait</span>"
msgstr "<span class=\"caption\">通过实现 `StorePacking` trait来优化存储</span>"

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by performing bitshift and additions. The `unpack` reverses this process to extract the original fields back "
"into a struct."
msgstr "`pack` 函数通过位移和加法将所有三个字段合并为一个  `u128`值。`unpack`则将这一过程逆转，将原始字段提取回结构体中。"

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the operations performed in the example:\n"
"The goal is to pack the `tiny`, `small`, and `medium` fields into a single `u128` value.\n"
"First, when packing:"
msgstr ""
"如果您对位运算不熟悉，这里将解释示例中执行的运算：\n"
"我们的目标是将 `tiny`, `small`, 还有 `medium`字段打包成一个 `u128` 值。\n"
"首先，打包时："

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"- `tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. This creates a `u128` value with the low 8 bits set to `tiny`'s value.\n"
"- `small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we add `tiny` to `small` to "
"combine them into a single `u128` value. The value of `tiny` now takes bits 0-7 and the value of small takes bits 8-39.\n"
"- Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits (`TWO_POW_40`) to make space for the previous fields. This takes bits 40-103."
msgstr ""
"- `tiny` 是一个 `u8`，因此我们只需用 `.into()` 将其直接转换为 `u128`。这会创建一个低 8 位设置为 `tiny` 值的 `u128` 值。\n"
"- `small` 是一个 `u32`，因此我们首先将它左移 8 位（向左添加 8 位值为 0 的比特），为 `tiny` 占用的 8 位留出空间。然后，我们将 `tiny` 添加到 `small` 中，将它们合并成一个 `u128` 值。现"
"在，`tiny` 的值占 0-7 位，`small` 的值占 8-39 位。\n"
"- 同样，`medium` 是一个 `u64`，因此我们将其左移 40 (8 + 32) 位（`TWO_POW_40`），为前面的字段腾出空间。这需要占用 40-103 位。"

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr "当解包时："

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"- First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& MASK_8`). This isolates the lowest 8 bits of the packed value, which is `tiny`'s value.\n"
"- For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the bitmask, then use bitwise AND with the 32 ones bitmask.\n"
"- For `medium` we right shift by 40 bits. Since it is the last value packed, we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""
"- 首先，我们通过与 8 个 1 的位掩码（`& MASK_8`）进行比特 AND（&）来提取`tiny`。这样就分离出打包值的最低 8 位，也就是 `tiny` 的值。\n"
"- 对于 `small`，我们右移 8 位 (`/TWO_POW_8`)，使其与位掩码对齐，然后与 32 个 1 的位掩码进行位和运算。\n"
"- 对于 `medium`，我们右移 40 位。由于它是最后打包的值，我们不需要应用位掩码，因为高位已经为 0。"

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit size of the packed storage type. For example, if you have a struct with multiple fields whose bit sizes add "
"up to 256 bits, you can pack them into a single `u256` variable. If the bit sizes add up to 512 bits, you can pack them into a single `u512` variable, and so on. You can define your "
"own structs and logic to pack and unpack them."
msgstr ""
"这种技术可用于任何一组适合打包存储类型位大小的字段。例如，如果一个结构体有多个字段，其位大小加起来为 256 位，那么可以将它们打包成一个 `u256` 变量。如果字段的位数加起来是 512 位，则可"
"以将它们打包到一个 `u512` 变量中，依此类推。你可以定义自己的结构和逻辑来打包和解包它们。"

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type implements the `StorePacking` trait, then the compiler will know it can use the `StoreUsingPacking` implementation "
"of the `Store` trait in order to pack before writing and unpack after reading from storage.\n"
"One important detail, however, is that the type that `StorePacking::pack` spits out also has to implement `Store` for `StoreUsingPacking` to work. Most of the time, we will want to "
"pack into a felt252 or u256 - but if you want to pack into a type of your own, make sure that this one implements the `Store` trait."
msgstr ""
"其余的工作由编译器自动完成 - 如果一个类型实现了 `StorePacking` trait，那么编译器将知道它可以使用 `Store` trait 的 `StoreUsingPacking` 实现，在写入之前进行打包，在从存储中读取后进行解"
"包。\n"
"然而，一个重要的细节是，`StorePacking::pack` 输出的类型也必须实现 `Store`，以使 `StoreUsingPacking` 正常工作。大多数情况下，我们希望打包到 felt252 或 u256 类型中 - 但是如果你想打包到"
"自定义类型中，请确保该类型实现了 `Store` trait。"

#: src/ch99-01-03-05-optimizing-storage.md:98
msgid "<footer id=\"last-change\">Last change: 2023-10-19</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-19</footer>"

#: src/ch99-01-05-00-components.md:1
msgid "# Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "# 组件：智能合约的乐高式构建块"

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and\n"
"bug-prone, as this logic can hardly be reused and needs to be reimplemented in\n"
"each contract. But what if there was a way to snap in just the extra\n"
"functionality you need inside your contract, separating the core logic of your\n"
"contract from the rest?"
msgstr ""
"开发共享通用逻辑和存储的合约可能会很痛苦，而且容易出错，\n"
"因为这个逻辑很难重用，需要在每份合约中重新编写。\n"
"但是，如果有一种方法可以额外提供您在合约中需要的功能，\n"
"并与你的合约的核心逻辑是分离的会怎样呢？"

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating reusable\n"
"logic, storage, and events that can be incorporated into multiple contracts.\n"
"They can be used to extend a contract's functionality, without having to\n"
"reimplement the same logic over and over again."
msgstr ""
"组件正好提供了这一点。它们是封装可重复使用的\n"
"模块化附加逻辑、存储和事件，可以被整合到多个合约中。\n"
"它们可用于扩展合约的功能，而无需一遍又一遍地重新实现相同的逻辑。"

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts by\n"
"plugging in a module that you or someone else wrote. This module can be a simple\n"
"one, like an ownership component, or more complex like a full-fledged ERC20\n"
"token."
msgstr ""
"将组件视为乐高积木。它们允许您通过插入您或其他人编写的模块方式增强您的合约。\n"
"这个模块可以是一个简单的组件，如所有权组件，或更复杂的，如成熟的 ERC20代币。"

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and\n"
"functions. Unlike a contract, a component cannot be declared or deployed. Its\n"
"logic will eventually be part of the contract’s bytecode it has been embedded\n"
"in."
msgstr ""
"组件是一个单独的模块，可以包含存储、事件和功能。\n"
"与合约不同，你不能声明或部署组件。\n"
"其逻辑最终将成为它被嵌入的合约字节码的一部分。"

#: src/ch99-01-05-00-components.md:24
msgid "## What's in a Component?"
msgstr "## 组件里面有什么？"

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "组件与合约非常相似。它可以包含："

#: src/ch99-01-05-00-components.md:28
msgid ""
"- Storage variables\n"
"- Events\n"
"- External and internal functions"
msgstr ""
"- 存储变量\n"
"- 事件\n"
"- 外部和内部函数"

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The component's\n"
"code becomes part of the contract it's embedded to."
msgstr "与合约不同，组件不能单独部署。组件的代码成为嵌入到的合约的一部分。"

#: src/ch99-01-05-00-components.md:35
msgid "## Creating Components"
msgstr "## 创建组件"

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a\n"
"`#[starknet::component]` attribute. Within this module, you can declare a `\n"
"Storage` struct and `Event` enum, as usually done in\n"
"[Contracts](./ch99-01-02-a-simple-contract.md)."
msgstr ""
"要创建一个组件，首先在它自己的模块中定义它，并用`#[starknet::component]`  属性。\n"
"在此模块中，您可以声明一个 `Storage` 结构和 `Event` 枚举，这通常在[合约](./ch99-01-02-a-simple-contract.md)中。"

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the signatures of\n"
"the functions that will allow external access to the component's logic. You can\n"
"define the interface of the component by declaring a trait with the\n"
"`#[starknet::interface]` attribute, just as you would with contracts. This\n"
"interface will be used to enable external access to the component's functions\n"
"using the\n"
"[Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md)\n"
"pattern."
msgstr ""
"下一步是定义组件接口，其中包含允许从外部访问组件逻辑的函数。\n"
"您可以这样定义组件的接口，方法是使用`#[starknet::interface]`属性，\n"
"就像你使用合约一样。这接口通过[Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md)模式，\n"
"用于启用对组件功能的外部访问。"

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an `impl`\n"
"block marked as `#[embeddable_as(name)]`. Usually, this `impl` block will be an\n"
"implementation of the trait defining the interface of the component."
msgstr ""
"组件外部逻辑的实际实现是在标记为`#[embeddable_as(name)]`的`impl`代码块中完成的。\n"
"通常，这个`impl`块将是一个定义组件接口的trait的实现。"

#: src/ch99-01-05-00-components.md:55
msgid ""
"> Note: `name` is the name that we’ll be using in the contract to refer to the\n"
"> component. It is different than the name of your impl."
msgstr ""
"> 注意：`name`是我们将在合约中用来指代\n"
"> 组件的名称。它与 impl 的名称不同。"

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible externally,\n"
"by simply omitting the `#[embeddable_as(name)]` attribute above the internal\n"
"`impl` block. You will be able to use these internal functions inside the\n"
"contract you embed the component in, but not interact with it from outside, as\n"
"they're not a part of the abi of the contract."
msgstr ""
"您还可以定义外部无法访问的内部函数，\n"
"只需省略内部`impl`块上方的 `#[embeddable_as(name)]`  属性即可。\n"
"您将能够在合约内部使用组件，但无法从外部与组件交互，因为它们不是合约 ABI 的一部分。"

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self:\n"
"ComponentState<TContractState>` (for state-modifying functions) or `self:\n"
"@ComponentState<TContractState>` (for view functions). This makes the impl\n"
"generic over `TContractState`, allowing us to use this component in any\n"
"contract."
msgstr ""
"这些`impl`块中的函数需要类似`ref self:ComponentState<TContractState>`（用于状态修改函数）的参数\n"
"或`self:@ComponentState<TContractState>`（用于只读函数）。这使得 impl\n"
"基于泛型 `TContractState`，允许我们在任何合约中使用该组件。"

#: src/ch99-01-05-00-components.md:70
msgid "### Example: an Ownable component"
msgstr "### 示例：一个 Ownable 组件"

#: src/ch99-01-05-00-components.md:72
msgid ""
"> ⚠️ The example shown below has not been audited and is not intended for\n"
"> production use. The authors are not responsible for any damages caused by the\n"
"> use of this code."
msgstr ""
"> ⚠️ 下面显示的示例尚未经过审核，不应适用于\n"
"> 产品之中。作者对因\n"
"> 使用此代码产生的任何问题概不负责。"

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available\n"
"externally to manage ownership of a contract, would look like this:"
msgstr "Ownable 组件的接口，定义的用于管理合约所有权外部可用方法如下所示："

#: src/ch99-01-05-00-components.md:79 src/ch99-01-05-00-components.md:305
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IOwnable<TContractState> {\n"
"    fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IOwnable<TContractState> {\n"
"    fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"}\n"
"```"

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr "组件本身定义为："

#: src/ch99-01-05-00-components.md:90
msgid "<!-- TODO -->"
msgstr "<!-- TODO -->"

#: src/ch99-01-05-00-components.md:92
msgid ""
"```rust\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferred: OwnershipTransferred\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred {\n"
"        previous_owner: ContractAddress,\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"\n"
"        fn transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            self.assert_only_owner();\n"
"            self._transfer_ownership(new_owner);\n"
"        }\n"
"\n"
"        fn renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            self.assert_only_owner();\n"
"            self._transfer_ownership(Zeroable::zero());\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of InternalTrait<TContractState> {\n"
"        fn initializer(ref self: ComponentState<TContractState>, owner: ContractAddress) {\n"
"            self._transfer_ownership(owner);\n"
"        }\n"
"\n"
"        fn assert_only_owner(self: @ComponentState<TContractState>) {\n"
"            let owner: ContractAddress = self.owner.read();\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);\n"
"            assert(caller == owner, Errors::NOT_OWNER);\n"
"        }\n"
"\n"
"        fn _transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            let previous_owner: ContractAddress = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self\n"
"                .emit(\n"
"                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner }\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferred: OwnershipTransferred\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred {\n"
"        previous_owner: ContractAddress,\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"\n"
"        fn transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            self.assert_only_owner();\n"
"            self._transfer_ownership(new_owner);\n"
"        }\n"
"\n"
"        fn renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            self.assert_only_owner();\n"
"            self._transfer_ownership(Zeroable::zero());\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of InternalTrait<TContractState> {\n"
"        fn initializer(ref self: ComponentState<TContractState>, owner: ContractAddress) {\n"
"            self._transfer_ownership(owner);\n"
"        }\n"
"\n"
"        fn assert_only_owner(self: @ComponentState<TContractState>) {\n"
"            let owner: ContractAddress = self.owner.read();\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);\n"
"            assert(caller == owner, Errors::NOT_OWNER);\n"
"        }\n"
"\n"
"        fn _transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            let previous_owner: ContractAddress = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self\n"
"                .emit(\n"
"                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner }\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch99-01-05-00-components.md:167
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The only\n"
"differences relate to the `#[embeddable_as]` attribute above the impl and the\n"
"genericity of the impl block that we will dissect in details."
msgstr ""
"这种语法实际上与用于合约的语法非常相似。\n"
"唯一的差异与 impl 上方的 `#[embeddable_as]` 属性有关。\n"
"我们将详细剖析的 impl 块的泛用性。"

#: src/ch99-01-05-00-components.md:171
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to the\n"
"implementation of the interface trait, and one containing methods that should\n"
"not be exposed externally and are only meant for internal use. Exposing the\n"
"`assert_only_owner` as part of the interface wouldn't make sense, as it's only\n"
"meant to be used internally by a contract embedding the component."
msgstr ""
"正如你所看到的，我们的组件有两个 `impl` 块：\n"
"一个对应于接口trait的实现，另一个包含不暴露在外部，仅供内部使用方法。\n"
"把`assert_only_owner`暴露出来作为接口的一部分是没有意义的，\n"
"因为它只是旨在由嵌入组件的合约在内部使用。"

#: src/ch99-01-05-00-components.md:177
msgid "## A closer look at the `impl` block"
msgstr "##  进一步研究 `impl` 块"

#: src/ch99-01-05-00-components.md:179
msgid "<!-- TODO quote the impl block syntax only -->"
msgstr "<!-- TODO quote the impl block syntax only -->"

#: src/ch99-01-05-00-components.md:181 src/ch99-01-05-01-components-under-the-hood.md:51
msgid ""
"```rust\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"```"
msgstr ""
"```rust\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"```"

#: src/ch99-01-05-00-components.md:188
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable inside a\n"
"contract. It allows us to specify the name of the impl that will be used in the\n"
"contract to refer to this component. In this case, the component will be\n"
"referred to as `Ownable` in contracts embedding it."
msgstr ""
"`#[embeddable_as]`属性用于将 impl 标记为可嵌入到合约。\n"
"它允许我们指定将在合约中引用此组件。\n"
"在这种情况下，组件将在嵌入它的合约中被视为`Ownable` 。"

#: src/ch99-01-05-00-components.md:193
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, with\n"
"the added restriction that `TContractState` must implement the `HasComponent<T>`\n"
"trait. This allows us to use the component in any contract, as long as the\n"
"contract implements the `HasComponent` trait. Understanding this mechanism in\n"
"details is not required to use components, but if you're curious about the inner\n"
"workings, you can read more in the [Components under the\n"
"hood](./ch99-01-05-01-components-under-the-hood.md) section."
msgstr ""
"实现本身是泛型的 `ComponentState<TContractState>`，\n"
"有着`TContractState` 必须实现`HasComponent<T>` trait的附加限制。\n"
"这允许我们在任何实现了`HasComponent` trait的合约中中使用该组件。\n"
"使用组件其实不需要你了解此机制的工作原理，但如果您对内部感到好奇，您可以阅读\n"
" [组件工作原理](./ch99-01-05-01-components-under-the-hood.md) 部分来学习更多。"

#: src/ch99-01-05-00-components.md:201
msgid ""
"One of the major differences from a regular smart contract is that access to\n"
"storage and events is done via the generic `ComponentState<TContractState>` type\n"
"and not `ContractState`. Note that while the type is different, accessing\n"
"storage or emitting events is done similarly via `self.storage_var_name.read()`\n"
"or `self.emit(...).`"
msgstr ""
"这里与常规智能合约的主要区别之一是访问\n"
"存储和事件是通过通用的`ComponentState<TContractState>`类型完成的，\n"
"而不是`ContractState`。请注意，虽然类型不同，但访问\n"
"存储或发出事件都是是通过类似 `self.storage_var_name.read()`或 `self.emit(...)`实现的。"

#: src/ch99-01-05-00-components.md:207
msgid ""
"> Note: To avoid the confusion between the embeddable name and the impl name, we\n"
"> recommend keeping the suffix `Impl` in the impl name."
msgstr ""
"> 注意：为避免混淆嵌入的名称和 impl 名称，我们\n"
"> 建议在 impl 名称中保留后缀“Impl”。"

#: src/ch99-01-05-00-components.md:210
msgid "## Migrating a Contract to a Component"
msgstr "## 将合约迁移到组件"

#: src/ch99-01-05-00-components.md:212
msgid ""
"Since both contracts and components share a lot of similarities, it's actually\n"
"very easy to migrate from a contract to a component. The only changes required\n"
"are:"
msgstr ""
"由于合约和组件有很多相似之处，因此实际上\n"
"从合约迁移到组件非常容易。唯一需要的更改\n"
"是："

#: src/ch99-01-05-00-components.md:216
msgid ""
"- Adding the `#[starknet::component]` attribute to the module.\n"
"- Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will be\n"
"  embedded in another contract.\n"
"- Adding generic parameters to the `impl` block:\n"
"  - Adding `TContractState` as a generic parameter.\n"
"  - Adding `+HasComponent<TContractState>` as an impl restriction.\n"
"- Changing the type of the `self` argument in the functions inside the `impl`\n"
"  block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""
"-  将 `#[starknet::component]` 属性添加到模块中。\n"
"-  将 `#[embeddable_as(name)]` 属性添加到 `impl` 块中，该块将嵌入到另一个合约中。\n"
"-  将泛型参数添加到`impl`块：\n"
"  -  添加 'TContractState' 作为泛型参数。\n"
"  -  添加 ·+HasComponent<TContractState>· 作为 impl 限制。\n"
"-  在`impl`块的函数中更改`self`参数的类型，\n"
"  设置为`ComponentState<TContractState>`用以取代`ContractState`。"

#: src/ch99-01-05-00-components.md:225
msgid ""
"For traits that do not have an explicit definition and are generated using\n"
"`#[generate_trait]`, the logic is the same - but the trait is generic over\n"
"`TContractState` instead of `ComponentState<TContractState>`, as demonstrated in\n"
"the example with the `InternalTrait`."
msgstr ""
"对于那些没有明确定义且使用\n"
"`#[generate_trait]`的trait，逻辑是相同的 - \n"
"但这些trait是`TContractState`而不是`ComponentState<TContractState>`的泛型，\n"
"如上面例子中就带有`InternalTrait`。"

#: src/ch99-01-05-00-components.md:230
msgid "## Using components inside a contract"
msgstr "## 在合约中使用组件"

#: src/ch99-01-05-00-components.md:232
msgid ""
"The major strength of components is how it allows reusing already built\n"
"primitives inside your contracts with a restricted amount of boilerplate. To\n"
"integrate a component into your contract, you need to:"
msgstr ""
"组件的主要优势在于它允许你在合约中的重复使用已经构建的组件原语，\n"
"且只需要相当少的模版代码。\n"
"将组件集成到您的合约中，您需要："

#: src/ch99-01-05-00-components.md:236
msgid ""
"1. Declare it with the `component!()` macro, specifying\n"
"\n"
"   1. The path to the component `path::to::component`.\n"
"   2. The name of the variable in your contract's storage referring to this\n"
"      component's storage (e.g. `ownable`).\n"
"   3. The name of the variant in your contract's event enum referring to this\n"
"      component's events (e.g. `OwnableEvent`).\n"
"\n"
"2. Add the path to the component's storage and events to the contract's\n"
"   `Storage` and `Event`. They must match the names provided in step 1 (e.g.\n"
"   `ownable: ownable_component::Storage` and `OwnableEvent:\n"
"ownable_component::Event`).\n"
"\n"
"   The storage variable **MUST** be annotated with the `#[substorage(v0)]`\n"
"   attribute.\n"
"\n"
"3. Embed the component's logic defined inside your contract, by instantiating\n"
"   the component's generic impl with a concrete `ContractState` using an impl\n"
"   alias. This alias must be annotated with `#[abi(embed_v0)]` to externally\n"
"   expose the component's functions.\n"
"\n"
"   As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`.\n"
"   Indeed, we don't want to expose externally the functions defined in this\n"
"   impl. However, we might still want to access them internally."
msgstr ""
"1. 用 `component!()` 宏，指定\n"
"\n"
"   1. 组件的路径 `path::to::component` 。\n"
"   2. 合约存储中变量的名称，引用此\n"
"      组件的存储（例如`ownable`）。\n"
"   3. 合约事件枚举中变体的名称，引用此\n"
"      组件的事件（例如`OwnableEvent`）。\n"
"\n"
"2. 将组件存储的路径和事件添加到合约的\n"
"   `Storage` 与 `Event`中。它们必须与步骤 1 中提供的名称匹配（例如\n"
"   `ownable: ownable_component::Storage` and `OwnableEvent:\n"
"ownable_component::Event`）。\n"
"\n"
"   存储变量 **必须** 用 `#[substorage(v0)]`属性进行标注\n"
"\n"
"3. 要将组件的逻辑嵌入到合约中，\n"
"   可以通过使用了impl别名的一个具体的 `ContractState`，\n"
"   来实例化一个组件的泛型 impl 。\n"
"   此别名必须用 `#[abi(embed_v0)]`标注，来将组件函数暴露给外部。\n"
"\n"
"   如您所见，内部impl 未标有 `#[abi(embed_v0)]`。\n"
"   事实上，我们不想从外部公开该impl其中定义的函数\n"
"   但是，我们可能仍希望在内部访问它们。"

#: src/ch99-01-05-00-components.md:261
msgid "<!-- TODO: Add content on impl aliases -->"
msgstr "<!-- TODO: Add content on impl aliases -->"

#: src/ch99-01-05-00-components.md:263
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the\n"
"following:"
msgstr "例如，要嵌入上面定义的`Ownable` 组件，我们将执行："

#: src/ch99-01-05-00-components.md:266
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod OwnableCounter {\n"
"    use listing_01_ownable::component::ownable_component;\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        counter: u128,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"\n"
"    #[external(v0)]\n"
"    fn foo(ref self: ContractState) {\n"
"        self.ownable.assert_only_owner();\n"
"        self.counter.write(self.counter.read() + 1);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod OwnableCounter {\n"
"    use listing_01_ownable::component::ownable_component;\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        counter: u128,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"\n"
"    #[external(v0)]\n"
"    fn foo(ref self: ContractState) {\n"
"        self.ownable.assert_only_owner();\n"
"        self.counter.write(self.counter.read() + 1);\n"
"    }\n"
"}\n"
"```"

#: src/ch99-01-05-00-components.md:301
msgid ""
"The component's logic is now seamlessly part of the contract! We can interact\n"
"with the components functions externally by calling them using the\n"
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""
"组件的逻辑现在无缝地成为合约的一部分！\n"
"我们可以通过随着合约实例化的`IOwnableDispatcher`\n"
"与组件函数互动。"

#: src/ch99-01-05-00-components.md:314
msgid "## Stacking Components for Maximum Composability"
msgstr "## 堆叠组件以实现最大的可组合性"

#: src/ch99-01-05-00-components.md:316
msgid ""
"The composability of components really shines when combining multiple of them\n"
"together. Each adds its features onto the contract. You will be able to rely on\n"
"[Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) future\n"
"implementation of components to quickly plug-in all the common functionalities\n"
"you need a contract to have."
msgstr ""
"当组合多个组件时，组件的可组合性将大放异彩。\n"
"每个组件都将其功能添加到合约中。\n"
"以后您将可以通过依赖 [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) 的\n"
"组件实现以快速插入你所需的合约所有常用功能。"

#: src/ch99-01-05-00-components.md:322
msgid ""
"Developers can focus on their core contract logic while relying on battle-tested\n"
"and audited components for everything else."
msgstr ""
"开发人员可以专注于他们的核心合约逻辑，\n"
"同时在其他部分依靠经过实战考验的逻辑并经过审核的组件。"

#: src/ch99-01-05-00-components.md:325
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on other components by restricting the\n"
"`TContractstate` they're generic on to implement the trait of another component.\n"
"Before we dive into this mechanism, let's first look at [how components work\n"
"under the hood](./ch99-01-05-01-components-under-the-hood)."
msgstr ""
"组件甚至可以 [依赖](./ch99-01-05-02-component-dependencies.md) 其他组件，\n"
"只要另一个组件通过了`TContractstate`这个泛型。\n"
"在我们深入研究这个机制之前，让我们先看看[深入理解组件如何工作](./ch99-01-05-01-components-under-the-hood)。"

#: src/ch99-01-05-00-components.md:330
msgid "## Troubleshooting"
msgstr "## 疑难解答"

#: src/ch99-01-05-00-components.md:332
msgid ""
"You might encounter some errors when trying to implement components.\n"
"Unfortunately, some of them lack meaningful error messages to help debug. This\n"
"section aims to provide you with some pointers to help you debug your code."
msgstr ""
"尝试实现组件时可能会遇到一些错误。\n"
"不幸的是，其中一些错误缺少有意义的错误消息来帮助调试。\n"
"这部分旨在为您提供一些指导来帮助您调试代码。"

#: src/ch99-01-05-00-components.md:336
msgid ""
"- `Trait not found. Not a trait.`\n"
"\n"
"  This error can occur when you're not importing the component's impl block\n"
"  correctly in your contract. Make sure to respect the following syntax:\n"
"\n"
"  ```rust\n"
"  #[abi(embed_v0)]\n"
"  impl IMPL_NAME = upgradeable::EMBEDDED_NAME<ContractState>\n"
"  ```\n"
"\n"
"  Referring to our previous example, this would be:\n"
"\n"
"  ```rust\n"
"  #[abi(embed_v0)]\n"
"  impl OwnableImpl = upgradeable::Ownable<ContractState>\n"
"  ```\n"
"\n"
"- `Plugin diagnostic: name is not a substorage member in the contract's Storage.\n"
"Consider adding to Storage: (...)`\n"
"\n"
"  The compiler helps you a lot debugging this by giving you recommendation on\n"
"  the action to take. Basically, you forgot to add the component's storage to\n"
"  your contract's storage. Make sure to add the path to the component's storage\n"
"  annotated with the `#[substorage(v0)]` attribute to your contract's storage.\n"
"\n"
"- `Plugin diagnostic: name is not a nested event in the contract's Event enum.\n"
"Consider adding to the Event enum:`\n"
"\n"
"  Similar to the previous error, the compiler, you forgot to add the component's\n"
"  events to your contract's events. Make sure to add the path to the component's\n"
"  events to your contract's events.\n"
"\n"
"- Components functions are not accessible externally\n"
"\n"
"  This can happen if you forgot to annotate the component's impl block with\n"
"  `#[abi(embed_v0)]`. Make sure to add this annotation when embedding the\n"
"  component's impl in your contract."
msgstr ""
"- `Trait not found. Not a trait.`\n"
"\n"
"  当您未正确的在合约中导入组件的 impl 块时，\n"
"  可能会发生此错误。请确保遵循了以下语法：\n"
"\n"
" ```rust\n"
"  #[abi(embed_v0)]\n"
"  impl IMPL_NAME = upgradeable::EMBEDDED_NAME<ContractState>\n"
"  ```\n"
"\n"
"参考我们之前的示例，这里应该写成：\n"
"\n"
" ```rust\n"
"  #[abi(embed_v0)]\n"
"  impl OwnableImpl = upgradeable::Ownable<ContractState>\n"
"  ```\n"
"\n"
"- `Plugin diagnostic: name is not a substorage member in the contract's Storage.\n"
"Consider adding to Storage: (...)`\n"
"\n"
"  在您调试时，编译器给出的建议操作能够起到很大的作用。\n"
"  基本上，这条错误表示您忘记将组件的存储添加到\n"
"  合约的存储中。使用`#[substorage(v0)]`属性标注，\n"
"  确保将其添加到到合约的存储中。\n"
"\n"
"- `Plugin diagnostic: name is not a nested event in the contract's Event enum.\n"
"Consider adding to the Event enum:`\n"
"\n"
"  与前面的错误类似，编译器提醒您忘记添加组件的\n"
"  事件到合约的事件中。确保将组件事件路径添加到合约的事件中。\n"
"\n"
"- Components functions are not accessible externally\n"
"\n"
"  这会发生在您忘了使用`#[abi(embed_v0)]`来标注impl块时。\n"
"  请确保在嵌入组件时在合约的impl块上用此标注。"

#: src/ch99-01-05-00-components.md:374
msgid "<footer id=\"last-change\">Last change: 2023-10-12</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-12</footer>"

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "# Components under the hood"
msgstr "# 深入了解组件"

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does this\n"
"magic actually happen behind the scenes?"
msgstr "组件为 Starknet 合约提供了强大的模块化。但在这个魔术的背后是什么原理呢？"

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the\n"
"mechanisms that enable component composability."
msgstr ""
"本章将深入探讨编译器的内部结构，以解释\n"
"实现组件可组合性的机制。"

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "## A Primer on Embeddable Impls"
msgstr "## 嵌入式实现入门"

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid "Before digging into components, we need to understand _embeddable impls_."
msgstr "在深入研究组件之前，我们需要了解 _embeddable impls_ 。"

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) can\n"
"be made embeddable. Embeddable impls can be injected into any contract, adding\n"
"new entry points and modifying the ABI of the contract."
msgstr ""
"一个实现了Starknet 接口trait（标有`#[starknet::interface]`）的impl是可嵌入的。\n"
"可嵌入的impl可以注入到任何合约中，这会添加新的入口点以及改变合约的 ABI。"

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "让我们看一个示例来看看这个实际运作的过程："

#: src/ch99-01-05-01-components-under-the-hood.md:19
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait SimpleTrait<TContractState> {\n"
"    fn ret_4(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::embeddable]\n"
"impl SimpleImpl<TContractState> of SimpleTrait<TContractState> {\n"
"    fn ret_4(self: @TContractState) -> u8 {\n"
"        4\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod simple_contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl MySimpleImpl = super::SimpleImpl<ContractState>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait SimpleTrait<TContractState> {\n"
"    fn ret_4(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::embeddable]\n"
"impl SimpleImpl<TContractState> of SimpleTrait<TContractState> {\n"
"    fn ret_4(self: @TContractState) -> u8 {\n"
"        4\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod simple_contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl MySimpleImpl = super::SimpleImpl<ContractState>;\n"
"}\n"
"```"

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid "By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr "通过嵌入 `SimpleImpl`，我们在合约的 ABI 中向外部公开 `ret4` 。"

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see how\n"
"components build on this."
msgstr "现在我们对嵌入机制更加熟悉了，我们可以看到组件如何在此基础上构建。"

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "## Inside Components: Generic Impls"
msgstr "## 内部组件：泛型实现"

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "回想一下组件中使用的 impl 块的语法："

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr "关键点："

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"- `OwnableImpl` requires the implementation of the\n"
"  `HasComponent<TContractState>` trait by the underlying contract, which is\n"
"  automatically generated with the `component!()` macro when using a component\n"
"  inside a contract.\n"
"\n"
"  The compiler will generate an impl that wraps any function in `OwnableImpl`,\n"
"  replacing the `self: ComponentState<TContractState>` argument with `self:\n"
"TContractState`, where access to the component state is made via the\n"
"  `get_component` function in the `HasComponent<TContractState>` trait.\n"
"\n"
"  For each component, the compiler generates a `HasComponent` trait. This trait\n"
"  defines the interface to bridge between the actual `TContractState` of a\n"
"  generic contract, and `ComponentState<TContractState>`.\n"
"\n"
"  ```rust\n"
"  // generated per component\n"
"  trait HasComponent<TContractState> {\n"
"      fn get_component(self: @TContractState) -> @ComponentState<TContractState>;\n"
"      fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;\n"
"      fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;\n"
"      fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;\n"
"      fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);\n"
"  }\n"
"  ```\n"
"\n"
"  In our context `ComponentState<TContractState>` is a type specific to the\n"
"  ownable component, i.e. it has members based on the storage variables defined\n"
"  in `ownable_component::Storage`. Moving from the generic `TContractState` to\n"
"  `ComponentState<TContractState>` will allow us to embed `Ownable` in any\n"
"  contract that wants to use it. The opposite direction\n"
"  (`ComponentState<TContractState>` to `ContractState`) is useful for\n"
"  dependencies (see the `Upgradeable` component depending on an `IOwnable`\n"
"  implementation example in the [Components dependencies ](./ch99-01-05-02-component-dependencies.md) section.\n"
"\n"
"  To put it briefly, one should think of an implementation of the above\n"
"  `HasComponent<T>` as saying: **“Contract whose state T has the upgradeable\n"
"  component”.**\n"
"\n"
"- `Ownable` is annotated with the `embeddable_as(<name>)` attribute:\n"
"\n"
"  `embeddable_as` is similar to `embeddable`; it only applies to `impls` of\n"
"  `starknet::interface` traits and allows embedding this impl in a contract\n"
"  module. That said, `embeddable_as(<name>)` has another role in the context of\n"
"  components. Eventually, when embedding `OwnableImpl` in some contract, we\n"
"  expect to get an impl with the following functions:\n"
"\n"
"  ```rust\n"
"      fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"  ```\n"
"\n"
"  Note that while starting with a function receiving the generic type\n"
"  `ComponentState<TContractState>`, we want to end up with a function receiving\n"
"  `ContractState`. This is where `embeddable_as(<name>)` comes in. To see the\n"
"  full picture, we need to see what is the impl generated by the compiler due to\n"
"  the `embeddable_as(Ownable)` annotation:\n"
"\n"
"  ```rust\n"
"  #[starknet::embeddable]\n"
"  impl Ownable<\n"
"            TContractState, +HasComponent<TContractState>\n"
"  , impl TContractStateDrop: Drop<TContractState>\n"
"  > of super::IOwnable<TContractState> {\n"
"\n"
"    fn owner(self: @TContractState) -> ContractAddress {\n"
"        let component = HasComponent::get_component(self);\n"
"        OwnableImpl::owner(component, )\n"
"    }\n"
"\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress\n"
"  ) {\n"
"        let mut component = HasComponent::get_component_mut(ref self);\n"
"        OwnableImpl::transfer_ownership(ref component, new_owner, )\n"
"    }\n"
"\n"
"    fn renounce_ownership(ref self: TContractState) {\n"
"        let mut component = HasComponent::get_component_mut(ref self);\n"
"        OwnableImpl::renounce_ownership(ref component, )\n"
"    }\n"
"  }\n"
"  ```\n"
"\n"
"  Note that thanks to having an impl of `HasComponent<TContractState>`, the\n"
"  compiler was able to wrap our functions in a new impl that doesn’t directly\n"
"  know about the `ComponentState` type. `Ownable`, whose name we chose when\n"
"  writing `embeddable_as(Ownable)`, is the impl that we will embed in a contract\n"
"  that wants ownership."
msgstr ""
"- `OwnableImpl` 要求底层合约实现`HasComponent<TContractState>` trait。\n"
"  这个trait在合约中使用组件的时候，会由`component!()`宏自动生成。\n"
"\n"
"  编译器将生成一个封装 `OwnableImpl` 中任何函数的 impl、\n"
"  用`self:TContractState`替换掉中的 `self: ComponentState<TContractState>`参数，其中对组件状态的访问是通过\n"
"  `HasComponent<TContractState>` trait中的 `get_component` 函数来进行的。\n"
"\n"
"  编译器会为每个组件生成一个 `HasComponent` trait。该trait\n"
"  定义了连接泛型合约与实际 `TContractState` 和 `ComponentState<TContractState>` 之间的接口。\n"
"\n"
"  ```rust\n"
"  // generated per component\n"
"  trait HasComponent<TContractState> {\n"
"      fn get_component(self: @TContractState) -> @ComponentState<TContractState>;\n"
"      fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;\n"
"      fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;\n"
"      fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;\n"
"      fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);\n"
"  }\n"
"  ```\n"
"\n"
"  在我们的上下文中，`ComponentState<TContractState>` 是一个特定的ownable组件的类型。\n"
"  它拥有着基于`ownable_component::Storage`定义的变量成员。\n"
"  从泛型`TContractState`转移到`ComponentState<TContractState>` 使得我们可以将\n"
"  `Ownable` 嵌入任意合约。反方向的转移（即`ComponentState<TContractState>` 转移到 `ContractState`）对于外部依赖是很有用的。\n"
"  详细可见[组件依赖 ](./ch99-01-05-02-component-dependencies.md)章节中的依赖于一个`IOwnable`实现的`Upgradeable`组件的例子。\n"
"\n"
"  简而言之，我们应该考虑上述\n"
"  `HasComponent<T>` 的实现： **\"合约的状态 T 具有可升级组件\"。**\n"
"\n"
"- `Ownable`被标注为 `embeddable_as(<name>)`属性：\n"
"\n"
"  `embeddable_as`与 `embeddable`类似；它只适用于 `starknet::interface` trait的 \"impls\",\n"
"  并允许将这个impl嵌入一个合约模块。也就是说，`embeddable_as(<name>)`在组件的上下文中还有另一个作用。\n"
"  最终，当在某个契约中嵌入 `OwnableImpl` 时，我们希望得到一个具有以下函数的 impl：\n"
"\n"
"  ```rust\n"
"      fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"  ```\n"
"\n"
"  请注意，在开始使用函数接收泛型\n"
"  `ComponentState<TContractState>`时，我们期望的是一个接受`ContractState`的函数。\n"
"  这就是 `embeddable_as(<name>)` 的用武之地。要了解全景，\n"
"  我们需要知道编译器为`embeddable_as(Ownable)`注解生成的 impl 是什么：\n"
"\n"
"  ```rust\n"
"  #[starknet::embeddable]\n"
"  impl Ownable<\n"
"            TContractState, +HasComponent<TContractState>\n"
"  , impl TContractStateDrop: Drop<TContractState>\n"
"  > of super::IOwnable<TContractState> {\n"
"\n"
"    fn owner(self: @TContractState) -> ContractAddress {\n"
"        let component = HasComponent::get_component(self);\n"
"        OwnableImpl::owner(component, )\n"
"    }\n"
"\n"
"    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress\n"
"  ) {\n"
"        let mut component = HasComponent::get_component_mut(ref self);\n"
"        OwnableImpl::transfer_ownership(ref component, new_owner, )\n"
"    }\n"
"\n"
"    fn renounce_ownership(ref self: TContractState) {\n"
"        let mut component = HasComponent::get_component_mut(ref self);\n"
"        OwnableImpl::renounce_ownership(ref component, )\n"
"    }\n"
"  }\n"
"  ```\n"
"\n"
"  请注意，由于有了`HasComponent<TContractState>`的impl，\n"
"  编译器才能够将我们的函数封装在一个不需要直接知道`ComponentState`的新的impl中。\n"
"  在合约中写上`embeddable_as(Ownable)`时，就意味着`Ownable`将是被嵌入合约中来实现所有权功能的impl。"

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "## Contract Integration"
msgstr "## 合约集成"

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see how a\n"
"contract integrates a component."
msgstr "我们已经了解了泛型impl如何实现组件的可重用性。接下来，让我们看看合约是如何集成组件的。"

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic impl\n"
"with the concrete `ContractState` of the contract."
msgstr ""
"合约使用 **impl alias** 来实例化组件的泛型 impl\n"
"替换为该合约的具体`ContractState`。"

#: src/ch99-01-05-01-components-under-the-hood.md:157
msgid ""
"```rust\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"```"
msgstr ""
"```rust\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"```"

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl alias\n"
"syntax. We’re instantiating the generic `OwnableImpl<TContractState>` with the\n"
"concrete type `ContractState`. Recall that `OwnableImpl<TContractState>` has the\n"
"`HasComponent<TContractState>` generic impl parameter. An implementation of this\n"
"trait is generated by the `component!` macro."
msgstr ""
"上面的代码使用了 Cairo impl 嵌入机制和 impl 别名语法。\n"
"我们正在用具体类型的`ContractState`来实例化泛型 `OwnableImpl<TContractState>`\n"
"回想一下，`OwnableImpl<TContractState>` 具有`HasComponent<TContractState>`泛型 impl 参数。\n"
"此实现的trait 由 `component!` 宏生成。"

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract\n"
"could have implemented this trait since only it knows about both the contract\n"
"state and the component state."
msgstr ""
"请注意，这只可以使用在可以实现这个trati的合约上，\n"
"因为只有这种合约知晓合约state 和组件 state。"

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid "This glues everything together to inject the component logic into the contract."
msgstr "这会将所有内容粘合在一起，以将组件逻辑注入到合约中。"

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "## Key Takeaways"
msgstr "## 关键要点"

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"- Embeddable impls allow injecting components logic into contracts by adding\n"
"  entry points and modifying the contract ABI.\n"
"- The compiler automatically generates a `HasComponent` trait implementation\n"
"  when a component is used in a contract. This creates a bridge between the\n"
"  contract's state and the component's state, enabling interaction between the\n"
"  two.\n"
"- Components encapsulate reusable logic in a generic, contract-agnostic way.\n"
"  Contracts integrate components through impl aliases and access them via the\n"
"  generated `HasComponent` trait.\n"
"- Components build on embeddable impls by defining generic component logic that\n"
"  can be integrated into any contract wanting to use that component. Impl\n"
"  aliases instantiate these generic impls with the contract's concrete storage\n"
"  types."
msgstr ""
"- 可嵌入的实现允许通过组件注入来添加入口点和改变合约 ABI。\n"
"- 档组件被用于合约中时，编译器会自动生成`HasComponent` tarit实现\n"
"  这在合约状态和组件状态搭了一座桥，以实现双方互动。\n"
"- 组件以通用的、与合约无关的方式封装可重用的逻辑。\n"
"  合约通过 impl 别名集成组件，并通过生成的`HasComponent` trait来访问组件。\n"
"- 组件基于可嵌入的实现构建，通过定义通用组件逻辑\n"
"  可以集成到任何想要使用该组件的合约中。\n"
"  实现别名使用合约的具体存储来实例化这些泛型实现类型。"

#: src/ch99-01-05-02-component-dependencies.md:1
msgid "# Component dependencies"
msgstr "# 组件依赖"

#: src/ch99-01-05-02-component-dependencies.md:3 src/ch99-01-05-03-testing-components.md:3
msgid "<footer id=\"last-change\">Last change: 2023-10-11</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-11</footer>"

#: src/ch99-01-05-03-testing-components.md:1
msgid "# Testing components"
msgstr "# 测试组件"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "# Starknet contracts: ABIs and cross-contract interactions"
msgstr "# Starknet合约：ABI和跨合约交互"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating complex decentralized applications, as it allows for composability and separation of concerns. This "
"chapter sheds light on how to make contracts interact with each other."
msgstr "在创建复杂的去中心化应用程序时，智能合约之间的交互是一项重要功能，因为它可以实现可组合性和关注点分离。本章将介绍如何实现合约之间的交互。"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid "Specifically, you'll learn about ABIs, contract interfaces, the contract and library dispatchers and their low-level system call equivalents!"
msgstr "具体来说，您将了解 ABI、合约接口、合约和库调度程序及其与底层系统调用等同程序！"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:7
msgid "<footer id=\"last-change\">Last change: 2023-07-22</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-07-22</footer>"

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "# ABIs and Contract Interfaces"
msgstr "# ABI和合约接口"

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid "Cross-contract interactions between smart contracts on a blockchain is a common practice which enables us to build flexible contracts that can speak with each other."
msgstr "区块链上的智能合约之间的跨合约互动是一种常见的做法，它使我们能够建立灵活的合约，相互对话。"

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "在Starknet上实现这一点需要我们称之为接口的东西。"

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "## ABI - Application Binary Interface"
msgstr "## ABI - 应用二进制接口"

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the contract's functions and structures, giving anyone (or any other contract) the ability to form encoded calls to it. "
"It is a blueprint that instructs how functions should be called, what input parameters they expect, and in what format."
msgstr "在Starknet上，合约的 ABI 是合约函数和结构的 JSON 表示，使任何人（或任何其他合约）都能对其进行编码调用。它是一个蓝图，指示如何调用函数、以及它们所需的输入参数和格式。"

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are stored on the VM as executable bytecodes which are in binary formats. Since this bytecode is not human "
"readable, it requires interpretation to be understood. This is where ABIs come into play, defining specific methods which can be called to a smart contract for execution. Without an "
"ABI, it becomes practically impossible for external actors to understand how to interact with a contract."
msgstr ""
"虽然我们用高级Cairo语言编写智能合约逻辑，但它们在虚拟机上存储为二进制格式的可执行字节码。由于这种字节码不是人类可读的，因此需要解释才能理解。这就是 ABI 的作用所在，它定义了可以调用智"
"能合约执行的特定方法。如果没有 ABI，外部参与者几乎不可能理解如何与合约交互。"

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data correctly, making it understandable by the smart contract and vice versa. When you interact with a smart "
"contract through a block explorer like [Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), they use the contract's ABI to format the data you send to the "
"contract and the data it returns."
msgstr ""
"ABI 通常用于 dApps 前端，使其能够正确格式化数据，使智能合约能够理解数据，反之亦然。当你通过 [Voyager](https://voyager.online/) 或 [Starkscan](https://starkscan.co/) 等区块资源管理器与"
"智能合约交互时，它们会使用合约的 ABI 来格式化你发送给合约的数据以及合约返回的数据。"

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "## Interface"
msgstr "## 接口"

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly.\n"
"It specifies the function signatures (name, parameters, visibility and return value) contained in a smart contract without including the function body."
msgstr ""
"合约的接口是它公开的函数列表。\n"
"它指定了智能合约中包含的函数签名（名称、参数、可见性和返回值），但不包括函数体。"

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the `#[starknet::interface]` attribute. If you are new to traits, check out the dedicated chapter on [traits](./ch08-02-traits-"
"in-cairo.md)."
msgstr "在Cairo中，合约接口是用 `#[starknet::interface]` 属性注解的 traits。如果你对 traits 还不熟悉，请查看专门介绍 [traits](./ch08-02-traits-in-cairo.md) 的章节。"

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the `TContractState` type. This is required for functions to access the contract's storage, so that they can read "
"and write to it."
msgstr "一个重要的规范是，该trait必须是基于 `TContractState` 类型的泛型。函数访问想要合约存储空间必须基于此trait，这样函数才能读写合约。"

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid "> Note: The contract constructor is not part of the interface. Nor are internal functions part of the interface."
msgstr "> 注意：合约的构造函数不是接口的一部分。内部函数也不是接口的一部分。"

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's a generic trait over the `TContractState` type. `view` functions have a self parameter of type "
"`@TContractState`, while `external` functions have a self parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"下面是 ERC20 代币合约的接口示例。正如您所看到的，它是在 `TContractState` 类型上的泛型trait。`view`函数有一个类型为`@TContractState`的自参数，而 `external` 函数有一个类型为 `ref self: "
"TContractState`.的自参数。"

#: src/ch99-02-01-abis-and-interfaces.md:28
msgid ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"```"

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "<span class=\"caption\">Listing 99-4: A simple ERC20 Interface</span>"
msgstr "<span class=\"caption\">示例99-4：一个简单的ERC20接口</span>"

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid "In the next chapter, we will see how we can call contracts from other smart contracts using _dispatchers_ and _syscalls_ ."
msgstr "在下一章，我们将研究如何使用  合约调度器 (  _dispatchers_  )、和 系统调用( _syscalls_ ) 来调用其他智能合约。"

#: src/ch99-02-01-abis-and-interfaces.md:59
msgid "<footer id=\"last-change\">Last change: 2023-11-15</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-15</footer>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid "# Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr "# 使用调度程序和系统调用与其他合约和类交互"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically created and exported by the compiler. Let's consider an interface that we named IERC20, these would be:"
msgstr "每次定义合约接口时，编译器都会自动创建并导出两个调度程序。我们将一个接口命名为 IERC20，它们是："

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid ""
"1. The Contract Dispatcher `IERC20Dispatcher`\n"
"2. The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""
"1. 合约调度器 `IERC20Dispatcher`\n"
"2. 库调度器 `IERC20LibraryDispatcher`"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid "The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to call the functions defined in the interface on the dispatcher struct."
msgstr "编译器还会生成一个名为 \"IERC20DispatcherTrait\"的trait，这使得我们可以在调度器结构上调用接口中定义的函数。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid "In this chapter, we are going to discuss what these are, how they work and how to use them."
msgstr "在本章中，我们将讨论它们是什么、如何工作以及如何使用。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid "To effectively break down the concepts in this chapter, we are going to be using the IERC20 interface from the previous chapter (refer to Listing 99-4):"
msgstr "为了有效地拆解本章的概念，我们将使用前一章的IERC20接口（参考示例99-4）："

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "## Contract Dispatcher"
msgstr "## 合约调度器"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` attribute automatically generate a dispatcher and a trait on compilation.\n"
"Our `IERC20` interface is expanded into something like this:"
msgstr ""
"如前所述，使用 `#[starknet::interface]` 属性注释的trait会在编译时自动生成一个调度器和一个trait。\n"
"我们的  `IERC20` 接口扩展至如下："

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to keep this chapter concise and straight to the point, we focused on one view function `name`, and one "
"external function `transfer`."
msgstr "**注：** IERC20 界面的扩展代码较长，但为了使本章简明扼要，我们将重点放在一个视图函数 `name` 和一个外部函数 `transfer`上。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:21
msgid ""
"```rust,noplayground\n"
"use starknet::{ContractAddress};\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: ContractAddress,\n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
"    fn name(\n"
"        self: IERC20Dispatcher\n"
"    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use starknet::{ContractAddress};\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: ContractAddress,\n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
"    fn name(\n"
"        self: IERC20Dispatcher\n"
"    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "<span class=\"caption\">Listing 99-5: An expanded form of the IERC20 trait</span>"
msgstr "<span class=\"caption\">示例99-5：IERC20 trait的扩展</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a contract address and implements the `DispatcherTrait` generated by the compiler, allowing us to call "
"functions from another contract. This means that we can instantiate a struct with the address of the contract we want to call, and then simply call the functions defined in the "
"interface on the dispatcher struct as if they were methods of that type."
msgstr ""
"如你所见，\"典型\"的调度器只是一个结构体，它封装了一个合约地址，并实现了编译器生成的 `DispatcherTrait`，允许我们调用另一个合约的函数。这意味着我们可以用要调用的合约地址实例化一个结构"
"体，然后简单地调用调度器结构体上的接口定义的函数，就像调用该类型的方法一样。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid "It's also worthy of note that all these are abstracted behind the scenes thanks to the power of Cairo plugins."
msgstr "而且值得注意的是，所有这些都被Cairo插件在幕后抽象化了。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "### Calling Contracts using the Contract Dispatcher"
msgstr "### 使用合约调度器调用合约"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to call functions defined on an ERC-20 token. Calling `transfer_token` will modify the state of the contract "
"deployed at `contract_address`."
msgstr "这是一个名为 `TokenWrapper` 的合约使用调度器调用定义在 ERC-20 令牌上的函数的示例。调用 `transfer_token` 将修改部署在 `contract_address` 的合约状态。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:56
msgid ""
"```rust,noplayground\n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait IERC20<TContractState> {\n"
"#     fn name(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn symbol(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn decimals(self: @TContractState) -> u8;\n"
"# \n"
"#     fn total_supply(self: @TContractState) -> u256;\n"
"# \n"
"#     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"# \n"
"#     fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"# \n"
"#     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"# \n"
"#     fn transfer_from(\n"
"#         ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"#     ) -> bool;\n"
"# \n"
"#     fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;\n"
"# }\n"
"# \n"
"# #[starknet::interface]\n"
"# trait ITokenWrapper<TContractState> {\n"
"#     fn token_name(self: @TContractState, contract_address: ContractAddress) -> felt252;\n"
"# \n"
"#     fn transfer_token(\n"
"#         ref self: TContractState,\n"
"#         contract_address: ContractAddress,\n"
"#         recipient: ContractAddress,\n"
"#         amount: u256\n"
"#     ) -> bool;\n"
"# }\n"
"# \n"
"# \n"
"//**** Specify interface here ****//\n"
"#[starknet::contract]\n"
"mod TokenWrapper {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use super::ITokenWrapper;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
"        fn token_name(self: @ContractState, contract_address: ContractAddress) -> felt252 {\n"
"            IERC20Dispatcher { contract_address }.name()\n"
"        }\n"
"\n"
"        fn transfer_token(\n"
"            ref self: ContractState,\n"
"            contract_address: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) -> bool {\n"
"            IERC20Dispatcher { contract_address }.transfer(recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust,noplayground\n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait IERC20<TContractState> {\n"
"#     fn name(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn symbol(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn decimals(self: @TContractState) -> u8;\n"
"# \n"
"#     fn total_supply(self: @TContractState) -> u256;\n"
"# \n"
"#     fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"# \n"
"#     fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"# \n"
"#     fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"# \n"
"#     fn transfer_from(\n"
"#         ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"#     ) -> bool;\n"
"# \n"
"#     fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;\n"
"# }\n"
"# \n"
"# #[starknet::interface]\n"
"# trait ITokenWrapper<TContractState> {\n"
"#     fn token_name(self: @TContractState, contract_address: ContractAddress) -> felt252;\n"
"# \n"
"#     fn transfer_token(\n"
"#         ref self: TContractState,\n"
"#         contract_address: ContractAddress,\n"
"#         recipient: ContractAddress,\n"
"#         amount: u256\n"
"#     ) -> bool;\n"
"# }\n"
"# \n"
"# \n"
"//**** Specify interface here ****//\n"
"#[starknet::contract]\n"
"mod TokenWrapper {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use super::ITokenWrapper;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
"        fn token_name(self: @ContractState, contract_address: ContractAddress) -> felt252 {\n"
"            IERC20Dispatcher { contract_address }.name()\n"
"        }\n"
"\n"
"        fn transfer_token(\n"
"            ref self: ContractState,\n"
"            contract_address: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) -> bool {\n"
"            IERC20Dispatcher { contract_address }.transfer(recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "<span class=\"caption\">Listing 99-6: A sample contract which uses the Contract Dispatcher</span>"
msgstr "<span class=\"caption\">示例99-6：一个使用合约调度器的样本合约</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and `IERC20Dispatcher` generated by the compiler, which allows us to make calls to the methods implemented for the "
"`IERC20Dispatcher` struct (`name`, `transfer`, etc), passing in the `contract_address` of the contract we want to call in the `IERC20Dispatcher` struct."
msgstr ""
"正如您所看到的，我们必须首先导入编译器生成的 `IERC20DispatcherTrait` 和 `IERC20Dispatcher`，这样我们就可以调用为 `IERC20Dispatcher` 结构实现的方法（`name`、`transfer` 等），并在 "
"`IERC20Dispatcher` 结构中传入我们要调用的合约的 `contract_address` 。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "## Library Dispatcher"
msgstr "## 库调度器"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library dispatcher lies in the execution context of the logic defined in the class. While regular dispatchers are used to "
"call functions from **contracts** (with an associated state), library dispatchers are used to call **classes** (stateless)."
msgstr "合约调度器和库调度器的主要区别在于类中定义的逻辑的执行上下文。普通调度程序用于调用来自 **合约**（有相关状态）的函数，而库调度程序则用于调用 **类**（无状态）。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "让我们设想两个合约 A 和 B。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the execution context of the logic defined in B is that of B. This means that the value returned by "
"`get_caller_address()` in B will return the address of A, and updating a storage variable in B will update the storage of B."
msgstr ""
"当A使用 `IBDispatcher` 来调用 **合约** B中的函数时，定义在B中的逻辑的执行上下文是B的。这意味着在B中由`get_caller_address()`返回的值将返回A的地址，并且在B中更新存储变量将更新B的存储。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, the execution context of the logic defined in B's class is that of A. This means that the value returned "
"by `get_caller_address()` variable in B will return the address of the caller of A, and updating a storage variable in B's class will update the storage of A (remember that the "
"**class** of B is stateless; there is no state that can be updated!)"
msgstr ""
"当A使用 `IBLibraryDispatcher` 来调用B的 **类** 中的函数时，定义在B类中的逻辑的执行上下文是A的。这意味着在B中由 `get_caller_address()` 变量返回的值将返回A的调用者的地址，并且在B的类中"
"更新存储变量将更新A的存储（请记住，B的类是无状态的；没有可以更新的状态！）"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid "The expanded form of the struct and trait generated by the compiler look like:"
msgstr "编译器生成的 struct 和 trait 的扩展形式如下："

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:141
msgid ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash,\n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
"    fn name(\n"
"        self: IERC20LibraryDispatcher\n"
"    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash,\n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
"    fn name(\n"
"        self: IERC20LibraryDispatcher\n"
"    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and the library dispatcher is that the former uses `call_contract_syscall` while the latter uses "
"`library_call_syscall`."
msgstr "请注意，普通合约调度程序与库调度程序的主要区别在于，前者是通过 `call_contract_syscall` 生成的，而后者则使用了 `library_call_syscall`。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "<span class=\"caption\">Listing 99-7: An expanded form of the IERC20 trait</span>"
msgstr "<span class=\"caption\">示例99-7：IERC20 trait的扩展</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "### Calling Contracts using the Library Dispatcher"
msgstr "### 使用库调度器调用合约"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid "Below's a sample code for calling contracts using the Library Dispatcher."
msgstr "下面是一个关于使用库调度器调用合约的示例代码。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:174
msgid ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"#[starknet::interface]\n"
"trait IContractB<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128);\n"
"\n"
"    fn get_value(self: @TContractState) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ContractA {\n"
"    use super::{IContractBDispatcherTrait, IContractBLibraryDispatcher};\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u128\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    #[external(v0)]\n"
"    impl ContractA of IContractA {\n"
"        fn set_value(ref self: ContractState, value: u128) {\n"
"            IContractBLibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }\n"
"                .set_value(value)\n"
"        }\n"
"\n"
"        fn get_value(self: @ContractState) -> u128 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"#[starknet::interface]\n"
"trait IContractB<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128);\n"
"\n"
"    fn get_value(self: @TContractState) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ContractA {\n"
"    use super::{IContractBDispatcherTrait, IContractBLibraryDispatcher};\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u128\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    #[external(v0)]\n"
"    impl ContractA of IContractA {\n"
"        fn set_value(ref self: ContractState, value: u128) {\n"
"            IContractBLibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }\n"
"                .set_value(value)\n"
"        }\n"
"\n"
"        fn get_value(self: @ContractState) -> u128 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:208
msgid "<span class=\"caption\">Listing 99-8: A sample contract using the Library Dispatcher</span>"
msgstr "<span class=\"caption\">示例99-8：一个使用库调度器的样本合约</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the `IContractBDispatcherTrait` and `IContractBLibraryDispatcher` which were generated from our interface by the compiler. "
"Then, we can create an instance of `IContractBLibraryDispatcher` passing in the `class_hash` of the class we want to make library calls to. From there, we can call the functions "
"defined in that class, executing its logic in the context of our contract. When we call `set_value` on ContractA, it will make a library call to the `set_value` function in "
"ContractB, updating the value of the storage variable `value` in ContractA."
msgstr ""
"正如你所看到的，我们必须首先在我们的合约中导入`IContractBDispatcherTrait`和`IContractBLibraryDispatcher`，它们是由编译器从我们的接口中生成的。然后，我们可以创建一个 "
"`IContractBLibraryDispatcher` 实例，并将我们要调用库的类的 `class_hash` 传递进去。在这里，我们可以调用该类中定义的函数，在我们的合约上下文中执行其逻辑。当我们在合约 A 上调用 "
"`set_value` 时，它将对合约 B 中的 `set_value` 函数进行库调用，更新合约 A 中存储变量 `value` 的值。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:212
msgid "## Using low-level syscalls"
msgstr "## 使用底层系统调用来"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the `starknet::call_contract_syscall`and `starknet::library_call_syscall` system calls. The dispatchers we described in the "
"previous sections are high-level syntaxes for these low-level system calls."
msgstr "调用其他合约和类的另一种方法是使用 `starknet::call_contract_syscall` 和 `starknet::library_call_syscall` 系统调用。我们在前几节中描述的调度器就是这些低级系统调用的高级语法。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get more control over the serialization/deserialization of the call data and the returned data. Here's an "
"example demonstrating how to use a `call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"使用这些系统调用可以方便地进行自定义错误处理，或对调用数据和返回数据的序列化/反序列化进行更多控制。下面的示例演示了如何使用 `call_contract_sycall`调用 ERC20 合约的 `transfer`函数："

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:218
msgid ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"#[starknet::interface]\n"
"trait ITokenWrapper<TContractState> {\n"
"    fn transfer_token(\n"
"        ref self: TContractState,\n"
"        address: ContractAddress,\n"
"        sender: ContractAddress,\n"
"        recipient: ContractAddress,\n"
"        amount: u256\n"
"    ) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod TokenWrapper {\n"
"    use super::ITokenWrapper;\n"
"    use serde::Serde;\n"
"    use starknet::SyscallResultTrait;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
"        fn transfer_token(\n"
"            ref self: ContractState,\n"
"            address: ContractAddress,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) -> bool {\n"
"            let mut call_data: Array<felt252> = ArrayTrait::new();\n"
"            Serde::serialize(@sender, ref call_data);\n"
"            Serde::serialize(@recipient, ref call_data);\n"
"            Serde::serialize(@amount, ref call_data);\n"
"            let mut res = starknet::call_contract_syscall(\n"
"                address, selector!(\"transferFrom\"), call_data.span()\n"
"            )\n"
"                .unwrap_syscall();\n"
"            Serde::<bool>::deserialize(ref res).unwrap()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"#[starknet::interface]\n"
"trait ITokenWrapper<TContractState> {\n"
"    fn transfer_token(\n"
"        ref self: TContractState,\n"
"        address: ContractAddress,\n"
"        sender: ContractAddress,\n"
"        recipient: ContractAddress,\n"
"        amount: u256\n"
"    ) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod TokenWrapper {\n"
"    use super::ITokenWrapper;\n"
"    use serde::Serde;\n"
"    use starknet::SyscallResultTrait;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
"        fn transfer_token(\n"
"            ref self: ContractState,\n"
"            address: ContractAddress,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) -> bool {\n"
"            let mut call_data: Array<felt252> = ArrayTrait::new();\n"
"            Serde::serialize(@sender, ref call_data);\n"
"            Serde::serialize(@recipient, ref call_data);\n"
"            Serde::serialize(@amount, ref call_data);\n"
"            let mut res = starknet::call_contract_syscall(\n"
"                address, selector!(\"transferFrom\"), call_data.span()\n"
"            )\n"
"                .unwrap_syscall();\n"
"            Serde::<bool>::deserialize(ref res).unwrap()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:264
msgid "<span class=\"caption\">Listing 99-9: A sample contract using syscalls</span>"
msgstr "<span class=\"caption\">示例 99-9：使用系统调用的合约示例</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:266
msgid "To use this syscall, we passed in the contract address, the selector of the function we want to call, and the call arguments."
msgstr "为了使用这个系统调用，我们传入了合约地址、我们想要调用的函数的选择器以及调用参数。"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:268
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this array, we serialize the expected function parameters into an `Array<felt252>` using the `Serde` trait, and "
"then pass this array as calldata. At the end, we are returned a serialized value which we'll need to deserialize ourselves!"
msgstr ""
"调用参数必须以`felt252` 数组的形式提供。为了构建这个数组，我们使用 'Serde' trait 将预期的函数参数序列化为一个 `Array<felt252>`，然后将这个数组作为 calldata 传递。最后，我们返回一个序"
"列化值，我们需要自己反序列化该值！"

#: src/ch99-01-04-00-other-examples.md:1
msgid "# Other examples "
msgstr "# 其他例子"

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, utilizing various features of the Cairo programming language. Your contributions are welcome and encouraged, as "
"we aim to gather as many diverse examples as possible."
msgstr "本节包含了Starknet智能合约的其他示例，利用了Cairo编程语言的各种功能。我们欢迎并鼓励大家贡献自己的代码，因为我们的目标是收集尽可能多的不同例子。"

#: src/ch99-01-04-00-other-examples.md:5
msgid "<footer id=\"last-change\">Last change: 2023-08-04</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-08-04</footer>"

#: src/ch99-01-04-01-voting-contract.md:1
msgid "# Deploying and Interacting with a Voting contract"
msgstr "# 部署表决合约并与之互动"

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the contract's constructor. Three voters are initialized at this stage, and their addresses are passed to an "
"internal function **`_register_voters`**. This function adds the voters to the contract's state, marking them as registered and eligible to vote."
msgstr ""
"Starknet的 **`Vote`** 合约首先要通过合约的构造函数注册投票人。在此阶段，三个投票人被初始化，他们的地址被传递给内部函数 **`_register_voters`**。该函数将选民添加到合约的状态中，标记为已"
"注册并有资格投票。"

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to represent the voting options (1 and 0, respectively). These constants facilitate the voting process by "
"standardizing the input values."
msgstr "在合约中，常量 **`YES`** 和 **`NO`** 被定义为表决选项（分别为 1 和 0）。这些常量使输入值标准化，从而方便了投票过程。"

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, the state of the contract is "
"updated, recording the vote and marking the voter as having voted. This ensures that the voter is not able to cast a vote again within the same proposal. The casting of a vote "
"triggers the **`VoteCast`** event, logging the action."
msgstr ""
"注册完成后，投票者可使用 **`vote`** 函数进行投票，选择 1（YES）或 0（NO）作为其投票。投票时，合约状态会被更新，记录投票情况并标记投票人已投票。这样可以确保投票者无法在同一提案中再次投"
"票。投票会触发 **`VoteCast`** 事件，记录投票行为。"

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized action is detected, such as a non-registered user attempting to vote or a user trying to vote again, the "
"**`UnauthorizedAttempt`** event is emitted."
msgstr "该合约还会监控未经授权的投票尝试。如果检测到未经授权的行为，如非注册用户试图投票或用户试图再次投票，就会发出 **`UnauthorizedAttempt`** 事件。"

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured voting system, managing the lifecycle of a vote from registration to casting, event logging, and result "
"retrieval within the Starknet environment. Constants like **`YES`** and **`NO`** help streamline the voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""
"这些功能、状态、常量和事件共同创建了一个结构化投票系统，在Starknet环境中管理着从注册到投票、事件记录、以及结果检索的投票生命周期。常量（如 **`YES`** 和 **`NO`** ）有助于简化投票流程，"
"而事件则在确保透明度和可追溯性方面发挥着重要作用。"

#: src/ch99-01-04-01-voting-contract.md:13
msgid ""
"```rust,noplayground\n"
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
"use starknet::ContractAddress;\n"
"\n"
"/// @dev Trait defining the functions that can be implemented or called by the Starknet Contract\n"
"#[starknet::interface]\n"
"trait VoteTrait<T> {\n"
"    /// @dev Function that returns the current vote status\n"
"    fn get_vote_status(self: @T) -> (u8, u8, u8, u8);\n"
"    /// @dev Function that checks if the user at the specified address is allowed to vote\n"
"    fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool;\n"
"    /// @dev Function that checks if the specified address is registered as a voter\n"
"    fn is_voter_registered(self: @T, address: ContractAddress) -> bool;\n"
"    /// @dev Function that allows a user to vote\n"
"    fn vote(ref self: T, vote: u8);\n"
"}\n"
"\n"
"/// @dev Starknet Contract allowing three registered voters to vote on a proposal\n"
"#[starknet::contract]\n"
"mod Vote {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    const YES: u8 = 1_u8;\n"
"    const NO: u8 = 0_u8;\n"
"\n"
"    /// @dev Structure that stores vote counts and voter states\n"
"    #[storage]\n"
"    struct Storage {\n"
"        yes_votes: u8,\n"
"        no_votes: u8,\n"
"        can_vote: LegacyMap::<ContractAddress, bool>,\n"
"        registered_voter: LegacyMap::<ContractAddress, bool>,\n"
"    }\n"
"\n"
"    /// @dev Contract constructor initializing the contract with a list of registered voters and 0 vote count\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        voter_1: ContractAddress,\n"
"        voter_2: ContractAddress,\n"
"        voter_3: ContractAddress\n"
"    ) {\n"
"        // Register all voters by calling the _register_voters function\n"
"        self._register_voters(voter_1, voter_2, voter_3);\n"
"\n"
"        // Initialize the vote count to 0\n"
"        self.yes_votes.write(0_u8);\n"
"        self.no_votes.write(0_u8);\n"
"    }\n"
"\n"
"    /// @dev Event that gets emitted when a vote is cast\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        VoteCast: VoteCast,\n"
"        UnauthorizedAttempt: UnauthorizedAttempt,\n"
"    }\n"
"\n"
"    /// @dev Represents a vote that was cast\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct VoteCast {\n"
"        voter: ContractAddress,\n"
"        vote: u8,\n"
"    }\n"
"\n"
"    /// @dev Represents an unauthorized attempt to vote\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UnauthorizedAttempt {\n"
"        unauthorized_address: ContractAddress,\n"
"    }\n"
"\n"
"    /// @dev Implementation of VoteTrait for ContractState\n"
"    #[external(v0)]\n"
"    impl VoteImpl of super::VoteTrait<ContractState> {\n"
"        /// @dev Returns the voting results\n"
"        fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) {\n"
"            let (n_yes, n_no) = self._get_voting_result();\n"
"            let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage();\n"
"            (n_yes, n_no, yes_percentage, no_percentage)\n"
"        }\n"
"\n"
"        /// @dev Check whether a voter is allowed to vote\n"
"        fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -> bool {\n"
"            self.can_vote.read(user_address)\n"
"        }\n"
"\n"
"        /// @dev Check whether an address is registered as a voter\n"
"        fn is_voter_registered(self: @ContractState, address: ContractAddress) -> bool {\n"
"            self.registered_voter.read(address)\n"
"        }\n"
"\n"
"        /// @dev Submit a vote\n"
"        fn vote(ref self: ContractState, vote: u8) {\n"
"            assert(vote == NO || vote == YES, 'VOTE_0_OR_1');\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            self._assert_allowed(caller);\n"
"            self.can_vote.write(caller, false);\n"
"\n"
"            if (vote == NO) {\n"
"                self.no_votes.write(self.no_votes.read() + 1_u8);\n"
"            }\n"
"            if (vote == YES) {\n"
"                self.yes_votes.write(self.yes_votes.read() + 1_u8);\n"
"            }\n"
"\n"
"            self.emit(VoteCast { voter: caller, vote: vote, });\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Internal Functions implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        /// @dev Registers the voters and initializes their voting status to true (can vote)\n"
"        fn _register_voters(\n"
"            ref self: ContractState,\n"
"            voter_1: ContractAddress,\n"
"            voter_2: ContractAddress,\n"
"            voter_3: ContractAddress\n"
"        ) {\n"
"            self.registered_voter.write(voter_1, true);\n"
"            self.can_vote.write(voter_1, true);\n"
"\n"
"            self.registered_voter.write(voter_2, true);\n"
"            self.can_vote.write(voter_2, true);\n"
"\n"
"            self.registered_voter.write(voter_3, true);\n"
"            self.can_vote.write(voter_3, true);\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Asserts implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl AssertsImpl of AssertsTrait {\n"
"        // @dev Internal function that checks if an address is allowed to vote\n"
"        fn _assert_allowed(ref self: ContractState, address: ContractAddress) {\n"
"            let is_voter: bool = self.registered_voter.read((address));\n"
"            let can_vote: bool = self.can_vote.read((address));\n"
"\n"
"            if (can_vote == false) {\n"
"                self.emit(UnauthorizedAttempt { unauthorized_address: address, });\n"
"            }\n"
"\n"
"            assert(is_voter == true, 'USER_NOT_REGISTERED');\n"
"            assert(can_vote == true, 'USER_ALREADY_VOTED');\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Implement the VotingResultTrait for the Vote contract\n"
"    #[generate_trait]\n"
"    impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {\n"
"        // @dev Internal function to get the voting results (yes and no vote counts)\n"
"        fn _get_voting_result(self: @ContractState) -> (u8, u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            (n_yes, n_no)\n"
"        }\n"
"\n"
"        // @dev Internal function to calculate the voting results in percentage\n"
"        fn _get_voting_result_in_percentage(self: @ContractState) -> (u8, u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            let total_votes: u8 = n_yes + n_no;\n"
"\n"
"            if (total_votes == 0_u8) {\n"
"                return (0, 0);\n"
"            }\n"
"            let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);\n"
"            let no_percentage: u8 = (n_no * 100_u8) / (total_votes);\n"
"\n"
"            (yes_percentage, no_percentage)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,noplayground\n"
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
"use starknet::ContractAddress;\n"
"\n"
"/// @dev Trait defining the functions that can be implemented or called by the Starknet Contract\n"
"#[starknet::interface]\n"
"trait VoteTrait<T> {\n"
"    /// @dev Function that returns the current vote status\n"
"    fn get_vote_status(self: @T) -> (u8, u8, u8, u8);\n"
"    /// @dev Function that checks if the user at the specified address is allowed to vote\n"
"    fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool;\n"
"    /// @dev Function that checks if the specified address is registered as a voter\n"
"    fn is_voter_registered(self: @T, address: ContractAddress) -> bool;\n"
"    /// @dev Function that allows a user to vote\n"
"    fn vote(ref self: T, vote: u8);\n"
"}\n"
"\n"
"/// @dev Starknet Contract allowing three registered voters to vote on a proposal\n"
"#[starknet::contract]\n"
"mod Vote {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    const YES: u8 = 1_u8;\n"
"    const NO: u8 = 0_u8;\n"
"\n"
"    /// @dev Structure that stores vote counts and voter states\n"
"    #[storage]\n"
"    struct Storage {\n"
"        yes_votes: u8,\n"
"        no_votes: u8,\n"
"        can_vote: LegacyMap::<ContractAddress, bool>,\n"
"        registered_voter: LegacyMap::<ContractAddress, bool>,\n"
"    }\n"
"\n"
"    /// @dev Contract constructor initializing the contract with a list of registered voters and 0 vote count\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        voter_1: ContractAddress,\n"
"        voter_2: ContractAddress,\n"
"        voter_3: ContractAddress\n"
"    ) {\n"
"        // Register all voters by calling the _register_voters function\n"
"        self._register_voters(voter_1, voter_2, voter_3);\n"
"\n"
"        // Initialize the vote count to 0\n"
"        self.yes_votes.write(0_u8);\n"
"        self.no_votes.write(0_u8);\n"
"    }\n"
"\n"
"    /// @dev Event that gets emitted when a vote is cast\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        VoteCast: VoteCast,\n"
"        UnauthorizedAttempt: UnauthorizedAttempt,\n"
"    }\n"
"\n"
"    /// @dev Represents a vote that was cast\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct VoteCast {\n"
"        voter: ContractAddress,\n"
"        vote: u8,\n"
"    }\n"
"\n"
"    /// @dev Represents an unauthorized attempt to vote\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UnauthorizedAttempt {\n"
"        unauthorized_address: ContractAddress,\n"
"    }\n"
"\n"
"    /// @dev Implementation of VoteTrait for ContractState\n"
"    #[external(v0)]\n"
"    impl VoteImpl of super::VoteTrait<ContractState> {\n"
"        /// @dev Returns the voting results\n"
"        fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) {\n"
"            let (n_yes, n_no) = self._get_voting_result();\n"
"            let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage();\n"
"            (n_yes, n_no, yes_percentage, no_percentage)\n"
"        }\n"
"\n"
"        /// @dev Check whether a voter is allowed to vote\n"
"        fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -> bool {\n"
"            self.can_vote.read(user_address)\n"
"        }\n"
"\n"
"        /// @dev Check whether an address is registered as a voter\n"
"        fn is_voter_registered(self: @ContractState, address: ContractAddress) -> bool {\n"
"            self.registered_voter.read(address)\n"
"        }\n"
"\n"
"        /// @dev Submit a vote\n"
"        fn vote(ref self: ContractState, vote: u8) {\n"
"            assert(vote == NO || vote == YES, 'VOTE_0_OR_1');\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            self._assert_allowed(caller);\n"
"            self.can_vote.write(caller, false);\n"
"\n"
"            if (vote == NO) {\n"
"                self.no_votes.write(self.no_votes.read() + 1_u8);\n"
"            }\n"
"            if (vote == YES) {\n"
"                self.yes_votes.write(self.yes_votes.read() + 1_u8);\n"
"            }\n"
"\n"
"            self.emit(VoteCast { voter: caller, vote: vote, });\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Internal Functions implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        /// @dev Registers the voters and initializes their voting status to true (can vote)\n"
"        fn _register_voters(\n"
"            ref self: ContractState,\n"
"            voter_1: ContractAddress,\n"
"            voter_2: ContractAddress,\n"
"            voter_3: ContractAddress\n"
"        ) {\n"
"            self.registered_voter.write(voter_1, true);\n"
"            self.can_vote.write(voter_1, true);\n"
"\n"
"            self.registered_voter.write(voter_2, true);\n"
"            self.can_vote.write(voter_2, true);\n"
"\n"
"            self.registered_voter.write(voter_3, true);\n"
"            self.can_vote.write(voter_3, true);\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Asserts implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl AssertsImpl of AssertsTrait {\n"
"        // @dev Internal function that checks if an address is allowed to vote\n"
"        fn _assert_allowed(ref self: ContractState, address: ContractAddress) {\n"
"            let is_voter: bool = self.registered_voter.read((address));\n"
"            let can_vote: bool = self.can_vote.read((address));\n"
"\n"
"            if (can_vote == false) {\n"
"                self.emit(UnauthorizedAttempt { unauthorized_address: address, });\n"
"            }\n"
"\n"
"            assert(is_voter == true, 'USER_NOT_REGISTERED');\n"
"            assert(can_vote == true, 'USER_ALREADY_VOTED');\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Implement the VotingResultTrait for the Vote contract\n"
"    #[generate_trait]\n"
"    impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {\n"
"        // @dev Internal function to get the voting results (yes and no vote counts)\n"
"        fn _get_voting_result(self: @ContractState) -> (u8, u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            (n_yes, n_no)\n"
"        }\n"
"\n"
"        // @dev Internal function to calculate the voting results in percentage\n"
"        fn _get_voting_result_in_percentage(self: @ContractState) -> (u8, u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            let total_votes: u8 = n_yes + n_no;\n"
"\n"
"            if (total_votes == 0_u8) {\n"
"                return (0, 0);\n"
"            }\n"
"            let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);\n"
"            let no_percentage: u8 = (n_no * 100_u8) / (total_votes);\n"
"\n"
"            (yes_percentage, no_percentage)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:191
msgid "<span class=\"caption\">Voting smart contract</span>"
msgstr "<span class=\"caption\">投票智能合约</span>"

#: src/ch99-01-04-01-voting-contract.md:193
msgid "## Deploying, calling and invoking the Voting Contract"
msgstr "## 部署、调用和唤起投票合约"

#: src/ch99-01-04-01-voting-contract.md:195
msgid "Part of the Starknet experience is deploying and interacting with smart contracts."
msgstr "Starknet 体验的一部分就是部署智能合约并与之交互。"

#: src/ch99-01-04-01-voting-contract.md:197
msgid "Once the contract is deployed, we can interact with it by calling and invoking its functions:"
msgstr "一旦部署了合约，我们就可以通过调用合约的函数与之交互："

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"- Calling contracts: Interacting with external functions that only read from the state. These functions do not alter the state of the network, so they don't require fees or signing.\n"
"- Invoking contracts: Interacting with external functions that can write to the state. These functions do alter the state of the network and require fees and signing."
msgstr ""
"- 调用合约：与只读取状态的外部函数交互。这些函数不会改变网络的状态，因此不需要付费或签署。\n"
"- 唤起合约：与可以写入状态的外部函数交互。这些函数会改变网络状态，因此需要付费或签署。"

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting contract. Then, we'll interact with the contract by calling and invoking its functions. You can also use "
"the Goerli Testnet instead of `katana`. However, we recommend using `katana` for local development and testing. You can find the complete tutorial for `katana` in the [Local "
"Development with Katana](https://book.starknet.io/chapter_3/katana.html) chapter of the Starknet Book."
msgstr ""
"我们将使用 `katana` 设置一个本地开发节点来部署投票合约。然后，我们将通过调用和调用其函数与合约进行交互。你也可以使用Goerli测试网络而不是 `katana`。然而，我们建议在本地开发和测试中使"
"用 `katana`。你可以在Starknet Book的 [Local Development with Katana](https://book.starknet.io/chapter_3/katana.html) 章节中找到有关 `katana` 的完整教程。"

#: src/ch99-01-04-01-voting-contract.md:204
msgid "### The `katana` local Starknet node"
msgstr "### `katana` 本地Starknet节点"

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md). It will allow you to do everything you "
"need to do with Starknet, but locally. It is a great tool for development and testing."
msgstr ""
"`katana`旨在支持[Dojo 团队](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)的本地开发。通过它，您可以在本地完成Starknet所需的一切工作。它是开发和测试的绝佳工具。"

#: src/ch99-01-04-01-voting-contract.md:208
msgid "To install `katana` from the source code, please refer to the [Local Development with Katana](https://book.starknet.io/chapter_3/katana.html) chapter of the Starknet Book."
msgstr "要从源代码安装 `katana`，请参考Starknet Book的 [Local Development with Katana](https://book.starknet.io/chapter_3/katana.html) 章节。"

#: src/ch99-01-04-01-voting-contract.md:210
msgid "Once you have `katana` installed, you can start the local Starknet node with:"
msgstr "一旦安装了 `katana`，就可以用以下命令启动本地Starknet节点："

#: src/ch99-01-04-01-voting-contract.md:212
msgid ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"
msgstr ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:216
msgid "This command will start a local Starknet node with 3 deployed accounts. We will use these accounts to deploy and interact with the voting contract:"
msgstr "该命令将启动一个本地 Starknet 节点，并部署 3 个账户。我们将使用这些账户部署投票合约并与之交互："

#: src/ch99-01-04-01-voting-contract.md:218
msgid ""
"```bash\n"
"...\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"| Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"| Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"| Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"...\n"
"```"
msgstr ""
"```bash\n"
"...\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"| Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"| Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"| Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"...\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:237
msgid ""
"Before we can interact with the voting contract, we need to prepare the voter and admin accounts on Starknet. Each voter account must be registered and sufficiently funded for "
"voting. For a more detailed understanding of how accounts operate with Account Abstraction, refer to the [Account Abstraction](https://book.starknet.io/chapter_4/index.html) chapter "
"of the Starknet Book."
msgstr ""
"在我们与投票合约进行交互之前，我们需要在Starknet上准备选民和管理员账户。每个选民账户必须进行注册，并具备足够的资金进行投票。如果你想更详细地了解账户如何与账户抽象一起操作，请参考"
"Starknet Book的 [账户抽象](https://book.starknet.io/chapter_4/index.html) 章节。"

#: src/ch99-01-04-01-voting-contract.md:239
msgid "### Smart wallets for voting"
msgstr "### 用于投票的智能钱包"

#: src/ch99-01-04-01-voting-contract.md:241
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a command line tool that allows you to interact with Starknet. You can find the installation instructions in the "
"[Environment setup](https://book.starknet.io/chapter_1/environment_setup.html) chapter of the Starknet Book."
msgstr ""
"除了Scarb之外，你还需要安装Starkli。Starkli是一个命令行工具，允许你与Starknet进行交互。你可以在Starknet Book的 [环境初始化](https://book.starknet.io/chapter_1/environment_setup.html) "
"章节中找到安装说明。"

#: src/ch99-01-04-01-voting-contract.md:243
msgid ""
"For each smart wallet we'll use, we must create a Signer within the encrypted keystore and an Account Descriptor. This process is also detailed in the [Environment setup](https://"
"book.starknet.io/chapter_1/environment_setup.html) chapter of the Starknet Book."
msgstr ""
"对于我们将使用的每个智能钱包，我们必须在加密的密钥库中创建一个签名者和一个账户描述符。这个过程也在Starknet Book的[环境初始化](https://book.starknet.io/chapter_1/environment_setup."
"html) 章节中详细介绍了。"

#: src/ch99-01-04-01-voting-contract.md:245
msgid "We can create Signers and Account Descriptors for the accounts we want to use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr "我们可以为要用于投票的账户创建签名者和账户描述符。让我们在智能合约中创建一个用于投票的智能钱包。"

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Firstly, we create a signer from a private key:"
msgstr "首先，我们用私钥创建一个签名者："

#: src/ch99-01-04-01-voting-contract.md:249
msgid ""
"```bash\n"
"starkli signer keystore from-key ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli signer keystore from-key ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:253
msgid "Then, we create the Account Descriptor by fetching the katana account we want to use:"
msgstr "然后，我们通过获取我们要使用的katana账户来创建账户描述符："

#: src/ch99-01-04-01-voting-contract.md:255
msgid ""
"```bash\n"
"starkli account fetch <KATANA ACCOUNT ADDRESS> --rpc http://0.0.0.0:5050 --output ~/.starkli-wallets/deployer/account0_account.json\n"
"```"
msgstr ""
"```bash\n"
"starkli account fetch <KATANA ACCOUNT ADDRESS> --rpc http://0.0.0.0:5050 --output ~/.starkli-wallets/deployer/account0_account.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:259
msgid "This command will create a new `account0_account.json` file containing the following details:"
msgstr "这个命令将创建一个新的 `account0_account.json` 文件，其中包含以下细节："

#: src/ch99-01-04-01-voting-contract.md:261
msgid ""
"```bash\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"        \"type\": \"open_zeppelin\",\n"
"        \"version\": 1,\n"
"        \"public_key\": \"<SMART_WALLET_PUBLIC_KEY>\"\n"
"  },\n"
"    \"deployment\": {\n"
"        \"status\": \"deployed\",\n"
"        \"class_hash\": \"<SMART_WALLET_CLASS_HASH>\",\n"
"        \"address\": \"<SMART_WALLET_ADDRESS>\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"        \"type\": \"open_zeppelin\",\n"
"        \"version\": 1,\n"
"        \"public_key\": \"<SMART_WALLET_PUBLIC_KEY>\"\n"
"  },\n"
"    \"deployment\": {\n"
"        \"status\": \"deployed\",\n"
"        \"class_hash\": \"<SMART_WALLET_CLASS_HASH>\",\n"
"        \"address\": \"<SMART_WALLET_ADDRESS>\"\n"
"  }\n"
"}\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:277
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all your smart wallets) with the following command. Notice the use of the `--rpc` flag and the RPC endpoint "
"provided by `katana`:"
msgstr "你可以用以下命令获取智能钱包的 class hash（所有智能钱包的class hash都一样）。注意使用了 `--rpc` 标志和 `katana` 提供的 RPC 端点："

#: src/ch99-01-04-01-voting-contract.md:279
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:283
msgid "For the public key, you can use the `starkli signer keystore inspect` command with the directory of the keystore json file:"
msgstr "要获取公钥，可以使用 `starkli signer keystore inspect` 命令，并输入 keystore json 文件的目录："

#: src/ch99-01-04-01-voting-contract.md:285
msgid ""
"```bash\n"
"starkli signer keystore inspect ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli signer keystore inspect ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:289
msgid "This process is identical for `account_1` and `account_2` in case you want to have a second and a third voter."
msgstr "如果您想拥有第二个和第三个投票人，用同样的过程对 `account_1` 和 `account_2` 进行操作即可。"

#: src/ch99-01-04-01-voting-contract.md:291
msgid "### Contract Deployment"
msgstr "### 合约部署"

#: src/ch99-01-04-01-voting-contract.md:293
msgid "Before deploying, we need to declare the contract. We can do this with the `starkli declare` command:"
msgstr "在部署之前，我们需要声明合约。我们可以使用 `starkli declare` 命令来完成这项工作："

#: src/ch99-01-04-01-voting-contract.md:295
msgid ""
"```bash\n"
"starkli declare target/dev/starknetbook_chapter_2_Vote.sierra.json --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/"
"deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/starknetbook_chapter_2_Vote.sierra.json --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/"
"deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:299
msgid ""
"If the compiler version you're using is older than the one used by Starkli and you encounter a `compiler-version` error while using the command above, you can specify a compiler "
"version to use in the command by adding the `--compiler-version x.y.z` flag."
msgstr ""
"如果你使用的编译器版本旧于Starkli使用的版本，并且在使用上述命令时遇到了 `compiler-version` 错误，你可以通过在命令中添加 `--compiler-version x.y.z` 标志来指定要使用的编译器版本。"

#: src/ch99-01-04-01-voting-contract.md:301
msgid "If you're still encountering issues with the compiler version, try upgrading Starkli using the command: `starkliup` to make sure you're using the latest version of starkli."
msgstr "如果你仍然遇到编译器版本的问题，请尝试使用以下命令来升级 Starkli：`starkliup`，以确保你正在使用 starkli 的最新版本。"

#: src/ch99-01-04-01-voting-contract.md:303
msgid ""
"The class hash of the contract is: `0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You can find it [on any block explorer](https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""
"合约的的class hash是`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`.您可以在 [任何区块浏览器] (https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)中看到他。"

#: src/ch99-01-04-01-voting-contract.md:305
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by `katana`). The `--account` flag specifies the account to use for signing the transaction. The account we use "
"here is the one we created in the previous step. The `--keystore` flag specifies the keystore file to use for signing the transaction."
msgstr "`--rpc`标志指定要使用的 RPC 端点（由 `katana`提供）。`--account` 标志指定用于签署交易的账户。这里使用的账户是上一步创建的账户。 `--keystore`标记用于指定签署交易的密钥存储文件。"

#: src/ch99-01-04-01-voting-contract.md:307
msgid ""
"Since we are using a local node, the transaction will achieve finality immediately. If you are using the Goerli Testnet, you will need to wait for the transaction to be final, which "
"usually takes a few seconds."
msgstr "由于我们使用的是本地节点，因此交易将立即完成。如果您使用的是 Goerli Testnet，则需要等待交易最终完成，这通常需要几秒钟。"

#: src/ch99-01-04-01-voting-contract.md:309
msgid ""
"The following command deploys the voting contract and registers voter_0, voter_1, and voter_2 as eligible voters. These are the constructor arguments, so add a voter account that you "
"can later vote with."
msgstr "以下命令将部署投票合约，并将 voter_0、voter_1 和 voter_2 注册为合格投票人。这些是构造函数参数，因此请添加一个以后可以用来投票的选民账户。"

#: src/ch99-01-04-01-voting-contract.md:311
msgid ""
"```bash\n"
"starkli deploy <class_hash_of_the_contract_to_be_deployed> <voter_0_address> <voter_1_address> <voter_2_address> --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/"
"account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli deploy <class_hash_of_the_contract_to_be_deployed> <voter_0_address> <voter_1_address> <voter_2_address> --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/"
"account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:315
msgid "An example command:"
msgstr "命令示例："

#: src/ch99-01-04-01-voting-contract.md:317
msgid ""
"```bash\n"
"starkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account ~/.starkli-"
"wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account ~/.starkli-"
"wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:321
msgid ""
"In this case, the contract has been deployed at an specific address: `0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This address will be different for you. We "
"will use this address to interact with the contract."
msgstr "在本例中，合约已部署到特定地址：`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`。您应该会看到不同的地址。我们将使用此地址与合约进行交互。"

#: src/ch99-01-04-01-voting-contract.md:323
msgid "### Voter Eligibility Verification"
msgstr "### 投票人资格验证"

#: src/ch99-01-04-01-voting-contract.md:325
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, `voter_can_vote` and `is_voter_registered`. These are external read functions, which mean they don't "
"alter the state of the contract but only read the current state."
msgstr "在我们的投票合约中，我们有两个函数来验证投票人的资格，即 `voter_can_vote` 和 `is_voter_registered`。这些函数是外部只读函数，这意味着它们不会改变合约的状态，而只是读取当前状态。"

#: src/ch99-01-04-01-voting-contract.md:327
msgid ""
"The `is_voter_registered` function checks whether a particular address is registered as an eligible voter in the contract. The `voter_can_vote` function, on the other hand, checks "
"whether the voter at a specific address is currently eligible to vote, i.e., they are registered and haven't voted already."
msgstr "`is_voter_registered`函数检查特定地址是否在合约中登记为合格投票人。另一方面，`voter_can_vote`函数会检查特定地址的投票人当前是否有资格投票，即他们是否已登记且尚未投票。"

#: src/ch99-01-04-01-voting-contract.md:329
msgid ""
"You can call these functions using the `starkli call` command. Note that the `call` command is used for read functions, while the `invoke` command is used for functions that can also "
"write to storage. The `call` command does not require signing, while the `invoke` command does."
msgstr "你可以使用 `starkli call` 命令来调用这些函数。请注意，`call`命令用于只读函数，而 `invoke`命令用于也可以写入存储空间的函数。调用 `call` 命令不需要签名，而 `invoke`命令需要签名。"

#: src/ch99-01-04-01-voting-contract.md:331
msgid ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:335
msgid ""
"First we added the address of the contract, then the function we want to call, and finally the input for the function. In this case, we are checking whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can vote."
msgstr ""
"首先，我们添加了合约的地址，然后是要调用的函数，最后是函数的输入。在本例中，我们要检查地址为 `0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` 的投票人是否可以投"
"票。"

#: src/ch99-01-04-01-voting-contract.md:337
msgid "Since we provided a registered voter address as an input, the result is 1 (boolean true), indicating the voter is eligible to vote."
msgstr "由于我们提供了已登记的投票人的地址作为输入，因此结果为 1（布尔值为 true），表明该选民有资格投票。"

#: src/ch99-01-04-01-voting-contract.md:339
msgid "Next, let's call the `is_voter_registered` function using an unregistered account address to observe the output:"
msgstr "接下来，让我们使用一个未注册的账户地址调用 `is_voter_registered` 函数来观察输出结果："

#: src/ch99-01-04-01-voting-contract.md:341
msgid ""
"```bash\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:345
msgid "With an unregistered account address, the terminal output is 0 (i.e., false), confirming that the account is not eligible to vote."
msgstr "对于未注册的账户地址，终端输出为 0（即假），确认该账户没有投票资格。"

#: src/ch99-01-04-01-voting-contract.md:347
msgid "### Casting a Vote"
msgstr "### 投票"

#: src/ch99-01-04-01-voting-contract.md:349
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! To vote, we interact with the `vote` function, which is flagged as external, necessitating the use of the "
"`starknet invoke` command."
msgstr "既然我们已经确定了如何验证选民资格，那么我们就可以投票了！投票时，我们要与`vote`函数交互，该函数被标记为外部函数，因此必须使用 `starknet invoke`命令。"

#: src/ch99-01-04-01-voting-contract.md:351
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the `vote` function, we are "
"charged a fee, and the transaction must be signed by the voter; we are writing to the contract's storage."
msgstr ""
"`invoke`命令的语法与 `call` 命令类似，但在投票时，我们需要输入 \"1\"（表示 \"是\"）或 \"0\"（表示 \"否\"）。当我们唤起 `vote` 函数时，我们会被收取一定的费用，而且交易必须由投票人签"
"署；我们正在向合约的存储空间写入内容。"

#: src/ch99-01-04-01-voting-contract.md:353
msgid ""
"```bash\n"
"//Voting Yes\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"\n"
"//Voting No\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"//Voting Yes\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"\n"
"//Voting No\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:361
msgid ""
"You will be prompted to enter the password for the signer. Once you enter the password, the transaction will be signed and submitted to the Starknet network. You will receive the "
"transaction hash as output. With the starkli transaction command, you can get more details about the transaction:"
msgstr "系统将提示您输入签名者的密码。输入密码后，交易将被签署并提交到Starknet网络。你将收到交易哈希值作为输出。使用 starkli 交易命令，你可以获得更多关于交易的详细信息："

#: src/ch99-01-04-01-voting-contract.md:363
msgid ""
"```bash\n"
"starkli transaction <TRANSACTION_HASH> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"starkli transaction <TRANSACTION_HASH> --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:367
msgid "This returns:"
msgstr "这个会返回："

#: src/ch99-01-04-01-voting-contract.md:369
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\",\n"
"  \"max_fee\": \"0x430e81\",\n"
"  \"version\": \"0x1\",\n"
"  \"signature\": [\n"
"    \"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\",\n"
"    \"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\"\n"
"  ],\n"
"  \"nonce\": \"0x3\",\n"
"  \"type\": \"INVOKE\",\n"
"  \"sender_address\": \"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\",\n"
"  \"calldata\": [\n"
"    \"0x1\",\n"
"    \"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\",\n"
"    \"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\",\n"
"    \"0x0\",\n"
"    \"0x1\",\n"
"    \"0x1\",\n"
"    \"0x1\"\n"
"  ]\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\",\n"
"  \"max_fee\": \"0x430e81\",\n"
"  \"version\": \"0x1\",\n"
"  \"signature\": [\n"
"    \"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\",\n"
"    \"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\"\n"
"  ],\n"
"  \"nonce\": \"0x3\",\n"
"  \"type\": \"INVOKE\",\n"
"  \"sender_address\": \"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\",\n"
"  \"calldata\": [\n"
"    \"0x1\",\n"
"    \"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\",\n"
"    \"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\",\n"
"    \"0x0\",\n"
"    \"0x1\",\n"
"    \"0x1\",\n"
"    \"0x1\"\n"
"  ]\n"
"}\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:393
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr "如果您尝试用同一个签名者投票两次，则会出现错误："

#: src/ch99-01-04-01-voting-contract.md:395
msgid ""
"```bash\n"
"Error: code=ContractError, message=\"Contract error\"\n"
"```"
msgstr ""
"```bash\n"
"Error: code=ContractError, message=\"Contract error\"\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:399
msgid "The error is not very informative, but you can get more details when looking at the output in the terminal where you started `katana` (our local Starknet node):"
msgstr "错误信息很简略，但你可以启动 `katana`（我们的本地Starknet节点）的终端中查看输出，获得更多细节："

#: src/ch99-01-04-01-voting-contract.md:401
msgid ""
"```bash\n"
"...\n"
"Transaction execution error: \"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
"```"
msgstr ""
"```bash\n"
"...\n"
"Transaction execution error: \"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:409
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr "错误的关键字是 `USER_ALREADY_VOTED`。"

#: src/ch99-01-04-01-voting-contract.md:411
msgid ""
"```bash\n"
"assert(can_vote == true, 'USER_ALREADY_VOTED');\n"
"```"
msgstr ""
"```bash\n"
"assert(can_vote == true, 'USER_ALREADY_VOTED');\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:415
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the accounts we want to use for voting. Remember that each Signer must be created from a private key, and each "
"Account Descriptor must be created from a public key, a smart wallet address, and the smart wallet class hash (which is the same for each voter)."
msgstr ""
"我们可以重复上述过程，为要将用于投票的账户创建签名者和账户描述符。请记住，每个签名者都必须用私钥创建，每个账户描述符都必须用公钥、智能钱包地址和智能钱包class hash （每个投票者的class "
"hash 都一样）创建。"

#: src/ch99-01-04-01-voting-contract.md:417
msgid ""
"```bash\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account1_account.json --"
"keystore ~/.starkli-wallets/deployer/account1_keystore.json\n"
"\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account2_account.json --"
"keystore ~/.starkli-wallets/deployer/account2_keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account1_account.json --"
"keystore ~/.starkli-wallets/deployer/account1_keystore.json\n"
"\n"
"starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account ~/.starkli-wallets/deployer/account2_account.json --"
"keystore ~/.starkli-wallets/deployer/account2_keystore.json\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:423
msgid "### Visualizing Vote Outcomes"
msgstr "### 投票结果可视化"

#: src/ch99-01-04-01-voting-contract.md:425
msgid "To examine the voting results, we invoke the `get_vote_status` function, another view function, through the `starknet call` command."
msgstr "为了检查投票结果，我们通过 `starknet call`命令调用另一个视图函数 `get_vote_status`。"

#: src/ch99-01-04-01-voting-contract.md:427
msgid ""
"```bash\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:431
msgid "The output reveals the tally of \"Yes\" and \"No\" votes along with their relative percentages."
msgstr "输出结果显示了 \"Yes\"和 \"No\" 票数及其相对百分比。"

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "# L1-L2 Messaging"
msgstr "# L1-L2 间信息传递"

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr "Layer 2的一个重要特征是它能与Layer 1交互。"

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its consensus mechanism and the submission of state updates on L1. Messaging is a way for smart-contracts on L1 "
"to interact with smart-contracts on L2 (or the other way around), allowing us to do \"cross-chain\" transactions. For example, we can do some computations on a chain and use the "
"result of this computation on the other chain."
msgstr ""
"Starknet拥有自己的 `L1-L2` 消息传递系统，它与其共识机制和L1上状态更新的提交方式不同。消息传递是L1上的智能合约与L2上的智能合约（或反之亦然）进行交互的一种方式，允许我们进行”跨链”交易。"
"例如，我们可以在一个链上进行一些计算，并在另一个链上使用这个计算的结果。"

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to bridge tokens from Ethereum to Starknet. You will simply have to deposit your tokens in the L1 bridge "
"contract, which will automatically trigger the minting of the same token on L2. Another good use case for `L1-L2` messaging would be [DeFi pooling](https://starkware.co/resource/defi-"
"pooling/)."
msgstr ""
"在Starknet上，所有的桥接都使用 `L1-L2` 消息传递。假设你想要将以太坊上的代币桥接到Starknet上。你只需要将代币存入L1桥接合约，这将自动触发在L2上铸造相同代币。`L1-L2` 消息传递的另一个很好"
"的用例是[DeFi池化](https://starkware.co/resource/defi-pooling/)。"

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid "On Starknet, it's important to note that the messaging system is **asynchronous** and **asymmetric**."
msgstr "在Starknet上，重要的是要注意消息系统是**异步**和**非对称**。"

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"- **Asynchronous**: this means that in your contract code (being solidity or cairo), you can't wait the result of the message being sent on the other chain within your contract code "
"execution.\n"
"- **Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is fully automatized by the Starknet sequencer, which means that the message is being automatically delivered "
"to the target contract on L2. However, when sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the message is sent on L1 by the Starknet sequencer. You must "
"then consume the message manually via a transaction on L1."
msgstr ""
"- **异步性**：这意味着在你的合约代码（无论是Solidity还是Cairo）中，在合约代码执行期间，你不能等待另一个链上发送消息的结果。\n"
"- **非对称性**：从以太坊发送消息到Starknet（`L1->L2`）是由Starknet序列器完全自动化的，这意味着消息会自动传递到L2上的目标合约。然而，当从Starknet发送消息到以太坊（`L2->L1`）时，"
"Starknet序列器仅在L1上发送消息的哈希。然后，你必须通过L1上的交易来手动消耗该消息。"

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "让我们来详细了解一下。"

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "## The StarknetMessaging Contract"
msgstr "## Starknet消息传递合约"

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) contract. It is a set of "
"Solidity contracts deployed on Ethereum that allows Starknet to function properly. One of the contracts of `StarknetCore` is called `StarknetMessaging` and it is the contract "
"responsible for passing messages between Starknet and Ethereum. `StarknetMessaging` follows an [interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) with functions allowing to send message to L2, receiving messages on L1 from L2 "
"and canceling messages."
msgstr ""
"`L1-L2` 消息传递系统的关键组件是[StarknetCore合约](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4)。它是部署在以太坊上的一组Solidity合约，用于使Starknet正常运"
"行。`StarknetCore` 的合约之一被称为`StarknetMessaging`，它负责在Starknet和以太坊之间传递消息。StarknetMessaging遵循一个[接口](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6)，其中包含了一些函数，允许向L2发送消息，在L1上从L2接收消息以及取消消息。"

#: src/ch99-04-00-L1-L2-messaging.md:20
msgid ""
"```js\n"
"interface IStarknetMessaging is IStarknetMessagingEvents {\n"
"\n"
"    function sendMessageToL2(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload\n"
"    ) external returns (bytes32);\n"
"\n"
"    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\n"
"        external\n"
"        returns (bytes32);\n"
"\n"
"    function startL1ToL2MessageCancellation(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload,\n"
"        uint256 nonce\n"
"    ) external;\n"
"\n"
"    function cancelL1ToL2Message(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload,\n"
"        uint256 nonce\n"
"    ) external;\n"
"}\n"
"```"
msgstr ""
"```js\n"
"interface IStarknetMessaging is IStarknetMessagingEvents {\n"
"\n"
"    function sendMessageToL2(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload\n"
"    ) external returns (bytes32);\n"
"\n"
"    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\n"
"        external\n"
"        returns (bytes32);\n"
"\n"
"    function startL1ToL2MessageCancellation(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload,\n"
"        uint256 nonce\n"
"    ) external;\n"
"\n"
"    function cancelL1ToL2Message(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload,\n"
"        uint256 nonce\n"
"    ) external;\n"
"}\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid "<span class=\"caption\"> Starknet messaging contract interface</span>"
msgstr "<span class=\"caption\">Starknet消息传送合约接口</span>"

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly listening to the logs emitted by the `StarknetMessaging` contract on Ethereum.\n"
"Once a message is detected in a log, the sequencer prepares and executes a `L1HandlerTransaction` to call the function on the target L2 contract. This takes up to 1-2 minutes to be "
"done (few seconds for ethereum block to be mined, and then the sequencer must build and execute the transaction)."
msgstr ""
"对于 `L1->L2` 的消息，Starknet序列器不断监听以太坊上的 `StarknetMessaging` 合约发出的日志。\n"
"一旦在日志中检测到消息，序列器会准备并执行 `L1HandlerTransaction`，以调用目标L2合约上的函数。这个过程可能需要1-2分钟（几秒钟用于挖掘以太坊区块，然后序列器必须构建并执行事务）。"

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of the block produced. When the sequencer produces a block, it sends the hash of each message prepared by "
"contracts execution\n"
"to the `StarknetCore` contract on L1, where they can then be consumed once the block they belong to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"`L2->L1` 的消息是由在L2上执行的合约准备的，并且是生成的区块的一部分。当序列器生成一个区块时，序列器将把合约执行准备的每个消息的哈希发送到L1上的 `StarknetCore` 合约，一旦它们所属的区块"
"在以太坊上被证明和验证（目前大约需要3-4小时），这些消息就可以被消耗。"

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "## Sending messages from Ethereum to Starknet"
msgstr "## 从以太坊向Starknet发送信息"

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity contracts must call the `sendMessageToL2` function of the `StarknetMessaging` contract. To receive these "
"messages on Starknet, you will need to annotate functions that can be called from L1 with the `#[l1_handler]` attribute."
msgstr ""
"如果你想从 Ethereum 向 Starknet 发送消息，你的 Solidity 合约必须调用 `StarknetMessaging` 合约的 `sendMessageToL2` 函数。要在 Starknet 上接收这些消息，你需要用 `#[l1_handler]` 属性注解"
"可从 L1 调用的函数。"

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this tutorial](https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) where we want to send a message to "
"Starknet.\n"
"The `_snMessaging` is a state variable already initialized with the address of the `StarknetMessaging` contract. You can check those addresses [here](https://docs.starknet.io/"
"documentation/tools/important_addresses/)."
msgstr ""
"让我们看一个简单的合约，来自[这个教程](https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) 我们希望向Starknet发送一条消息。\n"
"`_snMessaging` 是一个已经初始化为 `StarknetMessaging` 合约地址的状态变量。你可以在[这里](https://docs.starknet.io/documentation/tools/important_addresses/)检查这些地址。"

#: src/ch99-04-00-L1-L2-messaging.md:64
msgid ""
"```js\n"
"// Sends a message on Starknet with a single felt.\n"
"function sendMessageFelt(\n"
"    uint256 contractAddress,\n"
"    uint256 selector,\n"
"    uint256 myFelt\n"
")\n"
"    external\n"
"    payable\n"
"{\n"
"    // We \"serialize\" here the felt into a payload, which is an array of uint256.\n"
"    uint256[] memory payload = new uint256[](1);\n"
"    payload[0] = myFelt;\n"
"\n"
"    // msg.value must always be >= 20_000 wei.\n"
"    _snMessaging.sendMessageToL2{value: msg.value}(\n"
"        contractAddress,\n"
"        selector,\n"
"        payload\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```js\n"
"// Sends a message on Starknet with a single felt.\n"
"function sendMessageFelt(\n"
"    uint256 contractAddress,\n"
"    uint256 selector,\n"
"    uint256 myFelt\n"
")\n"
"    external\n"
"    payable\n"
"{\n"
"    // We \"serialize\" here the felt into a payload, which is an array of uint256.\n"
"    uint256[] memory payload = new uint256[](1);\n"
"    payload[0] = myFelt;\n"
"\n"
"    // msg.value must always be >= 20_000 wei.\n"
"    _snMessaging.sendMessageToL2{value: msg.value}(\n"
"        contractAddress,\n"
"        selector,\n"
"        payload\n"
"    );\n"
"}\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the `StarknetMessaging` contract.\n"
"Please note that if you want to send more complex data you can. Just be aware that your cairo contract will only understand `felt252` data type. So you must ensure that the "
"serialization of your data into the `uint256` array follow the cairo serialization scheme."
msgstr ""
"该函数向 `StarknetMessaging` 合约发送一个包含单个 felt 值的消息。\n"
"请注意，如果你想发送更复杂的数据，可以这样做。只是要注意，你的 Cairo 合约只能理解 `felt252` 数据类型。因此，你必须确保将数据序列化为 `uint256` 数组时，要按照 Cairo 的序列化方案进行操"
"作。"

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the minimum value we've to send here is `20k wei`, due to the fact that the `StarknetMessaging` contract will "
"register\n"
"the hash of our message in the storage of Ethereum."
msgstr "这里需要注意的是我们有 `{value: msg.value}`。实际上，我们在这里必须发送的最小值是 `20,000 wei` ，因为 `StarknetMessaging` 合约会在以太坊的存储中注册我们消息的哈希。"

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be executed by the sequencer is not bound to any account (the message originates from L1), you must also "
"ensure\n"
"that you pay enough fees on L1 for your message to be deserialized and processed on L2."
msgstr "除了这 `20,000 wei` 之外，由于由序列器执行的 `L1HandlerTransaction` 不绑定到任何账户（消息源自 L1），你还必须确保在 L1 上支付足够的费用，以便你的消息在 L2 上被反序列化和处理。"

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as it would be done for an `Invoke` transaction. For this, you can profile\n"
"the gas consumption using `starkli` or `snforge` to estimate the cost of your message execution."
msgstr "`L1HandlerTransaction` 的费用计算方式与 `Invoke` 交易的计算方式相同。为此，你可以使用 `starkly` 或 `snforge` 对gas消耗进行分析，估算你的消息执行成本。"

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr "`sendMessageToL2`的签名是："

#: src/ch99-04-00-L1-L2-messaging.md:101
msgid ""
"```js\n"
"function sendMessageToL2(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload\n"
"    ) external override returns (bytes32);\n"
"```"
msgstr ""
"```js\n"
"function sendMessageToL2(\n"
"        uint256 toAddress,\n"
"        uint256 selector,\n"
"        uint256[] calldata payload\n"
"    ) external override returns (bytes32);\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr "参数如下："

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid ""
"- `toAddress`: The contract address on L2 that will be called.\n"
"- `selector`: The selector of the function of this contract at `toAddress`. This selector (function) must have the `#[l1_handler]` attribute to be callable.\n"
"- `payload`: The payload is always an array of `felt252` (which are represented by `uint256` in solidity). For this reason we've inserted the input `myFelt` into the array.\n"
"  This is why we need to insert the input data into an array."
msgstr ""
"- `toAddress` : 在 L2 上将被调用的合约地址。\n"
"- `selector` : 位于 `toAddress` 上此合约函数的选择器。这个选择器（函数）必须具有 `#[l1_handler]` 属性以便被调用。\n"
"- `payload` : payload 始终是一个 `felt252` 数组（在 Solidity 中由 `uint256` 表示）。因此，我们将输入 `myFelt` 插入到数组中。这就是为什么我们需要将输入数据插入到数组中的原因。"

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr "在Starknet方面，要接收这条信息，我们需要："

#: src/ch99-04-00-L1-L2-messaging.md:118
msgid ""
"```rust\n"
"    #[l1_handler]\n"
"    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n"
"        assert(from_address == self.allowed_message_sender.read(), 'Invalid message sender');\n"
"\n"
"        // You can now use the data, automatically deserialized from the message payload.\n"
"        assert(my_felt == 123, 'Invalid value');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[l1_handler]\n"
"    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n"
"        assert(from_address == self.allowed_message_sender.read(), 'Invalid message sender');\n"
"\n"
"        // You can now use the data, automatically deserialized from the message payload.\n"
"        assert(my_felt == 123, 'Invalid value');\n"
"    }\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers are special functions that can only be executed by a `L1HandlerTransaction`. There is nothing particular to "
"do to receive transactions from L1, as the message is relayed by the sequencer automatically. In your `#[l1_handler]` functions, it is important to verify the sender of the L1 "
"message to ensure that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"我们需要为我们的函数添加 `#[l1_handler]` 属性。L1处理器是一种特殊的函数，只能由`L1HandlerTransaction` 执行。接收来自L1的事务时不需要特别处理，因为消息会自动由顺序器中继。在你的 "
"`#[l1_handler]` 函数中，重要的是要验证L1消息的发送者，以确保我们的合约只能接收来自受信任的L1合约的消息。"

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "## Sending messages from Starknet to Ethereum"
msgstr "## 从Starknet向以太坊发送信息"

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the `send_message_to_l1` syscall in your Cairo contracts. This syscall allows you to send messages to the "
"`StarknetMessaging` contract on L1. Unlike `L1->L2` messages, `L2->L1` messages must be consumed manually, which means that you will need your Solidity contract to call the "
"`consumeMessageFromL2` function of the `StarknetMessaging` contract explicitly in order to consume the message."
msgstr ""
"当从Starknet发送消息到以太坊时，你将需要在Cairo合约中使用 `send_message_to_l1` 系统调用。该系统调用允许您向L1上的 `StarknetMessaging` 合约发送消息。与 `L1->L2` 消息不同的是，`L2->L1` "
"消息必须手动消耗，这意味着你的Solidity合约需要显式调用 `StarknetMessaging` 合约的 `consumeMessageFromL2` 函数来消耗消息。"

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr "要从 L2 向 L1 发送信息，我们在Starknet上要做的是："

#: src/ch99-04-00-L1-L2-messaging.md:136
msgid ""
"```rust\n"
"        fn send_message_felt(ref self: ContractState, to_address: EthAddress, my_felt: felt252) {\n"
"            // Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
"            starknet::send_message_to_l1_syscall(to_address.into(), array![my_felt].span())\n"
"                .unwrap();\n"
"        }\n"
"```"
msgstr ""
"```rust\n"
"        fn send_message_felt(ref self: ContractState, to_address: EthAddress, my_felt: felt252) {\n"
"            // Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
"            starknet::send_message_to_l1_syscall(to_address.into(), array![my_felt].span())\n"
"                .unwrap();\n"
"        }\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid "We simply build the payload and pass it, along with the L1 contract address, to the syscall function."
msgstr "我们只需构建payload，并将其与 L1 合约地址一起传递给系统调用函数。"

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload as on L2. Then you call `consumeMessageFromL2` by passing the L2 contract address and the payload.\n"
"Please be aware that the L2 contract address expected by the `consumeMessageFromL2` is the contract address of the account that sends the transaction on L2,\n"
"and not the address of the contract executing the `send_message_to_l1_syscall`."
msgstr ""
"在L1上，重要的部分是构建与L2上相同的payload。然后，通过传递L2合约地址和payload来调用 `consumeMessageFromL2`。\n"
"请注意，`consumeMessageFromL2` 期望的L2合约地址是在L2上发送交易的账户的合约地址，而不是执行 `send_message_to_l1_syscall` 的合约的地址。"

#: src/ch99-04-00-L1-L2-messaging.md:151
msgid ""
"```js\n"
"function consumeMessageFelt(\n"
"    uint256 fromAddress,\n"
"    uint256[] calldata payload\n"
")\n"
"    external\n"
"{\n"
"    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);\n"
"\n"
"    // You can use the message hash if you want here.\n"
"\n"
"    // We expect the payload to contain only a felt252 value (which is a uint256 in solidity).\n"
"    require(payload.length == 1, \"Invalid payload\");\n"
"\n"
"    uint256 my_felt = payload[0];\n"
"\n"
"    // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.\n"
"    require(my_felt > 0, \"Invalid value\");\n"
"}\n"
"```"
msgstr ""
"```js\n"
"function consumeMessageFelt(\n"
"    uint256 fromAddress,\n"
"    uint256[] calldata payload\n"
")\n"
"    external\n"
"{\n"
"    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);\n"
"\n"
"    // You can use the message hash if you want here.\n"
"\n"
"    // We expect the payload to contain only a felt252 value (which is a uint256 in solidity).\n"
"    require(payload.length == 1, \"Invalid payload\");\n"
"\n"
"    uint256 my_felt = payload[0];\n"
"\n"
"    // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.\n"
"    require(my_felt > 0, \"Invalid value\");\n"
"}\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"As you can see, in this context we don't have to verify which contract from L2 is sending the message. But we are actually using the `consumeMessageFromL2` to validate the inputs "
"(the sender address on L2 and the payload) to ensure we are only consuming valid messages."
msgstr ""
"正如你所看到的，在这个上下文中，我们无需验证L2中的哪个合约正在发送消息。但实际上，我们使用 `consumeMessageFromL2` 来验证输入（在L2上的发送者地址和payload），以确保我们只处理有效的消"
"息。"

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of `uint256`, but the basic data type on Starknet is `felt252`; however, `felt252` are approximately 4 bits smaller "
"than `uint256`. So we have to pay attention to the values contained in the payload of the messages we are sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"重要的是要记住，在L1上我们发送的有效载荷是 `uint256`，但是在Starknet上的基本数据类型是 `felt252`；然而，`felt252` 比 `uint256` 大约小4位。因此，我们必须注意我们发送的消息有效载荷中包"
"含的值。如果在L1上构建的消息的值超过了最大的`felt252`，该消息将被卡住，无法在L2上被消耗。"

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "## Cairo Serde"
msgstr "## Cairo Serde"

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet contracts, written in Cairo, can only understand serialized data. And serialized data is always an array of "
"`felt252`.\n"
"On solidity, we have `uint256` type, and `felt252` are approximately 4 bits smaller than `uint256`. So we have to pay attention to the values contained in the payload of the messages "
"we are sending.\n"
"If, on L1, we build a message with values above the maximum `felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"在L1和L2之间发送消息之前，你必须记住，用Cairo编写的Starknet合约只能理解序列化数据。而序列化数据始终是一个`felt252`数组。\n"
"在Solidity中，我们有 `uint256` 类型，而 `felt252` 比 `uint256` 大约小4位。因此，我们必须注意我们发送的消息有效载荷中包含的值。\n"
"如果在L1上构建的消息的值超过了最大的 `felt252`，该消息将被卡住，无法在L2上被消耗。"

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid "So for instance, an actual `uint256` value in Cairo is represented by a struct like:"
msgstr "例如，在Cairo中，一个实际的 `uint256` 值表示为类似以下的结构："

#: src/ch99-04-00-L1-L2-messaging.md:184
msgid ""
"```rust,does_not_compile\n"
"struct u256 {\n"
"    low: u128,\n"
"    high: u128,\n"
"}\n"
"```"
msgstr ""
"```rust,does_not_compile\n"
"struct u256 {\n"
"    low: u128,\n"
"    high: u128,\n"
"}\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for the `high`. This means that to send only one `u256` to Cairo, you'll need to send a payload from L1 with "
"**TWO** values."
msgstr "这将被序列化为**两个** felts ，一个用于 `low` ，另一个用于 `high` 。这意味着要向Cairo发送一个 `u256`，你需要从L1发送一个包含**两个**值的 payload。"

#: src/ch99-04-00-L1-L2-messaging.md:193
msgid ""
"```js\n"
"uint256[] memory payload = new uint256[](2);\n"
"// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
"payload[0] = 1;\n"
"payload[1] = 0;\n"
"```"
msgstr ""
"```js\n"
"uint256[] memory payload = new uint256[](2);\n"
"// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
"payload[0] = 1;\n"
"payload[1] = 0;\n"
"```"

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the [Starknet documentation](https://docs.starknet.io/documentation/architecture_and_concepts/"
"Network_Architecture/messaging-mechanism/)."
msgstr "如果你想了解更多关于消息机制的信息，可以访问 [Starknet 文档](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid "You can also find a [detailed guide here](https://github.com/glihm/starknet-messaging-dev) to test the messaging in local."
msgstr "你也可以在这里找到[详细的教程](https://github.com/glihm/starknet-messaging-dev) 来在本地测试消息传递。"

#: src/ch99-04-00-L1-L2-messaging.md:204
msgid "<footer id=\"last-change\">Last change: 2023-11-22</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-22</footer>"

#: src/ch99-03-security-considerations.md:1
msgid "# Security Considerations"
msgstr "# 安全考量"

#: src/ch99-03-security-considerations.md:3
msgid "When developing software, ensuring it functions as intended is usually straightforward. However, preventing unintended usage and vulnerabilities can be more challenging."
msgstr "在开发软件时，确保其按预期运行通常比较简单而直接。然而，防止非预期的使用和漏洞可能更具挑战性。"

#: src/ch99-03-security-considerations.md:5
msgid "In smart contract development, security is very important. A single error can result in the loss of valuable assets or the improper functioning of certain features."
msgstr "在智能合约的开发中，安全性非常重要。仅仅一个简单的错误就可能导致宝贵资产的损失或某些功能的错误运行。"

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can examine the code and interact with it. Any errors or vulnerabilities in the code can be exploited by malicious "
"actors."
msgstr "智能合约在一个公开的环境中执行，任何人都可以检查代码并与之交互。代码中的任何错误或漏洞都可能被恶意行为者利用。"

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart contracts. By incorporating these concepts during development, you can create robust and reliable smart "
"contracts. This reduces the chances of unexpected behavior or vulnerabilities."
msgstr "本章介绍了编写安全智能合约的一般建议。在开发过程中，通过融入这些概念，你可以创建健壮可靠的智能合约。这将减少出现意外行为或漏洞的机会。"

#: src/ch99-03-security-considerations.md:11
msgid "## Disclaimer"
msgstr "## 免责声明"

#: src/ch99-03-security-considerations.md:13
msgid "This chapter does not provide an exhaustive list of all possible security issues, and it does not guarantee that your contracts will be completely secure."
msgstr "本章并未提供所有可能的安全问题的详尽列表，也不能保证您的合约完全安全。"

#: src/ch99-03-security-considerations.md:15
msgid "If you are developing smart contracts for production use, it is highly recommended to conduct external audits performed by security experts."
msgstr "如果您正在开发用于实际生产环境中的智能合约，强烈建议由安全专家对其进行第三方审计。"

#: src/ch99-03-security-considerations.md:17
msgid "## Mindset"
msgstr "## 安全思维"

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by rust. It is designed in a way that force you to cover all possible cases. Security issues on Starknet mostly arise from the way smart "
"contracts flows are designed, not much from the language itself."
msgstr "Cairo 是一种受到 Rust 启发的高度安全的语言。它的设计方式强制你覆盖所有可能的情况。在 Starknet 上的安全问题主要源于智能合约流程的设计，而非语言本身。"

#: src/ch99-03-security-considerations.md:21
msgid "Adopting a security mindset is the initial step in writing secure smart contracts. Try to always consider all possible scenarios when writing code."
msgstr "采用安全思维是编写安全智能合约的第一步。在编写代码时，尽量始终考虑所有可能的场景。"

#: src/ch99-03-security-considerations.md:23
msgid "### Viewing smart contract as Finite State Machines"
msgstr "### 将智能合约视为有限状态机"

#: src/ch99-03-security-considerations.md:25
msgid "Transactions in smart contracts are atomic, meaning they either succeed or fail without making any changes."
msgstr "智能合约中的交易是原子性的，这意味着它们要么成功，要么失败且不发生任何变化。"

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial states defined by the constructor constraints, and external function represents a set of possible state "
"transitions. A transaction is nothing more than a state transition."
msgstr "将智能合约视为状态机：它们有一组由构造函数约束定义的初始状态，而外部函数表示一组可能的状态转换。所谓交易也不过是一个状态转换。"

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert` or `panic` functions can be used to validate conditions before performing specific actions. You can learn more about these on the [Unrecoverable Errors with panic](./"
"ch10-01-unrecoverable-errors-with-panic.md) page."
msgstr "`assert` 或 `panic` 函数可以用于在执行特定操作之前验证条件。您可以在[无法恢复的错误与panic](./ch10-01-unrecoverable-errors-with-panic.md)页面上了解更多信息。"

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr "这些验证会包括："

#: src/ch99-03-security-considerations.md:33
msgid ""
"- Inputs provided by the caller\n"
"- Execution requirements\n"
"- Invariants (conditions that must always be true)\n"
"- Return values from other function calls"
msgstr ""
"- 调用者提供的输入参数\n"
"- 执行要求\n"
"- 不变量（必须始终为真的条件）\n"
"- 其他函数调用的返回值"

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert` function to validate that a user has enough funds to perform a withdraw transaction. If the condition is not met, the transaction will fail "
"and the state of the contract will not change."
msgstr "例如，您可以使用 `assert` 函数来验证用户是否具有足够的资金执行提款交易。如果条件不满足，交易将失败，并且合约的状态不会发生变化。"

#: src/ch99-03-security-considerations.md:40
msgid ""
"```rust,noplayground\n"
"    impl Contract of IContract<ContractState> {\n"
"        fn withdraw(ref self: ContractState, amount: u256) {\n"
"            let current_balance = self.balance.read();\n"
"\n"
"            assert(self.balance.read() >= amount, 'Insufficient funds');\n"
"\n"
"            self.balance.write(current_balance - amount);\n"
"        }\n"
"```"
msgstr ""
"```rust,noplayground\n"
"    impl Contract of IContract<ContractState> {\n"
"        fn withdraw(ref self: ContractState, amount: u256) {\n"
"            let current_balance = self.balance.read();\n"
"\n"
"            assert(self.balance.read() >= amount, 'Insufficient funds');\n"
"\n"
"            self.balance.write(current_balance - amount);\n"
"        }\n"
"```"

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly define the boundaries of possible state transitions for each function in your smart contract. These "
"checks ensure that the behavior of the contract stays within the expected limits."
msgstr "使用这些函数来进行条件检查，添加一���有助于清晰地定义智能合约中每个函数可能的状态转换的边界的约束。这些检查确保合约的行为保持在预期范围内。"

#: src/ch99-03-security-considerations.md:53
msgid "## Recommendations"
msgstr "## 建议"

#: src/ch99-03-security-considerations.md:55
msgid "### Checks Effects Interactions Pattern"
msgstr "### 检查-效果-交互 模式"

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to prevent reentrancy attacks on Ethereum. While reentrancy is harder to achieve in Starknet, it is still "
"recommended to use this pattern in your smart contracts."
msgstr "检查-效果-交互模式是一种常见的设计模式，用于防止以太坊上的重入攻击。尽管在 Starknet 上更难实现重入攻击，但仍建议在智能合约中使用这种模式。"

#: src/ch99-03-security-considerations.md:59
msgid "<!-- TODO add reference to the reentrancy CairoByExample page -->"
msgstr "<!-- TODO add reference to the reentrancy CairoByExample page -->"

#: src/ch99-03-security-considerations.md:61
msgid "The pattern consists of following a specific order of operations in your functions:"
msgstr "该模式由在函数中按照特定的操作顺序进行操作来实现："

#: src/ch99-03-security-considerations.md:63
msgid ""
"1. **Checks**: Validate all conditions and inputs before performing any state changes.\n"
"2. **Effects**: Perform all state changes.\n"
"3. **Interactions**: All external calls to other contracts should be made at the end of the function."
msgstr ""
"1. **Checks(检查)**: 在执行任何状态更改之前，验证所有条件和输入。\n"
"2. **Effects(效果)**: 执行所有状态更改。\n"
"3. **Interactions(交互)**: 所有对其他合约的外部调用应在函数的最后进行。"

#: src/ch99-03-security-considerations.md:67
msgid "### Access control"
msgstr "### 访问控制"

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or resources. It is a common security mechanism used to prevent unauthorized access to sensitive information "
"or actions. In smart contracts, some functions may often be restricted to specific users or roles."
msgstr "访问控制是限制对特定功能或资源的访问的过程。它是一种常见的安全机制，用于防止未经授权的敏感信息访问或操作。在智能合约中，某些函数可能经常需要被限制为特定的用户或角色使用。"

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. This pattern consists of defining a set of roles and assigning them to specific users. Each function can "
"then be restricted to specific roles."
msgstr "您可以使用访问控制模式来轻松管理权限。该模式包括定义一组不同权限角色，并给不同用户分配对应的角色。每个函数都可限制为特定的角色才可访问。"

#: src/ch99-03-security-considerations.md:73
msgid ""
"```rust,noplayground\n"
"#[starknet::contract]\n"
"mod access_control_contract {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    trait IContract<TContractState> {\n"
"        fn is_owner(self: @TContractState) -> bool;\n"
"        fn is_role_a(self: @TContractState) -> bool;\n"
"        fn only_owner(self: @TContractState);\n"
"        fn only_role_a(self: @TContractState);\n"
"        fn only_allowed(self: @TContractState);\n"
"        fn set_role_a(ref self: TContractState, _target: ContractAddress, _active: bool);\n"
"        fn role_a_action(ref self: ContractState);\n"
"        fn allowed_action(ref self: ContractState);\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Role 'owner': only one address\n"
"        owner: ContractAddress,\n"
"        // Role 'role_a': a set of addresses\n"
"        role_a: LegacyMap::<ContractAddress, bool>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    // Guard functions to check roles\n"
"\n"
"    impl Contract of IContract<ContractState> {\n"
"        #[inline(always)]\n"
"        fn is_owner(self: @ContractState) -> bool {\n"
"            self.owner.read() == get_caller_address()\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn is_role_a(self: @ContractState) -> bool {\n"
"            self.role_a.read(get_caller_address())\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_owner(self: @ContractState) {\n"
"            assert(Contract::is_owner(self), 'Not owner');\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_role_a(self: @ContractState) {\n"
"            assert(Contract::is_role_a(self), 'Not role A');\n"
"        }\n"
"\n"
"        // You can easily combine guards to perform complex checks\n"
"        fn only_allowed(self: @ContractState) {\n"
"            assert(Contract::is_owner(self) || Contract::is_role_a(self), 'Not allowed');\n"
"        }\n"
"\n"
"        // Functions to manage roles\n"
"\n"
"        fn set_role_a(ref self: ContractState, _target: ContractAddress, _active: bool) {\n"
"            Contract::only_owner(@self);\n"
"            self.role_a.write(_target, _active);\n"
"        }\n"
"\n"
"        // You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
"\n"
"        fn role_a_action(ref self: ContractState) {\n"
"            Contract::only_role_a(@self);\n"
"        // ...\n"
"        }\n"
"\n"
"        fn allowed_action(ref self: ContractState) {\n"
"            Contract::only_allowed(@self);\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,noplayground\n"
"#[starknet::contract]\n"
"mod access_control_contract {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    trait IContract<TContractState> {\n"
"        fn is_owner(self: @TContractState) -> bool;\n"
"        fn is_role_a(self: @TContractState) -> bool;\n"
"        fn only_owner(self: @TContractState);\n"
"        fn only_role_a(self: @TContractState);\n"
"        fn only_allowed(self: @TContractState);\n"
"        fn set_role_a(ref self: TContractState, _target: ContractAddress, _active: bool);\n"
"        fn role_a_action(ref self: ContractState);\n"
"        fn allowed_action(ref self: ContractState);\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Role 'owner': only one address\n"
"        owner: ContractAddress,\n"
"        // Role 'role_a': a set of addresses\n"
"        role_a: LegacyMap::<ContractAddress, bool>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    // Guard functions to check roles\n"
"\n"
"    impl Contract of IContract<ContractState> {\n"
"        #[inline(always)]\n"
"        fn is_owner(self: @ContractState) -> bool {\n"
"            self.owner.read() == get_caller_address()\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn is_role_a(self: @ContractState) -> bool {\n"
"            self.role_a.read(get_caller_address())\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_owner(self: @ContractState) {\n"
"            assert(Contract::is_owner(self), 'Not owner');\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_role_a(self: @ContractState) {\n"
"            assert(Contract::is_role_a(self), 'Not role A');\n"
"        }\n"
"\n"
"        // You can easily combine guards to perform complex checks\n"
"        fn only_allowed(self: @ContractState) {\n"
"            assert(Contract::is_owner(self) || Contract::is_role_a(self), 'Not allowed');\n"
"        }\n"
"\n"
"        // Functions to manage roles\n"
"\n"
"        fn set_role_a(ref self: ContractState, _target: ContractAddress, _active: bool) {\n"
"            Contract::only_owner(@self);\n"
"            self.role_a.write(_target, _active);\n"
"        }\n"
"\n"
"        // You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
"\n"
"        fn role_a_action(ref self: ContractState) {\n"
"            Contract::only_role_a(@self);\n"
"        // ...\n"
"        }\n"
"\n"
"        fn allowed_action(ref self: ContractState) {\n"
"            Contract::only_allowed(@self);\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch99-03-security-considerations.md:155
msgid "### Static analysis tool"
msgstr "### 静态分析工具"

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its execution, focusing on its structure, syntax, and properties. It involves analyzing the source code to identify "
"potential issues, vulnerabilities, or violations of specified rules."
msgstr "静态分析指的是在不执行代码的情况下对其进行检查的过程，重点关注其结构、语法和属性。它涉及到分析源代码，以识别潜在的问题、漏洞或违反特定规则的行为。"

#: src/ch99-03-security-considerations.md:159
msgid "By defining rules, such as coding conventions or security guidelines, developers can utilize static analysis tools to automatically check the code against these standards."
msgstr "通过定义规则，例如编码规范或安全指南，开发人员可以使用静态分析工具自动检查代码是否符合这些标准。"

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr "参考文献："

#: src/ch99-03-security-considerations.md:163
msgid ""
"- [Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)\n"
"- [Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""
"- [Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)\n"
"- [Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"

#: src/ch99-03-security-considerations.md:166
msgid "<footer id=\"last-change\">Last change: 2023-11-08</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-08</footer>"

#: src/appendix-00.md:1
msgid "# Appendix"
msgstr "# 附录"

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in your\n"
"Cairo journey."
msgstr "以下章节包含的参考资料可能对您的Cairo之旅有所帮助。"

#: src/appendix-00.md:6
msgid "<footer id=\"last-change\">Last change: 2023-04-01</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-04-01</footer>"

#: src/appendix-01-keywords.md:1
msgid "## Appendix A: Keywords"
msgstr "## 附录 A：关键字"

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future\n"
"use by the Cairo language."
msgstr "下面的列表包含了为当前或未来保留的Cairo 语言的关键字。"

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr "有两个关键字类别："

#: src/appendix-01-keywords.md:8
msgid ""
"- strict\n"
"- reserved"
msgstr ""
"- 严格（strict）关键字\n"
"- 保留（reserved）关键字"

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While their names are not reserved,\n"
"they are not recommended to be used as names of any items to follow good practices."
msgstr "还有第三类，是来自核心库的函数。虽然它们并不是保留关键字，但以遵循惯例不建议将其用作任何项的标识符。"

#: src/appendix-01-keywords.md:16
msgid "### Strict keywords"
msgstr "### 严格关键字"

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts.\n"
"They cannot be used as names of any items."
msgstr ""
"这些关键词只能在其应该被使用的上下文中使用。\n"
"因此，这些关键字不能被用作标识符。"

#: src/appendix-01-keywords.md:21
msgid ""
"- `as` - Rename import\n"
"- `break` - Exit a loop immediately\n"
"- `const` - Define constant items\n"
"- `continue` - Continue to the next loop iteration\n"
"- `else` - Fallback for `if` and `if let` control flow constructs\n"
"- `enum` - Define an enumeration\n"
"- `extern` - Function defined at the compiler level using hint available at cairo1 level with this declaration\n"
"- `false` - Boolean false literal\n"
"- `fn` - Define a function\n"
"- `if` - Branch based on the result of a conditional expression\n"
"- `impl` - Implement inherent or trait functionality\n"
"- `implicits` - Special kind of function parameters that are required to perform certain actions\n"
"- `let` - Bind a variable\n"
"- `loop` - Loop unconditionally\n"
"- `match` - Match a value to patterns\n"
"- `mod` - Define a module\n"
"- `mut` - Denote variable mutability\n"
"- `nopanic` - Functions marked with this notation mean that the function will never panic.\n"
"- `of` - Implementation a trait\n"
"- `ref` - Parameter passed implicitly returned at the end of a function\n"
"- `return` - Return from function\n"
"- `struct` - Define a structure\n"
"- `trait` - Define a trait\n"
"- `true` - Boolean true literal\n"
"- `type` - Define a type alias\n"
"- `use` - Bring symbols into scope"
msgstr ""
"- `as` - 重命名导入\n"
"- `break` - 立即退出一个循环\n"
"- `const` - 定义常量项\n"
"- `continue` - 继续进行下一个循环迭代\n"
"- `else` - `if`和`if let`控制流结构的 fallback\n"
"- `enum` - 定义一个枚举项\n"
"- `extern` - 于编译器层级使用此声明来表示此函数可使用Cairo1等级的hint\n"
"- `false` - 布尔字面值假\n"
"- `fn` - 定义一个函数\n"
"- `if` - 基于条件表达式的结果分支\n"
"- `impl` - 实现自有或 ‘trait’ 功能\n"
"- `implicits` - 执行某些动作所需的特殊类型的函数参数\n"
"- `let` - 绑定一个变量\n"
"- `loop` -无条件地循环\n"
"- `match` - 模式匹配\n"
"- `mod` - 定义一个模块\n"
"- `mut` - 表示变量的可变性\n"
"- `nopanic` - 用这个符号标记的函数意味着该函数永远不会panic\n"
"- `of` - 实现trait\n"
"- `ref`- 通过引用绑定\n"
"- `return` - 从函数返回\n"
"- `struct` - 定义一个结构体\n"
"- `trait` - 定义一个trait\n"
"- `true` - 布尔字面值真\n"
"- `type` - 定义一个类型的别名\n"
"- `use` - 引入外部空间的符号"

#: src/appendix-01-keywords.md:50
msgid "### Reserved keywords"
msgstr "### 保留关键字"

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use.\n"
"They have the same restrictions as strict keywords.\n"
"The reasoning behind this is to make current programs forward compatible with future versions of\n"
"Cairo by forbidding them to use these keywords."
msgstr ""
"这些关键字还没有被使用，但它们被保留下来供将来使用。\n"
"它们与严格关键字有同样的限制。\n"
"禁止使用这些关键字的原因是为了可以使现在的程序向前兼容新版本的Cairo语言。"

#: src/appendix-01-keywords.md:57
msgid ""
"- `Self`\n"
"- `assert`\n"
"- `do`\n"
"- `dyn`\n"
"- `for`\n"
"- `hint`\n"
"- `in`\n"
"- `macro`\n"
"- `move`\n"
"- `pub`\n"
"- `static_assert`\n"
"- `self`\n"
"- `static`\n"
"- `super`\n"
"- `try`\n"
"- `typeof`\n"
"- `unsafe`\n"
"- `where`\n"
"- `while`\n"
"- `with`\n"
"- `yield`"
msgstr ""
"- `Self`\n"
"- `assert`\n"
"- `do`\n"
"- `dyn`\n"
"- `for`\n"
"- `hint`\n"
"- `in`\n"
"- `macro`\n"
"- `move`\n"
"- `pub`\n"
"- `static_assert`\n"
"- `self`\n"
"- `static`\n"
"- `super`\n"
"- `try`\n"
"- `typeof`\n"
"- `unsafe`\n"
"- `where`\n"
"- `while`\n"
"- `with`\n"
"- `yield`"

#: src/appendix-01-keywords.md:81
msgid "### Built-in functions"
msgstr "### 内置函数"

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that serve a special purpose. We will not cover all of them in this book, but using the names of these functions as "
"names of other items is not recommended."
msgstr "Cairo编程语言提供了���个具有特殊用途的函数。我们不会在本书中介绍所有这些函数，但不建议使用这些函数的名称作为任何项的标识符。"

#: src/appendix-01-keywords.md:85
msgid "-`assert` - This function checks a boolean expression, and if it evaluates to false, it triggers the panic function. -`panic` - This function terminates the program."
msgstr "-`assert` - 这个函数检查一个布尔表达式，如果它的值是假的，就会触发panic函数。 -`panic` - 这个函数终止程序。"

#: src/appendix-02-operators-and-symbols.md:1
msgid "# Appendix B: Operators and Symbols"
msgstr "# 附录B：运算符和符号"

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr "本附录包含了Cairo语法的词汇表。"

#: src/appendix-02-operators-and-symbols.md:5
msgid "## Operators"
msgstr "## 运算符"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is "
"overloadable, the relevant trait to use to overload that operator is listed."
msgstr "表B-1包含了开罗的运算符，运算符在上下文中出现的例子和简短的解释，以及该运算符是否可以重载。如果一个运算符是可重载的，则列出了用于重载该运算符的相关特性。"

#: src/appendix-02-operators-and-symbols.md:9
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr "<span class=\"caption\">表B-1：运算符</span>"

#: src/appendix-02-operators-and-symbols.md:11
msgid ""
"| Operator | Example | Explanation | Overloadable? |\n"
"|----------|---------|-------------|---------------|\n"
"| `!` | `!expr` | Bitwise or logical complement | `Not` |\n"
"| `!=` | `expr != expr` | Non-equality comparison | `PartialEq` |\n"
"| `%` | `expr % expr` | Arithmetic remainder | `Rem` |\n"
"| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemEq` |\n"
"| `&` | `expr & expr` | Bitwise AND | `BitAnd` |\n"
"| `&&` | `expr && expr` | Short-circuiting logical AND | |\n"
"| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |\n"
"| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulEq` |\n"
"| `@` | `@var` | Snapshot | |\n"
"| `*` | `*var` | Desnap | |\n"
"| `+` | `expr + expr` | Arithmetic addition | `Add` |\n"
"| `+=` | `var += expr` | Arithmetic addition and assignment | `AddEq` |\n"
"| `,` | `expr, expr` | Argument and element separator | |\n"
"| `-` | `-expr` | Arithmetic negation | `Neg` |\n"
"| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |\n"
"| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubEq` |\n"
"| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |\n"
"| `.` | `expr.ident` | Member access | |\n"
"| `/` | `expr / expr` | Arithmetic division | `Div` |\n"
"| `/=` | `var /= expr` | Arithmetic division and assignment | `DivEq` |\n"
"| `:` | `pat: type`, `ident: type` | Constraints | |\n"
"| `:` | `ident: expr` | Struct field initializer | |\n"
"| `;` | `expr;` | Statement and item terminator | |\n"
"| `<` | `expr < expr` | Less than comparison | `PartialOrd` |\n"
"| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |\n"
"| `=` | `var = expr` | Assignment | |\n"
"| `==` | `expr == expr` | Equality comparison | `PartialEq` |\n"
"| `=>` | `pat => expr` | Part of match arm syntax | |\n"
"| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |\n"
"| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |\n"
"| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |\n"
"| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |\n"
"| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |"
msgstr ""
"| 运算符 | 示例 | 解释 | 是否可重载? |\n"
"|----------|---------|-------------|---------------|\n"
"| `!` | `!expr` | 位或逻辑补码 | `Not` |\n"
"| `!=` | `expr != expr` | 不等于 | `PartialEq` |\n"
"| `%` | `expr % expr` | 算数取余 | `Rem` |\n"
"| `%=` | `var %= expr` | 算数取余并赋值 | `RemEq` |\n"
"| `&` | `expr & expr` | 按位与 | `BitAnd` |\n"
"| `&&` | `expr && expr` | 短路逻辑与 | |\n"
"| `*` | `expr * expr` | 算数乘 | `Mul` |\n"
"| `*=` | `var *= expr` | 算数乘并赋值 | `MulEq` |\n"
"| `@` | `@var` | Snapshot | |\n"
"| `*` | `*var` | Desnap | |\n"
"| `+` | `expr + expr` | 算术加 | `Add` |\n"
"| `+=` | `var += expr` | 算数加并赋值 | `AddEq` |\n"
"| `,` | `expr, expr` | 参数和元素分隔符 | |\n"
"| `-` | `-expr` | 算数负号 | `Neg` |\n"
"| `-` | `expr - expr` | 算数减 | `Sub` |\n"
"| `-=` | `var -= expr` | 算数减并赋值 | `SubEq` |\n"
"| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | 函数与闭包的返回类型 | |\n"
"| `.` | `expr.ident` | 成员访问 | |\n"
"| `/` | `expr / expr` | 算数除 | `Div` |\n"
"| `/=` | `var /= expr` | 算数除并赋值 | `DivEq` |\n"
"| `:` | `pat: type`, `ident: type` | 约束条件 | |\n"
"| `:` | `ident: expr` | 结构体字段初始化器 | |\n"
"| `;` | `expr;` | 语句和条目结束符号 | |\n"
"| `<` | `expr < expr` | 小于比较 | `PartialOrd` |\n"
"| `<=` | `expr <= expr` | 小于等于比较 | `PartialOrd` |\n"
"| `=` | `var = expr` | 赋值 | |\n"
"| `==` | `expr == expr` | 等于比较 | `PartialEq` |\n"
"| `=>` | `pat => expr` | 匹配分支的一部分语法 | |\n"
"| `>` | `expr > expr` | 大于比较 | `PartialOrd` |\n"
"| `>=` | `expr >= expr` | 大于等于比较 | `PartialOrd` |\n"
"| `^` | `expr ^ expr` | 按位异或 | `BitXor` |\n"
"| <code>&vert;</code> | <code>expr &vert; expr</code> | 按位或 | `BitOr` |\n"
"| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | 短路逻辑或 | |"

#: src/appendix-02-operators-and-symbols.md:47
msgid "## Non Operator Symbols"
msgstr "## 非运算符符号"

#: src/appendix-02-operators-and-symbols.md:49
msgid "The following list contains all symbols that are not used as operators; that is, they do not have the same behavior as a function or method call."
msgstr "下面的列表包含了所有不作为运算符使用的符号；也就是说，他们并不像函数调用或方法调用一样表现。"

#: src/appendix-02-operators-and-symbols.md:51
msgid "Table B-2 shows symbols that appear on their own and are valid in a variety of locations."
msgstr "表B-2 展示了以其自身出现以及出现在合法其他各个地方的符号。"

#: src/appendix-02-operators-and-symbols.md:53
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr "<span class=\"caption\">表B-2：独立语法</span>"

#: src/appendix-02-operators-and-symbols.md:55
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `..._u8`, `..._usize`, etc. | Numeric literal of specific type |\n"
"| `'...'` | Short string |\n"
"| `_` | “Ignored” pattern binding; also used to make integer literals readable |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `..._u8`, `..._usize`, 等等。| 指定类型的数值常量 |\n"
"| `'...'` |  短字符串 |\n"
"| `_` |  \"“忽略” 模式绑定；也用于增强整型字面值的可读性 |"

#: src/appendix-02-operators-and-symbols.md:61
msgid "Table B-3 shows symbols that are used within the context of a module hierarchy path to access an item."
msgstr "表B-3 展示了出现在从模块结构到项的路径上下文中的符号。"

#: src/appendix-02-operators-and-symbols.md:63
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr "<span class=\"caption\">表B-3：路径相关语法</span>"

#: src/appendix-02-operators-and-symbols.md:65
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `ident::ident` | Namespace path |\n"
"| `super::path` | Path relative to the parent of the current module |\n"
"| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `ident::ident` | 命名空间路径 |\n"
"| `super::path` | 相对于当前模块的父级路径。\n"
"| `trait::method(...)` | 通过命名定义该方法的trait来消除方法调用的二义性 |"

#: src/appendix-02-operators-and-symbols.md:71
msgid "Table B-4 shows symbols that appear in the context of using generic type parameters."
msgstr "表B-4 展示了出现在泛型类型参数上下文中的符号。"

#: src/appendix-02-operators-and-symbols.md:73
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr "<span class=\"caption\">表 B-4：泛型</span>"

#: src/appendix-02-operators-and-symbols.md:75
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |\n"
"| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish |\n"
"| `fn ident<...> ...` | Define generic function |\n"
"| `struct ident<...> ...` | Define generic structure |\n"
"| `enum ident<...> ...` | Define generic enumeration |\n"
"| `impl<...> ...` | Define generic implementation |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `path<...>` | 为一个类型中的泛型指定具体参数（例如，`Vec<u8>`） |\n"
"| `path::<...>`, `method::<...>` | 为一个泛型、函数或表达式中的方法指定具体参数; 通常被称为Turbofish。\n"
"| `fn ident<...>...` | 泛型函数定义\n"
"| `struct ident<...>...` | 泛型结构体定义\n"
"| `enum ident<...>...` | 泛型枚举定义\n"
"| `impl<...>...` | 定义泛型实现 |"

#: src/appendix-02-operators-and-symbols.md:84
msgid "Table B-5 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item."
msgstr "表B-5展示了在调用或定义宏以及在其上指定属性时的上下文中出现的符号。"

#: src/appendix-02-operators-and-symbols.md:86
msgid "<span class=\"caption\">Table B-5: Macros and Attributes</span>"
msgstr "<span class=\"caption\">表B-5：宏和属性</span>"

#: src/appendix-02-operators-and-symbols.md:88
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `#[meta]` | Outer attribute |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `#[meta]` | 外部属性 |"

#: src/appendix-02-operators-and-symbols.md:92
msgid "Table B-6 shows symbols that create comments."
msgstr "表B-6 展示了创建注释的符号。"

#: src/appendix-02-operators-and-symbols.md:94
msgid "<span class=\"caption\">Table B-6: Comments</span>"
msgstr "<span class=\"caption\">表B-6：注释</span>"

#: src/appendix-02-operators-and-symbols.md:96
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `//` | Line comment |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `//` | 行注释 |"

#: src/appendix-02-operators-and-symbols.md:100
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr "表B-7 展示了出现在使用元组时上下文中的符号。"

#: src/appendix-02-operators-and-symbols.md:102
msgid "<span class=\"caption\">Table B-7: Tuples</span>"
msgstr "<span class=\"caption\">表B-7：元组</span>"

#: src/appendix-02-operators-and-symbols.md:105
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `()` | Empty tuple (aka unit), both literal and type |\n"
"| `(expr)` | Parenthesized expression |\n"
"| `(expr,)` | Single-element tuple expression |\n"
"| `(type,)` | Single-element tuple type |\n"
"| `(expr, ...)` | Tuple expression |\n"
"| `(type, ...)` | Tuple type |\n"
"| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |"
msgstr ""
"| 符号 | 解释 |\n"
"|--------|-------------|\n"
"| `()` | 空元组（又称单元），空元组（亦称单元），即是字面值也是类型 |\n"
"| `(expr)` | 括号表达式 |\n"
"| `(expr,)` | 单元素元组表达式 |\n"
"| `(type,)` | 单元素元组类型 |\n"
"| `(expr, ...)` | 元组表达式\n"
"| `(type, ...)` | 元组类型 |\n"
"| `expr(expr, ...)` | 函数调用表达式；也用于初始化元组`struct`和元组`enum`变体"

#: src/appendix-02-operators-and-symbols.md:115
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr "表B-8展示了使用大括号的上下文。"

#: src/appendix-02-operators-and-symbols.md:117
msgid "<span class=\"caption\">Table B-8: Curly Brackets</span>"
msgstr "<span class=\"caption\">表B-8：大括号</span>"

#: src/appendix-02-operators-and-symbols.md:119
msgid ""
"| Context | Explanation |\n"
"|---------|-------------|\n"
"| `{...}` | Block expression |\n"
"| `Type {...}` | `struct` literal |"
msgstr ""
"| 上下文 | 解释 |\n"
"|---------|-------------|\n"
"| `{...}` | 块表达式 |\n"
"| `Type {...}` | `struct`字面值 |"

#: src/appendix-02-operators-and-symbols.md:124
msgid "<footer id=\"last-change\">Last change: 2023-07-20</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-07-20</footer>"

#: src/appendix-03-derivable-traits.md:1
msgid "# Appendix C: Derivable Traits"
msgstr "# 附录C: 可派生的 Trait"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which you can apply to a struct or enum definition. The `derive` attribute generates code to implement a "
"default trait on the type you’ve annotated with the `derive` syntax."
msgstr "在本书的各个部分中，我们讨论了可应用于结构体和枚举定义的 `derive` 属性。`derive` 属性会在使用 `derive` 语法标记的类型上生成对应 trait 的默认实现的代码。"

#: src/appendix-03-derivable-traits.md:5
msgid "In this appendix, we provide a comprehensive reference detailing all the traits in the standard library compatible with the `derive` attribute."
msgstr "在这个附录中，我们提供了一个全面的参考，详细介绍了标准库中所有与`derive`属性兼容的trait。"

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that can be implemented on your types using `derive`. Other traits defined in the standard library don’t have "
"sensible default behavior, so it’s up to you to implement them in the way that makes sense for what you’re trying to accomplish."
msgstr ""
"这里列出的 trait 是仅有的在标准库中定义且能通过 `derive` 在类型上实现。标准库中定义的其它 trait 不能通过 `derive` 在类型上实现。这些 trait 不存在有意义的默认行为，所以由你负责以合理的"
"方式实现它们。"

#: src/appendix-03-derivable-traits.md:9
msgid ""
"The list of derivable traits provided in this appendix does not encompass all possibilities: external libraries can implement `derive` for their own traits, expanding the list of "
"traits compatible with `derive`."
msgstr "本附录所提供的可派生 trait 列表并不全面：库可以为其自己的 trait 实现 `derive`，可以使用 `derive` 的 trait 列表事实上是无限的。"

#: src/appendix-03-derivable-traits.md:11
msgid "## PartialEq for equality comparison"
msgstr "## 等值比较的 PartialEq 和 Eq"

#: src/appendix-03-derivable-traits.md:13
msgid "The `PartialEq` trait allows for comparison between instances of a type for equality, thereby enabling the == and != operators."
msgstr "`PartialEq` trait允许在一个类型的实例之间进行等值比较，从而实现 == 和 != 运算符。"

#: src/appendix-03-derivable-traits.md:15
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all fields are equal, and the instances are not equal if any fields are not equal. When derived on enums, each "
"variant is equal to itself and not equal to the other variants."
msgstr "当`PartialEq`在结构上派生时，只有当所有字段都相等时，两个实例才相等，如果任何字段不相等，实例就不相等。当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。"

#: src/appendix-03-derivable-traits.md:19
msgid ""
"```rust\n"
"#[derive(PartialEq, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = A {\n"
"        item: 2\n"
"    };\n"
"    assert(first_struct == second_struct, 'Structs are different');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(PartialEq, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = A {\n"
"        item: 2\n"
"    };\n"
"    assert(first_struct == second_struct, 'Structs are different');\n"
"}\n"
"```"

#: src/appendix-03-derivable-traits.md:36
msgid "## Clone and Copy for Duplicating Values"
msgstr "## 复制值的 Clone 和 Copy"

#: src/appendix-03-derivable-traits.md:38
msgid "The `Clone` trait provides the functionality to explicitly create a deep copy of a value."
msgstr "`Clone` trait 提供了明确创建一个值的深度拷贝的功能。"

#: src/appendix-03-derivable-traits.md:40
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone on each of the type's components. This means all the fields or values in the type must also implement "
"`Clone` to derive `Clone`."
msgstr "派生 `Clone` 实现了 `clone`  方法，其为整个的类型实现时，在类型的每一部分上调用了`clone`  方法。这意味着类型中所有字段或值也必须实现了 `Clone`，这样才能够派生 `Clone`。"

#: src/appendix-03-derivable-traits.md:44
msgid ""
"```rust\n"
"use clone::Clone;\n"
"\n"
"#[derive(Clone, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct.clone();\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use clone::Clone;\n"
"\n"
"#[derive(Clone, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct.clone();\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"}\n"
"```"

#: src/appendix-03-derivable-traits.md:61
msgid "The `Copy` trait allows for the duplication of values. You can derive `Copy` on any type whose parts all implement `Copy`."
msgstr "`Copy` trait 允许你复制值而不需要额外的代码。你可以在任何部分都实现了`Copy`的类型上派生`Copy`。"

#: src/appendix-03-derivable-traits.md:65
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct;\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents firs_struct from moving into second_struct\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct;\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents firs_struct from moving into second_struct\n"
"}\n"
"```"

#: src/appendix-03-derivable-traits.md:81
msgid "## Serializing with Serde"
msgstr "## 用Serde进行序列化"

#: src/appendix-03-derivable-traits.md:83
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` functions for data structures defined in your crate. It allows you to transform your structure into an array "
"(or the opposite)."
msgstr "`Serde`为你的crate中定义的数据结构提供`serialize`和`deserialize`函数的trait实现。它允许你将你的结构体转化为数组（或相反）。"

#: src/appendix-03-derivable-traits.md:87
msgid ""
"```rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let serialized = first_struct.serialize(ref output_array);\n"
"    panic(output_array);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let serialized = first_struct.serialize(ref output_array);\n"
"    panic(output_array);\n"
"}\n"
"```"

#: src/appendix-03-derivable-traits.md:108
msgid "Output:"
msgstr "输出:"

#: src/appendix-03-derivable-traits.md:110
msgid ""
"```Bash\n"
"Run panicked with [2 (''), 99 ('c'), ].\n"
"```"
msgstr ""
"```Bash\n"
"Run panicked with [2 (''), 99 ('c'), ].\n"
"```"

#: src/appendix-03-derivable-traits.md:114
msgid "We can see here that our struct A has been serialized into the output array."
msgstr "我们在这里可以看到，我们的结构体A已经被序列化到输出数组中。"

#: src/appendix-03-derivable-traits.md:116
msgid "Also, we can use `deserialize` function to convert the serialized array back into our A struct."
msgstr "另外，我们可以使用`deserialize`函数将序列化的数组转换回我们的结构体A。"

#: src/appendix-03-derivable-traits.md:120
msgid ""
"```rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"use option::OptionTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let mut serialized = first_struct.serialize(ref output_array);\n"
"    let mut span_array = output_array.span();\n"
"    let deserialized_struct: A = Serde::<A>::deserialize(ref span_array).unwrap();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"use option::OptionTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let mut serialized = first_struct.serialize(ref output_array);\n"
"    let mut span_array = output_array.span();\n"
"    let deserialized_struct: A = Serde::<A>::deserialize(ref span_array).unwrap();\n"
"}\n"
"```"

#: src/appendix-03-derivable-traits.md:143
msgid ""
"Here we are converting a serialized array span back to the struct A. `deserialize` returns an `Option` so we need to unwrap it. When using deserialize we also need to specify the "
"type we want to deserialize into."
msgstr "这里我们要把一个序列化的数组span转换回结构体A。`deserialize`返回一个`Option`，所以我们需要把它解包。当使用deserialize时，我们还需要指定我们想要反序列化的类型。"

#: src/appendix-03-derivable-traits.md:145
msgid "## Drop and Destruct"
msgstr "## Drop 和 Destruct"

#: src/appendix-03-derivable-traits.md:147
msgid ""
"When moving out of scope, variables need to be moved first. This is where the `Drop` trait intervenes. You can find more details about its usage [here](ch04-01-what-is-ownership."
"md#the-drop-trait)."
msgstr "当离开作用域时，需要先移动变量。这就是 `Drop` trait起作用的地方。你可以在[这里](ch04-01-what-is-ownership.md#the-drop-trait)找到更多关于它的用法的细节。"

#: src/appendix-03-derivable-traits.md:149
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling manually the `squash` method on each of them can be quickly redundant. `Destruct` trait allows Dictionaries "
"to be automatically squashed when they get out of scope. You can also find more information about `Destruct` [here](ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""
"此外，字典在离开作用域之前需要被squash（压缩）。在每个字典上手动调用`squash`方法很快就不再是必须操作。`Destruct` 特性允许字典在超出范围时被自动压缩。你也可以在[这里](ch04-01-what-is-"
"ownership.md#the-destruct-trait) 找到更多关于`Destruct`的信息。"

#: src/appendix-03-derivable-traits.md:151
msgid "## Store"
msgstr "## 存储"

#: src/appendix-03-derivable-traits.md:153
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet contract requires the `Store` trait to be implemented for this type. You can automatically derive the `store` "
"trait for all structs that do not contain complex types like Dictionaries or Arrays."
msgstr "在Starknet合约中的存储变量中存储用户定义的结构体需要为该类型实现 `Store` trait 。您可以为所有不包含字典或数组等复杂类型的结构体自动派生 `Store` trait 。"

#: src/appendix-03-derivable-traits.md:157
msgid ""
"```rust, noplayground\n"
"#[starknet::contract]\n"
"mod contract {\n"
"    #[derive(Drop, starknet::Store)]\n"
"    struct A {\n"
"        item_one: felt252,\n"
"        item_two: felt252,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        my_storage: A,\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust, noplayground\n"
"#[starknet::contract]\n"
"mod contract {\n"
"    #[derive(Drop, starknet::Store)]\n"
"    struct A {\n"
"        item_one: felt252,\n"
"        item_two: felt252,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        my_storage: A,\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/appendix-03-derivable-traits.md:174
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the Store trait. This `struct A` is subsequently used\n"
"as a storage variable in the contract."
msgstr "在这里，我们演示了一个派生了Store trait的`struct A`的实现。这个 `struct A`随后被用作合约中的存储变量。"

#: src/appendix-03-derivable-traits.md:177
msgid "## PartialOrd and Ord for Ordering Comparisons"
msgstr "## 用于排序比较的PartialOrd和Ord"

#: src/appendix-03-derivable-traits.md:179
msgid "In addition to the `PartialEq` trait, the standard library also provides the `PartialOrd` and `Ord` traits to compare values for ordering."
msgstr "除了 `PartialEq` trait，标准库还提供了 `PartialOrd` 和 `Ord` trait，用于值排序中的比较。"

#: src/appendix-03-derivable-traits.md:181
msgid "The `PartialOrd` trait allows for comparison between instances of a type for ordering, thereby enabling the <, <=, >, and >= operators."
msgstr "`PartialOrd`trait允许在一个类型的实例之间进行排序比较，从而使得我们可以使用 <、<=、> 和 >= 操作符。"

#: src/appendix-03-derivable-traits.md:183
msgid "When `PartialOrd` is derived on structs, two instances are ordered by comparing each field in turn."
msgstr "当在结构体上派生 `PartialOrd` 时，两个实例通过依次比较每个字段来排序。"

#: src/appendix-04-useful-development-tools.md:1
msgid "## Appendix D - Useful Development Tools"
msgstr "## 附录D - 实用开发工具"

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo\n"
"project provides. We’ll look at automatic formatting, quick ways to apply\n"
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"在本附录中，我们将提到由Cairo项目提供的一些有用的开发工具。\n"
"我们将看看自动格式化、快速应用警告修正，linter，以及与IDE的整合。"

#: src/appendix-04-useful-development-tools.md:7
msgid "### Automatic Formatting with `scarb fmt`"
msgstr "### 用`scarb fmt`自动格式化"

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command.\n"
"If you're using the cairo binaries directly, you can run `cairo-format` instead.\n"
"Many collaborative projects use `scarb fmt` to prevent arguments about which\n"
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"Scarb 项目可以使用 `scarb fmt` 命令进行格式化。\n"
"如果直接使用 cairo 二进制文件，可以运行 `cairo-format` 代替。\n"
"在大多多人合作项目里，每个成员都会使用`scarb fmt` 以防止在编写Cairo时争论使用哪种代码风格。"

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr "要格式化任何Cairo项目，请输入以下命令："

#: src/appendix-04-useful-development-tools.md:16
msgid "### IDE Integration Using `cairo-language-server`"
msgstr "### 使用`cairo-language-server`的IDE集成"

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the\n"
"[`cairo-language-server`][cairo-language-server]<!-- ignore -->. This tool is a set of\n"
"compiler-centric utilities that speaks the [Language Server Protocol][lsp]<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to\n"
"communicate with each other. Different clients can use `cairo-language-server`, such as\n"
"[the Cairo extension for Visual Studio Code][vscode-cairo]."
msgstr ""
"为了帮助IDE整合，Cairo社区建议使用\n"
"[`cairo-language-server`][cairo-language-server]<!-- ignore -->。这是\n"
"[Language Server Protocol][lsp]<!-- ignore -->的一套以编译器为中心的实用工具。\n"
"它是用于IDE和编程语言互相通信的规范。不同的客户端都可以使用`cairo-language-server`，例如\n"
"[Visual Studio Code的Cairo扩展][vscode-cairo]。"

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` [page][vscode-cairo]<!-- ignore -->\n"
"to install it on VSCode. You will get abilities such as autocompletion, jump to\n"
"definition, and inline errors."
msgstr ""
"请访问 `vscode-cairo` [page][vscode-cairo]<!-- 忽略 -->\n"
"将其安装到 VSCode 上。您将获得自动完成、跳转到\n"
"定义和内联错误等功能。"

#: src/appendix-04-useful-development-tools.md:34
msgid "> Note: If you have Scarb installed, it should work out of the box with the Cairo VSCode extension, without a manual installation of the language server."
msgstr "> 注意：如果你已安装 Scarb，则无需手动安装语言服务器，即可使用Cairo VSCode 扩展。"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "## Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr "## 附录 E - 编写合约所需最常见的类型 和Trait以及Cairo Prelude"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "### Prelude"
msgstr "### Prelude"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data\n"
"types, and traits that are automatically brought into scope of every module in a\n"
"Cairo crate without needing explicit import statements. Cairo's prelude provides\n"
"the basic building blocks developers need to start Cairo programs and writing\n"
"smart contracts."
msgstr ""
"Cairo预设是一个常用模块、函数、数据类型和特性的集合，它们会自动引入到Cairo crate中每个模块的作用域中，无需显式的导入语句。Cairo的预设提供了开发者开始编写Cairo程序和智能合约所需的基本"
"构建块。"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the\n"
"[lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.2.0/corelib/src/lib.cairo)\n"
"file of the corelib crate and contains Cairo's primitive data types, traits,\n"
"operators, and utility functions. This includes: Data types - felts, bools,\n"
"arrays, dicts, etc. Traits - behaviors for arithmetic, comparison, serialization\n"
"Operators - arithmetic, logical, bitwise Utility functions - helpers for arrays,\n"
"maps, boxing, etc. The core library prelude delivers the fundamental programming\n"
"constructs and operations needed for basic Cairo programs, without requiring the\n"
"explicit import of elements. Since the core library prelude is automatically\n"
"imported, its contents are available for use in any Cairo crate without explicit\n"
"imports. This prevents repetition and provides a better devX. This is what\n"
"allows you to use `ArrayTrait::append()` or the `Default` trait without bringing\n"
"them explicitly into scope."
msgstr ""
"核心库预设定义在 corelib crate 的[lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.2.0/corelib/src/lib.cairo)文件中，包含了Cairo的基本数据类型、traits、操作符和实用函数。其"
"中包括：\n"
"- 数据类型：felts、bools、arrays、dicts等。\n"
"- Traits：用于算术、比较、序列化的行为。\n"
"- 操作符：算术、逻辑、位运算符。\n"
"- 实用函数：用于数组、映射、包装等的辅助函数。\n"
"核心库预设提供了基本的Cairo程序所需的基本编程构造和操作，无需显式导入元素。由于核心库预设被自动导入，其内容可在任何Cairo crate中使用，无需显式导入。这避免了重复工作，提供了更好的开发"
"体验。这就是为什么你可以在不显式引入的情况下使用 `ArrayTrait::append()` 或 `Default` 特性的原因。"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid "### List of common types and traits"
msgstr "### 常见类型和trait列表"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"The following section provides a brief overview of commonly used types and\n"
"traits when developing Cairo programs. Most of these are included in the\n"
"prelude and not required to be imported explicitly - but not all of them."
msgstr "以下部分简要概述了在开发Cairo程序时常用的类型和特性。大多数这些都包含在预设中，无需显式导入 - 但并非全部。"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid ""
"| Import                    | Path                                                  | "
"Usage                                                                                                                                                                                  "
"|\n"
"| ------------------------- | ----------------------------------------------------- | "
"-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
"|\n"
"| `OptionTrait`             | `core::option::OptionTrait`                           | `OptionTrait<T>` defines a set of methods required to manipulate optional "
"value.                                                                                                       |\n"
"| `ResultTrait`             | `core::result::ResultTrait`                           | `ResultTrait<T, E>` Type for Starknet contract address, a value in the range [0, 2 \\*\\* "
"251).                                                                                          |\n"
"| `ContractAddress`         | `starknet::ContractAddress`                           | `ContractAddress` is a type to represent the smart contract "
"address                                                                                                                    |\n"
"| `ContractAddressZeroable` | `starknet::contract_address::ContractAddressZeroable` | `ContractAddressZeroable` is the implementation of the trait `Zeroable` for the "
"`ContractAddress` type. It is required to check whether a value of `t:ContractAddress` is zero or not. |\n"
"| `contract_address_const`  | `starknet::contract_address_const`                    | The `contract_address_const!` it's a function that allows instantiating constant contract "
"address values.                                                                              |\n"
"| `Into`                    | `traits::Into;`                                       | `Into<T>` is a trait used for conversion between types. If there is an implementation of Into<T,"
"S> for the types T and S, you can convert T into S.                                    |\n"
"| `TryInto`                 | `traits::TryInto;`                                    | `TryInto<T>` is a trait used for conversion between types.If there is an implementation of "
"TryInto<T,S> for the types T and S, you can convert T into S.                               |\n"
"| `get_caller_address`      | `starknet::get_caller_address`                        | `get_caller_address()` is a function that returns the address of the caller of the contract. It "
"can be used to identify the caller of a contract function.                             |\n"
"| `get_contract_address`    | `starknet::info::get_contract_address`                | `get_contract_address()` is a function that returns the address of the current contract. It can "
"be used to obtain the address of the contract being executed.                          |"
msgstr ""
"| Import                    | Path                                                  | "
"Usage                                                                                                                                                                                  "
"|\n"
"| ------------------------- | ----------------------------------------------------- | "
"-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
"|\n"
"| `OptionTrait`             | `core::option::OptionTrait`                           | `OptionTrait<T>` 定义了一组操作可选值所需的方"
"法.                                                                                                       |\n"
"| `ResultTrait`             | `core::result::ResultTrait`                           | `ResultTrait<T, E>` 是用于表示Starknet合约地址的类型，其取值范围为[0, 2 \\*\\* "
"251).                                                                                          |\n"
"| `ContractAddress`         | `starknet::ContractAddress`                           | `ContractAddress` 是一种用于表示智能合约地址的类"
"型                                                                                                                    |\n"
"| `ContractAddressZeroable` | `starknet::contract_address::ContractAddressZeroable` | `ContractAddressZeroable` 是对 `ContractAddress` 类型实现的`Zeroable` trait。它用于检查`t:"
"ContractAddress` 的值是否为零。|\n"
"| `contract_address_const`  | `starknet::contract_address_const`                    | `contract_address_const!` 是一个函数，允许实例化常量合约地址"
"值。                                                                              |\n"
"| `Into`                    | `traits::Into;`                                       | `Into<T>` 是用于类型转换的 trait。如果对类型T和S存在Into<T,S>的实现，那么可以将T转换为"
"S                                    |\n"
"| `TryInto`                 | `traits::TryInto;`                                    | `TryInto<T>` 是用于类型转换的 trait。如果对类型T和S存在TryInto<T,S>的实现，那么可以将T转换为"
"S.                               |\n"
"| `get_caller_address`      | `starknet::get_caller_address`                        | `get_caller_address()` 是一个函数，用于返回调用合约的地址。它可以用于识别合约函数的调用"
"者                             |\n"
"| `get_contract_address`    | `starknet::info::get_contract_address`                | `get_contract_address()` 是一个函数，用于返回当前合约的地址。它可以用于获取正在执行的合约的地"
"址.                          |"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used types\n"
"and traits in contract development. For more details, refer to the official\n"
"documentation and explore the available libraries and frameworks."
msgstr "这并不是一个详尽的列表，但它涵盖了合约开发中一些常用的类型和trait。关于更多的细节，请参考官方文档并参考可用的库以及框架。"

#: src/appendix-06-cairo-binaries.md:1
msgid "# Appendix F: Installing the Cairo binaries"
msgstr "# 附录 F：安装Cairo二进制文件"

#: src/appendix-06-cairo-binaries.md:3
msgid "If you want to have access to the Cairo binaries, for anything that you could not achieve by purely using Scarb you can install them by following the instructions below."
msgstr "如果你想访问Cairo二进制文件，以获取任何仅使用 Scarb 无法实现的功能时，可以按照下面的说明安装它们。"

#: src/appendix-06-cairo-binaries.md:5
msgid "The first step is to install Cairo. We will download Cairo manually, using cairo repository or with an installation script. You’ll need an internet connection for the download."
msgstr ""
"第一步是安装Cairo。我们可以手动下载Cairo（使用Cairo仓库）或使用安装脚本。下载过程需要连接互联网。\n"
"译注：如果你生活在中国大陆，你可能需要一些特殊方法来保证能够顺利安装所有的依赖包。"

#: src/appendix-06-cairo-binaries.md:7
msgid "### Prerequisites"
msgstr "### 先决条件"

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr "首先，你需要安装Rust和Git。"

#: src/appendix-06-cairo-binaries.md:11
msgid ""
"```bash\n"
"# Install stable Rust\n"
"rustup override set stable && rustup update\n"
"```"
msgstr ""
"```bash\n"
"# Install stable Rust\n"
"rustup override set stable && rustup update\n"
"```"

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr "安装[Git](https://git-scm.com/)。"

#: src/appendix-06-cairo-binaries.md:18
msgid "## Installing Cairo with a Script ([Installer](https://github.com/franalgaba/cairo-installer) by [Fran](https://github.com/franalgaba))"
msgstr "## 用脚本安装Cairo（[Installer](https://github.com/franalgaba/cairo-installer) by [Fran](https://github.com/franalgaba))"

#: src/appendix-06-cairo-binaries.md:20
msgid "### Install"
msgstr "### 安装"

#: src/appendix-06-cairo-binaries.md:22
msgid "If you wish to install a specific release of Cairo rather than the latest head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export CAIRO_GIT_TAG=v2.2.0`)."
msgstr "如果你想安装一个特定的Cairo版本，而不是最新版本，可以设置`CAIRO_GIT_TAG`环境变量（比如执行 `export CAIRO_GIT_TAG=v2.2.0` 来设置）。"

#: src/appendix-06-cairo-binaries.md:24
msgid ""
"```bash\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr ""
"```bash\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"

#: src/appendix-06-cairo-binaries.md:28
msgid "After installing, follow [these instructions](#set-up-your-shell-environment-for-cairo) to set up your shell environment."
msgstr "安装完毕后，按照[说明](#set-up-your-shell-environment-for-cairo)来设置你的shell环境。"

#: src/appendix-06-cairo-binaries.md:30
msgid "### Update"
msgstr "### 更新"

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"

#: src/appendix-06-cairo-binaries.md:37
msgid "### Uninstall"
msgstr "### 卸载"

#: src/appendix-06-cairo-binaries.md:39
msgid "Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, just remove it:"
msgstr "Cairo被安装在`$CAIRO_ROOT`（默认：~/.cairo）。要卸载它，只需删除它："

#: src/appendix-06-cairo-binaries.md:41
msgid ""
"```bash\n"
"rm -fr ~/.cairo\n"
"```"
msgstr ""
"```bash\n"
"rm -fr ~/.cairo\n"
"```"

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr "然后从.bashrc中删除这三行："

#: src/appendix-06-cairo-binaries.md:47
msgid ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"
msgstr ""
"```bash\n"
"export PATH=“$HOME/.cairo/target/release:$PATH”\n"
"```"

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr "最后，重新启动你的shell："

#: src/appendix-06-cairo-binaries.md:53
msgid ""
"```bash\n"
"exec $SHELL\n"
"```"
msgstr ""
"```bash\n"
"exec $SHELL\n"
"```"

#: src/appendix-06-cairo-binaries.md:57
msgid "### Set up your shell environment for Cairo"
msgstr "### 为Cairo设置你的shell环境"

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"- Define environment variable `CAIRO_ROOT` to point to the path where\n"
"  Cairo will store its data. `$HOME/.cairo` is the default.\n"
"  If you installed Cairo via Git checkout, we recommend\n"
"  to set it to the same location as where you cloned it.\n"
"- Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""
"- 定义环境变量`CAIRO_ROOT`，以指向Cairo存储自身数据的路径。默认为`$HOME/.cairo`。\n"
"  如果你通过Git checkout安装Cairo，我们建议把它设置到与你Git clone它相同的位置。\n"
"- 将`cairo-*`可执行文件添加到你的`PATH`中，如果还没被自动添加的话"

#: src/appendix-06-cairo-binaries.md:65
msgid "The below setup should work for the vast majority of users for common use cases."
msgstr "下面的设置应该适用于绝大多数用户的一般使用情况。"

#: src/appendix-06-cairo-binaries.md:67
msgid ""
"- For **bash**:\n"
"\n"
"  Stock Bash startup files vary widely between distributions in which of them source\n"
"  which, under what circumstances, in what order and what additional configuration they perform.\n"
"  As such, the most reliable way to get Cairo in all environments is to append Cairo\n"
"  configuration commands to both `.bashrc` (for interactive shells)\n"
"  and the profile file that Bash would use (for login shells).\n"
"\n"
"  First, add the commands to `~/.bashrc` by running the following in your terminal:\n"
"\n"
"  ```bash\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bashrc\n"
"  ```\n"
"\n"
"  Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add the commands there as well.\n"
"  If you have none of these, add them to `~/.profile`.\n"
"\n"
"  - to add to `~/.profile`:\n"
"\n"
"    ```bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile\n"
"    ```\n"
"\n"
"  - to add to `~/.bash_profile`:\n"
"    ```bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
"    ```\n"
"\n"
"- For **Zsh**:\n"
"\n"
"  ```zsh\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc\n"
"  ```\n"
"\n"
"  If you wish to get Cairo in non-interactive login shells as well, also add the commands to `~/.zprofile` or `~/.zlogin`.\n"
"\n"
"- For **Fish shell**:\n"
"\n"
"  If you have Fish 3.2.0 or newer, execute this interactively:\n"
"\n"
"  ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  fish_add_path $CAIRO_ROOT/target/release\n"
"  ```\n"
"\n"
"  Otherwise, execute the snippet below:\n"
"\n"
"  ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
"  ```"
msgstr ""
"-  对于**bash** ：\n"
"\n"
"  各个发行版间的 Stock Bash 的启动文件在什么情况下调用什么样的文件，以什么顺序执行，并进行哪些额外的配置都存在很大的差异\n"
"  因此，在所有环境中获得 Cairo 的最可靠方法是将 Cairo 配置命令附加到`.bashrc`（用于交互式shell）和Bash将使用的配置文件中。（用于登录shell）。\n"
"\n"
"  首先，通过在终端运行以下命令，将这些命令添加到`~/.bashrc`中：\n"
"\n"
"   ```bash\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bashrc\n"
"  ```\n"
"\n"
"  然后，如果你有 `~/.profile`、`~/.bash_profile`或`~/.bash_login`，也将这些命令添加到它们所对应的文件中。如果没有这些文件，则添加到 `~/.profile`中。\n"
"\n"
"  - 添加到 `~/.profile` 中：\n"
"\n"
"    ```bash\n"
"    echo ‘export CAIRO_ROOT=“$HOME/.cairo”’ >> ~/.profile\n"
"    echo ‘command -v cairo-compile >/dev/null || export PATH=“$CAIRO_ROOT/target/release:$PATH”’ >> ~/.profile\n"
"    ```\n"
"\n"
"  - 添加到`~/.bash_profile`：\n"
"    ```bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
"    ```\n"
"\n"
"- 对于**Zsh**：\n"
"\n"
"  ```zsh\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc\n"
"  ```\n"
"\n"
"  如果你希望在非交互式登录shell中也能得到Cairo，也可以将这些命令添加到`~/.zprofile`或`~/.zlogin`。\n"
"\n"
"- 对于**Fish shell**：\n"
"\n"
"  如果你有Fish 3.2.0或更新版本，请以交互方式执行：\n"
"\n"
"  ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  fish_add_path $CAIRO_ROOT/target/release\n"
"  ```\n"
"\n"
"  否则，执行下面的片段：\n"
"\n"
"   ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
"  ```"

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which\n"
"provides alternative shell completions for many command line tools with an\n"
"IDE-like popup interface in the terminal window.\n"
"(Note that their completions are independent from Cairo's codebase\n"
"so they might be slightly out of sync for bleeding-edge interface changes.)"
msgstr ""
"在 MacOS 中，你可能还想安装[Fig](https://fig.io/)。它为许多命令行工具提供了替\n"
"代性的 shell 补全功能，并在终端窗口有一个类似于 IDE 的弹出式界面。(注意，他们\n"
"的命令补全功能与Cairo的代码库无关，所以他们有可能有点跟不上Cairo命令行界面的更新）。"

#: src/appendix-06-cairo-binaries.md:129
msgid "### Restart your shell"
msgstr "### 重新启动你的shell"

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr "以使 `PATH`的改变生效。"

#: src/appendix-06-cairo-binaries.md:133
msgid ""
"```sh\n"
"exec \"$SHELL\"\n"
"```"
msgstr ""
"```sh\n"
"exec \"$SHELL\"\n"
"```"

#: src/appendix-06-cairo-binaries.md:137
msgid "## Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr "## 手动安装Cairo([指南](https://github.com/auditless/cairo-template)由[Abdel](https://github.com/abdelhamidbakhta)提供)"

#: src/appendix-06-cairo-binaries.md:139
msgid "### Step 1: Install Cairo 1.0"
msgstr "### 第1步：安装Cairo 1.0"

#: src/appendix-06-cairo-binaries.md:141
msgid "If you are using an x86 Linux system and can use the release binary, download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr "如果你使用的是 x86 Linux 系统，并且可以使用发布的二进制文件，请在这里下载Cairo：<https://github.com/starkware-libs/cairo/releases>。"

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr "对于其他用户，我们建议从源码编译 Cairo，如下所示："

#: src/appendix-06-cairo-binaries.md:145
msgid ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v2.2.0\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"
msgstr ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v2.2.0\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"

#: src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr "."

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**注意：保持Cairo已更新到最新版本**"

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to do\n"
"is pull the latest changes and rebuild as follows:"
msgstr ""
"现在你的Cairo编译器已经在一个克隆的仓库里了，你所需要做的是拉取最新的修改，\n"
"并按如下方式重新编译："

#: src/appendix-06-cairo-binaries.md:174
msgid ""
"```bash\n"
"cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
"```"
msgstr ""
"```bash\n"
"cd $CAIRO_ROOT && git fetch && git pull && cargo build —all —release\n"
"```"

#: src/appendix-06-cairo-binaries.md:178
msgid "### Step 2: Add Cairo 1.0 executables to your path"
msgstr "### 第二步：将Cairo 1.0的可执行文件添加到你的路径中"

#: src/appendix-06-cairo-binaries.md:180
msgid ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"
msgstr ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"

#: src/appendix-06-cairo-binaries.md:184
msgid "**NOTE: If installing from a Linux binary, adapt the destination path accordingly.**"
msgstr "**注意：如果你是在Linux编译的二进制文件，请相应调整目标路径**"

#: src/appendix-06-cairo-binaries.md:186
msgid "### Step 3: Setup Language Server"
msgstr "### 第三步：设置语言服务器"

#: src/appendix-06-cairo-binaries.md:188
msgid "#### VS Code Extension"
msgstr "#### VS代码扩展"

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"- If you have the previous Cairo 0 extension installed, you can disable/uninstall it.\n"
"- Install the Cairo 1 extension for proper syntax highlighting and code navigation. You can find the link to the extension [here](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1&ssr=false), or just search for \"Cairo 1.0\" in the VS Code marketplace.\n"
"- The extension will work out of the box once you will have [Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""
"- 如果你安装了以前的Cairo 0扩展，你���以禁用/卸载它。\n"
"- 安装Cairo 1扩展以获得正确的语法高亮和代码导航。你可以通过这个链接下载扩展[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false)，或者直接在VS Code市"
"场上搜索 \"Cairo 1.0\"。\n"
"- 一旦你安装了[Scarb](./ch01-03-hello-scarb.md)，该扩展就可以立即工作了。"

#: src/appendix-06-cairo-binaries.md:194
msgid "#### Cairo Language Server without Scarb"
msgstr "#### Cairo语言服务器(不使用Scarb时)"

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language Server with the compiler binary.\n"
"From [Step 1](#installing-cairo-with-a-script-installer-by-fran), the `cairo-language-server` binary should be built and executing this command will copy its path into your clipboard."
msgstr ""
"如果你不想依赖Scarb，你仍然可以通过编译的二进制文件使用Cairo语言服务器。\n"
"在[Step 1](#installing-cairo-with-a-script-installer-by-fran) 中，`cairo-language-server`二进制文件应该已经编译完成，执行这个命令将复制其路径到你的剪贴板。"

#: src/appendix-06-cairo-binaries.md:199
msgid ""
"```bash\n"
"which cairo-language-server | pbcopy\n"
"```"
msgstr ""
"```bash\n"
"which cairo-language-server | pbcopy\n"
"```"

#: src/appendix-06-cairo-binaries.md:203
msgid "Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting the path."
msgstr "将上面复制的路径更新到Cairo 1.0扩展的`cairo1.languageServerPath`中。"

#~ msgid "# The Cairo Programming Language"
#~ msgstr "# Cairo编程语言"

#~ msgid "# Foreword"
#~ msgstr "# 前言"

#~ msgid "# Introduction"
#~ msgstr "#  介绍"

#~ msgid "## References"
#~ msgstr "## 参考文献"

#~ msgid "# Getting Started"
#~ msgstr "# 入门"

#~ msgid "### Installation"
#~ msgstr "### 安装"

#~ msgid ""
#~ "To install Scarb, please refer to the [installation instructions](https://"
#~ "docs.swmansion.com/scarb/download).\n"
#~ "You can simply run the following command in your terminal, then follow "
#~ "the onscreen instructions. This will install the latest stable release."
#~ msgstr ""
#~ "要安装Scarb，请参考[安装说明]（https://docs.swmansion.com/scarb/"
#~ "download）。\n"
#~ "你可以简单地在终端运行以下命令，然后按照屏幕上的指示操作。这将安装最新的稳"
#~ "定版本。"

#~ msgid ""
#~ "```bash\n"
#~ "curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
#~ "install.sh | sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
#~ "install.sh | sh\n"
#~ "```"

#~ msgid "## Hello, World"
#~ msgstr "## Hello, World"

#~ msgid ""
#~ "```shell\n"
#~ "mkdir ~/cairo_projects\n"
#~ "cd ~/cairo_projects\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "mkdir ~/cairo_projects\n"
#~ "cd ~/cairo_projects\n"
#~ "```"

#~ msgid ""
#~ "```cmd\n"
#~ "> mkdir \"%USERPROFILE%\\cairo_projects\"\n"
#~ "> cd /d \"%USERPROFILE%\\cairo_projects\"\n"
#~ "```"
#~ msgstr ""
#~ "```cmd\n"
#~ "> mkdir \"%USERPROFILE%\\cairo_projects\"\n"
#~ "> cd /d \"%USERPROFILE%\\cairo_projects\"\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "scarb new hello_world\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "scarb new hello_world\n"
#~ "```"

#~ msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
#~ msgstr "<span class=\"filename\">文件名：Scarb.toml</span>"

#~ msgid ""
#~ "```rust,noplayground\n"
#~ "mod hello_world;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,noplayground\n"
#~ "mod hello_world;\n"
#~ "```"

#~ msgid ""
#~ "```rust,file=hello_world.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, World!'.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,file=hello_world.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, World!'.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ scarb build\n"
#~ "   Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)\n"
#~ "    Finished release target(s) in 0 seconds\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ scarb build\n"
#~ "   Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)\n"
#~ "    Finished release target(s) in 0 seconds\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "running hello_world ...\n"
#~ "[DEBUG] Hello, World!                   (raw: "
#~ "0x48656c6c6f2c20776f726c6421\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "running hello_world ...\n"
#~ "[DEBUG] Hello, World!                   (raw: "
#~ "0x48656c6c6f2c20776f726c6421\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust,noplayground\n"
#~ "fn main() {\n"
#~ "\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,noplayground\n"
#~ "fn main() {\n"
#~ "\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,noplayground\n"
#~ "    'Hello, World!'.print();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,noplayground\n"
#~ "    'Hello, World!'.print();\n"
#~ "```"

#~ msgid ""
#~ "```txt\n"
#~ "├── Scarb.toml\n"
#~ "├── src\n"
#~ "│   ├── lib.cairo\n"
#~ "│   └── file.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```txt\n"
#~ "├── Scarb.toml\n"
#~ "├── src\n"
#~ "│   ├── lib.cairo\n"
#~ "│   └── file.cairo\n"
#~ "```"

#~ msgid ""
#~ "- We can create a project using `scarb new`.\n"
#~ "- We can build a project using `scarb build` to generate the compiled "
#~ "Sierra code.\n"
#~ "- We can define custom scripts in `Scarb.toml` and call them with the "
#~ "`scarb run` command.\n"
#~ "- We can run tests using the `scarb test` command."
#~ msgstr ""
#~ "- 我们可以使用 `scarb new` 创建项目。\n"
#~ "- 我们可以使用 `scarb build` 生成编译后的 Sierra 代码。\n"
#~ "- 我们可以在 `Scarb.toml` 中定义自定义脚本，并使用 `scarb run` 命令调用它"
#~ "们。\n"
#~ "- 我们可以使用 `scarb test` 命令运行测试。"

#~ msgid "### Starknet support"
#~ msgstr "### Starknet 支持"

#~ msgid ""
#~ "- Install the latest stable version of Cairo\n"
#~ "- Write and run a “Hello, Scarb!” program using `scarb` directly\n"
#~ "- Create and run a new project using the conventions of Scarb\n"
#~ "- Execute tests using the `scarb test` command"
#~ msgstr ""
#~ "- 安装最新稳定版本的 Cairo\n"
#~ "- 直接使用 `scarb` 编写并运行 “Hello, world!”程序\n"
#~ "- 使用 Scarb 的默认设置创建并运行一个新项目\n"
#~ "- 使用 `scarb test` 命令执行测试"

#~ msgid "# Common Programming Concepts"
#~ msgstr "# 常见的编程概念"

#~ msgid "## Variables and Mutability"
#~ msgstr "## 变量和可变性"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    x.print();\n"
#~ "    x = 6;\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    x.print();\n"
#~ "    x = 6;\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "error: Cannot assign to an immutable variable.\n"
#~ " --> lib.cairo:5:5\n"
#~ "    x = 6;\n"
#~ "    ^***^\n"
#~ "\n"
#~ "Error: failed to compile: src/lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "error: Cannot assign to an immutable variable.\n"
#~ " --> lib.cairo:5:5\n"
#~ "    x = 6;\n"
#~ "    ^***^\n"
#~ "\n"
#~ "Error: failed to compile: src/lib.cairo\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut x = 5;\n"
#~ "    x.print();\n"
#~ "    x = 6;\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut x = 5;\n"
#~ "    x.print();\n"
#~ "    x = 6;\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                (raw: 5)\n"
#~ "\n"
#~ "[DEBUG]                                (raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                (raw: 5)\n"
#~ "\n"
#~ "[DEBUG]                                (raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    let x = x + 1;\n"
#~ "    {\n"
#~ "        let x = x * 2;\n"
#~ "        'Inner scope x value is:'.print();\n"
#~ "        x.print()\n"
#~ "    }\n"
#~ "    'Outer scope x value is:'.print();\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    let x = x + 1;\n"
#~ "    {\n"
#~ "        let x = x * 2;\n"
#~ "        'Inner scope x value is:'.print();\n"
#~ "        x.print()\n"
#~ "    }\n"
#~ "    'Outer scope x value is:'.print();\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "scarb cairo-run\n"
#~ "[DEBUG] Inner scope x value is:         (raw: "
#~ "7033328135641142205392067879065573688897582790068499258)\n"
#~ "\n"
#~ "[DEBUG]\n"
#~ "                                       (raw: 12)\n"
#~ "\n"
#~ "[DEBUG] Outer scope x value is:         (raw: "
#~ "7610641743409771490723378239576163509623951327599620922)\n"
#~ "\n"
#~ "[DEBUG]                                (raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "scarb cairo-run\n"
#~ "[DEBUG] Inner scope x value is:         (raw: "
#~ "7033328135641142205392067879065573688897582790068499258)\n"
#~ "\n"
#~ "[DEBUG]\n"
#~ "                                       (raw: 12)\n"
#~ "\n"
#~ "[DEBUG] Outer scope x value is:         (raw: "
#~ "7610641743409771490723378239576163509623951327599620922)\n"
#~ "\n"
#~ "[DEBUG]                                (raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: u64 = 2;\n"
#~ "    x.print();\n"
#~ "    let x: felt252 = x.into(); // converts x to a felt, type annotation "
#~ "is required.\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: u64 = 2;\n"
#~ "    x.print();\n"
#~ "    let x: felt252 = x.into(); // converts x to a felt, type annotation "
#~ "is required.\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut x: u64 = 2;\n"
#~ "    x.print();\n"
#~ "    x = 100_felt252;\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut x: u64 = 2;\n"
#~ "    x.print();\n"
#~ "    x = 100_felt252;\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"

#~ msgid "## Data Types"
#~ msgstr "## 数据类型"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let x: felt252 = 3;\n"
#~ "    let y: u32 = x.try_into().unwrap();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let x: felt252 = 3;\n"
#~ "    let y: u32 = x.try_into().unwrap();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "| Length  | Unsigned |\n"
#~ "| ------- | -------- |\n"
#~ "| 8-bit   | `u8`     |\n"
#~ "| 16-bit  | `u16`    |\n"
#~ "| 32-bit  | `u32`    |\n"
#~ "| 64-bit  | `u64`    |\n"
#~ "| 128-bit | `u128`   |\n"
#~ "| 256-bit | `u256`   |\n"
#~ "| 32-bit  | `usize`  |"
#~ msgstr ""
#~ "| 长度  | 无符号 |\n"
#~ "| ------- | -------- |\n"
#~ "| 8-bit   | `u8`     |\n"
#~ "| 16-bit  | `u16`    |\n"
#~ "| 32-bit  | `u32`    |\n"
#~ "| 64-bit  | `u64`    |\n"
#~ "| 128-bit | `u128`   |\n"
#~ "| 256-bit | `u256`   |\n"
#~ "| 32-bit  | `usize`  |"

#~ msgid ""
#~ "```rust\n"
#~ "fn sub_u8s(x: u8, y: u8) -> u8 {\n"
#~ "    x - y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    sub_u8s(1, 3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn sub_u8s(x: u8, y: u8) -> u8 {\n"
#~ "    x - y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    sub_u8s(1, 3);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "| Numeric literals | Example   |\n"
#~ "| ---------------- | --------- |\n"
#~ "| Decimal          | `98222`   |\n"
#~ "| Hex              | `0xff`    |\n"
#~ "| Octal            | `0o04321` |\n"
#~ "| Binary           | `0b01`    |"
#~ msgstr ""
#~ "| 数字字面值 | 例子   |\n"
#~ "| ---------------- | --------- |\n"
#~ "| Decimal(十进制)          | `98222`   |\n"
#~ "| Hex (十六进制)              | `0xff`    |\n"
#~ "| Octal (八进制)            | `0o04321` |\n"
#~ "| Binary (二进制)           | `0b01`    |"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    // addition\n"
#~ "    let sum = 5_u128 + 10_u128;\n"
#~ "\n"
#~ "    // subtraction\n"
#~ "    let difference = 95_u128 - 4_u128;\n"
#~ "\n"
#~ "    // multiplication\n"
#~ "    let product = 4_u128 * 30_u128;\n"
#~ "\n"
#~ "    // division\n"
#~ "    let quotient = 56_u128 / 32_u128; //result is 1\n"
#~ "    let quotient = 64_u128 / 32_u128; //result is 2\n"
#~ "\n"
#~ "    // remainder\n"
#~ "    let remainder = 43_u128 % 5_u128; // result is 3\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    // addition\n"
#~ "    let sum = 5_u128 + 10_u128;\n"
#~ "\n"
#~ "    // subtraction\n"
#~ "    let difference = 95_u128 - 4_u128;\n"
#~ "\n"
#~ "    // multiplication\n"
#~ "    let product = 4_u128 * 30_u128;\n"
#~ "\n"
#~ "    // division\n"
#~ "    let quotient = 56_u128 / 32_u128; //result is 1\n"
#~ "    let quotient = 64_u128 / 32_u128; //result is 2\n"
#~ "\n"
#~ "    // remainder\n"
#~ "    let remainder = 43_u128 % 5_u128; // result is 3\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let t = true;\n"
#~ "\n"
#~ "    let f: bool = false; // with explicit type annotation\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let t = true;\n"
#~ "\n"
#~ "    let f: bool = false; // with explicit type annotation\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    let my_first_char = 'C';\n"
#~ "    let my_first_string = 'Hello world';\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    let my_first_char = 'C';\n"
#~ "    let my_first_string = 'Hello world';\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let my_felt252 = 10;\n"
#~ "    // Since a felt252 might not fit in a u8, we need to unwrap the "
#~ "Option<T> type\n"
#~ "    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
#~ "    let my_u16: u16 = my_u8.into();\n"
#~ "    let my_u32: u32 = my_u16.into();\n"
#~ "    let my_u64: u64 = my_u32.into();\n"
#~ "    let my_u128: u128 = my_u64.into();\n"
#~ "    // As a felt252 is smaller than a u256, we can use the into() method\n"
#~ "    let my_u256: u256 = my_felt252.into();\n"
#~ "    let my_usize: usize = my_felt252.try_into().unwrap();\n"
#~ "    let my_other_felt252: felt252 = my_u8.into();\n"
#~ "    let my_third_felt252: felt252 = my_u16.into();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let my_felt252 = 10;\n"
#~ "    // Since a felt252 might not fit in a u8, we need to unwrap the "
#~ "Option<T> type\n"
#~ "    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
#~ "    let my_u16: u16 = my_u8.into();\n"
#~ "    let my_u32: u32 = my_u16.into();\n"
#~ "    let my_u64: u64 = my_u32.into();\n"
#~ "    let my_u128: u128 = my_u64.into();\n"
#~ "    // As a felt252 is smaller than a u256, we can use the into() method\n"
#~ "    let my_u256: u256 = my_felt252.into();\n"
#~ "    let my_usize: usize = my_felt252.try_into().unwrap();\n"
#~ "    let my_other_felt252: felt252 = my_u8.into();\n"
#~ "    let my_third_felt252: felt252 = my_u16.into();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let tup: (u32, u64, bool) = (10, 20, true);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let tup: (u32, u64, bool) = (10, 20, true);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let tup = (500, 6, true);\n"
#~ "\n"
#~ "    let (x, y, z) = tup;\n"
#~ "\n"
#~ "    if y == 6 {\n"
#~ "        'y is six!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let tup = (500, 6, true);\n"
#~ "\n"
#~ "    let (x, y, z) = tup;\n"
#~ "\n"
#~ "    if y == 6 {\n"
#~ "        'y is six!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let (x, y): (felt252, felt252) = (2, 3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let (x, y): (felt252, felt252) = (2, 3);\n"
#~ "}\n"
#~ "```"

#~ msgid "## Functions"
#~ msgstr "## 函数"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn another_function() {\n"
#~ "    'Another function.'.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "    another_function();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn another_function() {\n"
#~ "    'Another function.'.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "    another_function();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG] Hello, world!                (raw: "
#~ "5735816763073854953388147237921)\n"
#~ "[DEBUG] Another function.            (raw: "
#~ "22265147635379277118623944509513687592494)\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG] Hello, world!                (raw: "
#~ "5735816763073854953388147237921)\n"
#~ "[DEBUG] Another function.            (raw: "
#~ "22265147635379277118623944509513687592494)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252) {\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252) {\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5, 6);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252, y: felt252) {\n"
#~ "    x.print();\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5, 6);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252, y: felt252) {\n"
#~ "    x.print();\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "[DEBUG]                                 (raw: 6)\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "[DEBUG]                                 (raw: 6)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn foo(x: u8, y: u8) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_arg = 3;\n"
#~ "    let second_arg = 4;\n"
#~ "    foo(x: first_arg, y: second_arg);\n"
#~ "    let x = 1;\n"
#~ "    let y = 2;\n"
#~ "    foo(:x, :y)\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn foo(x: u8, y: u8) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_arg = 3;\n"
#~ "    let second_arg = 4;\n"
#~ "    foo(x: first_arg, y: second_arg);\n"
#~ "    let x = 1;\n"
#~ "    let y = 2;\n"
#~ "    foo(:x, :y)\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let y = 6;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let y = 6;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "//TAG: does_not_compile, ignore_fmt\n"
#~ "fn main() {\n"
#~ "    let x = (let y = 6);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "//TAG: does_not_compile, ignore_fmt\n"
#~ "fn main() {\n"
#~ "    let x = (let y = 6);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "error: Missing token TerminalRParen.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "                      ^\n"
#~ "\n"
#~ "error: Skipped tokens. Expected: statement.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-run\n"
#~ "error: Missing token TerminalRParen.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "                      ^\n"
#~ "\n"
#~ "error: Skipped tokens. Expected: statement.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let y = {\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "    };\n"
#~ "\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let y = {\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "    };\n"
#~ "\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "{\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "{\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn five() -> u32 {\n"
#~ "    5\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = five();\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn five() -> u32 {\n"
#~ "    5\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = five();\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "let x = 5;\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "let x = 5;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    x.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "//TAG: does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1;\n"
#~ "}\n"
#~ "```"

#~ msgid "The Account Descriptor will look like this. You can get the public key and the smart wallet address from the output of the initial `katana` command:"
#~ msgstr "账户描述符将如下所示。你可以从初始 `katana` 命令的输出中获取公钥和智能钱包地址："

#~ msgid ""
#~ "To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download).\n"
#~ "You can simply run the following command in your terminal, then follow the onscreen instructions. This will install the latest stable release."
#~ msgstr ""
#~ "要安装Scarb，请参考[安装说明]（https://docs.swmansion.com/scarb/download）。\n"
#~ "你可以简单地在终端运行以下命令，然后按照屏幕上的指示操作。这将安装最新的稳定版本。"

#~ msgid "### Starknet support"
#~ msgstr "### Starknet 支持"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"

#~ msgid "<!-- TODO: remove when Scarb test work -->"
#~ msgstr "<!— TODO: remove when Scarb test work —>"

#~ msgid ""
#~ "> Note: You will notice here a `cairo_project.toml` file.\n"
#~ "> This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed by Scarb),\n"
#~ "> which is required to run the `scarb cairo-test` command to run the code of the crate.\n"
#~ "> It is required until Scarb implements this feature. The content of the file is:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> and indicates that the crate named \"adder\" is located in the `src` directory."
#~ msgstr ""
#~ "> 注意：你会注意到这里有一个`cairo_project.toml`文件。\n"
#~ "> 这是 普通的Cairo项目的配置文件（即不由Scarb管理）、\n"
#~ "> 在运行`scarb cairo-test`命令来运行crate的代码需要这个文件。\n"
#~ "> 在Scarb实现这一功能之前，它是必需的。该文件的内容是：\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> adder = “src”\n"
#~ "> ```\n"
#~ ">\n"
#~ "> 该文件指出，名为 \"adder \"的crate位于`src`目录下。"

#~ msgid ""
#~ "> To successfully run your tests with `cairo-test` you will need to update your `cairo_project.toml` file to add the declaration of your `tests` crate.\n"
#~ ">\n"
#~ "> ```rust\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> tests = \"tests\"\n"
#~ "> ```"
#~ msgstr ""
#~ "> 为了成功地用`cairo-test`运行你的测试，你需要更新你的`cairo_project.toml`文件，添加你的`tests`crate的声明。\n"
#~ ">\n"
#~ "> ```rust\n"
#~ "> [crate_roots]\n"
#~ "> adder = “src”\n"
#~ "> tests = “tests”\n"
#~ "> ```"

#~ msgid "Each test file is compiled as its own separate crate, that's why whenever you add a new test file you must add it to your _tests/lib.cairo_."
#~ msgstr "每个测试文件都被编译为它自己独立的crate，这就是为什么每当你添加一个新的测试文件，你必须把它添加到你的 _tests/lib.cairo_ 文件中。"

#~ msgid "<span class=\"filename\">Filename: tests/lib.cairo</span>"
#~ msgstr "<span class=\"filename\">文件名：test/lib.cairo</span>"

#~ msgid "<span class=\"caption\">Listing 8-11: Testing functions from other modules</span>"
#~ msgstr "<span class=\"caption\">示例 8-11：从同一模块导入多个项</span>"

#~ msgid ""
#~ "```shell\n"
#~ "$ cairo-test tests/\n"
#~ "running 1 tests\n"
#~ "test tests::tests_integration::it_adds_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cairo-test tests/\n"
#~ "running 1 tests\n"
#~ "test tests::tests_integration::it_adds_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "You can set up a Starknet development environment using Scarb as stated in the [Hello, Scarb! - Starknet Support](ch01-03-hello-scarb.md#starknet-support) section. Each example in "
#~ "this chapter can be used with Scarb."
#~ msgstr "您可以按照[你好，Scarb！--Starknet 支持](ch01-03-hello-scarb.md#starknet-support)一节中的说明，使用 Scarb 建立 Starknet 开发环境。本章中的每个示例都可以使用 Scarb。"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "# #[starknet::contract]\n"
#~ "# mod contract {\n"
#~ "#     use starknet::ContractAddress;\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        id: u8,\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>,\n"
#~ "    }\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "# #[starknet::contract]\n"
#~ "# mod contract {\n"
#~ "#     use starknet::ContractAddress;\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        id: u8,\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>,\n"
#~ "    }\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "Mappings are a key-value data structure that you can use to store data within a smart contract. They are essentially hash tables that allow you to associate a unique key with a "
#~ "corresponding value. Mappings are also useful to store sets of data, as it's impossible to store arrays in storage."
#~ msgstr ""
#~ "映射是一种键值数据结构，你可以用它来存储智能合约中的数据。它们本质上是哈希表，允许你将一个唯一的键与一个相应的值联系起来。映射对于存储数据集也很有用，因为在存储中不可能存储数组。"

#~ msgid ""
#~ "A mapping is a variable of type `LegacyMap`, in which the key and value types are specified within angular brackets `<>`.\n"
#~ "It is important to note that the `LegacyMap` type can only be used inside the `Storage` struct, and can't be used to define mappings in user-defined structs."
#~ msgstr ""
#~ "映射是一个类型为 `LegacyMap` 的变量，其中键和值的类型在角括号 `<>` 中指定。\n"
#~ "需要注意的是，`LegacyMap`类型只能在 `LegacyMap`结构内部使用，不能用于在用户定义的结构中定义映射。"

#~ msgid ""
#~ "In mappings, the address of the value at key `k_1,...,k_n` is `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ\n"
#~ "is the Pedersen hash and the final value is taken `mod2251−256`. You can learn more about the contract storage layout in the [Starknet Documentation](https://docs.starknet.io/"
#~ "documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
#~ msgstr ""
#~ "在映射中，键`k_1,...,k_n`的值的地址是`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`，其中ℎ\n"
#~ "是Pedersen哈希值，最终值取为 \"mod2251-256\"。你可以在[Starknet文档](https://docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
#~ "中了解更多关于合约存储布局的信息。"

#~ msgid ""
#~ "The compiler knows how to store basic data types, such as unsigned integers (`u8`, `u128`, `u256`...), `felt252`, `ContractAddress`, etc. But what if you want to store a custom "
#~ "struct in storage? In that case, you have to explicitly tell the compiler how to store your struct in storage.\n"
#~ "In our example, we want to store a `Person` struct in storage, so we have to tell the compiler how to store it in storage by adding a derive attribute of the `starknet::Store` "
#~ "trait to our struct definition."
#~ msgstr ""
#~ "编译器知道如何存储基本数据类型，例如无符号整数（`u8`, `u128`, `u256`...), `felt252`,`ContractAddress`等。但是如果您想在存储空间中存储自定义结构体呢？在这种情况下，您必须明确地告诉"
#~ "编译器如何在存储空间中存储您的结构。\n"
#~ "在我们的示例中，我们希望将`Person`结构体存储在存储空间中，因此我们必须在结构体定义中添加`starknet::Store`trait的派生属性，告诉编译器如何将其存储在存储空间中。"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
#~ "    struct Person {\n"
#~ "        name: felt252,\n"
#~ "        address: ContractAddress\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
#~ "    struct Person {\n"
#~ "        name: felt252,\n"
#~ "        address: ContractAddress\n"
#~ "    }\n"
#~ "```"

#~ msgid "### Reading from Storage"
#~ msgstr "### 从存储中读取"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "            let name = self.names.read(address);\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "            let name = self.names.read(address);\n"
#~ "```"

#~ msgid "> Note: When the storage variable does not store a mapping, its value is accessed without passing any parameters to the read method"
#~ msgstr "> 注意：当存储变量不存储映射时，使用读取方法访问其值不需要传递任何参数"

#~ msgid "### Writing to Storage"
#~ msgstr "### 写入存储"

#~ msgid "To write a value to the storage variable `names`, we call the `write` function on the `names` storage variable, passing in the key and values as arguments."
#~ msgstr "为了给存储变量`names`写一个值，我们在`names`存储变量上调用`write`函数，将键和值作为参数传入。"

#~ msgid ""
#~ "```rust, noplayground\n"
#~ "            self.names.write(user, name);\n"
#~ "```"
#~ msgstr ""
#~ "```rust, noplayground\n"
#~ "            self.names.write(user, name);\n"
#~ "```"

#~ msgid "<span class=\"caption\">Listing 99-4: Writing to the `names` variable</span>"
#~ msgstr "<span class=\"caption\">示例99-4：向 \"names \"变量写入内容</span>"

#~ msgid ""
#~ "To use this syscall, we passed in the contract address, the function selector (which is the `starknet_keccak` hash of the function name), and the calldata (function arguments). At "
#~ "the end, we get returned a serialized value which we'll need to deserialize ourselves!"
#~ msgstr ""
#~ "要使用此系统调用，我们需要传入合约地址、函数选择器（即函数名的 `starknet_keccak` 哈希值）和 calldata（函数参数）。最后，我们会得到一个序列化值，我们需要自己对其进行反序列化！"

#~ msgid ""
#~ "The Starknet sequencer can receive the messages sent from Ethereum to the `StarknetMessaging` contract and trigger the appropriate functions on L2, or send messages to "
#~ "`StarknetCore` on L1."
#~ msgstr "Starknet排序器可以接收从以太坊发送到 `StarknetMessaging` 合约的信息，并在 L2 上触发相应的功能，或在 L1 上向 `StarknetCore`发送信息。"

#~ msgid ""
#~ "Let's take an example. It is adapted from the [starknet-edu L1-L2 exercises](https://github.com/starknet-edu/starknet-messaging-bridge/tree/main). It's a contract that can receive "
#~ "a message sent from L1 and store it, and also send a message to L1."
#~ msgstr ""
#~ "让我们举个例子。它改编自 [starknet-edu L1-L2 练习](https://github.com/starknet-edu/starknet-messaging-bridge/tree/main)。这是一个可以接收 L1 发送的信息并将其存储起来，同时也可以向 "
#~ "L1 发送信息的合约。"

#~ msgid ""
#~ "To give a bit of context, here we have two contracts, one on Ethereum and the other on Starknet. Both interact with each other. The goal of the workshop is to find a way to earn "
#~ "points by sending messages from one chain to the other."
#~ msgstr "在这里，我们有两个合约，一个在 Ethereum 上，另一个在 Starknet 上。两者相互影响。这个练习的目标是找到一种方法，通过从一个链向另一个链发送信息来赚取积分。"

#~ msgid "Here is a snippet of the solidity code to send a simple message from Ethereum to Starknet:"
#~ msgstr "下面是一段 solidity 代码，用于从 Ethereum 向 Starknet 发送一条简单的信息："

#~ msgid ""
#~ "```rust\n"
#~ "function ex01SendMessageToL2(uint256 value) external payable{\n"
#~ "\n"
#~ "    // This function call requires money to send L2 messages, we check there is enough\n"
#~ "    require(msg.value>=10000000000, \"Message fee missing\");\n"
#~ "\n"
#~ "    // Sending the message to the l2 contract\n"
#~ "    // Creating the payload\n"
#~ "    uint256[] memory payload = new uint256[](1);\n"
#~ "    // Adding the value to the payload\n"
#~ "    payload[0] = value;\n"
#~ "    // Sending the message\n"
#~ "    starknetCore.sendMessageToL2{value: 10000000000}(l2Evaluator, ex01_selector, payload);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "function ex01SendMessageToL2(uint256 value) external payable{\n"
#~ "\n"
#~ "    // This function call requires money to send L2 messages, we check there is enough\n"
#~ "    require(msg.value>=10000000000, \"Message fee missing\");\n"
#~ "\n"
#~ "    // Sending the message to the l2 contract\n"
#~ "    // Creating the payload\n"
#~ "    uint256[] memory payload = new uint256[](1);\n"
#~ "    // Adding the value to the payload\n"
#~ "    payload[0] = value;\n"
#~ "    // Sending the message\n"
#~ "    starknetCore.sendMessageToL2{value: 10000000000}(l2Evaluator, ex01_selector, payload);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "In `ex01SendMessageToL2`, we first construct the message (the payload). It is an array of `uint256`. Then we call `StarknetCore.sendMessageToL2`. The first parameter is the L2 "
#~ "contract address. The second is the selector (or the `sn_keccak` hash of the name of the function we want to call on L2), followed by the payload. We add a fee to it as a `msg."
#~ "value` because we need to pay the transaction on L2."
#~ msgstr ""
#~ "在 `ex01SendMessageToL2` 中，我们首先构建信息（有效载荷）。它是一个 `uint256` 数组。然后，我们调用 `StarknetCore.sendMessageToL2`。第一个参数是 L2 合约地址。第二个参数是选择器（或"
#~ "我们要在 L2 上调用的函数名称的 `sn_keccak` 的哈希值），然后是payload。我们在其中添加gas费用作为 `msg.value`，因为我们需要在 L2 上支付交易费用。"

#~ msgid ""
#~ "```rust\n"
#~ "    #[l1_handler]\n"
#~ "    fn ex_01_receive_message_from_l1(\n"
#~ "        ref self: ContractState, from_address: felt252, message: usize\n"
#~ "    ) {\n"
#~ "        // Selector: 0x274ab8abc4e270a94c36e1a54c794cd4dd537eeee371e7188c56ee768c4c0c4\n"
#~ "        // Check that the sender is the correct L1 evaluator\n"
#~ "        assert(from_address == self.l1_evaluator_address.read(), 'WRONG L1 EVALUATOR');\n"
#~ "        // Adding a check on the message, because why not?\n"
#~ "        assert(message > 168111, 'MESSAGE TOO SMALL');\n"
#~ "        assert(message < 5627895, 'MESSAGE TOO BIG');\n"
#~ "\n"
#~ "        // Store the message received from L1\n"
#~ "        let mut message_count = self.messages_count.read();\n"
#~ "        self.messages.write(message_count, message);\n"
#~ "        message_count += 1;\n"
#~ "        self.messages_count.write(message_count);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[l1_handler]\n"
#~ "    fn ex_01_receive_message_from_l1(\n"
#~ "        ref self: ContractState, from_address: felt252, message: usize\n"
#~ "    ) {\n"
#~ "        // Selector: 0x274ab8abc4e270a94c36e1a54c794cd4dd537eeee371e7188c56ee768c4c0c4\n"
#~ "        // Check that the sender is the correct L1 evaluator\n"
#~ "        assert(from_address == self.l1_evaluator_address.read(), 'WRONG L1 EVALUATOR');\n"
#~ "        // Adding a check on the message, because why not?\n"
#~ "        assert(message > 168111, 'MESSAGE TOO SMALL');\n"
#~ "        assert(message < 5627895, 'MESSAGE TOO BIG');\n"
#~ "\n"
#~ "        // Store the message received from L1\n"
#~ "        let mut message_count = self.messages_count.read();\n"
#~ "        self.messages.write(message_count, message);\n"
#~ "        message_count += 1;\n"
#~ "        self.messages_count.write(message_count);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    #[generate_trait]\n"
#~ "    impl Evaluator of IEvaluator {\n"
#~ "        fn ex_02_send_message_to_l1(ref self: ContractState, value: usize) {\n"
#~ "            // Create the message payload\n"
#~ "            // By default it's an array of felt252\n"
#~ "            let mut message_payload = ArrayTrait::new();\n"
#~ "            // Adding the address of the caller on L2\n"
#~ "            message_payload.append(get_caller_address().into());\n"
#~ "            // Adding the value\n"
#~ "            message_payload.append(value.into());\n"
#~ "            // Sending the message\n"
#~ "            send_message_to_l1_syscall(self.l1_evaluator_address.read(), message_payload.span());\n"
#~ "        }\n"
#~ "\n"
#~ "        fn get_l1_evaluator_address(self: @ContractState) -> felt252 {\n"
#~ "            self.l1_evaluator_address.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    #[generate_trait]\n"
#~ "    impl Evaluator of IEvaluator {\n"
#~ "        fn ex_02_send_message_to_l1(ref self: ContractState, value: usize) {\n"
#~ "            // Create the message payload\n"
#~ "            // By default it's an array of felt252\n"
#~ "            let mut message_payload = ArrayTrait::new();\n"
#~ "            // Adding the address of the caller on L2\n"
#~ "            message_payload.append(get_caller_address().into());\n"
#~ "            // Adding the value\n"
#~ "            message_payload.append(value.into());\n"
#~ "            // Sending the message\n"
#~ "            send_message_to_l1_syscall(self.l1_evaluator_address.read(), message_payload.span());\n"
#~ "        }\n"
#~ "\n"
#~ "        fn get_l1_evaluator_address(self: @ContractState) -> felt252 {\n"
#~ "            self.l1_evaluator_address.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"

#~ msgid "On L1, the important part is to build the same payload as on L2. Then you call `starknetCore.consumeMessageFromL2` by passing the L2 contract address and the payload."
#~ msgstr "在 L1 上，重要的是构建与 L2 上相同的payload。然后，调用 `starknetCore.consumeMessageFromL2`并将 L2 合约地址和payload 传递给它。"

#~ msgid ""
#~ "```js\n"
#~ "function ex02ReceiveMessageFromL2(uint256 player_l2_address, uint256 message) external payable{\n"
#~ "\n"
#~ "        require(msg.value>=10000000000, \"Message fee missing\");\n"
#~ "        // Consuming the message\n"
#~ "        // Reconstructing the payload of the message we want to consume\n"
#~ "        uint256[] memory payload = new uint256[](2);\n"
#~ "        // Adding the address of the player on L2\n"
#~ "        payload[0] = caller_l2_address;\n"
#~ "        // Adding the message\n"
#~ "        payload[1] = message;\n"
#~ "        // Adding a constraint on the message, to make sure players read BOTH contracts ;-)\n"
#~ "        require(message>3121906, 'Message too small');\n"
#~ "        require(message<4230938, 'Message too big');\n"
#~ "\n"
#~ "        // If the message constructed above was indeed sent by starknet, this returns the hash of the message\n"
#~ "        // If the message was NOT sent by starknet, the cal will revert\n"
#~ "        starknetCore.consumeMessageFromL2(l2Evaluator, payload);\n"
#~ "\n"
#~ "        // Firing an event, for fun\n"
#~ "        emit MessageReceived(message);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```js\n"
#~ "function ex02ReceiveMessageFromL2(uint256 player_l2_address, uint256 message) external payable{\n"
#~ "\n"
#~ "        require(msg.value>=10000000000, \"Message fee missing\");\n"
#~ "        // Consuming the message\n"
#~ "        // Reconstructing the payload of the message we want to consume\n"
#~ "        uint256[] memory payload = new uint256[](2);\n"
#~ "        // Adding the address of the player on L2\n"
#~ "        payload[0] = caller_l2_address;\n"
#~ "        // Adding the message\n"
#~ "        payload[1] = message;\n"
#~ "        // Adding a constraint on the message, to make sure players read BOTH contracts ;-)\n"
#~ "        require(message>3121906, 'Message too small');\n"
#~ "        require(message<4230938, 'Message too big');\n"
#~ "\n"
#~ "        // If the message constructed above was indeed sent by starknet, this returns the hash of the message\n"
#~ "        // If the message was NOT sent by starknet, the cal will revert\n"
#~ "        starknetCore.consumeMessageFromL2(l2Evaluator, payload);\n"
#~ "\n"
#~ "        // Firing an event, for fun\n"
#~ "        emit MessageReceived(message);\n"
#~ "    }\n"
#~ "```"

#~ msgid "This appendix provides a reference for common types and traits used in contract development, along with their corresponding imports, paths, and usage examples."
#~ msgstr "本附录提供了合约开发中使用的常见类型和trait的参考，以及相应的导入方法、路径和使用方法的范例。"

#~ msgid "Hello, Scarb!"
#~ msgstr "Hello，Scarb!"

#~ msgid "### Writing and Running a Cairo Program"
#~ msgstr "### 编写和运行Cairo程序"

#~ msgid ""
#~ "Next, make a new source file and call it _main.cairo_. Cairo files always end with\n"
#~ "the _.cairo_ extension. If you’re using more than one word in your filename, the\n"
#~ "convention is to use an underscore to separate them. For example, use\n"
#~ "_hello_world.cairo_ rather than _helloworld.cairo_."
#~ msgstr ""
#~ "接下来，制作一个新的源代码文件，并将命名为 _main.cairo_ 。Cairo文件的扩展名为 _.cairo_ 。\n"
#~ "如果你在文件名中使用一个以上的单词，惯例是用下划线来分隔它们。\n"
#~ "例如，使用 _hello_world.cairo_ 而不是 _helloworld.cairo_ 。"

#~ msgid "Now open the _main.cairo_ file you just created and enter the code in Listing 1-1."
#~ msgstr "现在打开你刚刚创建的 _main.cairo_ 文件，输入示例1-1中的代码。"

#~ msgid "<span class=\"filename\">Filename: main.cairo</span>"
#~ msgstr "<span class=\"filename\">文件名：main.cairo</span>"

#~ msgid "<span class=\"caption\">Listing 1-1: A program that prints `Hello, world!`</span>"
#~ msgstr "<span class=\"caption\">示例1-1：一个打印 \"Hello，world\"的程序。</span>"

#~ msgid ""
#~ "Save the file and go back to your terminal window in the\n"
#~ "_~/cairo_projects/hello_world_ directory. Enter the following\n"
#~ "commands to compile and run the file:"
#~ msgstr ""
#~ "保存该文件，并回到你的终端窗口，在\n"
#~ "  _~/cairo_projects/hello_world_ 目录。输入以下\n"
#~ "命令来编译和运行该文件："

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "Hello, world!\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "Hello, world!\n"
#~ "```"

#~ msgid ""
#~ "Just running with `cairo-run` is fine for simple programs, but as your project\n"
#~ "grows, you’ll want to manage all the options and make it easy to share your\n"
#~ "code. Next, we’ll introduce you to the Scarb tool, which will help you write\n"
#~ "real-world Cairo programs."
#~ msgstr ""
#~ "只用`cairo-run`运行简单的程序是可以的，但随着你的项目\n"
#~ "增长，你会希望管理所有的选项，并使之易于分享你的\n"
#~ "代码。接下来，我们将向你介绍Scarb工具，它将帮助你编写\n"
#~ "真实世界的Cairo程序。"

#~ msgid "# Hello, Scarb"
#~ msgstr "# 你好，Scarb"

#~ msgid ""
#~ "If we were to build the 'Hello, world!' project using Scarb, only the part of Scarb that handles building the code would be used, since the program doesn't require any external "
#~ "dependencies. As you write more complex Cairo programs, you’ll add dependencies, and if you start a project using Scarb, adding dependencies will be much easier to do."
#~ msgstr ""
#~ "如果我们使用 Scarb 构建 'Hello, world!' 项目，由于该程序不需要任何外部依赖，因此只会使用 Scarb 中处理代码构建的部分。当你编写更复杂的 Cairo 程序时，你需要添加依赖项，如果你使用 "
#~ "Scarb 启动一个项目，添加依赖项就会变得容易得多。"

#~ msgid "Let’s create a new project using Scarb and look at how it differs from our original “Hello, world!” project."
#~ msgstr "让我们用Scarb创建一个新的项目，看看它与我们原来的 \"Hello, world!\"项目有什么不同。"

#~ msgid ""
#~ "```rust,file=hello_scarb.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, Scarb!'.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,file=hello_scarb.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, Scarb!'.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "> Note: You will notice here that we didn't use a Scarb command, but rather a command from the Cairo binaries directly.\n"
#~ "> As Scarb doesn't have a command to execute Cairo code yet, we have to use the `cairo-run` command directly.\n"
#~ "> We will use this command in the rest of the tutorial, but we will also use Scarb commands to initialize projects."
#~ msgstr ""
#~ "> 注意：你会注意到这里我们没有使用Scarb的命令，而是直接使用了Cairo二进制文件的命令。\n"
#~ "> 由于Scarb还没有执行Cairo代码的命令，我们必须直接使用`cairo-run`命令来执行代码。\n"
#~ "> 在接下来的教程中我们将使用这个命令，但我们也将使用Scarb命令来初始化项目。"

#~ msgid "### Defining Custom Scripts"
#~ msgstr "### 定义自定义脚本"

#~ msgid ""
#~ "We can define Scarb scripts in `Scarb.toml` file, which can be used to execute custom shell scripts.\n"
#~ "Add the following line to your `Scarb.toml` file:"
#~ msgstr ""
#~ "我们可以在`Scarb.toml`文件中定义Scarb脚本，它可以用来执行自定义的shell脚本。\n"
#~ "在你的`Scarb.toml`文件中添加以下一行："

#~ msgid ""
#~ "```toml\n"
#~ "[scripts]\n"
#~ "run-lib = \"cairo-run src/lib.cairo\"\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[scripts]\n"
#~ "run-lib = \"cairo-run src/lib.cairo\"\n"
#~ "```"

#~ msgid "Now you can run the following command to run the project:"
#~ msgstr "现在你可以运行以下命令来运行该项目："

#~ msgid "Using `scarb run` is a convenient way to run custom shell scripts that can be useful to run files and test your project."
#~ msgstr "使用 \"scarb run \"是运行自定义shell脚本的一种方便的方法，可以用来运行文件和测试你的项目。"

#~ msgid ""
#~ "```toml\n"
#~ "\n"
#~ "[scripts]\n"
#~ "test = \"protostar test\"\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "\n"
#~ "[scripts]\n"
#~ "test = \"protostar test\"\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\t                              \t(raw: 5)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\t                              \t(raw: 5)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let mut x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = x.into();\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let mut x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = x.into();\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"

#~ msgid "<span class=\"filename\">Filename: src/main.cairo</span>"
#~ msgstr "<span class=\"filename\">文件名： src/main.cairo</span>"

#~ msgid "The snapshot type is always copyable and droppable, so that you can use it multiple times without worrying about ownership transfers."
#~ msgstr "快照类型始终是可复制和可删除的，因此你可以多次使用它而不必担心所有权的转移。"

#~ msgid ""
#~ "> Note: You will notice here a `cairo_project.toml` file.\n"
#~ "> This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed by Scarb),\n"
#~ "> which is required to run the `cairo-run .` command to run the code of the crate.\n"
#~ "> It is required until Scarb implements this feature. The content of the file is:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> backyard = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> and indicates that the crate named \"backyard\" is located in the `src` directory."
#~ msgstr ""
#~ "> 注意：你会注意到这里有一个`cairo_project.toml`文件。\n"
#~ "> 这是 通常的Cairo项目的配置文件（即不由Scarb管理）、\n"
#~ "> 这是运行`cairo-run .`命令���运行crate的代码所需要的。\n"
#~ "> 在Scarb实现这一功能之前，它是必需的。该文件的内容是：\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> backyard = “src”\n"
#~ "> ```\n"
#~ ">\n"
#~ "> 它表示名为 \"backyard \"的板块位于`src`目录下。"

#~ msgid "<span class=\"filename\">Filename: lib.cairo</span>"
#~ msgstr "<span class=\"filename\">文件名：lib.cairo</span>"

#~ msgid ""
#~ "```rust\n"
#~ "    balances.insert('Alex', 100_u64);\n"
#~ "    balances.insert('Maria', 50_u64);\n"
#~ "    balances.insert('Alex', 200_u64);\n"
#~ "    balances.get('Maria');\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    balances.insert('Alex', 100_u64);\n"
#~ "    balances.insert('Maria', 50_u64);\n"
#~ "    balances.insert('Alex', 200_u64);\n"
#~ "    balances.get('Maria');\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let mut dict: Felt252Dict<u64> = Default::default();\n"
#~ "\n"
#~ "    custom_insert(ref dict, '0', 100);\n"
#~ "\n"
#~ "    let val = custom_get(ref dict, '0');\n"
#~ "\n"
#~ "    assert(val == 100, 'Expecting 100');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let mut dict: Felt252Dict<u64> = Default::default();\n"
#~ "\n"
#~ "    custom_insert(ref dict, '0', 100);\n"
#~ "\n"
#~ "    let val = custom_get(ref dict, '0');\n"
#~ "\n"
#~ "    assert(val == 100, 'Expecting 100');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let mut db = UserDatabaseTrait::new();\n"
#~ "\n"
#~ "    db.add_user('Alex', 100);\n"
#~ "    db.add_user('Maria', 80);\n"
#~ "\n"
#~ "    db.add_user('Alex', 40);\n"
#~ "    db.add_user('Maria', 0);\n"
#~ "\n"
#~ "    let alex_latest_balance = db.get_user('Alex');\n"
#~ "    let maria_latest_balance = db.get_user('Maria');\n"
#~ "\n"
#~ "    assert(alex_latest_balance == 40, 'Expected 40');\n"
#~ "    assert(maria_latest_balance == 0, 'Expected 0');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let mut db = UserDatabaseTrait::new();\n"
#~ "\n"
#~ "    db.add_user('Alex', 100);\n"
#~ "    db.add_user('Maria', 80);\n"
#~ "\n"
#~ "    db.add_user('Alex', 40);\n"
#~ "    db.add_user('Maria', 0);\n"
#~ "\n"
#~ "    let alex_latest_balance = db.get_user('Alex');\n"
#~ "    let maria_latest_balance = db.get_user('Maria');\n"
#~ "\n"
#~ "    assert(alex_latest_balance == 40, 'Expected 40');\n"
#~ "    assert(maria_latest_balance == 0, 'Expected 0');\n"
#~ "}\n"
#~ "```"

#~ msgid "The ability of contracts to interact with other smart contracts on the blockchain is a common pattern found in smart contract development."
#~ msgstr "合约与区块链上其他智能合约的互动能力是智能合约开发中的一个常见模式。"

#~ msgid "For your Cairo code to qualify as an interface, it must meet the following requirements:"
#~ msgstr "要使你的Cairo代码有资格成为一个接口，它必须满足以下要求："

#~ msgid ""
#~ "1. Must be appended with the `#[abi]` attribute.\n"
#~ "2. Your interface functions should have no implementations.\n"
#~ "3. You must explicitly declare the function's decorator.\n"
#~ "4. Your interface should not declare a constructor.\n"
#~ "5. Your interface should not declare state variables."
#~ msgstr ""
#~ "1. 必须附加 `#[abi]` 属性。\n"
#~ "2. 你的接口函数不应该有任何实现。\n"
#~ "3. 你必须明确地声明该函数的装饰器。\n"
#~ "4. 你的接口不应该声明一个构造函数。\n"
#~ "5. 你的接口不应该声明状态变量。"

#~ msgid "Here's a sample interface for an ERC20 token contract:"
#~ msgstr "下面是一个ERC20代币合约的接口样本："

#~ msgid "## ABIs"
#~ msgstr "## ABI"

#~ msgid ""
#~ "ABI stands for Application Binary Interface. ABIs gives a smart contract the ability to communicate and interact with external applications or other smart contracts. ABIs can be "
#~ "likened to APIs in traditional web development, which helps data flow between applications and servers."
#~ msgstr "ABI是指应用二进制接口。ABI使智能合约有能力与外部应用程序或其他智能合约进行沟通和互动。ABI可以比喻为传统网络开发中的API，它帮助数据在应用程序和服务器之间流动。"

#~ msgid "Every contract on Starknet has an Application Binary Interface (ABI) that defines how to encode and decode data when calling its methods."
#~ msgstr "Starknet上的每个合约都有一个应用二进制接口（ABI），它定义了在调用其方法时如何对数据进行编码和解码。"

#~ msgid "# Contract Dispatcher, Library Dispatcher and System calls"
#~ msgstr "# 合约调度器、库调度器和系统调用"

#~ msgid ""
#~ "Traits annotated with the `#[abi]` attribute are programmed to automatically generate and export the relevant dispatcher logic on compilation. The compiler also generates a new "
#~ "trait, two new structs (one for contract calls, and the other for library calls) and their implementation of this trait. Our interface is expanded into something like this:"
#~ msgstr ""
#~ "用`#[abi]`属性注释的trait会在编译时自动生成并导出相关的调度器。编译器也会生成一个新的trait、两个新的结构体（一个用于合约调用，另一个用于库调用）以及它们对这个trait的实现。我们的接"
#~ "口被扩展为如下："

#~ msgid ""
#~ "The key difference between the contract dispatcher and the library dispatcher is that while the contract dispatcher calls an external contract's logic in the external contract's "
#~ "context, the library dispatcher calls the target contract's class hash, whilst executing the call in the calling contract's context.\n"
#~ "So unlike the contract dispatcher, calls made using the library dispatcher have no possibility of tampering with the target contract's state."
#~ msgstr ""
#~ "合约调度器和库调度器的关键区别在于，合约调度器是在外部合约的上下文中调用外部合约的逻辑，而库调度器则是在调用合约的上下文中执行调用，调用目标契约的classhash。\n"
#~ "因此，与合约调度器不同，使用库调度器进行的调用不可能修改目标合约的状态。"

#~ msgid ""
#~ "As stated in the previous chapter, contracts annotated with the `#[abi]` macro on compilation generates a new trait, two new structs (one for contract calls, and the other for "
#~ "library calls) and their implementation of this trait. The expanded form of the library traits looks like:"
#~ msgstr "如前一章所述，在编译时用`#[abi]`宏标注的合约会生成一个新的trait、两个新的结构体（一个用于契约调用，另一个用于库调用）以及它们对该trait的实现。库特征的扩展形式看起来像："

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod TokenWrapper {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20LibraryDispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use super::ITokenWrapper;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
#~ "        fn token_name(self: @ContractState) -> felt252 {\n"
#~ "            IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }.name()\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer_token(\n"
#~ "            ref self: ContractState, recipient: ContractAddress, amount: u256\n"
#~ "        ) -> bool {\n"
#~ "            IERC20LibraryDispatcher {\n"
#~ "                class_hash: starknet::class_hash_const::<0x1234>()\n"
#~ "            }.transfer(recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod TokenWrapper {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20LibraryDispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use super::ITokenWrapper;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
#~ "        fn token_name(self: @ContractState) -> felt252 {\n"
#~ "            IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }.name()\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer_token(\n"
#~ "            ref self: ContractState, recipient: ContractAddress, amount: u256\n"
#~ "        ) -> bool {\n"
#~ "            IERC20LibraryDispatcher {\n"
#~ "                class_hash: starknet::class_hash_const::<0x1234>()\n"
#~ "            }.transfer(recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "As you can see, we had to first import the `IERC20DispatcherTrait` and `IERC20LibraryDispatcher` which were generated and exported after compiling our interface, then we make "
#~ "calls to the methods implemented for the `IERC20LibraryDispatcher` struct (`name`, `transfer`, etc), passing in the `class_hash` of the contract we want to call."
#~ msgstr ""
#~ "如您所见，我们必须首先导入`IERC20DispatcherTrait`和`IERC20LibraryDispatcher`，它们是在编译我们的接口后生成并导出的，然后我们调用为`IERC20LibraryDispatcher`结构实现的方法（`name`、"
#~ "`transfer`等），并传入我们要调用的合约的`class_hash`。"

#~ msgid "TODO (Not derivable yet ?)"
#~ msgstr "TODO (还不能派生？)"

#~ msgid ""
#~ "```console\n"
#~ "cairo-format -r\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "cairo-format -r\n"
#~ "```"

#~ msgid ""
#~ "Running this command reformats all the Cairo code in the current directory, recursively. This\n"
#~ "should only change the code style, not the code semantics."
#~ msgstr ""
#~ "运行这条命令可以递归式的重新格式化当前目录下的所有Cairo代码。这条命令\n"
#~ "只会改变代码的风格，而不会改变代码的语义。"

#~ msgid "Writing Starknet Contracts"
#~ msgstr "编写Starknet智能合约"

#~ msgid ""
#~ "```rust\n"
#~ "let rect = Rectangle { ... }; // Rectangle instantiation\n"
#~ "\n"
#~ "// First way, as a method on the struct instance\n"
#~ "let area1 = rect.area();\n"
#~ "// Second way, from the implementation\n"
#~ "let area2 = RectangleGeometry::area(rect);\n"
#~ "// `area1` has same value as `area2`\n"
#~ "area1.print();\n"
#~ "area2.print();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let rect = Rectangle { ... }; // Rectangle instantiation\n"
#~ "\n"
#~ "// First way, as a method on the struct instance\n"
#~ "let area1 = rect.area();\n"
#~ "// Second way, from the implementation\n"
#~ "let area2 = RectangleGeometry::area(rect);\n"
#~ "// `area1` has same value as `area2`\n"
#~ "area1.print();\n"
#~ "area2.print();\n"
#~ "```"

#~ msgid "If the code was organised into modules like this,"
#~ msgstr "如果代码被如下般组织成模块,"

#~ msgid "you might also need to use `CircleGeometry`,"
#~ msgstr "你可能还需要使用`CircleGeometry`、"

#~ msgid ""
#~ "Ethereum, being the most widely used and resilient smart-contract platform, became a victim of its own success. With the rapid adoption of some previously mentioned use cases, "
#~ "mainly DeFi, the cost of performing transactions became extremely high, rendering the network almost unusable. Engineers and researchers in the ecosystem began working on "
#~ "solutions to address this scalability issue. A famous theorem in the blockchain space states that it is impossible to achieve a high level of scalability, decentralization, and "
#~ "security simultaneously; trade-offs must be made. Ethereum is at the intersection of decentralization and security. Eventually, it was decided that Ethereum's purpose would be to "
#~ "serve as a secure settlement layer, while complex computations would be offloaded to other networks built on top of Ethereum. These are called Layer 2s (L2s). The two primary "
#~ "types of L2s are optimistic rollups and validity rollups. Both approaches involve compressing and batching numerous transactions together, computing the new state, and settling "
#~ "the result on Ethereum (L1). The difference lies in the way the result is settled on L1. For optimistic rollups, the new state is considered valid by default, but there is a 7-day "
#~ "window for nodes to identify malicious transactions. In contrast, validity rollups, such as Starknet, use cryptography to prove that the new state has been correctly computed. "
#~ "This is the purpose of STARKs, this cryptographic technology could permit validity rollups to scale significantly more than optimistic rollups. You can learn more about STARKs "
#~ "from Starkware's Medium [article](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), which serves as a good primer."
#~ msgstr ""
#~ "以太坊作为使用最广泛、弹性最大的智能合约平台，成为了其自身成功的受害者。随着前面提到的一些用例的快速采用，主要是DeFi，执行交易的成本变得非常高，使网络几乎无法使用。生态系统中的工程"
#~ "师和研究人员开始研究解决这一可扩展性问题的方案。区块链领域的一个著名定理指出，不可能同时实现高水平的可扩展性、去中心化和安全性；必须做出权衡。以太坊正处于去中心化和安全的交叉点。最"
#~ "终，人们决定，以太坊的目的是作为一个安全的结算层，而复杂的计算将被卸载到建立在以太坊之上的其他网络。这些被称为第二层（L2）。L2的两种主要类型是optimistic-rollups和validity-rollups。"
#~ "这两种方法都涉及到将众多交易压缩和批量化，计算新的状态，并将结果在以太坊（L1）上结算。区别在于结果在L1上结算的方式。对于optimistic-rollups，新的状态默认被认为是有效的，但有一个7天"
#~ "的窗口供节点识别恶意交易。相比之下，validity-rollups，如Starknet，使用密码学来证明新的状态已经被正确计算出来。这是STARKs的目的，这种加密技术可以允许validity-rollups的规模大大超过"
#~ "optimistic-rollups。你可以从Starkware的Medium[文章](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a)中了解更多关于STARKs的信息，这可以作为一个很好的入门。"

#~ msgid "# Writing Starknet Contracts"
#~ msgstr "# 撰写Starknet合约"

#~ msgid "This chapter will guide you on how to create smart contracts in Cairo, and will clarify the distinction between Cairo programs and Starknet contracts."
#~ msgstr "本章将指导你如何在Cairo中创建智能合约，并将阐明Cairo程序和Starknet合约之间的区别。"

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod example {\n"
#~ "    use starknet::get_caller_address;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    struct Storage {\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>, \n"
#~ "    }\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn get_name(_address: ContractAddress) -> felt252 {\n"
#~ "        let name = names::read(_address);\n"
#~ "        return name;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod example {\n"
#~ "    use starknet::get_caller_address;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    struct Storage {\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>, \n"
#~ "    }\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn get_name(_address: ContractAddress) -> felt252 {\n"
#~ "        let name = names::read(_address);\n"
#~ "        return name;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "## Starknet Contract Attributes"
#~ msgstr "## Starknet合约的属性"

#~ msgid "Attributes are special annotations that modify the behavior of certain functions or methods. They are placed preceding a function and are denoted by the `#[]` symbol."
#~ msgstr "属性是修改某些函数或方法的行为的特殊标注。它们被放在一个函数的前面，用`#[]`符号来表示。"

#~ msgid "Here is a list of common attributes used in Starknet contracts:"
#~ msgstr "以下是Starknet合约中使用的常见属性列表："

#~ msgid ""
#~ "1. `#[contract]`: This attribute is used to annotate a module to be compiled as a Starknet contract.\n"
#~ "   The compiler recognizes this attribute and prepares the module with necessary contract elements,\n"
#~ "   such as the logic to handle external contract calls or how to access storage variables.\n"
#~ "\n"
#~ "2. `#[constructor]`: This attribute marks a function as a constructor. The constructor function is called only once upon deploying a contract, setting the initial state of the "
#~ "contract.\n"
#~ "\n"
#~ "3. `#[external]`: This attribute marks a function as an external function. External functions can be called by other contracts or externally and can modify the contract's state.\n"
#~ "\n"
#~ "4. `#[view]`: This attribute marks a function as a view function. View functions are read-only functions that allow you to access data from the contract, but prevent you from "
#~ "modifying the state of the blockchain.\n"
#~ "\n"
#~ "5. `#[event]`: This is used to define events that can be emitted by the contract.\n"
#~ "\n"
#~ "6. `#[l1_handler]`: This attribute is used to mark functions which can receive messages from L1s."
#~ msgstr ""
#~ "1. `#[contract]`：这个属性用来标注一个要被编译为Starknet合约的模块。\n"
#~ "   编译器会识别这个属性并为模块准备必要的合同元素、\n"
#~ "   例如，处理外部合同调用的逻辑或如何访问存储变量。\n"
#~ "\n"
#~ "2. `#[constructor]`：这个属性标志着一个函数是一个构造函数。构造函数在部署合约时只被调用一次，设置合约的初始状态。\n"
#~ "\n"
#~ "3. `#[external]`：这个属性标志着一个函数是一个外部函数。外部函数可以被其他合约或外部调用，可以修改合约的状态。\n"
#~ "\n"
#~ "4. `#[view]`：这个属性标志着一个函数是一个视图函数。视图函数是只读函数，允许你访问合约中的数据，但阻止你修改区块链的状态。\n"
#~ "\n"
#~ "5. `#[event]`：这是用来定义可由合约发出的事件。\n"
#~ "\n"
#~ "6. `#[l1_handler]`：这个属性用来标记可以接收L1消息的函数。"

#~ msgid ""
#~ "An event is defined as an empty function annotated with the `#[event]` attribute. The parameters of this function\n"
#~ "are the data that will be emitted by the event."
#~ msgstr ""
#~ "一个事件被定义为一个用`#[event]`属性注释的空函数。这个函数的参数\n"
#~ "的参数是将由该事件发出的数据。"

#~ msgid "In Listing 99-1, `StoredName` is an event that emits information when names are stored in the contract:"
#~ msgstr "在示例99-1中，`StoredName`是一个当名字被存储在合约中时，会被触发并发出信息的事件："

#~ msgid ""
#~ "```rust\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "```"

#~ msgid ""
#~ "We pass in the emitted data types as parameters within the parentheses. In this example, our event will emit the contract address of the caller and the name stored within the "
#~ "contract."
#~ msgstr "我们在括号内传入作为把发射的数据类型参数传入。在这个例子中，我们的事件将发出调用者的合同地址和存储在合同中的名字的信息。"

#~ msgid ""
#~ "After defining events, we can emit them by simply calling the event name like we'll call functions,\n"
#~ "passing in the values to be emitted as parameters:"
#~ msgstr ""
#~ "定义完事件后，我们可以像调用函数一样简单地调用事件名称来发射它们、\n"
#~ "作为参数传入要发射的值："

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        address: starknet::ContractAddress, selector: felt252, calldata: Array<felt252>\n"
#~ "    ) -> Span::<felt252> {\n"
#~ "        starknet::call_contract_syscall(address, selector, calldata.span()).unwrap_syscall()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        address: starknet::ContractAddress, selector: felt252, calldata: Array<felt252>\n"
#~ "    ) -> Span::<felt252> {\n"
#~ "        starknet::call_contract_syscall(address, selector, calldata.span()).unwrap_syscall()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- Disable previous Cairo 0.x extension\n"
#~ "- Install the Cairo 1 extension for proper syntax highlighting and code navigation.\n"
#~ "  Just follow the steps indicated [here](https://github.com/starkware-libs/cairo/blob/main/vscode-cairo/README.md)."
#~ msgstr ""
#~ "- 禁用以前的 Cairo 0.x 扩展\n"
#~ "- 安装Cairo 1扩展以获得正确的语法高亮和代码导航。\n"
#~ "只要按照[这里](https://github.com/starkware-libs/cairo/blob/main/vscode-cairo/README.md)所示的步骤就可以了。"

#~ msgid "As for now, Scarb needs manual installation with the following steps:"
#~ msgstr "就目前而言，Scarb需要手动安装，步骤如下："

#~ msgid ""
#~ "- Download the release archive matching your operating system and CPU architecture, from [Scarb releases on GitHub](https://github.com/software-mansion/scarb/releases)\n"
#~ "- Extract it to a location where you would like to have Scarb installed, e.g. `~/scarb`\n"
#~ "- Add path to the `scarb/bin` directory to your `PATH` environment variable.\n"
#~ "\n"
#~ "  This depend on what shell you are using. Let’s take the example of [zsh](https://ohmyz.sh/) and you have extracted Scarb to `~/scarb`:\n"
#~ "\n"
#~ "  - Open `~/.zshrc` file in your favorite editor\n"
#~ "  - Add the following line to the end of the file: `export PATH=\"$PATH:~/scarb/bin\"`\n"
#~ "\n"
#~ "- Verify installation by running the following command in new terminal session, it should print both Scarb and Cairo language versions, e.g:\n"
#~ "\n"
#~ "  ```bash\n"
#~ "  $ scarb --version\n"
#~ "  scarb 0.3.0 (182a9019d 2023-05-29)\n"
#~ "  cairo: 1.1.0 (https://crates.io/crates/cairo-lang-compiler/1.1.0)\n"
#~ "  ```"
#~ msgstr ""
#~ "- 从[GitHub上的Scarb发布页](https://github.com/software-mansion/scarb/releases)下载与你的操作系统和CPU架构相匹配的Release档案。\n"
#~ "- 将其解压到你想安装Scarb的位置，例如`~/scarb`。\n"
#~ "- 将`scarb/bin`目录的路径添加到你的`PATH`环境变量中。\n"
#~ "\n"
#~ "  这取决于你使用的是什么shell。让我们以[zsh](https://ohmyz.sh/)为例，将Scarb解压到`~/scarb`后：\n"
#~ "\n"
#~ "  - 用你爱用的编辑器打开`~/.zshrc`文件\n"
#~ "  - 在文件的末尾添加以下行：`export PATH=\"$PATH:~/scarb/bin\"`。\n"
#~ "\n"
#~ "- 在新的终端会话中运行以下命令来验证安装是否成功，它应该同时打印Scarb和Cairo语言的版本，例如：\n"
#~ "\n"
#~ "  ```bash\n"
#~ "  $ scarb --version\n"
#~ "  scarb 0.3.0 (182a9019d 2023-05-29)\n"
#~ "  cairo: 1.1.0 (https://crates.io/crates/cairo-lang-compiler/1.1.0)\n"
#~ "  ```"

#~ msgid ""
#~ "```rs\n"
#~ "let direction = Direction::North(());\n"
#~ "```"
#~ msgstr ""
#~ "```rs\n"
#~ "let direction = Direction::North(());\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let msg: Message = Message::Quit(());\n"
#~ "msg.process();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let msg: Message = Message::Quit(());\n"
#~ "msg.process();\n"
#~ "```"

#~ msgid ""
#~ "```rs\n"
#~ "enum Option<T> {\n"
#~ "    Some: T,\n"
#~ "    None: (),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rs\n"
#~ "enum Option<T> {\n"
#~ "    Some: T,\n"
#~ "    None: (),\n"
#~ "}\n"
#~ "```"

#~ msgid "Compiling the above code would error due to the `derive` macro not working well with generics. When using generic types is best to directly write the traits you want to use:"
#~ msgstr "由于`derive`宏在泛型中不能正常工作，编译上述代码会出错。当使用泛型时，最好直接编写你想使用的特性："

#~ msgid "<!-- TODO This is no longer true after in version 1.1.x and should be removed in the next versions -->"
#~ msgstr "<!-- TODO This is no longer true after in version 1.1.x and should be removed in the next versions -->"

#~ msgid ""
#~ "```rust\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of Drop<Wallet<T, U>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3, address: 14 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of Drop<Wallet<T, U>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3, address: 14 };\n"
#~ "}\n"
#~ "```"

#~ msgid "Listing 8-1: A test module and function"
#~ msgstr "示例8-1：一个测试模块和函数"

#~ msgid "Listing 8-2: The output from running a test"
#~ msgstr "示例8-2：运行一个测试的输出结果"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7,\n"
#~ "            width: 8,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1,\n"
#~ "            width: 5,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7,\n"
#~ "            width: 8,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1,\n"
#~ "            width: 5,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        // --snip--\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7,\n"
#~ "            width: 8,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1,\n"
#~ "            width: 5,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        // --snip--\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7,\n"
#~ "            width: 8,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1,\n"
#~ "            width: 5,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// —snip—\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1{\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value, }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1{\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value, }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "if value < 1{\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be <= 100');\n"
#~ "    panic(data);\n"
#~ "} else if value > 100{\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be >= 1');\n"
#~ "    panic(data);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "if value < 1{\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be <= 100');\n"
#~ "    panic(data);\n"
#~ "} else if value > 100{\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be >= 1');\n"
#~ "    panic(data);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn test_function_2() {\n"
#~ "    let number: felt252 = 258_felt252;\n"
#~ "    match do_something_with_parse_u8(number) {\n"
#~ "        Result::Ok(value) => value.print(),\n"
#~ "        Result::Err(e) => e.print()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn test_function_2() {\n"
#~ "    let number: felt252 = 258_felt252;\n"
#~ "    match do_something_with_parse_u8(number) {\n"
#~ "        Result::Ok(value) => value.print(),\n"
#~ "        Result::Err(e) => e.print()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Starknet contracts are denoted by the `#[contract]` attribute. We'll dive deeper into this in the next sections."
#~ msgstr "Starknet合约是由`#[contract]`属性表示的。我们将在接下来的章节中更深入地探讨这个问题。"

#~ msgid ""
#~ "```rust\n"
#~ "//**** Specify interface here ****//\n"
#~ "\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(\n"
#~ "        _contract_address: ContractAddress\n"
#~ "    ) -> felt252 {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//**** Specify interface here ****//\n"
#~ "\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(\n"
#~ "        _contract_address: ContractAddress\n"
#~ "    ) -> felt252 {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "<span class=\"caption\">Listing 99-4: An expanded form of the IERC20 trait</span>"
#~ msgstr "<span class=\"caption\">示例99-4：IERC20trait的扩展形式</span>"

#~ msgid ""
#~ "```rust\n"
#~ "{\n"
#~ "    let x = 3;\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "{\n"
#~ "    let x = 3;\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let span = array.span();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let span = array.span();\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "arr.append(1);\n"
#~ "arr.append(2);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "arr.append(1);\n"
#~ "arr.append(2);\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "let second_length = calculate_length(@arr1); // Calculate the current length of the array\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: 'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username: username,\n"
#~ "        email: email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username: username,\n"
#~ "        email: email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username,\n"
#~ "        email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username,\n"
#~ "        email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    enum Option<T> {\n"
#~ "        Some: T,\n"
#~ "        None: (),\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    enum Option<T> {\n"
#~ "        Some: T,\n"
#~ "        None: (),\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "In the next chapter, we’ll look at some collection data structures in the\n"
#~ "standard library that you can use in your neatly organized code."
#~ msgstr "在下一章中，让我们看看一些标准库提供的集合数据类型，你可以利用它们编写出漂亮整洁的代码。"

#~ msgid ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some(T),\n"
#~ "    None,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some(T),\n"
#~ "    None,\n"
#~ "}\n"
#~ "```"
