msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2023-11-21T20:02:02+01:00\n"
"PO-Revision-Date: 2023-12-11 11:57+0700\n"
"Last-Translator: megumii <contact@megumii.xyz>\n"
"Language-Team: Indonesian\n"
"Language: id\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr "Bahasa Pemrograman Cairo"

#: src/SUMMARY.md:3
msgid "The Cairo Programming Language Foreword Introduction"
msgstr "Pengantar Awal Bahasa Pemrograman Cairo"

#: src/SUMMARY.md:7 src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr "Memulai"

#: src/SUMMARY.md:11 src/ch01-01-installation.md:1 src/ch01-01-installation.md:19
msgid "Installation"
msgstr "Instalasi"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr "Hello, World!"

#: src/SUMMARY.md:14 src/SUMMARY.md:16 src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr "Konsep Pemrograman Umum"

#: src/SUMMARY.md:17 src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "Variabel dan Mutabilitas"

#: src/SUMMARY.md:18 src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "Tipe Data"

#: src/SUMMARY.md:19 src/ch02-03-functions.md:1
msgid "Functions"
msgstr "Fungsi"

#: src/SUMMARY.md:20 src/ch02-04-comments.md:1
msgid "Comments"
msgstr "Komentar"

#: src/SUMMARY.md:21 src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "Alur Kontrol"

#: src/SUMMARY.md:23 src/SUMMARY.md:25 src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr "Koleksi Umum"

#: src/SUMMARY.md:26 src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "Array"

#: src/SUMMARY.md:27 src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr ""

#: src/SUMMARY.md:28 src/ch03-03-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "Struktur Data Kustom"

#: src/SUMMARY.md:30 src/SUMMARY.md:32
msgid "Understanding Ownership"
msgstr "Memahami Kepemilikan"

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr "Apa Itu Kepemilikan?"

#: src/SUMMARY.md:34 src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "Referensi dan Snapshot"

#: src/SUMMARY.md:36 src/SUMMARY.md:38 src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr "Menggunakan Struct untuk Struktur Data Terkait"

#: src/SUMMARY.md:39 src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "Mendefinisikan dan Menginstansiasi Struct"

#: src/SUMMARY.md:40 src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "Contoh Program Menggunakan Struct"

#: src/SUMMARY.md:41 src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "Sintaks Metode"

#: src/SUMMARY.md:43 src/SUMMARY.md:45 src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr "Enum dan Pola Penyesuaian"

#: src/SUMMARY.md:46 src/ch06-01-enums.md:1 src/ch08-01-generic-data-types.md:163
msgid "Enums"
msgstr "Enum"

#: src/SUMMARY.md:47 src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "Konstruksi Alur Kontrol Cocok"

#: src/SUMMARY.md:49 src/SUMMARY.md:51 src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Mengelola Proyek Cairo dengan Paket, Krate, dan Modul"

#: src/SUMMARY.md:53 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "Paket dan Krate"

#: src/SUMMARY.md:54 src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "Mendefinisikan Modul untuk Mengontrol Ruang Lingkup"

#: src/SUMMARY.md:55 src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Jalur untuk Merujuk pada Item dalam Pohon Modul"

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "Membawa Jalur ke Ruang Lingkup dengan Kata Kunci 'use'"

#: src/SUMMARY.md:57 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "Memisahkan Modul ke File yang Berbeda"

#: src/SUMMARY.md:59 src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "Tipe Data Generik"

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr "Tipe Generik"

#: src/SUMMARY.md:63 src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr "Fungsi Generik"

#: src/SUMMARY.md:64 src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "Sifat dalam Cairo"

#: src/SUMMARY.md:66 src/SUMMARY.md:68 src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr "Menguji Program Cairo"

#: src/SUMMARY.md:70 src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "Cara Menulis Tes"

#: src/SUMMARY.md:71 src/ch09-02-test-organization.md:1
msgid "Testing Organization"
msgstr "Organisasi Pengujian"

#: src/SUMMARY.md:73 src/SUMMARY.md:75
msgid "Error Handling"
msgstr "Penanganan Kesalahan"

#: src/SUMMARY.md:77 src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr "Kesalahan yang Tidak Dapat Diperbaiki dengan panic"

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr "Kesalahan yang Dapat Diperbaiki dengan Hasil"

#: src/SUMMARY.md:80 src/SUMMARY.md:82 src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr "Fitur Lanjutan"

#: src/SUMMARY.md:84 src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "Peng-overloadan Operator"

#: src/SUMMARY.md:85 src/ch11-02-macros.md:1
msgid "Macros"
msgstr "Makro"

#: src/SUMMARY.md:87
msgid "Starknet smart contracts"
msgstr "Kontrak pintar Starknet"

#: src/SUMMARY.md:89 src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr "Kontrak Pintar Starknet"

#: src/SUMMARY.md:91 src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr "Pengantar kontrak pintar"

#: src/SUMMARY.md:92 src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr "Kontrak sederhana"

#: src/SUMMARY.md:93 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr "Penggalian lebih dalam ke dalam kontrak"

#: src/SUMMARY.md:95 src/ch99-01-03-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "Penyimpanan Kontrak"

#: src/SUMMARY.md:96 src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "Fungsi Kontrak"

#: src/SUMMARY.md:97
msgid "Contract Events"
msgstr "Event Kontrak"

#: src/SUMMARY.md:98 src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr "Mengurangi boilerplate"

#: src/SUMMARY.md:99
msgid "Optimizing storage costs"
msgstr "Mengoptimalkan biaya penyimpanan"

#: src/SUMMARY.md:101
msgid "Components"
msgstr "Komponen"

#: src/SUMMARY.md:103
msgid "Under the hood"
msgstr "Di balik layar"

#: src/SUMMARY.md:104 src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr "Ketergantungan komponen"

#: src/SUMMARY.md:105 src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr "Menguji komponen"

#: src/SUMMARY.md:107
msgid "ABIs and Cross-contract Interactions"
msgstr "ABIs dan Interaksi antar Kontrak"

#: src/SUMMARY.md:109
msgid "ABIs and Interfaces"
msgstr "ABIs dan Antarmuka"

#: src/SUMMARY.md:110
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr "Pengirim Kontrak, Pengirim Pustaka, dan pemanggilan sistem"

#: src/SUMMARY.md:112 src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr "Contoh lainnya"

#: src/SUMMARY.md:114 src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "Mendeploy dan Berinteraksi dengan kontrak pemungutan suara"

#: src/SUMMARY.md:116
msgid "L1 \\<\\> L2 Messaging"
msgstr "Pesan L1 \\<\\> L2"

#: src/SUMMARY.md:117 src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr "Pertimbangan Keamanan"

#: src/SUMMARY.md:119 src/appendix-00.md:1
msgid "Appendix"
msgstr "Lampiran"

#: src/SUMMARY.md:121
msgid "A - Keywords"
msgstr "A - Kata Kunci"

#: src/SUMMARY.md:122
msgid "B - Operators and Symbols"
msgstr "B - Operator dan Simbol"

#: src/SUMMARY.md:123
msgid "C - Derivable Traits"
msgstr "C - Sifat yang Dapat Diambil"

#: src/SUMMARY.md:124
msgid "D - Useful Development Tools"
msgstr "D - Alat Pengembangan yang Berguna"

#: src/SUMMARY.md:125
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr "E - Tipe dan Sifat Umum serta Pendahuluan Cairo"

#: src/SUMMARY.md:126
msgid "F - Installing Cairo binaries"
msgstr "F - Menginstal biner Cairo"

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-book.github.io). Special "
"thanks to [Starkware](https://starkware.co/) through [OnlyDust](https://www.onlydust.xyz/), and [Voyager]"
"(https://voyager.online/) for supporting the creation of this book."
msgstr ""
"dari Komunitas Cairo dan [kontributornya](https://github.com/cairo-book/cairo-book.github.io). Terima kasih "
"khusus kepada [Starkware](https://starkware.co/) melalui [OnlyDust](https://www.onlydust.xyz/), dan [Voyager]"
"(https://voyager.online/) atas dukungannya dalam pembuatan buku ini."

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo Compiler](https://github.com/starkware-libs/cairo) "
"[version 2.2.0](https://github.com/starkware-libs/cairo/releases). See the “Installation” section of Chapter 1 "
"to install or update Cairo."
msgstr ""
"Versi teks ini diasumsikan Anda menggunakan [Compiler Cairo](https://github.com/starkware-libs/cairo) [versi "
"2.2.0](https://github.com/starkware-libs/cairo/releases). Lihat bagian \"Instalasi\" dari Bab 1 untuk menginstal "
"atau memperbarui Cairo."

#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr "Pendahuluan"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language supporting verifiable computation. "
"Cairo started as an assembly language and gradually became more expressive. The learning curve was initially "
"steep, as Cairo 0.x was a low-level language that did not entirely abstract the underlying cryptographic "
"primitives required to build a proof for the execution of a program."
msgstr ""
"Pada tahun 2020, StarkWare merilis Cairo 0, bahasa pemrograman Turing-complete yang mendukung komputasi yang "
"dapat diverifikasi. Cairo awalnya merupakan bahasa assembly dan secara bertahap menjadi lebih ekspresif. Kurva "
"pembelajarannya pada awalnya curam, karena Cairo 0.x adalah bahasa tingkat rendah yang tidak sepenuhnya "
"mengabstraksi primitif kriptografis yang mendasari yang diperlukan untuk membangun bukti untuk eksekusi program."

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably improved, abstracting away the underlying "
"immutable memory model of the Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has been "
"built to help you create provable programs without specific knowledge of its underlying architecture so that you "
"can focus on the program itself, increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build an extensive test suite without "
"compromising on performance."
msgstr ""
"Dengan rilis Cairo 1, pengalaman pengembang telah meningkat secara signifikan, mengabstraksi model memori tak "
"berubah yang mendasari arsitektur Cairo bila memungkinkan. Terinspirasi kuat oleh Rust, Cairo 1 dibangun untuk "
"membantu Anda membuat program yang dapat dibuktikan tanpa pengetahuan khusus tentang arsitektur dasarnya "
"sehingga Anda dapat mengutamakan program itu sendiri, meningkatkan keamanan keseluruhan program Cairo. Didukung "
"oleh VM Rust, eksekusi program Cairo sekarang sangat cepat, memungkinkan Anda membangun serangkaian uji yang "
"luas tanpa mengorbankan kinerja."

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code "
"their smart contracts. This allows the Starknet OS to generate execution traces for transactions to be proved by "
"a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet."
msgstr ""
"Para pengembang blockchain yang ingin mendeploy kontrak di Starknet akan menggunakan bahasa pemrograman Cairo "
"untuk membuat kontrak pintar mereka. Hal ini memungkinkan OS Starknet untuk menghasilkan jejak eksekusi untuk "
"transaksi yang akan dibuktikan oleh pembuktian, yang kemudian diverifikasi di Ethereum L1 sebelum memperbarui "
"root state dari Starknet."

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used "
"for any computation that would benefit from being proved on one computer and verified on other machines with "
"lower hardware requirements."
msgstr ""
"Namun, Cairo bukan hanya untuk pengembang blockchain. Sebagai bahasa pemrograman umum, ia dapat digunakan untuk "
"komputasi apa pun yang akan mendapatkan manfaat dari pembuktian pada satu komputer dan verifikasi pada mesin "
"lain dengan persyaratan perangkat keras yang lebih rendah."

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of programming concepts. It is a friendly and "
"approachable text intended to help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there is to know about Cairo!"
msgstr ""
"Buku ini dirancang untuk para pengembang dengan pemahaman dasar tentang konsep-konsep pemrograman. Ini adalah "
"teks yang ramah dan mudah dipahami yang dimaksudkan untuk membantu Anda meningkatkan pengetahuan Anda tentang "
"Cairo, tetapi juga membantu Anda mengembangkan keterampilan pemrograman Anda secara umum. Jadi, mulailah dan "
"bersiaplah untuk belajar segala hal tentang Cairo!"

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr "— The Cairo community"

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr "Pengenalan"

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr "Apa itu Cairo?"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. The unique aspect of this processor "
"is that it was not created for the physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. This means that you can perform time "
"consuming operations on a machine you don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo 1 is a more high level language. It "
"first compiles to Sierra, an intermediate representation of Cairo which will compile later down to a safe subset "
"of CASM. The point of Sierra is to ensure your CASM will always be provable, even when the computation fails."
msgstr ""
"Cairo adalah bahasa pemrograman yang dirancang untuk CPU virtual dengan nama yang sama. Aspek unik dari prosesor "
"ini adalah bahwa prosesor ini tidak diciptakan untuk batasan fisik dunia kita tetapi untuk batasan kriptografis, "
"sehingga mampu membuktikan secara efisien eksekusi dari setiap program yang berjalan di atasnya. Ini berarti "
"Anda dapat melakukan operasi yang membutuhkan waktu lama pada mesin yang tidak Anda percayai, dan memeriksa "
"hasilnya dengan cepat pada mesin yang lebih murah. Sementara Cairo 0 dahulu dikompilasi langsung ke CASM, yaitu "
"bahasa rakitan CPU Cairo, Cairo 1 adalah bahasa yang lebih tinggi levelnya. Pertama-tama, ia dikompilasi ke "
"Sierra, representasi perantara Cairo yang kemudian akan dikompilasi menjadi subset aman dari CASM. Tujuan dari "
"Sierra adalah memastikan bahwa CASM Anda akan selalu bisa dibuktikan, bahkan ketika komputasi gagal."

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr "Apa yang bisa Anda lakukan dengannya?"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One major usecase is Starknet, a solution "
"to Ethereum scaling. Ethereum is a decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is verified by all the participants. "
"Starknet is a Layer 2 built on top of Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the programs and generates proofs that the "
"computations were done correctly. These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the interactions themselves. This approach allows "
"for increased throughput and reduced transaction costs while preserving Ethereum security."
msgstr ""
"Cairo memungkinkan Anda menghitung nilai yang dapat dipercaya pada mesin yang tidak dapat dipercaya. Salah satu "
"penggunaan utamanya adalah Starknet, solusi untuk skalabilitas Ethereum. Ethereum adalah platform blockchain "
"terdesentralisasi yang memungkinkan pembuatan aplikasi terdesentralisasi di mana setiap interaksi antara "
"pengguna dan d-app diverifikasi oleh semua peserta. Starknet adalah Layer 2 yang dibangun di atas Ethereum. Alih-"
"alih memerlukan semua peserta jaringan untuk memverifikasi semua interaksi pengguna, hanya satu node, yang "
"disebut pembuktian, yang menjalankan program dan menghasilkan bukti bahwa komputasi dilakukan dengan benar. "
"Bukti-bukti ini kemudian diverifikasi oleh kontrak pintar Ethereum, memerlukan daya komputasi yang jauh lebih "
"sedikit dibandingkan dengan mengeksekusi interaksi itu sendiri. Pendekatan ini memungkinkan peningkatan "
"throughput dan pengurangan biaya transaksi sambil mempertahankan keamanan Ethereum."

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr "Apa perbedaannya dengan bahasa pemrograman lainnya?"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially when it comes to overhead costs and "
"its primary advantages. Your program can be executed in two different ways:"
msgstr ""
"Cairo cukup berbeda dari bahasa pemrograman tradisional, terutama ketika datang ke biaya overhead dan keuntungan "
"utamanya. Program Anda dapat dieksekusi dengan dua cara yang berbeda:"

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because Cairo is virtualized, and because the "
"operations were not specifically designed for maximum efficiency, this can lead to some performance overhead but "
"it is not the most relevant part to optimize."
msgstr ""
"Ketika dieksekusi oleh pembuktian, ini mirip dengan bahasa lainnya. Karena Cairo tervirtualisasi, dan karena "
"operasi-operasi tidak dirancang khusus untuk efisiensi maksimum, ini bisa menyebabkan beberapa overhead kinerja "
"tetapi bukan bagian yang paling relevan untuk dioptimalkan."

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. This has to be as cheap as possible "
"since it could potentially be verified on many very small machines. Fortunately verifying is faster than "
"computing and Cairo has some unique advantages to improve it even more. A notable one is non-determinism. This "
"is a topic you will cover in more detail later in this book, but the idea is that you can theoretically use a "
"different algorithm for verifying than for computing. Currently, writing custom non-deterministic code is not "
"supported for the developers, but the standard library leverages non-determinism for improved performance. For "
"example sorting an array in Cairo costs the same price as copying it. Because the verifier doesn't sort the "
"array, it just checks that it is sorted, which is cheaper."
msgstr ""
"Ketika bukti yang dihasilkan diverifikasi oleh verifikasi, ini sedikit berbeda. Ini harus seefisien mungkin "
"karena dapat diverifikasi di banyak mesin yang sangat kecil. Untungnya, verifikasi lebih cepat daripada "
"perhitungan dan Cairo memiliki beberapa keunggulan unik untuk meningkatkannya lebih jauh. Salah satunya adalah "
"nondeterminisme. Ini adalah topik yang akan anda bahas lebih detail nanti dalam buku ini, tetapi ideanya adalah "
"bahwa secara teoritis Anda dapat menggunakan algoritma yang berbeda untuk verifikasi daripada untuk komputasi. "
"Saat ini, menulis kode nondeterministik khusus tidak didukung bagi para pengembang, tetapi perpustakaan standar "
"memanfaatkan nondeterminisme untuk kinerja yang lebih baik. Sebagai contoh, mengurutkan sebuah larik di Cairo "
"memiliki biaya yang sama dengan menyalinnya. Karena verifikator tidak mengurutkan larik tersebut, ia hanya "
"memeriksa bahwa larik tersebut terurut, yang lebih murah."

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, memory access is immutable, meaning "
"that once a value is written to memory, it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. Therefore, developers must think "
"carefully about how they manage memory and data structures in their programs to optimize performance."
msgstr ""
"Aspek lain yang membedakan bahasa ini adalah model memori yang digunakannya. Dalam Cairo, akses memori bersifat "
"tidak berubah (immutable), yang berarti bahwa setelah suatu nilai ditulis ke dalam memori, nilai tersebut tidak "
"dapat diubah. Cairo 1 menyediakan abstraksi-abstraksi yang membantu para pengembang dalam mengatasi kendala-"
"kendala ini, namun tidak sepenuhnya mensimulasikan mutabilitas. Oleh karena itu, para pengembang harus "
"memikirkan dengan hati-hati bagaimana mereka mengelola memori dan struktur data dalam program-program mereka "
"untuk mengoptimalkan kinerja."

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr "Referensi"

#: src/ch00-00-introduction.md:24
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "Arsitektur Cairo CPU: <https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-"
"sierra-7f32808421f5>"
msgstr ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-"
"sierra-7f32808421f5>"

#: src/ch00-00-introduction.md:26
msgid "State of non determinism: <https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr "State of non determinism: <https://twitter.com/PapiniShahar/status/1638203716535713798>"

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading [Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the "
"Cairo compiler and the Cairo language server together in an easy-to-install package so that you can start "
"writing Cairo code right away."
msgstr ""
"Cairo dapat diinstal dengan cara mendownload [Scarb](https://docs.swmansion.com/scarb/docs). Scarb menggabungkan "
"kompiler Cairo dan server bahasa Cairo secara bersamaan dalam paket instalasi yang mudah sehingga Anda dapat "
"mulai menulis kode Cairo dengan cepat."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by [Cargo](https://doc.rust-lang.org/cargo/), "
"Rust’s build system and package manager."
msgstr ""
"Scarb juga merupakan pengelola paket Cairo yang sangat terinspirasi dari [Cargo](https://doc.rust-lang.org/"
"cargo/), sistem pembangunan dan pengelola paket Rust."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), "
"downloading the libraries your code depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb menangani banyak tugas untuk Anda, seperti membangun kode Anda (baik itu murni Cairo atau kontrak "
"Starknet), mengunduh pustaka-pustaka yang diperlukan oleh kode Anda, membangun pustaka-pustaka tersebut, dan "
"menyediakan dukungan LSP (Language Server Protocol) untuk ekstensi Cairo 1 pada VSCode."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if you start a project using Scarb, "
"managing external code and dependencies will be a lot easier to do."
msgstr ""
"Ketika Anda menulis program Cairo yang lebih kompleks, Anda mungkin akan menambahkan dependensi, dan jika Anda "
"memulai sebuah proyek menggunakan Scarb, mengelola kode eksternal dan dependensi akan menjadi lebih mudah."

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Mari mulai dengan menginstal Scarb."

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr "Menginstal Scarb"

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr "Persyaratan"

#: src/ch01-01-installation.md:17
msgid "Scarb requires a Git executable to be available in the `PATH` environment variable."
msgstr "Scarb memerlukan Git yang dapat dieksekusi agar tersedia dalam lingkungan variable `PATH`."

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We "
"strongly recommend that you install Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-"
"asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure "
"that the version of Scarb you use to work on a project always matches the one defined in the project settings, "
"avoiding problems lead to version mismatch. Otherwise, you can simply run the following command in your "
"terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb."
msgstr ""
"Untuk menginstal Scarb, silakan lihat [petunjuk instalasi](https://docs.swmansion.com/scarb/download). Kami "
"sangat menyarankan Anda untuk menginstal Scarb [melalui asdf](https://docs.swmansion.com/scarb/download."
"html#install-via-asdf), sebuah alat CLI yang dapat mengelola beberapa versi runtime bahasa pada basis proyek "
"tertentu. Ini akan memastikan bahwa versi Scarb yang Anda gunakan untuk bekerja pada suatu proyek selalu sesuai "
"dengan yang ditentukan dalam pengaturan proyek, menghindari masalah yang disebabkan oleh ketidakcocokan versi. "
"Atau, Anda dapat menjalankan perintah berikut di terminal Anda, dan ikuti petunjuk yang muncul di layar. Ini "
"akan menginstal rilis stabil terbaru dari Scarb."

#: src/ch01-01-installation.md:27
msgid "'=https'"
msgstr "'=https'"

#: src/ch01-01-installation.md:30
msgid ""
"Verify installation by running the following command in new terminal session, it should print both Scarb and "
"Cairo language versions, e.g:"
msgstr ""
"Verifikasi instalasi dengan menjalankan perintah berikut dalam sesi terminal baru, seharusnya akan mencetak "
"versi dari Scarb dan bahasa Cairo, contohnya:"

#: src/ch01-01-installation.md:39
msgid "Installing the VSCode extension"
msgstr "Menginstall ekstensi VSCode"

#: src/ch01-01-installation.md:41
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You "
"can install it from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1). Once installed, go into the extension settings, and make sure to tick the `Enable Language Server` and "
"`Enable Scarb` options."
msgstr ""
"Cairo memiliki ekstensi VSCode yang menyediakan penyorotan sintaks, penyelesaian kode, dan fitur-fitur berguna "
"lainnya. Anda dapat menginstalnya dari [VSCode Marketplace](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1). Setelah terinstal, pergi ke pengaturan ekstensi, dan pastikan untuk mencentang opsi "
"Enable Language Server dan Enable Scarb."

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "Hello, World"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first Cairo program. It’s traditional "
"when learning a new language to write a little program that prints the text `Hello, world!` to the screen, so "
"we’ll do the same here!"
msgstr ""
"Sekarang bahwa Anda telah menginstal Cairo melalui Scarb, saatnya untuk menulis program Cairo pertama Anda. "
"Adalah tradisi ketika belajar bahasa baru untuk menulis program kecil yang mencetak teks Hello, world! ke layar, "
"jadi kita akan melakukan hal yang sama di sini!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes no specific demands about your "
"editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) "
"instead of the command line, feel free to use your favorite IDE. The Cairo team has developed a VSCode extension "
"for the Cairo language that you can use to get the features from the language server and code highlighting. See "
"[Appendix D](appendix-04-useful-development-tools.md) for more details."
msgstr ""
"Catatan: Buku ini mengasumsikan pengetahuan dasar tentang baris perintah. Cairo tidak membuat persyaratan khusus "
"tentang pengeditan atau alat bantu Anda atau di mana kode Anda berada, jadi jika Anda lebih memilih untuk "
"menggunakan lingkungan pengembangan terpadu (IDE) daripada baris perintah, silakan gunakan IDE favorit Anda. Tim "
"Cairo telah mengembangkan ekstensi VSCode untuk bahasa Cairo yang dapat Anda gunakan untuk mendapatkan fitur "
"dari server bahasa dan penyorotan kode. Lihat [Lampiran D](appendix-04-useful-development-tools.md) untuk lebih "
"banyak detail."

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr "Membuat Direktori Proyek"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t matter to Cairo where your code lives, "
"but for the exercises and projects in this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"Anda akan memulai dengan membuat direktori untuk menyimpan kode Cairo Anda. Tidak masalah bagi Cairo di mana "
"kode Anda berada, tetapi untuk latihan dan proyek dalam buku ini, kami menyarankan untuk membuat direktori "
"cairo_projects di direktori rumah Anda dan menyimpan semua proyek Anda di sana."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ directory and a directory for the "
"“Hello, world!” project within the _cairo_projects_ directory."
msgstr ""
"Buka terminal dan masukkan perintah-perintah berikut untuk membuat direktori cairo_projects dan sebuah direktori "
"untuk proyek “Hello, world!” di dalam direktori _cairo_projects_."

#: src/ch01-02-hello-world.md:25
msgid ""
"Note: From now on, for each example shown in the book, we assume that you will be working from a Scarb project "
"directory. If you are not using Scarb, and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"Catatan: Mulai dari sekarang, untuk setiap contoh yang ditunjukkan dalam buku ini, kami mengasumsikan bahwa Anda "
"akan bekerja dari direktori proyek Scarb. Jika Anda tidak menggunakan Scarb, dan mencoba menjalankan contoh-"
"contoh dari direktori yang berbeda, Anda mungkin perlu menyesuaikan perintah-perintahnya atau membuat proyek "
"Scarb."

#: src/ch01-02-hello-world.md:28
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Untuk Linux, macOS, dan PowerShell di Windows, masukkan ini:"

#: src/ch01-02-hello-world.md:35
msgid "For Windows CMD, enter this:"
msgstr "Untuk Windows CMD, enter this:"

#: src/ch01-02-hello-world.md:38 src/ch01-02-hello-world.md:39
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:42
msgid "Creating a Project with Scarb"
msgstr "Membuat Projek dengan Scarb"

#: src/ch01-02-hello-world.md:44
msgid "Let’s create a new project using Scarb."
msgstr "Mari membuat sebuah projek menggunakan Scarb."

#: src/ch01-02-hello-world.md:46
msgid "Navigate to your projects directory (or wherever you decided to store your code). Then run the following:"
msgstr ""
"Masuk ke direktori proyek Anda (atau di mana pun Anda memutuskan untuk menyimpan kode Anda). Kemudian jalankan "
"perintah berikut:"

#: src/ch01-02-hello-world.md:52
msgid ""
"It creates a new directory and project called `hello_world`. We’ve named our project `hello_world`, and Scarb "
"creates its files in a directory of the same name."
msgstr ""
"Perintah tersebut akan membuat direktori dan proyek baru yang disebut `hello_world`. Kami telah memberi nama "
"proyek kami `hello_world`, dan Scarb membuat file-filenya di dalam direktori dengan nama yang sama."

#: src/ch01-02-hello-world.md:54
msgid ""
"Go into the `hello_world` directory with the command `cd hello_world`. You’ll see that Scarb has generated two "
"files and one directory for us: a `Scarb.toml` file and a src directory with a `lib.cairo` file inside."
msgstr ""
"Masuk ke direktori `hello_world` dengan perintah cd `hello_world`. Anda akan melihat bahwa Scarb telah "
"menghasilkan dua file dan satu direktori untuk kita: sebuah file `Scarb.toml` dan sebuah direktori src dengan "
"file lib.cairo di dalamnya."

#: src/ch01-02-hello-world.md:56
msgid "It has also initialized a new Git repository along with a `.gitignore` file"
msgstr "Scarb juga telah menginisialisasi repositori Git baru bersama dengan file `.gitignore`"

#: src/ch01-02-hello-world.md:58
msgid ""
"Note: Git is a common version control system. You can stop using version control system by using the `--vcs` "
"flag. Run `scarb new -help` to see the available options."
msgstr ""
"Catatan: Git adalah sistem kontrol versi yang umum digunakan. Anda dapat berhenti menggunakan sistem kontrol "
"versi dengan menggunakan opsi `--vcs`. Jalankan `scarb new -help` untuk melihat opsi yang tersedia."

#: src/ch01-02-hello-world.md:61
msgid "Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-2."
msgstr "Buka _Scarb.toml_ di editor teks pilihan Anda. Ini seharusnya terlihat mirip dengan kode pada Listing 1-2."

#: src/ch01-02-hello-world.md:63
msgid "Filename: Scarb.toml"
msgstr "Filename: Scarb.toml"

#: src/ch01-02-hello-world.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# Lihat definisi lebih lanjut di https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of Scarb.toml generated by `scarb new`"
msgstr "Listing 1-2: Konten dari Scarb.toml yang digenerate dengan `scarb new`"

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal Language) format, which is Scarb’s "
"configuration format."
msgstr ""
"File ini menggunakan format [TOML](https://toml.io/) (Tom’s Obvious, Minimal Language), yang mana merupakan "
"format konfigurasi Scarb."

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the following statements are configuring a "
"package. As we add more information to this file, we’ll add other sections."
msgstr ""
"Baris pertama, `[package]`, adalah judul bagian yang menunjukkan bahwa pernyataan berikut sedang mengonfigurasi "
"sebuah paket. Saat kami menambahkan lebih banyak informasi ke file ini, kami akan menambahkan bagian lain."

#: src/ch01-02-hello-world.md:82
msgid ""
"The next two lines set the configuration information Scarb needs to compile your program: the name and the "
"version of Scarb to use."
msgstr ""
"Dua baris berikutnya menetapkan informasi konfigurasi yang diperlukan Scarb untuk mengompilasi program Anda: "
"nama dan versi Scarb yang akan digunakan."

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list any of your project’s dependencies. "
"In Cairo, packages of code are referred to as crates. We won’t need any other crates for this project."
msgstr ""
"Baris terakhir, `[dependencies]`, adalah awal dari bagian di mana Anda dapat mencantumkan dependensi-dependensi "
"dari proyek Anda. Dalam Cairo, paket-paket kode disebut sebagai crates. Kita tidak akan memerlukan crates lain "
"untuk proyek ini."

#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the `starknet` dependency as mentioned in "
"the [Scarb documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""
"Catatan: Jika Anda sedang membangun kontrak untuk Starknet, Anda perlu menambahkan dependensi starknet "
"sebagaimana disebutkan dalam [dokumentasi Scarb](https://docs.swmansion.com/scarb/docs/extensions/starknet/"
"starknet-package.html)."

#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is `src/lib.cairo`, let's delete all the content and put in the following "
"content, we will explain the reason later."
msgstr ""
"File lain yang dibuat oleh Scarb adalah `src/lib.cairo`, mari kita hapus semua konten dan masukkan konten "
"berikut, kami akan menjelaskan alasannya nanti."

#: src/ch01-02-hello-world.md:94
msgid "Then create a new file called `src/hello_world.cairo` and put the following code in it:"
msgstr "Kemudian buat file baru bernama `src/hello_world.cairo` dan masukkan yang berikut ini kode di dalamnya:"

#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr "Filename: src/hello_world.cairo"

#: src/ch01-02-hello-world.md:105
msgid ""
"We have just created a file called `lib.cairo`, which contains a module declaration referencing another module "
"named `hello_world`, as well as the file `hello_world.cairo`, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"Kita baru saja membuat file bernama `lib.cairo`, yang berisi moduldeklarasi yang mereferensikan modul lain "
"bernama `hello_world`, serta file `hello_world.cairo`, berisi detail implementasi Modul `hello_world`."

#: src/ch01-02-hello-world.md:107
msgid "Scarb requires your source files to be located within the `src` directory."
msgstr "Scarb mengharuskan file sumber Anda ditempatkan di dalam direktori `src`."

#: src/ch01-02-hello-world.md:109
msgid ""
"The top-level project directory is reserved for README files, license information, configuration files, and any "
"other non-code-related content. Scarb ensures a designated location for all project components, maintaining a "
"structured organization."
msgstr ""
"Direktori top-level digunakan untuk file README, lisensi informasi, file konfigurasi, dan konten lain yang tidak "
"terkait dengan kode.Scarb memastikan lokasi yang ditentukan untuk semua komponen proyek, menjagaorganisasi "
"terstruktur."

#: src/ch01-02-hello-world.md:112
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a project that does use Scarb. Move the "
"project code into the src directory and create an appropriate `Scarb.toml` file."
msgstr ""
"Jika Anda memulai proyek yang tidak menggunakan Scarb, Anda dapat mengonversinya menjadi proyek yang menggunakan "
"Scarb. Pindahkan kode proyek ke direktori srcdan buat file `Scarb.toml` yang sesuai."

#: src/ch01-02-hello-world.md:114
msgid "Building a Scarb Project"
msgstr "Mulai membangun Projek Scarb"

#: src/ch01-02-hello-world.md:116
msgid "From your `hello_world` directory, build your project by entering the following command:"
msgstr "Dari direktori `hello_world` Anda, bangun proyek Anda dengan memasukkan perintah berikut:"

#: src/ch01-02-hello-world.md:124
msgid "This command creates a `sierra` file in `target/dev`, let's ignore the `sierra` file for now."
msgstr "Perintah ini membuat file `sierra` di `target/dev`, abaikan saja file `sierra` untuk saat ini."

#: src/ch01-02-hello-world.md:126
msgid "If you have installed Cairo correctly, you should be able to run and see the following output:"
msgstr ""
"Jika Anda telah menginstal Kairo dengan benar, Anda seharusnya dapat menjalankannya dan melihatcontoh output:"

#: src/ch01-02-hello-world.md:136
msgid "Regardless of your operating system, the string `Hello, world!` should print to the terminal."
msgstr "Terlepas dari sistem operasi Anda, string `Halo, dunia!` harus dicetak ke terminal."

#: src/ch01-02-hello-world.md:139
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a Cairo program. That makes you a Cairo "
"programmer—welcome!"
msgstr ""
"Jika `Hello, world!` berhasil dicetak, selamat! Anda telah resmi menulis Program Cairo. Itu membuatmu menjadi "
"Cairo programmer—welcome!"

#: src/ch01-02-hello-world.md:142
msgid "Anatomy of a Cairo Program"
msgstr "Anatomi Program Cairo"

#: src/ch01-02-hello-world.md:144
msgid "Let’s review this “Hello, world!” program in detail. Here’s the first piece of the puzzle:"
msgstr "Mari kita ulas “Hello, world!” program ini secara detail. Ini bagian pertama dari teka-teki:"

#: src/ch01-02-hello-world.md:153
msgid ""
"These lines define a function named `main`. The `main` function is special: it is always the first code that "
"runs in every executable Cairo program. Here, the first line declares a function named `main` that has no "
"parameters and returns nothing. If there were parameters, they would go inside the parentheses `()`."
msgstr ""
"Baris-baris ini mendefinisikan fungsi bernama `main`. Fungsi `main` adalah spesial: itu selalu menjadi kode "
"pertama yang dijalankan di setiap program Cairo yang dapat dieksekusi.Di sini, baris pertama mendeklarasikan "
"fungsi bernama `main` yang tidak memiliki parameterdan tidak mengembalikan apa pun. Jika ada parameter, "
"parameter tersebut akan masuk ke dalam tanda kurung `()`."

#: src/ch01-02-hello-world.md:158
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around all function bodies. It’s good style "
"to place the opening curly bracket on the same line as the function declaration, adding one space in between."
msgstr ""
"Fungsi badan dibungkus dengan `{}`. Cairo memerlukan tanda kurung kurawal di sekelilingnya semua badan "
"berfungsi. Sebaiknya letakkan tanda kurung kurawal pembuka di baris yang sama dengan deklarasi fungsi, "
"menambahkan satu spasi di antaranya."

#: src/ch01-02-hello-world.md:162
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you can use the automatic formatter tool "
"available with `scarb fmt` to format your code in a particular style (more on `scarb fmt` in [Appendix D]"
"(appendix-04-useful-development-tools.md)). The Cairo team has included this tool with the standard Cairo "
"distribution, as `cairo-run` is, so it should already be installed on your computer!"
msgstr ""
"Catatan: Jika Anda ingin tetap menggunakan gaya standar di seluruh proyek Cairo, Andadapat menggunakan alat "
"pemformat otomatis yang tersedia dengan `scarb fmt` untuk memformatkode Anda dalam gaya tertentu (lebih lanjut "
"tentang `scarb fmt` di [Lampiran D](appendix-04-useful-development-tools.md)). Tim Cairo sudah memasukkan "
"inialat dengan distribusi standar Cairo, seperti `cairo-run`, jadi seharusnyasudah terinstal di komputer Anda!"

#: src/ch01-02-hello-world.md:169
msgid ""
"Prior to the main function declaration, The line `use debug::PrintTrait;` is responsible for importing an item "
"defined in another module. In this case, we are importing the `PrintTrait` item from the Cairo core library. By "
"doing so, we gain the ability to use the `print()` method on data types that are compatible with printing."
msgstr ""
"Sebelum deklarasi fungsi utama, baris `use debug::PrintTrait;` bertanggung jawab untuk mengimpor item yang "
"ditentukan dalam modul lain. Dalam hal ini, kita mengimpor item `PrintTrait` dari library inti Cairo. Dengan "
"melakukan itu, kita mendapatkan kemampuan untuk menggunakan metode `print()` pada tipe data yang kompatibel "
"dengan printing."

#: src/ch01-02-hello-world.md:171
msgid "The body of the `main` function holds the following code:"
msgstr "Badan fungsi `main` berisi kode berikut:"

#: src/ch01-02-hello-world.md:177
msgid ""
"This line does all the work in this little program: it prints text to the screen. There are four important "
"details to notice here."
msgstr ""
"Baris ini melakukan semua pekerjaan dalam program kecil ini: ia mencetak teks kelayar. Ada empat detail penting "
"yang perlu diperhatikan di sini."

#: src/ch01-02-hello-world.md:180
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "Pertama, gaya Cairo adalah membuat indentasi dengan empat spasi, bukan tab."

#: src/ch01-02-hello-world.md:182
msgid ""
"Second, the `print()` function called is a method from the trait `PrintTrait`. This trait is imported from the "
"Cairo core library, and it defines how to print values to the screen for different data types. In our case, our "
"text is defined as a \"short string\", which is an ASCII string that can fit in Cairo's basic data type, which "
"is the `felt252` type. By calling `Hello, world!'.print()`, we're calling the `print()` method of the `felt252` "
"implementation of the `PrintTrait` trait."
msgstr ""
"Kedua, fungsi `print()` yang dipanggil adalah metode dari sifat `PrintTrait`. Sifat ini diimpor dari library "
"inti Cairo, dan itu mendefinisikan cara mencetak nilai ke layar untuk tipe data berbeda. Di dalam hal ini, teks "
"kita didefinisikan sebagai \"string pendek\", yang merupakan string ASCII yang dapat ditampung dalam tipe data "
"dasar Cairo, yaitu tipe `felt252`. Dengan memanggil `Hello, world!'.print()`, kita memanggil metode `print()` "
"dari `felt252` penerapan sifat `PrintTrait`."

#: src/ch01-02-hello-world.md:184
msgid ""
"Third, you see the `'Hello, World!'` short string. We pass this short string as an argument to `print()`, and "
"the short string is printed to the screen."
msgstr ""
"Ketiga, Anda melihat string pendek `'Hello, World!'`. Kita meneruskan string pendek inisebagai argumen untuk "
"`print()`, dan string pendek dicetak ke layar."

#: src/ch01-02-hello-world.md:187
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this expression is over and the next one is "
"ready to begin. Most lines of Cairo code end with a semicolon."
msgstr ""
"Keempat, kita mengakhiri baris dengan titik koma (`;`), yang menunjukkan bahwa Ekspresi ini sudah selesai dan "
"yang berikutnya siap dimulai. Sebagian besar jalur di Cairokode diakhiri dengan titik koma."

#: src/ch01-02-hello-world.md:193
msgid "Running tests"
msgstr "Menjalankan uji coba"

#: src/ch01-02-hello-world.md:195
msgid ""
"To run all the tests associated with a particular package, you can use the `scarb test` command. It is not a "
"test runner by itself, but rather delegates work to a testing solution of choice. Scarb comes with preinstalled "
"`scarb cairo-test` extension, which bundles Cairo's native test runner. It is the default test runner used by "
"scarb test. To use third-party test runners, please refer to [Scarb's documentation](https://docs.swmansion.com/"
"scarb/docs/extensions/testing.html#using-third-party-test-runners)."
msgstr ""
"Untuk menjalankan semua tes yang terkait dengan paket tertentu, Anda dapat menggunakan Perintah \"`scarb test`. "
"Ini bukan test runner itu sendiri, melainkan delegasi bekerja untuk solusi pengujian pilihan. Scarb hadir dengan "
"ekstensi `scarb cairo-test` yang telah diinstal sebelumnya, menggabungkan pengujian asli Cairo runner. Ini "
"adalah test runner default yang digunakan oleh scarb test. Untuk menggunakan pihak ketiga test runner, silakan "
"merujuk ke [dokumentasi Scarb](https://docs.swmansion.com/scarb/docs/extensions/testing.html#using-third-party-"
"test-runners)."

#: src/ch01-02-hello-world.md:199
msgid ""
"Test functions are marked with the `#[test]` attributes, and running `scarb test` will run all test functions in "
"your codebase under the `src/` directory."
msgstr ""
"Fungsi pengujian ditandai dengan atribut `#[test]`, dan menjalankan `scarb test` akan menjalankan semua fungsi "
"pengujian di basis kode Anda di bawah `src/` direktori."

#: src/ch01-02-hello-world.md:208
msgid " A sample Scarb project structure"
msgstr " Contoh struktur proyek Scarb"

#: src/ch01-02-hello-world.md:210
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "Mari kita rekap apa yang telah kita pelajari sejauh ini tentang Scarb:"

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr "Kita dapat membuat proyek menggunakan `scarb new`."

#: src/ch01-02-hello-world.md:213
msgid "We can build a project using `scarb build` to generate the compiled Sierra code."
msgstr ""
"Kita dapat membangun proyek menggunakan `scarb build` untuk menghasilkan kode Sierra yang telah dikompilasi."

#: src/ch01-02-hello-world.md:214
msgid "We can define custom scripts in `Scarb.toml` and call them with the `scarb run` command."
msgstr "Kita dapat menentukan skrip khusus di `Scarb.toml` dan memanggilnya dengan `scarb run`."

#: src/ch01-02-hello-world.md:215
msgid "We can run tests using the `scarb test` command."
msgstr "Kita dapat menjalankan pengujian menggunakan perintah `scarb test`."

#: src/ch01-02-hello-world.md:217
msgid ""
"An additional advantage of using Scarb is that the commands are the same no matter which operating system you’re "
"working on. So, at this point, we’ll no longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Keuntungan tambahan menggunakan Scarb adalah perintahnya sama, tidaktidak peduli sistem operasi apa yang sedang "
"Anda gunakan. Jadi, pada titik ini, kami tidak akan melakukannyalagi memberikan instruksi khusus untuk Linux dan "
"macOS versus Windows."

#: src/ch01-02-hello-world.md:220 src/ch02-05-control-flow.md:242 src/ch03-02-dictionaries.md:528
#: src/ch03-03-custom-data-structures.md:214 src/ch05-03-method-syntax.md:286
#: src/ch07-05-separating-modules-into-different-files.md:98 src/ch10-02-recoverable-errors.md:202
msgid "Summary"
msgstr "Ringkasan"

#: src/ch01-02-hello-world.md:222
msgid "You’re already off to a great start on your Cairo journey! In this chapter, you’ve learned how to:"
msgstr "Anda sudah memulai perjalanan Anda di Cairo dengan baik! Dalam bab ini, Anda telah belajar cara:"

#: src/ch01-02-hello-world.md:224
msgid "Install the latest stable version of Cairo"
msgstr "Instal versi stabil terbaru dari Cairo"

#: src/ch01-02-hello-world.md:225
msgid "Write and run a “Hello, Scarb!” program using `scarb` directly"
msgstr "Menulis dan menjalankan program \"Hello, Scarb!\" menggunakan `scarb` langsung"

#: src/ch01-02-hello-world.md:226
msgid "Create and run a new project using the conventions of Scarb"
msgstr "Membuat dan menjalankan proyek baru menggunakan konvensi Scarb"

#: src/ch01-02-hello-world.md:227
msgid "Execute tests using the `scarb test` command"
msgstr "Melakukan pengujian menggunakan perintah `scarb test`"

#: src/ch01-02-hello-world.md:229
msgid "This is a great time to build a more substantial program to get used to reading and writing Cairo code."
msgstr ""
"Ini saat yang tepat untuk membangun program yang lebih substansial untuk membiasakan diri membaca dan menulis "
"kode Cairo."

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many "
"programming languages have much in common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain the conventions around using these "
"concepts."
msgstr ""
"Bab ini membahas konsep-konsep yang muncul dalam hampir setiap bahasa pemrograman dan bagaimana cara kerjanya di "
"Cairo. Banyak bahasa pemrograman memiliki kesamaan pada inti mereka. Tidak ada konsep yang disajikan dalam bab "
"ini yang unik untuk Cairo, namun kami akan membahasnya dalam konteks Cairo dan menjelaskan konvensi seputar "
"penggunaan konsep-konsep ini."

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, comments, and control flow. These "
"foundations will be in every Cairo program, and learning them early will give you a strong core to start from."
msgstr ""
"Secara khusus, Anda akan mempelajari tentang variabel, tipe-tipe dasar, fungsi, komentar, dan alur kontrol. "
"Dasar-dasar ini akan ada dalam setiap program Cairo, dan mempelajarinya sejak awal akan memberikan fondasi yang "
"kuat untuk memulai."

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is written to, it can't be overwritten but "
"only read from. To reflect this immutable memory model, variables in Cairo are immutable by default. However, "
"the language abstracts this model and gives you the option to make your variables mutable. Let’s explore how and "
"why Cairo enforces immutability, and how you can make your variables mutable."
msgstr ""
"Cairo menggunakan model memori yang tidak dapat diubah (immutable), artinya setelah sebuah sel memori ditulisi, "
"sel tersebut tidak dapat ditimpa (overwrite) tapi hanya dapat dibaca. Untuk mencerminkan model memori yang tidak "
"dapat diubah ini, variabel dalam Cairo bersifat tidak dapat diubah secara default. Namun, bahasa ini "
"mengabstraksikan model ini dan memberikan opsi untuk membuat variabel Anda menjadi dapat diubah (mutable). Mari "
"kita jelajahi bagaimana dan mengapa Cairo menerapkan ketidakberubahannya, serta bagaimana Anda dapat membuat "
"variabel Anda menjadi dapat diubah."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t change that value. To illustrate this, "
"generate a new project called _variables_ in your _cairo_projects_ directory by using `scarb new variables`."
msgstr ""
"Ketika sebuah variabel tidak dapat diubah, setelah nilai terikat pada sebuah nama, Anda tidak dapat mengubah "
"nilai tersebut. Untuk mengilustrasikannya, buatlah proyek baru yang disebut _variables_ dalam direktori "
"_cairo_projects_ Anda dengan menggunakan perintah `scarb new variables`."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its code with the following code, "
"which won’t compile just yet:"
msgstr ""
"Kemudian, di direktori baru Anda _variables_, buka _src/lib.cairo_ dan gantikan kode di dalamnya dengan kode "
"berikut, yang belum dapat dikompilasi:"

#: src/ch02-01-variables-and-mutability.md:17 src/ch02-01-variables-and-mutability.md:77
#: src/ch02-01-variables-and-mutability.md:155 src/ch02-05-control-flow.md:9 src/ch02-05-control-flow.md:58
#: src/ch02-05-control-flow.md:90 src/ch02-05-control-flow.md:130 src/ch04-01-what-is-ownership.md:252
#: src/ch04-01-what-is-ownership.md:294 src/ch04-01-what-is-ownership.md:347
#: src/ch04-02-references-and-snapshots.md:23 src/ch04-02-references-and-snapshots.md:134
#: src/ch05-01-defining-and-instantiating-structs.md:7 src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:48 src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:120 src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:48 src/ch05-02-an-example-program-using-structs.md:74
#: src/ch05-02-an-example-program-using-structs.md:103 src/ch05-02-an-example-program-using-structs.md:136
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:93 src/ch05-03-method-syntax.md:135
#: src/ch05-03-method-syntax.md:192 src/ch05-03-method-syntax.md:231
#: src/ch07-02-defining-modules-to-control-scope.md:78 src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18 src/ch09-01-how-to-write-tests.md:28
#: src/ch09-01-how-to-write-tests.md:62 src/ch09-01-how-to-write-tests.md:118 src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:207 src/ch09-01-how-to-write-tests.md:305
#: src/ch09-01-how-to-write-tests.md:394 src/ch09-01-how-to-write-tests.md:489
#: src/ch09-01-how-to-write-tests.md:527 src/ch09-01-how-to-write-tests.md:563 src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59 src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr "Filename: src/lib.cairo"

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an error message regarding an immutability "
"error, as shown in this output:"
msgstr ""
"Simpan dan jalankan program menggunakan `scarb cairo-run`. Anda seharusnya menerima pesan kesalahan terkait "
"kesalahan ketidakbisaan untuk mengubah variabel, seperti yang ditunjukkan dalam output ini:"

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. Compiler errors can be frustrating, "
"but really they only mean your program isn’t safely doing what you want it to do yet; they do _not_ mean that "
"you’re not a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"Contoh ini menunjukkan bagaimana kompiler membantu Anda menemukan kesalahan dalam program Anda. Kesalahan "
"kompiler bisa membuat frustrasi, namun sebenarnya hal itu hanya berarti program Anda belum secara aman melakukan "
"apa yang Anda inginkan; itu _bukan_ berarti Anda bukan seorang programmer yang baik! Para pengguna Cairo "
"berpengalaman pun masih mendapatkan kesalahan kompiler."

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` because you tried to assign a second "
"value to the immutable `x` variable."
msgstr ""
"Anda menerima pesan kesalahan `Cannot assign to an immutable variable.` karena mencoba mengganti nilai kedua "
"pada variabel `x` yang bersifat immutable (tidak dapat diubah)."

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a value that’s designated as immutable "
"because this specific situation can lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, it’s possible that the first part of "
"the code won’t do what it was designed to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only _sometimes_. The Cairo compiler "
"guarantees that when you state that a value won’t change, it really won’t change, so you don’t have to keep "
"track of it yourself. Your code is thus easier to reason through."
msgstr ""
"Sangat penting bagi kita untuk mendapatkan kesalahan pada waktu kompilasi ketika kita mencoba untuk mengubah "
"nilai yang ditetapkan sebagai immutable karena situasi ini dapat menyebabkan bug. Jika satu bagian dari kode "
"kita beroperasi dengan asumsi bahwa nilai tidak akan pernah berubah dan bagian lain dari kode kita mengubah "
"nilai tersebut, ada kemungkinan bahwa bagian pertama dari kode tidak akan melakukan apa yang dirancang untuk "
"dilakukan. Penyebab bug semacam ini dapat sulit dilacak setelahnya, terutama ketika potongan kode kedua mengubah "
"nilai hanya _terkadang_. Kompilator Cairo menjamin bahwa ketika Anda menyatakan bahwa sebuah nilai tidak akan "
"berubah, nilai tersebut benar-benar tidak akan berubah, sehingga Anda tidak perlu melacaknya sendiri. Kode Anda "
"menjadi lebih mudah untuk dipahami."

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"But mutability can be very useful, and can make code more convenient to write. Although variables are immutable "
"by default, you can make them mutable by adding `mut` in front of the variable name. Adding `mut` also conveys "
"intent to future readers of the code by indicating that other parts of the code will be changing this variable’s "
"value."
msgstr ""
"Namun, mutabilitas bisa sangat berguna dan membuat kode lebih nyaman untuk ditulis. Meskipun variabel secara "
"default bersifat immutable, Anda dapat membuatnya menjadi mutable dengan menambahkan `mut` di depan nama "
"variabel. Menambahkan `mut` juga menyampaikan niat kepada pembaca kode di masa mendatang dengan menunjukkan "
"bahwa bagian lain dari kode akan mengubah nilai variabel ini."

#: src/ch02-01-variables-and-mutability.md:67
msgid ""
"However, you might be wondering at this point what exactly happens when a variable is declared as `mut`, as we "
"previously mentioned that Cairo's memory is immutable. The answer is that Cairo's memory is immutable, but the "
"memory address the variable points to can be changed. Upon examining the low-level Cairo Assembly code, it "
"becomes clear that variable mutation is implemented as syntactic sugar, which translates mutation operations "
"into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo level, the "
"variable is not redeclared so its type cannot change."
msgstr ""
"Namun, pada saat ini Anda mungkin bertanya-tanya apa yang sebenarnya terjadi ketika sebuah variabel "
"dideklarasikan sebagai `mut`, mengingat kami sebelumnya menyebutkan bahwa memori Cairo bersifat immutable. "
"Jawabannya adalah bahwa memori Cairo bersifat immutable, namun alamat memori yang ditunjuk oleh variabel dapat "
"diubah. Setelah memeriksa kode Assembly Cairo yang tingkat rendah, menjadi jelas bahwa mutasi variabel "
"diimplementasikan sebagai sintaks gula, yang menerjemahkan operasi mutasi menjadi serangkaian langkah yang "
"setara dengan variabel shadowing. Satu-satunya perbedaan adalah bahwa pada tingkat Cairo, variabel tidak "
"dideklarasikan ulang sehingga tipe variabelnya tidak dapat berubah."

#: src/ch02-01-variables-and-mutability.md:75
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Sebagai contoh, mari ubah _src/lib.cairo_ menjadi sebagai berikut:"

#: src/ch02-01-variables-and-mutability.md:89
msgid "When we run the program now, we get this:"
msgstr "Saat kita menjalankan program sekarang, kita mendapatkan ini:"

#: src/ch02-01-variables-and-mutability.md:100
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is used. Ultimately, deciding whether "
"to use mutability or not is up to you and depends on what you think is clearest in that particular situation."
msgstr ""
"Kita diizinkan untuk mengubah nilai yang terikat pada `x` dari `5` menjadi `6` ketika `mut` digunakan. Pada "
"akhirnya, keputusan untuk menggunakan mutabilitas atau tidak tergantung pada Anda dan tergantung pada apa yang "
"menurut Anda paling jelas dalam situasi tertentu tersebut."

#: src/ch02-01-variables-and-mutability.md:104
msgid "Constants"
msgstr "Constant"

#: src/ch02-01-variables-and-mutability.md:106
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name and are not allowed to change, but "
"there are a few differences between constants and variables."
msgstr ""
"Seperti variabel yang tidak dapat diubah, _Constant_ adalah nilai yang terikat pada sebuah nama dan tidak "
"diizinkan untuk diubah, namun ada beberapa perbedaan antara konstan dan variabel."

#: src/ch02-01-variables-and-mutability.md:110
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just immutable by default—they’re always "
"immutable. You declare constants using the `const` keyword instead of the `let` keyword, and the type of the "
"value _must_ be annotated. We’ll cover types and type annotations in the next section, [“Data Types”](ch02-02-"
"data-types.md), so don’t worry about the details right now. Just know that you must always annotate the type."
msgstr ""
"Pertama, Anda tidak diizinkan menggunakan `mut` dengan Constant. Constant bukan hanya tidak dapat diubah secara "
"default—mereka selalu bersifat tidak dapat diubah. Anda mendeklarasikan konstan menggunakan kata kunci `const` "
"bukan kata kunci `let`, dan tipe nilai _harus_ diannotasikan. Kami akan membahas tipe dan annotasi tipe pada "
"bagian berikutnya, [“Tipe Data”](ch02-02-data-types.md), jadi jangan khawatir tentang detailnya saat ini. Cukup "
"ketahui bahwa Anda selalu harus melakukan annotasi tipe."

#: src/ch02-01-variables-and-mutability.md:117
msgid ""
"Constants can only be declared in the global scope, which makes them useful for values that many parts of code "
"need to know about."
msgstr ""
"Constant hanya dapat dideklarasikan dalam cakupan global, yang membuatnya berguna untuk nilai yang diperlukan "
"oleh banyak bagian kode."

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"The last difference is that constants may be set only to a constant expression, not the result of a value that "
"could only be computed at runtime. Only literal constants are currently supported."
msgstr ""
"Perbedaan terakhir adalah bahwa konstan hanya dapat diatur ke dalam ekspresi konstan, bukan hasil dari nilai "
"yang hanya dapat dihitung pada waktu runtime. Saat ini, hanya konstan literal yang didukung."

#: src/ch02-01-variables-and-mutability.md:124
msgid "Here’s an example of a constant declaration:"
msgstr "Berikut ini adalah contoh deklarasi konstan:"

#: src/ch02-01-variables-and-mutability.md:130
msgid "Cairo's naming convention for constants is to use all uppercase with underscores between words."
msgstr ""
"Konvensi penamaan konstan dalam Cairo adalah menggunakan huruf kapital semua dengan garis bawah di antara kata-"
"kata."

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Constants are valid for the entire time a program runs, within the scope in which they were declared. This "
"property makes constants useful for values in your application domain that multiple parts of the program might "
"need to know about, such as the maximum number of points any player of a game is allowed to earn, or the speed "
"of light."
msgstr ""
"Konstan valid untuk seluruh waktu program berjalan, dalam cakupan di mana mereka dideklarasikan. Properti ini "
"membuat konstan berguna untuk nilai-nilai dalam domain aplikasi Anda yang mungkin dibutuhkan oleh beberapa "
"bagian dari program, seperti jumlah maksimum poin yang diizinkan oleh pemain dalam permainan, atau kecepatan "
"cahaya."

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that "
"value to future maintainers of the code. It also helps to have only one place in your code you would need to "
"change if the hardcoded value needed to be updated in the future."
msgstr ""
"Memberi nama pada nilai-nilai yang telah diatur secara kaku (hardcoded) yang digunakan di seluruh program Anda "
"sebagai konstan berguna untuk menyampaikan makna dari nilai tersebut kepada pemelihara kode di masa mendatang. "
"Hal ini juga membantu agar hanya ada satu tempat dalam kode Anda yang perlu diubah jika nilai yang diatur secara "
"kaku tersebut perlu diperbarui di masa mendatang."

#: src/ch02-01-variables-and-mutability.md:144
msgid "Shadowing"
msgstr "Shadowing"

#: src/ch02-01-variables-and-mutability.md:146
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same name as a previous variable. "
"Caironautes say that the first variable is _shadowed_ by the second, which means that the second variable is "
"what the compiler will see when you use the name of the variable. In effect, the second variable overshadows the "
"first, taking any uses of the variable name to itself until either it itself is shadowed or the scope ends. We "
"can shadow a variable by using the same variable’s name and repeating the use of the `let` keyword as follows:"
msgstr ""
"Shadowing variabel merujuk pada deklarasi variabel baru dengan nama yang sama dengan variabel sebelumnya. "
"Caironautes mengatakan bahwa variabel pertama \"tershadow\" oleh variabel kedua, yang berarti bahwa variabel "
"kedua yang akan dilihat oleh kompiler saat Anda menggunakan nama variabel tersebut. Pada dasarnya, variabel "
"kedua menggantikan variabel pertama, mengambil penggunaan nama variabel itu sendiri hingga entah itu sendiri "
"yang ter-\"shadow\" atau cakupan berakhir. Kita dapat \"membayangi\" (shadow) sebuah variabel dengan menggunakan "
"nama variabel yang sama dan mengulangi penggunaan kata kunci `let` seperti berikut:"

#: src/ch02-01-variables-and-mutability.md:172
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new variable `x` by repeating `let x =`, "
"taking the original value and adding `1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and creates a new variable, multiplying the "
"previous value by `2` to give `x` a value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""
"Program ini pertama mengikat `x` pada nilai `5`. Kemudian membuat variabel baru `x` dengan mengulangi `let x =`, "
"mengambil nilai aslinya dan menambahkan `1` sehingga nilai dari `x` kemudian menjadi `6`. Kemudian, dalam sebuah "
"cakupan dalam dengan menggunakan kurung kurawal, pernyataan `let` yang ketiga juga melakukan shadowing terhadap "
"`x` dan membuat variabel baru, mengalikan nilai sebelumnya dengan `2` sehingga `x` memiliki nilai `12`. Ketika "
"cakupan itu selesai, shadowing internal berakhir dan `x` kembali menjadi `6`. Ketika program ini dijalankan, "
"akan menghasilkan keluaran berikut:"

#: src/ch02-01-variables-and-mutability.md:194
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a compile-time error if we "
"accidentally try to reassign to this variable without using the `let` keyword. By using `let`, we can perform a "
"few transformations on a value but have the variable be immutable after those transformations have been "
"completed."
msgstr ""
"Shadowing berbeda dengan menandai variabel sebagai `mut` karena kita akan mendapatkan kesalahan pada waktu "
"kompilasi jika secara tidak sengaja mencoba untuk menetapkan kembali (reassign) pada variabel ini tanpa "
"menggunakan kata kunci `let`. Dengan menggunakan `let`, kita dapat melakukan beberapa transformasi pada sebuah "
"nilai tetapi membuat variabel menjadi tidak dapat diubah setelah transformasi tersebut selesai dilakukan."

#: src/ch02-01-variables-and-mutability.md:200
msgid ""
"Another distinction between `mut` and shadowing is that when we use the `let` keyword again, we are effectively "
"creating a new variable, which allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at the lower level. The only "
"difference is that by shadowing a variable, the compiler will not complain if you change its type. For example, "
"say our program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"Perbedaan lain antara `mut` dan shadowing adalah bahwa ketika kita menggunakan kata kunci `let` lagi, kita "
"secara efektif membuat variabel baru, yang memungkinkan kita untuk mengubah tipe nilai sambil menggunakan "
"kembali nama yang sama. Seperti yang disebutkan sebelumnya, variabel shadowing dan variabel mutable setara pada "
"tingkat yang lebih rendah. Satu-satunya perbedaan adalah bahwa dengan melakukan shadowing pada sebuah variabel, "
"kompiler tidak akan mengeluh jika Anda mengubah tipe variabel tersebut. Sebagai contoh, katakanlah program kita "
"melakukan konversi tipe antara tipe `u64` dan `felt252`."

#: src/ch02-01-variables-and-mutability.md:214
msgid "// converts x to a felt, type annotation is required.\n"
msgstr "// mengubah x menjadi felt, annotasi tipe diperlukan.\n"

#: src/ch02-01-variables-and-mutability.md:219
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a `felt252` type. Shadowing thus "
"spares us from having to come up with different names, such as `x_u64` and `x_felt252`; instead, we can reuse "
"the simpler `x` name. However, if we try to use `mut` for this, as shown here, we’ll get a compile-time error:"
msgstr ""
"Variabel `x` pertama memiliki tipe `u64` sedangkan variabel `x` kedua memiliki tipe `felt252`. Dengan demikian, "
"shadowing menghemat kita dari harus menggunakan nama yang berbeda, seperti `x_u64` dan `x_felt252`; sebaliknya, "
"kita dapat menggunakan kembali nama yang lebih sederhana yaitu `x`. Namun, jika kita mencoba menggunakan `mut` "
"untuk ini, seperti yang ditunjukkan di sini, kita akan mendapatkan kesalahan pada waktu kompilasi:"

#: src/ch02-01-variables-and-mutability.md:235
msgid "The error says we were expecting a `u64` (the original type) but we got a different type:"
msgstr ""
"Kesalahan tersebut menyatakan bahwa kita mengharapkan tipe `u64` (tipe asli) tetapi kita mendapatkan tipe yang "
"berbeda:"

#: src/ch02-01-variables-and-mutability.md:237
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"

#: src/ch02-01-variables-and-mutability.md:247
msgid "Now that we’ve explored how variables work, let’s look at more data types they can have."
msgstr ""
"Setelah kita menjelajahi bagaimana variabel bekerja, mari kita lihat lebih banyak jenis data yang bisa mereka "
"miliki."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what kind of data is being specified so it "
"knows how to work with that data. This section covers two subsets of data types: scalars and compounds."
msgstr ""
"Setiap nilai di Cairo memiliki _jenis data_ tertentu, yang memberi tahu Cairo jenis data apa yang sedang "
"ditentukan sehingga Cairo tahu cara bekerja dengan data tersebut. Bagian ini mencakup dua subset jenis data: "
"skalar dan compound."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that it must know the types of all "
"variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In "
"cases when many types are possible, we can use a conversion method where we specify the desired output type."
msgstr ""
"Ingatlah bahwa Cairo adalah bahasa _berjenis statis_, yang berarti bahwa ia harus mengetahui jenis-jenis semua "
"variabel pada waktu kompilasi. Kompiler biasanya dapat menyimpulkan jenis yang diinginkan berdasarkan nilai dan "
"penggunaannya. Dalam kasus-kasus di mana banyak jenis mungkin terjadi, kita dapat menggunakan metode konversi "
"(cast) di mana kita menentukan jenis keluaran yang diinginkan."

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr "Anda akan melihat anotasi jenis yang berbeda untuk jenis data lainnya."

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr "Tipe Scalar"

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar types: felts, integers, and booleans. "
"You may recognize these from other programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Jenis data _scalar_ mewakili sebuah nilai tunggal. Cairo memiliki tiga jenis skalar utama: felts, bilangan "
"bulat, dan boolean. Anda mungkin mengenali ini dari bahasa pemrograman lain. Mari kita lihat bagaimana cara "
"kerjanya di Cairo."

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr "Tipe Felt"

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, "
"represented by the keyword `felt252`. In the context of Cairo, when we say “a field element” we mean an integer "
"in the range `0 <= x < P`, where `P` is a very large prime number currently equal to `P = 2^{251} + 17 * "
"2^{192}+1`. When adding, subtracting, or multiplying, if the result falls outside the specified range of the "
"prime number, an overflow occurs, and an appropriate multiple of P is added or subtracted to bring the result "
"back within the range (i.e., the result is computed modulo P)."
msgstr ""
"Dalam Cairo, jika Anda tidak menentukan jenis variabel atau argumen, jenisnya secara default menjadi elemen "
"lapangan, yang direpresentasikan oleh kata kunci `felt252`. Dalam konteks Cairo, ketika kita mengatakan \"elemen "
"lapangan,\" kami mengacu pada bilangan bulat dalam rentang `0 <= x < P`, di mana `P` adalah bilangan prima "
"sangat besar yang saat ini setara dengan `P = 2^{251} + 17 * 2^{192} + 1`. Ketika melakukan penjumlahan, "
"pengurangan, atau perkalian, jika hasilnya berada di luar rentang yang ditentukan oleh bilangan prima tersebut, "
"maka akan terjadi overflow, dan kelipatan yang sesuai dari P akan ditambahkan atau dikurangkan untuk membawa "
"hasil kembali dalam rentang tersebut (yaitu, hasilnya dihitung modulo P)."

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is division: Division of field elements (and "
"therefore division in Cairo) is unlike regular CPUs division, where integer division `x / y` is defined as `[x/"
"y]` where the integer part of the quotient is returned (so you get `7 / 3 = 2`) and it may or may not satisfy "
"the equation `(x / y) * y == x`, depending on the divisibility of `x` by `y`."
msgstr ""
"Perbedaan paling penting antara bilangan bulat dan elemen lapangan terletak pada pembagian: Pembagian elemen "
"lapangan (dan oleh karena itu pembagian di Cairo) berbeda dengan pembagian pada CPU biasa, di mana pembagian "
"bilangan bulat `x / y` didefinisikan sebagai `[x/y]` di mana bagian bilangan bulat dari hasil bagi dikembalikan "
"(sehingga Anda mendapatkan `7 / 3 = 2`) dan mungkin atau mungkin tidak memenuhi persamaan `(x / y) * y == x`, "
"tergantung pada kelipatan `x` oleh `y`."

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation `(x / y) * y == x`. If y divides x as "
"integers, you will get the expected result in Cairo (for example `6 / 2` will indeed result in `3`). But when y "
"does not divide x, you may get a surprising result: For example, since `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, the "
"value of `1 / 2` in Cairo is `(P+1)/2` (and not 0 or 0.5), as it satisfies the above equation."
msgstr ""
"Dalam Cairo, hasil dari `x/y` didefinisikan untuk selalu memenuhi persamaan `(x / y) * y == x`. Jika y membagi x "
"sebagai bilangan bulat, Anda akan mendapatkan hasil yang diharapkan di Cairo (misalnya `6 / 2` memang "
"menghasilkan `3`). Tetapi ketika y tidak membagi x, Anda mungkin mendapatkan hasil yang mengejutkan: Sebagai "
"contoh, karena `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, nilai dari `1 / 2` di Cairo adalah `(P+1)/2` (dan bukan 0 atau "
"0.5), karena memenuhi persamaan di atas."

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr "Tipe Integer"

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating all types in the core library. "
"However, it is highly recommended for programmers to use the integer types instead of the `felt252` type "
"whenever possible, as the `integer` types come with added security features that provide extra protection "
"against potential vulnerabilities in the code, such as overflow checks. By using these integer types, "
"programmers can ensure that their programs are more secure and less susceptible to attacks or other security "
"threats. An _integer_ is a number without a fractional component. This type declaration indicates the number of "
"bits the programmer can use to store the integer. Table 3-1 shows the built-in integer types in Cairo. We can "
"use any of these variants to declare the type of an integer value."
msgstr ""
"Jenis data `felt252` adalah jenis data dasar yang berfungsi sebagai dasar untuk membuat semua jenis data dalam "
"pustaka inti. Namun, sangat disarankan bagi para pemrogram untuk menggunakan jenis data bilangan bulat daripada "
"jenis `felt252` sebisa mungkin, karena jenis data `integer` dilengkapi dengan fitur keamanan tambahan yang "
"memberikan perlindungan ekstra terhadap potensi kerentanan dalam kode, seperti pemeriksaan overflow. Dengan "
"menggunakan jenis data bilangan bulat ini, para pemrogram dapat memastikan bahwa program-program mereka lebih "
"aman dan kurang rentan terhadap serangan atau ancaman keamanan lainnya. Sebuah _integer_ adalah angka tanpa "
"komponen pecahan. Deklarasi jenis data ini menunjukkan jumlah bit yang dapat digunakan oleh pemrogram untuk "
"menyimpan bilangan bulat. Tabel 3-1 menunjukkan jenis data bilangan bulat bawaan dalam Cairo. Kita dapat "
"menggunakan salah satu varian ini untuk mendeklarasikan jenis data dari nilai bilangan bulat."

#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr "Tabel 3-1: Jenis Data Bilangan Bulat di Cairo"

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr "Panjang"

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr "Tidak bertanda"

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr "8-bit"

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr "`u8`"

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr "16-bit"

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr "`u16`"

#: src/ch02-02-data-types.md:53 src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr "32-bit"

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr "`u32`"

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr "64-bit"

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr "`u64`"

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr "128-bit"

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr "`u128`"

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr "256-bit"

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr "`u256`"

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr "`usize`"

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is just an alias for `u32`; however, it "
"might be useful when in the future Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""
"Setiap varian memiliki ukuran yang eksplisit. Perlu diperhatikan bahwa untuk saat ini, jenis data `usize` "
"hanyalah alias untuk `u32`; namun, ini mungkin berguna jika di masa depan Cairo dapat dikompilasi ke MLIR. "
"Karena variabel-variabel bersifat tidak bertanda, mereka tidak dapat berisi angka negatif. Kode ini akan "
"menyebabkan program mengalami panic:"

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for `u256` which needs 4 more bits to be "
"stored. Under the hood, `u256` is basically a struct with 2 fields: `u256 {low: u128, high: u128}`"
msgstr ""
"Semua jenis bilangan bulat yang disebutkan sebelumnya dapat masuk ke dalam `felt252`, kecuali untuk `u256` yang "
"membutuhkan 4 bit tambahan untuk disimpan. Pada dasarnya, di bawah layar, `u256` adalah sebuah struktur dengan 2 "
"bidang: `u256 {low: u128, high: u128}`"

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note that number literals that can be "
"multiple numeric types allow a type suffix, such as `57_u8`, to designate the type."
msgstr ""
"Anda dapat menulis literal bilangan bulat dalam salah satu bentuk yang ditunjukkan dalam Tabel 3-2. Perlu "
"diperhatikan bahwa literal angka yang dapat menjadi beberapa jenis numerik memungkinkan adanya akhiran jenis, "
"seperti `57_u8`, untuk menunjukkan jenisnya."

#: src/ch02-02-data-types.md:78
msgid "Table 3-2: Integer Literals in Cairo"
msgstr "Tabel 3-2: Literal Bilangan Bulat di Cairo"

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr "Literal Numerik"

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:11
msgid "Example"
msgstr "Contoh"

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr "Decimal"

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr "`98222`"

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr "Hex"

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr "`0xff`"

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr "Octal"

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr "`0o04321`"

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr "Binary"

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr "`0b01`"

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the "
"good size. The primary situation in which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"Jadi, bagaimana Anda tahu jenis bilangan bulat mana yang harus digunakan? Cobalah untuk memperkirakan nilai "
"maksimum yang dapat dimiliki oleh integer Anda dan pilih ukuran yang sesuai. Situasi utama di mana Anda akan "
"menggunakan `usize` adalah saat mengindeks suatu jenis koleksi."

#: src/ch02-02-data-types.md:90
msgid "Numeric Operations"
msgstr "Operasi Numerik"

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the integer types: addition, subtraction, "
"multiplication, division, and remainder. Integer division truncates toward zero to the nearest integer. The "
"following code shows how you’d use each numeric operation in a `let` statement:"
msgstr ""
"Cairo mendukung operasi matematika dasar yang dapat Anda harapkan untuk semua jenis bilangan bulat: penambahan, "
"pengurangan, perkalian, pembagian, dan sisa. Pembagian bilangan bulat memutuskan ke nol ke bilangan bulat "
"terdekat. Kode berikut menunjukkan bagaimana Anda akan menggunakan setiap operasi numerik dalam pernyataan `let`:"

#: src/ch02-02-data-types.md:99
msgid "// addition\n"
msgstr "// addition\n"

#: src/ch02-02-data-types.md:102
msgid "// subtraction\n"
msgstr "// subtraction\n"

#: src/ch02-02-data-types.md:105
msgid "// multiplication\n"
msgstr "// multiplication\n"

#: src/ch02-02-data-types.md:108
msgid "// division\n"
msgstr "// division\n"

#: src/ch02-02-data-types.md:109
msgid "//result is 1\n"
msgstr "//result is 1\n"

#: src/ch02-02-data-types.md:110
msgid "//result is 2\n"
msgstr "//result is 2\n"

#: src/ch02-02-data-types.md:112
msgid "// remainder\n"
msgstr "// remainder\n"

#: src/ch02-02-data-types.md:113
msgid "// result is 3\n"
msgstr "// result is 3\n"

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then "
"bound to a variable."
msgstr ""
"Setiap ekspresi dalam pernyataan ini menggunakan operator matematika dan dievaluasi menjadi nilai tunggal, yang "
"kemudian diikat ke dalam suatu variabel."

#: src/ch02-02-data-types.md:120
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list of all operators that Cairo "
"provides."
msgstr ""
"[Bagian Lampiran B](appendix-02-operators-and-symbols.md#operators) berisi daftar semua operator yang disediakan "
"oleh Cairo."

#: src/ch02-02-data-types.md:122
msgid "The Boolean Type"
msgstr "Tipe Data Boolean"

#: src/ch02-02-data-types.md:124
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two possible values: `true` and `false`. "
"Booleans are one felt252 in size. The Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"Seperti dalam kebanyakan bahasa pemrograman lainnya, tipe data Boolean dalam Cairo memiliki dua nilai yang "
"mungkin: `true` dan `false`. Booleans memiliki ukuran satu `felt252`. Tipe data Boolean dalam Cairo ditentukan "
"menggunakan `bool`. Sebagai contoh:"

#: src/ch02-02-data-types.md:132
msgid "// with explicit type annotation\n"
msgstr "// dengan anotasi tipe eksplisit\n"

#: src/ch02-02-data-types.md:136
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` expression. We’ll cover how `if` "
"expressions work in Cairo in the [“Control Flow”](ch02-05-control-flow.md) section."
msgstr ""
"Cara utama menggunakan nilai Boolean adalah melalui kondisional, seperti ekspresi `if`. Kami akan menjelaskan "
"bagaimana ekspresi `if` bekerja di Cairo pada bagian [\"Alur Kontrol\"](ch02-05-control-flow.md)."

#: src/ch02-02-data-types.md:140
msgid "The Short String Type"
msgstr "Tipe Data String Pendek"

#: src/ch02-02-data-types.md:142
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters forming what we call a \"short "
"string\" inside `felt252`s. A short string has a max length of 31 chars. This is to ensure that it can fit in a "
"single felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples of declaring values by "
"putting them between single quotes:"
msgstr ""
"Cairo tidak memiliki tipe data asli untuk string, tetapi Anda dapat menyimpan karakter yang membentuk apa yang "
"kami sebut sebagai \"string pendek\" di dalam `felt252`. Sebuah string pendek memiliki panjang maksimal 31 "
"karakter. Hal ini dilakukan untuk memastikan bahwa string tersebut dapat muat dalam satu felt (satu felt adalah "
"252 bit, satu karakter ASCII adalah 8 bit). Berikut adalah beberapa contoh mendeklarasikan nilai dengan "
"menempatkannya di antara tanda kutip satu:"

#: src/ch02-02-data-types.md:147
msgid "'C'"
msgstr "'C'"

#: src/ch02-02-data-types.md:152
msgid "Type Conversion"
msgstr "Tipe Data casting"

#: src/ch02-02-data-types.md:154
msgid ""
"In Cairo, you can convert types scalar types from one type to another by using the `try_into` and `into` methods "
"provided by the `TryInto` and `Into` traits, respectively."
msgstr ""
"Di Cairo, Anda dapat mengonversi jenis tipe skalar dari satu jenis ke jenis lainnya dengan menggunakan metode "
"`try_into` dan `into` yang disediakan oleh trait `TryInto` dan `Into`, masing-masing."

#: src/ch02-02-data-types.md:156
msgid ""
"The `try_into` method allows for safe type conversion when the target type might not fit the source value. Keep in "
"mind that `try_into` returns an `Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"Metode `try_into` memungkinkan untuk konversi tipe yang aman ketika tipe target mungkin tidak cocok dengan nilai "
"sumber. Ingatlah bahwa `try_into` mengembalikan tipe `Option<T>`, yang perlu Anda unwrap untuk mengakses nilai "
"baru."

#: src/ch02-02-data-types.md:158
msgid ""
"On the other hand, the `into` method can be used for type conversion when success is guaranteed, such as when the "
"source type is smaller than the destination type."
msgstr ""
"Di sisi lain, metode `into` dapat digunakan untuk konversi tipe ketika keberhasilan dijamin, seperti ketika tipe "
"sumber lebih kecil dari tipe tujuan."

#: src/ch02-02-data-types.md:160
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the source value to convert it to another type. "
"The new variable's type must be explicitly defined, as demonstrated in the example below."
msgstr ""
"Untuk melakukan konversi, panggil `var.into()` atau `var.try_into()` pada nilai sumber untuk mengubahnya menjadi "
"tipe lain. Tipe variabel baru harus didefinisikan secara eksplisit, seperti yang ditunjukkan dalam contoh di "
"bawah ini."

#: src/ch02-02-data-types.md:165
msgid "// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> type\n"
msgstr "// Karena felt252 mungkin tidak muat dalam u8, kita perlu melepaskan tipe Option<T>\n"

#: src/ch02-02-data-types.md:171
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr "// Karena felt252 lebih kecil dari u256, kita dapat menggunakan metode into()\n"

#: src/ch02-02-data-types.md:179
msgid "The Tuple Type"
msgstr "Tipe Data Tuple"

#: src/ch02-02-data-types.md:181
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a variety of types into one compound "
"type. Tuples have a fixed length: once declared, they cannot grow or shrink in size."
msgstr ""
"_tuple_ adalah cara umum untuk mengelompokkan sejumlah nilai dengan berbagai jenis ke dalam satu tipe data "
"gabungan. Tupel memiliki panjang tetap: setelah dideklarasikan, mereka tidak dapat tumbuh atau menyusut dalam "
"ukuran."

#: src/ch02-02-data-types.md:185
msgid ""
"We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has "
"a type, and the types of the different values in the tuple don’t have to be the same. We’ve added optional type "
"annotations in this example:"
msgstr ""
"Kita membuat sebuah tupel dengan menulis daftar nilai yang dipisahkan oleh koma di dalam tanda kurung. Setiap "
"posisi dalam tupel memiliki tipe, dan tipe dari nilai-nilai yang berbeda dalam tupel tidak harus sama. Kami "
"telah menambahkan anotasi tipe opsional dalam contoh ini:"

#: src/ch02-02-data-types.md:196
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a single compound element. To get the "
"individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:"
msgstr ""
"Variabel `tup` terikat pada seluruh tupel karena tupel dianggap sebagai satu elemen gabungan. Untuk mendapatkan "
"nilai-nilai individual dari sebuah tupel, kita dapat menggunakan pola pencocokan untuk mendestruksi nilai tupel, "
"seperti ini:"

#: src/ch02-02-data-types.md:213
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It then uses a pattern with `let` to take "
"`tup` and turn it into three separate variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is six` as the value of `y` is `6`."
msgstr ""
"Program ini pertama-tama membuat tupel dan mengikatnya pada variabel `tup`. Kemudian, menggunakan pola dengan "
"`let` untuk mengambil `tup` dan mengubahnya menjadi tiga variabel terpisah, yaitu `x`, `y`, dan `z`. Ini disebut "
"_destructuring_ karena memecah tupel tunggal menjadi tiga bagian. Akhirnya, program mencetak `y is six` karena "
"nilai `y` adalah `6`."

#: src/ch02-02-data-types.md:219
msgid "We can also declare the tuple with value and types at the same time. For example:"
msgstr "Kita juga dapat mendeklarasikan tupel dengan nilai dan tipe pada saat yang bersamaan. Sebagai contoh:"

#: src/ch02-02-data-types.md:228
msgid "The unit type ()"
msgstr "Tipe Unit ()"

#: src/ch02-02-data-types.md:230
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by a tuple with no elements. Its size "
"is always zero, and it is guaranteed to not exist in the compiled code."
msgstr ""
"_Tipe unit_ adalah tipe yang hanya memiliki satu nilai `()`. Ini direpresentasikan oleh sebuah tupel tanpa "
"elemen. Ukurannya selalu nol, dan dipastikan tidak ada dalam kode yang telah dikompilasi."

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most important functions in the language: "
"the `main` function, which is the entry point of many programs. You’ve also seen the `fn` keyword, which allows "
"you to declare new functions."
msgstr ""
"Fungsi-fungsi banyak digunakan dalam kode Cairo. Anda sudah melihat salah satu fungsi yang paling penting dalam "
"bahasa ini: fungsi `main`, yang merupakan titik masuk dari banyak program. Anda juga sudah melihat kata kunci "
"`fn`, yang memungkinkan Anda mendeklarasikan fungsi baru."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and variable names, in which all letters are "
"lowercase and underscores separate words. Here’s a program that contains an example function definition:"
msgstr ""
"Kode Cairo menggunakan _snake case_ sebagai gaya konvensional untuk nama fungsi dan variabel, di mana semua "
"huruf ditulis dalam huruf kecil dan garis bawah memisahkan kata-kata. Berikut adalah program yang berisi contoh "
"definisi fungsi:"

#: src/ch02-03-functions.md:25
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name and a set of parentheses. The curly "
"brackets tell the compiler where the function body begins and ends."
msgstr ""
"Kita mendefinisikan fungsi di Cairo dengan menuliskan `fn` diikuti oleh nama fungsi dan seperangkat tanda "
"kurung. Kurung kurawal memberitahu kompiler di mana tubuh fungsi dimulai dan diakhiri."

#: src/ch02-03-functions.md:29
msgid ""
"We can call any function we’ve defined by entering its name followed by a set of parentheses. Because "
"`another_function` is defined in the program, it can be called from inside the `main` function. Note that we "
"defined `another_function` _before_ the `main` function in the source code; we could have defined it after as "
"well. Cairo doesn’t care where you define your functions, only that they’re defined somewhere in a scope that "
"can be seen by the caller."
msgstr ""
"Kita dapat memanggil setiap fungsi yang telah kita definisikan dengan menuliskan namanya diikuti oleh "
"seperangkat tanda kurung. Karena `another_function` didefinisikan dalam program, itu dapat dipanggil dari dalam "
"fungsi `main`. Perhatikan bahwa kita mendefinisikan `another_function` _sebelum_ fungsi `main` dalam kode "
"sumber; kita juga bisa mendefinisikannya setelahnya. Cairo tidak mempermasalahkan di mana Anda mendefinisikan "
"fungsi Anda, yang penting adalah bahwa mereka didefinisikan di suatu tempat dalam cakupan yang dapat terlihat "
"oleh pemanggil."

#: src/ch02-03-functions.md:36
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions further. Place the "
"`another_function` example in _src/lib.cairo_ and run it. You should see the following output:"
msgstr ""
"Mari kita mulai proyek baru dengan Scarb yang diberi nama _functions_ untuk menjelajahi fungsi lebih lanjut. "
"Tempatkan contoh `another_function` di _src/lib.cairo_ dan jalankannya. Anda seharusnya melihat output berikut:"

#: src/ch02-03-functions.md:46
msgid ""
"The lines execute in the order in which they appear in the `main` function. First the “Hello, world!” message "
"prints, and then `another_function` is called and its message is printed."
msgstr ""
"Baris-baris tersebut dieksekusi sesuai dengan urutan tampilan dalam fungsi `main`. Pertama, pesan \"Hello, world!"
"\" dicetak, dan kemudian `another_function` dipanggil dan pesannya dicetak."

#: src/ch02-03-functions.md:50
msgid "Parameters"
msgstr "Parameter"

#: src/ch02-03-functions.md:52
msgid ""
"We can define functions to have _parameters_, which are special variables that are part of a function’s "
"signature. When a function has parameters, you can provide it with concrete values for those parameters. "
"Technically, the concrete values are called _arguments_, but in casual conversation, people tend to use the "
"words _parameter_ and _argument_ interchangeably for either the variables in a function’s definition or the "
"concrete values passed in when you call a function."
msgstr ""
"Kita dapat mendefinisikan fungsi dengan _parameter_, yang merupakan variabel khusus yang merupakan bagian dari "
"tanda tangan fungsi. Ketika sebuah fungsi memiliki parameter, Anda dapat memberikannya nilai konkret untuk "
"parameter-parameter tersebut. Secara teknis, nilai konkret disebut _argument_, tetapi dalam percakapan sehari-"
"hari, orang cenderung menggunakan kata _parameter_ dan _argument_ secara bergantian baik untuk variabel dalam "
"definisi fungsi atau nilai konkret yang dilewatkan saat Anda memanggil fungsi."

#: src/ch02-03-functions.md:60
msgid "In this version of `another_function` we add a parameter:"
msgstr "Pada versi `another_function` ini, kita menambahkan sebuah parameter:"

#: src/ch02-03-functions.md:74
msgid "Try running this program; you should get the following output:"
msgstr "Coba jalankan program ini; Anda seharusnya mendapatkan output berikut:"

#: src/ch02-03-functions.md:81
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type of `x` is specified as `felt252`. "
"When we pass `5` in to `another_function`, the `.print()` function outputs `5` in the console."
msgstr ""
"Deklarasi `another_function` memiliki satu parameter bernama `x`. Tipe data dari `x` ditentukan sebagai "
"`felt252`. Ketika kita memasukkan `5` ke dalam `another_function`, fungsi `.print()` mengeluarkan output `5` di "
"konsol."

#: src/ch02-03-functions.md:85
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This is a deliberate decision in Cairo’s "
"design: requiring type annotations in function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also able to give more helpful error "
"messages if it knows what types the function expects."
msgstr ""
"Dalam fungsi signature, Anda _harus_ mendeklarasikan tipe setiap parameter. Ini adalah keputusan yang disengaja "
"dalam desain Cairo: memerlukan anotasi tipe dalam definisi fungsi berarti hampir tidak pernah compiler "
"memerlukan Anda untuk menggunakannya di tempat lain dalam kode untuk mengetahui jenis data apa yang Anda maksud. "
"Compiler juga dapat memberikan pesan kesalahan yang lebih membantu jika mengetahui tipe data yang diharapkan "
"oleh fungsi."

#: src/ch02-03-functions.md:91
msgid "When defining multiple parameters, separate the parameter declarations with commas, like this:"
msgstr "Ketika mendefinisikan beberapa parameter, pisahkan deklarasi parameter dengan koma, seperti ini:"

#: src/ch02-03-functions.md:107
msgid ""
"This example creates a function named `another_function` with two parameters. The first parameter is named `x` "
"and is an `felt252`. The second is named `y` and is type `felt252` too. The function then prints the content of "
"the felt `x` and then the content of the felt `y`."
msgstr ""
"Contoh ini membuat sebuah fungsi bernama `another_function` dengan dua parameter. Parameter pertama dinamai `x` "
"dan memiliki tipe data `felt252`. Yang kedua dinamai `y` dan juga memiliki tipe data `felt252`. Fungsi kemudian "
"mencetak isi dari felt `x` dan kemudian isi dari felt `y`."

#: src/ch02-03-functions.md:111
msgid ""
"Let’s try running this code. Replace the program currently in your _functions_ project’s _src/lib.cairo_ file "
"with the preceding example and run it using `scarb cairo-run`:"
msgstr ""
"Mari coba menjalankan kode ini. Gantilah program yang saat ini ada dalam file _src/lib.cairo_ proyek _functions_ "
"Anda dengan contoh sebelumnya dan jalankannya menggunakan `scarb cairo-run`:"

#: src/ch02-03-functions.md:120
msgid ""
"Because we called the function with `5` as the value for `x` and `6` as the value for `y`, the program output "
"contains those values."
msgstr ""
"Karena kita memanggil fungsi dengan `5` sebagai nilai untuk `x` dan `6` sebagai nilai untuk `y`, output program "
"berisi nilai-nilai tersebut."

#: src/ch02-03-functions.md:123
msgid "Named parameters"
msgstr "Parameter Dengan Nama"

#: src/ch02-03-functions.md:125
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the "
"function calls more readable and self-descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is `parameter_name: value`. If you pass a "
"variable that has the same name as the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"Di Cairo, parameter dengan nama memungkinkan Anda menentukan nama argumen saat Anda memanggil suatu fungsi. Hal "
"ini membuat pemanggilan fungsi lebih mudah dibaca dan lebih deskriptif. Jika Anda ingin menggunakan parameter "
"dengan nama, Anda perlu menentukan nama parameter dan nilai yang ingin Anda lewatkan kepadanya. Syntaxnya adalah "
"`nama_parameter: nilai`. Jika Anda melewatkan variabel yang memiliki nama yang sama dengan parameter, Anda dapat "
"hanya menulis `:nama_parameter` alih-alih `nama_parameter: nama_variabel`."

#: src/ch02-03-functions.md:128
msgid "Here is an example:"
msgstr "Berikut adalah contohnya:"

#: src/ch02-03-functions.md:143
msgid "Statements and Expressions"
msgstr "Pernyataan dan Ekspresi"

#: src/ch02-03-functions.md:145
msgid ""
"Function bodies are made up of a series of statements optionally ending in an expression. So far, the functions "
"we’ve covered haven’t included an ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important distinction to understand. Other languages "
"don’t have the same distinctions, so let’s look at what statements and expressions are and how their differences "
"affect the bodies of functions."
msgstr ""
"Badan fungsi terdiri dari serangkaian pernyataan yang opsionalnya diakhiri dengan sebuah ekspresi. Sejauh ini, "
"fungsi-fungsi yang telah kita bahas belum mencakup ekspresi di akhirnya, tetapi Anda telah melihat ekspresi "
"sebagai bagian dari pernyataan. Karena Cairo adalah bahasa berbasis ekspresi, ini adalah perbedaan penting yang "
"perlu dipahami. Bahasa lain tidak memiliki perbedaan yang sama, jadi mari kita lihat apa itu pernyataan dan "
"ekspresi serta bagaimana perbedaan mereka memengaruhi badan fungsi."

#: src/ch02-03-functions.md:153
msgid "**Statements** are instructions that perform some action and do not return a value."
msgstr "**Pernyataan** adalah instruksi yang melakukan suatu tindakan dan tidak mengembalikan nilai."

#: src/ch02-03-functions.md:155
msgid "**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "**Ekspresi** mengevaluasi menjadi nilai hasil. Mari kita lihat beberapa contoh."

#: src/ch02-03-functions.md:157
msgid ""
"We’ve actually already used statements and expressions. Creating a variable and assigning a value to it with the "
"`let` keyword is a statement. In Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"Sebenarnya, kita sudah menggunakan pernyataan dan ekspresi. Membuat variabel dan memberikan nilai kepadanya "
"dengan kata kunci `let` adalah sebuah pernyataan. Pada Listing 2-1, `let y = 6;` adalah sebuah pernyataan."

#: src/ch02-03-functions.md:167
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr "Listing 2-1: Deklarasi fungsi `main` yang berisi satu pernyataan"

#: src/ch02-03-functions.md:169
msgid "Function definitions are also statements; the entire preceding example is a statement in itself."
msgstr "Definisi fungsi juga termasuk pernyataan; seluruh contoh sebelumnya adalah sebuah pernyataan itu sendiri."

#: src/ch02-03-functions.md:172
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` statement to another variable, as the "
"following code tries to do; you’ll get an error:"
msgstr ""
"Pernyataan tidak mengembalikan nilai. Oleh karena itu, Anda tidak dapat memberikan nilai dari suatu pernyataan "
"`let` ke variabel lain, seperti yang dicoba oleh kode berikut; Anda akan mendapatkan kesalahan:"

#: src/ch02-03-functions.md:181
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "Ketika Anda menjalankan program ini, kesalahan yang akan Anda dapatkan akan terlihat seperti ini:"

#: src/ch02-03-functions.md:205
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything for `x` to bind to. This is different "
"from what happens in other languages, such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` and `y` have the value `6`; that is "
"not the case in Cairo."
msgstr ""
"Pernyataan `let y = 6` tidak mengembalikan nilai, sehingga tidak ada nilai yang dapat diikat oleh `x`. Ini "
"berbeda dari apa yang terjadi di bahasa lain, seperti C dan Ruby, di mana hasil dari assignment adalah nilai "
"dari assignment tersebut. Dalam bahasa-bahasa tersebut, Anda dapat menulis `x = y = 6` dan memiliki kedua `x` "
"dan `y` bernilai `6`; hal ini tidak terjadi dalam Cairo."

#: src/ch02-03-functions.md:211
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code that you’ll write in Cairo. Consider a "
"math operation, such as `5 + 6`, which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an expression that evaluates to the "
"value `6`. Calling a function is an expression. A new scope block created with curly brackets is an expression, "
"for example:"
msgstr ""
"Expression mengevaluasi menjadi suatu nilai dan membentuk sebagian besar kode yang akan Anda tulis di Cairo. "
"Pertimbangkan operasi matematika, seperti `5 + 6`, yang merupakan ekspresi yang mengevaluasi menjadi nilai `11`. "
"Ekspresi dapat menjadi bagian dari pernyataan: dalam Listing 2-1, `6` dalam pernyataan `let y = 6;` adalah "
"ekspresi yang mengevaluasi menjadi nilai `6`. Memanggil fungsi adalah sebuah ekspresi. Blok cakupan baru yang "
"dibuat dengan kurung kurawal adalah ekspresi, sebagai contoh:"

#: src/ch02-03-functions.md:231
msgid "This expression:"
msgstr "Expression ini:"

#: src/ch02-03-functions.md:240
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to `y` as part of the `let` statement. "
"Note that the `x + 1` line doesn’t have a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn "
"it into a statement, and it will then not return a value. Keep this in mind as you explore function return "
"values and expressions next."
msgstr ""
"adalah blok yang, dalam hal ini, mengevaluasi menjadi `4`. Nilai itu diikat ke `y` sebagai bagian dari "
"pernyataan `let`. Perhatikan bahwa baris `x + 1` tidak memiliki titik koma di akhir, yang berbeda dari sebagian "
"besar baris yang telah Anda lihat sejauh ini. Ekspresi tidak memasukkan titik koma di akhir. Jika Anda "
"menambahkan titik koma di akhir ekspresi, Anda mengubahnya menjadi pernyataan, dan kemudian tidak akan "
"mengembalikan nilai. Ingatlah ini saat Anda menjelajahi nilai kembalian fungsi dan ekspresi selanjutnya."

#: src/ch02-03-functions.md:248
msgid "Functions with Return Values"
msgstr "Fungsi dengan Return Value"

#: src/ch02-03-functions.md:250
msgid ""
"Functions can return values to the code that calls them. We don’t name return values, but we must declare their "
"type after an arrow (`->`). In Cairo, the return value of the function is synonymous with the value of the final "
"expression in the block of the body of a function. You can return early from a function by using the `return` "
"keyword and specifying a value, but most functions return the last expression implicitly. Here’s an example of a "
"function that returns a value:"
msgstr ""
"Fungsi dapat mengembalikan nilai kepada kode yang memanggilnya. Kita tidak memberi nama pada nilai-nilai "
"kembalian, tetapi kita harus mendeklarasikan tipe mereka setelah panah (`->`). Di Cairo, nilai kembalian fungsi "
"bersinonim dengan nilai dari ekspresi terakhir dalam blok tubuh fungsi. Anda dapat mengembalikan nilai "
"sebelumnya dari sebuah fungsi dengan menggunakan kata kunci `return` dan menentukan sebuah nilai, tetapi "
"sebagian besar fungsi mengembalikan ekspresi terakhir secara implisit. Berikut adalah contoh fungsi yang "
"mengembalikan nilai:"

#: src/ch02-03-functions.md:271
msgid ""
"There are no function calls, or even `let` statements in the `five` function—just the number `5` by itself. "
"That’s a perfectly valid function in Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""
"Tidak ada panggilan fungsi, atau bahkan pernyataan `let` dalam fungsi `five` — hanya angka `5` itu sendiri. Itu "
"adalah fungsi yang sepenuhnya valid dalam bahasa Cairo. Perhatikan bahwa tipe pengembalian fungsi juga "
"ditentukan, yaitu `-> u32`. Cobalah menjalankan kode ini; keluarannya seharusnya terlihat seperti ini:"

#: src/ch02-03-functions.md:281
msgid ""
"The `5` in `five` is the function’s return value, which is why the return type is `u32`. Let’s examine this in "
"more detail. There are two important bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` returns a `5`, that line is the same "
"as the following:"
msgstr ""
"Angka `5` dalam `five` adalah nilai kembalian fungsi, itulah mengapa tipe pengembalian adalah `u32`. Mari kita "
"periksa ini lebih detail. Ada dua bagian penting: pertama, baris `let x = five();` menunjukkan bahwa kita "
"menggunakan nilai kembalian suatu fungsi untuk menginisialisasi variabel. Karena fungsi `five` mengembalikan "
"`5`, baris tersebut sama dengan yang berikut:"

#: src/ch02-03-functions.md:291
msgid ""
"Second, the `five` function has no parameters and defines the type of the return value, but the body of the "
"function is a lonely `5` with no semicolon because it’s an expression whose value we want to return. Let’s look "
"at another example:"
msgstr ""
"Kedua, fungsi `five` tidak memiliki parameter dan menentukan tipe nilai kembalian, tetapi tubuh fungsi tersebut "
"hanya berisi angka `5` tanpa titik koma karena itu adalah suatu ekspresi yang nilainya ingin kita kembalikan. "
"Mari kita lihat contoh lain:"

#: src/ch02-03-functions.md:310
msgid ""
"Running this code will print `[DEBUG]                    (raw: 6)`. But if we place a semicolon at the end of "
"the line containing `x + 1`, changing it from an expression to a statement, we’ll get an error:"
msgstr ""
"Menjalankan kode ini akan mencetak `[DEBUG]                    (raw: 6)`. Tetapi jika kita menempatkan titik "
"koma di akhir baris yang berisi `x + 1`, mengubahnya dari suatu ekspresi menjadi suatu pernyataan, kita akan "
"mendapatkan sebuah kesalahan:"

#: src/ch02-03-functions.md:328
msgid "Compiling this code produces an error, as follows:"
msgstr "Mengompilasi kode ini menghasilkan kesalahan, seperti berikut:"

#: src/ch02-03-functions.md:330
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"
msgstr ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"

#: src/ch02-03-functions.md:334
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue with this code. The definition of the "
"function `plus_one` says that it will return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which contradicts the function definition and "
"results in an error."
msgstr ""
"Pesan kesalahan utama, `Unexpected return type`, mengungkapkan masalah inti dengan kode ini. Definisi fungsi "
"`plus_one` menyatakan bahwa itu akan mengembalikan `u32`, tetapi pernyataan tidak dievaluasi menjadi suatu "
"nilai, yang diwakili oleh `()`, yaitu tipe unit. Oleh karena itu, tidak ada yang dikembalikan, yang bertentangan "
"dengan definisi fungsi dan menyebabkan kesalahan."

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using comments. To create a comment, use "
"the // syntax, after which any text on the same line will be ignored by the compiler."
msgstr ""
"Dalam program Cairo, Anda dapat menyertakan teks penjelasan di dalam kode menggunakan komentar. Untuk membuat "
"komentar, gunakan sintaks //, setelah itu segala teks pada baris yang sama akan diabaikan oleh kompiler."

#: src/ch02-04-comments.md:7
#, fuzzy
msgid "// start of the function\n"
msgstr "// awal dari fungsi\n"

#: src/ch02-04-comments.md:8
#, fuzzy
msgid "// return the sum of 1 and 4\n"
msgstr "// kembalikan hasil penjumlahan dari 1 dan 4.\n"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to run some code repeatedly while a "
"condition is true are basic building blocks in most programming languages. The most common constructs that let "
"you control the flow of execution of Cairo code are if expressions and loops."
msgstr ""
"Kemampuan untuk menjalankan beberapa kode tergantung pada apakah suatu kondisi benar, dan untuk menjalankan "
"beberapa kode secara berulang selama suatu kondisi benar adalah blok dasar dalam sebagian besar bahasa "
"pemrograman. Konstruksi yang paling umum yang memungkinkan Anda mengendalikan alur eksekusi kode Cairo adalah "
"ekspresi if dan loop."

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "`if` Expressions"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You provide a condition and then state, "
"“If this condition is met, run this block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Ekspresi if memungkinkan Anda bercabang dalam kode Anda tergantung pada kondisi. Anda memberikan suatu kondisi "
"dan kemudian menyatakan, \"Jika kondisi ini terpenuhi, jalankan blok kode ini. Jika kondisinya tidak terpenuhi, "
"jangan jalankan blok kode ini.\""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks "
"whether or not the variable `number` has a value equal to 5. We place the block of code to execute if the "
"condition is `true` immediately after the condition inside curly brackets."
msgstr ""
"Semua ekspresi `if` dimulai dengan kata kunci `if`, diikuti oleh suatu kondisi. Dalam kasus ini, kondisinya "
"memeriksa apakah variabel `number` memiliki nilai yang sama dengan 5. Kami menempatkan blok kode untuk "
"dijalankan jika kondisinya `true` langsung setelah kondisi di dalam kurung kurawal."

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do here, to give the program an "
"alternative block of code to execute should the condition evaluate to `false`. If you don’t provide an `else` "
"expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit "
"of code."
msgstr ""
"Opsionalnya, kita juga dapat menyertakan ekspresi `else`, seperti yang kita pilih di sini, untuk memberikan "
"program blok kode alternatif yang akan dijalankan jika kondisi dinilai `false`. Jika Anda tidak menyediakan "
"ekspresi `else` dan kondisinya `false`, program akan melewati blok `if` dan melanjutkan ke bagian kode "
"berikutnya."

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "Coba jalankan kode ini; Anda seharusnya melihat keluaran berikut:"

#: src/ch02-05-control-flow.md:36
msgid "Let’s try changing the value of `number` to a value that makes the condition `true` to see what happens:"
msgstr ""
"Mari mencoba mengubah nilai `number` menjadi suatu nilai yang membuat kondisinya menjadi `true` untuk melihat "
"apa yang terjadi:"

#: src/ch02-05-control-flow.md:47
msgid ""
"It’s also worth noting that the condition in this code must be a bool. If the condition isn’t a bool, we’ll get "
"an error."
msgstr ""
"Juga perlu dicatat bahwa kondisi dalam kode ini harus berupa tipe bool. Jika kondisinya bukan bool, kita akan "
"mendapatkan kesalahan."

#: src/ch02-05-control-flow.md:54
msgid "Handling Multiple Conditions with `else if`"
msgstr "Menangani Beberapa Kondisi dengan `else if`"

#: src/ch02-05-control-flow.md:56
msgid "You can use multiple conditions by combining if and else in an else if expression. For example:"
msgstr ""
"Anda dapat menggunakan beberapa kondisi dengan menggabungkan if dan else dalam suatu ekspresi else if. Contohnya:"

#: src/ch02-05-control-flow.md:78
msgid "This program has four possible paths it can take. After running it, you should see the following output:"
msgstr ""
"Program ini memiliki empat jalur yang mungkin diambil. Setelah dijalankan, Anda seharusnya melihat keluaran "
"berikut:"

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and executes the first body for which the "
"condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1'.print()`, nor do we see the `number not found` text from the `else` block. That’s because "
"Cairo only executes the block for the first true condition, and once it finds one, it doesn’t even check the "
"rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want "
"to refactor your code. [Chapter 6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo "
"branching construct called `match` for these cases."
msgstr ""
"Ketika program ini dieksekusi, ia memeriksa setiap ekspresi `if` secara berurutan dan menjalankan blok pertama "
"di mana kondisinya dinilai sebagai `true`. Perhatikan bahwa meskipun `number - 2 == 1` adalah `true`, kita tidak "
"melihat keluaran `number minus 2 is 1'.print()`, dan tidak pula melihat teks `number not found` dari blok "
"`else`. Hal ini karena Cairo hanya menjalankan blok untuk kondisi true pertama yang ditemuinya, dan begitu "
"menemukannya, ia bahkan tidak memeriksa yang lainnya. Menggunakan terlalu banyak ekspresi `else if` dapat "
"membuat kode menjadi berantakan, jadi jika Anda memiliki lebih dari satu, Anda mungkin ingin memperbaiki kode "
"Anda. [Bab 6](./ch06-02-the-match-control-flow-construct.md) menjelaskan suatu konstruksi percabangan Cairo yang "
"kuat yang disebut `match` untuk kasus-kasus seperti ini."

#: src/ch02-05-control-flow.md:86
msgid "Using `if` in a `let` statement"
msgstr "Menggunakan `if` dalam sebuah pernyataan `let`"

#: src/ch02-05-control-flow.md:88
msgid ""
"Because if is an expression, we can use it on the right side of a let statement to assign the outcome to a "
"variable."
msgstr ""
"Karena `if` adalah suatu ekspresi, kita dapat menggunakannya di sisi kanan dari pernyataan `let` untuk "
"menetapkan hasilnya ke suatu variabel."

#: src/ch02-05-control-flow.md:114
msgid ""
"The `number` variable will be bound to a value based on the outcome of the `if` expression. Which will be 5 here."
msgstr ""
"Variabel `number` akan diikat ke suatu nilai berdasarkan hasil dari ekspresi `if`. Yang akan menjadi 5 di sini."

#: src/ch02-05-control-flow.md:116
msgid "Repetition with Loops"
msgstr "Pengulangan dengan Loop"

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, "
"which will run through the code inside the loop body to the end and then start immediately back at the "
"beginning. To experiment with loops, let’s create a new project called loops."
msgstr ""
"Seringkali diperlukan untuk menjalankan suatu blok kode lebih dari sekali. Untuk tugas ini, Cairo menyediakan "
"sintaks perulangan yang sederhana, yang akan menjalankan kode di dalam tubuh perulangan hingga akhir, lalu "
"segera kembali ke awal. Untuk bereksperimen dengan perulangan, mari buat proyek baru yang disebut loops."

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr "Saat ini, Cairo hanya memiliki satu jenis perulangan: `loop`."

#: src/ch02-05-control-flow.md:122
msgid "Repeating Code with `loop`"
msgstr "Mengulang Kode dengan `loop`"

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over again forever or until you explicitly "
"tell it to stop."
msgstr ""
"Kata kunci `loop` memberitahu Cairo untuk menjalankan suatu blok kode berulang kali selamanya atau sampai Anda "
"secara eksplisit memberi tahu untuk berhenti."

#: src/ch02-05-control-flow.md:127
msgid "As an example, change the _src/lib.cairo_ file in your _loops_ directory to look like this:"
msgstr "Sebagai contoh, ubah file _src/lib.cairo_ di direktori _loops_ Anda sehingga terlihat seperti ini:"

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `again!` printed over and over continuously until we stop the program "
"manually, because the stop condition is never reached. While the compiler prevents us from writing programs "
"without a stop condition (`break` statement), the stop condition might never be reached, resulting in an "
"infinite loop. Most terminals support the keyboard shortcut "
msgstr ""
"Ketika kita menjalankan program ini, kita akan melihat `again!` dicetak terus-menerus secara terus menerus "
"sampai kita menghentikan program secara manual, karena kondisi berhenti tidak pernah tercapai. Meskipun kompiler "
"mencegah kita menulis program tanpa kondisi berhenti (`break` statement), kondisi berhenti mungkin tidak pernah "
"tercapai, mengakibatkan perulangan tak terbatas. Sebagian besar terminal mendukung pintasan keyboard "

#: src/ch02-05-control-flow.md:149
msgid "ctrl-c"
msgstr "ctrl-c"

#: src/ch02-05-control-flow.md:149
msgid " to interrupt a program that is stuck in a continual loop. Give it a try:"
msgstr " untuk menghentikan sebuah program yang terjebak dalam perulangan berkelanjutan. Coba saja:"

#: src/ch02-05-control-flow.md:166
msgid ""
"Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a "
"mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--"
"available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement "
"that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In "
"this case, the program panicked because it ran out of gas, as the stop condition was never reached. It is "
"particularly important in the context of smart contracts deployed on Starknet, as it prevents from running "
"infinite loops on the network. If you're writing a program that needs to run a loop, you will need to execute it "
"with the `--available-gas` flag set to a value that is large enough to run the program."
msgstr ""
"Catatan: Cairo mencegah kita untuk menjalankan program dengan perulangan tak terbatas dengan menyertakan "
"pengukur gas. Pengukur gas adalah mekanisme yang membatasi jumlah komputasi yang dapat dilakukan dalam sebuah "
"program. Dengan mengatur nilai untuk opsi `--available-gas`, kita dapat menetapkan jumlah maksimum gas yang "
"tersedia untuk program. Gas adalah satuan pengukuran yang mengungkapkan biaya komputasi dari sebuah instruksi. "
"Ketika pengukur gas habis, program akan berhenti. Dalam kasus ini, program mengalami panic karena kehabisan gas, "
"karena kondisi berhenti tidak pernah tercapai. Ini sangat penting dalam konteks kontrak pintar yang "
"diimplementasikan di Starknet, karena mencegah dari perulangan tak terbatas di jaringan. Jika Anda menulis "
"program yang perlu menjalankan suatu perulangan, Anda perlu menjalankannya dengan opsi `--available-gas` diatur "
"ke nilai yang cukup besar untuk menjalankan program."

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break` statement within the loop to tell the program when to stop "
"executing the loop. Let's fix the infinite loop by adding a making the stop condition `i > 10` reachable."
msgstr ""
"Untuk keluar dari suatu perulangan, Anda dapat menempatkan pernyataan `break` dalam perulangan untuk memberi "
"tahu program kapan harus berhenti menjalankan perulangan. Mari perbaiki perulangan tak terbatas dengan membuat "
"kondisi berhenti `i > 10` dapat dicapai."

#: src/ch02-05-control-flow.md:187
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the "
"code in this iteration. Let's add a `continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""
"Kata kunci `continue` memberitahu program untuk melanjutkan ke iterasi berikutnya dari perulangan dan untuk "
"melewati sisa kode dalam iterasi ini. Mari tambahkan pernyataan `continue` ke dalam perulangan kita untuk "
"melewati pernyataan `print` ketika `i` sama dengan `5`."

#: src/ch02-05-control-flow.md:207
msgid "Executing this program will not print the value of `i` when it is equal to `5`."
msgstr "Menjalankan program ini tidak akan mencetak nilai dari `i` ketika nilainya sama dengan `5`."

#: src/ch02-05-control-flow.md:209
msgid "Returning Values from Loops"
msgstr "Mengembalikan Nilai dari Loop"

#: src/ch02-05-control-flow.md:211
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, such as checking whether an operation "
"has succeeded. You might also need to pass the result of that operation out of the loop to the rest of your "
"code. To do this, you can add the value you want returned after the `break` expression you use to stop the loop; "
"that value will be returned out of the loop so you can use it, as shown here:"
msgstr ""
"Salah satu penggunaan dari `loop` adalah untuk mencoba operasi yang mungkin gagal, seperti memeriksa apakah "
"suatu operasi berhasil. Anda mungkin juga perlu meneruskan hasil dari operasi tersebut keluar dari perulangan ke "
"sisa kode Anda. Untuk melakukannya, Anda dapat menambahkan nilai yang ingin Anda kembalikan setelah ekspresi "
"`break` yang Anda gunakan untuk menghentikan perulangan; nilai tersebut akan dikembalikan keluar dari perulangan "
"sehingga Anda dapat menggunakannya, seperti yang ditunjukkan di sini:"

#: src/ch02-05-control-flow.md:235
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to `0`. Then we declare a variable "
"named `result` to hold the value returned from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When the condition is met, we use the "
"`break` keyword with the value `counter * 2`. After the loop, we use a semicolon to end the statement that "
"assigns the value to `result`. Finally, we print the value in `result`, which in this case is `20`."
msgstr ""
"Sebelum perulangan, kita mendeklarasikan variabel bernama `counter` dan menginisialisasinya dengan `0`. Kemudian "
"kita mendeklarasikan variabel bernama `result` untuk menyimpan nilai yang dikembalikan dari perulangan. Pada "
"setiap iterasi perulangan, kita memeriksa apakah `counter` sama dengan `10`, dan kemudian menambahkan `1` ke "
"variabel `counter`. Ketika kondisi terpenuhi, kita menggunakan kata kunci `break` dengan nilai `counter * 2`. "
"Setelah perulangan, kita menggunakan titik koma untuk mengakhiri pernyataan yang memberikan nilai ke `result`. "
"Akhirnya, kita mencetak nilai dalam `result`, yang dalam hal ini adalah `20`."

#: src/ch02-05-control-flow.md:244
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data types, functions, comments, `if` "
"expressions and loops! To practice with the concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"Anda berhasil! Ini adalah bab yang cukup besar: Anda telah mempelajari tentang variabel, tipe data, fungsi, "
"komentar, ekspresi `if`, dan perulangan! Untuk berlatih dengan konsep-konsep yang dibahas dalam bab ini, cobalah "
"membuat program untuk melakukan hal-hal berikut:"

#: src/ch02-05-control-flow.md:248
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "Menghasilkan bilangan Fibonacci ke-_n_."

#: src/ch02-05-control-flow.md:249
msgid "Compute the factorial of a number _n_."
msgstr "Menghitung faktorial dari suatu bilangan _n_."

#: src/ch02-05-control-flow.md:251
msgid "Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr "Selanjutnya, kita akan meninjau jenis-jenis koleksi umum dalam Cairo pada bab berikutnya."

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store and manipulate data. These collections "
"are designed to be efficient, flexible, and easy to use. This section introduces the primary collection types "
"available in Cairo: Arrays and Dictionaries."
msgstr ""
"Cairo menyediakan serangkaian jenis koleksi umum yang dapat digunakan untuk menyimpan dan memanipulasi data. "
"Koleksi-koleksi ini dirancang agar efisien, fleksibel, dan mudah digunakan. Bagian ini memperkenalkan jenis-"
"jenis koleksi utama yang tersedia di Cairo: Array dan Dictionary."

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and use array methods by importing the "
"`array::ArrayTrait` trait."
msgstr ""
"Array adalah kumpulan elemen-elemen dengan tipe yang sama. Anda dapat membuat dan menggunakan metode-metode "
"array dengan mengimpor trait `array::ArrayTrait`."

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose "
"values can't be modified. This has to do with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of an array and remove items from the "
"front using `pop_front`."
msgstr ""
"Hal penting yang perlu dicatat adalah bahwa array memiliki opsi modifikasi yang terbatas. Array sebenarnya "
"adalah antrian nilai yang tidak dapat diubah. Hal ini terkait dengan fakta bahwa begitu suatu slot memori "
"ditulis, tidak dapat ditimpa, tetapi hanya bisa dibaca. Anda hanya dapat menambahkan item ke akhir array dan "
"menghapus item dari depan menggunakan `pop_front`."

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "Membuat Array"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an Array is done with the `ArrayTrait::new()` call. Here is an example of the creation of an array to "
"which we append 3 elements:"
msgstr ""
"Membuat Array dilakukan dengan panggilan `ArrayTrait::new()`. Berikut adalah contoh pembuatan array yang kami "
"tambahkan 3 elemen:"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when instantiating the array like this, "
"or explicitly define the type of the variable."
msgstr ""
"Jika diperlukan, Anda dapat menyertakan tipe item yang diharapkan di dalam array saat menginstansiasi array "
"seperti ini, atau secara eksplisit menentukan tipe variabel."

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "Memperbarui Array"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "Menambahkan Elemen"

#: src/ch03-01-arrays.md:35
msgid "To add an element to the end of an array, you can use the `append()` method:"
msgstr "Untuk menambahkan elemen ke akhir array, Anda dapat menggunakan metode `append()`:"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "Menghapus Elemen"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the `pop_front()` method. This method returns "
"an `Option` containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"Anda hanya dapat menghapus elemen dari depan array dengan menggunakan metode `pop_front()`. Metode ini "
"mengembalikan `Option` yang berisi elemen yang dihapus, atau `Option::None` jika array kosong."

#: src/ch03-01-arrays.md:61
msgid "// print '10'\n"
msgstr ""

#: src/ch03-01-arrays.md:65
msgid "The above code will print `10` as we remove the first element that was added."
msgstr "Kode di atas akan mencetak `10` karena kita menghapus elemen pertama yang ditambahkan."

#: src/ch03-01-arrays.md:67
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once "
"they've been added. You can only add elements to the end of an array and remove elements from the front of an "
"array. These operations do not require memory mutation, as they involve updating pointers rather than directly "
"modifying the memory cells."
msgstr ""
"Dalam Cairo, memori bersifat imutabel, yang berarti bahwa tidak mungkin untuk memodifikasi elemen-elemen dari "
"suatu array setelah mereka ditambahkan. Anda hanya dapat menambahkan elemen ke akhir array dan menghapus elemen "
"dari depan array. Operasi-operasi ini tidak memerlukan mutasi memori, karena melibatkan pembaruan pointer "
"daripada langsung memodifikasi sel-sel memori."

#: src/ch03-01-arrays.md:69
msgid "Reading Elements from an Array"
msgstr "Membaca Elemen dari Array"

#: src/ch03-01-arrays.md:71
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that return different types. Using `arr."
"at(index)` is equivalent to using the subscripting operator `arr[index]`."
msgstr ""
"Untuk mengakses elemen-elemen array, Anda dapat menggunakan metode array `get()` atau `at()` yang mengembalikan "
"tipe yang berbeda. Menggunakan `arr.at(indeks)` setara dengan menggunakan operator subscripting `arr[indeks]`."

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-"
"pointer type) containing a snapshot to the element at the specified index if that element exists in the array. "
"If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that "
"may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and Snapshots](ch04-02-references-and-snapshots.md) chapter."
msgstr ""
"Fungsi `get` mengembalikan `Option<Box<@T>>`, yang berarti ia mengembalikan opsi ke tipe Box (tipe smart-pointer "
"Cairo) yang berisi snapshot dari elemen pada indeks yang ditentukan jika elemen tersebut ada dalam array. Jika "
"elemennya tidak ada, `get` mengembalikan `None`. Metode ini berguna ketika Anda berharap mengakses indeks yang "
"mungkin tidak berada dalam batas array dan ingin menangani kasus-kasus tersebut dengan lembut tanpa panic. "
"Snapshot akan dijelaskan lebih detail dalam bab [References and Snapshots](ch04-02-references-and-snapshots.md)."

#: src/ch03-01-arrays.md:75
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the element at the specified index using "
"the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error "
"occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's "
"bounds, which can prevent unexpected behavior."
msgstr ""
"Fungsi `at`, di sisi lain, langsung mengembalikan snapshot dari elemen pada indeks yang ditentukan dengan "
"menggunakan operator `unbox()` untuk mengekstrak nilai yang disimpan dalam sebuah box. Jika indeks berada di "
"luar batas, terjadi kesalahan panic. Anda sebaiknya hanya menggunakan `at` ketika ingin program mengalami panic "
"jika indeks yang diberikan berada di luar batas array, yang dapat mencegah perilaku yang tidak diinginkan."

#: src/ch03-01-arrays.md:77
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access attempts, and use `get` when you prefer to "
"handle such cases gracefully without panicking."
msgstr ""
"Secara ringkas, gunakan `at` ketika Anda ingin program mengalami panic pada percobaan akses di luar batas, dan "
"gunakan `get` ketika Anda lebih suka menangani kasus-kasus tersebut dengan lembut tanpa panic."

#: src/ch03-01-arrays.md:90
msgid ""
"In this example, the variable named `first` will get the value `0` because that is the value at index `0` in the "
"array. The variable named `second` will get the value `1` from index `1` in the array."
msgstr ""
"Dalam contoh ini, variabel bernama `first` akan mendapatkan nilai `0` karena itu adalah nilai pada indeks `0` "
"dalam array. Variabel bernama `second` akan mendapatkan nilai `1` dari indeks `1` dalam array."

#: src/ch03-01-arrays.md:94
msgid "Here is an example with the `get()` method:"
msgstr "Berikut adalah contoh dengan metode `get()`:"

#: src/ch03-01-arrays.md:101
msgid "// Change this value to see different results, what would happen if the index doesn't exist?\n"
msgstr ""

#: src/ch03-01-arrays.md:105
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
msgstr ""

#: src/ch03-01-arrays.md:117
msgid "Size related methods"
msgstr "Metode yang berkaitan dengan ukuran"

#: src/ch03-01-arrays.md:119
msgid "To determine the number of elements in an array, use the `len()` method. The return is of type `usize`."
msgstr ""
"Untuk menentukan jumlah elemen dalam sebuah array, gunakan metode `len()`. Hasil yang dikembalikan adalah tipe "
"`usize`."

#: src/ch03-01-arrays.md:121
msgid ""
"If you want to check if an array is empty or not, you can use the `is_empty()` method, which returns `true` if "
"the array is empty and `false` otherwise."
msgstr ""
"Jika Anda ingin memeriksa apakah sebuah array kosong atau tidak, Anda dapat menggunakan metode `is_empty()`, "
"yang mengembalikan nilai `true` jika array tersebut kosong dan `false` jika tidak."

#: src/ch03-01-arrays.md:123
msgid "Storing multiple types with Enums"
msgstr "Menyimpan beberapa tipe data dengan Enums"

#: src/ch03-01-arrays.md:125
msgid ""
"If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type "
"that can hold multiple types. Enums will be explained in more detail in the [Enums and Pattern Matching](ch06-00-"
"enums-and-pattern-matching.md) chapter."
msgstr ""
"Jika Anda ingin menyimpan elemen-elemen dari tipe data yang berbeda dalam sebuah array, Anda dapat menggunakan "
"`Enum` untuk mendefinisikan tipe data kustom yang dapat menyimpan beberapa tipe. Enums akan dijelaskan lebih "
"detail dalam bab [Enums and Pattern Matching](ch06-00-enums-and-pattern-matching.md)."

#: src/ch03-01-arrays.md:143
msgid "Span"
msgstr "Span"

#: src/ch03-01-arrays.md:145
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled "
"access to the elements of an array without modifying the original array. Span is particularly useful for "
"ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing "
"read-only operations (cf. [References and Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""
"`Span` adalah sebuah struktur data yang mewakili snapshot dari sebuah `Array`. Dirancang untuk memberikan akses "
"yang aman dan terkendali terhadap elemen-elemen dari sebuah array tanpa memodifikasi array aslinya. Span sangat "
"berguna untuk memastikan integritas data dan menghindari masalah peminjaman ketika melewatkan array antar fungsi "
"atau saat melakukan operasi baca saja (lihat [References and Snapshots](ch04-02-references-and-snapshots.md))."

#: src/ch03-01-arrays.md:147
msgid "All methods provided by `Array` can also be used with `Span`, with the exception of the `append()` method."
msgstr "Semua metode yang disediakan oleh `Array` juga dapat digunakan dengan `Span`, kecuali metode `append()`."

#: src/ch03-01-arrays.md:149
msgid "Turning an Array into span"
msgstr "Mengubah sebuah Array menjadi span"

#: src/ch03-01-arrays.md:151
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "Untuk membuat `Span` dari sebuah `Array`, panggil metode `span()`:"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The `Felt252Dict<T>` data type represents a "
"collection of key-value pairs where each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages such as maps, hash tables, "
"associative arrays and many others."
msgstr ""
"Cairo menyediakan dalam pustaka intinya tipe data yang mirip dengan kamus (dictionary-like type). Tipe data "
"`Felt252Dict<T>` mewakili kumpulan pasangan kunci-nilai dimana setiap kunci bersifat unik dan terkait dengan "
"nilai yang sesuai. Jenis struktur data ini dikenal dengan berbagai istilah dalam bahasa pemrograman yang "
"berbeda, seperti maps, hash tables, associative arrays, dan banyak yang lainnya."

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a certain way for which using an "
"`Array<T>` and indexing doesn't suffice. Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"Tipe `Felt252Dict<T>` berguna ketika Anda ingin mengatur data Anda dengan cara tertentu di mana penggunaan "
"`Array<T>` dan pengindeksan tidak mencukupi. Kamus Cairo juga memungkinkan programmer untuk dengan mudah "
"mensimulasikan keberadaan memori yang dapat diubah (mutable memory) ketika memori tersebut sebenarnya tidak ada."

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "Penggunaan Dasar dari Kamus"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the data types of both key and value. "
"In Cairo, the key type is restricted to `felt252` leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"Hal yang lazim dalam bahasa pemrograman lain saat membuat kamus baru adalah mendefinisikan tipe data dari kunci "
"(key) dan nilai (value). Namun, dalam Cairo, tipe data kunci terbatas pada `felt252`, sehingga hanya tersedia "
"kemungkinan untuk menentukan tipe data nilai, yang diwakili oleh `T` dalam `Felt252Dict<T>`."

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait `Felt252DictTrait` which includes all "
"basic operations. Among them we can find:"
msgstr ""
"Fungsi inti dari `Felt252Dict<T>` diimplementasikan dalam trait `Felt252DictTrait` yang mencakup semua operasi "
"dasar. Di antara mereka, kita dapat menemukan:"

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "`insert(felt252, T) -> ()` untuk menulis nilai ke sebuah contoh kamus (dictionary) dan"

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "`get(felt252) -> T` untuk membaca nilai dari kamus tersebut."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other language. In the following example, we "
"create a dictionary to represent a mapping between individuals and their balance:"
msgstr ""
"Fungsi-fungsi ini memungkinkan kita untuk memanipulasi kamus seperti dalam bahasa pemrograman lainnya. Pada "
"contoh berikut, kita membuat sebuah kamus untuk merepresentasikan hubungan antara individu dan saldo mereka:"

#: src/ch03-02-dictionaries.md:33
msgid ""
"The first thing we do is import `Felt252DictTrait` which brings to scope all the methods we need to interact "
"with the dictionary. Next, we create a new instance of `Felt252Dict<u64>` by using the `default` method of the "
"`Default` trait and added two individuals, each one with their own balance, using the `insert` method. Finally, "
"we checked the balance of our users with the `get` method."
msgstr ""
"Hal pertama yang dilakukan adalah mengimpor `Felt252DictTrait` yang membawa ke dalam ruang lingkup (scope) semua "
"metode yang dibutuhkan untuk berinteraksi dengan kamus. Selanjutnya, kita membuat sebuah contoh baru dari "
"`Felt252Dict<u64>` dengan menggunakan metode `default` dari trait `Default` dan menambahkan dua individu, masing-"
"masing dengan saldo mereka sendiri, menggunakan metode `insert`. Terakhir, kita memeriksa saldo pengguna kita "
"dengan metode `get`."

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory "
"cell once but the `Felt252Dict<T>` type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""
"Sepanjang buku ini, kita telah membicarakan tentang bagaimana memori dalam Cairo bersifat tidak dapat diubah "
"(immutable), yang berarti Anda hanya dapat menuliskan nilai ke sebuah sel memori sekali saja, tetapi tipe "
"`Felt252Dict<T>` mewakili cara untuk mengatasi hambatan ini. Kami akan menjelaskan bagaimana ini "
"diimplementasikan lebih lanjut pada bagian [Dictionaries Underneath](#dictionaries-underneath)."

#: src/ch03-02-dictionaries.md:37
msgid "Building upon our previous example, let us show a code example where the balance of the same user changes:"
msgstr ""
"Mengembangkan dari contoh sebelumnya, mari tunjukkan contoh kode di mana saldo dari pengguna yang sama berubah:"

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr ""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the _Alex_ individual twice, each time using a different balance and each "
"time that we checked for its balance it had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"Perhatikan bagaimana dalam contoh ini kita menambahkan individu _Alex_ dua kali, setiap kali menggunakan saldo "
"yang berbeda, dan setiap kali kita memeriksa saldo-nya, nilainya adalah nilai terakhir yang dimasukkan! "
"`Felt252Dict<T>` secara efektif memungkinkan kita untuk \"menimpa\" (overwrite) nilai yang disimpan untuk kunci "
"tertentu."

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you "
"instantiate a `Felt252Dict<T>`, behind the scenes all keys have their associated values initialized as zero. "
"This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an "
"error or an undefined value. This also means there is no way to delete data from a dictionary. Something to take "
"into account when incorporating this structure into your code."
msgstr ""
"Sebelum melanjutkan dan menjelaskan bagaimana kamus diimplementasikan, penting untuk disebutkan bahwa begitu "
"Anda membuat sebuah `Felt252Dict<T>`, di balik layar semua kunci memiliki nilai terkait mereka diinisialisasi "
"sebagai nol. Ini berarti bahwa jika misalnya, Anda mencoba untuk mendapatkan saldo dari pengguna yang tidak ada, "
"Anda akan mendapatkan nilai 0 daripada sebuah kesalahan atau nilai yang tidak terdefinisi. Ini juga berarti "
"bahwa tidak ada cara untuk menghapus data dari sebuah kamus. Hal yang perlu diperhatikan ketika menggabungkan "
"struktur ini ke dalam kode Anda."

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` and how it mimics the same behavior as "
"the corresponding data structures in any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from any other popular language in "
"existence, which as a consequence means that dictionaries are implemented very differently as well!"
msgstr ""
"Hingga saat ini, kita telah melihat semua fitur dasar dari `Felt252Dict<T>` dan bagaimana ia meniru perilaku "
"yang sama seperti struktur data yang sesuai dalam bahasa pemrograman lainnya, yaitu, secara eksternal tentunya. "
"Cairo pada intinya adalah bahasa pemrograman yang non-deterministik dan lengkap secara Turing, sangat berbeda "
"dari bahasa lain yang populer saat ini, yang sebagai konsekuensinya berarti bahwa kamus diimplementasikan dengan "
"cara yang sangat berbeda juga!"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about `Felt252Dict<T>` inner mechanisms and the "
"compromises that were taken to make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as another way to interact with them."
msgstr ""
"Pada bagian-bagian berikutnya, kami akan memberikan beberapa wawasan tentang mekanisme internal `Felt252Dict<T>` "
"dan kompromi yang diambil untuk membuatnya berfungsi. Setelah itu, kita akan melihat bagaimana menggunakan kamus "
"dengan struktur data lain serta menggunakan metode `entry` sebagai cara lain untuk berinteraksi dengan mereka."

#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr "Dasar dari Kamus"

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order "
"to simulate mutability, the language implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three "
"fields:"
msgstr ""
"Salah satu batasan dari desain non-deterministik Cairo adalah sistem memorinya yang tidak dapat diubah, sehingga "
"untuk mensimulasikan keberlangsungan, bahasa ini mengimplementasikan `Felt252Dict<T>` sebagai daftar entri. "
"Setiap entri mewakili waktu ketika sebuah kamus diakses untuk tujuan membaca/memperbarui/menulis. Sebuah entri "
"memiliki tiga bidang:"

#: src/ch03-02-dictionaries.md:69
msgid "A `key` field that identifies the value for this key-value pair of the dictionary."
msgstr "Bidang `key` yang mengidentifikasi nilai untuk pasangan kunci-nilai (key-value pair) dalam kamus ini."

#: src/ch03-02-dictionaries.md:70
msgid "A `previous_value` field that indicates which previous value was held at `key`."
msgstr "Bidang `previous_value` yang menunjukkan nilai sebelumnya yang dipegang oleh `key`."

#: src/ch03-02-dictionaries.md:71
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr "Bidang `new_value` yang menunjukkan nilai baru yang dipegang oleh `key`."

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would internally define it as "
"`Array<Entry<T>>` where each `Entry<T>` has information about what key-value pair it represents and the previous "
"and new values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"Jika kita mencoba mengimplementasikan `Felt252Dict<T>` menggunakan struktur tingkat tinggi, kita akan "
"mendefinisikannya secara internal sebagai `Array<Entry<T>>` di mana setiap `Entry<T>` memiliki informasi tentang "
"pasangan kunci-nilai yang direpresentasikannya dan nilai-nilai sebelumnya dan baru yang dipegangnya. Definisi "
"dari `Entry<T>` akan menjadi:"

#: src/ch03-02-dictionaries.md:83
msgid "For each time we interact with a `Felt252Dict<T>` a new `Entry<T>` will be registered:"
msgstr "Setiap kali kita berinteraksi dengan sebuah `Felt252Dict<T>`, sebuah `Entry<T>` baru akan terdaftar:"

#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and previous and new values are stored with "
"the same value."
msgstr ""
"Sebuah `get` akan mendaftarkan sebuah entri di mana tidak ada perubahan dalam keadaan, dan nilai-nilai "
"sebelumnya dan baru disimpan dengan nilai yang sama."

#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be the element being inserted, and the "
"`previous_value` the last element inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"Sebuah `insert` akan mendaftarkan sebuah `Entry<T>` baru dimana `new_value` akan menjadi elemen yang sedang "
"dimasukkan, dan `previous_value` akan menjadi elemen terakhir yang dimasukkan sebelum ini. Jika ini adalah entri "
"pertama untuk sebuah kunci tertentu, maka nilai sebelumnya akan menjadi nol."

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per "
"`Felt252Dict<T>` interaction. Let's show an example of this using the `balances` dictionary from the previous "
"section and inserting the users 'Alex' and 'Maria':"
msgstr ""
"Penggunaan daftar entri ini menunjukkan bahwa tidak ada penulisan ulang (rewriting), hanya penciptaan sel memori "
"baru setiap kali ada interaksi dengan `Felt252Dict<T>`. Mari tunjukkan contohnya dengan menggunakan kamus "
"`balances` dari bagian sebelumnya dan memasukkan pengguna 'Alex' dan 'Maria':"

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr "Instruksi-instruksi ini kemudian akan menghasilkan daftar entri berikut:"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130 src/ch03-02-dictionaries.md:143
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130 src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130 src/ch03-02-dictionaries.md:143
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr "Alex"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146 src/ch03-02-dictionaries.md:147
msgid "0"
msgstr "0"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:135
msgid "100"
msgstr "100"

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr "Maria"

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
msgid "50"
msgstr "50"

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr "200"

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the `previous` and `current` values are set "
"properly. Also reading from 'Maria' registered an entry with no change from previous to current values."
msgstr ""
"Perhatikan bahwa karena 'Alex' dimasukkan dua kali, ia muncul dua kali dan nilai `sebelumnya` dan `saat ini` "
"diatur dengan benar. Juga membaca dari 'Maria' mendaftarkan sebuah entri tanpa perubahan dari nilai sebelumnya "
"ke nilai saat ini."

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each read/write operation, there is a scan for the "
"whole entry list in search of the last entry with the same `key`. Once the entry has been found, its `new_value` "
"is extracted and used on the new entry to be added as the `previous_value`. This means that interacting with "
"`Felt252Dict<T>` has a worst-case time complexity of `O(n)` where `n` is the number of entries in the list."
msgstr ""
"Pendekatan ini dalam mengimplementasikan `Felt252Dict<T>` berarti bahwa untuk setiap operasi baca/tulis, terjadi "
"pemindaian pada seluruh daftar entri untuk mencari entri terakhir dengan `kunci` yang sama. Setelah entri "
"ditemukan, `nilai_baru`-nya diekstrak dan digunakan pada entri baru yang akan ditambahkan sebagai "
"`nilai_sebelumnya`. Hal ini berarti berinteraksi dengan `Felt252Dict<T>` memiliki kompleksitas waktu kasus "
"terburuk `O(n)` di mana `n` adalah jumlah entri dalam daftar."

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing `Felt252Dict<T>` you'd surely find them, probably "
"even ditching completely the need for a `previous_value` field, nonetheless, since Cairo is not your normal "
"language this won't work. One of the purposes of Cairo is, with the STARK proof system, to generate proofs of "
"computational integrity. This means that you need to verify that program execution is correct and inside the "
"boundaries of Cairo restrictions. One of those boundary checks consists of \"dictionary squashing\" and that "
"requires information on both previous and new values for every entry."
msgstr ""
"Jika Anda memikirkan alternatif cara untuk mengimplementasikan `Felt252Dict<T>`, mungkin Anda akan menemukannya, "
"bahkan mungkin benar-benar menghilangkan kebutuhan akan bidang `nilai_sebelumnya`. Namun, karena Cairo bukanlah "
"bahasa yang biasa, hal ini tidak akan berhasil. Salah satu tujuan dari Cairo adalah, dengan sistem bukti STARK, "
"untuk menghasilkan bukti integritas komputasi. Ini berarti Anda perlu memverifikasi bahwa eksekusi program "
"adalah benar dan berada dalam batasan-batasan Cairo. Salah satu pemeriksaan batasan tersebut terdiri dari "
"\"dictionary squashing\" dan hal itu membutuhkan informasi tentang nilai sebelumnya dan nilai baru untuk setiap "
"entri."

#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr "Merenggut Kamus"

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct we need "
"to check that there wasn't any illegal tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains "
"coherent throughout the execution."
msgstr ""
"Untuk memverifikasi bahwa bukti yang dihasilkan oleh eksekusi program Cairo yang menggunakan `Felt252Dict<T>` "
"adalah benar, kita perlu memeriksa bahwa tidak ada tindakan pemalsuan yang ilegal terhadap kamus. Hal ini "
"dilakukan melalui metode yang disebut `squash_dict` yang meninjau setiap entri dari daftar entri dan memeriksa "
"bahwa akses ke kamus tetap konsisten sepanjang eksekusi."

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key `k`, taken in the same order as they "
"were inserted, verify that the ith entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"Proses merenggut (squashing) dilakukan sebagai berikut: diberikan semua entri dengan kunci tertentu `k`, diambil "
"dalam urutan yang sama seperti saat mereka dimasukkan, verifikasi bahwa nilai `new_value` entri ke-i sama dengan "
"nilai `previous_value` entri ke-(i+1)."

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr "Sebagai contoh, diberikan daftar entri berikut:"

#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
msgid "150"
msgstr "150"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr "Charles"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "70"
msgstr "70"

#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138
msgid "250"
msgstr "250"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137
msgid "40"
msgstr "40"

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
msgid "300"
msgstr "300"

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "190"
msgstr "190"

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:145
msgid "90"
msgstr "90"

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr "Setelah proses merenggut (squashing), daftar entri akan berkurang menjadi:"

#: src/ch03-02-dictionaries.md:149
msgid "In case of a change on any of the values of the first table, squashing would have failed during runtime."
msgstr ""
"Dalam kasus perubahan pada salah satu nilai dari tabel pertama, proses merenggut (squashing) akan gagal selama "
"runtime."

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr "Penghancuran Kamus"

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of Dictionaries](#basic-use-of-dictionaries) you'd notice that there was "
"never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the "
"scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` "
"trait. This call occurred just before the `balance` dictionary went out of scope."
msgstr ""
"Jika Anda menjalankan contoh-contoh dari [Basic Use of Dictionaries](#basic-use-of-dictionaries), Anda akan "
"melihat bahwa tidak pernah ada pemanggilan untuk merenggut kamus, namun program berhasil dikompilasi. Yang "
"terjadi di balik layar adalah bahwa merenggut (squash) dipanggil secara otomatis melalui implementasi "
"`Felt252Dict<T>` dari trait `Destruct<T>`. Panggilan ini terjadi tepat sebelum kamus `balance` keluar dari "
"cakupan (out of scope)."

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main "
"difference between these two is that `Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` "
"trait is `Felt252Dict<T>`, for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more "
"about these traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-destruct)."
msgstr ""
"Trait `Destruct<T>` merupakan cara lain untuk menghapus instansi dari cakupan selain dari `Drop<T>`. Perbedaan "
"utama antara keduanya adalah bahwa `Drop<T>` dianggap sebagai operasi no-op, yang berarti tidak menghasilkan "
"CASM (Cairo Assembly) baru sedangkan `Destruct<T>` tidak memiliki batasan ini. Hanya tipe yang secara aktif "
"menggunakan trait `Destruct<T>` adalah `Felt252Dict<T>`, untuk setiap tipe lain `Destruct<T>` dan `Drop<T>` "
"adalah sinonim. Anda dapat membaca lebih lanjut tentang trait-trait ini dalam [Drop and Destruct](/appendix-03-"
"derivable-traits.md#drop-and-destruct)."

#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), we will have a hands-on example "
"where we implement the `Destruct<T>` trait for a custom type."
msgstr ""
"Nanti dalam bagian [Dictionaries as Struct Members](#dictionaries-as-struct-members), kita akan memiliki contoh "
"praktis di mana kita akan mengimplementasikan trait `Destruct<T>` untuk sebuah tipe kustom."

#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the functionality of `Felt252Dict<T>` as well as how "
"and why it is implemented in a certain way. If you haven't understood all of it, don't worry because in this "
"section we will have some more examples using dictionaries."
msgstr ""
"Hingga saat ini, kami telah memberikan gambaran menyeluruh tentang fungsionalitas `Felt252Dict<T>` serta "
"bagaimana dan mengapa ia diimplementasikan dengan cara tertentu. Jika Anda belum memahami semuanya, jangan "
"khawatir karena dalam bagian ini kami akan memberikan beberapa contoh lebih lanjut menggunakan kamus."

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary basic functionality included in "
"`Felt252DictTrait<T>` which we didn't mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-complex-types) with other complex types such as `Array<T>` and how "
"to [implement](#dictionaries-as-struct-members) a struct with a dictionary as a member."
msgstr ""
"Kami akan memulai dengan menjelaskan metode `entry` yang merupakan bagian dari fungsi dasar kamus yang "
"disertakan dalam `Felt252DictTrait<T>` yang tidak kami sebutkan di awal. Segera setelah itu, kita akan melihat "
"contoh bagaimana `Felt252Dict<T>` [berinteraksi](#dictionaries-of-complex-types) dengan jenis-jenis kompleks "
"lainnya seperti `Array<T>` dan bagaimana cara [mengimplementasikan](#dictionaries-as-struct-members) sebuah "
"struktur dengan kamus sebagai anggotanya."

#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr "Entry dan Finalize"

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we explained how `Felt252Dict<T>` internally "
"worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The "
"Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""
"Pada bagian [Dictionaries Underneath](#dictionaries-underneath), kami menjelaskan bagaimana `Felt252Dict<T>` "
"bekerja secara internal. Ini adalah daftar entri untuk setiap kali kamus diakses dalam berbagai cara. Pertama, "
"ia akan mencari entri terakhir berdasarkan suatu `kunci` tertentu, kemudian memperbarui sesuai dengan operasi "
"apa pun yang sedang dieksekusi. Bahasa Cairo memberikan alat kepada kita untuk mereplikasi hal ini sendiri "
"melalui metode `entry` dan `finalize`."

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose of creating a new entry given a "
"certain key. Once called, this method takes ownership of the dictionary and returns the entry to update. The "
"method signature is as follows:"
msgstr ""
"Metode `entry` disertakan sebagai bagian dari `Felt252DictTrait<T>` dengan tujuan untuk membuat entri baru "
"berdasarkan suatu kunci tertentu. Setelah dipanggil, metode ini mengambil kepemilikan dari kamus dan "
"mengembalikan entri untuk diperbarui. Tanda tangan metodenya adalah sebagai berikut:"

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second one is used to create the "
"appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which is the type used by Cairo to "
"represent dictionary entries, and a `T` representing the value held previously."
msgstr ""
"Parameter input pertama mengambil kepemilikan dari kamus sedangkan yang kedua digunakan untuk membuat entri yang "
"sesuai. Metode ini mengembalikan sebuah tuple yang berisi `Felt252DictEntry<T>`, yang merupakan tipe yang "
"digunakan oleh Cairo untuk mewakili entri kamus, dan `T` yang mewakili nilai yang dipegang sebelumnya."

#: src/ch03-02-dictionaries.md:177
msgid ""
"The next thing to do is to update the entry with the new value. For this, we use the `finalize` method which "
"inserts the entry and returns ownership of the dictionary:"
msgstr ""
"Langkah selanjutnya adalah memperbarui entri dengan nilai baru. Untuk ini, kita menggunakan metode `finalize` "
"yang memasukkan entri dan mengembalikan kepemilikan dari kamus:"

#: src/ch03-02-dictionaries.md:183
msgid "This method receives the entry and the new value as a parameter and returns the updated dictionary."
msgstr ""
"Metode ini menerima entri dan nilai baru sebagai parameter, lalu mengembalikan kamus yang telah diperbarui."

#: src/ch03-02-dictionaries.md:185
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to implement our own version of the "
"`get` method from a dictionary. We should then do the following:"
msgstr ""
"Mari kita lihat contoh penggunaan `entry` dan `finalize`. Bayangkan kita ingin mengimplementasikan versi kita "
"sendiri dari metode `get` dari sebuah kamus. Maka kita harus melakukan hal berikut:"

#: src/ch03-02-dictionaries.md:187
msgid "Create the new entry to add using the `entry` method"
msgstr "Membuat entri baru yang akan ditambahkan menggunakan metode `entry`"

#: src/ch03-02-dictionaries.md:188
msgid "Insert back the entry where the `new_value` equals the `previous_value`."
msgstr "Masukkan kembali entri di mana `nilai_baru` sama dengan `nilai_sebelumnya`."

#: src/ch03-02-dictionaries.md:189
msgid "Return the value."
msgstr "Kembalikan value tersebut."

#: src/ch03-02-dictionaries.md:191
msgid "Implementing our custom get would look like this:"
msgstr "Implementasi custom `get` kita akan terlihat seperti ini:"

#: src/ch03-02-dictionaries.md:199 src/ch03-02-dictionaries.md:248
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:202 src/ch03-02-dictionaries.md:251
msgid "// Store the value to return\n"
msgstr ""

#: src/ch03-02-dictionaries.md:205 src/ch03-02-dictionaries.md:254
msgid "// Update the entry with `prev_value` and get back ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:257
msgid "// Return the read value\n"
msgstr ""

#: src/ch03-02-dictionaries.md:213
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for inserting a new value when "
"finalizing. If we were to implement it, it would look like the following:"
msgstr ""
"Mengimplementasikan metode `insert` akan mengikuti alur kerja yang serupa, kecuali untuk memasukkan nilai baru "
"saat proses finalisasi. Jika kita hendak mengimplementasikannya, akan terlihat seperti berikut:"

#: src/ch03-02-dictionaries.md:227
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exists, _prev_value will\n"
"    // be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:232
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:238
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to how `insert` and `get` are "
"implemented for `Felt252Dict<T>`. This code shows some example usage:"
msgstr ""
"Sebagai catatan penyelesaian, kedua metode ini diimplementasikan dengan cara yang mirip dengan bagaimana "
"`insert` dan `get` diimplementasikan untuk `Felt252Dict<T>`. Kode ini menunjukkan contoh penggunaannya:"

#: src/ch03-02-dictionaries.md:270
msgid "// Get the last entry associated with `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:271
msgid "// Notice that if `key` does not exists, _prev_value will\n"
msgstr ""

#: src/ch03-02-dictionaries.md:272
msgid "// be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:275
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr ""

#: src/ch03-02-dictionaries.md:276
msgid "// and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:283 src/ch03-02-dictionaries.md:285
msgid "'0'"
msgstr "'0'"

#: src/ch03-02-dictionaries.md:293
msgid "Dictionaries of types not supported natively"
msgstr "Dictionaries dari jenis yang tidak didukung secara native"

#: src/ch03-02-dictionaries.md:295
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`. This trait "
"defines the `zero_default` method which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` "
"- but it is not implemented for more complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types not natively supported is not a "
"straightforward task, because you would need to write a couple of trait implementations in order to make the "
"data type a valid dictionary value type. To compensate this, you can wrap your type inside a `Nullable<T>`."
msgstr ""
"Salah satu batasan dari `Felt252Dict<T>` yang belum kita bahas adalah trait `Felt252DictValue<T>`. Trait ini "
"mendefinisikan metode `zero_default` yang dipanggil saat suatu nilai tidak ada dalam kamus. Ini "
"diimplementasikan oleh beberapa jenis data umum, seperti sebagian besar bilangan bulat tidak bertanda, `bool`, "
"dan `felt252` - tetapi tidak diimplementasikan untuk jenis yang lebih kompleks seperti array, struktur (termasuk "
"`u256`), dan jenis lain dari pustaka inti. Ini berarti membuat kamus dari jenis yang tidak didukung secara "
"native bukanlah tugas yang mudah, karena Anda perlu menulis beberapa implementasi trait untuk membuat tipe data "
"menjadi tipe nilai kamus yang valid. Untuk mengompensasi hal ini, Anda dapat melingkupi tipe Anda di dalam "
"`Nullable<T>`."

#: src/ch03-02-dictionaries.md:301
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It "
"is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference "
"with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type, inspired by "
"Rust, allows us to allocate a new memory segment for our type, and access this segment using a pointer that can "
"only be manipulated in one place at a time."
msgstr ""
"`Nullable<T>` adalah tipe pointer cerdas yang dapat menunjuk ke sebuah nilai atau menjadi `null` ketika tidak "
"ada nilai. Ini biasanya digunakan dalam Bahasa Pemrograman Berorientasi Objek ketika suatu referensi tidak "
"menunjuk ke mana-mana. Perbedaannya dengan `Option` adalah bahwa nilai yang dibungkus disimpan di dalam tipe "
"data `Box<T>`. Tipe `Box<T>`, yang terinspirasi dari Rust, memungkinkan kita untuk mengalokasikan segmen memori "
"baru untuk tipe kita, dan mengakses segmen ini menggunakan pointer yang hanya dapat dimanipulasi di satu tempat "
"pada satu waktu."

#: src/ch03-02-dictionaries.md:303
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a dictionary. For that, we will use "
"`Nullable<T>` and `Box<T>`. Also, we are storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a dictionary."
msgstr ""
"Mari kita tunjukkan dengan contoh. Kita akan mencoba menyimpan sebuah `Span<felt252>` di dalam sebuah kamus. "
"Untuk itu, kita akan menggunakan `Nullable<T>` dan `Box<T>`. Selain itu, kita menyimpan sebuah `Span<T>` dan "
"bukan sebuah `Array<T>` karena yang terakhir tidak mengimplementasikan trait `Copy<T>` yang diperlukan untuk "
"membaca dari sebuah kamus."

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:368
msgid "// Create the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:371
msgid "// Crate the array to insert\n"
msgstr ""

#: src/ch03-02-dictionaries.md:319 src/ch03-02-dictionaries.md:377
msgid "// Insert it as a `Span`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:321 src/ch03-02-dictionaries.md:336
msgid "//...\n"
msgstr ""

#: src/ch03-02-dictionaries.md:325
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary `d`. We want it to hold a "
"`Nullable<Span>`. After that, we created an array and filled it with values."
msgstr ""
"Dalam potongan kode ini, yang pertama kita lakukan adalah membuat kamus baru `d`. Kita ingin kamus ini menampung "
"`Nullable<Span>`. Setelah itu, kita membuat sebuah array dan mengisinya dengan nilai-nilai."

#: src/ch03-02-dictionaries.md:327
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice that we didn't do that directly, "
"but instead, we took some steps in between:"
msgstr ""
"Langkah terakhir adalah memasukkan array sebagai sebuah span ke dalam kamus. Perhatikan bahwa kita tidak "
"melakukannya secara langsung, melainkan kita melakukan beberapa langkah di antaranya:"

#: src/ch03-02-dictionaries.md:329
msgid "We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr "Kita melingkupi array di dalam `Box` menggunakan metode `new` dari `BoxTrait`."

#: src/ch03-02-dictionaries.md:330
msgid "We wrapped the `Box` inside a nullable using the `nullable_from_box` function."
msgstr "Kita melingkupi `Box` di dalam nullable menggunakan fungsi `nullable_from_box`."

#: src/ch03-02-dictionaries.md:331
msgid "Finally, we inserted the result."
msgstr "Terakhir, kita memasukkan hasilnya."

#: src/ch03-02-dictionaries.md:333
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. "
"The following code shows how to achieve that:"
msgstr ""
"Setelah elemen berada di dalam kamus, dan kita ingin mengambilnya, kita mengikuti langkah yang sama namun dalam "
"urutan terbalik. Berikut adalah contoh kode untuk mencapainya:"

#: src/ch03-02-dictionaries.md:338 src/ch03-02-dictionaries.md:380
msgid "// Get value back\n"
msgstr ""

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:383
msgid "// Search the value and assert it is not null\n"
msgstr ""

#: src/ch03-02-dictionaries.md:347 src/ch03-02-dictionaries.md:389
msgid "// Verify we are having the right values\n"
msgstr ""

#: src/ch03-02-dictionaries.md:354
msgid "Here we:"
msgstr ""

#: src/ch03-02-dictionaries.md:356
msgid "Read the value using `get`."
msgstr "Baca nilai menggunakan `get`."

#: src/ch03-02-dictionaries.md:357
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "Verifikasi bahwa nilai tersebut tidak null menggunakan fungsi `match_nullable`."

#: src/ch03-02-dictionaries.md:358
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "Membuka nilai _wrapped_ di dalam kotak dan memastikan bahwa itu benar."

#: src/ch03-02-dictionaries.md:360
msgid "The complete script would look like this:"
msgstr "Skrip lengkap akan terlihat seperti ini:"

#: src/ch03-02-dictionaries.md:397
msgid "Dictionaries as Struct Members"
msgstr "Kamus sebagai Anggota Struktur"

#: src/ch03-02-dictionaries.md:399
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly interacting with them may not be "
"entirely seamless. Let's try implementing a custom _user database_ that will allow us to add users and query "
"them. We will need to define a struct to represent the new type and a trait to define its functionality:"
msgstr ""
"Mendefinisikan kamus sebagai anggota struktur memungkinkan dalam Cairo, tetapi berinteraksi dengan mereka dengan "
"benar mungkin tidak sepenuhnya mulus. Mari mencoba mengimplementasikan _basis data pengguna_ kustom yang akan "
"memungkinkan kita menambahkan pengguna dan mengajukan pertanyaan kepada mereka. Kita akan perlu mendefinisikan "
"sebuah struktur untuk mewakili tipe baru dan sebuah trait untuk menentukan fungsinya:"

#: src/ch03-02-dictionaries.md:414
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic over the balances of the users, "
"giving major flexibility to whoever uses our data type. Its two members are:"
msgstr ""
"Tipe baru kita `UserDatabase<T>` mewakili basis data pengguna. Ini bersifat generik terhadap saldo pengguna, "
"memberikan fleksibilitas utama kepada siapa pun yang menggunakan tipe data kita. Dua anggotanya adalah:"

#: src/ch03-02-dictionaries.md:416
msgid "`users_amount`, the number of users currently inserted and"
msgstr "`users_amount`, jumlah pengguna yang saat ini telah dimasukkan dan"

#: src/ch03-02-dictionaries.md:417
msgid "`balances`, a mapping of each user to its balance."
msgstr "`balances`, pemetaan setiap pengguna dengan saldo mereka."

#: src/ch03-02-dictionaries.md:419
msgid "The database core functionality is defined by `UserDatabaseTrait`. The following methods are defined:"
msgstr ""
"Fungsionalitas inti basis data didefinisikan oleh `UserDatabaseTrait`. Metode-metode berikut didefinisikan:"

#: src/ch03-02-dictionaries.md:421
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "`new` untuk dengan mudah membuat tipe `UserDatabase` baru."

#: src/ch03-02-dictionaries.md:422
msgid "`add_user` to insert users in the database."
msgstr "`add_user` untuk memasukkan pengguna ke dalam basis data."

#: src/ch03-02-dictionaries.md:423
msgid "`get_balance` to find user's balance in the database."
msgstr "`get_balance` untuk menemukan saldo pengguna dalam basis data."

#: src/ch03-02-dictionaries.md:425
msgid ""
"The only remaining step is to implement each of the methods in `UserDatabaseTrait`, but since we are working "
"with [generic types](/src/ch08-00-generic-types-and-traits.md) we also need to correctly establish the "
"requirements of `T` so it can be a valid `Felt252Dict<T>` value type:"
msgstr ""
"Langkah terakhir yang tersisa adalah mengimplementasikan setiap metode dalam `UserDatabaseTrait`, tetapi karena "
"kita sedang bekerja dengan [tipe generik](/src/ch08-00-generic-types-and-traits.md), kita juga perlu menetapkan "
"persyaratan `T` dengan benar agar dapat menjadi tipe nilai `Felt252Dict<T>` yang valid:"

#: src/ch03-02-dictionaries.md:427
msgid "`T` should implement the `Copy<T>` since it's required for getting values from a `Felt252Dict<T>`."
msgstr ""
"`T` harus mengimplementasikan `Copy<T>` karena ini diperlukan untuk mendapatkan nilai dari `Felt252Dict<T>`."

#: src/ch03-02-dictionaries.md:428
msgid "All value types of a dictionary implement the `Felt252DictValue<T>`, our generic type should do as well."
msgstr ""
"Semua tipe nilai dari kamus mengimplementasikan `Felt252DictValue<T>`, tipe generik kita juga seharusnya "
"demikian."

#: src/ch03-02-dictionaries.md:429
msgid "To insert values, `Felt252DictTrait<T>` requires all value types to be destructible."
msgstr "Untuk memasukkan nilai, `Felt252DictTrait<T>` mengharuskan semua tipe nilai untuk dapat dihancurkan."

#: src/ch03-02-dictionaries.md:431
msgid "The implementation, with all restriction in place, would be as follow:"
msgstr "Implementasinya, dengan semua batasan yang ada, akan seperti berikut:"

#: src/ch03-02-dictionaries.md:437 src/ch03-02-dictionaries.md:484
msgid "// Creates a database\n"
msgstr "// Creates a database\n"

#: src/ch03-02-dictionaries.md:442 src/ch03-02-dictionaries.md:489
msgid "// Get the user's balance\n"
msgstr "// Get the user's balance\n"

#: src/ch03-02-dictionaries.md:447 src/ch03-02-dictionaries.md:494
msgid "// Add a user\n"
msgstr "// Add a user\n"

#: src/ch03-02-dictionaries.md:455
msgid ""
"Our database implementation is almost complete, except for one thing: the compiler doesn't know how to make a "
"`UserDatabase<T>` go out of scope, since it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. "
"Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are forced to implement the "
"`Destruct<T>` trait manually (refer to the [Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for "
"more information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` definition won't work because of "
"the use of [genericity](/src/ch08-00-generic-types-and-traits.md) in the struct definition. We need to code the "
"`Destruct<T>` trait implementation by ourselves:"
msgstr ""
"Implementasi basis data kita hampir selesai, kecuali satu hal: kompiler tidak tahu bagaimana membuat "
"`UserDatabase<T>` keluar dari cakupan, karena itu tidak mengimplementasikan trait `Drop<T>` maupun trait "
"`Destruct<T>`. Karena memiliki `Felt252Dict<T>` sebagai anggota, itu tidak dapat dihapus, jadi kita terpaksa "
"mengimplementasikan trait `Destruct<T>` secara manual (lihat bab [Milik](ch04-01-what-is-ownership.md#the-drop-"
"trait) untuk informasi lebih lanjut). Menggunakan `#[derive(Destruct)]` di atas definisi `UserDatabase<T>` tidak "
"akan berfungsi karena penggunaan [genericity](/src/ch08-00-generic-types-and-traits.md) dalam definisi struktur. "
"Kita perlu mengkodekan implementasi trait `Destruct<T>` sendiri:"

#: src/ch03-02-dictionaries.md:469
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a fully functional database. We can now "
"try it out:"
msgstr ""
"Mengimplementasikan `Destruct<T>` untuk `UserDatabase` adalah langkah terakhir kita untuk mendapatkan basis data "
"yang sepenuhnya fungsional. Sekarang kita bisa mencobanya:"

#: src/ch03-02-dictionaries.md:530
msgid ""
"Well done! You finished this chapter on arrays and dictionaries in Cairo. These data structures may be a bit "
"challenging to grasp, but they are really useful."
msgstr ""
"Selamat! Anda telah menyelesaikan bab ini tentang array dan kamus di Cairo. Struktur data ini mungkin agak sulit "
"dipahami, tetapi mereka benar-benar berguna."

#: src/ch03-02-dictionaries.md:532
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares with Rust and that _doesn’t_ commonly "
"exist in other programming languages: ownership."
msgstr ""
"Ketika Anda siap melanjutkan, kita akan membahas sebuah konsep yang Cairo bagikan dengan Rust dan _tidak_ umum "
"ada dalam bahasa pemrograman lain: kepemilikan."

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays (`Array<T>`) to store collections of "
"data. However, you will quickly realize that arrays have one big limitation - the data stored in them is "
"immutable. Once you append a value to an array, you can't modify it."
msgstr ""
"Ketika Anda pertama kali mulai memprogram di Cairo, Anda kemungkinan besar ingin menggunakan array (`Array<T>`) "
"untuk menyimpan kumpulan data. Namun, Anda akan segera menyadari bahwa array memiliki satu keterbatasan besar - "
"data yang disimpan di dalamnya bersifat tidak dapat diubah. Setelah Anda menambahkan nilai ke dalam array, Anda "
"tidak dapat memodifikasinya."

#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For example, say you're making a game "
"where the players have a level, and they can level up. You might try to store the level of the players in an "
"array:"
msgstr ""
"Ini dapat menjadi frustrasi ketika Anda ingin menggunakan struktur data yang dapat diubah. Sebagai contoh, "
"katakanlah Anda membuat sebuah game di mana para pemain memiliki level, dan mereka dapat naik level. Anda "
"mungkin mencoba menyimpan level para pemain dalam sebuah array:"

#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once it's set. If a player dies, you "
"cannot remove it from the array unless he happens to be in the first position."
msgstr ""
"Tetapi kemudian Anda menyadari bahwa Anda tidak dapat meningkatkan level di indeks tertentu setelah diatur. Jika "
"seorang pemain mati, Anda tidak dapat menghapusnya dari array kecuali jika dia kebetulan berada di posisi "
"pertama."

#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary type](./ch03-02-dictionaries.md) called "
"`Felt252Dict<T>` that allows us to simulate the behavior of mutable data structures. Let's first explore how to "
"use it to create a dynamic array implementation."
msgstr ""
"Untungnya, Cairo menyediakan tipe [kamus](./ch03-02-dictionaries.md) bawaan yang praktis disebut "
"`Felt252Dict<T>` yang memungkinkan kita mensimulasikan perilaku struktur data yang dapat diubah. Mari pertama-"
"tama jelajahi cara menggunakannya untuk membuat implementasi array dinamis."

#: src/ch03-03-custom-data-structures.md:28
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of the book. We recommend you to check "
"out the following chapter first: [Structs](ch05-00-using-structs-to-structure-related-data), [Methods](./ch05-03-"
"method-syntax.md), [Generic types](./ch08-00-generic-types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)"
msgstr ""
"Catatan: Beberapa konsep yang digunakan dalam bab ini disajikan dalam bagian-bagian berikutnya dari buku ini. "
"Kami menyarankan Anda untuk mengecek bab-bab berikut terlebih dahulu: [Structs](ch05-00-using-structs-to-"
"structure-related-data), [Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-types-and-"
"traits.md), [Traits](./ch08-02-traits-in-cairo.md)"

#: src/ch03-03-custom-data-structures.md:35
msgid "Simulating a dynamic array with dicts"
msgstr "Mensimulasikan array dinamis dengan kamus"

#: src/ch03-03-custom-data-structures.md:37
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. What operations should it support?"
msgstr ""
"Pertama, mari pertimbangkan bagaimana kita ingin array dinamis yang dapat diubah kita berperilaku. Operasi apa "
"yang seharusnya didukungnya?"

#: src/ch03-03-custom-data-structures.md:40
msgid "It should:"
msgstr "Seharusnya:"

#: src/ch03-03-custom-data-structures.md:42
msgid "Allow us to append items at the end"
msgstr "Memungkinkan kita untuk menambahkan item di bagian akhir"

#: src/ch03-03-custom-data-structures.md:43
msgid "Let us access any item by index"
msgstr "Memungkinkan kita mengakses item apa pun berdasarkan indeks"

#: src/ch03-03-custom-data-structures.md:44
msgid "Allow setting the value of an item at a specific index"
msgstr "Memungkinkan penyetelan nilai item pada indeks tertentu"

#: src/ch03-03-custom-data-structures.md:45
msgid "Return the current length"
msgstr "Mengembalikan panjang saat ini"

#: src/ch03-03-custom-data-structures.md:47
msgid "We can define this interface in Cairo like:"
msgstr "Kita dapat mendefinisikan antarmuka ini di Cairo seperti:"

#: src/ch03-03-custom-data-structures.md:60
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We named it Vec as it is similar to the "
"`Vec<T>` data structure in Rust."
msgstr ""
"Ini memberikan gambaran untuk implementasi array dinamis kita. Kami menamainya Vec karena mirip dengan struktur "
"data `Vec<T>` dalam Rust."

#: src/ch03-03-custom-data-structures.md:63
msgid "Implementing a dynamic array in Cairo"
msgstr "Mengimplementasikan array dinamis di Cairo"

#: src/ch03-03-custom-data-structures.md:65
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers (felts) to values. We'll also store a "
"separate `len` field to track the length."
msgstr ""
"Untuk menyimpan data kita, kita akan menggunakan `Felt252Dict<T>` yang memetakan nomor indeks (felt) ke nilai. "
"Kita juga akan menyimpan bidang terpisah `len` untuk melacak panjangnya."

#: src/ch03-03-custom-data-structures.md:68
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` pointer to allow using any type `T` "
"in our data structure, as explained in the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"Berikut tampilan struktur kita. Kami melingkupi tipe `T` dalam pointer `Nullable` untuk memungkinkan penggunaan "
"setiap tipe `T` dalam struktur data kami, seperti dijelaskan dalam bagian [Kamus](./ch03-02-dictionaries."
"md#dictionaries-of-types-not-supported-natively):"

#: src/ch03-03-custom-data-structures.md:80
msgid ""
"The key thing that makes this vector mutable is that we can insert values into the dictionary to set or update "
"values in our data structure. For example, to update a value at a specific index, we do:"
msgstr ""
"Hal kunci yang membuat vektor ini dapat diubah adalah kita dapat menyisipkan nilai ke dalam kamus untuk mengatur "
"atau memperbarui nilai dalam struktur data kita. Sebagai contoh, untuk memperbarui nilai pada indeks tertentu, "
"kita lakukan:"

#: src/ch03-03-custom-data-structures.md:91
msgid "This overwrites the previously existing value at that index in the dictionary."
msgstr "Ini menimpa nilai yang sudah ada sebelumnya pada indeks tersebut dalam kamus."

#: src/ch03-03-custom-data-structures.md:93
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for modifiable data structures like "
"vectors."
msgstr ""
"Meskipun array bersifat tidak dapat diubah, kamus memberikan fleksibilitas yang kita butuhkan untuk struktur "
"data yang dapat dimodifikasi seperti vektor."

#: src/ch03-03-custom-data-structures.md:96
msgid ""
"The implementation of the rest of the interface is straightforward. The implementation of all the methods "
"defined in our interface can be done as follow :"
msgstr ""
"Implementasi sisa antarmukanya cukup langsung. Implementasi semua metode yang didefinisikan dalam antarmuka kita "
"dapat dilakukan sebagai berikut:"

#: src/ch03-03-custom-data-structures.md:133
msgid ""
"The full implementation of the `Vec` structure can be found in the community-maintained library [Alexandria]"
"(https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)."
msgstr ""
"Implementasi lengkap struktur `Vec` dapat ditemukan di perpustakaan yang dikelola oleh komunitas [Alexandria]"
"(https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)."

#: src/ch03-03-custom-data-structures.md:137
msgid "Simulating a Stack with dicts"
msgstr "Mensimulasikan Stack dengan kamus"

#: src/ch03-03-custom-data-structures.md:139
msgid "We will now look at a second example and its implementation details: a Stack."
msgstr "Sekarang kita akan melihat contoh kedua dan detail implementasinya: sebuah Stack."

#: src/ch03-03-custom-data-structures.md:141
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new element and removal of an existing "
"element takes place at the same end, represented as the top of the stack."
msgstr ""
"Sebuah Stack adalah koleksi LIFO (Last-In, First-Out). Penyisipan elemen baru dan penghapusan elemen yang sudah "
"ada terjadi di ujung yang sama, yang direpresentasikan sebagai puncak tumpukan."

#: src/ch03-03-custom-data-structures.md:145
msgid "Let us define what operations we need to create a stack :"
msgstr "Mari tentukan operasi apa yang kita butuhkan untuk membuat sebuah stack:"

#: src/ch03-03-custom-data-structures.md:147
msgid "Push an item to the top of the stack"
msgstr "Mendorong sebuah item ke bagian atas stack"

#: src/ch03-03-custom-data-structures.md:148
msgid "Pop an item from the top of the stack"
msgstr "Mengeluarkan sebuah item dari bagian atas stack"

#: src/ch03-03-custom-data-structures.md:149
msgid "Check whether there are still any elements in the stack."
msgstr "Memeriksa apakah masih ada elemen di dalam stack."

#: src/ch03-03-custom-data-structures.md:151
msgid "From these specifications we can define the following interface :"
msgstr "Dari spesifikasi ini, kita dapat mendefinisikan antarmuka berikut:"

#: src/ch03-03-custom-data-structures.md:161
msgid "Implementing a Mutable Stack in Cairo"
msgstr "Menerapkan Stack Yang Dapat Diubah di Cairo"

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"To create a stack data structure in Cairo, we can again use a `Felt252Dict<T>` to store the values of the stack "
"along with a `usize` field to keep track of the length of the stack to iterate over it."
msgstr ""
"Untuk membuat struktur data tumpukan (stack) di Cairo, kita dapat lagi menggunakan `Felt252Dict<T>` untuk "
"menyimpan nilai-nilai tumpukan beserta sebuah bidang `usize` untuk melacak panjang tumpukan agar dapat melakukan "
"iterasi atasnya."

#: src/ch03-03-custom-data-structures.md:167
msgid "The Stack struct is defined as:"
msgstr "Struktur data Stack didefinisikan sebagai berikut:"

#: src/ch03-03-custom-data-structures.md:176
msgid "Next, let's see how our main functions `push` and `pop` are implemented."
msgstr "Selanjutnya, mari kita lihat bagaimana fungsi utama kami, `push` dan `pop`, diimplementasikan."

#: src/ch03-03-custom-data-structures.md:201
msgid ""
"The code uses the `insert` and `get` methods to access the values in the `Felt252Dict<T>`. To push an element at "
"the top of the stack, the `push` function inserts the element in the dict at index `len` - and increases the "
"`len` field of the stack to keep track of the position of the stack top. To remove a value, the `pop` function "
"retrieves the last value at position `len-1` and then decreases the value of `len` to update the position of the "
"stack top accordingly."
msgstr ""
"Kode menggunakan metode `insert` dan `get` untuk mengakses nilai-nilai dalam `Felt252Dict<T>`. Untuk menambahkan "
"elemen di bagian atas tumpukan, fungsi `push` menyisipkan elemen ke dalam dict pada indeks `len` - dan "
"meningkatkan bidang `len` dari tumpukan untuk melacak posisi puncak tumpukan. Untuk menghapus sebuah nilai, "
"fungsi `pop` mengambil nilai terakhir pada posisi `len-1` dan kemudian mengurangi nilai dari `len` untuk "
"memperbarui posisi puncak tumpukan sesuai dengan yang diperlukan."

#: src/ch03-03-custom-data-structures.md:209
msgid ""
"The full implementation of the Stack, along with more data structures that you can use in your code, can be "
"found in the community-maintained [Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/"
"data_structures) library, in the \"data_structures\" crate."
msgstr ""
"Implementasi lengkap dari Struktur Data Stack, bersama dengan lebih banyak struktur data yang dapat Anda gunakan "
"dalam kode Anda, dapat ditemukan dalam perpustakaan yang dipelihara oleh komunitas [Alexandria](https://github."
"com/keep-starknet-strange/alexandria/tree/main/src/data_structures), di dalam kumpulan \"data_structures\" crate."

#: src/ch03-03-custom-data-structures.md:216
msgid ""
"While Cairo's memory model is immutable and can make it difficult to implement mutable data structures, we can "
"fortunately use the `Felt252Dict<T>` type to simulate mutable data structures. This allows us to implement a "
"wide range of data structures that are useful for many applications, effectively hiding the complexity of the "
"underlying memory model."
msgstr ""
"Meskipun model memori Cairo bersifat tak dapat diubah (immutable) dan dapat menyulitkan implementasi struktur "
"data yang dapat diubah, untungnya kita dapat menggunakan tipe `Felt252Dict<T>` untuk mensimulasikan struktur "
"data yang dapat diubah. Hal ini memungkinkan kita untuk mengimplementasikan beragam struktur data yang berguna "
"untuk banyak aplikasi, efektif menyembunyikan kompleksitas dari model memori yang mendasarinya."

#: src/ch04-00-understanding-ownership.md:1
msgid "Understanding Cairo's Ownership system"
msgstr "Memahami Cairo's Ownership system"

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to statically ensure that in every Cairo "
"program, a value is used exactly once. This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory cell, are detected at compile time. "
"This is achieved by implementing an ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as references and snapshots."
msgstr ""
"Cairo adalah bahasa yang dibangun di sekitar sistem tipe linear yang memungkinkan kita untuk memastikan secara "
"statis bahwa dalam setiap program Cairo, sebuah nilai digunakan tepat satu kali. Sistem tipe linear ini membantu "
"mencegah kesalahan saat runtime dengan memastikan bahwa operasi yang dapat menyebabkan kesalahan tersebut, "
"seperti menulis dua kali ke sel memori, terdeteksi pada waktu kompilasi. Hal ini dicapai dengan menerapkan "
"sistem kepemilikan dan melarang penggandaan serta penghapusan nilai secara default. Pada bab ini, kita akan "
"membahas sistem kepemilikan Cairo serta referensi dan snapshot."

#: src/ch04-01-what-is-ownership.md:1
msgid "What Is Ownership?"
msgstr "Apa itu Ownership?"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of its compiled code. The ownership "
"mechanism complements the linear type system, which enforces that objects are used exactly once. This helps "
"prevent common operations that can produce runtime errors, such as illegal memory address references or multiple "
"writes to the same memory address, and ensures the soundness of Cairo programs by checking at compile time that "
"all the dictionaries are squashed."
msgstr ""
"Cairo menerapkan sistem kepemilikan untuk memastikan keamanan dan kebenaran dari kode yang dikompilasi. "
"Mekanisme kepemilikan melengkapi sistem tipe linear, yang menegaskan bahwa objek digunakan tepat satu kali. Hal "
"ini membantu mencegah operasi umum yang dapat menghasilkan kesalahan saat runtime, seperti referensi alamat "
"memori ilegal atau penulisan ganda ke alamat memori yang sama, dan memastikan kesahihan program Cairo dengan "
"memeriksa pada waktu kompilasi bahwa semua kamus telah di-\"squash\"."

#: src/ch04-01-what-is-ownership.md:9
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() {` code in examples, so if you’re "
"following along, make sure to put the following examples inside a `main` function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code."
msgstr ""
"Sekarang setelah kita melewati sintaks dasar Cairo, kita tidak akan menyertakan semua kode `fn main() {` dalam "
"contoh, jadi jika Anda mengikuti, pastikan untuk menempatkan contoh-contoh berikut di dalam fungsi `main` secara "
"manual. Sebagai hasilnya, contoh-contoh kita akan sedikit lebih ringkas, memungkinkan kita untuk fokus pada "
"detail sebenarnya daripada kode boilerplate."

#: src/ch04-01-what-is-ownership.md:15
msgid "Ownership Rules"
msgstr "Peraturan Ownership"

#: src/ch04-01-what-is-ownership.md:17
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as we work through the examples that "
"illustrate them:"
msgstr ""
"Pertama, mari kita lihat aturan-aturan kepemilikan. Ingatlah aturan-aturan ini saat kita bekerja melalui contoh-"
"contoh yang mengilustrasikan mereka:"

#: src/ch04-01-what-is-ownership.md:20
msgid "Each value in Cairo has an _owner_."
msgstr "Setiap nilai dalam Cairo memiliki _pemilik_."

#: src/ch04-01-what-is-ownership.md:21
msgid "There can only be one owner at a time."
msgstr "Hanya boleh ada satu pemilik pada suatu waktu."

#: src/ch04-01-what-is-ownership.md:22
msgid "When the owner goes out of scope, the value will be _dropped_."
msgstr "Ketika pemilik keluar dari lingkup, nilai akan _dihapus_ (dropped)."

#: src/ch04-01-what-is-ownership.md:24
msgid "Variable Scope"
msgstr "Lingkup Variabel"

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some variables. A scope is the range within a "
"program for which an item is valid. Take the following variable:"
msgstr ""
"Sebagai contoh pertama tentang kepemilikan, kita akan melihat _lingkup_ (scope) dari beberapa variabel. Lingkup "
"adalah rentang dalam program di mana suatu item valid. Ambil variabel berikut:"

#: src/ch04-01-what-is-ownership.md:34
msgid ""
"The variable `s` refers to a short string, where the value of the string is hardcoded into the text of our "
"program. The variable is valid from the point at which it’s declared until the end of the current _scope_. "
"Listing 4-1 shows a program with comments annotating where the variable `s` would be valid."
msgstr ""
"Variabel `s` mengacu pada sebuah string pendek, di mana nilai dari string tersebut telah dimasukkan secara "
"langsung ke dalam teks program kita. Variabel ini valid mulai dari titik di mana ia dideklarasikan hingga akhir "
"_lingkup_ (scope) saat ini. Listing 4-1 menampilkan sebuah program dengan komentar yang menandai di mana "
"variabel `s` akan valid."

#: src/ch04-01-what-is-ownership.md:40
msgid "//TAG: ignore_fmt\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:42
msgid "// s is not valid here, it’s not yet declared\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:43
msgid "// s is valid from this point forward\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:45
msgid "// do stuff with s\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:46
msgid "// this scope is now over, and s is no longer valid\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:50
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr "Listing 4-1: Sebuah variabel dan lingkup di mana variabel tersebut valid"

#: src/ch04-01-what-is-ownership.md:53
msgid "In other words, there are two important points in time here:"
msgstr "Dengan kata lain, ada dua titik waktu penting di sini:"

#: src/ch04-01-what-is-ownership.md:55
msgid "When `s` comes _into_ scope, it is valid."
msgstr "Ketika `s` masuk ke dalam _lingkup_, itu valid."

#: src/ch04-01-what-is-ownership.md:56
msgid "It remains valid until it goes _out of_ scope."
msgstr "Itu tetap valid sampai keluar dari _lingkup_."

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"At this point, the relationship between scopes and when variables are valid is similar to that in other "
"programming languages. Now we’ll build on top of this understanding by using the `Array` type we introduced in "
"the [previous chapter](./ch03-01-arrays.md)."
msgstr ""
"Pada titik ini, hubungan antara lingkup dan kapan variabel valid mirip dengan dalam bahasa pemrograman lain. "
"Sekarang kita akan memperluas pemahaman ini dengan menggunakan tipe `Array` yang kita perkenalkan dalam [bab "
"sebelumnya](./ch03-01-arrays.md)."

#: src/ch04-01-what-is-ownership.md:62
msgid "Ownership with the `Array` Type"
msgstr "Kepemilikan dengan Tipe `Array`"

#: src/ch04-01-what-is-ownership.md:64
msgid ""
"To illustrate the rules of ownership, we need a data type that is more complex. The types covered in the [Data "
"Types](ch02-02-data-types.html#data-types)"
msgstr ""
"Untuk mengilustrasikan aturan-aturan kepemilikan, kita memerlukan tipe data yang lebih kompleks. Tipe-tipe yang "
"dibahas dalam [Tipe Data](ch02-02-data-types.html#data-types)"

#: src/ch04-01-what-is-ownership.md:65
msgid ""
" section of Chapter 2 are of a known size, can be quickly and trivially copied to make a new, independent "
"instance if another part of code needs to use the same value in a different scope, and can easily be dropped "
"when they're no longer used. But what is the behavior with the `Array` type whose size is unknown at compile "
"time and which can't be trivially copied?"
msgstr ""
" bagaimana perilaku dengan tipe `Array` yang ukurannya tidak diketahui pada saat kompilasi dan tidak dapat "
"dengan mudah disalin? Tipe data ini tidak dapat secara sederhana disalin untuk membuat instansi baru yang "
"independen jika bagian lain dari kode memerlukan penggunaan nilai yang sama dalam lingkup yang berbeda, dan "
"tidak dapat dengan mudah dihapus saat tidak lagi digunakan?"

#: src/ch04-01-what-is-ownership.md:72
msgid "Here is a short reminder of what an array looks like:"
msgstr "Berikut adalah pengingat singkat tentang bagaimana penampilan dari sebuah array:"

#: src/ch04-01-what-is-ownership.md:82
msgid ""
"So, how does the ownership system ensure that each cell is never written to more than once? Consider the "
"following code, where we try to pass the same instance of an array in two consecutive function calls:"
msgstr ""
"Jadi, bagaimana sistem kepemilikan memastikan bahwa setiap sel tidak pernah ditulis lebih dari satu kali? "
"Pertimbangkan kode berikut, di mana kita mencoba untuk melewati instansi yang sama dari sebuah array dalam dua "
"pemanggilan fungsi yang berurutan:"

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the functions `foo` and `bar`, which "
"means that the parameter used in both function calls is the same instance of the array. If you append a value to "
"the array in `foo`, and then try to append another value to the same array in `bar`, what would happen is that "
"you would attempt to try to write to the same memory cell twice, which is not allowed in Cairo. To prevent this, "
"the ownership of the `arr` variable moves from the `main` function to the `foo` function. When trying to call "
"`bar` with `arr` as a parameter, the ownership of `arr` was already moved to the first call. The ownership "
"system thus prevents us from using the same instance of `arr` in `foo`."
msgstr ""
"Dalam kasus ini, kita mencoba melewati instansi array yang sama `arr` secara nilai ke fungsi-fungsi `foo` dan "
"`bar`, yang berarti bahwa parameter yang digunakan dalam kedua pemanggilan fungsi adalah instansi yang sama dari "
"array. Jika Anda menambahkan sebuah nilai ke array di `foo`, dan kemudian mencoba menambahkan nilai lain ke "
"array yang sama di `bar`, yang akan terjadi adalah upaya untuk menulis ke sel memori yang sama dua kali, yang "
"tidak diperbolehkan dalam Cairo. Untuk mencegah hal ini, kepemilikan variabel `arr` berpindah dari fungsi `main` "
"ke fungsi `foo`. Ketika mencoba memanggil `bar` dengan `arr` sebagai parameter, kepemilikan dari `arr` sudah "
"dipindahkan ke panggilan pertama. Sistem kepemilikan dengan demikian mencegah kita dari menggunakan instansi "
"yang sama dari `arr` di `foo`."

#: src/ch04-01-what-is-ownership.md:107
msgid "Running the code above will result in a compile-time error:"
msgstr "Menjalankan kode di atas akan menghasilkan kesalahan pada waktu kompilasi:"

#: src/ch04-01-what-is-ownership.md:116
msgid "The `Copy` Trait"
msgstr "Trait `Copy`"

#: src/ch04-01-what-is-ownership.md:118
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not move the ownership of the value to the "
"function called, but will instead pass a copy of the value. You can implement the `Copy` trait on your type by "
"adding the `#[derive(Copy)]` annotation to your type definition. However, Cairo won't allow a type to be "
"annotated with Copy if the type itself or any of its components don't implement the Copy trait. While Arrays and "
"Dictionaries can't be copied, custom types that don't contain either of them can be."
msgstr ""
"Jika sebuah tipe mengimplementasikan trait `Copy`, melewatinya ke fungsi tidak akan memindahkan kepemilikan dari "
"nilai ke fungsi yang dipanggil, namun akan melewatkan salinan dari nilai tersebut. Anda dapat "
"mengimplementasikan trait `Copy` pada tipe Anda dengan menambahkan anotasi `#[derive(Copy)]` pada definisi tipe "
"Anda. Namun, Cairo tidak akan mengizinkan suatu tipe untuk dianotasi dengan `Copy` jika tipe itu sendiri atau "
"salah satu komponennya tidak mengimplementasikan trait `Copy`. Meskipun Array dan Dictionary tidak dapat "
"disalin, tipe kustom yang tidak mengandung keduanya dapat."

#: src/ch04-01-what-is-ownership.md:135
msgid "// do something with p\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:139
msgid ""
"In this example, we can pass `p1` twice to the foo function because the `Point` type implements the `Copy` "
"trait. This means that when we pass `p1` to `foo`, we are actually passing a copy of `p1`, and the ownership of "
"`p1` remains with the main function. If you remove the `Copy` trait derivation from the `Point` type, you will "
"get a compile-time error when trying to compile the code."
msgstr ""
"Dalam contoh ini, kita dapat melewati `p1` dua kali ke fungsi foo karena tipe `Point` mengimplementasikan trait "
"`Copy`. Ini berarti bahwa ketika kita melewati `p1` ke `foo`, sebenarnya kita melewati salinan dari `p1`, dan "
"kepemilikan dari `p1` tetap berada di dalam fungsi `main`. Jika Anda menghapus derivasi trait `Copy` dari tipe "
"`Point`, Anda akan mendapatkan kesalahan pada waktu kompilasi saat mencoba mengompilasi kode."

#: src/ch04-01-what-is-ownership.md:142
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter 5](ch05-00-using-structs-to-"
"structure-related-data.md)._"
msgstr ""
"_Jangan khawatir tentang kata kunci `Struct`. Kami akan memperkenalkan ini dalam [Bab 5](ch05-00-using-structs-"
"to-structure-related-data.md)._"

#: src/ch04-01-what-is-ownership.md:144
msgid "The `Drop` Trait"
msgstr "`Drop` Trait"

#: src/ch04-01-what-is-ownership.md:146
msgid ""
"You may have noticed that the `Point` type in the previous example also implements the `Drop` trait. In Cairo, a "
"value cannot go out of scope unless it has been previously moved. For example, the following code will not "
"compile, because the struct `A` is not moved before it goes out of scope:"
msgstr ""
"Anda mungkin telah memperhatikan bahwa tipe `Point` pada contoh sebelumnya juga mengimplementasikan trait "
"`Drop`. Dalam Cairo, sebuah nilai tidak dapat keluar dari lingkup kecuali sudah dipindahkan sebelumnya. Sebagai "
"contoh, kode berikut tidak akan bisa dikompilasi, karena struktur `A` tidak dipindahkan sebelum keluar dari "
"lingkup:"

#: src/ch04-01-what-is-ownership.md:153
msgid "// error: Value not dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:157
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the fact that if a statement during the "
"execution of the program is false, no cheating prover can convince an honest verifier that it is true. In our "
"case, we want to ensure the consistency of consecutive dictionary key updates during program execution, which is "
"only checked when the dictionaries are `squashed` - which moves the ownership of the dictionary to the `squash` "
"method, thus allowing the dictionary to go out of scope. Unsquashed dictionaries are dangerous, as a malicious "
"prover could prove the correctness of inconsistent updates."
msgstr ""
"Hal ini untuk memastikan kesahihan program-program Cairo. Kesahihan mengacu pada fakta bahwa jika suatu "
"pernyataan selama eksekusi program adalah salah, tidak ada pemeriksa yang jujur dapat diyakinkan oleh pemeriksa "
"yang tidak jujur bahwa itu benar. Dalam kasus kami, kami ingin memastikan konsistensi dari pembaruan kunci kamus "
"berturut-turut selama eksekusi program, yang hanya diperiksa ketika kamus tersebut 'dipersiapkan' (squashed) - "
"yang memindahkan kepemilikan kamus ke metode `squash`, sehingga memungkinkan kamus tersebut keluar dari lingkup. "
"Kamus yang tidak disiapkan (unsquashed) berbahaya, karena pemeriksa yang jahat dapat membuktikan kebenaran dari "
"pembaruan yang tidak konsisten."

#: src/ch04-01-what-is-ownership.md:165
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of scope without being explicitly moved. "
"When a value of a type that implements the `Drop` trait goes out of scope, the `Drop` implementation is called "
"on the type, which moves the value to the `drop` function, allowing it to go out of scope - This is what we call "
"\"dropping\" a value. It is important to note that the implementation of drop is a \"no-op\", meaning that it "
"doesn't perform any actions other than allowing the value to go out of scope."
msgstr ""
"Namun, tipe-tipe yang mengimplementasikan trait `Drop` diizinkan untuk keluar dari lingkup tanpa dipindahkan "
"secara eksplisit. Ketika nilai dari suatu tipe yang mengimplementasikan trait `Drop` keluar dari lingkup, "
"implementasi `Drop` dipanggil pada tipe tersebut, yang memindahkan nilai ke fungsi `drop`, memungkinkannya untuk "
"keluar dari lingkup - Ini yang kita sebut sebagai \"menghapus\" (dropping) sebuah nilai. Penting untuk dicatat "
"bahwa implementasi drop adalah \"no-op\", yang berarti bahwa itu tidak melakukan tindakan apa pun selain "
"memungkinkan nilai untuk keluar dari lingkup."

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be dropped when going out of scope, "
"except for dictionaries (`Felt252Dict`) and types containing dictionaries. For example, the following code "
"compiles:"
msgstr ""
"Implementasi `Drop` dapat diperoleh untuk semua tipe, memungkinkan mereka untuk di-drop saat keluar dari "
"lingkup, kecuali untuk kamus (`Felt252Dict`) dan tipe yang mengandung kamus. Sebagai contoh, kode berikut dapat "
"dikompilasi:"

#: src/ch04-01-what-is-ownership.md:176
msgid "// Now there is no error.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:180
msgid "The `Destruct` Trait"
msgstr "`Destruct` Trait"

#: src/ch04-01-what-is-ownership.md:182
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, and it is easy to forget to do so. "
"To make it easier to use dictionaries, Cairo provides the `Destruct` trait, which allows you to specify the "
"behavior of a type when it goes out of scope. While Dictionaries don't implement the `Drop` trait, they do "
"implement the `Destruct` trait, which allows them to automatically be `squashed` when they go out of scope. This "
"means that you can use dictionaries without having to manually call the `squash` method."
msgstr ""
"Memanggil metode `squash` secara manual pada suatu kamus tidaklah sangat praktis, dan mudah untuk dilupakan. "
"Untuk memudahkan penggunaan kamus, Cairo menyediakan trait `Destruct`, yang memungkinkan Anda untuk menentukan "
"perilaku suatu tipe saat keluar dari lingkup. Meskipun Kamus tidak mengimplementasikan trait `Drop`, mereka "
"mengimplementasikan trait `Destruct`, yang memungkinkan mereka untuk secara otomatis di-\"squash\" saat keluar "
"dari lingkup. Ini berarti bahwa Anda dapat menggunakan kamus tanpa harus memanggil metode `squash` secara manual."

#: src/ch04-01-what-is-ownership.md:184
msgid "Consider the following example, in which we define a custom type that contains a dictionary:"
msgstr "Pertimbangkan contoh berikut, di mana kita mendefinisikan sebuah tipe kustom yang mengandung sebuah kamus:"

#: src/ch04-01-what-is-ownership.md:197
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "Jika Anda mencoba menjalankan kode ini, Anda akan mendapatkan kesalahan pada waktu kompilasi:"

#: src/ch04-01-what-is-ownership.md:206
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the `Drop` (as it contains a dictionary "
"and can't `derive(Drop)`) nor the `Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"Ketika A keluar dari lingkup, ia tidak dapat di-drop karena tidak mengimplementasikan trait `Drop` (karena "
"mengandung kamus dan tidak bisa `derive(Drop)`) maupun trait `Destruct`. Untuk memperbaiki ini, kita dapat "
"menurunkan implementasi trait `Destruct` untuk tipe `A`:"

#: src/ch04-01-what-is-ownership.md:215
msgid "// No error here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:219
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically `squashed`, and the program will compile."
msgstr ""
"Sekarang, ketika `A` keluar dari lingkup, kamusnya akan secara otomatis di-\"squash\", dan program akan berhasil "
"dikompilasi."

#: src/ch04-01-what-is-ownership.md:221
msgid "Copy Array data with Clone"
msgstr "Menyalin Data Array dengan Clone"

#: src/ch04-01-what-is-ownership.md:223
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common method called `clone`. We’ll discuss "
"method syntax in Chapter 6, but because methods are a common feature in many programming languages, you’ve "
"probably seen them before."
msgstr ""
"Jika kita _ingin_ menyalin data secara mendalam dari sebuah `Array`, kita dapat menggunakan metode umum yang "
"disebut `clone`. Kami akan membahas sintaks metode dalam Bab 6, tetapi karena metode adalah fitur umum dalam "
"banyak bahasa pemrograman, Anda mungkin sudah pernah melihatnya sebelumnya."

#: src/ch04-01-what-is-ownership.md:226
msgid "Here’s an example of the `clone` method in action."
msgstr "Berikut adalah contoh penggunaan metode `clone`."

#: src/ch04-01-what-is-ownership.md:228
msgid ""
"Note: in the following example, we need to import the `Clone` trait from the corelib `clone` module, and its "
"implementation for the array type from the `array` module."
msgstr ""
"Catatan: pada contoh berikut, kita perlu mengimpor trait `Clone` dari modul `clone` dalam corelib, dan "
"implementasinya untuk tipe array dari modul `array`."

#: src/ch04-01-what-is-ownership.md:239
msgid ""
"Note: you will need to run `scarb cairo-run` with the `--available-gas=2000000` option to run this example, "
"because it uses a loop and must be ran with a gas limit."
msgstr ""
"Catatan: Anda perlu menjalankan `scarb cairo-run` dengan opsi `--available-gas=2000000` untuk menjalankan contoh "
"ini, karena menggunakan sebuah loop dan harus dijalankan dengan batasan gas."

#: src/ch04-01-what-is-ownership.md:241
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being executed and that code may be "
"expensive. It’s a visual indicator that something different is going on."
msgstr ""
"Ketika Anda melihat panggilan ke `clone`, Anda tahu bahwa beberapa kode sembarang sedang dieksekusi dan kode "
"tersebut mungkin memakan biaya yang mahal. Itu adalah penanda visual bahwa ada sesuatu yang berbeda sedang "
"terjadi."

#: src/ch04-01-what-is-ownership.md:245
msgid "Ownership and Functions"
msgstr "Kepemilikan dan Fungsi"

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in the Array section, passing an "
"`Array` as a function parameter transfers its ownership; let's see what happens with other types."
msgstr ""
"Mengirimkan sebuah variabel ke dalam sebuah fungsi akan entah memindahkannya atau menyalinnya. Seperti yang "
"terlihat pada bagian Array, melewatkan sebuah `Array` sebagai parameter fungsi mentransfer kepemilikannya; mari "
"lihat apa yang terjadi dengan tipe-tipe lainnya."

#: src/ch04-01-what-is-ownership.md:249
msgid "Listing 4-3 has an example with some annotations showing where variables go into and out of scope."
msgstr ""
"Listing 4-3 memiliki contoh dengan beberapa anotasi yang menunjukkan di mana variabel masuk dan keluar dari "
"lingkup."

#: src/ch04-01-what-is-ownership.md:259
msgid "// my_struct comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:261
msgid ""
"// my_struct's value moves into the function...\n"
"                                    // ... and so is no longer valid here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:264
msgid "// x comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:266
msgid ""
"// x would move into the function,\n"
"                                    // but u128 implements Copy, so it is okay to still\n"
"                                    // use x afterward\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:270
msgid "// Here, x goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:273
msgid "// some_struct comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:274
msgid "// Here, some_struct goes out of scope and `drop` is called.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:276
msgid "// some_uinteger comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:277
msgid "// Here, some_integer goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:280
msgid "Listing 4-3: Functions with ownership and scope annotated"
msgstr "Listing 4-3: Fungsi dengan kepemilikan dan lingkup yang diberi anotasi"

#: src/ch04-01-what-is-ownership.md:283
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo would throw a compile-time error. "
"These static checks protect us from mistakes. Try adding code to `main` that uses `my_struct` and `x` to see "
"where you can use them and where the ownership rules prevent you from doing so."
msgstr ""
"Jika kita mencoba menggunakan `my_struct` setelah panggilan ke `takes_ownership`, Cairo akan melemparkan "
"kesalahan pada waktu kompilasi. Pemeriksaan statis ini melindungi kita dari kesalahan. Coba tambahkan kode ke "
"`main` yang menggunakan `my_struct` dan `x` untuk melihat di mana Anda dapat menggunakannya dan di mana aturan "
"kepemilikan mencegah Anda melakukannya."

#: src/ch04-01-what-is-ownership.md:288
msgid "Return Values and Scope"
msgstr "Value Return dan Lingkup"

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example of a function that returns some "
"value, with similar annotations as those in Listing 4-3."
msgstr ""
"Value Return juga dapat mentransfer kepemilikan. Listing 4-4 menunjukkan contoh sebuah fungsi yang mengembalikan "
"suatu nilai, dengan anotasi yang mirip dengan yang ada pada Listing 4-3."

#: src/ch04-01-what-is-ownership.md:301
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:304
msgid "// a2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:310
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:313
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:317
msgid "// some_a comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:319
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:323
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:325
msgid ""
"// some_a comes into\n"
"                                          // scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"// some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:334
msgid "Listing 4-4: Transferring ownership of return values"
msgstr "Listing 4-4: Mentransfer kepemilikan dari value return"

#: src/ch04-01-what-is-ownership.md:337
msgid ""
"When a variable goes out of scope, its value is dropped, unless ownership of the value has been moved to another "
"variable."
msgstr ""
"Ketika sebuah variabel keluar dari lingkup, nilainya dihapus (dropped), kecuali kepemilikannya dari nilai "
"tersebut telah dipindahkan ke variabel lain."

#: src/ch04-01-what-is-ownership.md:339
msgid ""
"While this works, taking ownership and then returning ownership with every function is a bit tedious. What if we "
"want to let a function use a value but not take ownership? It’s quite annoying that anything we pass in also "
"needs to be passed back if we want to use it again, in addition to any data resulting from the body of the "
"function that we might want to return as well."
msgstr ""
"Meskipun ini berfungsi, mengambil kepemilikan dan kemudian mengembalikan kepemilikan setiap fungsi sedikit "
"merepotkan. Bagaimana jika kita ingin membiarkan sebuah fungsi menggunakan sebuah nilai tetapi tidak mengambil "
"kepemilikannya? Sangat menjengkelkan bahwa apapun yang kita lewatkan juga perlu dikembalikan jika kita ingin "
"menggunakannya lagi, selain dari data apapun yang dihasilkan dari badan fungsi yang mungkin juga ingin kita "
"kembalikan."

#: src/ch04-01-what-is-ownership.md:345
msgid "Cairo does let us return multiple values using a tuple, as shown in Listing 4-5."
msgstr ""
"Cairo memungkinkan kita untuk mengembalikan multiple nilai menggunakan tuple, seperti yang ditunjukkan pada "
"Listing 4-5."

#: src/ch04-01-what-is-ownership.md:357
msgid "// len() returns the length of an array\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:363
msgid "Listing 4-5: Returning ownership of parameters"
msgstr "Listing 4-5: Menunjukan Ownership dari parameter"

#: src/ch04-01-what-is-ownership.md:365
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Cairo has "
"two features for using a value without transferring ownership, called _references_ and _snapshots_."
msgstr ""
"Tetapi ini terlalu banyak seremoni dan pekerjaan yang berlebihan untuk konsep yang seharusnya umum. Untungnya "
"untuk kita, Cairo memiliki dua fitur untuk menggunakan sebuah nilai tanpa mentransfer kepemilikan, yang disebut "
"_referensi_ dan _snapshot_."

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the `Array` to the calling function so we "
"can still use the `Array` after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"Masalah dengan kode tuple pada Listing 4-5 adalah kita harus mengembalikan `Array` ke fungsi pemanggil sehingga "
"kita masih dapat menggunakan `Array` setelah panggilan ke `calculate_length`, karena `Array` tersebut "
"dipindahkan ke dalam `calculate_length`."

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a snapshot is an immutable view of a value "
"at a certain point in time. In the previous chapter, we talked about how Cairo's ownership system prevents us "
"from using a value after we've moved it, protecting us from potentially writing twice to the same memory cell "
"when appending values to arrays. However, it's not very convenient. Let's see how we can retain ownership of the "
"value in the calling function using snapshots."
msgstr ""
"Sebagai gantinya, kita dapat menyediakan _snapshot_ dari nilai `Array`. Di Cairo, snapshot adalah pandangan yang "
"tidak dapat diubah dari sebuah nilai pada titik waktu tertentu. Pada bab sebelumnya, kita membahas bagaimana "
"sistem kepemilikan Cairo mencegah kita menggunakan sebuah nilai setelah kita telah memindahkannya, melindungi "
"kita dari kemungkinan menulis dua kali ke sel memori yang sama saat menambahkan nilai ke array. Namun, ini tidak "
"terlalu nyaman. Mari kita lihat bagaimana kita dapat mempertahankan kepemilikan nilai di dalam fungsi pemanggil "
"menggunakan snapshot."

#: src/ch04-02-references-and-snapshots.md:17
msgid ""
"Here is how you would define and use a `calculate_length` function that takes a snapshot to an array as a "
"parameter instead of taking ownership of the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as parameter. As we're passing it as a snapshot, which is an immutable "
"view of the array, we can be sure that the `calculate_length` function will not mutate the array, and ownership "
"of the array is kept in the main function."
msgstr ""
"Berikut adalah cara Anda akan mendefinisikan dan menggunakan fungsi `calculate_length` yang mengambil snapshot "
"dari sebuah array sebagai parameter daripada mengambil kepemilikan dari nilai yang mendasarinya. Pada contoh "
"ini, fungsi `calculate_length` mengembalikan panjang dari array yang dilewatkan sebagai parameter. Karena kita "
"melewatinya sebagai snapshot, yang merupakan pandangan yang tidak dapat diubah dari array, kita dapat yakin "
"bahwa fungsi `calculate_length` tidak akan mengubah array tersebut, dan kepemilikan dari array tetap berada di "
"dalam fungsi utama."

#: src/ch04-02-references-and-snapshots.md:30 src/ch04-02-references-and-snapshots.md:69
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:31 src/ch04-02-references-and-snapshots.md:70
msgid "// Mutate `arr1` by appending a value\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:34
msgid ""
"// Calculate the length of the array when the snapshot was taken\n"
"    //ANCHOR: function_call\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:36
msgid ""
"// Calculate the current length of the array\n"
"    //ANCHOR_END: function_call\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:47
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot because it is defined as such in the "
"`ArrayTrait` trait. If you try to call a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on non-snapshot types."
msgstr ""
"Catatan: Hanya mungkin untuk memanggil metode `len()` pada sebuah snapshot array karena itu didefinisikan dalam "
"trait `ArrayTrait`. Jika Anda mencoba memanggil sebuah metode yang tidak didefinisikan untuk snapshot pada "
"sebuah snapshot, Anda akan mendapatkan kesalahan kompilasi. Namun, Anda dapat memanggil metode yang mengharapkan "
"snapshot pada tipe-tipe non-snapshot."

#: src/ch04-02-references-and-snapshots.md:49
msgid "The output of this program is:"
msgstr "Output dari program ini:"

#: src/ch04-02-references-and-snapshots.md:59
msgid ""
"First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, "
"note that we pass `@arr1` into `calculate_length` and, in its definition, we take `@Array<u128>` rather than "
"`Array<u128>`."
msgstr ""
"Pertama, perhatikan bahwa semua kode tuple dalam deklarasi variabel dan nilai kembalian fungsi telah hilang. "
"Kedua, perhatikan bahwa kita melewatkan `@arr1` ke dalam `calculate_length` dan, dalam definisinya, kita "
"mengambil `@Array<u128>` daripada `Array<u128>`."

#: src/ch04-02-references-and-snapshots.md:62
msgid "Let’s take a closer look at the function call here:"
msgstr "Mari kita perhatikan lebih dekat panggilan fungsi di sini:"

#: src/ch04-02-references-and-snapshots.md:73
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:74
msgid "// Calculate the current length of the array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because a snapshot is an immutable view of "
"a value, the value it points to cannot be modified through the snapshot, and the value it refers to will not be "
"dropped once the snapshot stops being used."
msgstr ""
"Sintaks `@arr1` memungkinkan kita membuat snapshot dari nilai di `arr1`. Karena sebuah snapshot adalah pandangan "
"yang tidak dapat diubah dari sebuah nilai, nilai yang ditunjuknya tidak dapat dimodifikasi melalui snapshot, dan "
"nilai yang dirujuknya tidak akan dihapus begitu snapshot berhenti digunakan."

#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type of the parameter `arr` is a "
"snapshot. Let’s add some explanatory annotations:"
msgstr ""
"Demikian pula, tanda fungsi menggunakan `@` untuk menunjukkan bahwa tipe dari parameter `arr` adalah sebuah "
"snapshot. Mari kita tambahkan beberapa anotasi penjelasan:"

#: src/ch04-02-references-and-snapshots.md:91
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:93
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be "
"used.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:97
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any function parameter’s scope, but the "
"underlying value of the snapshot is not dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to return the values in order to give back "
"ownership of the original value, because we never had it."
msgstr ""
"Lingkup di mana variabel `array_snapshot` valid sama seperti lingkup parameter fungsi mana pun, tetapi nilai "
"dasar dari snapshot tidak dihapus saat `array_snapshot` berhenti digunakan. Ketika fungsi memiliki snapshot "
"sebagai parameter daripada nilai aktual, kita tidak perlu mengembalikan nilai untuk memberikan kembali "
"kepemilikan dari nilai asli, karena kita tidak pernah memiliki kepemilikannya."

#: src/ch04-02-references-and-snapshots.md:99
msgid "Desnap Operator"
msgstr "Desnap Operator"

#: src/ch04-02-references-and-snapshots.md:101
msgid ""
"To convert a snapshot back into a regular value, you can use the `desnap` operator `*`, which serves as the "
"opposite of the `@` operator: the snapshot value is copied to a new variable."
msgstr ""
"Untuk mengonversi sebuah snapshot kembali menjadi nilai regular, Anda dapat menggunakan operator `desnap` `*`, "
"yang berfungsi sebagai kebalikan dari operator `@`: nilai snapshot akan disalin ke variabel baru."

#: src/ch04-02-references-and-snapshots.md:103
msgid ""
"It's important to note that during this conversion process, the value it points to is copied into a new "
"variable. This enables multiple uses of the underlying value without concerns about ownership transfers. This "
"also means that the value pointed to by the snapshot must be copyable (which is not the case for Arrays, as they "
"don't implement `Copy`)."
msgstr ""
"Penting untuk dicatat bahwa selama proses konversi ini, nilai yang ditunjuknya disalin ke dalam variabel baru. "
"Ini memungkinkan penggunaan ganda dari nilai dasar tanpa kekhawatiran tentang transfer kepemilikan. Ini juga "
"berarti bahwa nilai yang ditunjuk oleh snapshot harus dapat disalin (copyable) (yang bukan merupakan kasus untuk "
"Arrays, karena mereka tidak mengimplementasikan `Copy`)."

#: src/ch04-02-references-and-snapshots.md:105
msgid ""
"In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of "
"the rectangle in the `calculate_area` function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the "
"rectangle to the function, and then transform the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Dalam contoh berikut, kita ingin menghitung luas persegi panjang, tetapi kita tidak ingin mengambil kepemilikan "
"dari persegi panjang di fungsi `calculate_area`, karena kita mungkin ingin menggunakan persegi panjang tersebut "
"lagi setelah panggilan fungsi. Karena fungsi kita tidak mengubah instance persegi panjang, kita dapat meneruskan "
"snapshot dari persegi panjang ke fungsi, dan kemudian mengubah snapshot kembali menjadi nilai menggunakan "
"operator `desnap` `*`."

#: src/ch04-02-references-and-snapshots.md:123
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:131
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? Try the code in Listing 4-6. Spoiler "
"alert: it doesn’t work!"
msgstr ""
"Tetapi, apa yang terjadi jika kita mencoba memodifikasi sesuatu yang kita lewati sebagai snapshot? Cobalah kode "
"di Listing 4-6. Peringatan: itu tidak berhasil!"

#: src/ch04-02-references-and-snapshots.md:155
msgid "Listing 4-6: Attempting to modify a snapshot value"
msgstr "Listing 4-6: Mencoba untuk memodifikasi nilai snapshot"

#: src/ch04-02-references-and-snapshots.md:157
msgid "Here’s the error:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:166
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr "Compiler mencegah kita untuk memodifikasi nilai yang terkait dengan snapshot."

#: src/ch04-02-references-and-snapshots.md:168
msgid "Mutable References"
msgstr "Referensi yang Dapat Diubah"

#: src/ch04-02-references-and-snapshots.md:170
msgid ""
"We can achieve the behavior we want in Listing 4-6 by using a _mutable reference_ instead of a snapshot. Mutable "
"references are actually mutable values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed "
"while keeping ownership of it by returning it automatically at the end of the execution. In Cairo, a parameter "
"can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Kita dapat mencapai perilaku yang diinginkan pada Listing 4-6 dengan menggunakan sebuah _mutable reference_ "
"daripada sebuah snapshot. Mutable references sebenarnya adalah nilai yang dapat dimutasi yang dilewati ke suatu "
"fungsi yang secara implisit dikembalikan pada akhir fungsi, mengembalikan kepemilikan ke konteks pemanggilan. "
"Dengan cara ini, mereka memungkinkan Anda untuk memodifikasi nilai yang dilewati sambil tetap memegang "
"kepemilikannya dengan mengembalikannya secara otomatis pada akhir eksekusi. Di Cairo, sebuah parameter dapat "
"dilewati sebagai _mutable reference_ menggunakan modifier `ref`."

#: src/ch04-02-references-and-snapshots.md:173
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ using the `ref` modifier if the "
"variable is declared as mutable with `mut`."
msgstr ""
"**Catatan**: Di Cairo, sebuah parameter hanya dapat dilewati sebagai _mutable reference_ menggunakan modifier "
"`ref` jika variabel dideklarasikan sebagai mutable dengan `mut`."

#: src/ch04-02-references-and-snapshots.md:175
msgid ""
"In Listing 4-7, we use a mutable reference to modify the value of the `height` and `width` fields of the "
"`Rectangle` instance in the `flip` function."
msgstr ""
"Pada Listing 4-7, kita menggunakan mutable reference untuk memodifikasi nilai dari bidang `height` dan `width` "
"dari instance `Rectangle` dalam fungsi `flip`."

#: src/ch04-02-references-and-snapshots.md:199
msgid "Listing 4-7: Use of a mutable reference to modify a value"
msgstr "Listing 4-7: Penggunaan mutable reference untuk memodifikasi sebuah nilai"

#: src/ch04-02-references-and-snapshots.md:201
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of `rec` into `flip` with `ref rec`, and "
"update the function signature to accept a mutable reference with `ref rec: Rectangle`. This makes it very clear "
"that the `flip` function will mutate the value of the `Rectangle` instance passed as parameter."
msgstr ""
"Pertama, kita ubah `rec` menjadi `mut`. Kemudian kita lewatkan sebuah mutable reference dari `rec` ke dalam "
"`flip` dengan `ref rec`, dan perbarui tanda fungsi untuk menerima sebuah mutable reference dengan `ref rec: "
"Rectangle`. Hal ini membuat sangat jelas bahwa fungsi `flip` akan memutasi nilai dari instance `Rectangle` yang "
"dilewatkan sebagai parameter."

#: src/ch04-02-references-and-snapshots.md:203
msgid "The output of the program is:"
msgstr "Output dari program ini:"

#: src/ch04-02-references-and-snapshots.md:212
msgid "As expected, the `height` and `width` fields of the `rec` variable have been swapped."
msgstr "Seperti yang diharapkan, bidang `height` dan `width` dari variabel `rec` telah ditukar."

#: src/ch04-02-references-and-snapshots.md:214
msgid "Small recap"
msgstr "Rekap kecil"

#: src/ch04-02-references-and-snapshots.md:216
msgid "Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr "Mari kita tinjau kembali apa yang telah kita bahas tentang kepemilikan, snapshot, dan referensi:"

#: src/ch04-02-references-and-snapshots.md:218
msgid "At any given time, a variable can only have one owner."
msgstr "Pada setiap waktu tertentu, sebuah variabel hanya dapat dimiliki oleh satu entitas."

#: src/ch04-02-references-and-snapshots.md:219
msgid "You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""
"Anda dapat melewati sebuah variabel dengan-nilai (by-value), dengan-snapshot (by-snapshot), atau dengan-"
"referensi (by-reference) ke dalam suatu fungsi."

#: src/ch04-02-references-and-snapshots.md:220
msgid "If you pass-by-value, ownership of the variable is transferred to the function."
msgstr ""
"Jika Anda melewatinya dengan-nilai (pass-by-value), kepemilikan dari variabel tersebut dialihkan ke dalam fungsi."

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function won’t mutate it, you can pass it as a "
"snapshot with `@`."
msgstr ""
"Jika Anda ingin tetap memegang kepemilikan dari variabel dan yakin bahwa fungsi Anda tidak akan memutasi "
"nilainya, Anda dapat melewatinya sebagai snapshot dengan menggunakan `@`."

#: src/ch04-02-references-and-snapshots.md:222
msgid ""
"If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a "
"mutable reference with `ref`."
msgstr ""
"Jika Anda ingin tetap memegang kepemilikan dari variabel dan mengetahui bahwa fungsi Anda akan memutasi "
"nilainya, Anda dapat melewatinya sebagai mutable reference dengan menggunakan `ref`."

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together and name multiple related values "
"that make up a meaningful group. If you’re familiar with an object-oriented language, a struct is like an "
"object’s data attributes. In this chapter, we’ll compare and contrast tuples with structs to build on what you "
"already know and demonstrate when structs are a better way to group data."
msgstr ""
"Sebuah struct, atau struktur, adalah tipe data kustom yang memungkinkan Anda untuk mengemas bersama dan memberi "
"nama pada beberapa nilai terkait yang membentuk kelompok yang bermakna. Jika Anda familiar dengan bahasa "
"pemrograman berbasis objek, sebuah struct mirip dengan atribut data objek. Dalam bab ini, kita akan "
"membandingkan dan kontras antara tuple dengan struct untuk memperluas pengetahuan Anda dan menunjukkan kapan "
"struct menjadi cara yang lebih baik untuk mengelompokkan data."

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, "
"especially the kind of associated functions called methods, to specify behavior associated with a struct type. "
"Structs and enums (discussed in the next chapter) are the building blocks for creating new types in your "
"program’s domain to take full advantage of Cairo's compile-time type checking."
msgstr ""
"Kami akan menunjukkan bagaimana mendefinisikan dan menginisialisasi struct. Kami akan membahas bagaimana "
"mendefinisikan fungsi terkait, terutama jenis fungsi terkait yang disebut metode, untuk menentukan perilaku yang "
"terkait dengan tipe struct. Struct dan enum (dibahas dalam bab berikutnya) adalah blok bangunan untuk membuat "
"tipe baru dalam domain program Anda untuk memanfaatkan penuh pemeriksaan tipe pada waktu kompilasi Cairo."

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-types.md) section, in that both hold "
"multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs "
"are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Struct mirip dengan tuple, yang dibahas dalam bagian [Tipe Data](ch02-02-data-types.md), karena keduanya "
"menyimpan beberapa nilai terkait. Seperti tuple, bagian-bagian dari sebuah struct dapat memiliki tipe yang "
"berbeda-beda. Berbeda dengan tuple, dalam sebuah struct, Anda akan memberi nama pada setiap bagian data sehingga "
"jelas apa arti dari nilai-nilai tersebut. Menambahkan nama-nama ini berarti bahwa struct lebih fleksibel "
"daripada tuple: Anda tidak perlu bergantung pada urutan data untuk menentukan atau mengakses nilai dari sebuah "
"instance."

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire struct. A struct’s name should describe "
"the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names "
"and types of the pieces of data, which we call fields. For example, Listing 5-1 shows a struct that stores "
"information about a user account."
msgstr ""
"Untuk mendefinisikan sebuah struct, kita masukkan kata kunci `struct` dan memberi nama pada keseluruhan struct. "
"Nama struct sebaiknya menggambarkan signifikansi dari potongan-potongan data yang dikelompokkan bersama. "
"Kemudian, di dalam kurung kurawal, kita mendefinisikan nama dan tipe dari potongan-potongan data tersebut, yang "
"disebut sebagai fields. Sebagai contoh, Listing 5-1 menunjukkan sebuah struct yang menyimpan informasi tentang "
"sebuah akun pengguna."

#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "Listing 5-1: A `User` struct definition"
msgstr "Listing 5-1: Definisi struct `User`"

#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that struct by specifying concrete values for "
"each of the fields. We create an instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields and the values are the data we want to "
"store in those fields. We don’t have to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for the type, and instances fill in "
"that template with particular data to create values of the type."
msgstr ""
"Untuk menggunakan sebuah struct setelah kita telah mendefinisikannya, kita membuat sebuah _instance_ dari struct "
"tersebut dengan menentukan nilai konkret untuk setiap fieldnya. Kita membuat sebuah instance dengan menyebutkan "
"nama struct dan kemudian menambahkan kurung kurawal yang berisi pasangan _key: value_, di mana kunci-kuncinya "
"adalah nama-nama field dan nilai-nilainya adalah data yang ingin kita simpan dalam field-field tersebut. Kita "
"tidak harus menyebutkan field-field tersebut dalam urutan yang sama dengan yang kita deklarasikan dalam struct. "
"Dengan kata lain, definisi struct tersebut seperti template umum untuk tipe data, dan instance mengisi template "
"tersebut dengan data tertentu untuk membuat nilai dari tipe tersebut."

#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 5-2."
msgstr ""
"Sebagai contoh, kita dapat mendeklarasikan seorang pengguna tertentu seperti yang ditunjukkan pada Listing 5-2."

#: src/ch05-01-defining-and-instantiating-structs.md:44
msgid "Listing 5-2: Creating an instance of the `User` struct"
msgstr "Listing 5-2: Membuat sebuah instance dari struct `User`"

#: src/ch05-01-defining-and-instantiating-structs.md:46
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to access this user’s email address, we "
"use `user1.email`. If the instance is mutable, we can change a value by using the dot notation and assigning "
"into a particular field. Listing 5-3 shows how to change the value in the `email` field of a mutable `User` "
"instance."
msgstr ""
"Untuk mendapatkan nilai spesifik dari sebuah struct, kita menggunakan notasi titik (dot notation). Sebagai "
"contoh, untuk mengakses alamat email dari pengguna ini, kita gunakan `user1.email`. Jika instance tersebut "
"mutable, kita dapat mengubah sebuah nilai dengan menggunakan notasi titik dan melakukan assignment ke dalam "
"sebuah field tertentu. Listing 5-3 menunjukkan bagaimana mengubah nilai dalam field `email` dari sebuah instance "
"mutable `User`."

#: src/ch05-01-defining-and-instantiating-structs.md:76
msgid "Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr "Listing 5-3: Mengubah nilai dalam field email dari sebuah instance `User`"

#: src/ch05-01-defining-and-instantiating-structs.md:78
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to mark only certain fields as mutable."
msgstr ""
"Perlu diingat bahwa seluruh instance harus mutable; Cairo tidak mengizinkan kita untuk menandai hanya beberapa "
"field tertentu sebagai mutable."

#: src/ch05-01-defining-and-instantiating-structs.md:80
msgid ""
"As with any expression, we can construct a new instance of the struct as the last expression in the function "
"body to implicitly return that new instance."
msgstr ""
"Seperti halnya dengan ekspresi lainnya, kita dapat membuat sebuah instance baru dari struct sebagai ekspresi "
"terakhir dalam tubuh fungsi untuk secara implisit mengembalikan instance baru tersebut."

#: src/ch05-01-defining-and-instantiating-structs.md:82
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance with the given email and username. The "
"`active` field gets the value of `true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"Listing 5-4 menunjukkan sebuah fungsi `build_user` yang mengembalikan sebuah instance `User` dengan email dan "
"username yang diberikan. Field `active` mendapatkan nilai `true`, dan field `sign_in_count` mendapatkan nilai "
"`1`."

#: src/ch05-01-defining-and-instantiating-structs.md:112
msgid "Listing 5-4: A `build_user` function that takes an email and username and returns a `User` instance"
msgstr ""
"Listing 5-4: Sebuah fungsi `build_user` yang mengambil email dan username, dan mengembalikan sebuah instance "
"`User`"

#: src/ch05-01-defining-and-instantiating-structs.md:114
msgid ""
"It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the "
"`email` and `username` field names and variables is a bit tedious. If the struct had more fields, repeating each "
"name would get even more annoying. Luckily, there’s a convenient shorthand!"
msgstr ""
"Masuk akal untuk memberi nama parameter fungsi dengan nama yang sama dengan field-field struct, tetapi harus "
"mengulang nama field `email` dan `username` serta variabelnya agak menjengkelkan. Jika struct memiliki lebih "
"banyak field, pengulangan setiap nama akan menjadi lebih menjengkelkan. Untungnya, ada sebuah singkatan yang "
"nyaman!"

#: src/ch05-01-defining-and-instantiating-structs.md:116
msgid "Using the Field Init Shorthand"
msgstr "Menggunakan Singkatan Inisialisasi Field"

#: src/ch05-01-defining-and-instantiating-structs.md:118
msgid ""
"Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field "
"init shorthand syntax to rewrite `build_user` so it behaves exactly the same but doesn’t have the repetition of "
"`username` and `email`, as shown in Listing 5-5."
msgstr ""
"Karena nama-nama parameter dan nama-nama field struct sama persis dalam Listing 5-4, kita dapat menggunakan "
"sintaks singkatan inisialisasi field untuk menulis ulang `build_user` sehingga berfungsi sama persis tetapi "
"tidak memiliki pengulangan `username` dan `email`, seperti yang ditunjukkan dalam Listing 5-5."

#: src/ch05-01-defining-and-instantiating-structs.md:148
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because the `username` and `email` "
"parameters have the same name as struct fields"
msgstr ""
"Listing 5-5: Sebuah fungsi `build_user` yang menggunakan singkatan inisialisasi field karena parameter "
"`username` dan `email` memiliki nama yang sama dengan field struct"

#: src/ch05-01-defining-and-instantiating-structs.md:150
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field named `email`. We want to set the "
"`email` field’s value to the value in the `email` parameter of the `build_user` function. Because the `email` "
"field and the `email` parameter have the same name, we only need to write `email` rather than `email: email`."
msgstr ""
"Di sini, kita sedang membuat sebuah instance baru dari struct `User`, yang memiliki field bernama `email`. Kita "
"ingin mengatur nilai field `email` ke nilai dari parameter `email` dalam fungsi `build_user`. Karena field "
"`email` dan parameter `email` memiliki nama yang sama, kita hanya perlu menulis `email` daripada `email: email`."

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that calculates the area of a rectangle. "
"We’ll start by using single variables, and then refactor the program until we’re using structs instead."
msgstr ""
"Untuk memahami kapan kita mungkin ingin menggunakan struct, mari kita tulis sebuah program yang menghitung luas "
"dari sebuah persegi panjang. Kita akan mulai dengan menggunakan variabel tunggal, dan kemudian melakukan "
"refaktor program hingga pada akhirnya kita menggunakan struct."

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the width and height of a rectangle "
"specified in pixels and calculate the area of the rectangle. Listing 5-6 shows a short program with one way of "
"doing exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Mari buat proyek baru dengan Scarb yang disebut _rectangles_ yang akan mengambil lebar dan tinggi dari sebuah "
"persegi panjang yang ditentukan dalam piksel dan menghitung luas dari persegi panjang tersebut. Listing 5-6 "
"menunjukkan sebuah program pendek dengan salah satu cara untuk melakukan hal tersebut dalam _src/lib.cairo_ dari "
"proyek kita."

#: src/ch05-02-an-example-program-using-structs.md:23
msgid "Listing 5-6: Calculating the area of a rectangle specified by separate width and height variables"
msgstr ""
"Listing 5-6: Menghitung luas dari sebuah persegi panjang yang ditentukan oleh variabel lebar dan tinggi terpisah"

#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run`:"
msgstr "Sekarang jalankan program dengan `scarb cairo-run`:"

#: src/ch05-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the `area` function with each dimension, "
"but we can do more to make this code clear and readable."
msgstr ""
"Kode ini berhasil dalam menemukan luas dari persegi panjang dengan memanggil fungsi `area` dengan setiap "
"dimensi, tetapi kita dapat melakukan lebih untuk membuat kode ini lebih jelas dan mudah dibaca."

#: src/ch05-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "Permasalahan pada kode ini terlihat pada tanda tangan dari `area`:"

#: src/ch05-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but the function we wrote has two "
"parameters, and it’s not clear anywhere in our program that the parameters are related. It would be more "
"readable and more manageable to group width and height together. We’ve already discussed one way we might do "
"that in [Chapter 2](ch02-02-data-types.html#the-tuple-type): using tuples."
msgstr ""
"Fungsi `area` seharusnya menghitung luas dari satu persegi panjang, tetapi fungsi yang kita tulis memiliki dua "
"parameter, dan tidak jelas di mana pun dalam program kita bahwa parameter-parameter tersebut saling terkait. "
"Lebih mudah dibaca dan lebih mudah dikelola jika kita mengelompokkan lebar dan tinggi bersama-sama. Kita telah "
"membahas satu cara untuk melakukannya pada [Bab 2](ch02-02-data-types.html#the-tuple-type): menggunakan tuple."

#: src/ch05-02-an-example-program-using-structs.md:44
msgid "Refactoring with Tuples"
msgstr "Refaktorisasi dengan Tuple"

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr "Listing 5-7 menunjukkan versi lain dari program kita yang menggunakan tuple."

#: src/ch05-02-an-example-program-using-structs.md:55 src/ch05-02-an-example-program-using-structs.md:87
msgid "// print out the area\n"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:64
msgid "Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr "Listing 5-7: Menentukan lebar dan tinggi dari persegi panjang dengan sebuah tuple"

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one "
"argument. But in another way, this version is less clear: tuples don’t name their elements, so we have to index "
"into the parts of the tuple, making our calculation less obvious."
msgstr ""
"Dalam satu hal, program ini lebih baik. Tuple memungkinkan kita menambahkan sedikit struktur, dan sekarang kita "
"hanya melewatkan satu argumen. Tetapi dalam hal lain, versi ini kurang jelas: tuple tidak memberi nama pada "
"elemen-elemennya, sehingga kita harus mengindeks ke dalam bagian-bagian dari tuple, membuat perhitungan kita "
"menjadi kurang jelas."

#: src/ch05-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but if we want to calculate the "
"difference, it would matter! We would have to keep in mind that `width` is the tuple index `0` and `height` is "
"the tuple index `1`. This would be even harder for someone else to figure out and keep in mind if they were to "
"use our code. Because we haven’t conveyed the meaning of our data in our code, it’s now easier to introduce "
"errors."
msgstr ""
"Bercampurnya lebar dan tinggi tidak akan masalah dalam perhitungan luas, tetapi jika kita ingin menghitung "
"perbedaannya, hal ini akan menjadi masalah! Kita harus ingat bahwa `width` adalah indeks `0` dari tuple dan "
"`height` adalah indeks `1` dari tuple. Ini akan menjadi lebih sulit bagi orang lain untuk memahami dan diingat "
"jika mereka ingin menggunakan kode kita. Karena kita belum menyampaikan makna dari data kita dalam kode kita, "
"sekarang lebih mudah untuk memperkenalkan kesalahan."

#: src/ch05-02-an-example-program-using-structs.md:70
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "Refaktorisasi dengan Struct: Menambahkan Lebih Banyak Makna"

#: src/ch05-02-an-example-program-using-structs.md:72
msgid ""
"We use structs to add meaning by labeling the data. We can transform the tuple we’re using into a struct with a "
"name for the whole as well as names for the parts."
msgstr ""
"Kita menggunakan struct untuk menambahkan makna dengan memberi label pada data. Kita dapat mengubah tuple yang "
"kita gunakan menjadi sebuah struct dengan sebuah nama untuk keseluruhan serta nama-nama untuk bagian-bagiannya."

#: src/ch05-02-an-example-program-using-structs.md:95
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr "Listing 5-8: Mendefinisikan sebuah struct `Rectangle`"

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly brackets, we defined the fields as "
"`width` and `height`, both of which have type `u64`. Then, in `main`, we created a particular instance of "
"`Rectangle` that has a width of `30` and a height of `10`. Our `area` function is now defined with one "
"parameter, which we’ve named `rectangle` which is of type `Rectangle` struct. We can then access the fields of "
"the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index "
"values of `0` and `1`."
msgstr ""
"Di sini kita telah mendefinisikan sebuah struct dan memberinya nama `Rectangle`. Di dalam kurung kurawal, kita "
"mendefinisikan field-field sebagai `width` dan `height`, yang keduanya memiliki tipe `u64`. Kemudian, di `main`, "
"kita membuat sebuah instance khusus dari `Rectangle` yang memiliki lebar `30` dan tinggi `10`. Fungsi `area` "
"kita sekarang didefinisikan dengan satu parameter, yang kita beri nama `rectangle` yang bertipe struct "
"`Rectangle`. Kita dapat mengakses field-field dari instance tersebut dengan notasi titik, dan memberikan nama-"
"nama yang deskriptif pada nilai-nilai tersebut daripada menggunakan nilai indeks tuple `0` dan `1`."

#: src/ch05-02-an-example-program-using-structs.md:99
msgid "Adding Useful Functionality with Trait"
msgstr "Menambahkan Fungsionalitas yang Berguna dengan Trait"

#: src/ch05-02-an-example-program-using-structs.md:101
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re debugging our program and see the "
"values for all its fields. Listing 5-9 tries using the `print` as we have used in previous chapters. This won’t "
"work."
msgstr ""
"Akan berguna jika kita dapat mencetak sebuah instance dari `Rectangle` saat kita melakukan debugging pada "
"program kita dan melihat nilai-nilai untuk semua fieldnya. Listing 5-9 mencoba menggunakan `print` seperti yang "
"telah kita gunakan pada bab-bab sebelumnya. Ini tidak akan berhasil."

#: src/ch05-02-an-example-program-using-structs.md:119
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr "Listing 5-9: Mencoba untuk mencetak sebuah instance `Rectangle`"

#: src/ch05-02-an-example-program-using-structs.md:121
msgid "When we compile this code, we get an error with this message:"
msgstr "Ketika kita mengompilasi kode ini, kita mendapatkan sebuah pesan error dengan pesan ini:"

#: src/ch05-02-an-example-program-using-structs.md:123
msgid ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:133
msgid ""
"The `print` trait is implemented for many data types, but not for the `Rectangle` struct. We can fix this by "
"implementing the `PrintTrait` trait on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""
"Trait `print` diimplementasikan untuk banyak tipe data, tetapi tidak untuk struct `Rectangle`. Kita dapat "
"memperbaiki hal ini dengan mengimplementasikan trait `PrintTrait` pada `Rectangle` seperti yang ditunjukkan "
"dalam Listing 5-10. Untuk mempelajari lebih lanjut tentang traits, lihat [Traits in Cairo](ch08-02-traits-in-"
"cairo.md)."

#: src/ch05-02-an-example-program-using-structs.md:161
msgid "Listing 5-10: Implementing the `PrintTrait` trait on `Rectangle`"
msgstr "Listing 5-10: Mengimplementasikan trait `PrintTrait` pada `Rectangle`"

#: src/ch05-02-an-example-program-using-structs.md:163
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the fields for this instance, which would "
"definitely help during debugging."
msgstr ""
"Bagus! Ini bukan tampilan yang paling bagus, tetapi ini menampilkan nilai dari semua field untuk instance ini, "
"yang pasti akan membantu selama proses debugging."

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters "
"and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first parameter is always `self`, which "
"represents the instance of the type the method is being called on. For those familiar with Rust, Cairo's "
"approach might be confusing, as methods cannot be defined directly on types. Instead, you must define a trait "
"and an implementation associated with the type for which the method is intended."
msgstr ""
"_Metode_ mirip dengan fungsi: kita mendeklarasikannya dengan kata kunci `fn` dan sebuah nama, mereka dapat "
"memiliki parameter dan nilai pengembalian, dan mereka berisi beberapa kode yang dijalankan ketika metode "
"tersebut dipanggil dari suatu tempat lain. Berbeda dengan fungsi, metode didefinisikan dalam konteks dari suatu "
"tipe dan parameter pertamanya selalu `self`, yang mewakili instance dari tipe yang metode itu dipanggil. Bagi "
"yang akrab dengan Rust, pendekatan Cairo mungkin membingungkan, karena metode tidak dapat didefinisikan secara "
"langsung pada tipe-tipe. Sebagai gantinya, Anda harus mendefinisikan sebuah trait dan implementasi yang terkait "
"dengan tipe yang dituju untuk metode tersebut."

#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr "Mendefinisikan Metode"

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a parameter and instead make an `area` "
"method defined on the `RectangleTrait` trait, as shown in Listing 5-13."
msgstr ""
"Mari ubah fungsi `area` yang memiliki sebuah instance `Rectangle` sebagai parameter dan alihkan menjadi sebuah "
"metode `area` yang didefinisikan pada trait `RectangleTrait`, seperti yang ditunjukkan dalam Listing 5-13."

#: src/ch05-03-method-syntax.md:45
msgid "Listing 5-13: Defining an `area` method to use on the `Rectangle` "
msgstr "Listing 5-13: Mendefinisikan metode `area` yang digunakan pada `Rectangle` "

#: src/ch05-03-method-syntax.md:48
msgid ""
"To define the function within the context of `Rectangle`, we start by defining a `trait` block with the "
"signature of the method that we want to implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we define an `impl` (implementation) block "
"for `RectangleTrait`, that defines the behavior of the methods implemented. Everything within this `impl` block "
"will be associated with the type of the `self` parameter of the method called. While it is technically possible "
"to define methods for multiple types within the same `impl` block, it is not a recommended practice, as it can "
"lead to confusion. We recommend that the type of the `self` parameter stays consistent within the same `impl` "
"block. Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, "
"only) parameter to be `self` in the signature and everywhere within the body. In `main`, where we called the "
"`area` function and passed `rect1` as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an instance: we add a dot followed by the "
"method name, parentheses, and any arguments."
msgstr ""
"Untuk mendefinisikan fungsi dalam konteks `Rectangle`, kita mulai dengan mendefinisikan blok `trait` dengan "
"tanda tangan dari metode yang ingin kita implementasikan. Traits tidak terikat pada tipe tertentu; hanya "
"parameter `self` dari metode yang mendefinisikan tipe mana yang dapat digunakan. Kemudian, kita mendefinisikan "
"blok `impl` (implementasi) untuk `RectangleTrait`, yang mendefinisikan perilaku dari metode-metode yang "
"diimplementasikan. Segala sesuatu dalam blok `impl` ini akan terkait dengan tipe dari parameter `self` dari "
"metode yang dipanggil. Meskipun secara teknis mungkin untuk mendefinisikan metode untuk beberapa tipe dalam blok "
"`impl` yang sama, ini bukan praktik yang direkomendasikan, karena dapat menyebabkan kebingungan. Kami "
"menyarankan agar tipe parameter `self` tetap konsisten dalam blok `impl` yang sama. Kemudian, kita memindahkan "
"fungsi `area` ke dalam kurung kurawal `impl` dan mengubah parameter pertama (dan dalam kasus ini, satu-satunya) "
"menjadi `self` dalam tanda tangan dan di semua bagian dalam tubuh fungsi. Di `main`, di mana kita memanggil "
"fungsi `area` dan melewati `rect1` sebagai argumen, kita sebaliknya dapat menggunakan _method syntax_ untuk "
"memanggil metode `area` pada instance `Rectangle` kita. _Method syntax_ diletakkan setelah sebuah instance: kita "
"tambahkan titik yang diikuti dengan nama metode, tanda kurung, dan argumen-argumen apapun."

#: src/ch05-03-method-syntax.md:64
msgid ""
"Methods must have a parameter named `self` of the type they will be applied to for their first parameter. Note "
"that we used the `@` snapshot operator in front of the `Rectangle` type in the function signature. By doing so, "
"we indicate that this method takes an immutable snapshot of the `Rectangle` instance, which is automatically "
"created by the compiler when passing the instance to the method. Methods can take ownership of `self`, use "
"`self` with snapshots as we’ve done here, or use a mutable reference to `self` using the `ref self: T` syntax."
msgstr ""
"Metode harus memiliki parameter bernama `self` dengan tipe yang akan diterapkan pada parameter pertamanya. "
"Perhatikan bahwa kita menggunakan operator snapshot `@` di depan tipe `Rectangle` dalam tanda tangan fungsi. "
"Dengan melakukannya, kita menunjukkan bahwa metode ini mengambil snapshot yang tidak dapat diubah dari instance "
"`Rectangle`, yang secara otomatis dibuat oleh kompiler saat melewati instance ke metode. Metode dapat memiliki "
"kepemilikan dari `self`, menggunakan `self` dengan snapshot seperti yang kita lakukan di sini, atau menggunakan "
"referensi mutable ke `self` dengan menggunakan sintaks `ref self: T`."

#: src/ch05-03-method-syntax.md:71
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in the function version: we don’t want "
"to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, we’d use `ref self: Rectangle` as the "
"first parameter. Having a method that takes ownership of the instance by using just `self` as the first "
"parameter is rare; this technique is usually used when the method transforms `self` into something else and you "
"want to prevent the caller from using the original instance after the transformation."
msgstr ""
"Kami memilih `self: @Rectangle` di sini dengan alasan yang sama dengan penggunaan `@Rectangle` pada versi "
"fungsi: kami tidak ingin memiliki kepemilikan, dan kami hanya ingin membaca data dalam struct, bukan menulis ke "
"dalamnya. Jika kami ingin mengubah instance yang kami panggil metode tersebut sebagai bagian dari apa yang "
"dilakukan metode, kami akan menggunakan `ref self: Rectangle` sebagai parameter pertama. Memiliki sebuah metode "
"yang memiliki kepemilikan dari instance dengan hanya menggunakan `self` sebagai parameter pertama adalah hal "
"yang jarang; teknik ini biasanya digunakan ketika metode mentransformasi `self` menjadi sesuatu yang lain dan "
"Anda ingin mencegah pemanggil untuk menggunakan instance asli setelah transformasi."

#: src/ch05-03-method-syntax.md:80
msgid ""
"Observe the use of the desnap operator `*` within the area method when accessing the struct's members. This is "
"necessary because the struct is passed as a snapshot, and all of its field values are of type `@T`, requiring "
"them to be desnapped in order to manipulate them."
msgstr ""
"Perhatikan penggunaan operator desnap `*` dalam metode area ketika mengakses member dari struct. Hal ini "
"diperlukan karena struct tersebut dilewati sebagai snapshot, dan semua nilai fieldnya memiliki tipe `@T`, yang "
"memerlukan desnap untuk memanipulasinya."

#: src/ch05-03-method-syntax.md:84
msgid ""
"The main reason for using methods instead of functions is for organization and code clarity. We’ve put all the "
"things we can do with an instance of a type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various places in the library we provide. "
"However, we can define multiple combinations of `trait` & `impl` blocks for the same type at different places, "
"which can be useful for a more granular code organization. For example, you could implement the `Add` trait for "
"your type in one `impl` block, and the `Sub` trait in another block."
msgstr ""
"Alasan utama penggunaan metode daripada fungsi adalah untuk organisasi dan kejelasan kode. Kita telah menyatukan "
"semua hal yang dapat kita lakukan dengan sebuah instance dari suatu tipe dalam satu kombinasi blok `trait` & "
"`impl`, daripada membuat pengguna kode kita mencari kemampuan dari `Rectangle` di berbagai tempat dalam "
"perpustakaan yang kita sediakan. Namun, kita dapat mendefinisikan beberapa kombinasi blok `trait` & `impl` untuk "
"tipe yang sama di tempat-tempat yang berbeda, yang dapat berguna untuk organisasi kode yang lebih terperinci. "
"Sebagai contoh, Anda bisa mengimplementasikan `Add` trait untuk tipe Anda dalam satu blok `impl`, dan `Sub` "
"trait di blok lainnya."

#: src/ch05-03-method-syntax.md:89
msgid ""
"Note that we can choose to give a method the same name as one of the struct’s fields. For example, we can define "
"a method on `Rectangle` that is also named `width`:"
msgstr ""
"Perhatikan bahwa kita dapat memilih untuk memberikan sebuah metode nama yang sama dengan salah satu field dari "
"struct. Sebagai contoh, kita dapat mendefinisikan sebuah metode pada `Rectangle` yang juga bernama `width`:"

#: src/ch05-03-method-syntax.md:119
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value in the instance’s `width` field is "
"greater than `0` and `false` if the value is `0`: we can use a field within a method of the same name for any "
"purpose. In `main`, when we follow `rect1.width` with parentheses, Cairo knows we mean the method `width`. When "
"we don’t use parentheses, Cairo knows we mean the field `width`."
msgstr ""
"Di sini, kita memilih untuk membuat metode `width` mengembalikan `true` jika nilai dalam field `width` dari "
"instance lebih besar dari `0` dan `false` jika nilai adalah `0`: kita dapat menggunakan field dalam sebuah "
"metode yang memiliki nama yang sama untuk tujuan apapun. Di `main`, ketika kita mengikuti `rect1.width` dengan "
"tanda kurung, Cairo tahu bahwa kita mengacu pada metode `width`. Ketika kita tidak menggunakan tanda kurung, "
"Cairo tahu bahwa kita mengacu pada field `width`."

#: src/ch05-03-method-syntax.md:126
msgid "Methods with More Parameters"
msgstr "Metode dengan Parameter Lebih Banyak"

#: src/ch05-03-method-syntax.md:128
msgid ""
"Let’s practice using methods by implementing a second method on the `Rectangle` struct. This time we want an "
"instance of `Rectangle` to take another instance of `Rectangle` and return `true` if the second `Rectangle` can "
"fit completely within `self` (the first `Rectangle`); otherwise, it should return `false`. That is, once we’ve "
"defined the `can_hold` method, we want to be able to write the program shown in Listing 5-14."
msgstr ""
"Mari latihan menggunakan metode dengan mengimplementasikan metode kedua pada struct `Rectangle`. Kali ini, kita "
"ingin sebuah instance dari `Rectangle` untuk mengambil instance lain dari `Rectangle` dan mengembalikan `true` "
"jika `Rectangle` kedua dapat sepenuhnya muat di dalam `self` (Rectangle pertama); jika tidak, maka seharusnya "
"mengembalikan `false`. Artinya, setelah kita mendefinisikan metode `can_hold`, kita ingin dapat menulis program "
"seperti yang ditunjukkan dalam Listing 5-14."

#: src/ch05-03-method-syntax.md:158
msgid "Listing 5-14: Using the as-yet-unwritten `can_hold` method"
msgstr "Listing 5-14: Menggunakan metode `can_hold` yang belum ditulis"

#: src/ch05-03-method-syntax.md:161
msgid ""
"The expected output would look like the following because both dimensions of `rect2` are smaller than the "
"dimensions of `rect1`, but `rect3` is wider than `rect1`:"
msgstr ""
"Output yang diharapkan akan terlihat seperti berikut karena kedua dimensi `rect2` lebih kecil daripada dimensi "
"`rect1`, tetapi `rect3` lebih lebar daripada `rect1`:"

#: src/ch05-03-method-syntax.md:177
msgid ""
"We know we want to define a method, so it will be within the `trait RectangleTrait` and `impl RectangleImpl of "
"RectangleTrait` blocks. The method name will be `can_hold`, and it will take a snapshot of another `Rectangle` "
"as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: "
"`rect1.can_hold(@rect2)` passes in `@rect2`, which is a snapshot to `rect2`, an instance of `Rectangle`. This "
"makes sense because we only need to read `rect2` (rather than write, which would mean we’d need a mutable "
"borrow), and we want `main` to retain ownership of `rect2` so we can use it again after calling the `can_hold` "
"method. The return value of `can_hold` will be a Boolean, and the implementation will check whether the width "
"and height of `self` are greater than the width and height of the other `Rectangle`, respectively. Let’s add the "
"new `can_hold` method to the `trait` and `impl` blocks from Listing 5-13, shown in Listing 5-15."
msgstr ""
"Kita tahu kita ingin mendefinisikan sebuah metode, jadi metode tersebut akan berada dalam blok `trait "
"RectangleTrait` dan `impl RectangleImpl of RectangleTrait`. Nama metode tersebut akan menjadi `can_hold`, dan "
"itu akan mengambil gambaran dari `Rectangle` lain sebagai parameter. Kita dapat mengetahui tipe data parameter "
"tersebut dengan melihat kode yang memanggil metode: `rect1.can_hold(@rect2)` mengirimkan `@rect2`, yang "
"merupakan gambaran dari `rect2`, suatu instansi dari `Rectangle`. Ini masuk akal karena kita hanya perlu membaca "
"`rect2` (bukan menulis, yang berarti kita memerlukan pinjaman yang dapat diubah), dan kita ingin agar `main` "
"tetap memiliki kepemilikan dari `rect2` sehingga kita dapat menggunakannya lagi setelah memanggil metode "
"`can_hold`. Nilai kembalian dari `can_hold` akan berupa Boolean, dan implementasinya akan memeriksa apakah lebar "
"dan tinggi dari `self` lebih besar dari lebar dan tinggi dari `Rectangle` lain tersebut, masing-masing. Mari "
"tambahkan metode `can_hold` baru ke blok `trait` dan `impl` dari Listing 5-13, seperti yang ditunjukkan dalam "
"Listing 5-15."

#: src/ch05-03-method-syntax.md:211
msgid ""
"Listing 5-15: Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a "
"parameter"
msgstr ""
"Listing 5-15: Implementasi metode `can_hold` pada `Rectangle` yang mengambil instansi `Rectangle` lain sebagai "
"parameter"

#: src/ch05-03-method-syntax.md:214
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get our desired output. Methods can take "
"multiple parameters that we add to the signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""
"Ketika kita menjalankan kode ini dengan fungsi `main` pada Listing 5-14, kita akan mendapatkan output yang "
"diinginkan. Metode dapat mengambil beberapa parameter yang kita tambahkan ke dalam tanda tangan setelah "
"parameter `self`, dan parameter-parameter tersebut berfungsi seperti parameter dalam fungsi."

#: src/ch05-03-method-syntax.md:219
msgid "Accessing implementation functions"
msgstr "Mengakses Fungsi Implementasi"

#: src/ch05-03-method-syntax.md:221
msgid ""
"All functions defined within a `trait` and `impl` block can be directly addressed using the `::` operator on the "
"implementation name. Functions in traits that aren’t methods are often used for constructors that will return a "
"new instance of the struct. These are often called `new`, but `new` isn’t a special name and isn’t built into "
"the language. For example, we could choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it easier to create a square `Rectangle` "
"rather than having to specify the same value twice:"
msgstr ""
"Semua fungsi yang didefinisikan dalam blok `trait` dan `impl` dapat diakses secara langsung menggunakan operator "
"`::` pada nama implementasi. Fungsi dalam trait yang bukan metode sering digunakan untuk konstruktor yang akan "
"mengembalikan instansi baru dari struktur tersebut. Mereka sering disebut sebagai `new`, tetapi `new` bukanlah "
"nama khusus dan bukan bagian dari bahasa. Sebagai contoh, kita bisa memilih untuk menyediakan fungsi terkait "
"bernama `square` yang akan memiliki satu parameter dimensi dan menggunakan itu sebagai lebar dan tinggi, "
"sehingga memudahkan untuk membuat `Rectangle` yang berbentuk persegi daripada harus menentukan nilai yang sama "
"dua kali:"

#: src/ch05-03-method-syntax.md:245
msgid ""
"To call this function, we use the `::` syntax with the implementation name; `let square = RectangleImpl::"
"square(10);` is an example. This function is namespaced by the implementation; the `::` syntax is used for both "
"trait functions and namespaces created by modules. We’ll discuss modules in \\[Chapter 8\\]\\[modules\\]"
msgstr ""
"Untuk memanggil fungsi ini, kita menggunakan sintaks `::` dengan nama implementasi; `let square = RectangleImpl::"
"square(10);` adalah contohnya. Fungsi ini berada di dalam ruang nama implementasi; sintaks `::` digunakan untuk "
"fungsi-fungsi trait maupun ruang nama yang dibuat oleh modul. Kita akan membahas modul di \\[Chapter "
"8\\]\\[modules\\]."

#: src/ch05-03-method-syntax.md:248 src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr ""

#: src/ch05-03-method-syntax.md:250
msgid "Note: It is also possible to call this function using the trait name, with `RectangleTrait::square(10)`."
msgstr ""
"Catatan: Juga memungkinkan untuk memanggil fungsi ini menggunakan nama trait, dengan `RectangleTrait::"
"square(10)`."

#: src/ch05-03-method-syntax.md:252
msgid "Multiple `impl` Blocks"
msgstr "Blok `impl` Multipel"

#: src/ch05-03-method-syntax.md:254
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For example, Listing 5-15 is equivalent to "
"the code shown in Listing 5-16, which has each method in its own `trait` and `impl` blocks."
msgstr ""
"Setiap struktur diizinkan memiliki beberapa blok `trait` dan `impl`. Sebagai contoh, Listing 5-15 setara dengan "
"kode yang ditunjukkan dalam Listing 5-16, yang memiliki setiap metode dalam blok `trait` dan `impl` tersendiri."

#: src/ch05-03-method-syntax.md:279
msgid "Listing 5-16: Rewriting Listing 5-15 using multiple `impl` blocks"
msgstr "Listing 5-16: Menuliskan ulang Listing 5-15 menggunakan beberapa blok `impl`"

#: src/ch05-03-method-syntax.md:282
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` blocks here, but this is valid "
"syntax. We’ll see a case in which multiple blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits."
"md), where we discuss generic types and traits."
msgstr ""
"Tidak ada alasan untuk memisahkan metode-metode ini ke dalam beberapa blok `trait` dan `impl` di sini, tetapi "
"ini adalah sintaks yang valid. Kita akan melihat kasus di mana beberapa blok berguna dalam [Chapter 8](ch08-00-"
"generic-types-and-traits.md), di mana kita membahas jenis dan trait generik."

#: src/ch05-03-method-syntax.md:288
msgid ""
"Structs let you create custom types that are meaningful for your domain. By using structs, you can keep "
"associated pieces of data connected to each other and name each piece to make your code clear. In `trait` and "
"`impl` blocks, you can define methods, which are functions associated to a type and let you specify the behavior "
"that instances of your type have."
msgstr ""
"Struct memungkinkan Anda membuat jenis kustom yang memiliki makna untuk domain Anda. Dengan menggunakan struct, "
"Anda dapat menjaga agar bagian-bagian data terkait tetap terhubung satu sama lain dan memberikan nama pada "
"setiap bagian untuk menjadikan kode Anda lebih jelas. Dalam blok `trait` dan `impl`, Anda dapat mendefinisikan "
"metode, yang merupakan fungsi yang terkait dengan suatu tipe dan memungkinkan Anda menentukan perilaku yang "
"dimiliki instansi dari tipe Anda."

#: src/ch05-03-method-syntax.md:294
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to Cairo’s enum feature to add another "
"tool to your toolbox."
msgstr ""
"Namun, struct bukan satu-satunya cara untuk membuat tipe kustom: mari beralih ke fitur enum Cairo untuk "
"menambahkan alat lain ke dalam kotak alat Anda."

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. Enums allow you to define a type by "
"enumerating its possible _variants_. First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called `Option`, which expresses that a value "
"can be either something or nothing. Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"Dalam bab ini, kita akan melihat _enumerations_, juga disebut _enums_. Enums memungkinkan Anda mendefinisikan "
"tipe dengan menghitung _variants_ yang mungkin. Pertama, kita akan mendefinisikan dan menggunakan sebuah enum "
"untuk menunjukkan bagaimana enum dapat mengkodekan makna bersama dengan data. Selanjutnya, kita akan menjelajahi "
"enum yang sangat berguna, yang disebut `Option`, yang menyatakan bahwa suatu nilai dapat menjadi sesuatu atau "
"tidak. Akhirnya, kita akan melihat bagaimana pola pencocokan dalam ekspresi `match` membuatnya mudah untuk "
"menjalankan kode yang berbeda untuk nilai-nilai enum yang berbeda."

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type that consists of a fixed set of named "
"values, called _variants_. Enums are useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Enum, singkatan dari \"enumerations,\" adalah cara untuk mendefinisikan tipe data kustom yang terdiri dari set "
"tetap dari nilai-nilai yang diberi nama, disebut _variants_. Enum berguna untuk merepresentasikan kumpulan nilai "
"terkait di mana setiap nilai bersifat berbeda dan memiliki makna tertentu."

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "Enum Variants dan Values"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "Berikut adalah contoh sederhana dari sebuah enum:"

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and "
"`West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any associated value. One variant can be "
"instantiated using this syntax:"
msgstr ""
"Pada contoh ini, kita telah mendefinisikan sebuah enum yang disebut `Direction` dengan empat varian: `North`, "
"`East`, `South`, dan `West`. Konvensi penamaan adalah menggunakan PascalCase untuk varian enum. Setiap varian "
"mewakili nilai yang berbeda dari tipe Direction. Pada contoh ini, varian tidak memiliki nilai terkait. Satu "
"varian dapat diinstansiasi menggunakan sintaks ini:"

#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an enum instance, in this example to "
"run specific code according to a Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""
"Mudah untuk menulis kode yang berbeda tergantung pada varian dari sebuah instansi enum, seperti pada contoh ini "
"untuk menjalankan kode tertentu sesuai dengan suatu Arah. Anda dapat mempelajari lebih lanjut tentang hal ini di "
"halaman [Konstruksi Alur Kontrol Match](ch06-02-the-match-control-flow-construct.md)."

#: src/ch06-01-enums.md:39
msgid "Enums Combined with Custom Types"
msgstr "Enums Kombinasi dengan Tipe Kustom"

#: src/ch06-01-enums.md:41
msgid "Enums can also be used to store more interesting data associated with each variant. For example:"
msgstr ""
"Enum juga dapat digunakan untuk menyimpan data yang lebih menarik yang terkait dengan setiap varian. Sebagai "
"contoh:"

#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and `Move`, all with different types:"
msgstr ""
"Pada contoh ini, enum `Message` memiliki tiga varian: `Quit`, `Echo`, dan `Move`, masing-masing dengan tipe yang "
"berbeda:"

#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr "`Quit` tidak memiliki nilai terkait."

#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr "`Echo` adalah satu felt."

#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr "`Move` adalah tuple dari dua nilai u128."

#: src/ch06-01-enums.md:58
msgid "You could even use a Struct or another Enum you defined inside one of your Enum variants."
msgstr ""
"Anda bahkan dapat menggunakan Struct atau Enum lain yang Anda tentukan di dalam salah satu varian Enum Anda."

#: src/ch06-01-enums.md:60
msgid "Trait Implementations for Enums"
msgstr "Implementasi Trait untuk Enums"

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and "
"behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"Di Cairo, Anda dapat mendefinisikan trait dan mengimplementasikannya untuk enum kustom Anda. Ini memungkinkan "
"Anda mendefinisikan metode dan perilaku yang terkait dengan enum tersebut. Berikut adalah contoh mendefinisikan "
"trait dan mengimplementasikannya untuk enum `Message` sebelumnya:"

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a "
"Quit message:"
msgstr ""
"Pada contoh ini, kita mengimplementasikan trait `Processing` untuk `Message`. Berikut adalah cara penggunaannya "
"untuk memproses pesan Quit:"

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr "Menjalankan kode ini akan mencetak `quitting`."

#: src/ch06-01-enums.md:114
msgid "The Option Enum and Its Advantages"
msgstr "Enum Option dan Keuntungannya"

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: "
"`Some: T` and `None: ()`. `Some: T ` indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"Enum Option adalah enum standar dalam Cairo yang mewakili konsep nilai opsional. Ini memiliki dua varian: `Some: "
"T` dan `None: ()`. `Some: T` menunjukkan bahwa ada nilai dengan tipe `T`, sementara `None` mewakili ketiadaan "
"nilai."

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent the possibility of a value being "
"absent, making your code more expressive and easier to reason about. Using `Option` can also help prevent bugs "
"caused by using uninitialized or unexpected `null` values."
msgstr ""
"Enum `Option` berguna karena memungkinkan Anda secara eksplisit mewakili kemungkinan nilai yang tidak ada, "
"membuat kode Anda lebih ekspresif dan lebih mudah untuk dipahami. Penggunaan `Option` juga dapat membantu "
"mencegah bug yang disebabkan oleh penggunaan nilai `null` yang tidak diinisialisasi atau tidak terduga."

#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the first element of an array with a given "
"value, or None if the element is not present."
msgstr ""
"Sebagai contoh, berikut adalah sebuah fungsi yang mengembalikan indeks dari elemen pertama dalam sebuah array "
"dengan nilai tertentu, atau None jika elemen tidak ada."

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr "Kami sedang mendemonstrasikan dua pendekatan untuk fungsi di atas:"

#: src/ch06-01-enums.md:131
msgid "Recursive Approach `find_value_recursive`"
msgstr "Pendekatan Rekursif `find_value_recursive`"

#: src/ch06-01-enums.md:132
msgid "Iterative Approach `find_value_iterative`"
msgstr "Pendekatan Iteratif `find_value_iterative`"

#: src/ch06-01-enums.md:134
msgid ""
"Note: in the future it would be nice to replace this example by something simpler using a loop and without gas "
"related code."
msgstr ""
"Catatan: di masa mendatang, akan bagus untuk menggantikan contoh ini dengan sesuatu yang lebih sederhana "
"menggunakan perulangan dan tanpa kode terkait gas."

#: src/ch06-01-enums.md:202
msgid "Running this code would print `it worked`."
msgstr "Menjalankan kode ini akan mencetak `it worked`."

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that allows you to compare a value against "
"a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of match comes from the expressiveness of "
"the patterns and the fact that the compiler confirms that all possible cases are handled."
msgstr ""
"Cairo memiliki konstruksi alur kontrol yang sangat kuat yang disebut `match` yang memungkinkan Anda "
"membandingkan nilai terhadap serangkaian pola dan kemudian menjalankan kode berdasarkan pola mana yang cocok. "
"Pola dapat terdiri dari nilai literal, nama variabel, wildcard, dan banyak hal lainnya. Keunggulan dari `match` "
"berasal dari ekspresivitas pola dan fakta bahwa kompiler memastikan bahwa semua kasus mungkin ditangani."

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized "
"holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the value “fits”, the value falls into the "
"associated code block to be used during execution."
msgstr ""
"Bayangkan ekspresi match seperti mesin penyortiran koin: koin meluncur turun melalui jalur dengan lubang-lubang "
"berbagai ukuran, dan setiap koin jatuh melalui lubang pertama yang ditemuinya yang sesuai. Dengan cara yang "
"sama, nilai melewati setiap pola dalam match, dan pada pola pertama di mana nilai \"cocok\", nilai tersebut "
"jatuh ke dalam blok kode yang terkait untuk digunakan selama eksekusi."

#: src/ch06-02-the-match-control-flow-construct.md:9
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a function that takes an unknown US "
"coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, "
"as shown in Listing 6-3."
msgstr ""
"Berbicara tentang koin, mari gunakan mereka sebagai contoh dengan menggunakan match! Kita dapat menulis sebuah "
"fungsi yang mengambil sebuah koin AS yang tidak diketahui dan, dengan cara yang mirip dengan mesin penghitung, "
"menentukan jenis koinnya dan mengembalikan nilainya dalam sen, seperti yang ditunjukkan pada Listing 6-3."

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid "Listing 6-3: An enum and a match expression that has the variants of the enum as its patterns"
msgstr "Listing 6-3: Sebuah enum dan ekspresi match yang memiliki varian-varian enum sebagai polanya"

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list the `match` keyword followed by an "
"expression, which in this case is the value `coin`. This seems very similar to a conditional expression used "
"with if, but there’s a big difference: with if, the condition needs to evaluate to a Boolean value, but here it "
"can be any type. The type of coin in this example is the `Coin` enum that we defined on the first line."
msgstr ""
"Mari kita bahas `match` dalam fungsi `value_in_cents`. Pertama-tama, kita daftarkan kata kunci `match` diikuti "
"oleh suatu ekspresi, yang dalam hal ini adalah nilai `coin`. Ini tampak sangat mirip dengan ekspresi kondisional "
"yang digunakan dengan if, tetapi ada perbedaan besar: dengan if, kondisi harus dievaluasi menjadi nilai Boolean, "
"tetapi di sini itu bisa menjadi tipe apa pun. Tipe dari koin dalam contoh ini adalah enum `Coin` yang kita "
"tentukan pada baris pertama."

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that "
"is the value `Coin::Penny(_)` and then the `=>` operator that separates the pattern and the code to run. The "
"code in this case is just the value `1`. Each arm is separated from the next with a comma."
msgstr ""
"Selanjutnya adalah lengan-lengan `match`. Sebuah lengan memiliki dua bagian: sebuah pola dan beberapa kode. "
"Lengan pertama di sini memiliki pola yang merupakan nilai `Coin::Penny(_)` dan kemudian operator `=>` yang "
"memisahkan pola dan kode yang akan dijalankan. Kode dalam hal ini hanya nilai `1`. Setiap lengan dipisahkan dari "
"yang berikutnya dengan koma."

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value against the pattern of each arm, in order. "
"If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match "
"the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as "
"we need: in the above example, our match has four arms."
msgstr ""
"Ketika ekspresi `match` dieksekusi, itu membandingkan nilai hasilnya dengan pola dari setiap lengan, secara "
"berurutan. Jika suatu pola cocok dengan nilai, kode yang terkait dengan pola tersebut dieksekusi. Jika pola "
"tersebut tidak cocok dengan nilai, eksekusi dilanjutkan ke lengan berikutnya, mirip dengan mesin penyortiran "
"koin. Kita dapat memiliki sebanyak yang kita butuhkan: pada contoh di atas, match kita memiliki empat lengan."

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr "Dalam Cairo, urutan lengan harus mengikuti urutan yang sama dengan enum."

#: src/ch06-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value of the expression in the matching "
"arm is the value that gets returned for the entire match expression."
msgstr ""
"Kode yang terkait dengan setiap lengan adalah suatu ekspresi, dan nilai hasil dari ekspresi di lengan yang cocok "
"adalah nilai yang dikembalikan untuk seluruh ekspresi match."

#: src/ch06-02-the-match-control-flow-construct.md:41
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it is in our example where each arm "
"just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, "
"with a comma following the arm. For example, the following code prints “Lucky penny!” every time the method is "
"called with a `Coin::Penny`, but still returns the last value of the block, `1`:"
msgstr ""
"Biasanya kita tidak menggunakan kurung kurawal jika kode lengan match pendek, seperti pada contoh kita di mana "
"setiap lengan hanya mengembalikan suatu nilai. Jika Anda ingin menjalankan beberapa baris kode dalam lengan "
"match, Anda harus menggunakan kurung kurawal, dengan koma mengikuti lengan. Sebagai contoh, kode berikut "
"mencetak \"Lucky penny!\" setiap kali metode dipanggil dengan `Coin::Penny`, tetapi tetap mengembalikan nilai "
"terakhir dari blok, `1`:"

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid "Patterns That Bind to Values"
msgstr "Pola yang Terikat pada Nilai"

#: src/ch06-02-the-match-control-flow-construct.md:59
msgid ""
"Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. "
"This is how we can extract values out of enum variants."
msgstr ""
"Fitur lain yang berguna dari lengan match adalah bahwa mereka dapat terikat pada bagian-bagian dari nilai yang "
"cocok dengan pola. Inilah cara kita dapat mengekstrak nilai dari varian enum."

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United "
"States minted quarters with different designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information to our `enum` by changing the "
"`Quarter` variant to include a `UsState` value stored inside it, which we’ve done in Listing 6-4."
msgstr ""
"Sebagai contoh, mari ubah salah satu varian enum kita untuk menyimpan data di dalamnya. Dari tahun 1999 hingga "
"2008, Amerika Serikat mencetak koin seperempat dolar dengan desain yang berbeda untuk setiap dari 50 negara "
"bagian di satu sisi. Tidak ada koin lain yang mendapatkan desain negara bagian, sehingga hanya koin seperempat "
"dolar yang memiliki nilai tambahan ini. Kita dapat menambahkan informasi ini ke enum kita dengan mengubah varian "
"`Quarter` untuk menyertakan nilai `UsState` yang disimpan di dalamnya, seperti yang kita lakukan pada Listing "
"6-4."

#: src/ch06-02-the-match-control-flow-construct.md:79
msgid "Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a `UsState` value"
msgstr "Listing 6-4: Sebuah enum `Coin` di mana varian `Quarter` juga menyimpan nilai `UsState`"

#: src/ch06-02-the-match-control-flow-construct.md:81
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin "
"type, we’ll also call out the name of the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"Mari bayangkan bahwa seorang teman mencoba mengumpulkan semua 50 koin seperempat dolar dari setiap negara "
"bagian. Saat kita menyortir koin receh berdasarkan jenis koin, kita juga akan menyebutkan nama negara bagian "
"yang terkait dengan setiap koin seperempat dolar, sehingga jika itu adalah salah satu yang belum dimiliki oleh "
"teman kita, mereka dapat menambahkannya ke koleksinya."

#: src/ch06-02-the-match-control-flow-construct.md:83
msgid ""
"In the match expression for this code, we add a variable called `state` to the pattern that matches values of "
"the variant `Coin::Quarter`. When a `Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"Dalam ekspresi match untuk kode ini, kita menambahkan variabel yang disebut `state` ke dalam pola yang cocok "
"dengan nilai dari varian `Coin::Quarter`. Ketika `Coin::Quarter` cocok, variabel `state` akan terikat pada nilai "
"negara bagian koin tersebut. Kemudian kita dapat menggunakan `state` dalam kode untuk lengan tersebut, seperti "
"berikut:"

#: src/ch06-02-the-match-control-flow-construct.md:99
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an implementation for the `print` function "
"for the `debug::PrintTrait`:"
msgstr ""
"Untuk mencetak nilai dari suatu varian enum di Cairo, kita perlu menambahkan implementasi untuk fungsi `print` "
"pada `debug::PrintTrait`:"

#: src/ch06-02-the-match-control-flow-construct.md:112
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` would be `Coin::Quarter(UsState::"
"Alaska)`. When we compare that value with each of the match arms, none of them match until we reach `Coin::"
"Quarter(state)`. At that point, the binding for state will be the value `UsState::Alaska`. We can then use that "
"binding in the `PrintTrait`, thus getting the inner state value out of the `Coin` enum variant for `Quarter`."
msgstr ""
"Jika kita memanggil `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` akan menjadi `Coin::"
"Quarter(UsState::Alaska)`. Ketika kita membandingkan nilai tersebut dengan setiap lengan match, tidak ada yang "
"cocok sampai kita mencapai `Coin::Quarter(state)`. Pada titik tersebut, pengikatan untuk state akan menjadi "
"nilai `UsState::Alaska`. Kita kemudian dapat menggunakan pengikatan tersebut dalam `PrintTrait`, sehingga "
"mendapatkan nilai dalam varian enum `Coin` untuk `Quarter`."

#: src/ch06-02-the-match-control-flow-construct.md:114
msgid "Matching with Options"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:116
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the `Some` case when using `Option<T>`; we "
"can also handle `Option<T>` using `match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression works remains the same. You can use "
"Options by importing the `option::OptionTrait` trait."
msgstr ""
"Pada bagian sebelumnya, kita ingin mendapatkan nilai dalam `T` dari kasus `Some` saat menggunakan `Option<T>`; "
"kita juga dapat menangani `Option<T>` menggunakan `match`, seperti yang kita lakukan dengan enum `Coin`! Alih-"
"alih membandingkan koin, kita akan membandingkan variasi dari `Option<T>`, tetapi cara kerja ekspresi `match` "
"tetap sama. Anda dapat menggunakan Options dengan mengimpor trait `option::OptionTrait`."

#: src/ch06-02-the-match-control-flow-construct.md:118
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if there’s a value inside, adds `1` to "
"that value. If there isn’t a value inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""
"Mari kita tulis sebuah fungsi yang mengambil `Option<u8>` dan, jika ada nilai di dalamnya, menambahkan `1` ke "
"nilai tersebut. Jika tidak ada nilai di dalamnya, fungsi tersebut harus mengembalikan nilai `None` dan tidak "
"mencoba melakukan operasi apapun."

#: src/ch06-02-the-match-control-flow-construct.md:120
msgid "This function is very easy to write, thanks to match, and will look like Listing 6-5."
msgstr "Fungsi ini sangat mudah ditulis, berkat penggunaan match, dan akan terlihat seperti pada Listing 6-5."

#: src/ch06-02-the-match-control-flow-construct.md:141
msgid "Listing 6-5: A function that uses a match expression on an `Option<u8>`"
msgstr "Listing 6-5: Sebuah fungsi yang menggunakan ekspresi match pada `Option<u8>`"

#: src/ch06-02-the-match-control-flow-construct.md:144
msgid ""
"Note that your arms must respect the same order as the enum defined in the `OptionTrait` of the core Cairo lib."
msgstr ""
"Perlu diingat bahwa bagian-bagian (arms) Anda harus mengikuti urutan yang sama seperti enum yang didefinisikan "
"dalam `OptionTrait` dari pustaka inti Cairo."

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call `plus_one(five)`, the variable `x` "
"in the body of `plus_one` will have the value `Some(5)`. We then compare that against each match arm:"
msgstr ""
"Mari kita telaah secara lebih detail eksekusi pertama dari `plus_one`. Ketika kita memanggil `plus_one(five)`, "
"variabel `x` dalam tubuh `plus_one` akan memiliki nilai `Some(5)`. Kemudian kita membandingkannya dengan setiap "
"bagian dalam `match`:"

#: src/ch06-02-the-match-control-flow-construct.md:159
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! We have the same variant. The `val` "
"binds to the value contained in `Option::Some`, so `val` takes the value `5`. The code in the match arm is then "
"executed, so we add `1` to the value of `val` and create a new `Option::Some` value with our total `6` inside. "
"Because the first arm matched, no other arms are compared."
msgstr ""
"Apakah nilai `Option::Some(5)` cocok dengan pola `Option::Some(val)`? Ya, cocok! Kita memiliki varian yang sama. "
"`val` diikat ke nilai yang terkandung dalam `Option::Some`, sehingga `val` mengambil nilai `5`. Kode dalam "
"bagian match kemudian dieksekusi, sehingga kita menambahkan `1` ke nilai `val` dan membuat nilai `Option::Some` "
"baru dengan total `6` di dalamnya. Karena bagian pertama cocok, tidak ada bagian lain yang dibandingkan."

#: src/ch06-02-the-match-control-flow-construct.md:161
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where `x` is `Option::None`. We enter the "
"match and compare to the first arm:"
msgstr ""
"Sekarang mari kita pertimbangkan panggilan kedua dari `plus_one` dalam fungsi utama kita, di mana `x` adalah "
"`Option::None`. Kita masuk ke dalam match dan membandingkannya dengan bagian pertama:"

#: src/ch06-02-the-match-control-flow-construct.md:167
msgid "The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so we continue to the next arm:"
msgstr ""
"Nilai `Option::Some(val)` tidak cocok dengan pola `Option::None`, jadi kita lanjutkan ke bagian selanjutnya:"

#: src/ch06-02-the-match-control-flow-construct.md:173
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the `Option::None` value on the right "
"side of `=>`."
msgstr ""
"Cocok! Tidak ada nilai yang dapat ditambahkan, jadi program berhenti dan mengembalikan nilai `Option::None` pada "
"sisi kanan dari `=>`."

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this pattern a lot in Cairo code: `match` "
"against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at "
"first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite."
msgstr ""
"Kombinasi `match` dan enum berguna dalam banyak situasi. Anda akan sering melihat pola ini dalam kode Cairo: "
"`match` terhadap sebuah enum, mengikat variabel pada data di dalamnya, dan kemudian menjalankan kode berdasarkan "
"data tersebut. Awalnya mungkin sedikit membingungkan, tetapi setelah Anda terbiasa, Anda akan berharap memiliki "
"fitur ini dalam semua bahasa pemrograman. Ini secara konsisten menjadi favorit pengguna."

#: src/ch06-02-the-match-control-flow-construct.md:177
msgid "Matches Are Exhaustive"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns must cover all possibilities. Consider "
"this version of our `plus_one` function, which has a bug and won’t compile:"
msgstr ""
"Ada satu aspek lain dari match yang perlu kita bahas: pola-pola dari setiap bagian harus mencakup semua "
"kemungkinan. Pertimbangkan versi fungsi `plus_one` kita yang ini, yang memiliki bug dan tidak akan dapat "
"dikompilasi:"

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Cairo "
"are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle the `None` case, it protects us from "
"assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""
"Cairo mengetahui bahwa kita tidak mencakup setiap kemungkinan, dan bahkan tahu pola mana yang terlupakan! "
"Pertandingan dalam Cairo adalah eksaustif: kita harus mengeksplorasi setiap kemungkinan terakhir agar kode "
"menjadi valid. Terutama dalam kasus `Option<T>`, ketika Cairo mencegah kita untuk lupa menangani secara "
"eksplisit kasus `None`, itu melindungi kita dari asumsi bahwa kita memiliki sebuah nilai ketika sebenarnya "
"mungkin null, sehingga membuat kesalahan miliaran dolar yang telah dibahas sebelumnya menjadi tidak mungkin "
"terjadi."

#: src/ch06-02-the-match-control-flow-construct.md:201
msgid "Match 0 and the \\_ Placeholder"
msgstr "Match 0 dan \\_ Placeholder"

#: src/ch06-02-the-match-control-flow-construct.md:203
msgid ""
"Using enums, we can also take special actions for a few particular values, but for all other values take one "
"default action. Currently only `0` and the `_`operator are supported."
msgstr ""
"Dengan menggunakan enum, kita juga dapat melakukan tindakan khusus untuk beberapa nilai tertentu, namun untuk "
"semua nilai lainnya, kita lakukan satu tindakan default. Saat ini, hanya `0` dan operator `_` yang didukung."

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 and 7. If you have 0, you win. For "
"all other values you lose. Here's a match that implements that logic, with the number hardcoded rather than a "
"random value."
msgstr ""
"Bayangkan kita sedang mengimplementasikan sebuah permainan di mana Anda mendapatkan angka acak antara 0 dan 7. "
"Jika Anda mendapatkan 0, Anda menang. Untuk semua nilai lainnya, Anda kalah. Berikut adalah pola match yang "
"mengimplementasikan logika tersebut, dengan angka yang ditentukan secara manual daripada nilai acak."

#: src/ch06-02-the-match-control-flow-construct.md:216
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that covers every other possible value, the "
"pattern is the character `_`. This code compiles, even though we haven’t listed all the possible values a "
"`felt252` can have, because the last pattern will match all values not specifically listed. This catch-all "
"pattern meets the requirement that `match` must be exhaustive. Note that we have to put the catch-all arm last "
"because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never "
"run, so Cairo will warn us if we add arms after a catch-all!"
msgstr ""
"Bagian pertama, polanya adalah nilai literal 0. Untuk bagian terakhir yang mencakup setiap nilai lain yang "
"mungkin, polanya adalah karakter `_`. Kode ini dikompilasi, meskipun kita tidak mencantumkan semua nilai yang "
"mungkin dimiliki oleh `felt252`, karena pola terakhir akan cocok dengan semua nilai yang tidak secara khusus "
"terdaftar. Pola penangkapan ini memenuhi persyaratan bahwa `match` harus lengkap. Perlu dicatat bahwa kita harus "
"menempatkan bagian penangkapan terakhir terakhir karena pola dievaluasi berurutan. Jika kita menempatkan bagian "
"penangkapan terakhir lebih awal, bagian lainnya tidak akan pernah dieksekusi, sehingga Cairo akan memberi "
"peringatan jika kita menambahkan bagian setelah bagian penangkapan terakhir!"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly important. By grouping related "
"functionality and separating code with distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"Saat Anda menulis program-program yang besar, mengatur kode akan menjadi semakin penting. Dengan mengelompokkan "
"fungsionalitas terkait dan memisahkan kode dengan fitur-fitur yang berbeda, Anda akan menjelaskan di mana "
"menemukan kode yang mengimplementasikan fitur tertentu dan tempat untuk mengubah cara kerja suatu fitur."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a project grows, you should organize "
"code by splitting it into multiple modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers all these techniques."
msgstr ""
"Program-program yang telah kita tulis sejauh ini berada dalam satu modul di satu file. Saat sebuah proyek "
"berkembang, Anda sebaiknya mengatur kode dengan membaginya menjadi beberapa modul dan kemudian beberapa file. "
"Saat sebuah paket berkembang, Anda dapat mengekstrak bagian-bagiannya menjadi crate terpisah yang menjadi "
"dependensi eksternal. Bab ini membahas semua teknik tersebut."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you reuse code at a higher level: once "
"you’ve implemented an operation, other code can call your code without having to know how the implementation "
"works."
msgstr ""
"Kita juga akan membahas cara menyembunyikan detail implementasi, yang memungkinkan Anda untuk menggunakan ulang "
"kode pada level yang lebih tinggi: setelah Anda mengimplementasikan suatu operasi, kode lain dapat memanggil "
"kode Anda tanpa harus tahu bagaimana implementasinya bekerja."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has a set of names that are defined as "
"“in scope.” When reading, writing, and compiling code, programmers and compilers need to know whether a "
"particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other "
"item and what that item means. You can create scopes and change which names are in or out of scope. You can’t "
"have two items with the same name in the same scope."
msgstr ""
"Konsep terkait adalah cakupan (scope): konteks bertingkat di mana kode ditulis memiliki serangkaian nama yang "
"didefinisikan sebagai \"dalam cakupan\". Saat membaca, menulis, dan mengompilasi kode, para programmer dan "
"kompilator perlu mengetahui apakah suatu nama tertentu pada suatu tempat tertentu merujuk pada variabel, fungsi, "
"struktur data, enum, modul, konstanta, atau item lainnya dan apa makna dari item tersebut. Anda dapat membuat "
"cakupan dan mengubah nama-nama mana yang berada dalam atau di luar cakupan. Anda tidak dapat memiliki dua item "
"dengan nama yang sama dalam cakupan yang sama."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s organization. These features, sometimes "
"collectively referred to as the _module system_, include:"
msgstr ""
"Cairo memiliki sejumlah fitur yang memungkinkan Anda mengelola organisasi kode Anda. Fitur-fitur ini, kadang "
"disebut secara kolektif sebagai _sistem modul_, meliputi:"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid "**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr "**Packages:** Fitur Scarb yang memungkinkan Anda membangun, menguji, dan berbagi crate"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. It has a root directory, and a root "
"module defined at the file `lib.cairo` under this directory."
msgstr ""
"**Crates:** Sebuah pohon modul yang sesuai dengan satu unit kompilasi. Ini memiliki direktori root, dan modul "
"root yang didefinisikan pada file `lib.cairo` di bawah direktori ini."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid "**Modules** and **use:** Let you control the organization and scope of items."
msgstr "**Modules** dan **use:** Memungkinkan Anda mengendalikan organisasi dan cakupan dari item-item."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid "**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr "**Path:** Cara untuk memberi nama pada sebuah item, seperti struktur, fungsi, atau modul"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, and explain how to use them to "
"manage scope. By the end, you should have a solid understanding of the module system and be able to work with "
"scopes like a pro!"
msgstr ""
"Dalam bab ini, kita akan membahas semua fitur tersebut, membahas interaksinya, dan menjelaskan cara "
"menggunakannya untuk mengelola cakupan. Pada akhirnya, Anda seharusnya memiliki pemahaman yang kuat tentang "
"sistem modul dan mampu bekerja dengan cakupan seperti seorang profesional!"

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a crate?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at a time. Even if you run `cairo-"
"compile` rather than `scarb build` and pass a single source code file, the compiler considers that file to be a "
"crate. Crates can contain modules, and the modules may be defined in other files that get compiled with the "
"crate, as will be discussed in the subsequent sections."
msgstr ""
"Sebuah crate adalah jumlah kode terkecil yang dipertimbangkan oleh kompiler Cairo pada satu waktu. Meskipun Anda "
"menjalankan `cairo-compile` daripada `scarb build` dan melewati satu file kode sumber, kompiler menganggap file "
"tersebut sebagai sebuah crate. Crate dapat berisi modul-modul, dan modul-modul tersebut mungkin didefinisikan "
"dalam file lain yang dikompilasi bersama dengan crate, seperti yang akan dibahas dalam bagian-bagian berikutnya."

#: src/ch07-01-packages-and-crates.md:7
msgid "What is the crate root?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts from and makes up the root module "
"of your crate (we’ll explain modules in depth in the [“Defining Modules to Control Scope”](./ch07-02-defining-"
"modules-to-control-scope.md) section)."
msgstr ""
"Crate root adalah file sumber `lib.cairo` yang digunakan oleh kompiler Cairo sebagai awal dan menjadi modul root "
"dari crate Anda (kami akan menjelaskan modul secara mendalam dalam bagian [“Defining Modules to Control Scope”]"
"(./ch07-02-defining-modules-to-control-scope.md))."

#: src/ch07-01-packages-and-crates.md:11
msgid "What is a package?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A Cairo package is a bundle of one or more crates with a Scarb.toml file that describes how to build those "
"crates. This enables the splitting of code into smaller, reusable parts and facilitates more structured "
"dependency management."
msgstr ""
"Package Cairo adalah bundel dari satu atau lebih crate dengan berkas Scarb.toml yang mendeskripsikan cara "
"membangun crate-crate tersebut. Hal ini memungkinkan pemisahan kode ke dalam bagian-bagian yang lebih kecil dan "
"dapat digunakan kembali, serta memfasilitasi manajemen dependensi yang lebih terstruktur."

#: src/ch07-01-packages-and-crates.md:15
msgid "Creating a Package with Scarb"
msgstr "Membuat Package dengan Scarb"

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To create a new package, run the following "
"command:"
msgstr ""
"Anda dapat membuat package Cairo baru menggunakan perangkat baris perintah scarb. Untuk membuat paket baru, "
"jalankan perintah berikut:"

#: src/ch07-01-packages-and-crates.md:23
msgid "This command will generate a new package directory named `my_package` with the following structure:"
msgstr ""
"Perintah ini akan menghasilkan sebuah direktori package baru yang bernama `my_package` dengan struktur sebagai "
"berikut:"

#: src/ch07-01-packages-and-crates.md:32
msgid "`src/` is the main directory where all the Cairo source files for the package will be stored."
msgstr "`src/` adalah direktori utama di mana semua berkas sumber Cairo untuk paket akan disimpan."

#: src/ch07-01-packages-and-crates.md:33
msgid "`lib.cairo` is the default root module of the crate, which is also the main entry point of the package."
msgstr "`lib.cairo` adalah modul root default dari crate, yang juga merupakan titik masuk utama dari paket."

#: src/ch07-01-packages-and-crates.md:34
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and configuration options for the package, "
"such as dependencies, package name, version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"`Scarb.toml` adalah berkas manifest paket, yang berisi metadata dan opsi konfigurasi untuk paket, seperti "
"dependensi, nama paket, versi, dan penulis. Anda dapat menemukan dokumentasi tentangnya di [referensi scarb]"
"(https://docs.swmansion.com/scarb/docs/reference/manifest.html)."

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into multiple Cairo source files. You can do "
"this by creating additional `.cairo` files within the `src` directory or its subdirectories."
msgstr ""
"Ketika Anda mengembangkan paket Anda, Anda mungkin ingin mengatur kode Anda ke dalam beberapa berkas sumber "
"Cairo. Anda dapat melakukannya dengan membuat berkas `.cairo` tambahan di dalam direktori `src` atau "
"subdirektorinya."

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module system, namely _paths_ that allow you to "
"name items and the `use` keyword that brings a path into scope."
msgstr ""
"Pada bagian ini, kita akan membahas tentang modul dan bagian-bagian lain dari sistem modul, yaitu _paths_ yang "
"memungkinkan Anda memberi nama pada item, dan kata kunci `use` yang membawa path ke dalam cakupan."

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when you’re organizing your code in the "
"future. Then we’ll explain each of the rules in detail."
msgstr ""
"Pertama, kita akan memulai dengan daftar aturan untuk referensi mudah saat Anda mengorganisir kode Anda di masa "
"mendatang. Kemudian kita akan menjelaskan setiap aturan secara detail."

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` keyword work in the compiler, and how most "
"developers organize their code. We’ll be going through examples of each of these rules throughout this chapter, "
"but this is a great place to refer to as a reminder of how modules work. You can create a new Scarb project with "
"`scarb new backyard` to follow along."
msgstr ""
"Di sini kami menyediakan referensi cepat tentang bagaimana modul, path, dan kata kunci `use` bekerja dalam "
"kompiler, serta bagaimana sebagian besar pengembang mengatur kode mereka. Kami akan menjelaskan contoh dari "
"setiap aturan ini sepanjang bab ini, namun ini adalah tempat yang bagus untuk dilihat kembali sebagai pengingat "
"tentang bagaimana modul bekerja. Anda dapat membuat proyek Scarb baru dengan `scarb new backyard` untuk "
"mengikuti langkah-langkahnya."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first looks in the crate root file (_src/lib."
"cairo_) for code to compile."
msgstr ""
"**Mulai dari crate roo**: Saat mengompilasi sebuah crate, kompiler pertama-tama mencari kode yang akan "
"dikompilasi dalam berkas akar crate (_src/lib.cairo_)."

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; say, you declare a “garden” module "
"with `mod garden;`. The compiler will look for the module’s code in these places:"
msgstr ""
"**Declaring modules**: Di dalam berkas crate root, Anda dapat mendeklarasikan modul baru; misalnya, Anda "
"mendeklarasikan modul \"garden\" dengan `mod garden;`. Kompiler akan mencari kode modul ini di tempat-tempat "
"berikut:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid "Inline, within curly brackets that replace the semicolon following `mod garden;`."
msgstr "Secara langsung, di dalam tanda kurung kurawal yang menggantikan titik koma setelah `mod garden;`."

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can declare submodules. For example, you "
"might declare `mod vegetables;` in _src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""
"**Declaring modules**: Di dalam berkas selain akar crate, Anda dapat mendeklarasikan submodul. Sebagai contoh, "
"Anda mungkin mendeklarasikan `mod vegetables;` di _src/garden.cairo_. Kompiler akan mencari kode submodul ini "
"dalam direktori yang dinamai sesuai dengan modul induk di tempat-tempat berikut:"

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid "Inline, directly following `mod vegetables`, within curly brackets instead of the semicolon."
msgstr ""
"Secara langsung, langsung setelah `mod vegetables`, di dalam tanda kurung kurawal sebagai pengganti titik koma."

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr "Di dalam berkas _src/garden/vegetables.cairo_"

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can refer to code in that module from "
"anywhere else in that same crate, using the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at `backyard::garden::vegetables::Asparagus`."
msgstr ""
": Setelah sebuah modul menjadi bagian dari crate Anda, Anda dapat merujuk pada kode dalam modul tersebut dari "
"mana saja di dalam crate yang sama, menggunakan path ke kode tersebut. Sebagai contoh, sebuah tipe `Asparagus` "
"dalam modul sayuran taman akan ditemukan di `backyard::garden::vegetables::Asparagus`."

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts to items to reduce repetition of long "
"paths. In any scope that can refer to `backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only need to write `Asparagus` to make use "
"of that type in the scope."
msgstr ""
"**Kata kunci `use`**: Dalam suatu lingkup, kata kunci `use` membuat pintasan ke item untuk mengurangi "
"pengulangan jalur panjang. Dalam setiap lingkup yang dapat merujuk ke `backyard::garden::vegetables::Asparagus`, "
"Anda dapat membuat pintasan dengan `use backyard::garden::vegetables::Asparagus;` dan mulai dari situ Anda hanya "
"perlu menulis `Asparagus` untuk menggunakan tipe tersebut dalam lingkup tersebut."

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The crate’s directory, also named "
"`backyard`, contains these files and directories:"
msgstr ""
"Di sini kita membuat sebuah crate yang bernama `backyard` yang mengilustrasikan aturan-aturan ini. Direktori "
"crate ini, yang juga bernama `backyard`, berisi file-file dan direktori-direktori berikut:"

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "Berkas crate root dalam kasus ini adalah _src/lib.cairo_, dan berisi:"

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid "The `mod garden;` line tells the compiler to include the code it finds in _src/garden.cairo_, which is:"
msgstr ""
"Baris `mod garden;` memberitahu kompiler untuk menyertakan kode yang ditemukan di _src/garden.cairo_, yang "
"isinya adalah:"

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "Filename: src/garden.cairo"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid "Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is included too. That code is:"
msgstr ""
"Di sini, `mod vegetables;` berarti kode dalam _src/garden/vegetables.cairo_ juga disertakan. Kode tersebut "
"adalah:"

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the `Asparagus` type into scope, so we can use "
"it in the `main` function."
msgstr ""
"Baris `use garden::vegetables::Asparagus;` memungkinkan kita untuk membawa tipe data `Asparagus` ke dalam "
"lingkup, sehingga kita dapat menggunakannya dalam fungsi `main`."

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid "Now let’s get into the details of these rules and demonstrate them in action!"
msgstr "Sekarang mari kita masuk ke dalam detail aturan-aturan ini dan tunjukkan penggunaannya dalam praktek!"

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "Grouping Related Code in Modules"
msgstr "Mengelompokkan Kode yang Terkait dalam Modul"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy reuse. As an example, let’s write a "
"library crate that provides the functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, rather than the implementation of a "
"restaurant."
msgstr ""
"_Modules_ memungkinkan kita mengatur kode dalam sebuah crate agar mudah dibaca dan digunakan kembali. Sebagai "
"contoh, mari kita tulis sebuah crate perpustakaan yang menyediakan fungsionalitas sebuah restoran. Kita akan "
"mendefinisikan tanda tangan fungsi-fungsi namun tidak mengisi tubuh fungsi tersebut agar dapat fokus pada "
"organisasi kode, bukan implementasi dari sebuah restoran."

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as _front of house_ and others as _back "
"of house_. Front of house is where customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, "
"dishwashers clean up, and managers do administrative work."
msgstr ""
"Dalam industri restoran, beberapa bagian dari sebuah restoran disebut sebagai _front of house_ dan yang lainnya "
"disebut sebagai _back of house_. _Front of house_ adalah tempat di mana para pelanggan berada; ini meliputi "
"tempat di mana tuan rumah duduknya pelanggan, pelayan mengambil pesanan dan pembayaran, dan penjaga bar membuat "
"minuman. _Back of house_ adalah tempat di mana koki bekerja di dapur, pembersih peralatan membersihkan, dan "
"manajer melakukan pekerjaan administratif."

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into nested modules. Create a new package "
"named `restaurant` by running `scarb new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house section:"
msgstr ""
"Untuk mengatur crate kita dengan cara ini, kita dapat mengelompokkan fungsinya ke dalam modul-modul bertingkat. "
"Buatlah sebuah paket baru dengan nama `restaurant` dengan menjalankan perintah `scarb new restaurant`; kemudian "
"masukkan kode dalam Listing 7-1 ke dalam _src/lib.cairo_ untuk mendefinisikan beberapa modul dan tanda tangan "
"fungsi. Berikut bagian _front of house_-nya:"

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid "Listing 7-1: A `front_of_house` module containing other modules that then contain functions"
msgstr "Listing 7-1: Sebuah modul `front_of_house` yang berisi modul-modul lain yang kemudian berisi fungsi-fungsi"

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module (in this case, `front_of_house`). "
"The body of the module then goes inside curly brackets. Inside modules, we can place other modules, as in this "
"case with the modules `hosting` and `serving`. Modules can also hold definitions for other items, such as "
"structs, enums, constants, traits, and—as in Listing 6-1—functions."
msgstr ""
"Kita mendefinisikan sebuah modul dengan kata kunci `mod` diikuti oleh nama modul (dalam kasus ini, "
"`front_of_house`). Tubuh dari modul tersebut kemudian ditempatkan di dalam kurung kurawal. Di dalam modul, kita "
"dapat menempatkan modul-modul lain, seperti dalam kasus ini dengan modul-modul `hosting` dan `serving`. Modul "
"juga dapat menyimpan definisi untuk item-item lain, seperti struct, enum, konstanta, traits, dan—seperti pada "
"Daftar 6-1—fungsi-fungsi."

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why they’re related. Programmers using this "
"code can navigate the code based on the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new functionality to this code would know "
"where to place the code to keep the program organized."
msgstr ""
"Dengan menggunakan modul, kita dapat mengelompokkan definisi-definisi terkait bersama dan menjelaskan mengapa "
"mereka terkait. Para programmer yang menggunakan kode ini dapat menjelajahi kode berdasarkan grup-grup tersebut "
"daripada harus membaca melalui semua definisi, sehingga lebih mudah untuk menemukan definisi yang relevan bagi "
"mereka. Para programmer yang menambahkan fungsionalitas baru ke dalam kode ini akan tahu di mana meletakkan kode "
"tersebut untuk menjaga keorganisasian program."

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The reason for this name is that the "
"content of this file form a module named after the crate name at the root of the crate’s module structure, known "
"as the _module tree_."
msgstr ""
"Sebelumnya, kami menyebutkan bahwa _src/lib.cairo_ disebut sebagai akar crate. Alasan dari nama ini adalah bahwa "
"konten dari file ini membentuk sebuah modul yang dinamai sesuai dengan nama crate pada akar struktur modul "
"crate, yang dikenal sebagai _pohon modul_ (_module tree_)."

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "Listing 7-2 menunjukkan pohon modul untuk struktur pada Daftar 7-1."

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr "Listing 7-2: Pohon modul untuk kode pada Daftar 6-1"

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for example, `hosting` nests inside "
"`front_of_house`. The tree also shows that some modules are _siblings_ to each other, meaning they’re defined in "
"the same module; `hosting` and `serving` are siblings defined within `front_of_house`. If module A is contained "
"inside module B, we say that module A is the _child_ of module B and that module B is the _parent_ of module A. "
"Notice that the entire module tree is rooted under the explicit name of the crate `restaurant`."
msgstr ""
"Pohon ini menunjukkan bagaimana beberapa modul bersarang di dalam modul lain; misalnya, `hosting` bersarang di "
"dalam `front_of_house`. Pohon ini juga menunjukkan bahwa beberapa modul adalah _saudara kandung_ satu sama lain, "
"artinya mereka didefinisikan dalam modul yang sama; `hosting` dan `serving` adalah saudara kandung yang "
"didefinisikan di dalam `front_of_house`. Jika modul A terdapat di dalam modul B, kita katakan bahwa modul A "
"adalah _anak_ dari modul B dan bahwa modul B adalah _induk_ dari modul A. Perhatikan bahwa seluruh pohon modul "
"berakar di bawah nama eksplisit dari peti kemas `restaurant`."

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your computer; this is a very apt "
"comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in "
"a directory, we need a way to find our modules."
msgstr ""
"Pohon modul mungkin mengingatkan Anda pada pohon direktori dalam sistem file di komputer Anda; perbandingan ini "
"sangat tepat! Sama seperti direktori dalam sistem file, Anda menggunakan modul untuk mengatur kode Anda. Dan "
"sama seperti file dalam sebuah direktori, kita memerlukan cara untuk menemukan modul-modul kita."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when "
"navigating a filesystem. To call a function, we need to know its path."
msgstr ""
"Untuk menunjukkan kepada Cairo di mana menemukan suatu item dalam pohon modul, kita menggunakan jalur dengan "
"cara yang sama seperti saat kita menavigasi sistem file. Untuk memanggil sebuah fungsi, kita perlu tahu jalurnya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Sebuah path dapat memiliki dua bentuk:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute path begins with the crate name."
msgstr ""
"Sebuah _absolute path_ adalah path lengkap yang dimulai dari root crate. Absolute path dimulai dengan nama crate."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "_Relative path_ dimulai dari modul saat ini."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid "Both absolute and relative paths are followed by one or more identifiers separated by double colons (`::`)."
msgstr ""
"Baik jalur absolute maupun relative diikuti oleh satu atau lebih pengenal yang dipisahkan oleh titik dua ganda "
"(`::`)."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the restaurant we used in the last "
"chapter. We have a crate named `restaurant` in which we have a module named `front_of_house` that contains a "
"module named `hosting`. The `hosting` module contains a function named `add_to_waitlist`. We want to call the "
"`add_to_waitlist` function from the `eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"Untuk mengilustrasikan konsep ini, mari kita ambil contoh Daftar 7-1 untuk restoran yang kita gunakan dalam bab "
"sebelumnya. Kita memiliki sebuah crate yang bernama `restaurant` di mana kita memiliki modul bernama "
"`front_of_house` yang berisi sebuah modul bernama `hosting`. Modul `hosting` berisi sebuah fungsi yang bernama "
"`add_to_waitlist`. Kita ingin memanggil fungsi `add_to_waitlist` dari fungsi `eat_at_restaurant`. Kita perlu "
"memberi tahu Cairo jalur ke fungsi `add_to_waitlist` agar Cairo bisa menemukannya."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:36
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:37
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:40
msgid "// ✅ Compiles\n"
msgstr "// ✅ Compiles\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:39
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid "Listing 7-3: Calling the `add_to_waitlist` function using absolute and relative paths"
msgstr "Listing 7-3: Memanggil fungsi `add_to_waitlist` menggunakan jalur absolut dan relatif"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in `eat_at_restaurant`, we use an absolute path. The "
"`add_to_waitlist` function is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute paths start "
"from the crate root, which you need to refer to by using the crate name."
msgstr ""
"Ketika pertama kali kita memanggil fungsi `add_to_waitlist` dalam `eat_at_restaurant`, kita menggunakan jalur "
"absolut. Fungsi `add_to_waitlist` didefinisikan dalam crate yang sama dengan `eat_at_restaurant`. Dalam Cairo, "
"jalur absolut dimulai dari akar crate, yang perlu Anda rujuk dengan menggunakan nama crate."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path starts with `front_of_house`, the "
"name of the module defined at the same level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path `./front_of_house/hosting/add_to_waitlist`. Starting with a module name means "
"that the path is relative to the current module."
msgstr ""
"Ketika kita memanggil `add_to_waitlist` untuk kedua kalinya, kita menggunakan jalur relatif. Jalur dimulai "
"dengan `front_of_house`, nama modul yang didefinisikan pada level yang sama dengan `eat_at_restaurant` dalam "
"pohon modul. Di sini, ekuivalen pada sistem file akan menggunakan jalur `./front_of_house/hosting/"
"add_to_waitlist`. Memulai dengan nama modul berarti bahwa jalur tersebut relatif terhadap modul saat ini."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "Starting Relative Paths with `super`"
msgstr "Memulai Relative Path dengan `super`"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on your project, and depends on whether "
"you’re more likely to move item definition code separately from or together with the code that uses the item."
msgstr ""
"Memilih apakah akan menggunakan `super` atau tidak adalah keputusan yang akan Anda buat berdasarkan proyek Anda, "
"dan bergantung pada apakah Anda lebih cenderung untuk memindahkan kode definisi item secara terpisah dari atau "
"bersama dengan kode yang menggunakan item tersebut."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid "Listing 7-4: Calling a function using a relative path starting with super"
msgstr "Listing 7-4: Memanggil sebuah fungsi menggunakan relative path yang dimulai dengan `super`"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using `super`, which wasn't the case "
"previously."
msgstr ""
"Di sini Anda dapat melihat dengan jelas bahwa Anda dapat mengakses modul induk dengan mudah menggunakan `super`, "
"yang sebelumnya tidak mungkin dilakukan."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "Membawa Paths ke dalam Scope dengan Kata Kunci `use`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and repetitive. Fortunately, there’s a way "
"to simplify this process: we can create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"Mengharuskan menuliskan jalur untuk memanggil fungsi dapat terasa merepotkan dan repetitif. Untungnya, ada cara "
"untuk menyederhanakan proses ini: kita dapat membuat pintasan ke suatu jalur dengan menggunakan kata kunci `use` "
"sekali, dan kemudian menggunakan nama yang lebih pendek di mana pun dalam lingkup tersebut."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module into the scope of the "
"`eat_at_restaurant` function so we only have to specify `hosting::add_to_waitlist` to call the `add_to_waitlist` "
"function in `eat_at_restaurant`."
msgstr ""
"Pada Listing 7-5, kita memasukkan modul `restaurant::front_of_house::hosting` ke dalam lingkup fungsi "
"`eat_at_restaurant` sehingga kita hanya perlu menentukan `hosting::add_to_waitlist` untuk memanggil fungsi "
"`add_to_waitlist` di dalam `eat_at_restaurant`."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section "
"\"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr "// ✅ Shorter path\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr "Listing 7-5: Membawa module ke dalam scope dengan `use`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in the filesystem. By adding `use "
"restaurant::front_of_house::hosting` in the crate root, hosting is now a valid name in that scope, just as "
"though the `hosting` module had been defined in the crate root."
msgstr ""
"Menambahkan `use` dan sebuah path dalam suatu scope mirip dengan membuat tautan simbolik dalam sistem file. "
"Dengan menambahkan `use restaurant::front_of_house::hosting` di root crate, `hosting` sekarang menjadi nama yang "
"valid dalam scope tersebut, seolah-olah modul `hosting` telah didefinisikan di root crate."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which the `use` occurs. Listing 7-6 moves "
"the `eat_at_restaurant` function into a new child module named `customer`, which is then a different scope than "
"the `use` statement, so the function body won’t compile:"
msgstr ""
"Perhatikan bahwa `use` hanya membuat pintasan untuk scope tertentu di mana `use` tersebut terjadi. Listing 7-6 "
"memindahkan fungsi `eat_at_restaurant` ke dalam modul anak baru bernama `customer`, yang kemudian menjadi scope "
"yang berbeda dari pernyataan `use`, sehingga badan fungsi tidak akan dapat dikompilasi:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr "Listing 7-6: Pernyataan `use` hanya berlaku dalam lingkup tempat ia berada"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid "The compiler error shows that the shortcut no longer applies within the `customer` module:"
msgstr "Error kompilasi menunjukkan bahwa pintasan tidak berlaku lagi di dalam modul `customer`:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "Creating Idiomatic `use` Paths"
msgstr "Membuat Path`use` yang Idiomatik"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use restaurant::front_of_house::hosting` and then "
"called `hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the `use` path all the way out "
"to the `add_to_waitlist` function to achieve the same result, as in Listing 7-7."
msgstr ""
"Pada Listing 7-5, Anda mungkin bertanya-tanya mengapa kita menentukan `use restaurant::front_of_house::hosting` "
"dan kemudian memanggil `hosting::add_to_waitlist` dalam `eat_at_restaurant` daripada menentukan jalur `use` "
"sepanjang jalan ke fungsi `add_to_waitlist` untuk mencapai hasil yang sama, seperti pada Listing 7-7."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid "Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic"
msgstr "Listing 7-7: Membawa fungsi `add_to_waitlist` ke dalam scope dengan `use`, yang kurang idiomatik"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 6-7 accomplish the same task, Listing 7-5 is the idiomatic way to bring a function "
"into scope with `use`. Bringing the function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when calling the function makes it clear "
"that the function isn’t locally defined while still minimizing repetition of the full path. The code in Listing "
"7-7 is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"Meskipun kedua Listing 7-5 dan 6-7 berhasil menyelesaikan tugas yang sama, Listing 7-5 merupakan cara yang "
"idiomatik untuk membawa sebuah fungsi ke dalam lingkup dengan `use`. Memasukkan modul induk fungsi ke dalam "
"scope dengan `use` berarti kita harus menentukan modul induk saat memanggil fungsi tersebut. Menentukan modul "
"induk saat memanggil fungsi membuat jelas bahwa fungsi tersebut tidak didefinisikan secara lokal sementara tetap "
"meminimalkan pengulangan dari jalur lengkap. Kode dalam Listing 7-7 kurang jelas mengenai di mana "
"`add_to_waitlist` didefinisikan."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items with `use`, it’s idiomatic to "
"specify the full path. Listing 7-8 shows the idiomatic way to bring the core library’s `ArrayTrait` trait into "
"the scope."
msgstr ""
"Di sisi lain, saat mengimpor structs, enums, traits, dan item lain dengan `use`, cara yang idiomatik adalah "
"dengan menentukan jalur lengkap. Listing 7-8 menunjukkan cara yang idiomatik untuk membawa trait `ArrayTrait` "
"dari perpustakaan inti (core library) ke dalam scope."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr "Listing 7-8: Membawa `ArrayTrait` ke dalam scope dengan cara yang idiomatik"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that has emerged in the Rust community, and "
"folks have gotten used to reading and writing Rust code this way. As Cairo shares many idioms with Rust, we "
"follow this convention as well."
msgstr ""
"Tidak ada alasan kuat di balik idiom ini: itu hanya konvensi yang muncul dalam komunitas Rust, dan orang-orang "
"telah terbiasa membaca dan menulis kode Rust dengan cara ini. Karena Cairo memiliki banyak kesamaan dengan idiom-"
"idiom Rust, kami juga mengikuti konvensi ini."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same name into scope with `use` statements, "
"because Cairo doesn’t allow that."
msgstr ""
"Pengecualian dari idiom ini adalah jika kita membawa dua item dengan nama yang sama ke dalam lingkup dengan "
"pernyataan `use`, karena Cairo tidak mengizinkan hal tersebut."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "Providing New Names with the `as` Keyword"
msgstr "Memberikan Nama Baru dengan Kata Kunci `as`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same name into the same scope with `use`: "
"after the path, we can specify `as` and a new local name, or _alias_, for the type. Listing 7-9 shows how you "
"can rename an import with `as`:"
msgstr ""
"Ada solusi lain untuk masalah membawa dua tipe dengan nama yang sama ke dalam lingkup yang sama dengan `use`: "
"setelah path, kita dapat menentukan `as` dan nama lokal baru, atau _alias_, untuk tipe tersebut. Listing 7-9 "
"menunjukkan bagaimana Anda dapat menamai ulang impor dengan `as`:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid "// ArrayTrait was renamed to Arr\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid "Listing 7-9: Renaming a trait when it’s brought into scope with the `as` keyword"
msgstr "Listing 7-9: Menamai ulang sebuah trait ketika dibawa ke dalam lingkup dengan kata kunci `as`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now access the trait's methods with the "
"`Arr` identifier."
msgstr ""
"Di sini, kami membawa `ArrayTrait` ke dalam lingkup dengan alias `Arr`. Sekarang kami dapat mengakses metode-"
"metode dari trait tersebut menggunakan pengenal `Arr`."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "Importing multiple items from the same module"
msgstr "Mengimpor beberapa item dari modul yang sama"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums) from the same module in Cairo, you can "
"use curly braces `{}` to list all of the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr ""
"Ketika Anda ingin mengimpor beberapa item (seperti fungsi, struktur, atau enumerasi) dari modul yang sama di "
"Cairo, Anda dapat menggunakan kurung kurawal `{}` untuk menuliskan semua item yang ingin Anda impor. Ini "
"membantu menjaga kode Anda bersih dan mudah dibaca dengan menghindari daftar panjang pernyataan `use` secara "
"individual."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid "The general syntax for importing multiple items from the same module is:"
msgstr "Syntax umum untuk mengimpor beberapa item dari modul yang sama adalah:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid "Here is an example where we import three structures from the same module:"
msgstr "Berikut contoh di mana kita mengimpor tiga struktur dari modul yang sama:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid "// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid "// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like this:\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid "// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189 src/ch08-02-traits-in-cairo.md:186
#: src/ch08-02-traits-in-cairo.md:190 src/ch08-02-traits-in-cairo.md:199 src/ch99-03-security-considerations.md:143
#: src/ch99-03-security-considerations.md:148
msgid "// ...\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr "Listing 7-10: Mengimpor beberapa item dari modul yang sama"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "Re-exporting Names in Module Files"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available in the new scope can be imported as "
"if it had been defined in that code’s scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring into their scope."
msgstr ""
"Ketika kita membawa sebuah nama ke dalam scope dengan kata kunci `use`, nama yang tersedia dalam scope baru "
"dapat diimpor seolah-olah itu telah didefinisikan dalam scope kode tersebut. Teknik ini disebut _re-exporting_ "
"karena kita membawa sebuah item ke dalam scope, namun juga membuat item tersebut tersedia bagi orang lain untuk "
"diimpor ke dalam scope mereka."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid "For example, let's re-export the `add_to_waitlist` function in the restaurant example:"
msgstr "Sebagai contoh, mari kita _re-export_ fungsi `add_to_waitlist` dalam contoh restoran:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid "Listing 7-11: Making a name available for any code to use from a new scope with `pub use`"
msgstr ""
"Listing 7-11: Membuat sebuah nama tersedia untuk digunakan oleh kode mana pun dari scope baru dengan `pub use`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `use` has re-exported the `hosting` "
"module from the root module, external code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"Sebelum perubahan ini, kode eksternal harus memanggil fungsi `add_to_waitlist` dengan menggunakan path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Sekarang bahwa `use` telah mere-export modul `hosting` "
"dari modul root, kode eksternal sekarang dapat menggunakan path `restaurant::hosting::add_to_waitlist()` sebagai "
"gantinya."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different from how programmers calling your "
"code would think about the domain. For example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a restaurant probably won’t think about "
"the parts of the restaurant in those terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for programmers working on the library and "
"programmers calling the library."
msgstr ""
"Mere-export (_re-exporting_) berguna ketika struktur internal kode Anda berbeda dari cara para programmer yang "
"memanggil kode Anda akan memikirkan domain tersebut. Sebagai contoh, dalam metafora restoran ini, orang-orang "
"yang menjalankan restoran memikirkan \"depan rumah\" dan \"belakang rumah\". Tetapi pelanggan yang mengunjungi "
"restoran mungkin tidak akan memikirkan bagian-bagian restoran dengan istilah tersebut. Dengan `use`, kita dapat "
"menulis kode kita dengan satu struktur tetapi mengekspos struktur yang berbeda. Melakukan hal ini membuat "
"perpustakaan kita terorganisir dengan baik untuk para programmer yang bekerja pada perpustakaan dan programmer "
"yang memanggil perpustakaan tersebut."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "Using External Packages in Cairo with Scarb"
msgstr "Menggunakan Packages Eksternal di Cairo dengan Scarb"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality provided by the community. To use an "
"external package in your project with Scarb, follow these steps:"
msgstr ""
"Anda mungkin perlu menggunakan packages eksternal untuk memanfaatkan fungsionalitas yang disediakan oleh "
"komunitas. Untuk menggunakan paket eksternal dalam proyek Anda dengan Scarb, ikuti langkah-langkah berikut:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"The dependencies system is still a work in progress. You can check the official [documentation](https://docs."
"swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr ""
"Sistem dependensi masih dalam tahap pengembangan. Anda dapat memeriksa [dokumentasi resmi](https://docs."
"swmansion.com/scarb/docs/guides/dependencies.html)."

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might "
"want to move their definitions to a separate file to make the code easier to navigate."
msgstr ""
"Sejauh ini, semua contoh dalam bab ini telah mendefinisikan beberapa modul dalam satu file. Ketika modul menjadi "
"besar, Anda mungkin ingin memindahkan definisi mereka ke file terpisah untuk memudahkan navigasi kode."

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple restaurant modules. We’ll extract "
"modules into files instead of having all the modules defined in the crate root file. In this case, the crate "
"root file is _src/lib.cairo_."
msgstr ""
"Sebagai contoh, mari kita mulai dari kode pada Listing 7-11 yang memiliki beberapa modul restoran. Kita akan "
"mengekstrak modul ke dalam file daripada memiliki semua modul yang didefinisikan dalam file akar krate. Dalam "
"kasus ini, file akar krate adalah _src/lib.cairo_."

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the code inside the curly brackets for "
"the `front_of_house` module, leaving only the `mod front_of_house;` declaration, so that _src/lib.cairo_ "
"contains the code shown in Listing 7-12. Note that this won’t compile until we create the _src/front_of_house."
"cairo_ file in Listing 7-13."
msgstr ""
"Pertama, kita akan mengekstrak modul `front_of_house` ke dalam file terpisah. Hapuslah kode di dalam kurung "
"kurawal untuk modul `front_of_house`, sehingga hanya tersisa deklarasi `mod front_of_house;`, sehingga _src/lib."
"cairo_ berisi kode seperti yang ditunjukkan dalam Listing 7-12. Perlu diingat bahwa ini tidak akan dapat "
"dikompilasi hingga kita membuat file _src/front_of_house.cairo_ seperti yang terlihat pada Listing 7-13."

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid "Listing 7-12: Declaring the `front_of_house` module whose body will be in _src/front_of_house.cairo_"
msgstr "Listing 7-12: Mendeklarasikan modul `front_of_house` yang isinya akan berada di _src/front_of_house.cairo_"

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named _src/front_of_house.cairo_, as shown "
"in Listing 7-13. The compiler knows to look in this file because it came across the module declaration in the "
"crate root with the name `front_of_house`."
msgstr ""
"Selanjutnya, letakkan kode yang ada di dalam kurung kurawal ke dalam file baru yang diberi nama _src/"
"front_of_house.cairo_, seperti yang ditunjukkan pada Listing 7-13. Kompiler akan mencari file ini karena menemui "
"deklarasi modul di file akar krate dengan nama `front_of_house`."

#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
msgid "Filename: src/front_of_house.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:46
msgid "Listing 7-13: Definitions inside the `front_of_house` module in _src/front_of_house.cairo_"
msgstr "Listing 7-13: Definisi di dalam modul `front_of_house` di _src/front_of_house.cairo_"

#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in your module tree. Once the compiler "
"knows the file is part of the project (and knows where in the module tree the code resides because of where "
"you’ve put the `mod` statement), other files in your project should refer to the loaded file’s code using a path "
"to where it was declared, as covered in the [“Paths for Referring to an Item in the Module Tree”](ch06-03-paths-"
"for-referring-to-an-item-in-the-module-tree.html)"
msgstr ""
"Perhatikan bahwa Anda hanya perlu memuat sebuah file menggunakan deklarasi `mod` _sekali_ dalam pohon modul "
"Anda. Begitu kompiler tahu bahwa file tersebut merupakan bagian dari proyek (dan mengetahui di mana dalam pohon "
"modul kode tersebut berada karena di mana Anda menempatkan pernyataan `mod`), file-file lain dalam proyek Anda "
"seharusnya merujuk pada kode file yang dimuat menggunakan path ke tempat di mana itu dideklarasikan, sebagaimana "
"dijelaskan dalam bagian [“Paths for Referring to an Item in the Module Tree”](ch06-03-paths-for-referring-to-an-"
"item-in-the-module-tree.html)"

#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may have seen in other programming "
"languages."
msgstr ""
" bagian. Dengan kata lain, `mod` _bukanlah_ operasi \"include\" seperti yang mungkin Anda temui dalam bahasa "
"pemrograman lain."

#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a bit different because `hosting` is a "
"child module of `front_of_house`, not of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case _src/front_of_house/_."
msgstr ""
"Selanjutnya, kita akan mengekstrak modul `hosting` ke dalam file terpisah. Proses ini agak berbeda karena "
"`hosting` adalah modul anak dari `front_of_house`, bukan dari modul akar. Kita akan menempatkan file untuk "
"`hosting` dalam direktori baru yang akan dinamai sesuai dengan leluhurnya dalam pohon modul, dalam hal ini _src/"
"front_of_house/_."

#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain only the declaration of the `hosting` "
"module:"
msgstr ""
"Untuk memulai proses memindahkan `hosting`, kita mengubah _src/front_of_house.cairo_ sehingga hanya berisi "
"deklarasi modul `hosting`:"

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ to contain the definitions made in "
"the `hosting` module:"
msgstr ""
"Kemudian, kita membuat direktori _src/front_of_house_ dan sebuah file _hosting.cairo_ untuk berisi definisi yang "
"dibuat di dalam modul `hosting`:"

#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would expect the _hosting.cairo_ code to "
"be in a `hosting` module declared in the crate root, and not declared as a child of the `front_of_house` module. "
"The compiler’s rules for which files to check for which modules’ code means the directories and files more "
"closely match the module tree."
msgstr ""
"Jika kita memindahkan _hosting.cairo_ ke dalam direktori _src_, kompiler akan mengharapkan kode _hosting.cairo_ "
"berada dalam modul `hosting` yang dideklarasikan di akar krate, dan bukan dideklarasikan sebagai anak modul dari "
"modul `front_of_house`. Aturan kompiler untuk mengecek file mana yang harus diperiksa untuk kode modul mana "
"membuat direktori dan file lebih sesuai dengan pohon modul."

#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree remains the same. The function calls in "
"`eat_at_restaurant` will work without any modification, even though the definitions live in different files. "
"This technique lets you move modules to new files as they grow in size."
msgstr ""
"Kami telah memindahkan kode setiap modul ke file terpisah, dan pohon modul tetap sama. Panggilan fungsi dalam "
"`eat_at_restaurant` akan berfungsi tanpa modifikasi apa pun, meskipun definisinya berada di file yang berbeda. "
"Teknik ini memungkinkan Anda memindahkan modul ke file baru ketika ukurannya berkembang."

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in _src/lib.cairo_ also hasn’t changed, nor "
"does `use` have any impact on what files are compiled as part of the crate. The `mod` keyword declares modules, "
"and Cairo looks in a file with the same name as the module for the code that goes into that module."
msgstr ""
"Perlu dicatat bahwa pernyataan `use restaurant::front_of_house::hosting` di _src/lib.cairo_ juga tidak berubah, "
"dan `use` tidak memiliki dampak pada file mana yang dikompilasi sebagai bagian dari krate. Kata kunci `mod` "
"mendeklarasikan modul, dan Cairo mencari kode yang masuk ke dalam modul itu dalam sebuah file dengan nama yang "
"sama dengan modul tersebut."

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules so you can refer to items defined "
"in one module from another module. You can do this by specifying absolute or relative paths. These paths can be "
"brought into scope with a `use` statement so you can use a shorter path for multiple uses of the item in that "
"scope. Module code is public by default."
msgstr ""
"Cairo memungkinkan Anda membagi paket menjadi beberapa krate dan sebuah krate menjadi modul sehingga Anda dapat "
"merujuk ke item yang didefinisikan di satu modul dari modul lainnya. Anda dapat melakukannya dengan menentukan "
"path absolute atau relative. Path ini dapat dimasukkan ke dalam cakupan dengan pernyataan `use` sehingga Anda "
"dapat menggunakan path yang lebih pendek untuk beberapa penggunaan item dalam cakupan tersebut. Kode modul "
"bersifat publik secara default."

#: src/ch08-00-generic-types-and-traits.md:1
msgid "Generic Types and Traits"
msgstr "Generic Types dan Traits"

#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the duplication of concepts. In Cairo, one such "
"tool is generics: abstract stand-ins for concrete types or other properties. We can express the behavior of "
"generics or how they relate to other generics without knowing what will be in their place when compiling and "
"running the code."
msgstr ""
"Setiap bahasa pemrograman memiliki alat untuk menangani duplikasi konsep secara efektif. Dalam Cairo, salah satu "
"alat tersebut adalah generics: pengganti abstrak untuk tipe konkret atau properti lainnya. Kita dapat "
"mengekspresikan perilaku generics atau bagaimana mereka berhubungan dengan generics lain tanpa mengetahui apa "
"yang akan menggantikan mereka saat mengompilasi dan menjalankan kode."

#: src/ch08-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part of their definition instead of a "
"concrete type like `u32` or `ContractAddress`."
msgstr ""
"Fungsi, struktur, enumerasi, dan trait dapat menggabungkan tipe generik sebagai bagian dari definisi mereka, "
"bukan tipe konkret seperti `u32` atau `ContractAddress`."

#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that represents multiple types to remove code "
"duplication."
msgstr ""
"Generics memungkinkan kita untuk mengganti tipe tertentu dengan suatu tempat penampung yang mewakili beberapa "
"tipe untuk menghilangkan duplikasi kode."

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a new definition, reducing development "
"time for the programmer, but code duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which will cause contract size to "
"increment."
msgstr ""
"Untuk setiap tipe konkret yang menggantikan tipe generik, kompiler membuat definisi baru, mengurangi waktu "
"pengembangan bagi pemrogram, tetapi duplikasi kode pada tingkat kompilasi masih ada. Ini dapat menjadi penting "
"jika Anda menulis kontrak Starknet dan menggunakan generic untuk beberapa tipe yang akan menyebabkan peningkatan "
"ukuran kontrak."

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You can combine traits with generic "
"types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just "
"any type."
msgstr ""
"Selanjutnya, Anda akan belajar bagaimana menggunakan trait untuk mendefinisikan perilaku secara generik. Anda "
"dapat menggabungkan trait dengan tipe generik untuk membatasi tipe generik agar hanya menerima tipe-tipe yang "
"memiliki perilaku tertentu, bukan hanya tipe apa pun."

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs and functions, which we can then "
"use with many different concrete data types. In Cairo we can use generics when defining functions, structs, "
"enums, traits, implementations and methods! In this chapter we are going to take a look at how to effectively "
"use generic types with all of them."
msgstr ""
"Kita menggunakan generics untuk membuat definisi untuk deklarasi item, seperti structs dan functions, yang "
"kemudian dapat kita gunakan dengan banyak tipe data konkret yang berbeda. Di Cairo, kita dapat menggunakan "
"generics saat mendefinisikan functions, structs, enums, traits, implementations, dan methods! Pada bab ini, kita "
"akan melihat bagaimana cara menggunakan tipe generik secara efektif dengan semuanya itu."

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the function signature, where we would "
"usually specify the data types of the parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If we need to perform this operation for "
"lists of different types, then we would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"Saat mendefinisikan sebuah fungsi yang menggunakan generics, kita menempatkan generics dalam tanda tangan "
"fungsi, di mana kita biasanya akan menentukan tipe data dari parameter dan nilai kembalian. Sebagai contoh, "
"bayangkan kita ingin membuat sebuah fungsi yang, diberikan dua `Array` item, akan mengembalikan yang terbesar. "
"Jika kita perlu melakukan operasi ini untuk daftar berbagai jenis, maka kita harus mendefinisikan ulang fungsi "
"tersebut setiap kali. Untungnya, kita dapat mengimplementasikan fungsi ini sekali menggunakan generics dan "
"melanjutkan ke tugas-tugas lainnya."

#: src/ch08-01-generic-data-types.md:10
msgid "// Specify generic type T between the angulars\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:31
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns the one with more elements and drops "
"the other. If you compile the previous code, you will notice that it will fail with an error saying that there "
"are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to "
"guarantee that an `Array<T>` is droppable when executing the `main` function. In order to drop an array of `T`, "
"the compiler must first know how to drop `T`. This can be fixed by specifying in the function signature of "
"`largest_list` that `T` must implement the drop trait. The correct function definition of `largest_list` is as "
"follows:"
msgstr ""
"Fungsi `largest_list` membandingkan dua daftar dengan tipe yang sama dan mengembalikan yang memiliki lebih "
"banyak elemen sementara yang lain dihapus. Jika Anda mengompilasi kode sebelumnya, Anda akan melihat bahwa akan "
"gagal dengan pesan kesalahan yang menyatakan bahwa tidak ada trait yang didefinisikan untuk menghapus sebuah "
"array dari tipe generik. Hal ini terjadi karena kompiler tidak memiliki cara untuk menjamin bahwa sebuah "
"`Array<T>` dapat dihapus saat menjalankan fungsi `main`. Untuk menghapus sebuah array dari `T`, kompiler harus "
"pertama-tama tahu bagaimana cara menghapus `T`. Ini dapat diperbaiki dengan menentukan dalam tanda tangan fungsi "
"`largest_list` bahwa `T` harus mengimplementasikan trait drop. Definisi fungsi `largest_list` yang benar adalah "
"sebagai berikut:"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement that whatever generic type is placed "
"there, it must be droppable. The `main` function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""
"Fungsi `largest_list` yang baru memasukkan dalam definisinya persyaratan bahwa tipe generik apa pun yang "
"ditempatkan di sana, harus dapat dihapus. Fungsi `main` tetap tidak berubah, kompiler cukup cerdas untuk "
"menyimpulkan tipe konkret apa yang digunakan dan apakah itu mengimplementasikan trait `Drop`."

#: src/ch08-01-generic-data-types.md:51
msgid "Constraints for Generic Types"
msgstr "Kendala untuk Generic Types"

#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. Knowing which traits a generic type "
"implements allow us to use them more effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this previously by adding the `TDrop` "
"implementation as part of the generic arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function logic."
msgstr ""
"Saat mendefinisikan tipe generik, penting untuk memiliki informasi tentang mereka. Mengetahui trait mana yang "
"diimplementasikan oleh tipe generik memungkinkan kita menggunakan mereka dengan lebih efektif dalam logika "
"fungsi dengan biaya membatasi tipe generik yang dapat digunakan dengan fungsi tersebut. Kami melihat contoh ini "
"sebelumnya dengan menambahkan implementasi `TDrop` sebagai bagian dari argumen generik dari `largest_list`. "
"Sementara `TDrop` ditambahkan untuk memenuhi persyaratan kompiler, kita juga dapat menambahkan kendala untuk "
"mendukung logika fungsi kita."

#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to find the smallest element among "
"them. Initially, we know that for an element of type `T` to be comparable, it must implement the `PartialOrd` "
"trait. The resulting function would be:"
msgstr ""
"Bayangkan bahwa kita ingin, diberikan sebuah daftar elemen dari suatu tipe generik `T`, untuk menemukan elemen "
"terkecil di antara mereka. Awalnya, kita tahu bahwa untuk sebuah elemen tipe `T` agar dapat dibandingkan, ia "
"harus mengimplementasikan trait `PartialOrd`. Fungsi yang dihasilkan akan menjadi:"

#: src/ch08-01-generic-data-types.md:58
msgid ""
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:62
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:66
msgid "// The index we will use to move through the list\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:69
msgid "// Iterate through the whole list storing the smallest\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:87
msgid "// We need to specify that we are passing a snapshot of `list` as an argument\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:93
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot "
"of an `Array<T>` as a parameter and returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so we don't require to implement the "
"`Drop` trait for `T` as well. Why it does not compile then?"
msgstr ""
"Fungsi `smallest_element` menggunakan tipe generik `T` yang mengimplementasikan trait `PartialOrd`, mengambil "
"snapshot dari `Array<T>` sebagai parameter, dan mengembalikan salinan elemen terkecil. Karena parameter adalah "
"tipe `@Array<T>`, kita tidak lagi perlu menghapusnya di akhir eksekusi dan karenanya kita tidak memerlukan "
"implementasi trait `Drop` untuk `T` juga. Mengapa kemudian kode ini tidak dapat dikompilasi?"

#: src/ch08-01-generic-data-types.md:95
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, unless `PartialOrd` is implemented "
"for `@T` we need to desnap the element using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now "
"variables with type `T` that need to be dropped, requiring for `T` to implement the `Drop` trait as well. We "
"must then add both `Drop` and `Copy` traits implementation for the function to be correct. After updating "
"the`smallest_element` function the resulting code would be:"
msgstr ""
"Ketika mengindeks pada `list`, nilai menghasilkan snap dari elemen yang diindeks, kecuali `PartialOrd` "
"diimplementasikan untuk `@T` kita perlu melepaskan snap elemen tersebut menggunakan `*`. Operasi `*` memerlukan "
"salinan dari `@T` ke `T`, yang berarti bahwa `T` perlu mengimplementasikan trait `Copy`. Setelah menyalin elemen "
"bertipe `@T` ke `T`, sekarang ada variabel dengan tipe `T` yang perlu dibuang, memerlukan `T` untuk "
"mengimplementasikan trait `Drop` juga. Oleh karena itu, kita harus menambahkan implementasi trait `Drop` dan "
"`Copy` untuk fungsi tersebut agar menjadi benar. Setelah memperbarui fungsi `smallest_element`, kode hasilnya "
"akan menjadi:"

#: src/ch08-01-generic-data-types.md:115
msgid "Structs"
msgstr ""

#: src/ch08-01-generic-data-types.md:117
msgid ""
"We can also define structs to use a generic type parameter for one or more fields using the `<>` syntax, similar "
"to function definitions. First we declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify "
"concrete data types. The next code example shows the definition `Wallet<T>` which has a `balance` field of type "
"`T`."
msgstr ""
"Kita juga dapat mendefinisikan struct untuk menggunakan parameter tipe generik untuk satu atau lebih bidang "
"menggunakan sintaks `<>`, mirip dengan definisi fungsi. Pertama, kita mendeklarasikan nama parameter tipe di "
"dalam tanda kurung sudut tepat setelah nama struct. Kemudian kita menggunakan tipe generik dalam definisi struct "
"di tempat kita seharusnya menentukan tipe data konkret. Contoh kode berikut menunjukkan definisi `Wallet<T>` "
"yang memiliki bidang `balance` bertipe `T`."

#: src/ch08-01-generic-data-types.md:131
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the "
"following code:"
msgstr ""
"Kode di atas menghasilkan trait `Drop` untuk tipe `Wallet` secara otomatis. Ini setara dengan menulis kode "
"berikut:"

#: src/ch08-01-generic-data-types.md:145
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` "
"implementation. Notice that we must define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is "
"droppable as long as `T` is also droppable."
msgstr ""
"Kami menghindari menggunakan makro `derive` untuk implementasi `Drop` dari `Wallet` dan sebaliknya "
"mendefinisikan implementasi `WalletDrop` kami sendiri. Perhatikan bahwa kita harus mendefinisikan, sama seperti "
"fungsi, tipe generik tambahan untuk `WalletDrop` yang menyatakan bahwa `T` juga mengimplementasikan trait "
"`Drop`. Pada dasarnya, kami mengatakan bahwa struct `Wallet<T>` dapat dihapus selama `T` juga dapat dihapus."

#: src/ch08-01-generic-data-types.md:147
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and we want that field to be different "
"than `T` but generic as well, we can simply add another generic type between the `<>`:"
msgstr ""
"Terakhir, jika kita ingin menambahkan bidang ke `Wallet` yang mewakili alamatnya dan kita ingin bidang tersebut "
"berbeda dari `T` tetapi juga generik, kita hanya perlu menambahkan tipe generik lain di antara `<>`:"

#: src/ch08-01-generic-data-types.md:161
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign this type to the new field member "
"`address`. Notice that the derive attribute for the `Drop` trait works for `U` as well."
msgstr ""
"Kita menambahkan ke definisi struct `Wallet` tipe generik baru `U` dan kemudian menetapkan tipe ini ke anggota "
"bidang baru `address`. Perhatikan bahwa atribut `derive` untuk trait `Drop` juga berfungsi untuk `U`."

#: src/ch08-01-generic-data-types.md:165
msgid ""
"As we did with structs, we can define enums to hold generic data types in their variants. For example the "
"`Option<T>` enum provided by the Cairo core library:"
msgstr ""
"Seperti yang kita lakukan dengan struct, kita dapat mendefinisikan enums untuk menyimpan tipe data generik dalam "
"variasi mereka. Sebagai contoh, enum `Option<T>` yang disediakan oleh perpustakaan inti Cairo:"

#: src/ch08-01-generic-data-types.md:174
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` "
"and `None` that doesn't hold any value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction "
"with any type."
msgstr ""
"Enum `Option<T>` adalah generic terhadap tipe `T` dan memiliki dua variasi: `Some`, yang menyimpan satu nilai "
"tipe `T`, dan `None` yang tidak menyimpan nilai apa pun. Dengan menggunakan enum `Option<T>`, kita dapat "
"menyatakan konsep abstrak dari nilai opsional dan karena nilai memiliki tipe generik `T`, kita dapat menggunakan "
"abstraksi ini dengan tipe apa pun."

#: src/ch08-01-generic-data-types.md:176
msgid ""
"Enums can use multiple generic types as well, like definition of the `Result<T, E>` enum that the core library "
"provides:"
msgstr ""
"Enums juga dapat menggunakan beberapa tipe generik, seperti definisi enum `Result<T, E>` yang disediakan oleh "
"perpustakaan inti:"

#: src/ch08-01-generic-data-types.md:185 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type "
"`T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum "
"anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a "
"value of type `E`)."
msgstr ""
"Enum `Result<T, E>` memiliki dua tipe generik, `T` dan `E`, dan dua variasi: `Ok` yang menyimpan nilai tipe `T` "
"dan `Err` yang menyimpan nilai tipe `E`. Definisi ini membuatnya nyaman untuk menggunakan enum `Result` di mana "
"pun kita memiliki operasi yang mungkin berhasil (dengan mengembalikan nilai tipe `T`) atau gagal (dengan "
"mengembalikan nilai tipe `E`)."

#: src/ch08-01-generic-data-types.md:187
msgid "Generic Methods"
msgstr "Metode Generic"

#: src/ch08-01-generic-data-types.md:189
msgid ""
"We can implement methods on structs and enums, and use the generic types in their definition, too. Using our "
"previous definition of `Wallet<T>` struct, we define a `balance` method for it:"
msgstr ""
"Kita dapat mengimplementasikan metode pada struct dan enums, dan juga menggunakan tipe generik dalam "
"definisinya. Dengan menggunakan definisi sebelumnya dari struct `Wallet<T>`, kita mendefinisikan metode "
"`balance` untuknya:"

#: src/ch08-01-generic-data-types.md:213
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which defines a method that returns a snapshot "
"of the field `address` from `Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. Note that "
"you need to include a generic type in both definitions of the trait and the implementation."
msgstr ""
"Pertama, kita mendefinisikan trait `WalletTrait<T>` menggunakan tipe generik `T` yang mendefinisikan sebuah "
"metode yang mengembalikan salinan dari bidang `address` dari `Wallet`. Kemudian kita memberikan implementasi "
"untuk trait tersebut dalam `WalletImpl<T>`. Perhatikan bahwa Anda perlu menyertakan tipe generik dalam kedua "
"definisi trait dan implementasinya."

#: src/ch08-01-generic-data-types.md:215
msgid ""
"We can also specify constraints on generic types when defining methods on the type. We could, for example, "
"implement methods only for `Wallet<u128>` instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the `balance` field."
msgstr ""
"Kita juga dapat menentukan batasan pada tipe generik saat mendefinisikan metode pada tipe tersebut. Sebagai "
"contoh, kita bisa mengimplementasikan metode hanya untuk instans `Wallet<u128>` daripada `Wallet<T>`. Pada "
"contoh kode, kita mendefinisikan implementasi untuk dompet yang memiliki tipe konkret `u128` untuk bidang "
"`balance`."

#: src/ch08-01-generic-data-types.md:222
msgid "/// Generic trait for wallets\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:233
msgid "/// Trait for wallets of type u128\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:254
msgid ""
"The new method `receive` increments the size of the balance of any instance of a `Wallet<u128>`. Notice that we "
"changed the `main` function making `w` a mutable variable in order for it to be able to update its balance. If "
"we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile."
msgstr ""
"Metode baru `receive` menambahkan ukuran saldo dari setiap instans `Wallet<u128>`. Perhatikan bahwa kita "
"mengubah fungsi `main` dengan membuat variabel `w` menjadi mutable agar dapat memperbarui saldonya. Jika kita "
"mengubah inisialisasi `w` dengan mengubah tipe `balance`, kode sebelumnya tidak akan dapat dikompilasi."

#: src/ch08-01-generic-data-types.md:256
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from "
"`Wallet<U, V>` we are going to define a trait that picks two wallets of different generic types and create a new "
"one with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"Cairo memungkinkan kita untuk mendefinisikan metode generik di dalam trait generik juga. Dengan menggunakan "
"implementasi sebelumnya dari `Wallet<U, V>`, kita akan mendefinisikan sebuah trait yang memilih dua dompet "
"dengan tipe generik yang berbeda dan membuat yang baru dengan tipe generik dari masing-masing. Pertama, mari "
"kita tulis kembali definisi struct:"

#: src/ch08-01-generic-data-types.md:265
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr "Selanjutnya, kita akan dengan naif mendefinisikan trait dan implementasi untuk mixup:"

#: src/ch08-01-generic-data-types.md:268
msgid "// This does not compile!\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:281
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` methods which given an instance of "
"`Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the reason for this code not to compile. If "
"you have been following from the start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order for the compiler to know how to drop "
"instances of `Wallet<T, U>`. The updated implementation is as follow:"
msgstr ""
"Kami membuat trait `WalletMixTrait<T1, U1>` dengan metode `mixup<T2, U2>` yang, dengan memberikan instans dari "
"`Wallet<T1, U1>` dan `Wallet<T2, U2>`, membuat `Wallet<T1, U2>` baru. Seperti yang dijelaskan dalam tanda tangan "
"`mixup`, baik `self` maupun `other` akan dibuang (dropped) pada akhir fungsi, itulah sebabnya kode ini tidak "
"dapat dikompilasi. Jika Anda telah mengikuti dari awal hingga sekarang, Anda akan tahu bahwa kita harus "
"menambahkan persyaratan untuk semua tipe generik dengan menentukan bahwa mereka akan mengimplementasikan trait "
"`Drop` agar kompiler tahu cara membuang (drop) instans `Wallet<T, U>`. Implementasi yang diperbarui adalah "
"sebagai berikut:"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same "
"for `T2` and `U2`, this time as part of `mixup` signature. We can now try the `mixup` function:"
msgstr ""
"Kami menambahkan persyaratan agar `T1` dan `U1` dapat di-drop pada deklarasi `WalletMixImpl`. Selanjutnya, kami "
"melakukan hal yang sama untuk `T2` dan `U2`, kali ini sebagai bagian dari tanda tangan `mixup`. Sekarang kita "
"dapat mencoba fungsi `mixup`:"

#: src/ch08-01-generic-data-types.md:313
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of `Wallet<felt252, u8>`. Then, we call "
"`mixup` and create a new `Wallet<bool, u8>` instance."
msgstr ""
"Pertama, kita membuat dua instans: satu dari `Wallet<bool, u128>` dan yang lain dari `Wallet<felt252, u8>`. "
"Kemudian, kita memanggil `mixup` dan membuat instans baru `Wallet<bool, u8>`."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The blueprint specification includes a set of "
"function signatures containing type annotations for the parameters and return value. This sets a standard to "
"implement the specific functionality."
msgstr ""
"Trait menentukan rancangan fungsionalitas yang dapat diimplementasikan. Spesifikasi rancangan tersebut mencakup "
"serangkaian tanda tangan fungsi yang berisi anotasi tipe untuk parameter dan nilai kembalian. Ini menetapkan "
"standar untuk mengimplementasikan fungsionalitas tertentu."

#: src/ch08-02-traits-in-cairo.md:5
msgid "Defining a Trait"
msgstr "Mendefinisikan Sebuah Trait"

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"To define a trait, you use the keyword `trait` followed by the name of the trait in `PascalCase` then the "
"function signatures in a pair of curly braces."
msgstr ""
"Untuk mendefinisikan sebuah trait, Anda menggunakan kata kunci `trait` diikuti oleh nama trait dalam "
"`PascalCase` dan tanda kurung kurawal yang berisi tanda tangan fungsi."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We want our application to be able to "
"perform geometry operations on these shapes, So we define a trait `ShapeGeometry` that contains a blueprint to "
"implement geometry operations on a shape like this:"
msgstr ""
"Sebagai contoh, misalkan kita memiliki beberapa struct yang mewakili bentuk-bentuk. Kita ingin aplikasi kita "
"dapat melakukan operasi geometri pada bentuk-bentuk tersebut. Jadi, kita mendefinisikan sebuah trait "
"`ShapeGeometry` yang berisi rancangan untuk mengimplementasikan operasi geometri pada suatu bentuk seperti ini:"

#: src/ch08-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods `boundary` and `area`. When implemented, both "
"these functions should return a `u64` and accept parameters as specified by the trait."
msgstr ""
"Di sini, trait `ShapeGeometry` mendeklarasikan tanda tangan untuk dua metode, yaitu `boundary` dan `area`. "
"Ketika diimplementasikan, kedua fungsi ini harus mengembalikan nilai `u64` dan menerima parameter sesuai yang "
"dijelaskan oleh trait."

#: src/ch08-02-traits-in-cairo.md:20
msgid "Implementing a Trait"
msgstr "Melaksanakan Sebuah Trait"

#: src/ch08-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your implementation followed by `of` then the "
"name of trait being implemented. Here's an example implementing `ShapeGeometry` trait."
msgstr ""
"Sebuah trait dapat diimplementasikan menggunakan kata kunci `impl` dengan nama implementasi yang diikuti oleh "
"`of` dan kemudian nama trait yang diimplementasikan. Berikut adalah contoh mengimplementasikan trait "
"`ShapeGeometry`."

#: src/ch08-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` defining what the methods `boundary` "
"and `area` should do. Note that the function parameters and return value types are identical to the trait "
"specification."
msgstr ""
"Dalam kode di atas, `RectangleGeometry` mengimplementasikan trait `ShapeGeometry` dengan mendefinisikan apa yang "
"seharusnya dilakukan oleh metode `boundary` dan `area`. Perhatikan bahwa tipe parameter fungsi dan nilai "
"kembalian identik dengan spesifikasi trait."

#: src/ch08-02-traits-in-cairo.md:37
msgid "Implementing a trait, without writing its declaration."
msgstr "Mengimplementasikan sebuah trait tanpa menuliskan deklarasinya."

#: src/ch08-02-traits-in-cairo.md:39
msgid ""
"You can write implementations directly without defining the corresponding trait. This is made possible by using "
"the `#[generate_trait]` attribute within the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` as a suffix to your trait name, as "
"the compiler will create the trait by adding a `Trait` suffix to the implementation name."
msgstr ""
"Anda dapat menulis implementasi secara langsung tanpa mendefinisikan trait yang sesuai. Ini dimungkinkan dengan "
"menggunakan atribut `#[generate_trait]` dalam implementasi, yang akan membuat kompiler secara otomatis "
"menghasilkan trait yang sesuai dengan implementasi tersebut. Ingatlah untuk menambahkan `Trait` sebagai sufiks "
"pada nama trait Anda, karena kompiler akan membuat trait dengan menambahkan sufiks `Trait` pada nama "
"implementasi."

#: src/ch08-02-traits-in-cairo.md:58
msgid ""
"In the aforementioned code, there is no need to manually define the trait. The compiler will automatically "
"handle its definition, dynamically generating and updating it as new functions are introduced."
msgstr ""
"Dalam kode tersebut, tidak perlu mendefinisikan trait secara manual. Kompiler akan menangani definisinya secara "
"otomatis, menghasilkan dan memperbarui trait secara dinamis ketika fungsi-fungsi baru diperkenalkan."

#: src/ch08-02-traits-in-cairo.md:60
msgid "Parameter `self`"
msgstr "Parameter `self`"

#: src/ch08-02-traits-in-cairo.md:62
msgid ""
"In the example above, `self` is a special parameter. When a parameter with name `self` is used, the implemented "
"functions are also [attached to the instances of the type as methods](ch05-03-method-syntax.md#defining-"
"methods). Here's an illustration,"
msgstr ""
"Dalam contoh di atas, `self` adalah parameter khusus. Ketika sebuah parameter dengan nama `self` digunakan, "
"fungsi-fungsi yang diimplementasikan juga [terlampir pada instansi dari tipe tersebut sebagai metode](ch05-03-"
"method-syntax.md#defining-methods). Berikut adalah ilustrasinya,"

#: src/ch08-02-traits-in-cairo.md:64
msgid ""
"When the `ShapeGeometry` trait is implemented, the function `area` from the `ShapeGeometry` trait can be called "
"in two ways:"
msgstr ""
"Ketika trait `ShapeGeometry` diimplementasikan, fungsi `area` dari trait `ShapeGeometry` dapat dipanggil dengan "
"dua cara:"

#: src/ch08-02-traits-in-cairo.md:90
msgid "// Rectangle instantiation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:92
msgid "// First way, as a method on the struct instance\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:94
msgid "// Second way, from the implementation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:96
msgid "// Third way, from the trait\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:99
msgid "// `area1` has same value as `area2` and `area3`\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:108
msgid "And the implementation of the `area` method will be accessed via the `self` parameter."
msgstr "Dan implementasi metode `area` akan diakses melalui parameter `self`."

#: src/ch08-02-traits-in-cairo.md:110
msgid "Generic Traits"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:112
msgid ""
"Usually we want to write a trait when we want multiple types to implement a functionality in a standard way. "
"However, in the example above the signatures are static and cannot be used for multiple types. To do this, we "
"use generic types when defining traits."
msgstr ""
"Biasanya kita ingin menulis sebuah trait ketika kita ingin banyak tipe mengimplementasikan sebuah fungsionalitas "
"dengan cara standar. Namun, dalam contoh di atas, tanda tangan statis dan tidak dapat digunakan untuk banyak "
"tipe. Untuk melakukannya, kita menggunakan tipe generik saat mendefinisikan trait."

#: src/ch08-02-traits-in-cairo.md:114
msgid ""
"In the example below, we use generic type `T` and our method signatures can use this alias which can be provided "
"during implementation."
msgstr ""
"Pada contoh di bawah, kita menggunakan tipe generik `T` dan tanda tangan metode kita dapat menggunakan alias ini "
"yang dapat diberikan selama implementasi."

#: src/ch08-02-traits-in-cairo.md:129
msgid "// Here T is an alias type which will be provided during implementation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:135
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:146
msgid ""
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:160
msgid "// 35\n"
msgstr "// 35\n"

#: src/ch08-02-traits-in-cairo.md:161
msgid "// 24\n"
msgstr "// 24\n"

#: src/ch08-02-traits-in-cairo.md:164
msgid "// 78\n"
msgstr "// 78\n"

#: src/ch08-02-traits-in-cairo.md:165
msgid "// 31\n"
msgstr "// 31\n"

#: src/ch08-02-traits-in-cairo.md:169
msgid "Managing and using external trait implementations"
msgstr "Mengelola dan Menggunakan Implementasi Trait Eksternal"

#: src/ch08-02-traits-in-cairo.md:171
msgid ""
"To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In the code "
"above we imported `PrintTrait` from `debug` with `use debug::PrintTrait;` to use the `print()` methods on "
"supported types."
msgstr ""
"Untuk menggunakan metode-metode dari trait, Anda perlu memastikan bahwa trait/implementasi yang benar telah "
"diimpor. Pada kode di atas, kita mengimpor `PrintTrait` dari `debug` dengan `use debug::PrintTrait;` untuk "
"menggunakan metode `print()` pada tipe-tipe yang didukung."

#: src/ch08-02-traits-in-cairo.md:173
msgid ""
"In some cases you might need to import not only the trait but also the implementation if they are declared in "
"separate modules. If `CircleGeometry` was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr ""
"Dalam beberapa kasus, Anda mungkin perlu mengimpor tidak hanya trait tetapi juga implementasinya jika mereka "
"dideklarasikan dalam modul terpisah. Jika `CircleGeometry` berada dalam modul/berkas terpisah `circle`, maka "
"untuk menggunakan `boundary` pada `circ: Circle`, kita perlu mengimpor `CircleGeometry` selain dari "
"`ShapeGeometry`."

#: src/ch08-02-traits-in-cairo.md:176
msgid ""
"If the code was organized into modules like this, where the implementation of a trait was defined in a different "
"module than the trait itself, explicitly importing the relevant implementation is required."
msgstr ""
"Jika kode diorganisir ke dalam modul seperti ini, di mana implementasi dari sebuah trait didefinisikan dalam "
"modul yang berbeda dari trait itu sendiri, mengimpor implementasi yang relevan secara eksplisit diperlukan."

#: src/ch08-02-traits-in-cairo.md:180
msgid "// struct Circle { ... } and struct Rectangle { ... }\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:193
msgid "// Could be in a different file\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:206
msgid ""
"// Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:213
msgid "To make it work, in addition to,"
msgstr "Agar dapat berfungsi, selain itu,"

#: src/ch08-02-traits-in-cairo.md:219
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not need to import `RectangleGeometry`, as "
"it is defined in the same module as the imported trait, and thus is automatically resolved."
msgstr ""
"anda perlu mengimpor `CircleGeometry` secara eksplisit. Perhatikan bahwa Anda tidak perlu mengimpor "
"`RectangleGeometry`, karena itu didefinisikan dalam modul yang sama dengan trait yang diimpor, dan oleh karena "
"itu secara otomatis teratasi."

#: src/ch09-01-how-to-write-tests.md:3 src/ch09-01-how-to-write-tests.md:13
msgid "The Anatomy of a Test Function"
msgstr "Anatomi dari Fungsi Pengujian"

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies "
"of test functions typically perform these three actions:"
msgstr ""
"Pengujian adalah fungsi-fungsi Cairo yang memverifikasi bahwa kode non-pengujian berfungsi dengan cara yang "
"diharapkan. Tubuh fungsi pengujian biasanya melakukan tiga tindakan ini:"

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "Menyiapkan data atau keadaan yang diperlukan."

#: src/ch09-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "Menjalankan kode yang ingin diuji."

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "Memeriksa bahwa hasilnya sesuai dengan yang diharapkan."

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests that take these actions, which include "
"the `test` attribute, the `assert` function, and the `should_panic` attribute."
msgstr ""
"Mari kita lihat fitur-fitur yang disediakan oleh Cairo khusus untuk menulis pengujian yang melakukan tiga "
"tindakan ini, termasuk atribut `test`, fungsi `assert`, dan atribut `should_panic`."

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the `test` attribute. Attributes are "
"metadata about pieces of Cairo code; one example is the derive attribute we used with structs in Chapter 5. To "
"change a function into a test function, add `#[test]` on the line before `fn`. When you run your tests with the "
"`scarb cairo-test` command, Scarb runs Cairo's test runner binary that runs the annotated functions and reports "
"on whether each test function passes or fails."
msgstr ""
"Pada dasarnya, sebuah pengujian di Cairo adalah sebuah fungsi yang diannotasikan dengan atribut `test`. Atribut "
"adalah metadata tentang bagian-bagian kode Cairo; salah satu contohnya adalah atribut derive yang kita gunakan "
"dengan struct di Bab 5. Untuk mengubah sebuah fungsi menjadi fungsi pengujian, tambahkan `#[test]` pada baris "
"sebelum `fn`. Ketika Anda menjalankan pengujian dengan perintah `scarb cairo-test`, Scarb menjalankan binary "
"pengujian Cairo yang menjalankan fungsi-fungsi yang diannotasikan dan melaporkan apakah setiap fungsi pengujian "
"lulus atau gagal."

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using Scarb with the command `scarb new "
"adder`:"
msgstr ""
"Mari kita buat proyek baru yang disebut `adder` yang akan menambahkan dua angka menggunakan Scarb dengan "
"perintah `scarb new adder`:"

#: src/ch09-01-how-to-write-tests.md:26
msgid "In _lib.cairo_, let's remove the existing content and add a first test, as shown in Listing 9-1."
msgstr ""
"Di dalam _lib.cairo_, mari hapus konten yang ada dan tambahkan pengujian pertama, seperti yang ditunjukkan pada "
"Listing 9-1."

#: src/ch09-01-how-to-write-tests.md:38
msgid "Listing 9-1: A test module and function"
msgstr "Listing 9-1: Sebuah modul pengujian dan fungsi"

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the `#[test]` annotation: this attribute "
"indicates this is a test function, so the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or perform common operations, so we "
"always need to indicate which functions are tests."
msgstr ""
"Untuk saat ini, mari abaikan dua baris teratas dan fokus pada fungsi. Perhatikan anotasi `#[test]`: atribut ini "
"menunjukkan bahwa ini adalah fungsi pengujian, sehingga runner pengujian tahu untuk memperlakukan fungsi ini "
"sebagai pengujian. Kita mungkin juga memiliki fungsi non-pengujian dalam modul pengujian untuk membantu "
"menyiapkan skenario umum atau melakukan operasi umum, sehingga kita selalu perlu menunjukkan fungsi mana yang "
"merupakan pengujian."

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert` function, which contains the result of adding 2 and 2, equals 4. "
"This assertion serves as an example of the format for a typical test. Let’s run it to see that this test passes."
msgstr ""
"Tubuh fungsi contoh menggunakan fungsi `assert`, yang berisi hasil penambahan 2 dan 2, sama dengan 4. Pernyataan "
"ini berfungsi sebagai contoh format untuk pengujian biasa. Mari jalankan untuk melihat bahwa pengujian ini "
"berhasil."

#: src/ch09-01-how-to-write-tests.md:44
msgid "The `scarb cairo-test` command runs all tests founds in our project, as shown in Listing 9-2."
msgstr ""
"Perintah `scarb cairo-test` menjalankan semua pengujian yang ditemukan dalam proyek kita, seperti yang "
"ditunjukkan pada Listing 9-2."

#: src/ch09-01-how-to-write-tests.md:54
msgid "Listing 9-2: The output from running a test"
msgstr "Listing 9-2: Hasil dari menjalankan sebuah pengujian"

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 tests`. The next line shows the name of "
"the test function, called `it_works`, and that the result of running that test is `ok`. The overall summary "
"`test result: ok.` means that all the tests passed, and the portion that reads `1 passed; 0 failed` totals the "
"number of tests that passed or failed."
msgstr ""
"`scarb cairo-test` mengompilasi dan menjalankan pengujian. Kita melihat baris `running 1 tests`. Baris "
"berikutnya menunjukkan nama fungsi pengujian, yang disebut `it_works`, dan bahwa hasil dari menjalankan "
"pengujian tersebut adalah `ok`. Ringkasan keseluruhan `test result: ok.` berarti bahwa semua pengujian berhasil, "
"dan bagian yang berbunyi `1 passed; 0 failed` menghitung jumlah pengujian yang berhasil atau gagal."

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the "
"[Ignoring Some Tests Unless Specifically Requested](#ignoring-some-tests-unless-specifically-requested) section "
"later in this chapter. Because we haven’t done that here, the summary shows `0 ignored`. We can also pass an "
"argument to the `scarb cairo-test` command to run only a test whose name matches a string; this is called "
"filtering and we’ll cover that in the [Running Single Tests](#running-single-tests) section. We also haven’t "
"filtered the tests being run, so the end of the summary shows `0 filtered out`."
msgstr ""
"Mungkin untuk menandai pengujian sebagai diabaikan sehingga tidak dijalankan dalam suatu instansi tertentu; kita "
"akan mencakup hal ini di bagian [Mengabaikan Beberapa Pengujian Kecuali Diminta Secara Khusus](#mengabaikan-"
"beberapa-pengujian-kecuali-diminta-secara-khusus) nanti dalam bab ini. Karena kita belum melakukannya di sini, "
"ringkasan menunjukkan `0 diabaikan`. Kita juga dapat melewatkan argumen ke perintah `scarb cairo-test` untuk "
"menjalankan hanya pengujian yang namanya cocok dengan string; ini disebut sebagai penyaringan dan akan kita "
"bahas di bagian [Menjalankan Pengujian Tunggal](#menjalankan-pengujian-tunggal). Kita juga belum menyaring "
"pengujian yang dijalankan, sehingga akhir ringkasan menunjukkan `0 disaring`."

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of the `it_works` function to a "
"different name, such as `exploration`, like so:"
msgstr ""
"Mari mulai menyesuaikan pengujian sesuai kebutuhan kita. Pertama, ubah nama fungsi `it_works` menjadi nama lain, "
"misalnya `exploration`, seperti ini:"

#: src/ch09-01-how-to-write-tests.md:72
msgid "Then run `scarb cairo-test` again. The output now shows `exploration` instead of `it_works`:"
msgstr "Kemudian jalankan `scarb cairo-test` lagi. Output sekarang menunjukkan `exploration` alih-alih `it_works`:"

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test "
"function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, "
"the test is marked as failed. Enter the new test as a function named `another`, so your _src/lib.cairo_ file "
"looks like Listing 9-3."
msgstr ""
"Sekarang kita akan menambahkan pengujian lain, tapi kali ini kita akan membuat pengujian yang gagal! Pengujian "
"gagal ketika ada sesuatu yang panik dalam fungsi pengujian. Setiap pengujian dijalankan dalam thread baru, dan "
"ketika thread utama melihat bahwa thread pengujian telah mati, pengujian ditandai sebagai gagal. Masukkan "
"pengujian baru sebagai fungsi bernama `another`, sehingga berkas _src/lib.cairo_ Anda terlihat seperti Listing "
"9-3."

#: src/ch09-01-how-to-write-tests.md:92
msgid "Listing 9-3: Adding a second test that will fail"
msgstr "Listing 9-3: Menambahkan tes kedua yang akan gagal"

#: src/ch09-01-how-to-write-tests.md:104
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr "Listing 9-4: Hasil tes ketika satu tes berhasil dan satu tes gagal"

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new section appears between the "
"individual results and the summary. It displays the detailed reason for each test failure. In this case, we get "
"the details that `another` failed because it panicked with `[1725643816656041371866211894343434536761780588 "
"('Make this test fail'), ]` in the _src/lib.cairo_ file."
msgstr ""
"Alih-alih `ok`, baris `adder::lib::tests::another` menunjukkan `fail`. Sebuah bagian baru muncul di antara hasil "
"individu dan ringkasan. Ini menampilkan alasan rinci untuk setiap kegagalan tes. Dalam kasus ini, kita "
"mendapatkan detail bahwa `another` gagal karena terjadi panic dengan "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` di dalam file _src/lib.cairo_."

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. We had one test pass and one test "
"fail."
msgstr ""
"Baris ringkasan ditampilkan di akhir: secara keseluruhan, hasil tes kita adalah `GAGAL`. Kita memiliki satu tes "
"yang berhasil dan satu tes yang gagal."

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, let’s look at some functions that "
"are useful in tests."
msgstr ""
"Sekarang setelah Anda telah melihat bagaimana hasil tes terlihat dalam skenario yang berbeda, mari kita lihat "
"beberapa fungsi yang berguna dalam tes."

#: src/ch09-01-how-to-write-tests.md:112
msgid "Checking Results with the assert function"
msgstr "Memeriksa Hasil dengan Fungsi assert"

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure that some condition in a test "
"evaluates to `true`. We give the `assert` function a first argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the assert function calls `panic()` to "
"cause the test to fail with a message we defined as the second argument of the `assert` function. Using the "
"`assert` function helps us check that our code is functioning in the way we intend."
msgstr ""
"Fungsi `assert`, yang disediakan oleh Cairo, berguna ketika Anda ingin memastikan bahwa kondisi tertentu dalam "
"tes dievaluasi sebagai `true`. Kami memberikan fungsi `assert` argumen pertama yang dievaluasi sebagai Boolean. "
"Jika nilai tersebut adalah `true`, tidak ada yang terjadi dan tes berhasil. Jika nilai tersebut adalah `false`, "
"fungsi assert memanggil `panic()` untuk menyebabkan tes gagal dengan pesan yang kita tentukan sebagai argumen "
"kedua dari fungsi `assert`. Menggunakan fungsi `assert` membantu kami memeriksa bahwa kode kita berfungsi sesuai "
"yang kami inginkan."

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-15](ch05-03-method-syntax.md#multiple-impl-blocks), we used a `Rectangle` struct and a "
"`can_hold` method, which are repeated here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert` function."
msgstr ""
"Pada [Bab 5, Listing 5-15](ch05-03-method-syntax.md#multiple-impl-blocks), kita menggunakan struktur `Rectangle` "
"dan metode `can_hold`, yang diulang di sini pada Listing 9-5. Mari letakkan kode ini dalam file _src/lib.cairo_, "
"lalu tulis beberapa tes untuknya menggunakan fungsi `assert`."

#: src/ch09-01-how-to-write-tests.md:137
msgid "Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from Chapter 5"
msgstr "Listing 9-5: Menggunakan struktur `Rectangle` dan metodenya `can_hold` dari Bab 5"

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case for the assert function. In Listing "
"9-6, we write a test that exercises the `can_hold` method by creating a `Rectangle` instance that has a width of "
"`8` and a height of `7` and asserting that it can hold another `Rectangle` instance that has a width of `5` and "
"a height of `1`."
msgstr ""
"Metode `can_hold` mengembalikan `bool`, yang berarti ini adalah penggunaan yang sempurna untuk fungsi assert. "
"Pada Listing 9-6, kita menulis tes yang menggunakan metode `can_hold` dengan membuat instans `Rectangle` yang "
"memiliki lebar `8` dan tinggi `7`, serta mengasertakan bahwa itu dapat menahan instans `Rectangle` lain yang "
"memiliki lebar `5` dan tinggi `1`."

#: src/ch09-01-how-to-write-tests.md:192
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle"
msgstr ""
"Listing 9-6: Tes untuk `can_hold` yang memeriksa apakah suatu persegi panjang yang lebih besar dapat benar-benar "
"menahan persegi panjang yang lebih kecil"

#: src/ch09-01-how-to-write-tests.md:194
msgid ""
"Note that we’ve added two new lines inside the tests module: `use super::Rectangle;` and `use super::"
"RectangleTrait;`. The tests module is a regular module that follows the usual visibility rules. Because the "
"tests module is an inner module, we need to bring the code under test in the outer module into the scope of the "
"inner module."
msgstr ""
"Perhatikan bahwa kami telah menambahkan dua baris baru di dalam modul tes: `use super::Rectangle;` dan `use "
"super::RectangleTrait;`. Modul tes adalah modul biasa yang mengikuti aturan visibilitas biasa. Karena modul tes "
"adalah modul dalam, kita perlu membawa kode yang sedang diuji di modul luar ke dalam cakupan modul dalam "
"tersebut."

#: src/ch09-01-how-to-write-tests.md:196
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two `Rectangle` instances that we need. "
"Then we called the assert function and passed it the result of calling `larger.can_hold(@smaller)`. This "
"expression is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"Kami memberi nama tes kami `larger_can_hold_smaller`, dan kami telah membuat dua instans `Rectangle` yang kita "
"perlukan. Kemudian, kami memanggil fungsi assert dan meneruskannya dengan hasil pemanggilan `larger."
"can_hold(@smaller)`. Ekspresi ini seharusnya mengembalikan `true`, jadi tes kami seharusnya berhasil. Mari kita "
"lihat!"

#: src/ch09-01-how-to-write-tests.md:205
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger "
"rectangle:"
msgstr ""
"Tes tersebut berhasil! Mari tambahkan tes lain, kali ini mengasertakan bahwa sebuah persegi panjang yang lebih "
"kecil tidak dapat menahan sebuah persegi panjang yang lebih besar:"

#: src/ch09-01-how-to-write-tests.md:258
msgid ""
"Because the correct result of the `can_hold` function in this case is `false`, we need to negate that result "
"before we pass it to the assert function. As a result, our test will pass if `can_hold` returns false:"
msgstr ""
"Karena hasil yang benar dari fungsi `can_hold` dalam kasus ini adalah `false`, kita perlu menegasi hasil "
"tersebut sebelum kita meneruskannya ke fungsi assert. Sebagai hasilnya, tes kita akan berhasil jika `can_hold` "
"mengembalikan false:"

#: src/ch09-01-how-to-write-tests.md:268
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll "
"change the implementation of the `can_hold` method by replacing the greater-than sign with a less-than sign when "
"it compares the widths:"
msgstr ""
"Dua tes yang berhasil! Sekarang mari kita lihat apa yang terjadi pada hasil tes kita ketika kita memperkenalkan "
"bug dalam kode kita. Kita akan mengubah implementasi metode `can_hold` dengan mengganti tanda greater-than "
"dengan tanda less-than ketika membandingkan lebar:"

#: src/ch09-01-how-to-write-tests.md:282
msgid "Running the tests now produces the following:"
msgstr "Menjalankan tes sekarang menghasilkan yang berikut:"

#: src/ch09-01-how-to-write-tests.md:295
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` is `5`, the comparison of the widths "
"in `can_hold` now returns `false`: `8` is not less than `5`."
msgstr ""
"Tes kita menangkap bug tersebut! Karena `larger.width` adalah `8` dan `smaller.width` adalah `5`, perbandingan "
"lebar dalam `can_hold` sekarang mengembalikan `false`: `8` tidak kurang dari `5`."

#: src/ch09-01-how-to-write-tests.md:297
msgid "Checking for panics with `should_panic`"
msgstr "Memeriksa panic dengan `should_panic`"

#: src/ch09-01-how-to-write-tests.md:299
msgid ""
"In addition to checking return values, it’s important to check that our code handles error conditions as we "
"expect. For example, consider the Guess type in Listing 9-8. Other code that uses `Guess` depends on the "
"guarantee that `Guess` instances will contain only values between `1` and `100`. We can write a test that "
"ensures that attempting to create a `Guess` instance with a value outside that range panics."
msgstr ""
"Selain memeriksa nilai kembalian, penting untuk memeriksa bahwa kode kita menangani kondisi error sesuai yang "
"diharapkan. Sebagai contoh, pertimbangkan tipe Guess pada Listing 9-8. Kode lain yang menggunakan `Guess` "
"bergantung pada jaminan bahwa instans `Guess` hanya akan berisi nilai antara `1` dan `100`. Kita dapat menulis "
"tes yang memastikan upaya membuat instans `Guess` dengan nilai di luar jangkauan tersebut akan menyebabkan panic."

#: src/ch09-01-how-to-write-tests.md:301
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The test passes if the code inside the "
"function panics; the test fails if the code inside the function doesn’t panic."
msgstr ""
"Kita melakukan ini dengan menambahkan atribut `should_panic` ke fungsi tes kita. Tes tersebut berhasil jika kode "
"di dalam fungsi menyebabkan panic; tes tersebut gagal jika kode di dalam fungsi tidak menyebabkan panic."

#: src/ch09-01-how-to-write-tests.md:303
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of `GuessTrait::new` happen when we expect them "
"to."
msgstr ""
"Listing 9-8 menunjukkan tes yang memeriksa bahwa kondisi error dari `GuessTrait::new` terjadi ketika kita "
"mengharapkannya."

#: src/ch09-01-how-to-write-tests.md:341
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr "Listing 9-8: Menguji bahwa suatu kondisi akan menyebabkan panic"

#: src/ch09-01-how-to-write-tests.md:343
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and before the test function it applies "
"to. Let’s look at the result when this test passes:"
msgstr ""
"Kita menempatkan atribut `#[should_panic]` setelah atribut `#[test]` dan sebelum fungsi tes yang diterapkannya. "
"Mari kita lihat hasilnya ketika tes ini berhasil:"

#: src/ch09-01-how-to-write-tests.md:352
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition that the new function will panic if "
"the value is greater than `100`:"
msgstr ""
"Terlihat baik! Sekarang mari kita perkenalkan bug dalam kode kita dengan menghapus kondisi bahwa fungsi baru "
"akan panic jika nilai lebih besar dari `100`:"

#: src/ch09-01-how-to-write-tests.md:379
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr "Ketika kita menjalankan tes pada Listing 9-8, itu akan gagal:"

#: src/ch09-01-how-to-write-tests.md:390
msgid ""
"We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s "
"annotated with `#[should_panic]`. The failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""
"Kita tidak mendapatkan pesan yang sangat membantu dalam kasus ini, tetapi ketika kita melihat fungsi tes, kita "
"melihat bahwa itu diberi anotasi `#[should_panic]`. Kegagalan yang kita dapatkan berarti bahwa kode dalam fungsi "
"tes tidak menyebabkan panic."

#: src/ch09-01-how-to-write-tests.md:392
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would pass even if the test panics for a "
"different reason from the one we were expecting. To make `should_panic` tests more precise, we can add an "
"optional expected parameter to the `should_panic` attribute. The test harness will make sure that the failure "
"message contains the provided text. For example, consider the modified code for `Guess` in Listing 9-9 where the "
"new function panics with different messages depending on whether the value is too small or too large."
msgstr ""
"Tes yang menggunakan `should_panic` bisa tidak presisi. Sebuah tes `should_panic` akan lulus bahkan jika tes "
"menyebabkan panic karena alasan yang berbeda dari yang kita harapkan. Untuk membuat tes `should_panic` lebih "
"presisi, kita dapat menambahkan parameter opsional yang diharapkan ke atribut `should_panic`. Harness tes akan "
"memastikan bahwa pesan kegagalan berisi teks yang diberikan. Sebagai contoh, pertimbangkan kode yang "
"dimodifikasi untuk `Guess` pada Listing 9-9 di mana fungsi baru menyebabkan panic dengan pesan yang berbeda "
"tergantung pada apakah nilai terlalu kecil atau terlalu besar."

#: src/ch09-01-how-to-write-tests.md:433
msgid "Listing 9-9: Testing for a panic with a panic message containing the error message string"
msgstr "Listing 9-9: Menguji untuk panic dengan pesan panic yang berisi string pesan kesalahan"

#: src/ch09-01-how-to-write-tests.md:435
msgid ""
"This test will pass because the value we put in the `should_panic` attribute’s expected parameter is the array "
"of string of the message that the `Guess::new` function panics with. We need to specify the entire panic message "
"that we expect."
msgstr ""
"Tes ini akan berhasil karena nilai yang kita masukkan ke dalam parameter yang diharapkan dari atribut "
"`should_panic` adalah array string dari pesan yang menyebabkan panic pada fungsi `Guess::new`. Kita perlu "
"menentukan seluruh pesan panic yang kita harapkan."

#: src/ch09-01-how-to-write-tests.md:437
msgid ""
"To see what happens when a `should_panic` test with an expected message fails, let’s again introduce a bug into "
"our code by swapping the bodies of the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""
"Untuk melihat apa yang terjadi ketika tes `should_panic` dengan pesan yang diharapkan gagal, mari lagi "
"memperkenalkan bug ke dalam kode kita dengan menukar isi blok if `value < 1` dan blok else if `value > 100`:"

#: src/ch09-01-how-to-write-tests.md:469
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "Kali ini ketika kita menjalankan tes `should_panic`, itu akan gagal:"

#: src/ch09-01-how-to-write-tests.md:481
msgid ""
"The failure message indicates that this test did indeed panic as we expected, but the panic message did not "
"include the expected string. The panic message that we did get in this case was `Guess must be >= 1`. Now we can "
"start figuring out where our bug is!"
msgstr ""
"Pesan kegagalan menunjukkan bahwa tes ini memang menyebabkan panic seperti yang kita harapkan, tetapi pesan "
"panic tidak mencakup string yang diharapkan. Pesan panic yang kita dapatkan dalam kasus ini adalah `Guess must "
"be >= 1`. Sekarang kita dapat mulai mencari tahu di mana bug kita berada!"

#: src/ch09-01-how-to-write-tests.md:483
msgid "Running Single Tests"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:485
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you "
"might want to run only the tests pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the test you want to run as an argument."
msgstr ""
"Terkadang, menjalankan seluruh rangkaian tes bisa memakan waktu lama. Jika Anda sedang bekerja pada kode di area "
"tertentu, Anda mungkin hanya ingin menjalankan tes yang berkaitan dengan kode tersebut. Anda dapat memilih tes "
"mana yang akan dijalankan dengan memberikan opsi `-f` (untuk \"filter\") kepada `scarb cairo-test`, diikuti "
"dengan nama tes yang ingin Anda jalankan sebagai argumen."

#: src/ch09-01-how-to-write-tests.md:487
msgid ""
"To demonstrate how to run a single test, we’ll first create two tests functions, as shown in Listing 9-10, and "
"choose which ones to run."
msgstr ""
"Untuk menunjukkan bagaimana menjalankan satu tes saja, pertama-tama kita akan membuat dua fungsi tes, seperti "
"yang ditunjukkan pada Listing 9-10, dan memilih mana yang akan dijalankan."

#: src/ch09-01-how-to-write-tests.md:508
msgid "Listing 9-10: Two tests with two different names"
msgstr "Listing 9-10: Dua tes dengan dua nama berbeda"

#: src/ch09-01-how-to-write-tests.md:510
msgid "We can pass the name of any test function to `cairo-test` to run only that test using the `-f` flag:"
msgstr ""
"Kita dapat melewatkan nama fungsi tes apa pun ke `cairo-test` untuk menjalankan hanya tes tersebut menggunakan "
"flag `-f`:"

#: src/ch09-01-how-to-write-tests.md:519
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t match that name. The test output lets "
"us know we had one more test that didn’t run by displaying 1 filtered out at the end."
msgstr ""
"Hanya tes dengan nama `add_two_and_two` yang dijalankan; tes lainnya tidak cocok dengan nama tersebut. Output "
"tes memberi tahu kita bahwa ada satu tes lagi yang tidak dijalankan dengan menampilkan 1 filtered out di akhir."

#: src/ch09-01-how-to-write-tests.md:521
msgid "We can also specify part of a test name, and any test whose name contains that value will be run."
msgstr "Kalimat tersebut dapat diterjemahkan ke dalam bahasa Indonesia sebagai berikut:."

#: src/ch09-01-how-to-write-tests.md:523
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "\"Mengabaikan Beberapa Uji Coba Kecuali Diminta Secara Khusus\""

#: src/ch09-01-how-to-write-tests.md:525
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during "
"most runs of `scarb cairo-test`. Rather than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude them, as shown here:"
msgstr ""
"Kadang-kadang beberapa uji coba tertentu dapat memakan banyak waktu untuk dieksekusi, jadi Anda mungkin ingin "
"mengecualikannya selama sebagian besar dari jalannya `scarb cairo-test`. Alih-alih menyebutkan sebagai argumen "
"semua uji coba yang ingin Anda jalankan, Anda dapat menandai uji coba yang memakan banyak waktu menggunakan "
"atribut `ignore` untuk mengecualikannya, seperti yang ditunjukkan di sini:"

#: src/ch09-01-how-to-write-tests.md:540
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:545
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now when we run our tests, "
"`it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"Setelah `#[test]` kita tambahkan baris `#[ignore]` ke uji coba yang ingin kita eksklusikan. Sekarang ketika kita "
"menjalankan uji coba kita, `it_works` berjalan, tetapi `expensive_test` tidak:"

#: src/ch09-01-how-to-write-tests.md:555
msgid "The `expensive_test` function is listed as ignored."
msgstr "Fungsi `expensive_test` terdaftar sebagai diabaikan."

#: src/ch09-01-how-to-write-tests.md:557
msgid ""
"When you’re at a point where it makes sense to check the results of the ignored tests and you have time to wait "
"for the results, you can run `scarb cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""
"Ketika Anda sudah pada titik di mana ada alasan untuk memeriksa hasil dari uji coba yang diabaikan dan Anda "
"memiliki waktu untuk menunggu hasilnya, Anda dapat menjalankan `scarb cairo-test --include-ignored` untuk "
"menjalankan semua uji coba, baik yang diabaikan maupun tidak."

#: src/ch09-01-how-to-write-tests.md:559
msgid "Testing recursive functions or loops"
msgstr "Menguji fungsi rekursif atau perulangan"

#: src/ch09-01-how-to-write-tests.md:561
msgid ""
"When testing recursive functions or loops, you must provide the test with a maximum amount of gas that it can "
"consume. This prevents running infinite loops or consuming too much gas, and can help you benchmark the "
"efficiency of your implementations. To do so, you must add the `#[available_gas(<Number>)]` attribute on the "
"test function. The following example shows how to use it:"
msgstr ""
"Saat menguji fungsi rekursif atau perulangan, Anda harus memberikan jumlah gas maksimum yang dapat dikonsumsi "
"oleh uji coba. Hal ini mencegah terjadinya perulangan tak terbatas atau penggunaan gas yang berlebihan, dan "
"dapat membantu Anda dalam mengukur efisiensi implementasi Anda. Untuk melakukannya, Anda harus menambahkan "
"atribut `#[available_gas(<Angka>)]` pada fungsi uji coba. Berikut adalah contoh penggunaannya:"

#: src/ch09-01-how-to-write-tests.md:592
msgid "Benchmarking the gas usage of a specific operation"
msgstr "Membenchmark penggunaan gas dari sebuah operasi tertentu"

#: src/ch09-01-how-to-write-tests.md:594
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can use the following pattern in your test "
"function."
msgstr ""
"Ketika Anda ingin melakukan benchmark terhadap penggunaan gas dari suatu operasi tertentu, Anda dapat "
"menggunakan pola berikut dalam fungsi uji coba Anda."

#: src/ch09-01-how-to-write-tests.md:599 src/ch09-01-how-to-write-tests.md:629
msgid "/// code we want to bench.\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:603
msgid "The following example shows how to use it to test the gas function of the `sum_n` function above."
msgstr ""
"Contoh berikut menunjukkan bagaimana cara menggunakannya untuk menguji fungsi gas dari fungsi `sum_n` di atas."

#: src/ch09-01-how-to-write-tests.md:636
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that was consumed by the operation "
"benchmarked."
msgstr ""
"Nilai yang tercetak saat menjalankan `scarb cairo-test` adalah jumlah gas yang dikonsumsi oleh operasi yang di-"
"benchmark."

#: src/ch09-01-how-to-write-tests.md:649
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation of the hex number). The total "
"amount consumed by the test is slightly higher at 98030, due to some extra steps required to run the entire test "
"function."
msgstr ""
"Di sini, penggunaan gas dari fungsi `sum_n` adalah 96760 (representasi desimal dari angka heksadesimal). Total "
"yang dikonsumsi oleh uji coba sedikit lebih tinggi pada 98030, karena beberapa langkah tambahan yang diperlukan "
"untuk menjalankan keseluruhan fungsi uji coba."

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small "
"and more focused, testing one module in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's good practice to start organizing "
"your code as if it were. Integration tests use your code in the same way any other external code would, using "
"only the public interface and potentially exercising multiple modules per test."
msgstr ""
"Kita akan memikirkan uji coba dalam dua kategori utama: uji coba unit dan uji coba integrasi. Uji coba unit "
"adalah uji coba yang kecil dan lebih terfokus, menguji satu modul pada satu waktu secara terisolasi, dan dapat "
"menguji fungsi-fungsi privat. Meskipun Cairo belum menerapkan konsep fungsi/field publik/privat, adalah praktik "
"yang baik untuk mulai mengorganisir kode Anda seolah-olah itu ada. Uji coba integrasi menggunakan kode Anda "
"dengan cara yang sama seperti kode eksternal lainnya, hanya menggunakan antarmuka publik dan mungkin melibatkan "
"beberapa modul dalam satu uji coba."

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect "
"them to, separately and together."
msgstr ""
"Menulis kedua jenis uji coba tersebut penting untuk memastikan bahwa bagian-bagian dari perpustakaan Anda "
"melakukan apa yang Anda harapkan, baik secara terpisah maupun bersama-sama."

#: src/ch09-02-test-organization.md:7
msgid "Unit Tests"
msgstr ""

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly "
"pinpoint where code is and isn’t working as expected. You’ll put unit tests in the `src` directory in each file "
"with the code that they’re testing."
msgstr ""
"Tujuan dari uji coba unit adalah untuk menguji setiap unit kode secara terisolasi dari bagian lain kode untuk "
"dengan cepat menemukan di mana kode bekerja dan tidak bekerja sesuai harapan. Anda akan menempatkan uji coba "
"unit di dalam direktori `src` pada setiap file dengan kode yang mereka uji."

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the test functions and to annotate the "
"module with `cfg(test)`."
msgstr ""
"Konvensinya adalah membuat modul bernama tests di setiap file untuk menampung fungsi-fungsi uji coba dan memberi "
"anotasi modul dengan `cfg(test)`."

#: src/ch09-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run "
"`scarb cairo-test`, not when you run `cairo-run`. This saves compile time when you only want to build the "
"library and saves space in the resulting compiled artifact because the tests are not included. You’ll see that "
"because integration tests go in a different directory, they don’t need the `#[cfg(test)]` annotation. However, "
"because unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to specify that they shouldn’t be "
"included in the compiled result."
msgstr ""
"Anotasi `#[cfg(test)]` pada modul uji coba memberitahu Cairo untuk mengompilasi dan menjalankan kode uji coba "
"hanya saat Anda menjalankan `scarb cairo-test`, bukan saat Anda menjalankan `cairo-run`. Ini menghemat waktu "
"kompilasi saat Anda hanya ingin membangun perpustakaan dan menghemat ruang dalam artefak hasil kompilasi karena "
"uji coba tidak disertakan. Anda akan melihat bahwa karena uji coba integrasi berada di direktori yang berbeda, "
"mereka tidak memerlukan anotasi `#[cfg(test)]`. Namun, karena uji coba unit berada dalam file yang sama dengan "
"kode, Anda akan menggunakan `#[cfg(test)]` untuk menentukan bahwa mereka tidak harus disertakan dalam hasil yang "
"dikompilasi."

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of this chapter, we wrote this first "
"test:"
msgstr ""
"Ingat bahwa ketika kita membuat proyek `adder` baru pada bagian pertama dari bab ini, kita menulis uji coba "
"pertama ini:"

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the following item should only be included "
"given a certain configuration option. In this case, the configuration option is `test`, which is provided by "
"Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we "
"actively run the tests with `scarb cairo-test`. This includes any helper functions that might be within this "
"module, in addition to the functions annotated with `#[test]`."
msgstr ""
"Atribut `cfg` singkatan dari konfigurasi dan memberi tahu Cairo bahwa item berikutnya hanya akan disertakan "
"dengan opsi konfigurasi tertentu. Dalam hal ini, opsi konfigurasinya adalah `test`, yang disediakan oleh Cairo "
"untuk mengompilasi dan menjalankan uji coba. Dengan menggunakan atribut `cfg`, Cairo mengompilasi kode uji coba "
"kita hanya jika kita secara aktif menjalankan uji coba dengan `scarb cairo-test`. Ini termasuk fungsi bantu apa "
"pun yang mungkin ada dalam modul ini, selain fungsi-fungsi yang diberi anotasi `#[test]`."

#: src/ch09-02-test-organization.md:34
msgid "Integration Tests"
msgstr ""

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. Their purpose is to test whether many "
"parts of your library work together correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is important as well. To create integration "
"tests, you first need a `tests` directory."
msgstr ""
"Uji coba integrasi menggunakan perpustakaan Anda dengan cara yang sama seperti kode lainnya. Tujuan mereka "
"adalah untuk menguji apakah banyak bagian dari perpustakaan Anda bekerja bersama dengan benar. Unit kode yang "
"bekerja dengan benar secara independen bisa memiliki masalah saat diintegrasikan, sehingga cakupan uji dari kode "
"terintegrasi juga penting. Untuk membuat uji coba integrasi, pertama-tama Anda memerlukan direktori `tests`."

#: src/ch09-02-test-organization.md:38
msgid "The `tests` Directory"
msgstr "`Tests` Directory"

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:68
msgid "Enter the code in Listing 9-11 into the _src/tests/integration_tests.cairo_ file:"
msgstr "Masukkan kode dalam Listing 9-11 ke dalam file _src/tests/integration_tests.cairo_:"

#: src/ch09-02-test-organization.md:80
msgid "Filename: src/tests/integration_tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:82
msgid ""
"We need to bring our tested functions into each test file scope. For that reason we add `use adder::it_adds_two` "
"at the top of the code, which we didn’t need in the unit tests."
msgstr ""
"Kita perlu membawa fungsi-fungsi yang diuji ke dalam ruang lingkup setiap file uji coba. Untuk alasan itu, kita "
"tambahkan `use adder::it_adds_two` di bagian atas kode, yang tidak kita perlukan dalam uji coba unit."

#: src/ch09-02-test-organization.md:84
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains "
"\"integration_tests\"."
msgstr ""
"Kemudian, untuk menjalankan semua uji coba integrasi kita, kita cukup menambahkan filter untuk hanya menjalankan "
"uji coba yang jalurnya mengandung \"integration_tests\"."

#: src/ch09-02-test-organization.md:95
msgid "The result of the tests is the same as what we've been seeing: one line for each test."
msgstr ""
"Hasil dari uji coba tersebut sama seperti yang telah kita lihat sebelumnya: satu baris untuk setiap uji coba."

#: src/ch10-00-error-handling.md:1
msgid "Error handling"
msgstr ""

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you "
"to address potential issues in your code, but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as pattern matching with the Result "
"enum, using the ? operator for more ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. These "
"concepts are crucial for building robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""
"Pada bab ini, kita akan menjelajahi berbagai teknik penanganan kesalahan yang disediakan oleh Cairo, yang tidak "
"hanya memungkinkan Anda untuk mengatasi masalah potensial dalam kode Anda, tetapi juga membuat lebih mudah untuk "
"membuat program yang dapat beradaptasi dan mudah dipelihara. Dengan memeriksa berbagai pendekatan dalam "
"mengelola kesalahan, seperti pencocokan pola dengan enum Result, menggunakan operator ? untuk penyebaran "
"kesalahan yang lebih ergonomis, dan menggunakan metode unwrap atau expect untuk penanganan kesalahan yang dapat "
"dipulihkan, Anda akan mendapatkan pemahaman yang lebih mendalam tentang fitur penanganan kesalahan Cairo. Konsep-"
"konsep ini penting untuk membangun aplikasi yang tangguh yang dapat mengatasi situasi yang tidak terduga dengan "
"efektif, sehingga memastikan kode Anda siap untuk produksi."

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in runtime errors. While the panic "
"function from the core library doesn't provide a resolution for these errors, it does acknowledge their "
"occurrence and terminates the program. There are two primary ways that a panic can be triggered in Cairo: "
"inadvertently, through actions causing the code to panic (e.g., accessing an array beyond its bounds), or "
"deliberately, by invoking the panic function."
msgstr ""
"Di Cairo, masalah yang tidak terduga dapat muncul selama eksekusi program, yang mengakibatkan kesalahan saat "
"runtime. Meskipun fungsi panic dari pustaka inti tidak memberikan solusi untuk kesalahan ini, ia mengakui "
"keberadaan kesalahan tersebut dan menghentikan program. Ada dua cara utama yang dapat menyebabkan panic terjadi "
"di Cairo: secara tidak sengaja, melalui tindakan yang menyebabkan kode panic (misalnya, mengakses array melebihi "
"batasnya), atau secara sengaja, dengan memanggil fungsi panic."

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The `panic` function takes an array as an "
"argument, which can be used to provide an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to safely terminate the execution."
msgstr ""
"Ketika terjadi panic, itu mengakibatkan penghentian tiba-tiba dari program. Fungsi `panic` mengambil array "
"sebagai argumen, yang dapat digunakan untuk menyediakan pesan kesalahan dan melakukan proses unwind di mana "
"semua variabel dihapus dan kamus-kamus dirombak untuk memastikan keselamatan program agar dapat menghentikan "
"eksekusi dengan aman."

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid "Here is how we can `panic` from inside a program and return the error code `2`:"
msgstr ""
"Berikut adalah cara kita dapat melakukan `panic` dari dalam sebuah program dan mengembalikan kode kesalahan `2`:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:24
msgid "Running the program will produce the following output:"
msgstr "Menjalankan program akan menghasilkan keluaran berikut:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"As you can notice in the output, the print statement is never reached, as the program terminates after "
"encountering the `panic` statement."
msgstr ""
"Seperti yang dapat Anda perhatikan pada keluaran, pernyataan cetak tidak pernah tercapai, karena program "
"berhenti setelah menemui pernyataan `panic`."

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use the `panic_with_felt252` function. "
"This function serves as an abstraction of the array-defining process and is often preferred due to its clearer "
"and more concise expression of intent. By using `panic_with_felt252`, developers can panic in a one-liner by "
"providing a felt252 error message as an argument, making the code more readable and maintainable."
msgstr ""
"Pendekatan alternatif dan lebih idiomatik untuk panic dalam Cairo adalah dengan menggunakan fungsi "
"`panic_with_felt252`. Fungsi ini berfungsi sebagai abstraksi dari proses definisi array dan sering dipilih "
"karena penjelasan maksud yang lebih jelas dan ringkas. Dengan menggunakan `panic_with_felt252`, para pengembang "
"dapat melakukan panic dalam satu baris dengan menyediakan pesan kesalahan felt252 sebagai argumen, membuat kode "
"menjadi lebih mudah dibaca dan dipelihara."

#: src/ch10-01-unrecoverable-errors-with-panic.md:35
msgid "Let's consider an example:"
msgstr "Mari kita pertimbangkan sebuah contoh:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that case, if there is no need for an "
"array and multiple values to be returned within the error, so `panic_with_felt252` is a more succinct "
"alternative."
msgstr ""
"Menjalankan program ini akan menghasilkan pesan kesalahan yang sama seperti sebelumnya. Dalam kasus tersebut, "
"jika tidak ada kebutuhan untuk sebuah array dan beberapa nilai yang akan dikembalikan dalam kesalahan, maka "
"`panic_with_felt252` adalah alternatif yang lebih singkat."

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "nopanic notation"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"You can use the `nopanic` notation to indicate that a function will never panic. Only `nopanic` functions can be "
"called in a function annotated as `nopanic`."
msgstr ""
"Anda dapat menggunakan notasi `nopanic` untuk menunjukkan bahwa sebuah fungsi tidak akan pernah panic. Hanya "
"fungsi-fungsi `nopanic` yang dapat dipanggil dalam sebuah fungsi yang diberi anotasi `nopanic`."

#: src/ch10-01-unrecoverable-errors-with-panic.md:49 src/ch10-01-unrecoverable-errors-with-panic.md:84
#: src/appendix-03-derivable-traits.md:17 src/appendix-03-derivable-traits.md:42
#: src/appendix-03-derivable-traits.md:63 src/appendix-03-derivable-traits.md:85
#: src/appendix-03-derivable-traits.md:118 src/appendix-03-derivable-traits.md:155
msgid "Example:"
msgstr "Contoh:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:57
msgid "Wrong example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:65
msgid ""
"If you write the following function that includes a function that may panic you will get the following error:"
msgstr ""
"Jika Anda menulis fungsi berikut yang mencakup sebuah fungsi yang mungkin panic, Anda akan mendapatkan pesan "
"kesalahan berikut:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:78
msgid "Note that there are two functions that may panic here, assert and equality."
msgstr "Perlu diingat bahwa ada dua fungsi yang mungkin panic di sini, yaitu assert dan equality."

#: src/ch10-01-unrecoverable-errors-with-panic.md:80
msgid "panic_with attribute"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:82
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an `Option` or `Result`. This attribute "
"takes two arguments, which are the data that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will panic if the function returns `None` "
"or `Err`, the panic function will be called with the given data."
msgstr ""
"Anda dapat menggunakan atribut `panic_with` untuk menandai sebuah fungsi yang mengembalikan `Option` atau "
"`Result`. Atribut ini mengambil dua argumen, yaitu data yang akan dipindahkan sebagai alasan panic serta nama "
"untuk fungsi pembungkus. Ini akan membuat pembungkus untuk fungsi yang Anda anotasi yang akan panic jika fungsi "
"tersebut mengembalikan `None` atau `Err`, fungsi panic akan dipanggil dengan data yang diberikan."

#: src/ch10-01-unrecoverable-errors-with-panic.md:97
msgid "// this returns None\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:98
msgid "// this panics with 'value is 0'\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:102
msgid "Using assert"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:104
msgid ""
"The assert function from the Cairo core library is actually a utility function based on panics. It asserts that "
"a boolean expression is true at runtime, and if it is not, it calls the panic function with an error value. The "
"assert function takes two arguments: the boolean expression to verify, and the error value. The error value is "
"specified as a felt252, so any string passed must be able to fit inside a felt252."
msgstr ""
"Fungsi assert dari pustaka inti Cairo sebenarnya adalah fungsi utilitas berbasis panic. Ini menegaskan bahwa "
"sebuah ekspresi boolean benar saat runtime, dan jika tidak, itu memanggil fungsi panic dengan nilai kesalahan. "
"Fungsi assert mengambil dua argumen: ekspresi boolean yang akan diverifikasi, dan nilai kesalahan. Nilai "
"kesalahan ditentukan sebagai felt252, jadi setiap string yang dilewatkan harus mampu masuk ke dalam felt252."

#: src/ch10-01-unrecoverable-errors-with-panic.md:106
msgid "Here is an example of its usage:"
msgstr "Berikut adalah contoh penggunaannya:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:118
msgid ""
"We are asserting in main that `my_number` is not zero to ensure that we're not performing a division by 0. In "
"this example, `my_number` is zero so the assertion will fail, and the program will panic with the string 'number "
"is zero' (as a felt252) and the division will not be reached."
msgstr ""
"Kami melakukan asersi di dalam fungsi `main` bahwa `my_number` bukan nol untuk memastikan bahwa kita tidak "
"melakukan pembagian dengan 0. Pada contoh ini, `my_number` adalah nol sehingga asersi akan gagal, dan program "
"akan panic dengan string 'number is zero' (sebagai felt252) dan pembagian tidak akan tercapai."

#: src/ch10-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "Kesalahan yang Dapat Dipulihkan dengan `Result`"

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. Sometimes, when a function fails, "
"it’s for a reason that you can easily interpret and respond to. For example, if you try to add two large "
"integers and the operation overflows because the sum exceeds the maximum representable value, you might want to "
"return an error or a wrapped result instead of causing undefined behavior or terminating the process."
msgstr ""
"Kebanyakan kesalahan tidak serius sehingga memerlukan program untuk berhenti sepenuhnya. Terkadang, ketika "
"sebuah fungsi gagal, itu karena alasan yang dapat Anda terjemahkan dan tanggapi dengan mudah. Sebagai contoh, "
"jika Anda mencoba untuk menambahkan dua bilangan bulat besar dan operasinya melebihi kapasitas maksimum yang "
"dapat direpresentasikan sehingga terjadi overflow, Anda mungkin ingin mengembalikan kesalahan atau hasil yang "
"dibungkus daripada menyebabkan perilaku yang tidak terdefinisi atau menghentikan proses."

#: src/ch10-02-recoverable-errors.md:7
msgid "The `Result` enum"
msgstr "`Result` enum"

#: src/ch10-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in Chapter 8 that the `Result` enum is "
"defined as having two variants, `Ok` and `Err`, as follows:"
msgstr ""
"Ingat dari [“Tipe data generik”](ch08-01-generic-data-types.md#enums) dalam Bab 8 bahwa enum `Result` "
"didefinisikan memiliki dua varian, `Ok` dan `Err`, sebagai berikut:"

#: src/ch10-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "`ResultTrait`"

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` enum, such as unwrapping values, "
"checking whether the `Result` is `Ok` or `Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"Trait `ResultTrait` menyediakan metode-metode untuk bekerja dengan enum `Result<T, E>`, seperti membuka nilai-"
"nilai, memeriksa apakah `Result` adalah `Ok` atau `Err`, dan melakukan panic dengan pesan kustom. Implementasi "
"`ResultTraitImpl` mendefinisikan logika dari metode-metode ini."

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to extract the value of type `T` from a "
"`Result<T, E>` when it is in the `Ok` variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior when the `Result` is in the `Err` "
"variant. The `expect` method allows you to provide a custom error message (as a `felt252` value) that will be "
"used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap` method "
"panics with a default error message, providing less information about the cause of the panic."
msgstr ""
"Metode `expect` dan `unwrap` mirip dalam hal keduanya mencoba mengekstrak nilai tipe `T` dari sebuah `Result<T, "
"E>` saat berada dalam varian `Ok`. Jika `Result` adalah `Ok(x)`, kedua metode mengembalikan nilai `x`. Namun, "
"perbedaan utama antara kedua metode tersebut terletak pada perilaku mereka saat `Result` berada dalam varian "
"`Err`. Metode `expect` memungkinkan Anda untuk memberikan pesan kesalahan kustom (sebagai nilai `felt252`) yang "
"akan digunakan saat terjadi panic, memberikan lebih banyak kontrol dan konteks atas panic tersebut. Di sisi "
"lain, metode `unwrap` akan panic dengan pesan kesalahan default, memberikan informasi yang lebih sedikit tentang "
"penyebab dari panic."

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the `Result` is `Err(x)`, both methods "
"return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics "
"with a default error message, providing less information about the cause of the panic."
msgstr ""
"Metode `expect_err` dan `unwrap_err` memiliki perilaku yang sama sekali berlawanan. Jika `Result` adalah "
"`Err(x)`, kedua metode mengembalikan nilai `x`. Namun, perbedaan utama antara kedua metode tersebut terletak "
"pada kasus `Result::Ok()`. Metode `expect_err` memungkinkan Anda untuk memberikan pesan kesalahan kustom "
"(sebagai nilai `felt252`) yang akan digunakan saat terjadi panic, memberikan lebih banyak kontrol dan konteks "
"atas panic tersebut. Di sisi lain, metode `unwrap_err` akan panic dengan pesan kesalahan default, memberikan "
"informasi yang lebih sedikit tentang penyebab dari panic."

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl EDrop: Drop<E>>` in the first four "
"methods signatures. This syntax represents generic type constraints in the Cairo language. These constraints "
"indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` "
"and `E`, respectively."
msgstr ""
"Seorang pembaca yang teliti mungkin telah memperhatikan `<impl TDrop: Drop<T>>` dan `<impl EDrop: Drop<E>>` "
"dalam tanda tangan metode-metode pertama. sintaks ini merupakan representasi dari batasan tipe generik dalam "
"bahasa Cairo. Batasan-batasan ini menunjukkan bahwa fungsi-fungsi terkait memerlukan implementasi dari trait "
"`Drop` untuk tipe-tipe generik `T` dan `E`, secara berturut-turut."

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by the `ResultTrait` trait to check the "
"variant of a `Result` enum value."
msgstr ""
"Akhirnya, metode `is_ok` dan `is_err` adalah fungsi utilitas yang disediakan oleh trait `ResultTrait` untuk "
"memeriksa varian dari nilai enumerasi `Result`."

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Ok` variant, "
"meaning the operation was successful. If the `Result` is the `Err` variant, it returns `false`."
msgstr ""
"`is_ok` mengambil gambaran (snapshot) dari nilai `Result<T, E>` dan mengembalikan `true` jika `Result` merupakan "
"varian `Ok`, yang berarti operasi berhasil. Jika `Result` merupakan varian `Err`, maka mengembalikan `false`."

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, "
"meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"`is_err` mengambil referensi dari nilai `Result<T, E>` dan mengembalikan `true` jika `Result` merupakan varian "
"`Err`, yang berarti operasi mengalami kesalahan. Jika `Result` merupakan varian `Ok`, maka mengembalikan `false`."

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of an operation without consuming the "
"Result value, allowing you to perform additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"Metode-metode ini berguna ketika Anda ingin memeriksa keberhasilan atau kegagalan suatu operasi tanpa "
"mengonsumsi nilai Result, memungkinkan Anda untuk melakukan operasi tambahan atau membuat keputusan berdasarkan "
"varian tanpa meng-unwrap (membuka) nilainya."

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation of the `ResultTrait` [here](https://github.com/starkware-libs/cairo/blob/main/"
"corelib/src/result.cairo#L20)."
msgstr ""
"Anda dapat menemukan implementasi dari `ResultTrait` [di sini](https://github.com/starkware-libs/cairo/blob/main/"
"corelib/src/result.cairo#L20)."

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr "Selalu lebih mudah dipahami dengan contoh."

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr "Lihatlah tanda tangan fungsi ini:"

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if "
"the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""
"Fungsi ini menerima dua bilangan bulat u128, a dan b, dan mengembalikan `Result<u128, u128>` di mana varian `Ok` "
"berisi hasil penjumlahan jika tidak terjadi overflow, dan varian `Err` berisi nilai yang mengalami overflow jika "
"penjumlahan mengalami overflow."

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Sekarang, kita dapat menggunakan fungsi ini di tempat lain. Misalnya:"

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. It uses the `Result` returned by "
"`u128_overflowing_add` to determine the success or failure of the addition operation. The match expression "
"checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` "
"containing the sum. If the result is `Err(r)`, it returns `Option::None` to indicate that the operation has "
"failed due to overflow. The function does not panic in case of an overflow."
msgstr ""
"Di sini, fungsi ini menerima dua bilangan bulat u128, a dan b, dan mengembalikan `Option<u128>`. Fungsi ini "
"menggunakan `Result` yang dikembalikan oleh `u128_overflowing_add` untuk menentukan keberhasilan atau kegagalan "
"operasi penjumlahan. Ekspresi match memeriksa `Result` dari `u128_overflowing_add`. Jika hasilnya adalah "
"`Ok(r)`, maka mengembalikan `Option::Some(r)` yang berisi hasil penjumlahan. Jika hasilnya adalah `Err(r)`, maka "
"mengembalikan `Option::None` untuk menunjukkan bahwa operasi gagal karena overflow. Fungsi ini tidak memunculkan "
"panic dalam kasus overflow."

#: src/ch10-02-recoverable-errors.md:81
msgid "Let's take another example demonstrating the use of `unwrap`. First we import the necessary modules:"
msgstr ""
"Mari kita lihat contoh lain yang menunjukkan penggunaan `unwrap`. Pertama, kita impor modul-modul yang "
"diperlukan:"

#: src/ch10-02-recoverable-errors.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries to convert it into a `u8` integer "
"using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::"
"Err('Invalid integer')`."
msgstr ""
"Dalam contoh ini, fungsi `parse_u8` menerima bilangan bulat `felt252` dan mencoba mengonversinya menjadi "
"bilangan bulat `u8` menggunakan metode `try_into`. Jika berhasil, fungsi mengembalikan `Result::Ok(value)`, "
"sebaliknya mengembalikan `Result::Err('Angka tidak valid')`."

#: src/ch10-02-recoverable-errors.md:103
msgid "Listing 10-1: Using the Result type"
msgstr "Listing 10-1: Menggunakan tipe Result"

#: src/ch10-02-recoverable-errors.md:105
msgid "Our two test cases are:"
msgstr "Dua kasus uji kita adalah:"

#: src/ch10-02-recoverable-errors.md:121
msgid "// should not panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:129
msgid "// should panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The "
"second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to "
"panic with the error message 'Invalid integer'."
msgstr ""
"Yang pertama menguji konversi valid dari `felt252` menjadi `u8`, mengharapkan metode `unwrap` tidak menimbulkan "
"panic. Fungsi uji kedua mencoba mengonversi nilai yang berada di luar jangkauan `u8`, mengharapkan metode "
"`unwrap` menimbulkan panic dengan pesan kesalahan 'Angka tidak valid'."

#: src/ch10-02-recoverable-errors.md:139
msgid "We could have also used the #\\[should_panic\\] attribute here."
msgstr "Kita juga bisa menggunakan atribut `#[should_panic]` di sini."

#: src/ch10-02-recoverable-errors.md:141
msgid "The `?` operator ?"
msgstr ""

#: src/ch10-02-recoverable-errors.md:143
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator is used for more idiomatic and "
"concise error handling. When you use the `?` operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"Operator terakhir yang akan kita bahas adalah operator `?`. Operator `?` digunakan untuk penanganan kesalahan "
"yang lebih idiomatik dan ringkas. Ketika Anda menggunakan operator `?` pada tipe `Result` atau `Option`, itu "
"akan melakukan hal berikut:"

#: src/ch10-02-recoverable-errors.md:145
msgid "If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly."
msgstr ""
"Jika nilainya adalah `Result::Ok(x)` atau `Option::Some(x)`, maka akan mengembalikan nilai dalamnya, yaitu `x`, "
"secara langsung."

#: src/ch10-02-recoverable-errors.md:146
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately "
"returning from the function."
msgstr ""
"Jika nilainya adalah `Result::Err(e)` atau `Option::None`, maka akan menyebarkan kesalahan atau `None` dengan "
"segera mengembalikan dari fungsi tersebut."

#: src/ch10-02-recoverable-errors.md:148
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let the calling function deal with them."
msgstr ""
"Operator `?` berguna ketika Anda ingin menangani kesalahan secara implisit dan membiarkan fungsi pemanggil "
"menanganinya."

#: src/ch10-02-recoverable-errors.md:150
msgid "Here is an example."
msgstr "Berikut adalah contohnya."

#: src/ch10-02-recoverable-errors.md:155 src/ch10-02-recoverable-errors.md:177
msgid "// DO SOMETHING\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:161
msgid "Listing 10-1: Using the `?` operator"
msgstr "Listing 10-1: Menggunakan operator \"?\""

#: src/ch10-02-recoverable-errors.md:163
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8`. The `?` operator is "
"used to propagate the error, if any, or unwrap the successful value."
msgstr ""
"Fungsi `do_something_with_parse_u8` mengambil nilai `felt252` sebagai masukan dan memanggil `parse_u8`. Operator "
"`?` digunakan untuk menyebarkan kesalahan, jika ada, atau membuka nilai yang berhasil."

#: src/ch10-02-recoverable-errors.md:165
msgid "And with a little test case:"
msgstr "Dan dengan sedikit kasus uji:"

#: src/ch10-02-recoverable-errors.md:198
msgid "The console will print the error \"Invalid Integer\"."
msgstr "Konsol akan mencetak kesalahan \"Integer Tidak Valid\"."

#: src/ch10-02-recoverable-errors.md:204
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result enum, which has two variants: `Ok` and "
"`Err`. The `Result<T, E>` enum is generic, with types `T` and `E` representing the successful and error values, "
"respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, "
"checking if the result is `Ok` or `Err`, and panicking with custom messages."
msgstr ""
"Kita melihat bahwa kesalahan yang dapat dipulihkan dapat diatasi di Cairo menggunakan enum Result, yang memiliki "
"dua varian: `Ok` dan `Err`. Enum `Result<T, E>` bersifat generik, dengan tipe `T` dan `E` mewakili nilai yang "
"berhasil dan nilai kesalahan, masing-masing. Trait `ResultTrait` menyediakan metode untuk bekerja dengan "
"`Result<T, E>`, seperti membuka nilai, memeriksa apakah hasilnya `Ok` atau `Err`, dan menimbulkan panic dengan "
"pesan khusus."

#: src/ch10-02-recoverable-errors.md:206
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use pattern matching to handle the "
"success or failure of an operation. The `?` operator can be used to implicitly handle errors by propagating the "
"error or unwrapping the successful value. This allows for more concise and clear error handling, where the "
"caller is responsible for managing errors raised by the called function."
msgstr ""
"Untuk menangani kesalahan yang dapat dipulihkan, sebuah fungsi dapat mengembalikan tipe `Result` dan menggunakan "
"pola pencocokan untuk menangani keberhasilan atau kegagalan suatu operasi. Operator `?` dapat digunakan untuk "
"menangani kesalahan secara implisit dengan menyebarkan kesalahan atau membuka nilai yang berhasil. Ini "
"memungkinkan penanganan kesalahan yang lebih ringkas dan jelas, di mana pemanggil bertanggung jawab untuk "
"mengelola kesalahan yang dihasilkan oleh fungsi yang dipanggil."

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr "Sekarang, mari kita pelajari tentang fitur-fitur lebih lanjut yang ditawarkan oleh Cairo."

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows the redefinition of standard "
"operators, such as addition (+), subtraction (-), multiplication (\\*), and division (/), to work with user-"
"defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types "
"to be expressed in the same way as operations on primitive types."
msgstr ""
"Operator overloading adalah fitur dalam beberapa bahasa pemrograman yang memungkinkan pengulangan definisi "
"operator standar, seperti penambahan (+), pengurangan (-), perkalian (\\*), dan pembagian (/), agar dapat "
"berfungsi dengan tipe yang ditentukan pengguna. Hal ini dapat membuat sintaks kode lebih intuitif, dengan "
"memungkinkan operasi pada tipe yang ditentukan pengguna untuk diungkapkan dengan cara yang sama seperti operasi "
"pada tipe primitif."

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of specific traits. Each operator has an "
"associated trait, and overloading that operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. Misuse can lead to confusion, making the "
"code more difficult to maintain, for example when there is no semantic meaning to the operator being overloaded."
msgstr ""
"Di Cairo, operator overloading dicapai melalui implementasi trait khusus. Setiap operator memiliki trait "
"terkait, dan pengulangan operator melibatkan penyediaan implementasi trait tersebut untuk tipe kustom. Namun, "
"penting untuk menggunakan operator overloading dengan bijak. Penyalahgunaan dapat menyebabkan kebingungan, "
"membuat kode menjadi lebih sulit untuk dikelola, misalnya ketika tidak ada makna semantik pada operator yang di-"
"overload."

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have two data fields, mana and health. "
"Combining two `Potions` should add their respective fields."
msgstr ""
"Pertimbangkan contoh di mana dua `Potion` perlu digabungkan. `Potion` memiliki dua bidang data, yaitu mana dan "
"kesehatan. Menggabungkan dua `Potion` seharusnya menambahkan bidang masing-masing."

#: src/ch11-01-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr ""

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. The add function takes two "
"arguments: `lhs` and `rhs` (left and right-hand side). The function body returns a new `Potion` instance, its "
"field values being a combination of `lhs` and `rhs`."
msgstr ""
"Dalam kode di atas, kami sedang mengimplementasikan trait `Add` untuk tipe `Potion`. Fungsi tambah mengambil dua "
"argumen: `lhs` dan `rhs` (kiri dan kanan). Tubuh fungsi mengembalikan instance `Potion` baru, dengan nilai "
"bidangnya merupakan kombinasi dari `lhs` dan `rhs`."

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires specification of the concrete type being "
"overloaded. The overloaded generic trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"Seperti yang diilustrasikan dalam contoh tersebut, pengoverloadan operator memerlukan spesifikasi tipe konkret "
"yang di-overload. Trait generik yang di-overload adalah `Add<T>`, dan kami mendefinisikan implementasi konkret "
"untuk tipe `Potion` dengan `Add<Potion>`."

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their code. They are called "
"`inline_macros` and are a way of writing code that generates other code. In Cairo, there are only two `macros`: "
"`array![]` and `consteval_int!()`."
msgstr ""
"Bahasa Cairo memiliki beberapa plugin yang memungkinkan pengembang menyederhanakan kode mereka. Mereka disebut "
"`inline_macros` dan merupakan cara penulisan kode yang menghasilkan kode lain. Di Cairo, hanya ada dua `macros`: "
"`array![]` dan `consteval_int!()`."

#: src/ch11-02-macros.md:5
msgid "Let's start by `array!`"
msgstr "Mari kita mulai dengan `array!`"

#: src/ch11-02-macros.md:7
msgid ""
"Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing "
"that is redundant. You would first declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, the compiler will create an array "
"and append all values passed to the `array!` macro sequentially."
msgstr ""
"Terkadang, kita perlu membuat array dengan nilai yang sudah diketahui pada saat kompilasi. Cara dasar untuk "
"melakukannya terasa redundan. Anda akan pertama-tama mendeklarasikan array dan kemudian menambahkan masing-"
"masing nilai satu per satu. `array!` adalah cara yang lebih sederhana untuk melakukan tugas ini dengan "
"menggabungkan dua langkah tersebut. Pada saat kompilasi, kompiler akan membuat array dan menambahkan semua nilai "
"yang dilewatkan ke macro `array!` secara berurutan."

#: src/ch11-02-macros.md:10
msgid "Without `array!`:"
msgstr ""

#: src/ch11-02-macros.md:21
msgid "With `array!`:"
msgstr "Dengan `array!`:"

#: src/ch11-02-macros.md:27
msgid "`consteval_int!`"
msgstr ""

#: src/ch11-02-macros.md:29
msgid ""
"In some situations, a developer might need to declare a constant that is the result of a computation of "
"integers. To compute a constant expression and use its result at compile time, it is required to use the "
"`consteval_int!` macro."
msgstr ""
"Dalam beberapa situasi, seorang pengembang mungkin perlu mendeklarasikan konstanta yang merupakan hasil dari "
"perhitungan bilangan bulat. Untuk menghitung ekspresi konstan dan menggunakan hasilnya pada saat kompilasi, "
"diperlukan untuk menggunakan macro `consteval_int!`."

#: src/ch11-02-macros.md:31
msgid "Here is an example of `consteval_int!`:"
msgstr "Berikut adalah contoh dari `consteval_int!`:"

#: src/ch11-02-macros.md:37
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "Ini akan diinterpretasikan sebagai `const a: felt252 = 8;` oleh kompiler."

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a `main` entrypoint. In the coming "
"sections, you will learn to write and deploy Starknet contracts."
msgstr ""
"Sepanjang bagian-bagian sebelumnya, Anda sebagian besar menulis program dengan titik masuk `main`. Pada bagian-"
"bagian berikutnya, Anda akan belajar menulis dan mendeploy kontrak Starknet."

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts for the Starknet network. Starknet is "
"a permissionless network that leverages zk-STARKs technology for scalability. As a Layer-2 scalability solution "
"for Ethereum, Starknet's goal is to offer fast, secure, and low-cost transactions. It functions as a Validity "
"Rollup (commonly known as a zero-knowledge Rollup) and is built on top of the Cairo language and the Starknet VM."
msgstr ""
"Salah satu aplikasi dari bahasa Cairo adalah menulis kontrak pintar untuk jaringan Starknet. Starknet adalah "
"jaringan tanpa izin yang memanfaatkan teknologi zk-STARKs untuk skalabilitas. Sebagai solusi skalabilitas "
"Layer-2 untuk Ethereum, tujuan Starknet adalah menawarkan transaksi yang cepat, aman, dan dengan biaya rendah. "
"Ini berfungsi sebagai Validity Rollup (umumnya dikenal sebagai zero-knowledge Rollup) dan dibangun di atas "
"bahasa Cairo dan Starknet VM."

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the Starknet VM. Since they run on the VM, "
"they have access to Starknet’s persistent state, can alter or modify variables in Starknet’s states, communicate "
"with other contracts, and interact seamlessly with the underlying L1."
msgstr ""
"Kontrak Starknet, dengan kata sederhana, adalah program-program yang dapat dijalankan pada Starknet VM. Karena "
"mereka berjalan di VM, mereka memiliki akses ke status persisten Starknet, dapat mengubah atau memodifikasi "
"variabel dalam status Starknet, berkomunikasi dengan kontrak lain, dan berinteraksi dengan lancar dengan L1 yang "
"mendasarinya."

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive deeper into this in the next sections. "
"If you want to learn more about the Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section will focus on writing smart contracts "
"in Cairo."
msgstr ""
"Kontrak Starknet ditandai dengan atribut `#[contract]`. Kami akan membahas ini lebih lanjut pada bagian-bagian "
"berikutnya. Jika Anda ingin mempelajari lebih lanjut tentang jaringan Starknet itu sendiri, arsitekturnya, dan "
"alat yang tersedia, Anda sebaiknya membaca [Buku Starknet](https://book.starknet.io/). Bagian ini akan fokus "
"pada penulisan kontrak pintar di Cairo."

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this functionality, you'll need to make some "
"configurations in your `Scarb.toml` file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a `[[target.starknet-contract]]` section to enable "
"contract compilation."
msgstr ""
"Scarb mendukung pengembangan kontrak pintar untuk Starknet. Untuk mengaktifkan fungsionalitas ini, Anda perlu "
"melakukan beberapa konfigurasi dalam file `Scarb.toml` Anda (lihat [Instalasi](./ch01-01-installation.md) untuk "
"cara menginstal Scarb). Anda harus menambahkan dependensi `starknet` dan menambahkan bagian `[[target.starknet-"
"contract]]` untuk mengaktifkan kompilasi kontrak."

#: src/ch99-00-starknet-smart-contracts.md:17
msgid "Below is the minimal Scarb.toml file required to compile a crate containing Starknet contracts:"
msgstr ""
"Berikut adalah file Scarb.toml minimal yang diperlukan untuk mengompilasi kerangka yang berisi kontrak Starknet:"

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0-rc0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please refer to the [Scarb documentation]"
"(https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""
"Untuk konfigurasi tambahan, seperti dependensi kontrak eksternal, silakan merujuk ke [dokumentasi Scarb](https://"
"docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)."

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr "Setiap contoh dalam bab ini dapat digunakan dengan Scarb."

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts are, what are they used for and why "
"would blockchain developers use Cairo and Starknet. If you are already familiar with blockchain programming, "
"feel free to skip this chapter. The last part might still be interesting though."
msgstr ""
"Bab ini akan memberikan pengantar tingkat tinggi tentang apa itu kontrak pintar, apa yang mereka gunakan, dan "
"mengapa pengembang blockchain akan menggunakan Cairo dan Starknet. Jika Anda sudah familiar dengan pemrograman "
"blockchain, silakan lewati bab ini. Bagian terakhir mungkin masih menarik untuk dibaca."

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "Smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth of Ethereum. Smart contracts are "
"essentially programs deployed on a blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that are executed based on specific inputs. "
"They primarily consist of two components: storage and functions. Once deployed, users can interact with smart "
"contracts by initiating blockchain transactions containing execution data (which function to call and with what "
"input). Smart contracts can modify and read the storage of the underlying blockchain. A smart contract has its "
"own address and is considered a blockchain account, meaning it can hold tokens."
msgstr ""
"Kontrak pintar menjadi populer dan lebih tersebar luas dengan lahirnya Ethereum. Kontrak pintar pada dasarnya "
"adalah program yang diterapkan pada blockchain. Istilah \"kontrak pintar\" agak menyesatkan, karena mereka "
"bukanlah \"pintar\" maupun \"kontrak,\" melainkan berupa kode dan instruksi yang dieksekusi berdasarkan input "
"tertentu. Mereka terutama terdiri dari dua komponen: penyimpanan dan fungsi. Setelah diterapkan, pengguna dapat "
"berinteraksi dengan kontrak pintar dengan memulai transaksi blockchain yang berisi data eksekusi (fungsi yang "
"akan dipanggil dan dengan input apa). Kontrak pintar dapat memodifikasi dan membaca penyimpanan blockchain yang "
"mendasarinya. Kontrak pintar memiliki alamat sendiri dan dianggap sebagai akun blockchain, yang berarti dapat "
"menyimpan token."

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on the blockchain. For example, on "
"Ethereum and the [EVM-compatible ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code is compiled also differs based on "
"the blockchain. On Ethereum, Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra and "
"then into Cairo Assembly (casm)."
msgstr ""
"Bahasa pemrograman yang digunakan untuk menulis kontrak pintar bervariasi tergantung pada blockchain. Sebagai "
"contoh, pada Ethereum dan [ekosistem yang kompatibel dengan EVM](https://ethereum.org/en/developers/docs/evm/), "
"bahasa yang paling umum digunakan adalah Solidity, sementara pada Starknet, menggunakan bahasa Cairo. Cara kode "
"dikompilasi juga berbeda berdasarkan blockchain. Pada Ethereum, Solidity dikompilasi menjadi bytecode. Pada "
"Starknet, Cairo dikompilasi menjadi Sierra dan kemudian menjadi Cairo Assembly (casm)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are **permissionless**, meaning anyone can deploy a "
"smart contract on the network (within the context of a decentralized blockchain, of course). Smart contracts are "
"also **transparent**; the data stored by the smart contract is accessible to anyone. The code that composes the "
"contract can also be transparent, enabling **composability**. This allows developers to write smart contracts "
"that use other smart contracts. Smart contracts can only access and interact with data from the blockchain they "
"are deployed on. They require third-party software (called `oracles`) to access external data (the price of a "
"token for instance)."
msgstr ""
"Kontrak pintar memiliki beberapa karakteristik unik. Mereka **tanpa izin**, artinya siapa pun dapat menerapkan "
"kontrak pintar di jaringan (dalam konteks blockchain terdesentralisasi, tentu saja). Kontrak pintar juga "
"**transparan**; data yang disimpan oleh kontrak pintar dapat diakses oleh siapa pun. Kode yang menyusun kontrak "
"juga dapat transparan, memungkinkan **komposabilitas**. Ini memungkinkan pengembang menulis kontrak pintar yang "
"menggunakan kontrak pintar lainnya. Kontrak pintar hanya dapat mengakses dan berinteraksi dengan data dari "
"blockchain tempat mereka diterapkan. Mereka memerlukan perangkat lunak pihak ketiga (yang disebut `orakel`) "
"untuk mengakses data eksternal (seperti harga token, misalnya)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, it is required to know what the other "
"contracts look like. Hence, Ethereum developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to build tokens like `USDC`, `DAI` or "
"`STARK`, and the `ERC721`, for NFTs (Non-fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"Agar pengembang dapat membangun kontrak pintar yang dapat berinteraksi satu sama lain, diperlukan pengetahuan "
"tentang bagaimana kontrak lain terlihat. Oleh karena itu, pengembang Ethereum mulai membangun standar untuk "
"pengembangan kontrak pintar, yaitu `ERCxx`. Dua standar yang paling banyak digunakan dan terkenal adalah "
"`ERC20`, digunakan untuk membangun token seperti `USDC`, `DAI`, atau `STARK`, dan `ERC721`, untuk NFT (Token Non-"
"fungible) seperti `CryptoPunks` atau `Everai`."

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "Use cases"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are the technical constraints of the "
"blockchain and the creativity of developers."
msgstr ""
"Ada banyak kasus penggunaan yang mungkin untuk kontrak pintar. Satu-satunya batasan adalah kendala teknis dari "
"blockchain dan kreativitas para pengembang."

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "DeFi"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of Ethereum or Bitcoin, which is "
"essentially handling money. In the context of the alternative payment system promised by Bitcoin, smart "
"contracts on Ethereum enable the creation of decentralized financial applications that no longer rely on "
"traditional financial intermediaries. This is what we call DeFi (decentralized finance). DeFi consists of "
"various projects such as lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""
"Saat ini, kasus penggunaan utama untuk kontrak pintar mirip dengan Ethereum atau Bitcoin, yang pada dasarnya "
"menangani uang. Dalam konteks sistem pembayaran alternatif yang dijanjikan oleh Bitcoin, kontrak pintar di "
"Ethereum memungkinkan penciptaan aplikasi keuangan terdesentralisasi yang tidak lagi bergantung pada perantara "
"keuangan tradisional. Ini yang disebut DeFi (keuangan terdesentralisasi). DeFi terdiri dari berbagai proyek "
"seperti aplikasi peminjaman/peminjaman, pertukaran terdesentralisasi (DEX), derivatif on-chain, stablecoin, dana "
"lindung terdesentralisasi, asuransi, dan banyak lagi."

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "Tokenization"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such as real estate, art, or precious "
"metals. Tokenization divides an asset into digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and simplify the buying and selling process."
msgstr ""
"Kontrak pintar dapat memfasilitasi tokenisasi aset dunia nyata, seperti properti, seni, atau logam mulia. "
"Tokenisasi membagi suatu aset menjadi token digital, yang dapat diperdagangkan dan dikelola dengan mudah di "
"platform blockchain. Ini dapat meningkatkan likuiditas, memungkinkan kepemilikan fraksional, dan menyederhanakan "
"proses jual beli."

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "Voting"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. Votes can be recorded on the "
"blockchain, ensuring immutability and transparency. The smart contract can then automatically tally the votes "
"and declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"Kontrak pintar dapat digunakan untuk membuat sistem pemungutan suara yang aman dan transparan. Suara dapat "
"dicatat di blockchain, memastikan ketidakubahannya dan transparansi. Kontrak pintar kemudian dapat secara "
"otomatis menghitung suara dan mengumumkan hasilnya, meminimalkan potensi penipuan atau manipulasi."

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "Royalties"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and other content creators. When a piece "
"of content is consumed or sold, the smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for intermediaries."
msgstr ""
"Kontrak pintar dapat mengotomatisasi pembayaran royalti bagi seniman, musisi, dan pembuat konten lainnya. Ketika "
"suatu konten dikonsumsi atau dijual, kontrak pintar dapat secara otomatis menghitung dan mendistribusikan "
"royalti kepada pemilik yang berhak, memastikan kompensasi yang adil dan mengurangi kebutuhan akan perantara."

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "Decentralized identities DIDs"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, allowing individuals to control their "
"personal information and share it with third parties securely. The smart contract could verify the authenticity "
"of a user's identity and automatically grant or revoke access to specific services based on the user's "
"credentials."
msgstr ""
"Kontrak pintar dapat digunakan untuk membuat dan mengelola identitas digital, memungkinkan individu mengontrol "
"informasi pribadi mereka dan membagikannya dengan pihak ketiga secara aman. Kontrak pintar dapat memverifikasi "
"keaslian identitas pengguna dan secara otomatis memberikan atau mencabut akses ke layanan tertentu berdasarkan "
"kredensial pengguna."

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "The rise of Starknet and Cairo"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, became a victim of its own success. "
"With the rapid adoption of some previously mentioned use cases, mainly DeFi, the cost of performing transactions "
"became extremely high, rendering the network almost unusable. Engineers and researchers in the ecosystem began "
"working on solutions to address this scalability issue."
msgstr ""
"Ethereum, sebagai platform kontrak pintar yang paling banyak digunakan dan tangguh, menjadi korban dari "
"kesuksesannya sendiri. Dengan adopsi cepat beberapa kasus penggunaan yang telah disebutkan sebelumnya, terutama "
"DeFi, biaya untuk melakukan transaksi menjadi sangat tinggi, membuat jaringan hampir tidak dapat digunakan. "
"Insinyur dan peneliti di ekosistem ini mulai bekerja pada solusi untuk mengatasi masalah skalabilitas ini."

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-"
"trilemma)) in the blockchain space states that it is impossible to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. Ethereum is at the intersection of "
"decentralization and security. Eventually, it was decided that Ethereum's purpose would be to serve as a secure "
"settlement layer, while complex computations would be offloaded to other networks built on top of Ethereum. "
"These are called Layer 2s (L2s)."
msgstr ""
"Sebuah trilema terkenal ([The Blockchain Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-"
"scalability-trilemma)) di ruang blockchain menyatakan bahwa tidak mungkin mencapai tingkat skalabilitas, "
"desentralisasi, dan keamanan yang tinggi secara bersamaan; kompromi harus dilakukan. Ethereum berada di "
"persimpangan desentralisasi dan keamanan. Akhirnya, diputuskan bahwa tujuan Ethereum adalah untuk berfungsi "
"sebagai lapisan penyelesaian yang aman, sementara perhitungan kompleks akan dialihkan ke jaringan lain yang "
"dibangun di atas Ethereum. Ini disebut sebagai Layer 2 (L2)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. Both approaches involve compressing "
"and batching numerous transactions together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic rollups, the new state is considered "
"valid by default, but there is a 7-day window for nodes to identify malicious transactions."
msgstr ""
"Dua jenis utama L2 adalah optimistic rollups dan validity rollups. Kedua pendekatan tersebut melibatkan "
"penggabungan dan pengelompokan banyak transaksi bersama-sama, menghitung keadaan baru, dan menyelesaikan "
"hasilnya di Ethereum (L1). Perbedaannya terletak pada cara hasilnya diselesaikan di L1. Untuk optimistic "
"rollups, keadaan baru dianggap sah secara default, tetapi ada jendela waktu 7 hari bagi node untuk "
"mengidentifikasi transaksi yang berbahaya."

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove that the new state has been correctly "
"computed. This is the purpose of STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs from Starkware's Medium [article]"
"(https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"Sebaliknya, validity rollups, seperti Starknet, menggunakan kriptografi untuk membuktikan bahwa keadaan baru "
"telah dihitung dengan benar. Ini adalah tujuan dari STARKs, teknologi kriptografi ini dapat memungkinkan "
"validity rollups untuk mengalami peningkatan skala yang signifikan lebih dari optimistic rollups. Anda dapat "
"mempelajari lebih lanjut tentang STARKs dari artikel Medium [Starkware](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), yang berfungsi sebagai panduan yang baik."

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet Book](https://book.starknet.io/chapter_4/index."
"html), which is a great resource to learn more about the Starknet network."
msgstr ""
"Arsitektur Starknet dijelaskan secara mendalam dalam [Buku Starknet](https://book.starknet.io/chapter_4/index."
"html), yang merupakan sumber daya yang baik untuk mempelajari lebih lanjut tentang jaringan Starknet."

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work with STARKs and make them general-"
"purpose. With Cairo, we can write **provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""
"Ingat Cairo? Sebenarnya, itu adalah bahasa yang dikembangkan khusus untuk bekerja dengan STARKs dan membuatnya "
"serbaguna. Dengan Cairo, kita dapat menulis **kode yang dapat dipertanggungjawabkan**. Dalam konteks Starknet, "
"ini memungkinkan membuktikan kebenaran perhitungan dari satu keadaan ke keadaan lainnya."

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM (either as-is or adapted) as a base "
"layer, Starknet employs its own VM. This frees developers from the constraints of the EVM, opening up a broader "
"range of possibilities. Coupled with decreased transaction costs, the combination of Starknet and Cairo creates "
"an exciting playground for developers. Native account abstraction enables more complex logic for accounts, that "
"we call \"Smart Accounts\", and transaction flows. Emerging use cases include **transparent AI** and machine "
"learning applications. Finally, **blockchain games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for optimal scalability."
msgstr ""
"Berbeda dengan kebanyakan (jika tidak semua) pesaing Starknet yang memilih menggunakan EVM (baik itu apa adanya "
"atau disesuaikan) sebagai lapisan dasar, Starknet menggunakan VM sendiri. Hal ini membebaskan pengembang dari "
"batasan EVM, membuka peluang yang lebih luas. Dipadukan dengan penurunan biaya transaksi, kombinasi Starknet dan "
"Cairo menciptakan area bermain yang menarik bagi pengembang. Abstraksi akun asli memungkinkan logika yang lebih "
"kompleks untuk akun, yang kami sebut \"Smart Accounts\", dan alur transaksi. Beberapa kasus penggunaan yang "
"muncul termasuk aplikasi **kecerdasan buatan yang transparan** dan pembelajaran mesin. Terakhir, **permainan "
"blockchain** dapat dikembangkan sepenuhnya **on-chain**. Starknet secara khusus dirancang untuk memaksimalkan "
"kemampuan bukti STARK untuk skalabilitas yang optimal."

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid "Learn more about Account Abstraction in the [Starknet Book](https://book.starknet.io/chapter_5/index.html)."
msgstr ""
"Pelajari lebih lanjut tentang Abstraksi Akun di [Buku Starknet](https://book.starknet.io/chapter_5/index.html)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr "Program-program Cairo dan kontrak Starknet: apa perbedaannya?"

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts previously learned in this book are "
"still applicable to write Starknet contracts. As you may have already noticed, a Cairo program must always have "
"a function `main` that serves as the entry point for this program:"
msgstr ""
"Kontrak-kontrak Starknet merupakan suatu himpunan istimewa dari program-program Cairo, sehingga konsep-konsep "
"yang telah dipelajari sebelumnya dalam buku ini masih dapat diterapkan untuk menulis kontrak-kontrak Starknet. "
"Seperti yang mungkin sudah Anda perhatikan, suatu program Cairo harus selalu memiliki fungsi `main` yang "
"berfungsi sebagai titik masuk untuk program ini:"

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, and as such, have access to "
"Starknet's state. For a module to be handled as a contract by the compiler, it must be annotated with the "
"`#[starknet::contract]` attribute."
msgstr ""
"Kontrak-kontrak Starknet pada dasarnya adalah program-program yang dapat berjalan di sistem operasi Starknet, "
"dan sebagai hasilnya, memiliki akses ke status Starknet. Agar suatu modul dapat dianggap sebagai kontrak oleh "
"compiler, harus diberi anotasi dengan atribut `#[starknet::contract]`."

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an example of a basic contract. You "
"will learn how to write a simple contract that stores a single number on the blockchain."
msgstr ""
"Bab ini akan memperkenalkan Anda pada dasar-dasar kontrak Starknet dengan contoh kontrak dasar. Anda akan "
"belajar cara menulis kontrak sederhana yang menyimpan satu angka pada blockchain."

#: src/ch99-01-02-a-simple-contract.md:5
msgid "Anatomy of a simple Starknet Contract"
msgstr "Struktur dari Kontrak Starknet Sederhana"

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet contract. It might not be easy to "
"understand it all at once, but we will go through it step by step:"
msgstr ""
"Mari kita pertimbangkan kontrak berikut untuk memperkenalkan dasar-dasar kontrak Starknet. Mungkin tidak mudah "
"untuk memahaminya sekaligus, tetapi kita akan membahasnya langkah demi langkah:"

#: src/ch99-01-02-a-simple-contract.md:38
msgid "Listing 99-1: A simple storage contract"
msgstr "Listing 99-1: Kontrak penyimpanan sederhana"

#: src/ch99-01-02-a-simple-contract.md:40
msgid "Note: Starknet contracts are defined within [modules](./ch07-02-defining-modules-to-control-scope.md)."
msgstr "Catatan: Kontrak Starknet didefinisikan dalam [modul](./ch07-02-defining-modules-to-control-scope.md)."

#: src/ch99-01-02-a-simple-contract.md:42
msgid "What is this contract?"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called `stored_data` of type `u128` (unsigned "
"integer of 128 bits). You can think of it as a single slot in a database that you can query and alter by calling "
"functions of the code that manages the database. The contract defines and exposes publicly the functions `set` "
"and `get` that can be used to modify or retrieve the value of that variable."
msgstr ""
"Dalam contoh ini, struktur `Storage` mendeklarasikan variabel penyimpanan yang disebut `stored_data` dengan tipe "
"`u128` (bilangan bulat tak bertanda 128 bit). Anda dapat menganggapnya sebagai satu slot dalam database yang "
"dapat Anda tanyakan dan ubah dengan memanggil fungsi dari kode yang mengelola database tersebut. Kontrak "
"menentukan dan mengekspos secara publik fungsi-fungsi `set` dan `get` yang dapat digunakan untuk mengubah atau "
"mengambil nilai dari variabel tersebut."

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr "Antarmuka: rancangan kontrak"

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes to the outside world. Here, the "
"interface exposes two functions: `set` and `get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo."
"md) mechanism from Cairo, we can make sure that the actual implementation of the contract matches its interface. "
"In fact, you will get a compilation error if your contract doesn’t conform with the declared interface."
msgstr ""
"Antarmuka dari sebuah kontrak mewakili fungsi-fungsi yang kontrak tersebut ungkapkan ke dunia luar. Di sini, "
"antarmuka mengungkapkan dua fungsi: `set` dan `get`. Dengan memanfaatkan mekanisme [traits & impls](./ch08-02-"
"traits-in-cairo.md) dari Cairo, kita dapat memastikan bahwa implementasi sebenarnya dari kontrak sesuai dengan "
"antarmukanya. Faktanya, Anda akan mendapatkan kesalahan kompilasi jika kontrak Anda tidak sesuai dengan "
"antarmuka yang dideklarasikan."

#: src/ch99-01-02-a-simple-contract.md:70
msgid "Listing 99-1-bis: A wrong implementation of the interface of the contract. This does not compile."
msgstr "Listing 99-1-bis: Implementasi antarmuka kontrak yang salah. Ini tidak dapat dikompilasi."

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` argument which is passed by reference to "
"the `set` function. The `self` parameter represents the contract state. Seeing the `self` argument passed to "
"`set` tells us that this function might access the state of the contract, as it is what gives us access to the "
"contract’s storage. The `ref` modifier implies that `self` may be modified, meaning that the storage variables "
"of the contract may be modified inside the `set` function."
msgstr ""
"Pada antarmuka, perhatikan tipe generik `TContractState` dari argumen `self` yang dilewatkan secara referensi ke "
"fungsi `set`. Parameter `self` mewakili status kontrak. Melihat argumen `self` yang dilewatkan ke `set` memberi "
"tahu kita bahwa fungsi ini mungkin mengakses status kontrak, karena itulah yang memberikan akses ke penyimpanan "
"kontrak. Modifier `ref` mengimplikasikan bahwa `self` dapat dimodifikasi, yang berarti variabel penyimpanan "
"kontrak dapat dimodifikasi di dalam fungsi `set`."

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which immediately tells us that it does not "
"modify the state (and indeed, the compiler will complain if we try to modify storage inside the `get` function)."
msgstr ""
"Di sisi lain, `get` mengambil _snapshot_ dari `TContractState`, yang segera memberi tahu kita bahwa fungsi ini "
"tidak memodifikasi status (dan memang, kompiler akan mengeluh jika kita mencoba memodifikasi penyimpanan di "
"dalam fungsi `get`)."

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr "Fungsi-fungsi publik didefinisikan dalam blok implementasi"

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr "Sebelum kita menjelajahi lebih lanjut, mari tentukan beberapa terminologi."

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is exposed to the outside world. In the "
"example above, `set` and `get` are public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the example above, `set` and `get` are public "
"functions."
msgstr ""
"Dalam konteks Starknet, sebuah _fungsi publik_ adalah fungsi yang terpapar ke dunia luar. Pada contoh di atas, "
"`set` dan `get` adalah fungsi publik. Fungsi publik dapat dipanggil oleh siapa saja, dan dapat dipanggil dari "
"luar kontrak atau dari dalam kontrak. Pada contoh di atas, `set` dan `get` adalah fungsi publik."

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked through a transaction and that can "
"mutate the state of the contract. `set` is an external function."
msgstr ""
"Apa yang kita sebut sebagai fungsi _eksternal_ adalah fungsi publik yang dipanggil melalui transaksi dan dapat "
"mengubah status kontrak. `set` adalah fungsi eksternal."

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the contract, but that cannot mutate the "
"state of the contract. `get` is a view function."
msgstr ""
"Fungsi _view_ adalah fungsi publik yang dapat dipanggil dari luar kontrak, tetapi tidak dapat mengubah status "
"kontrak. `get` adalah fungsi view."

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in order to match the interface, the "
"external functions of the contract must be defined in an implementation of this trait — which allows us to make "
"sure that the implementation of the contract matches its interface."
msgstr ""
"Karena antarmuka kontrak didefinisikan sebagai trait `ISimpleStorage`, agar sesuai dengan antarmuka tersebut, "
"fungsi eksternal dari kontrak harus didefinisikan dalam implementasi dari trait ini — yang memungkinkan kita "
"memastikan bahwa implementasi kontrak sesuai dengan antarmuka tersebut."

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. The implementation block must be "
"annotated with the `#[external(v0)]` attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions will not be callable from the outside. "
"All functions defined in a block marked as `#[external(v0)]` are consequently _public functions_."
msgstr ""
"Namun, hanya mendefinisikan fungsi-fungsi dalam implementasi saja tidak cukup. Blok implementasi harus diberi "
"anotasi atribut `#[external(v0)]`. Atribut ini mengekspos fungsi-fungsi yang didefinisikan dalam implementasi "
"ini ke dunia luar — lupakan untuk menambahkannya dan fungsi-fungsi Anda tidak dapat dipanggil dari luar. Semua "
"fungsi yang didefinisikan dalam blok yang ditandai sebagai `#[external(v0)]` oleh karena itu menjadi _fungsi "
"publik_."

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter corresponding to the `self` argument in "
"the trait must be `ContractState`. The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, `ContractState` gives us the ability to "
"emit events. The name `ContractState` is not surprising, as it’s a representation of the contract’s state, which "
"is what we think of `self` in the contract interface trait."
msgstr ""
"Ketika menulis implementasi antarmuka, parameter generik yang sesuai dengan argumen `self` dalam trait harus "
"menjadi `ContractState`. Tipe `ContractState` dihasilkan oleh kompiler dan memberikan akses ke variabel "
"penyimpanan yang didefinisikan dalam struktur `Storage`. Selain itu, `ContractState` memberikan kemampuan untuk "
"mengeluarkan peristiwa (events). Nama `ContractState` tidak mengherankan, karena ini merupakan representasi dari "
"status kontrak, yang merupakan apa yang kita pikirkan sebagai `self` dalam trait antarmuka kontrak."

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr "Memodifikasi status kontrak"

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the contract are defined under the "
"implementation of a trait that has a `TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` parameter to the function, allowing "
"access the storage variables of the contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the `read` and `write` methods to either "
"read or write the value of the storage variable."
msgstr ""
"Seperti yang dapat Anda perhatikan, semua fungsi yang perlu mengakses status kontrak didefinisikan di bawah "
"implementasi suatu trait yang memiliki parameter generik `TContractState` dan mengambil parameter `self: "
"ContractState`. Ini memungkinkan kita untuk secara eksplisit melewati parameter `self: ContractState` ke fungsi, "
"memungkinkan akses ke variabel penyimpanan kontrak. Untuk mengakses variabel penyimpanan kontrak saat ini, Anda "
"menambahkan awalan `self` ke nama variabel penyimpanan, yang memungkinkan Anda menggunakan metode `read` dan "
"`write` untuk membaca atau menulis nilai variabel penyimpanan."

#: src/ch99-01-02-a-simple-contract.md:118
msgid "Using `self` and the `write` method to modify the value of a storage variable"
msgstr "Menggunakan `self` dan metode `write` untuk memodifikasi nilai variabel penyimpanan"

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, attempting to modify will result in a "
"compilation error."
msgstr ""
"Catatan: jika status kontrak dilewatkan sebagai snapshot alih-alih `ref`, percobaan untuk memodifikasi akan "
"menghasilkan kesalahan kompilasi."

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a single number that is accessible by "
"anyone in the world. Anyone could call `set` again with a different value and overwrite your number, but the "
"number is still stored in the history of the blockchain. Later, you will see how you can impose access "
"restrictions so that only you can alter the number."
msgstr ""
"Kontrak ini belum melakukan banyak hal selain memungkinkan siapa pun menyimpan satu angka yang dapat diakses "
"oleh siapa pun di dunia. Siapa pun bisa memanggil `set` lagi dengan nilai yang berbeda dan menimpa angka Anda, "
"tetapi angka tersebut masih disimpan dalam sejarah blockchain. Nanti, Anda akan melihat bagaimana Anda dapat "
"memberlakukan pembatasan akses sehingga hanya Anda yang dapat mengubah angka tersebut."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract written in Cairo. In this section, "
"we'll be taking a deeper look at all the components of a smart contract, step by step."
msgstr ""
"Pada bagian sebelumnya, kami memberikan contoh pengantar dari kontrak pintar yang ditulis dalam bahasa Cairo. "
"Pada bagian ini, kita akan melihat lebih dalam semua komponen dari kontrak pintar, langkah demi langkah."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we specified the difference between _public "
"functions, external functions and view functions_, and we mentioned how to interact with _storage_."
msgstr ""
"Ketika kita membahas [_interfaces_](./ch99-01-02-a-simple-contract.md), kita menjelaskan perbedaan antara "
"_fungsi publik, fungsi eksternal, dan fungsi view_, dan kita menyebutkan cara berinteraksi dengan _penyimpanan_."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr "Pada titik ini, seharusnya Anda memiliki beberapa pertanyaan yang muncul dalam pikiran:"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr "Bagaimana cara saya mendefinisikan fungsi internal atau privat?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr ""
"Bagaimana cara saya mengeluarkan peristiwa (events)? Bagaimana cara saya membuat indeks pada peristiwa tersebut?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid "Where should I define functions that do not need to access the contract's state?"
msgstr "Di mana sebaiknya saya mendefinisikan fungsi yang tidak perlu mengakses status kontrak?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr "Apakah ada cara untuk mengurangi boilerplate (kode yang sering diulang)?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr "Bagaimana cara menyimpan tipe data yang lebih kompleks?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's consider the following example contract "
"that we'll be using throughout this chapter:"
msgstr ""
"Untungnya, kita akan menjawab semua pertanyaan tersebut dalam bab ini. Mari pertimbangkan contoh kontrak berikut "
"yang akan kita gunakan sepanjang bab ini:"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:104
msgid "Listing 99-1bis: Our reference contract for this chapter"
msgstr "Listing 99-1bis: Kontrak referensi untuk bab ini"

#: src/ch99-01-03-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through storage variables. As stated "
"previously, storage variables allow you to store data that will be stored in the contract's storage that is "
"itself stored on the blockchain. These data are persistent and can be accessed and modified anytime once the "
"contract is deployed."
msgstr ""
"Cara paling umum untuk berinteraksi dengan penyimpanan kontrak adalah melalui variabel penyimpanan. Seperti yang "
"disebutkan sebelumnya, variabel penyimpanan memungkinkan Anda menyimpan data yang akan disimpan di penyimpanan "
"kontrak yang sendiri disimpan di blockchain. Data ini bersifat persisten dan dapat diakses serta dimodifikasi "
"kapan saja setelah kontrak diimplementasikan."

#: src/ch99-01-03-01-contract-storage.md:5
msgid "Storage variables in Starknet contracts are stored in a special struct called `Storage`:"
msgstr "Variabel penyimpanan dalam kontrak Starknet disimpan dalam sebuah struktur khusus yang disebut `Storage`:"

#: src/ch99-01-03-01-contract-storage.md:96
msgid "A Storage Struct"
msgstr "Storage Struct"

#: src/ch99-01-03-01-contract-storage.md:98
msgid ""
"The storage struct is a [struct](./ch05-00-using-structs-to-structure-related-data.md) like any other, except "
"that it **must** be annotated with `#[storage]`. This annotation tells the compiler to generate the required "
"code to interact with the blockchain state, and allows you to read and write data from and to storage. Moreover, "
"this allows you to define storage mappings using the `LegacyMap` type."
msgstr ""
"Struktur penyimpanan adalah [struct](./ch05-00-using-structs-to-structure-related-data.md) seperti halnya "
"struktur lainnya, kecuali bahwa struktur ini **harus** diberi anotasi `#[storage]`. Anotasi ini memberi tahu "
"kompiler untuk menghasilkan kode yang diperlukan untuk berinteraksi dengan status blockchain, dan memungkinkan "
"Anda membaca dan menulis data dari dan ke penyimpanan. Selain itu, ini memungkinkan Anda mendefinisikan pemetaan "
"penyimpanan menggunakan tipe `LegacyMap`."

#: src/ch99-01-03-01-contract-storage.md:101
msgid ""
"Each variable stored in the storage struct is stored in a different location in the contract's storage. The "
"storage address of a variable is determined by the variable's name, and the eventual keys of the variable if it "
"is a [mapping](#storing-mappings)."
msgstr ""
"Setiap variabel yang disimpan dalam struktur penyimpanan disimpan di lokasi yang berbeda dalam penyimpanan "
"kontrak. Alamat penyimpanan dari suatu variabel ditentukan oleh nama variabel tersebut, dan kunci akhir dari "
"variabel tersebut jika itu adalah [mapping](#storing-mappings)."

#: src/ch99-01-03-01-contract-storage.md:103
msgid "Storage Addresses"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:105
msgid "The address of a storage variable is computed as follows:"
msgstr "Alamat dari variabel penyimpanan dihitung sebagai berikut:"

#: src/ch99-01-03-01-contract-storage.md:107
msgid ""
"If the variable is a single value (not a mapping), the address is the `sn_keccak` hash of the ASCII encoding of "
"the variable's name. `sn_keccak` is Starknet's version of the Keccak256 hash function, whose output is truncated "
"to 250 bits."
msgstr ""
"Jika variabel adalah nilai tunggal (bukan pemetaan), alamatnya adalah hash `sn_keccak` dari pengodean ASCII nama "
"variabel. `sn_keccak` adalah versi fungsi hash Keccak256 milik Starknet, dengan keluaran yang dipotong menjadi "
"250 bit."

#: src/ch99-01-03-01-contract-storage.md:108
msgid ""
"If the variable is a [mapping](#storing-mappings), the address of the value at key `k_1,...,k_n` is `h(..."
"h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ is the Pedersen hash and the final value is taken `mod "
"(2^251) − 256`."
msgstr ""
"Jika variabel adalah [pemetaan](#storing-mappings), alamat dari nilai pada kunci `k_1,...,k_n` adalah `h(..."
"h(h(sn_keccak(nama_variabel),k_1),k_2),...,k_n)` di mana ℎ adalah hash Pedersen dan nilai akhir diambil `mod "
"(2^251) − 256`."

#: src/ch99-01-03-01-contract-storage.md:109
msgid ""
"If it is a mapping to complex values (e.g., tuples or structs), then this complex value lies in a continuous "
"segment starting from the address calculated in the previous point. Note that 256 field elements is the current "
"limitation on the maximal size of a complex storage value."
msgstr ""
"Jika itu adalah pemetaan ke nilai kompleks (misalnya, tupel atau structs), maka nilai kompleks ini terletak "
"dalam segmen berkelanjutan yang dimulai dari alamat yang dihitung pada poin sebelumnya. Perlu diperhatikan bahwa "
"256 elemen lapangan adalah batasan saat ini pada ukuran maksimal nilai penyimpanan kompleks."

#: src/ch99-01-03-01-contract-storage.md:111
msgid ""
"You can access the address of a storage variable by calling the `address` function on the variable, which "
"returns a `StorageBaseAddress` value."
msgstr ""
"Anda dapat mengakses alamat variabel penyimpanan dengan memanggil fungsi `address` pada variabel tersebut, yang "
"mengembalikan nilai `StorageBaseAddress`."

#: src/ch99-01-03-01-contract-storage.md:202
msgid "Interacting with Storage Variables"
msgstr "Berinteraksi dengan Variabel Penyimpanan"

#: src/ch99-01-03-01-contract-storage.md:204
msgid ""
"Variables stored in the storage struct can be accessed and modified using the `read` and `write` functions, and "
"you can get their address in storage using the `addr` function. These functions are automatically generated by "
"the compiler for each storage variable."
msgstr ""
"Variabel yang disimpan dalam struktur penyimpanan dapat diakses dan dimodifikasi menggunakan fungsi `read` dan "
"`write`, dan Anda dapat mendapatkan alamatnya di penyimpanan menggunakan fungsi `addr`. Fungsi-fungsi ini secara "
"otomatis dihasilkan oleh kompiler untuk setiap variabel penyimpanan."

#: src/ch99-01-03-01-contract-storage.md:206
msgid ""
"To read the value of the `owner` storage variable, which is a single value, we call the `read` function on the "
"`owner` variable, passing in no parameters."
msgstr ""
"Untuk membaca nilai variabel penyimpanan `owner`, yang merupakan nilai tunggal, kita panggil fungsi `read` pada "
"variabel `owner`, tanpa memberikan parameter."

#: src/ch99-01-03-01-contract-storage.md:297
msgid "Calling the `read` function on the `owner` variable"
msgstr "Memanggil fungsi `read` pada variabel `owner`"

#: src/ch99-01-03-01-contract-storage.md:299
msgid ""
"To read the value of the storage variable `names`, which is a mapping from `ContractAddress` to `felt252`, we "
"call the `read` function on the `names` variable, passing in the key `address` as a parameter. If the mapping "
"had more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"Untuk membaca nilai variabel penyimpanan `names`, yang merupakan pemetaan dari `ContractAddress` ke `felt252`, "
"kita panggil fungsi `read` pada variabel `names`, dengan melewatkan kunci `address` sebagai parameter. Jika "
"pemetaan memiliki lebih dari satu kunci, kita akan melewatkan kunci-kunci lain sebagai parameter juga."

#: src/ch99-01-03-01-contract-storage.md:390
msgid "Calling the `read` function on the `names` variable"
msgstr "Memanggil fungsi `read` pada variabel `names`"

#: src/ch99-01-03-01-contract-storage.md:392
msgid ""
"To write a value to a storage variable, we call the `write` function passing in the eventual keys the value as "
"arguments. As with the `read` function, the number of arguments depends on the number of keys - here, we only "
"pass in the value to write to the `owner` variable as it is a simple variable."
msgstr ""
"Untuk menulis nilai ke variabel penyimpanan, kita panggil fungsi `write` dengan melewatkan kunci-kunci akhir dan "
"nilai sebagai argumen. Seperti halnya fungsi `read`, jumlah argumen tergantung pada jumlah kunci - di sini, kita "
"hanya melewatkan nilai yang akan ditulis ke variabel `owner` karena ini adalah variabel sederhana."

#: src/ch99-01-03-01-contract-storage.md:483
msgid "Calling the `write` function on the `owner` variable"
msgstr "Memanggil fungsi `write` pada variabel `owner`"

#: src/ch99-01-03-01-contract-storage.md:574
msgid "Calling the `write` function on the `names` variable"
msgstr "Memanggil fungsi `write` pada variabel `names`"

#: src/ch99-01-03-01-contract-storage.md:576
msgid "Storing custom types"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:578
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used to specify how a type should be "
"stored in storage. In order for a type to be stored in storage, it must implement the `Store` trait. Most types "
"from the core library, such as unsigned integers (`u8`, `u128`, `u256`...), `felt252`, `bool`, "
"`ContractAddress`, etc. implement the `Store` trait and can thus be stored without further action."
msgstr ""
"Trait `Store`, yang didefinisikan dalam modul `starknet::storage_access`, digunakan untuk menentukan bagaimana "
"suatu tipe harus disimpan di penyimpanan. Agar suatu tipe dapat disimpan di penyimpanan, ia harus "
"mengimplementasikan trait `Store`. Sebagian besar tipe dari pustaka inti, seperti bilangan bulat tanpa tanda "
"(`u8`, `u128`, `u256`, ...), `felt252`, `bool`, `ContractAddress`, dll., mengimplementasikan trait `Store` dan "
"oleh karena itu dapat disimpan tanpa tindakan lebih lanjut."

#: src/ch99-01-03-01-contract-storage.md:580
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an enum or a struct? In that case, you "
"have to explicitly tell the compiler how to store this type."
msgstr ""
"Namun, bagaimana jika Anda ingin menyimpan tipe yang Anda tentukan sendiri, seperti enum atau struct? Dalam "
"kasus ini, Anda harus secara eksplisit memberi tahu kompiler bagaimana menyimpan tipe ini."

#: src/ch99-01-03-01-contract-storage.md:582
msgid ""
"In our example, we want to store a `Person` struct in storage, which is possible by implementing the `Store` "
"trait for the `Person` type. This can be achieved by simply adding a `#[derive(starknet::Store)]` attribute on "
"top of our struct definition."
msgstr ""
"Dalam contoh kami, kami ingin menyimpan struktur `Person` di penyimpanan, yang dapat dilakukan dengan "
"mengimplementasikan trait `Store` untuk tipe `Person`. Ini dapat dicapai dengan menambahkan atribut "
"`#[derive(starknet::Store)]` di atas definisi struct kami."

#: src/ch99-01-03-01-contract-storage.md:673
msgid "Structs storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:675
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. The elements of the struct are "
"stored in the same order as they are defined in the struct definition. The first element of the struct is stored "
"at the base address of the struct, which is computed as specified in [Storage Addresses](#storage-addresses) and "
"can be obtained by calling `var.address()`, and subsequent elements are stored at addresses contiguous to the "
"first element. For example, the storage layout for the `owner` variable of type `Person` will result in the "
"following layout:"
msgstr ""
"Pada Starknet, struktur disimpan di penyimpanan sebagai urutan tipe primitif. Elemen-elemen struktur disimpan "
"dalam urutan yang sama dengan yang didefinisikan dalam definisi struct. Elemen pertama dari struct disimpan di "
"alamat dasar struct, yang dihitung seperti yang dijelaskan dalam [Alamat Penyimpanan](#storage-addresses) dan "
"dapat diperoleh dengan memanggil `var.address()`, dan elemen-elemen berikutnya disimpan di alamat yang "
"berdekatan dengan elemen pertama. Sebagai contoh, tata letak penyimpanan untuk variabel `owner` bertipe `Person` "
"akan menghasilkan tata letak berikut:"

#: src/ch99-01-03-01-contract-storage.md:679
msgid "Fields"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:679
msgid "Address"
msgstr "Address"

#: src/ch99-01-03-01-contract-storage.md:681
msgid "name"
msgstr "name"

#: src/ch99-01-03-01-contract-storage.md:681
msgid "owner.address()"
msgstr "owner.address()"

#: src/ch99-01-03-01-contract-storage.md:682
msgid "address"
msgstr "address"

#: src/ch99-01-03-01-contract-storage.md:682
msgid "owner.address() +1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:684
msgid "Storage mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:686
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys to values. However, unlike a typical "
"hash table, the key data itself is not stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a key/value pair is set. The only way to "
"remove a mapping is to set its value to the default zero value."
msgstr ""
"Pemetaan penyimpanan mirip dengan tabel hash karena memungkinkan pemetaan kunci ke nilai. Namun, tidak seperti "
"tabel hash biasa, data kunci itu sendiri tidak disimpan - hanya hash-nya yang digunakan untuk mencari nilai yang "
"terkait di penyimpanan kontrak. Pemetaan tidak memiliki konsep panjang atau apakah sepasang kunci/nilai diatur. "
"Satu-satunya cara untuk menghapus sebuah pemetaan adalah dengan mengatur nilainya menjadi nilai nol default."

#: src/ch99-01-03-01-contract-storage.md:689
msgid ""
"Mappings are only used to compute the location of data in the storage of a contract given certain keys. They are "
"thus **only allowed as storage variables**. They cannot be used as parameters or return parameters of contract "
"functions, and cannot be used as types inside structs."
msgstr ""
"Pemetaan hanya digunakan untuk menghitung lokasi data dalam penyimpanan kontrak dengan menggunakan kunci "
"tertentu. Oleh karena itu, pemetaan **hanya diperbolehkan sebagai variabel penyimpanan**. Mereka tidak dapat "
"digunakan sebagai parameter atau parameter pengembalian dari fungsi kontrak, dan tidak dapat digunakan sebagai "
"tipe dalam struktur data."

#: src/ch99-01-03-01-contract-storage.md:701
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets `<>`, specifying the key and value "
"types."
msgstr ""
"Untuk mendeklarasikan sebuah pemetaan, gunakan tipe `LegacyMap` yang diapit oleh tanda kurung sudut `<>`, dengan "
"menentukan tipe kunci dan tipe nilai."

#: src/ch99-01-03-01-contract-storage.md:704
msgid ""
"You can also create more complex mappings with multiple keys. You can find one in Listing 99-2bis like the "
"popular `allowances` storage variable in the ERC20 Standard which maps an `owner` and an allowed `spender` to "
"its `allowance` amount using multiple keys passed inside a tuple:"
msgstr ""
"Anda juga dapat membuat pemetaan yang lebih kompleks dengan beberapa kunci. Anda dapat menemukan contohnya di "
"Listing 99-2bis seperti variabel penyimpanan `allowances` pada Standar ERC20 yang populer, yang memetakan "
"`pemilik` dan `spender` yang diizinkan ke jumlah `izin` menggunakan beberapa kunci yang dilewatkan dalam sebuah "
"tuple:"

#: src/ch99-01-03-01-contract-storage.md:713
msgid "Listing 99-2bis: Storing mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:715
msgid ""
"The address in storage of a variable stored in a mapping is computed according to the description in the "
"[Storage Addresses](#storage-addresses) section. If the key of a mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the `Hash` trait, which can be derived with the "
"`#[derive(Hash)]` attribute. For example, if you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the values of the two fields of the struct."
msgstr ""
"Alamat di penyimpanan dari variabel yang disimpan dalam pemetaan dihitung sesuai dengan deskripsi dalam bagian "
"[Alamat Penyimpanan](#storage-addresses). Jika kunci dari suatu pemetaan adalah struktur, setiap elemen dari "
"struktur tersebut menjadi kunci. Selain itu, struktur harus mengimplementasikan trait `Hash`, yang dapat "
"diturunkan dengan atribut `#[derive(Hash)]`. Sebagai contoh, jika Anda memiliki struktur dengan dua bidang, "
"alamatnya akan menjadi `h(h(sn_keccak(nama_variabel),k_1),k_2)` - di mana `k_1` dan `k_2` adalah nilai dari dua "
"bidang struktur tersebut."

#: src/ch99-01-03-01-contract-storage.md:718
msgid ""
"Similarly, in the case of a nested mapping such as `LegacyMap((ContractAddress, ContractAddress), u8)`, the "
"address will be computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""
"Demikian juga, dalam kasus pemetaan bertingkat seperti `LegacyMap((ContractAddress, ContractAddress), u8)`, "
"alamatnya akan dihitung dengan cara yang sama: `h(h(sn_keccak(nama_variabel),k_1),k_2)`."

#: src/ch99-01-03-01-contract-storage.md:720
msgid ""
"For more details about the contract storage layout in the [Starknet Documentation](https://docs.starknet.io/"
"documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
msgstr ""
"Untuk informasi lebih lanjut tentang tata letak penyimpanan kontrak, kunjungi [Dokumentasi Starknet](https://"
"docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)."

#: src/ch99-01-03-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of functions you could encounter in contracts:"
msgstr "Pada bagian ini, kita akan melihat berbagai jenis fungsi yang mungkin Anda temui dalam kontrak:"

#: src/ch99-01-03-02-contract-functions.md:5
msgid "1. Constructors"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:7
msgid ""
"Constructors are a special type of function that only runs once when deploying a contract, and can be used to "
"initialize the state of a contract."
msgstr ""
"Constructors adalah jenis fungsi khusus yang hanya dijalankan sekali saat mendeploy kontrak, dan dapat digunakan "
"untuk menginisialisasi status kontrak."

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr "Beberapa aturan penting yang perlu diperhatikan:"

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr "Kontrak Anda tidak boleh memiliki lebih dari satu konstruktor."

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr "Fungsi konstruktor Anda harus diberi nama `constructor`."

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr "Harus diberi anotasi dengan atribut `#[constructor]`."

#: src/ch99-01-03-02-contract-functions.md:24
msgid "2. Public functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the contract. They must be defined inside "
"an implementation block annotated with the `#[external(v0)]` attribute. This attribute only affects the "
"visibility (public vs private/internal), but it doesn't inform us on the ability of these functions to modify "
"the state of the contract."
msgstr ""
"Seperti yang disebutkan sebelumnya, fungsi publik dapat diakses dari luar kontrak. Mereka harus didefinisikan di "
"dalam blok implementasi yang diberi atribut `#[external(v0)]`. Atribut ini hanya memengaruhi visibilitas (publik "
"vs privat/internal), tetapi tidak memberikan informasi tentang kemampuan fungsi-fungsi ini untuk memodifikasi "
"status kontrak."

#: src/ch99-01-03-02-contract-functions.md:47
msgid "External functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:49
msgid ""
"External functions are functions that can modify the state of a contract. They are public and can be called by "
"any other contract or externally. External functions are _public_ functions where the `self: ContractState` is "
"passed as reference with the `ref` keyword, allowing you to modify the state of the contract."
msgstr ""
"Fungsi eksternal adalah fungsi yang dapat memodifikasi status suatu kontrak. Mereka bersifat publik dan dapat "
"dipanggil oleh kontrak lain atau dari luar. Fungsi eksternal adalah fungsi _publik_ di mana `self: "
"ContractState` dilewatkan sebagai referensi dengan kata kunci `ref`, memungkinkan Anda untuk memodifikasi status "
"kontrak."

#: src/ch99-01-03-02-contract-functions.md:59
msgid "View functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:61
msgid ""
"View functions are read-only functions allowing you to access data from the contract while ensuring that the "
"state of the contract is not modified. They can be called by other contracts or externally. View functions are "
"_public_ functions where the `self: ContractState` is passed as snapshot, preventing you from modifying the "
"state of the contract."
msgstr ""
"Fungsi tampilan (view) adalah fungsi hanya baca yang memungkinkan Anda mengakses data dari kontrak sambil "
"memastikan bahwa status kontrak tidak dimodifikasi. Mereka dapat dipanggil oleh kontrak lain atau dari luar. "
"Fungsi tampilan adalah fungsi _publik_ di mana `self: ContractState` dilewatkan sebagai snapshot, mencegah Anda "
"untuk memodifikasi status kontrak."

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"**Note:** It's important to note that both external and view functions are public. To create an internal "
"function in a contract, you will need to define it outside of the implementation block annotated with the "
"`#[external(v0)]` attribute."
msgstr ""
"**Catatan:** Penting untuk dicatat bahwa fungsi eksternal dan fungsi tampilan (view) keduanya bersifat publik. "
"Untuk membuat fungsi internal dalam sebuah kontrak, Anda perlu mendefinisikannya di luar blok implementasi yang "
"diberi atribut `#[external(v0)]`."

#: src/ch99-01-03-02-contract-functions.md:73
msgid "3. Private functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the `#[external(v0)]` attribute are private functions "
"(also called internal functions). They can only be called from within the contract."
msgstr ""
"Fungsi-fungsi yang tidak didefinisikan dalam blok yang diberi atribut `#[external(v0)]` adalah fungsi pribadi "
"(juga disebut fungsi internal). Mereka hanya dapat dipanggil dari dalam kontrak itu sendiri."

#: src/ch99-01-03-02-contract-functions.md:90
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait definition for this implementation? Well, "
"the `#[generate_trait]` attribute is a special attribute that tells the compiler to generate a trait definition "
"for the implementation block. This allows you to get rid of the boilerplate code of defining a trait and "
"implementing it for the implementation block. We will see more about this in the [next section](./ch99-01-03-04-"
"reducing-boilerplate.md)."
msgstr ""
"Tunggu, apa itu atribut `#[generate_trait]`? Di mana definisi trait untuk implementasi ini? Nah, atribut "
"`#[generate_trait]` adalah atribut khusus yang memberi tahu kompiler untuk menghasilkan definisi trait untuk "
"blok implementasi. Ini memungkinkan Anda untuk menghilangkan kode boilerplate dari mendefinisikan sebuah trait "
"dan mengimplementasikannya untuk blok implementasi. Kita akan melihat lebih lanjut tentang hal ini di [bagian "
"berikutnya](./ch99-01-03-04-reducing-boilerplate.md)."

#: src/ch99-01-03-02-contract-functions.md:92
msgid ""
"At this point, you might still be wondering if all of this is really necessary if you don't need to access the "
"contract's state in your function (for example, a helper/library function). As a matter of fact, you can also "
"define internal functions outside of implementation blocks. The only reason why we _need_ to define functions "
"inside impl blocks is if we want to access the contract's state."
msgstr ""
"Pada titik ini, Anda mungkin masih bertanya-tanya apakah semua ini benar-benar diperlukan jika Anda tidak perlu "
"mengakses status kontrak dalam fungsi Anda (misalnya, fungsi bantu/perpustakaan). Sebenarnya, Anda juga dapat "
"mendefinisikan fungsi internal di luar blok implementasi. Satu-satunya alasan mengapa kita _harus_ "
"mendefinisikan fungsi di dalam blok impl adalah jika kita ingin mengakses status kontrak."

#: src/ch99-01-03-03-contract-events.md:1 src/ch99-01-05-00-components.md:29
msgid "Events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during execution. They provide a way for "
"smart contracts to communicate with the external world by logging information about specific occurrences in a "
"contract."
msgstr ""
"Events adalah struktur data kustom yang dihasilkan oleh kontrak pintar selama eksekusi. Mereka memberikan cara "
"bagi kontrak pintar untuk berkomunikasi dengan dunia eksternal dengan mencatat informasi tentang kejadian khusus "
"dalam sebuah kontrak."

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for instance, the Non-Fungible Tokens "
"(NFTs) minted on Starknet. All of these are indexed and stored in a database, then displayed to users through "
"the use of these events. Neglecting to include an event within your NFT contract could lead to a bad user "
"experience. This is because users may not see their NFTs appear in their wallets (wallets use these indexers to "
"display a user's NFTs)."
msgstr ""
"Events memiliki peran penting dalam pembuatan kontrak pintar. Ambil contoh, Token Non-Fungible (NFT) yang "
"diciptakan di Starknet. Semua ini diindeks dan disimpan dalam database, kemudian ditampilkan kepada pengguna "
"melalui penggunaan peristiwa ini. Mengabaikan untuk menyertakan peristiwa dalam kontrak NFT Anda dapat "
"mengakibatkan pengalaman pengguna yang buruk. Ini karena pengguna mungkin tidak melihat NFT mereka muncul di "
"dompet mereka (dompet menggunakan indexer ini untuk menampilkan NFT pengguna)."

#: src/ch99-01-03-03-contract-events.md:9
msgid "Defining events"
msgstr "Mendefinisikan events"

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, which implements the `starknet::"
"Event` trait, as enum variants. This trait is defined in the core library as follows:"
msgstr ""
"Semua peristiwa yang berbeda dalam kontrak didefinisikan dalam enum `Event`, yang mengimplementasikan trait "
"`starknet::Event` sebagai varian-varian enum. Trait ini didefinisikan dalam perpustakaan inti sebagai berikut:"

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate an implementation for the above "
"trait, instantiated with the Event type, which in our example is the following enum:"
msgstr ""
"Atribut `#[derive(starknet::Event)]` membuat kompiler menghasilkan implementasi untuk trait di atas, yang "
"diinstansiasi dengan tipe Event, yang dalam contoh kami adalah enum berikut:"

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and each variant needs to implement the "
"`starknet::Event` trait itself. Moreover, the members of these variants must implement the `Serde` trait (_c.f._ "
"[Appendix C: Serializing with Serde](./appendix-03-derivable-traits.md)), as keys/data are added to the event "
"using a serialization process."
msgstr ""
"Setiap varian event harus menjadi struktur dengan nama yang sama dengan varian tersebut, dan setiap varian harus "
"mengimplementasikan trait `starknet::Event` itu sendiri. Selain itu, anggota dari varian-varian ini harus "
"mengimplementasikan trait `Serde` (_cf._ [Lampiran C: Serializing with Serde](./appendix-03-derivable-traits."
"md)), karena kunci/data ditambahkan ke peristiwa menggunakan proses serialisasi."

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the `append_keys_and_data` function for "
"each variant of our `Event` enum. The generated implementation will append a single key based on the variant "
"name (`StoredName`), and then recursively call `append_keys_and_data` in the impl of the Event trait for the "
"variant’s type ."
msgstr ""
"Implementasi otomatis dari trait `starknet::Event` akan mengimplementasikan fungsi `append_keys_and_data` untuk "
"setiap varian dari enum `Event` kita. Implementasi yang dihasilkan akan menambahkan satu kunci berdasarkan nama "
"varian (`StoredName`), dan kemudian secara rekursif memanggil `append_keys_and_data` pada implementasi trait "
"Event untuk tipe varian tersebut."

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the contract address of the caller and the "
"name stored within the contract, where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with the `#[key]` as demonstrated in the "
"example for the `user` key."
msgstr ""
"Dalam kontrak kami, kami mendefinisikan sebuah peristiwa yang bernama `StoredName` yang mengeluarkan alamat "
"kontrak dari pemanggil dan nama yang disimpan dalam kontrak, di mana bidang `user` diserialisasikan sebagai "
"kunci dan bidang `name` diserialisasikan sebagai data. Untuk mengindeks kunci dari suatu peristiwa, cukup beri "
"anotasi dengan `#[key]` seperti yang ditunjukkan dalam contoh untuk kunci `user`."

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name })`, a key corresponding to the name "
"` StoredName`, specifically `sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized as key, "
"thanks to the `#[key]` attribute, while address is serialized as data. After everything is processed, we end up "
"with the following keys and data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [address]`."
msgstr ""
"Saat mengeluarkan peristiwa dengan `self.emit(StoredName { user: user, name: name })`, sebuah kunci yang sesuai "
"dengan nama `StoredName`, khususnya `sn_keccak(StoredName)`, ditambahkan ke daftar kunci. `user` "
"diserialisasikan sebagai kunci, berkat atribut `#[key]`, sementara alamat diserialisasikan sebagai data. Setelah "
"semuanya diproses, kita mendapatkan kunci dan data berikut: `keys = [sn_keccak(\"StoredName\"),user]` dan `data "
"= [address]`."

#: src/ch99-01-03-03-contract-events.md:48
msgid "Emitting events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:50
msgid "After defining events, we can emit them using `self.emit`, with the following syntax:"
msgstr ""
"Setelah mendefinisikan peristiwa, kita dapat mengeluarkannya menggunakan `self.emit`, dengan sintaks berikut:"

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a contract that didn't have any "
"corresponding trait."
msgstr ""
"Pada bagian sebelumnya, kita melihat contoh blok implementasi dalam suatu kontrak yang tidak memiliki trait yang "
"sesuai."

#: src/ch99-01-03-04-reducing-boilerplate.md:18
msgid ""
"It's not the first time that we encounter this attribute, we already talked about in it [Traits in Cairo](./"
"ch08-02-traits-in-cairo.md). In this section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""
"Ini bukan kali pertama kita bertemu dengan atribut ini, kita sudah membicarakannya dalam [Traits in Cairo](./"
"ch08-02-traits-in-cairo.md). Pada bagian ini, kita akan melihat lebih dalam tentangnya dan melihat bagaimana "
"atribut ini dapat digunakan dalam kontrak."

#: src/ch99-01-03-04-reducing-boilerplate.md:20
msgid ""
"Recall that in order to access the ContractState in a function, this function must be defined in an "
"implementation block whose generic parameter is `ContractState`. This implies that we first need to define a "
"generic trait that takes a `TContractState`, and then implement this trait for the `ContractState` type. But by "
"using the `#[generate_trait]` attribute, this whole process can be skipped and we can simply define the "
"implementation block directly, without any generic parameter, and use `self: ContractState` in our functions."
msgstr ""
"Ingat bahwa untuk mengakses ContractState dalam suatu fungsi, fungsi ini harus didefinisikan dalam blok "
"implementasi yang generic parameternya adalah `ContractState`. Ini mengimplikasikan bahwa kita pertama-tama "
"perlu mendefinisikan trait generik yang mengambil `TContractState`, dan kemudian mengimplementasikan trait ini "
"untuk tipe `ContractState`. Tetapi dengan menggunakan atribut `#[generate_trait]`, seluruh proses ini dapat "
"dilewati dan kita dapat dengan mudah mendefinisikan blok implementasi secara langsung, tanpa parameter generik "
"apapun, dan menggunakan `self: ContractState` dalam fungsi-fungsi kita."

#: src/ch99-01-03-04-reducing-boilerplate.md:23
msgid ""
"If we had to manually define the trait for the `InternalFunctions` implementation, it would look something like "
"this:"
msgstr ""
"Jika kita harus secara manual mendefinisikan trait untuk implementasi `InternalFunctions`, akan terlihat seperti "
"ini:"

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr "Optimasi Penyimpanan dengan `StorePacking`"

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a piece of data. When done well, it can "
"significantly reduce the size of the data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""
"Pengemasan bit adalah konsep yang sederhana: Gunakan sebanyak mungkin bit yang diperlukan untuk menyimpan sebuah "
"data. Jika dilakukan dengan baik, ini dapat secara signifikan mengurangi ukuran data yang perlu Anda simpan. Hal "
"ini terutama penting dalam kontrak pintar, di mana penyimpanan mahal."

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage usage to reduce gas costs. Indeed, most "
"of the cost associated with a transaction is related to storage updates; and each storage slot costs gas to "
"write to. This means that by packing multiple values into fewer slots, you can decrease the gas cost incurred by "
"the users of your smart contract."
msgstr ""
"Ketika menulis kontrak pintar Cairo, penting untuk mengoptimalkan penggunaan penyimpanan guna mengurangi biaya "
"gas. Memang, sebagian besar biaya yang terkait dengan suatu transaksi berhubungan dengan pembaruan penyimpanan; "
"dan setiap slot penyimpanan memerlukan biaya gas untuk ditulis. Ini berarti dengan memadatkan beberapa nilai ke "
"dalam slot yang lebih sedikit, Anda dapat mengurangi biaya gas yang ditanggung oleh pengguna kontrak pintar Anda."

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into fewer storage slots. For example, "
"consider a `Sizes` struct with 3 fields of different types. The total size is 8 + 32 + 64 = 104 bits. This is "
"less than the 128 bits of a single `u128`. This means we can pack all 3 fields into a single `u128` variable. "
"Since a storage slot can hold up to 251 bits, our packed value will take only one storage slot instead of 3."
msgstr ""
"Cairo menyediakan trait `StorePacking` untuk memungkinkan pengemasan bidang struktur ke dalam slot penyimpanan "
"yang lebih sedikit. Sebagai contoh, pertimbangkan struktur `Sizes` dengan 3 bidang berbagai jenis. Ukuran "
"totalnya adalah 8 + 32 + 64 = 104 bit. Ini kurang dari 128 bit dari satu variabel `u128`. Ini berarti kita dapat "
"memadatkan semua 3 bidang ke dalam satu variabel `u128`. Karena satu slot penyimpanan dapat menampung hingga 251 "
"bit, nilai yang dipadatkan kita akan memerlukan hanya satu slot penyimpanan daripada 3."

#: src/ch99-01-03-05-optimizing-storage.md:49
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:58
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:66
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr "Mengoptimalkan penyimpanan dengan mengimplementasikan trait `StorePacking`"

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by performing bitshift and additions. "
"The `unpack` reverses this process to extract the original fields back into a struct."
msgstr ""
"Fungsi `pack` menggabungkan ketiga bidang ke dalam satu nilai `u128` dengan melakukan operasi pergeseran bit dan "
"penambahan. Fungsi `unpack` membalikkan proses ini untuk mengekstrak kembali bidang asli ke dalam sebuah "
"struktur."

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the operations performed in the example: "
"The goal is to pack the `tiny`, `small`, and `medium` fields into a single `u128` value. First, when packing:"
msgstr ""
"Jika Anda tidak familiar dengan operasi bit, berikut adalah penjelasan dari operasi-operasi yang dilakukan dalam "
"contoh ini: Tujuannya adalah untuk memadatkan bidang `tiny`, `small`, dan `medium` ke dalam satu nilai `u128`. "
"Pertama, saat memadatkan:"

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. This creates a `u128` value with the "
"low 8 bits set to `tiny`'s value."
msgstr ""
"`tiny` adalah `u8` sehingga kita langsung mengonversinya menjadi `u128` dengan `.into()`. Ini membuat nilai "
"`u128` dengan 8 bit terendah diatur ke nilai `tiny`."

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the value 0 to the left) to create room "
"for the 8 bites taken by `tiny`. Then we add `tiny` to `small` to combine them into a single `u128` value. The "
"value of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""
"`small` adalah `u32` sehingga kita pertama-tama menggesernya ke kiri sebanyak 8 bit (menambahkan 8 bit dengan "
"nilai 0 di sebelah kiri) untuk membuat ruang bagi 8 bit yang diambil oleh `tiny`. Kemudian kita tambahkan nilai "
"`tiny` ke `small` untuk menggabungkannya menjadi satu nilai `u128`. Nilai dari `tiny` sekarang mengambil bit 0-7 "
"dan nilai dari `small` mengambil bit 8-39."

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits (`TWO_POW_40`) to make space for the "
"previous fields. This takes bits 40-103."
msgstr ""
"Demikian pula, `medium` adalah `u64` sehingga kita menggesernya ke kiri sebanyak 40 (8 + 32) bit (`TWO_POW_40`) "
"untuk memberikan ruang bagi bidang sebelumnya. Ini mencakup bit 40-103."

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& MASK_8`). This isolates the lowest 8 "
"bits of the packed value, which is `tiny`'s value."
msgstr ""
"Pertama, kita ekstrak nilai `tiny` dengan melakukan operasi bitwise ANDing (&) dengan bitmask 8 ones (`& "
"MASK_8`). Ini mengisolasi 8 bit terendah dari nilai yang dipadatkan, yang merupakan nilai `tiny`."

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the bitmask, then use bitwise AND with "
"the 32 ones bitmask."
msgstr ""
"Untuk `small`, kita melakukan pergeseran ke kanan sebesar 8 bit (`/ TWO_POW_8`) untuk menyelaraskan dengan "
"bitmask, kemudian menggunakan operasi bitwise AND dengan bitmask 32 ones."

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, we don't need to apply a bitmask as "
"the higher bits are already 0."
msgstr ""
"Untuk `medium`, kita melakukan pergeseran ke kanan sebesar 40 bit. Karena ini adalah nilai terakhir yang "
"dipadatkan, kita tidak perlu menerapkan bitmask karena bit yang lebih tinggi sudah bernilai 0."

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit size of the packed storage type. For "
"example, if you have a struct with multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack them into a single `u512` variable, "
"and so on. You can define your own structs and logic to pack and unpack them."
msgstr ""
"Teknik ini dapat digunakan untuk setiap kelompok bidang yang cocok dalam ukuran bit dari tipe penyimpanan yang "
"dipadatkan. Sebagai contoh, jika Anda memiliki struktur dengan beberapa bidang yang ukuran bit-nya ditambahkan "
"menjadi 256 bit, Anda dapat memadatkannya ke dalam satu variabel `u256`. Jika ukuran bit-nya ditambahkan menjadi "
"512 bit, Anda dapat memadatkannya ke dalam satu variabel `u512`, dan seterusnya. Anda dapat mendefinisikan "
"struktur dan logika sendiri untuk memadatkan dan membuka padatan tersebut."

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type implements the `StorePacking` trait, then the "
"compiler will know it can use the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, however, is that the type that "
"`StorePacking::pack` spits out also has to implement `Store` for `StoreUsingPacking` to work. Most of the time, "
"we will want to pack into a felt252 or u256 - but if you want to pack into a type of your own, make sure that "
"this one implements the `Store` trait."
msgstr ""
"Sisa pekerjaan tersebut dilakukan secara ajaib oleh kompiler - jika suatu tipe mengimplementasikan trait "
"`StorePacking`, maka kompiler akan tahu bahwa dapat menggunakan implementasi `StoreUsingPacking` dari trait "
"`Store` untuk mengemas sebelum menulis dan membongkar setelah membaca dari penyimpanan. Namun, satu detail "
"penting adalah bahwa tipe yang dihasilkan oleh `StorePacking::pack` juga harus mengimplementasikan `Store` agar "
"`StoreUsingPacking` dapat berfungsi. Sebagian besar waktu, kita akan menginginkan pengemasan ke felt252 atau "
"u256 - tetapi jika Anda ingin mengemas ke tipe milik Anda sendiri, pastikan bahwa tipe tersebut "
"mengimplementasikan trait `Store`."

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "Komponen: Blok Bangunan Seperti Lego untuk Kontrak Pintar"

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and bug-prone, as this logic can hardly "
"be reused and needs to be reimplemented in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of your contract from the rest?"
msgstr ""
"Mengembangkan kontrak yang berbagi logika dan penyimpanan umum dapat menyakitkan dan rentan terhadap bug, karena "
"logika ini sulit untuk digunakan kembali dan perlu diimplementasikan ulang dalam setiap kontrak. Tetapi "
"bagaimana jika ada cara untuk menyisipkan hanya fungsionalitas tambahan yang Anda butuhkan di dalam kontrak "
"Anda, memisahkan logika inti kontrak Anda dari yang lain?"

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating reusable logic, storage, and events that "
"can be incorporated into multiple contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""
"Komponen menyediakan hal tersebut secara tepat. Mereka adalah tambahan modular yang mengemas logika, "
"penyimpanan, dan peristiwa yang dapat digunakan kembali yang dapat disertakan ke dalam beberapa kontrak. Mereka "
"dapat digunakan untuk memperluas fungsionalitas kontrak tanpa harus mengimplementasikan ulang logika yang sama "
"berulang kali."

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts by plugging in a module that you or "
"someone else wrote. This module can be a simple one, like an ownership component, or more complex like a full-"
"fledged ERC20 token."
msgstr ""
"Pikirkan tentang komponen sebagai blok Lego. Mereka memungkinkan Anda memperkaya kontrak Anda dengan menyematkan "
"modul yang Anda atau orang lain tulis. Modul ini bisa menjadi yang sederhana, seperti komponen kepemilikan, atau "
"lebih kompleks seperti token ERC20 yang lengkap."

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and functions. Unlike a contract, a component "
"cannot be declared or deployed. Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""
"Sebuah komponen adalah modul terpisah yang dapat berisi penyimpanan (storage), peristiwa (events), dan fungsi-"
"fungsi. Berbeda dengan kontrak, sebuah komponen tidak dapat dideklarasikan atau didaftarkan. Logikanya pada "
"akhirnya akan menjadi bagian dari bytecode kontrak yang telah disematkan di dalamnya."

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "Sebuah komponen sangat mirip dengan kontrak. Ini dapat berisi:"

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch99-01-05-00-components.md:30
msgid "External and internal functions"
msgstr "Fungsi eksternal dan internal"

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The component's code becomes part of the contract "
"it's embedded to."
msgstr ""
"Berbeda dengan kontrak, sebuah komponen tidak dapat dideploy secara independen. Kode komponen menjadi bagian "
"dari kontrak tempat komponen tersebut disematkan."

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr "Membuat Komponen"

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a `#[starknet::component]` attribute. "
"Within this module, you can declare a ` Storage` struct and `Event` enum, as usually done in [Contracts](./"
"ch99-01-02-a-simple-contract.md)."
msgstr ""
"Untuk membuat sebuah komponen, pertama-tama tentukan komponen tersebut dalam modulnya sendiri yang diberi "
"atribut `#[starknet::component]`. Dalam modul ini, Anda dapat mendeklarasikan struktur `Storage` dan enumerasi "
"`Event`, seperti yang biasanya dilakukan dalam [Kontrak](./ch99-01-02-a-simple-contract.md)."

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the signatures of the functions that will allow "
"external access to the component's logic. You can define the interface of the component by declaring a trait "
"with the `#[starknet::interface]` attribute, just as you would with contracts. This interface will be used to "
"enable external access to the component's functions using the [Dispatcher](./ch99-02-02-contract-dispatcher-"
"library-dispatcher-and-system-calls.md) pattern."
msgstr ""
"Langkah selanjutnya adalah mendefinisikan antarmuka komponen, yang berisi tanda tangan fungsi-fungsi yang akan "
"mengizinkan akses eksternal ke logika komponen. Anda dapat mendefinisikan antarmuka dari komponen dengan "
"mendeklarasikan sebuah trait dengan atribut `#[starknet::interface]`, sama halnya dengan yang Anda lakukan "
"dengan kontrak-kontrak. Antarmuka ini akan digunakan untuk mengaktifkan akses eksternal ke fungsi-fungsi "
"komponen menggunakan pola [Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md)."

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an `impl` block marked as "
"`#[embeddable_as(name)]`. Usually, this `impl` block will be an implementation of the trait defining the "
"interface of the component."
msgstr ""
"Implementasi aktual logika eksternal komponen dilakukan dalam blok `impl` yang ditandai sebagai "
"`#[embeddable_as(name)]`. Biasanya, blok `impl` ini akan menjadi implementasi dari trait yang mendefinisikan "
"antarmuka dari komponen."

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the component. It is different than the "
"name of your impl."
msgstr ""
"Catatan: `name` adalah nama yang akan kita gunakan dalam kontrak untuk merujuk ke komponen. Ini berbeda dengan "
"nama impl Anda."

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible externally, by simply omitting the "
"`#[embeddable_as(name)]` attribute above the internal `impl` block. You will be able to use these internal "
"functions inside the contract you embed the component in, but not interact with it from outside, as they're not "
"a part of the abi of the contract."
msgstr ""
"Anda juga dapat mendefinisikan fungsi-fungsi internal yang tidak akan dapat diakses secara eksternal, dengan "
"hanya menghilangkan atribut `#[embeddable_as(name)]` di atas blok `impl` internal. Anda akan dapat menggunakan "
"fungsi-fungsi internal ini di dalam kontrak yang menanamkan komponen, tetapi tidak dapat berinteraksi dengan "
"mereka dari luar, karena mereka bukan bagian dari abi dari kontrak."

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: ComponentState<TContractState>` (for state-"
"modifying functions) or `self: @ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any contract."
msgstr ""
"Fungsi-fungsi dalam blok `impl` ini mengharapkan argumen seperti `ref self: ComponentState<TContractState>` "
"(untuk fungsi-fungsi yang memodifikasi state) atau `self: @ComponentState<TContractState>` (untuk fungsi-fungsi "
"view). Hal ini membuat impl menjadi generik terhadap `TContractState`, memungkinkan kita untuk menggunakan "
"komponen ini dalam berbagai kontrak."

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr "Contoh: sebuah komponen Ownable"

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for production use. The authors are not "
"responsible for any damages caused by the use of this code."
msgstr ""
"⚠️ Contoh yang ditunjukkan di bawah ini belum diaudit dan tidak dimaksudkan untuk digunakan secara produksi. Para "
"penulis tidak bertanggung jawab atas segala kerusakan yang disebabkan oleh penggunaan kode ini."

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available externally to manage ownership of a "
"contract, would look like this:"
msgstr ""
"Antarmuka dari komponen Ownable, yang mendefinisikan metode-metode yang tersedia secara eksternal untuk "
"mengelola kepemilikan sebuah kontrak, akan terlihat seperti ini:"

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr "Komponen itu sendiri didefinisikan sebagai:"

#: src/ch99-01-05-00-components.md:167
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The only differences relate to the "
"`#[embeddable_as]` attribute above the impl and the genericity of the impl block that we will dissect in details."
msgstr ""
"Syntax ini sebenarnya cukup mirip dengan syntax yang digunakan untuk kontrak. Satu-satunya perbedaan terkait "
"dengan atribut `#[embeddable_as]` di atas impl dan genericity dari blok impl yang akan kita analisis secara "
"detail."

#: src/ch99-01-05-00-components.md:171
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to the implementation of the interface "
"trait, and one containing methods that should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make sense, as it's only meant to be used "
"internally by a contract embedding the component."
msgstr ""
"Seperti yang dapat Anda lihat, komponen kami memiliki dua blok `impl`: satu yang sesuai dengan implementasi dari "
"trait antarmuka, dan satu berisi metode-metode yang tidak seharusnya terpapar secara eksternal dan hanya "
"dimaksudkan untuk penggunaan internal. Memaparkan `assert_only_owner` sebagai bagian dari antarmuka tidak akan "
"masuk akal, karena itu hanya dimaksudkan untuk digunakan secara internal oleh sebuah kontrak yang menanamkan "
"komponen."

#: src/ch99-01-05-00-components.md:177
msgid "A closer look at the `impl` block"
msgstr "Pemeriksaan lebih rinci pada blok `impl`"

#: src/ch99-01-05-00-components.md:188
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable inside a contract. It allows us to "
"specify the name of the impl that will be used in the contract to refer to this component. In this case, the "
"component will be referred to as `Ownable` in contracts embedding it."
msgstr ""
"Atribut `#[embeddable_as]` digunakan untuk menandai impl sebagai yang dapat disematkan di dalam sebuah kontrak. "
"Ini memungkinkan kita untuk menentukan nama impl yang akan digunakan dalam kontrak untuk merujuk ke komponen "
"ini. Dalam kasus ini, komponen ini akan dirujuk sebagai `Ownable` dalam kontrak yang menanamkannya."

#: src/ch99-01-05-00-components.md:193
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, with the added restriction that "
"`TContractState` must implement the `HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. Understanding this mechanism in details "
"is not required to use components, but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) section."
msgstr ""
"Implementasi itu sendiri generik terhadap `ComponentState<TContractState>`, dengan pembatasan tambahan bahwa "
"`TContractState` harus mengimplementasikan trait `HasComponent<T>`. Ini memungkinkan kita untuk menggunakan "
"komponen dalam setiap kontrak, selama kontrak tersebut mengimplementasikan trait `HasComponent`. Memahami "
"mekanisme ini secara detail tidak diperlukan untuk menggunakan komponen, tetapi jika Anda penasaran tentang cara "
"kerjanya, Anda dapat membaca lebih lanjut di bagian [Komponen di Balik Layar](./ch99-01-05-01-components-under-"
"the-hood.md)."

#: src/ch99-01-05-00-components.md:201
msgid ""
"One of the major differences from a regular smart contract is that access to storage and events is done via the "
"generic `ComponentState<TContractState>` type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via `self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""
"Salah satu perbedaan utama dari sebuah kontrak pintar reguler adalah bahwa akses ke penyimpanan dan peristiwa "
"dilakukan melalui tipe generik `ComponentState<TContractState>` dan bukan `ContractState`. Perhatikan bahwa "
"meskipun tipe ini berbeda, akses penyimpanan atau pengeluaran peristiwa dilakukan secara serupa melalui `self."
"storage_var_name.read()` atau `self.emit(...).`"

#: src/ch99-01-05-00-components.md:207
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, we recommend keeping the suffix "
"`Impl` in the impl name."
msgstr ""
"Catatan: Untuk menghindari kebingungan antara nama yang dapat disematkan dan nama impl, kami merekomendasikan "
"untuk tetap menyisipkan akhiran `Impl` dalam nama impl."

#: src/ch99-01-05-00-components.md:210
msgid "Migrating a Contract to a Component"
msgstr "Migrasi Kontrak ke Komponen"

#: src/ch99-01-05-00-components.md:212
msgid ""
"Since both contracts and components share a lot of similarities, it's actually very easy to migrate from a "
"contract to a component. The only changes required are:"
msgstr ""
"Karena kedua kontrak dan komponen memiliki banyak kesamaan, sebenarnya sangat mudah untuk bermigrasi dari sebuah "
"kontrak ke sebuah komponen. Satu-satunya perubahan yang diperlukan adalah:"

#: src/ch99-01-05-00-components.md:216
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr "Menambahkan atribut `#[starknet::component]` ke modul."

#: src/ch99-01-05-00-components.md:217
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will be embedded in another contract."
msgstr "Menambahkan atribut `#[embeddable_as(name)]` ke blok `impl` yang akan disematkan dalam kontrak lain."

#: src/ch99-01-05-00-components.md:219
msgid "Adding generic parameters to the `impl` block:"
msgstr "Menambahkan parameter generik ke blok `impl`:"

#: src/ch99-01-05-00-components.md:220
msgid "Adding `TContractState` as a generic parameter."
msgstr "Menambahkan `TContractState` sebagai parameter generik."

#: src/ch99-01-05-00-components.md:221
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr "Menambahkan `+HasComponent<TContractState>` sebagai batasan impl."

#: src/ch99-01-05-00-components.md:222
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` block to "
"`ComponentState<TContractState>` instead of `ContractState`."
msgstr ""
"Mengubah tipe argumen `self` dalam fungsi-fungsi di dalam blok `impl` menjadi `ComponentState<TContractState>` "
"alih-alih `ContractState`."

#: src/ch99-01-05-00-components.md:225
msgid ""
"For traits that do not have an explicit definition and are generated using `#[generate_trait]`, the logic is the "
"same - but the trait is generic over `TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""
"Untuk trait yang tidak memiliki definisi eksplisit dan dihasilkan menggunakan `#[generate_trait]`, logikanya "
"sama - tetapi trait tersebut bersifat generic terhadap `TContractState` alih-alih "
"`ComponentState<TContractState>`, seperti yang ditunjukkan dalam contoh dengan `InternalTrait`."

#: src/ch99-01-05-00-components.md:230
msgid "Using components inside a contract"
msgstr "Menggunakan komponen di dalam kontrak"

#: src/ch99-01-05-00-components.md:232
msgid ""
"The major strength of components is how it allows reusing already built primitives inside your contracts with a "
"restricted amount of boilerplate. To integrate a component into your contract, you need to:"
msgstr ""
"Kekuatan utama dari komponen adalah bagaimana ia memungkinkan penggunaan kembali primitif-primitif yang sudah "
"dibangun di dalam kontrak Anda dengan jumlah boilerplate yang terbatas. Untuk mengintegrasikan sebuah komponen "
"ke dalam kontrak Anda, Anda perlu:"

#: src/ch99-01-05-00-components.md:236
msgid "Declare it with the `component!()` macro, specifying"
msgstr "Deklarasikan dengan menggunakan macro `component!()`, dengan menentukan"

#: src/ch99-01-05-00-components.md:238
msgid "The path to the component `path::to::component`."
msgstr "Jalur ke komponen `path::to::component`."

#: src/ch99-01-05-00-components.md:239
msgid "The name of the variable in your contract's storage referring to this component's storage (e.g. `ownable`)."
msgstr ""
"Nama variabel dalam penyimpanan kontrak Anda yang merujuk pada penyimpanan komponen ini (misalnya, `ownable`)."

#: src/ch99-01-05-00-components.md:241
msgid ""
"The name of the variant in your contract's event enum referring to this component's events (e.g. `OwnableEvent`)."
msgstr ""
"Nama varian dalam enumerasi acara kontrak Anda yang merujuk pada acara komponen ini (misalnya, `OwnableEvent`)."

#: src/ch99-01-05-00-components.md:244
msgid ""
"Add the path to the component's storage and events to the contract's `Storage` and `Event`. They must match the "
"names provided in step 1 (e.g. `ownable: ownable_component::Storage` and `OwnableEvent: ownable_component::"
"Event`)."
msgstr ""
"Tambahkan jalur penyimpanan dan acara komponen ke `Storage` dan `Event` kontrak. Mereka harus sesuai dengan nama-"
"nama yang diberikan pada langkah 1 (misalnya, `ownable: ownable_component::Storage` dan `OwnableEvent: "
"ownable_component::Event`)."

#: src/ch99-01-05-00-components.md:249
msgid "The storage variable **MUST** be annotated with the `#[substorage(v0)]` attribute."
msgstr "Variabel penyimpanan **HARUS** diberi anotasi dengan atribut `#[substorage(v0)]`."

#: src/ch99-01-05-00-components.md:252
msgid ""
"Embed the component's logic defined inside your contract, by instantiating the component's generic impl with a "
"concrete `ContractState` using an impl alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""
"Sematkan logika komponen yang didefinisikan di dalam kontrak Anda, dengan menginstansiasi impl generic komponen "
"dengan `ContractState` konkret menggunakan alias impl. Alias ini harus dianotasi dengan `#[abi(embed_v0)]` untuk "
"mengekspos secara eksternal fungsi-fungsi komponen."

#: src/ch99-01-05-00-components.md:257
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. Indeed, we don't want to expose "
"externally the functions defined in this impl. However, we might still want to access them internally."
msgstr ""
"Seperti yang dapat Anda lihat, InternalImpl tidak ditandai dengan `#[abi(embed_v0)]`. Memang, kita tidak ingin "
"mengekspos secara eksternal fungsi-fungsi yang didefinisikan dalam impl ini. Namun, kita mungkin masih ingin "
"mengaksesnya secara internal."

#: src/ch99-01-05-00-components.md:263
msgid "For example, to embed the `Ownable` component defined above, we would do the following:"
msgstr ""
"Sebagai contoh, untuk menyematkan komponen `Ownable` yang didefinisikan di atas, kita akan melakukan hal berikut:"

#: src/ch99-01-05-00-components.md:301
msgid ""
"The component's logic is now seamlessly part of the contract! We can interact with the components functions "
"externally by calling them using the `IOwnableDispatcher` instantiated with the contract's address."
msgstr ""
"Logika komponen sekarang secara mulus menjadi bagian dari kontrak! Kami dapat berinteraksi dengan fungsi-fungsi "
"komponen secara eksternal dengan memanggilnya menggunakan `IOwnableDispatcher` yang diinstansiasi dengan alamat "
"kontrak."

#: src/ch99-01-05-00-components.md:314
msgid "Stacking Components for Maximum Composability"
msgstr "Menumpuk Komponen untuk Komposabilitas Maksimum"

#: src/ch99-01-05-00-components.md:316
msgid ""
"The composability of components really shines when combining multiple of them together. Each adds its features "
"onto the contract. You will be able to rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common functionalities you need a contract to "
"have."
msgstr ""
"Kemampuan komposabilitas dari komponen benar-benar bersinar ketika menggabungkan beberapa di antaranya bersama-"
"sama. Setiap komponen menambahkan fiturnya ke kontrak. Anda akan dapat mengandalkan implementasi komponen "
"[OpenZeppelin's](https://github.com/OpenZeppelin/cairo-contracts) di masa mendatang untuk dengan cepat "
"menyematkan semua fungsionalitas umum yang Anda perlukan pada kontrak."

#: src/ch99-01-05-00-components.md:322
msgid ""
"Developers can focus on their core contract logic while relying on battle-tested and audited components for "
"everything else."
msgstr ""
"Pengembang dapat fokus pada logika inti kontrak mereka sambil mengandalkan komponen yang telah diuji pertempuran "
"dan diaudit untuk segala hal lainnya."

#: src/ch99-01-05-00-components.md:325
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on other components by restricting the "
"`TContractstate` they're generic on to implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the hood](./ch99-01-05-01-components-under-the-hood)."
msgstr ""
"Komponen bahkan dapat [menggantungkan diri](./ch99-01-05-02-component-dependencies.md) pada komponen lain dengan "
"membatasi `TContractstate` yang mereka generic pada untuk mengimplementasikan trait dari komponen lain. Sebelum "
"kita mendalami mekanisme ini, mari kita lihat terlebih dahulu [bagaimana komponen bekerja di balik layar](./"
"ch99-01-05-01-components-under-the-hood)."

#: src/ch99-01-05-00-components.md:330
msgid "Troubleshooting"
msgstr ""

#: src/ch99-01-05-00-components.md:332
msgid ""
"You might encounter some errors when trying to implement components. Unfortunately, some of them lack meaningful "
"error messages to help debug. This section aims to provide you with some pointers to help you debug your code."
msgstr ""
"Anda mungkin mengalami beberapa kesalahan saat mencoba mengimplementasikan komponen. Sayangnya, beberapa di "
"antaranya tidak memiliki pesan kesalahan yang bermakna untuk membantu debug. Bagian ini bertujuan untuk "
"memberikan beberapa petunjuk untuk membantu Anda debug kode Anda."

#: src/ch99-01-05-00-components.md:336
msgid "`Trait not found. Not a trait.`"
msgstr "`Trait not found. Not a trait.`"

#: src/ch99-01-05-00-components.md:338
msgid ""
"This error can occur when you're not importing the component's impl block correctly in your contract. Make sure "
"to respect the following syntax:"
msgstr ""
"Kesalahan ini dapat terjadi ketika Anda tidak mengimpor blok impl komponen dengan benar dalam kontrak Anda. "
"Pastikan untuk mengikuti sintaks berikut:"

#: src/ch99-01-05-00-components.md:346
msgid "Referring to our previous example, this would be:"
msgstr "Mengacu pada contoh sebelumnya kita, ini akan menjadi:"

#: src/ch99-01-05-00-components.md:353
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's Storage. Consider adding to Storage: (...)`"
msgstr ""
"`Plugin diagnostic: nama bukanlah anggota substorage dalam penyimpanan Storage kontrak. Pertimbangkan untuk "
"menambahkannya ke dalam Storage: (...)`"

#: src/ch99-01-05-00-components.md:356
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on the action to take. Basically, you "
"forgot to add the component's storage to your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's storage."
msgstr ""
"Kompilator membantu Anda banyak dalam debug ini dengan memberikan rekomendasi tentang tindakan yang harus "
"diambil. Pada dasarnya, Anda lupa menambahkan penyimpanan komponen ke penyimpanan kontrak Anda. Pastikan untuk "
"menambahkan jalur penyimpanan komponen yang dianotasi dengan atribut `#[substorage(v0)]` ke penyimpanan kontrak "
"Anda."

#: src/ch99-01-05-00-components.md:361
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. Consider adding to the Event enum:`"
msgstr ""
"`Plugin diagnostic: nama bukanlah acara bersarang dalam enumerasi Event kontrak. Pertimbangkan untuk "
"menambahkannya ke dalam enumerasi Event:`"

#: src/ch99-01-05-00-components.md:364
msgid ""
"Similar to the previous error, the compiler, you forgot to add the component's events to your contract's events. "
"Make sure to add the path to the component's events to your contract's events."
msgstr ""
"Seperti kesalahan sebelumnya, kompilator menyatakan bahwa Anda lupa menambahkan acara-acara komponen ke acara-"
"acara kontrak Anda. Pastikan untuk menambahkan jalur acara-acara komponen ke acara-acara kontrak Anda."

#: src/ch99-01-05-00-components.md:368
msgid "Components functions are not accessible externally"
msgstr "Fungsi-fungsi komponen tidak dapat diakses secara eksternal"

#: src/ch99-01-05-00-components.md:370
msgid ""
"This can happen if you forgot to annotate the component's impl block with `#[abi(embed_v0)]`. Make sure to add "
"this annotation when embedding the component's impl in your contract."
msgstr ""
"Ini dapat terjadi jika Anda lupa memberi anotasi blok impl komponen dengan `#[abi(embed_v0)]`. Pastikan untuk "
"menambahkan anotasi ini saat menyematkan blok impl komponen ke dalam kontrak Anda."

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr "Komponen di Balik Layar"

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does this magic actually happen behind the "
"scenes?"
msgstr ""
"Komponen memberikan modularitas yang kuat untuk kontrak Starknet. Tetapi bagaimana sebenarnya keajaiban ini "
"terjadi di balik layar?"

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the mechanisms that enable component "
"composability."
msgstr ""
"Bab ini akan menyelami ke dalam internal kompilator untuk menjelaskan mekanisme yang memungkinkan komposabilitas "
"komponen."

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr "Pengantar Mengenai Implementasi yang Dapat Disematkan"

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid "Before digging into components, we need to understand _embeddable impls_."
msgstr ""
"Sebelum menggali ke dalam komponen, kita perlu memahami _implementasi yang dapat disematkan_ (embeddable impls)."

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) can be made embeddable. Embeddable "
"impls can be injected into any contract, adding new entry points and modifying the ABI of the contract."
msgstr ""
"Implementasi dari trait antarmuka Starknet (ditandai dengan `#[starknet::interface]`) dapat dibuat embeddable. "
"Implementasi yang dapat disematkan ini dapat disisipkan ke dalam kontrak apa pun, menambahkan titik masuk baru "
"dan memodifikasi ABI dari kontrak tersebut."

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "Mari lihat contoh untuk melihat ini dalam aksi:"

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid "By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr "Dengan menyematkan `SimpleImpl`, kita secara eksternal mengungkapkan `ret4` dalam ABI kontrak."

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid "Now that we’re more familiar with the embedding mechanism, we can now see how components build on this."
msgstr ""
"Sekarang setelah kita lebih familiar dengan mekanisme penyematan, kita dapat melihat bagaimana komponen "
"membangun dari ini."

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr "Di Dalam Komponen: Implementasi Generik"

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "Ingatlah sintaks blok impl yang digunakan dalam komponen:"

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr "Key points:"

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the `HasComponent<TContractState>` trait by the underlying "
"contract, which is automatically generated with the `component!()` macro when using a component inside a "
"contract."
msgstr ""
"`OwnableImpl` memerlukan implementasi dari trait `HasComponent<TContractState>` oleh kontrak yang mendasarinya, "
"yang secara otomatis dihasilkan dengan makro `component!()` ketika menggunakan komponen di dalam kontrak."

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, replacing the `self: "
"ComponentState<TContractState>` argument with `self: TContractState`, where access to the component state is "
"made via the `get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""
"Kompiler akan menghasilkan impl yang membungkus setiap fungsi dalam `OwnableImpl`, menggantikan argumen `self: "
"ComponentState<TContractState>` dengan `self: TContractState`, di mana akses ke status komponen dilakukan "
"melalui fungsi `get_component` dalam trait `HasComponent<TContractState>`."

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This trait defines the interface to bridge "
"between the actual `TContractState` of a generic contract, and `ComponentState<TContractState>`."
msgstr ""
"Untuk setiap komponen, kompiler menghasilkan trait `HasComponent`. Trait ini mendefinisikan antarmuka untuk "
"menjembatani antara `TContractState` aktual dari kontrak generik dan `ComponentState<TContractState>`."

#: src/ch99-01-05-01-components-under-the-hood.md:75
msgid "// generated per component\n"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the ownable component, i.e. it has members "
"based on the storage variables defined in `ownable_component::Storage`. Moving from the generic `TContractState` "
"to `ComponentState<TContractState>` will allow us to embed `Ownable` in any contract that wants to use it. The "
"opposite direction (`ComponentState<TContractState>` to `ContractState`) is useful for dependencies (see the "
"`Upgradeable` component depending on an `IOwnable` implementation example in the [Components dependencies ](./"
"ch99-01-05-02-component-dependencies.md) section."
msgstr ""
"Dalam konteks kita, `ComponentState<TContractState>` adalah tipe yang spesifik untuk komponen ownable, yaitu "
"memiliki anggota berdasarkan variabel penyimpanan yang didefinisikan dalam `ownable_component::Storage`. "
"Berpindah dari generic `TContractState` ke `ComponentState<TContractState>` akan memungkinkan kita menyematkan "
"`Ownable` dalam setiap kontrak yang ingin menggunakannya. Arah sebaliknya (`ComponentState<TContractState>` ke "
"`ContractState`) berguna untuk dependensi (lihat contoh implementasi `IOwnable` oleh komponen `Upgradeable` pada "
"bagian [Komponen Dependensi](./ch99-01-05-02-component-dependencies.md))."

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above `HasComponent<T>` as saying: **“Contract "
"whose state T has the upgradeable component”.**"
msgstr ""
"Secara singkat, seseorang seharusnya memandang implementasi dari `HasComponent<T>` di atas sebagai berkata: "
"**“Kontrak yang memiliki komponen yang dapat ditingkatkan untuk state T”.**"

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr "`Ownable` dianotasi dengan atribut `embeddable_as(<name>)`:"

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of `starknet::interface` traits and "
"allows embedding this impl in a contract module. That said, `embeddable_as(<name>)` has another role in the "
"context of components. Eventually, when embedding `OwnableImpl` in some contract, we expect to get an impl with "
"the following functions:"
msgstr ""
"`embeddable_as` mirip dengan `embeddable`; itu hanya berlaku untuk `impls` dari trait `starknet::interface` dan "
"memungkinkan penyematan impl ini dalam modul kontrak. Meskipun demikian, `embeddable_as(<name>)` memiliki peran "
"lain dalam konteks komponen. Pada akhirnya, ketika menyematkan `OwnableImpl` dalam suatu kontrak, kita berharap "
"mendapatkan impl dengan fungsi-fungsi berikut:"

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type `ComponentState<TContractState>`, we want to "
"end up with a function receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. To see the "
"full picture, we need to see what is the impl generated by the compiler due to the `embeddable_as(Ownable)` "
"annotation:"
msgstr ""
"Perhatikan bahwa meskipun kita memulai dengan fungsi yang menerima tipe generik "
"`ComponentState<TContractState>`, kita ingin berakhir dengan fungsi yang menerima `ContractState`. Inilah "
"saatnya menggunakan `embeddable_as(<name>)`. Untuk melihat gambaran keseluruhan, kita perlu melihat impl yang "
"dihasilkan oleh kompiler karena adanya anotasi `embeddable_as(Ownable)`:"

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the compiler was able to wrap our "
"functions in a new impl that doesn’t directly know about the `ComponentState` type. `Ownable`, whose name we "
"chose when writing `embeddable_as(Ownable)`, is the impl that we will embed in a contract that wants ownership."
msgstr ""
"Perhatikan bahwa berkat adanya impl dari `HasComponent<TContractState>`, kompiler dapat membungkus fungsi-fungsi "
"kita dalam sebuah impl baru yang tidak langsung mengetahui tentang tipe `ComponentState`. `Ownable`, yang kita "
"pilih saat menulis `embeddable_as(Ownable)`, adalah impl yang akan kita sematkan ke dalam kontrak yang ingin "
"memiliki kepemilikan."

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "Contract Integration"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see how a contract integrates a component."
msgstr ""
"Kita telah melihat bagaimana impl generik memungkinkan penggunaan kembali komponen. Selanjutnya, mari kita lihat "
"bagaimana sebuah kontrak mengintegrasikan sebuah komponen."

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic impl with the concrete "
"`ContractState` of the contract."
msgstr ""
"Kontrak menggunakan **alias impl** untuk menginisialisasi impl generik komponen dengan tipe konkret "
"`ContractState` dari kontrak."

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl alias syntax. We’re instantiating the "
"generic `OwnableImpl<TContractState>` with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic impl parameter. An implementation "
"of this trait is generated by the `component!` macro."
msgstr ""
"Baris-baris di atas menggunakan mekanisme penyematan impl Cairo bersamaan dengan sintaksis alias impl. Kami "
"menginisialisasi generic `OwnableImpl<TContractState>` dengan tipe konkret `ContractState`. Ingat bahwa "
"`OwnableImpl<TContractState>` memiliki parameter impl generik `HasComponent<TContractState>`. Implementasi trait "
"ini dihasilkan oleh makro `component!`."

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since only it knows about both the contract "
"state and the component state."
msgstr ""
"Perhatikan bahwa hanya kontrak yang menggunakan yang dapat mengimplementasikan trait ini karena hanya kontrak "
"tersebut yang mengetahui tentang kedua status kontrak dan status komponen."

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid "This glues everything together to inject the component logic into the contract."
msgstr "Ini menggabungkan semuanya untuk menyisipkan logika komponen ke dalam kontrak."

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding entry points and modifying the "
"contract ABI."
msgstr ""
"Impl yang dapat disematkan memungkinkan penyisipan logika komponen ke dalam kontrak dengan menambahkan titik "
"masuk dan memodifikasi ABI kontrak."

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation when a component is used in a "
"contract. This creates a bridge between the contract's state and the component's state, enabling interaction "
"between the two."
msgstr ""
"Kompiler secara otomatis menghasilkan implementasi trait `HasComponent` ketika sebuah komponen digunakan dalam "
"sebuah kontrak. Ini menciptakan jembatan antara status kontrak dan status komponen, memungkinkan interaksi di "
"antara keduanya."

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. Contracts integrate components "
"through impl aliases and access them via the generated `HasComponent` trait."
msgstr ""
"Komponen mengemas logika yang dapat digunakan kembali dengan cara yang generik dan tidak tergantung pada kontrak "
"tertentu. Kontrak mengintegrasikan komponen melalui alias implementasi dan mengaksesnya melalui trait yang "
"dihasilkan `HasComponent`."

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic that can be integrated into any "
"contract wanting to use that component. Impl aliases instantiate these generic impls with the contract's "
"concrete storage types."
msgstr ""
"Komponen membangun pada implementasi yang dapat disematkan dengan mendefinisikan logika komponen generik yang "
"dapat diintegrasikan ke dalam setiap kontrak yang ingin menggunakan komponen tersebut. Alias implementasi "
"menginisialisasi implementasi generik ini dengan tipe penyimpanan konkret dari kontrak."

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr "Starknet contracts: ABIs dan cross-contract interactions"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating complex decentralized applications, "
"as it allows for composability and separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""
"Interaksi antara smart contract adalah fitur penting saat membuat aplikasi terdesentralisasi yang kompleks, "
"karena ini memungkinkan untuk komposabilitas dan pemisahan kepentingan. Bab ini memberikan pandangan tentang "
"cara membuat kontrak berinteraksi satu sama lain."

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and library dispatchers and their low-"
"level system call equivalents!"
msgstr ""
"Secara khusus, Anda akan mempelajari tentang ABIs, antarmuka kontrak, dispatcher kontrak dan perpustakaan, serta "
"setara panggilan sistem tingkat rendah mereka!"

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr "ABIs dan Antarmuka kontrak"

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a common practice which enables us to "
"build flexible contracts that can speak with each other."
msgstr ""
"Interaksi Cross-contract pintar di sebuah blockchain adalah praktik umum yang memungkinkan kita membangun "
"kontrak yang fleksibel dan dapat berkomunikasi satu sama lain."

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "Mencapai hal ini di Starknet membutuhkan sesuatu yang kita sebut sebagai antarmuka."

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the contract's functions and structures, giving "
"anyone (or any other contract) the ability to form encoded calls to it. It is a blueprint that instructs how "
"functions should be called, what input parameters they expect, and in what format."
msgstr ""
"Pada Starknet, ABI dari sebuah kontrak adalah representasi JSON dari fungsi dan struktur kontrak, memberikan "
"kemampuan kepada siapa saja (atau kontrak lain) untuk membentuk panggilan yang dienkripsi kepadanya. Ini adalah "
"panduan yang memberitahu cara fungsi harus dipanggil, parameter input apa yang diharapkan, dan dalam format apa."

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are stored on the VM as executable bytecodes "
"which are in binary formats. Since this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods which can be called to a smart contract "
"for execution. Without an ABI, it becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"Meskipun kita menulis logika kontrak pintar kita dalam bahasa Cairo tingkat tinggi, mereka disimpan di VM "
"sebagai bytecodes eksekusi yang berbentuk biner. Karena bytecode ini tidak dapat dibaca oleh manusia, diperlukan "
"interpretasi untuk bisa dimengerti. Di sinilah ABIs berperan, dengan mendefinisikan metode-metode tertentu yang "
"dapat dipanggil untuk menjalankan kontrak pintar. Tanpa ABI, menjadi praktis tidak mungkin bagi pelaku eksternal "
"untuk memahami cara berinteraksi dengan kontrak."

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data correctly, making it understandable by "
"the smart contract and vice versa. When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), they use the contract's ABI to format "
"the data you send to the contract and the data it returns."
msgstr ""
"ABIs umumnya digunakan dalam frontend dApps, memungkinkannya memformat data dengan benar sehingga dapat "
"dimengerti oleh kontrak pintar dan sebaliknya. Ketika Anda berinteraksi dengan kontrak pintar melalui penjelajah "
"blok seperti [Voyager](https://voyager.online/) atau [Starkscan](https://starkscan.co/), mereka menggunakan ABI "
"kontrak untuk memformat data yang Anda kirimkan ke kontrak dan data yang dikembalikan olehnya."

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. It specifies the function signatures "
"(name, parameters, visibility and return value) contained in a smart contract without including the function "
"body."
msgstr ""
"Antarmuka kontrak adalah daftar fungsi yang diekspos secara publik oleh kontrak. Ini menentukan tanda tangan "
"fungsi (nama, parameter, visibilitas, dan nilai kembalian) yang terkandung dalam kontrak pintar tanpa "
"menyertakan tubuh fungsi."

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the `#[starknet::interface]` attribute. If you are new to "
"traits, check out the dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Antarmuka kontrak dalam Cairo adalah trait yang dianotasi dengan atribut `#[starknet::interface]`. Jika Anda "
"baru mengenal trait, lihat bab khusus tentang [traits](./ch08-02-traits-in-cairo.md)."

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the `TContractState` type. This is required "
"for functions to access the contract's storage, so that they can read and write to it."
msgstr ""
"Spesifikasi penting adalah bahwa trait ini harus generik terhadap tipe `TContractState`. Ini diperlukan agar "
"fungsi dapat mengakses penyimpanan kontrak, sehingga dapat membaca dan menulis ke dalamnya."

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are internal functions part of the interface."
msgstr ""
"Catatan: Konstruktor kontrak tidak termasuk dalam antarmuka. Begitu juga dengan fungsi internal yang bukan "
"bagian dari antarmuka."

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's a generic trait over the "
"`TContractState` type. `view` functions have a self parameter of type `@TContractState`, while `external` "
"functions have a self parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"Berikut adalah antarmuka contoh untuk kontrak token ERC20. Seperti yang dapat Anda lihat, ini adalah trait "
"generik atas tipe `TContractState`. Fungsi `view` memiliki parameter `self` bertipe `@TContractState`, sementara "
"fungsi `external` memiliki parameter `self` bertipe yang dilewatkan dengan referensi `ref self: TContractState`."

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "Listing 99-4: A simple ERC20 Interface"
msgstr "Listing 99-4: A simple ERC20 Interface"

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart contracts using _dispatchers_ and "
"_syscalls_ ."
msgstr ""
"Pada bab berikutnya, kita akan melihat bagaimana kita dapat memanggil kontrak dari kontrak pintar lain "
"menggunakan _dispatchers_ dan _syscalls_."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid "Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr "Berinteraksi dengan kontrak dan kelas lain menggunakan Pemanggil dan syscalls"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically created and exported by the "
"compiler. Let's consider an interface that we named IERC20, these would be:"
msgstr ""
"Setiap kali sebuah antarmuka kontrak didefinisikan, dua pemanggil secara otomatis dibuat dan diekspor oleh "
"kompiler. Mari pertimbangkan sebuah antarmuka yang kita namai IERC20, ini akan menjadi:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr "Contract Dispatcher `IERC20Dispatcher`"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr "Library Dispatcher `IERC20LibraryDispatcher`"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to call the functions defined in the "
"interface on the dispatcher struct."
msgstr ""
"Kompiler juga menghasilkan trait `IERC20DispatcherTrait`, memungkinkan kita untuk memanggil fungsi yang "
"didefinisikan dalam antarmuka pada struktur dispatcher."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid "In this chapter, we are going to discuss what these are, how they work and how to use them."
msgstr "Dalam bab ini, kita akan membahas apa itu, bagaimana cara kerjanya, dan bagaimana menggunakannya."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be using the IERC20 interface from the "
"previous chapter (refer to Listing 99-4):"
msgstr ""
"Untuk secara efektif memahami konsep dalam bab ini, kita akan menggunakan antarmuka IERC20 dari bab sebelumnya "
"(lihat Listing 99-4):"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` attribute automatically generate a "
"dispatcher and a trait on compilation. Our `IERC20` interface is expanded into something like this:"
msgstr ""
"Seperti yang disebutkan sebelumnya, trait yang dianotasi dengan atribut `#[starknet::interface]` secara otomatis "
"menghasilkan pemanggil dan trait saat dikompilasi. Antarmuka `IERC20` kita diperluas menjadi sesuatu seperti ini:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to keep this chapter concise and "
"straight to the point, we focused on one view function `name`, and one external function `transfer`."
msgstr ""
"**Catatan:** Kode yang diperluas untuk antarmuka IERC20 kami jauh lebih panjang, tetapi untuk menjaga bab ini "
"ringkas dan langsung ke pokok, kami berfokus pada satu fungsi pandangan `name`, dan satu fungsi eksternal "
"`transfer`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:37
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "Listing 99-5: An expanded form of the IERC20 trait"
msgstr "Listing 99-5: Bentuk yang diperluas dari trait IERC20"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a contract address and implements the "
"`DispatcherTrait` generated by the compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to call, and then simply call the "
"functions defined in the interface on the dispatcher struct as if they were methods of that type."
msgstr ""
"Seperti yang dapat Anda lihat, \"dispatcher\" klasik hanyalah sebuah struktur yang melibatkan alamat kontrak dan "
"mengimplementasikan `DispatcherTrait` yang dihasilkan oleh kompiler, memungkinkan kita untuk memanggil fungsi "
"dari kontrak lain. Ini berarti bahwa kita dapat membuat instansi dari struktur dengan alamat kontrak yang ingin "
"kita panggil, dan kemudian cukup memanggil fungsi yang didefinisikan dalam antarmuka pada struktur dispatcher "
"seolah-olah mereka adalah metode dari tipe tersebut."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes thanks to the power of Cairo plugins."
msgstr "Perlu dicatat bahwa semua ini diabstraksikan di balik layar berkat kekuatan plugin Cairo."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "Memanggil Kontrak menggunakan Pemanggil Kontrak"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to call functions defined on an ERC-20 "
"token. Calling `transfer_token` will modify the state of the contract deployed at `contract_address`."
msgstr ""
"Ini adalah contoh kontrak bernama `TokenWrapper` yang menggunakan pemanggil untuk memanggil fungsi yang "
"didefinisikan pada token ERC-20. Memanggil `transfer_token` akan memodifikasi status kontrak yang dideploy di "
"`contract_address`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "Listing 99-6: A sample contract which uses the Contract Dispatcher"
msgstr "Listing 99-6: Sebuah kontrak contoh yang menggunakan Pemanggil Kontrak"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and `IERC20Dispatcher` generated by the compiler, "
"which allows us to make calls to the methods implemented for the `IERC20Dispatcher` struct (`name`, `transfer`, "
"etc), passing in the `contract_address` of the contract we want to call in the `IERC20Dispatcher` struct."
msgstr ""
"Seperti yang dapat Anda lihat, kita harus mengimpor terlebih dahulu `IERC20DispatcherTrait` dan "
"`IERC20Dispatcher` yang dihasilkan oleh kompiler, yang memungkinkan kita untuk melakukan panggilan ke metode-"
"metode yang diimplementasikan untuk struct `IERC20Dispatcher` (`name`, `transfer`, dll.), meneruskan "
"`contract_address` dari kontrak yang ingin kita panggil di dalam struct `IERC20Dispatcher`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library dispatcher lies in the execution context of "
"the logic defined in the class. While regular dispatchers are used to call functions from **contracts** (with an "
"associated state), library dispatchers are used to call **classes** (stateless)."
msgstr ""
"Perbedaan kunci antara dispatcher kontrak dan dispatcher pustaka terletak pada konteks eksekusi logika yang "
"didefinisikan di dalam kelas. Sementara dispatcher reguler digunakan untuk memanggil fungsi dari **kontrak** "
"(dengan keadaan yang terkait), dispatcher pustaka digunakan untuk memanggil **kelas** (tanpa keadaan)."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "Mari kita pertimbangkan dua kontrak, A dan B."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the execution context of the logic defined "
"in B is that of B. This means that the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""
"Ketika A menggunakan `IBDispatcher` untuk memanggil fungsi dari **kontrak** B, konteks eksekusi logika yang "
"didefinisikan di B adalah milik B. Ini berarti nilai yang dikembalikan oleh `get_caller_address()` di B akan "
"mengembalikan alamat A, dan memperbarui variabel penyimpanan di B akan memperbarui penyimpanan B."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, the execution context of the logic "
"defined in B's class is that of A. This means that the value returned by `get_caller_address()` variable in B "
"will return the address of the caller of A, and updating a storage variable in B's class will update the storage "
"of A (remember that the **class** of B is stateless; there is no state that can be updated!)"
msgstr ""
"Ketika A menggunakan `IBLibraryDispatcher` untuk memanggil fungsi dari **kelas** B, konteks eksekusi logika yang "
"didefinisikan di kelas B adalah milik A. Ini berarti nilai yang dikembalikan oleh variabel "
"`get_caller_address()` di B akan mengembalikan alamat pemanggil A, dan memperbarui variabel penyimpanan di kelas "
"B akan memperbarui penyimpanan A (ingat bahwa **kelas** B adalah stateless; tidak ada keadaan yang dapat "
"diperbarui!)"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid "The expanded form of the struct and trait generated by the compiler look like:"
msgstr "Bentuk yang diperluas dari struct dan trait yang dihasilkan oleh kompiler terlihat seperti:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:157
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and the library dispatcher is that the "
"former uses `call_contract_syscall` while the latter uses `library_call_syscall`."
msgstr ""
"Perhatikan bahwa perbedaan utama antara dispatcher kontrak reguler dan dispatcher pustaka adalah bahwa yang "
"pertama menggunakan `call_contract_syscall` sedangkan yang kedua menggunakan `library_call_syscall`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "Listing 99-7: An expanded form of the IERC20 trait"
msgstr "Listing 99-7: Sebuah bentuk yang diperluas dari trait IERC20"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr "Memanggil Kontrak menggunakan Pustaka Dispatcher"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid "Below's a sample code for calling contracts using the Library Dispatcher."
msgstr "Berikut adalah contoh kode untuk memanggil kontrak menggunakan Pustaka Dispatcher."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:208
msgid "Listing 99-8: A sample contract using the Library Dispatcher"
msgstr "Listing 99-8: Sebuah contoh kontrak yang menggunakan Library Dispatcher"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the `IContractBDispatcherTrait` and "
"`IContractBLibraryDispatcher` which were generated from our interface by the compiler. Then, we can create an "
"instance of `IContractBLibraryDispatcher` passing in the `class_hash` of the class we want to make library calls "
"to. From there, we can call the functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call to the `set_value` function in "
"ContractB, updating the value of the storage variable `value` in ContractA."
msgstr ""
"Seperti yang dapat Anda lihat, kita harus mengimpor terlebih dahulu ke dalam kontrak kita "
"`IContractBDispatcherTrait` dan `IContractBLibraryDispatcher` yang dihasilkan dari antarmuka kita oleh kompiler. "
"Kemudian, kita dapat membuat instansi dari `IContractBLibraryDispatcher` dengan meneruskan `class_hash` dari "
"kelas yang ingin kita panggil sebagai pustaka. Dari sana, kita dapat memanggil fungsi-fungsi yang didefinisikan "
"dalam kelas tersebut, menjalankan logiknya dalam konteks kontrak kita. Ketika kita memanggil `set_value` pada "
"KontrakA, itu akan membuat panggilan pustaka ke fungsi `set_value` di KontrakB, memperbarui nilai variabel "
"penyimpanan `value` di KontrakA."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr "Menggunakan low-level syscalls"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the `starknet::call_contract_syscall`and `starknet::"
"library_call_syscall` system calls. The dispatchers we described in the previous sections are high-level "
"syntaxes for these low-level system calls."
msgstr ""
"Cara lain untuk memanggil kontrak dan kelas lain adalah dengan menggunakan panggilan sistem `starknet::"
"call_contract_syscall` dan `starknet::library_call_syscall`. Dispacher yang kita deskripsikan pada bagian "
"sebelumnya adalah sintaks tingkat tinggi untuk panggilan sistem tingkat rendah ini."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get more control over the serialization/"
"deserialization of the call data and the returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"Menggunakan syscalls ini dapat berguna untuk penanganan kesalahan yang disesuaikan atau untuk mendapatkan lebih "
"banyak kendali atas serialisasi/deserialisasi data panggilan dan data yang dikembalikan. Berikut adalah contoh "
"yang menunjukkan bagaimana menggunakan `call_contract_sycall` untuk memanggil fungsi `transfer` dari kontrak "
"ERC20:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:264
msgid "Listing 99-9: A sample contract using syscalls"
msgstr "Listing 99-9: Sebuah contoh kontrak yang menggunakan syscall"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:266
msgid ""
"To use this syscall, we passed in the contract address, the selector of the function we want to call, and the "
"call arguments."
msgstr ""
"Untuk menggunakan syscall ini, kami meneruskan alamat kontrak, pemilih fungsi yang ingin kami panggil, dan "
"argumen panggilan."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:268
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this array, we serialize the expected "
"function parameters into an `Array<felt252>` using the `Serde` trait, and then pass this array as calldata. At "
"the end, we are returned a serialized value which we'll need to deserialize ourselves!"
msgstr ""
"Argumen panggilan harus disediakan sebagai array `felt252`. Untuk membangun array ini, kita melakukan "
"serialisasi parameter fungsi yang diharapkan menjadi `Array<felt252>` menggunakan trait `Serde`, dan kemudian "
"meneruskan array ini sebagai calldata. Pada akhirnya, kita akan mendapatkan nilai yang diserialisasikan yang "
"perlu kita deserialisasikan sendiri!"

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, utilizing various features of the Cairo "
"programming language. Your contributions are welcome and encouraged, as we aim to gather as many diverse "
"examples as possible."
msgstr ""
"Bagian ini berisi contoh tambahan kontrak pintar Starknet, memanfaatkan berbagai fitur dari bahasa pemrograman "
"Cairo. Kontribusi Anda sangat diharapkan dan diterima dengan baik, karena kami bertujuan untuk mengumpulkan "
"sebanyak mungkin contoh yang beragam."

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the contract's constructor. Three "
"voters are initialized at this stage, and their addresses are passed to an internal function "
"**`_register_voters`**. This function adds the voters to the contract's state, marking them as registered and "
"eligible to vote."
msgstr ""
"Kontrak **`Vote`** di Starknet dimulai dengan mendaftarkan pemilih melalui konstruktor kontrak. Tiga pemilih "
"diinisialisasi pada tahap ini, dan alamat mereka diteruskan ke fungsi internal **`_register_voters`**. Fungsi "
"ini menambahkan pemilih ke status kontrak, menandai mereka sebagai terdaftar dan memenuhi syarat untuk "
"memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to represent the voting options (1 and 0, "
"respectively). These constants facilitate the voting process by standardizing the input values."
msgstr ""
"Dalam kontrak, konstanta **`YES`** dan **`NO`** didefinisikan untuk mewakili opsi pemilihan (1 dan 0, masing-"
"masing). Konstan ini memudahkan proses pemilihan dengan standarisasi nilai masukan."

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** function, selecting either the 1 (YES) or 0 "
"(NO) as their vote. When voting, the state of the contract is updated, recording the vote and marking the voter "
"as having voted. This ensures that the voter is not able to cast a vote again within the same proposal. The "
"casting of a vote triggers the **`VoteCast`** event, logging the action."
msgstr ""
"Setelah terdaftar, seorang pemilih dapat memberikan suara menggunakan fungsi **`vote`**, memilih 1 (YA) atau 0 "
"(TIDAK) sebagai suaranya. Saat memberikan suara, status kontrak diperbarui, mencatat suara dan menandai pemilih "
"sebagai yang sudah memberikan suara. Hal ini memastikan bahwa pemilih tidak dapat memberikan suara lagi dalam "
"proposal yang sama. Penyelenggaraan suara memicu acara **`VoteCast`**, mencatat tindakan tersebut."

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized action is detected, such as a non-"
"registered user attempting to vote or a user trying to vote again, the **`UnauthorizedAttempt`** event is "
"emitted."
msgstr ""
"Kontrak ini juga memantau upaya pemilihan yang tidak sah. Jika tindakan tidak sah terdeteksi, seperti pengguna "
"yang tidak terdaftar mencoba memberikan suara atau pengguna yang mencoba memberikan suara lagi, acara "
"**`UnauthorizedAttempt`** akan dipancarkan."

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured voting system, managing the "
"lifecycle of a vote from registration to casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the voting process, while events play a vital "
"role in ensuring transparency and traceability."
msgstr ""
"Secara bersama-sama, fungsi-fungsi, status, konstanta, dan acara-acara ini menciptakan sistem pemilihan "
"terstruktur, mengelola siklus hidup suatu pemilihan mulai dari pendaftaran hingga pencoblosan, pencatatan acara, "
"dan pengambilan hasil dalam lingkungan Starknet. Konstan seperti **`YES`** dan **`NO`** membantu menyederhanakan "
"proses pemilihan, sementara acara-acara memainkan peran penting dalam memastikan transparansi dan jejak jejak."

#: src/ch99-01-04-01-voting-contract.md:14
msgid "/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:16
msgid "/// @dev Trait defining the functions that can be implemented or called by the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:20
msgid "/// @dev Function that returns the current vote status\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:22
msgid "/// @dev Function that checks if the user at the specified address is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:24
msgid "/// @dev Function that checks if the specified address is registered as a voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:26
msgid "/// @dev Function that allows a user to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:29
msgid "/// @dev Starknet Contract allowing three registered voters to vote on a proposal\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:39
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:48
msgid "/// @dev Contract constructor initializing the contract with a list of registered voters and 0 vote count\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:56
msgid "// Register all voters by calling the _register_voters function\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:59
msgid "// Initialize the vote count to 0\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:64
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:72
msgid "/// @dev Represents a vote that was cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:79
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:85
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:88
msgid "/// @dev Returns the voting results\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:95
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:100
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:105
msgid "/// @dev Submit a vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:123
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:126
msgid "/// @dev Registers the voters and initializes their voting status to true (can vote)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:144
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:147
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:161
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:164
msgid "// @dev Internal function to get the voting results (yes and no vote counts)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:172
msgid "// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:191
msgid "Voting smart contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr "Mendeploy, Memanggil, dan Memanggil Kontrak Pemilihan"

#: src/ch99-01-04-01-voting-contract.md:195
msgid "Part of the Starknet experience is deploying and interacting with smart contracts."
msgstr "Bagian dari pengalaman Starknet adalah mendeploy dan berinteraksi dengan kontrak pintar."

#: src/ch99-01-04-01-voting-contract.md:197
msgid "Once the contract is deployed, we can interact with it by calling and invoking its functions:"
msgstr ""
"Setelah kontrak didaftarkan, kita dapat berinteraksi dengan kontrak tersebut dengan melakukan panggilan dan "
"pemanggilan fungsi-fungsinya:"

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from the state. These functions do not "
"alter the state of the network, so they don't require fees or signing."
msgstr ""
"Memanggil kontrak: Berinteraksi dengan fungsi eksternal yang hanya membaca dari status. Fungsi-fungsi ini tidak "
"mengubah status jaringan, sehingga tidak memerlukan biaya atau tanda tangan."

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to the state. These functions do alter "
"the state of the network and require fees and signing."
msgstr ""
"Memanggil kontrak: Berinteraksi dengan fungsi eksternal yang dapat menulis ke status. Fungsi-fungsi ini mengubah "
"status jaringan dan memerlukan biaya serta tanda tangan."

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting contract. Then, we'll interact with "
"the contract by calling and invoking its functions. You can also use the Goerli Testnet instead of `katana`. "
"However, we recommend using `katana` for local development and testing. You can find the complete tutorial for "
"`katana` in the [Local Development with Katana](https://book.starknet.io/chapter_3/katana.html) chapter of the "
"Starknet Book."
msgstr ""
"Kami akan menyiapkan node pengembangan lokal menggunakan `katana` untuk mendeploy kontrak pemilihan. "
"Selanjutnya, kita akan berinteraksi dengan kontrak tersebut dengan memanggil dan memanggil fungsi-fungsinya. "
"Anda juga dapat menggunakan Goerli Testnet sebagai pengganti `katana`. Namun, kami merekomendasikan menggunakan "
"`katana` untuk pengembangan dan pengujian lokal. Anda dapat menemukan panduan lengkap untuk `katana` dalam bab "
"[Pengembangan Lokal dengan Katana](https://book.starknet.io/chapter_3/katana.html) dari Buku Starknet."

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr "Node Starknet lokal `katana`"

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo team](https://github.com/dojoengine/dojo/blob/"
"main/crates/katana/README.md). It will allow you to do everything you need to do with Starknet, but locally. It "
"is a great tool for development and testing."
msgstr ""
"`katana` dirancang untuk mendukung pengembangan lokal oleh [tim Dojo](https://github.com/dojoengine/dojo/blob/"
"main/crates/katana/README.md). Ini akan memungkinkan Anda melakukan semua yang diperlukan dengan Starknet, "
"tetapi secara lokal. Ini adalah alat yang bagus untuk pengembangan dan pengujian."

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Local Development with Katana](https://book."
"starknet.io/chapter_3/katana.html) chapter of the Starknet Book."
msgstr ""
"Untuk menginstal `katana` dari kode sumber, silakan lihat bab [Pengembangan Lokal dengan Katana](https://book."
"starknet.io/chapter_3/katana.html) pada Buku Starknet."

#: src/ch99-01-04-01-voting-contract.md:210
msgid "Once you have `katana` installed, you can start the local Starknet node with:"
msgstr "Setelah Anda menginstal `katana`, Anda dapat memulai node Starknet lokal dengan:"

#: src/ch99-01-04-01-voting-contract.md:216
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We will use these accounts to deploy and "
"interact with the voting contract:"
msgstr ""
"Perintah ini akan memulai node Starknet lokal dengan 3 akun yang telah didaftarkan. Kami akan menggunakan akun-"
"akun ini untuk mendaftarkan dan berinteraksi dengan kontrak pemilihan:"

#: src/ch99-01-04-01-voting-contract.md:221
msgid "================="
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:237
msgid ""
"Before we can interact with the voting contract, we need to prepare the voter and admin accounts on Starknet. "
"Each voter account must be registered and sufficiently funded for voting. For a more detailed understanding of "
"how accounts operate with Account Abstraction, refer to the [Account Abstraction](https://book.starknet.io/"
"chapter_4/index.html) chapter of the Starknet Book."
msgstr ""
"Sebelum kita dapat berinteraksi dengan kontrak pemilihan, kita perlu menyiapkan akun pemilih dan admin di "
"Starknet. Setiap akun pemilih harus didaftarkan dan memiliki cukup dana untuk memberikan suara. Untuk pemahaman "
"yang lebih rinci tentang bagaimana akun beroperasi dengan Abstraksi Akun, lihat bab [Abstraksi Akun](https://"
"book.starknet.io/chapter_4/index.html) dari Buku Starknet."

#: src/ch99-01-04-01-voting-contract.md:239
msgid "Smart wallets for voting"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:241
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a command line tool that allows you to "
"interact with Starknet. You can find the installation instructions in the [Environment setup](https://book."
"starknet.io/chapter_1/environment_setup.html) chapter of the Starknet Book."
msgstr ""
"Selain Scarb, Anda juga perlu menginstal Starkli. Starkli adalah alat baris perintah yang memungkinkan Anda "
"berinteraksi dengan Starknet. Anda dapat menemukan petunjuk instalasi di bab [Pengaturan Environment](https://"
"book.starknet.io/chapter_1/environment_setup.html) dari Buku Starknet."

#: src/ch99-01-04-01-voting-contract.md:243
msgid ""
"For each smart wallet we'll use, we must create a Signer within the encrypted keystore and an Account "
"Descriptor. This process is also detailed in the [Environment setup](https://book.starknet.io/chapter_1/"
"environment_setup.html) chapter of the Starknet Book."
msgstr ""
"Untuk setiap dompet pintar yang akan kita gunakan, kita harus membuat Pemeterai (Signer) di dalam keystore "
"terenkripsi dan sebuah Deskripsi Akun. Proses ini juga dijelaskan secara rinci dalam bab [Pengaturan Environment]"
"(https://book.starknet.io/chapter_1/environment_setup.html) dari Buku Starknet."

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to use for voting. Let's create a smart "
"wallet for voting in our smart contract."
msgstr ""
"Kita dapat membuat Pemeterai (Signer) dan Deskripsi Akun untuk akun-akun yang ingin kita gunakan untuk "
"memberikan suara. Mari buat dompet pintar untuk memberikan suara dalam kontrak pintar kita."

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Firstly, we create a signer from a private key:"
msgstr "Pertama-tama, kita membuat pemeterai dari kunci pribadi:"

#: src/ch99-01-04-01-voting-contract.md:253
msgid "Then, we create the Account Descriptor:"
msgstr "Kemudian, kita membuat Account Descriptor:"

#: src/ch99-01-04-01-voting-contract.md:259
msgid ""
"The Account Descriptor will look like this. You can get the public key and the smart wallet address from the "
"output of the initial `katana` command:"
msgstr ""
"Account Descriptor: akan terlihat seperti ini. Anda dapat mendapatkan kunci publik dan alamat dompet pintar dari "
"keluaran perintah awal `katana`:"

#: src/ch99-01-04-01-voting-contract.md:263 src/ch99-01-04-01-voting-contract.md:266
#: src/ch99-01-04-01-voting-contract.md:375
msgid "\"version\""
msgstr "\"version\""

#: src/ch99-01-04-01-voting-contract.md:264
msgid "\"variant\""
msgstr "\"variant\""

#: src/ch99-01-04-01-voting-contract.md:265 src/ch99-01-04-01-voting-contract.md:381
msgid "\"type\""
msgstr "\"type\""

#: src/ch99-01-04-01-voting-contract.md:265
msgid "\"open_zeppelin\""
msgstr "\"open_zeppelin\""

#: src/ch99-01-04-01-voting-contract.md:267
msgid "\"public_key\""
msgstr "\"public_key\""

#: src/ch99-01-04-01-voting-contract.md:267
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr "\"<SMART_WALLET_PUBLIC_KEY>\""

#: src/ch99-01-04-01-voting-contract.md:269
msgid "\"deployment\""
msgstr "\"deployment\""

#: src/ch99-01-04-01-voting-contract.md:270
msgid "\"status\""
msgstr "\"status\""

#: src/ch99-01-04-01-voting-contract.md:270
msgid "\"deployed\""
msgstr "\"deployed\""

#: src/ch99-01-04-01-voting-contract.md:271
msgid "\"class_hash\""
msgstr "\"class_hash\""

#: src/ch99-01-04-01-voting-contract.md:271
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr "\"<SMART_WALLET_CLASS_HASH>\""

#: src/ch99-01-04-01-voting-contract.md:272
msgid "\"address\""
msgstr "\"address\""

#: src/ch99-01-04-01-voting-contract.md:272
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr "\"<SMART_WALLET_ADDRESS>\""

#: src/ch99-01-04-01-voting-contract.md:277
msgid ""
"Copy the Account Descriptor above and paste in the newly created `account0_account.json file`, then replace "
"\"\\<SMART_WALLET_PUBLIC_KEY>\", \"\\<SMART_WALLET_CLASS_HASH>\" and \"\\<SMART_WALLET_ADDRESS>\" with values "
"from the `katana` account used."
msgstr ""
"Salin Deskripsi Akun di atas dan tempelkan ke dalam file `account0_account.json` yang baru dibuat, kemudian "
"gantilah \"\\<SMART_WALLET_PUBLIC_KEY>\", \"\\<SMART_WALLET_CLASS_HASH>\" dan \"\\<SMART_WALLET_ADDRESS>\" "
"dengan nilai-nilai dari akun `katana` yang digunakan."

#: src/ch99-01-04-01-voting-contract.md:279
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all your smart wallets) with the following "
"command. Notice the use of the `--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""
"Anda dapat mengambil hash kelas dompet pintar (akan sama untuk semua dompet pintar Anda) dengan perintah "
"berikut. Perhatikan penggunaan flag `--rpc` dan ujung RPC yang disediakan oleh `katana`:"

#: src/ch99-01-04-01-voting-contract.md:281
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` command with the directory of the keystore "
"json file:"
msgstr ""
"Untuk kunci publik, Anda dapat menggunakan perintah `starkli signer keystore inspect` dengan direktori file json "
"keystore:"

#: src/ch99-01-04-01-voting-contract.md:291
msgid ""
"This process is identical for `account_1` and `account_2` in case you want to have a second and a third voter."
msgstr "Proses ini identik untuk `account_1` dan `account_2` jika Anda ingin memiliki voter kedua dan ketiga."

#: src/ch99-01-04-01-voting-contract.md:293
msgid "Contract Deployment"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:295
msgid "Before deploying, we need to declare the contract. We can do this with the `starkli declare` command:"
msgstr ""
"Sebelum melakukan penyebaran, kita perlu mendeklarasikan kontrak. Hal ini dapat dilakukan dengan perintah "
"`starkli declare`:"

#: src/ch99-01-04-01-voting-contract.md:301
msgid ""
"If the compiler version you're using is older than the one used by Starkli and you encounter a `compiler-"
"version` error while using the command above, you can specify a compiler version to use in the command by adding "
"the `--compiler-version x.y.z` flag."
msgstr ""
"Jika versi kompilator yang Anda gunakan lebih lama daripada yang digunakan oleh Starkli dan Anda mengalami "
"kesalahan `compiler-version` saat menggunakan perintah di atas, Anda dapat menentukan versi kompilator yang akan "
"digunakan dalam perintah dengan menambahkan flag `--compiler-version x.y.z`."

#: src/ch99-01-04-01-voting-contract.md:303
msgid ""
"If you're still encountering issues with the compiler version, try upgrading Starkli using the command: "
"`starkliup` to make sure you're using the latest version of starkli."
msgstr ""
"Jika Anda masih mengalami masalah dengan versi kompilator, coba perbarui Starkli menggunakan perintah: "
"`starkliup` untuk memastikan Anda menggunakan versi terbaru dari starkli."

#: src/ch99-01-04-01-voting-contract.md:305
msgid ""
"The class hash of the contract is: `0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You can "
"find it [on any block explorer](https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""
"Hash kelas dari kontrak adalah: `0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. Anda dapat "
"menemukannya [di penjelajah blok mana pun](https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."

#: src/ch99-01-04-01-voting-contract.md:307
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by `katana`). The `--account` flag "
"specifies the account to use for signing the transaction. The account we use here is the one we created in the "
"previous step. The `--keystore` flag specifies the keystore file to use for signing the transaction."
msgstr ""
"Flag `--rpc` menentukan titik akhir RPC yang digunakan (yang disediakan oleh `katana`). Flag `--account` "
"menentukan akun yang digunakan untuk menandatangani transaksi. Akun yang kita gunakan di sini adalah yang kita "
"buat pada langkah sebelumnya. Flag `--keystore` menentukan file keystore yang digunakan untuk menandatangani "
"transaksi."

#: src/ch99-01-04-01-voting-contract.md:309
msgid ""
"Since we are using a local node, the transaction will achieve finality immediately. If you are using the Goerli "
"Testnet, you will need to wait for the transaction to be final, which usually takes a few seconds."
msgstr ""
"Karena kita menggunakan node lokal, transaksi akan mencapai finalitas segera. Jika Anda menggunakan Goerli "
"Testnet, Anda perlu menunggu transaksi menjadi final, yang biasanya memerlukan waktu beberapa detik."

#: src/ch99-01-04-01-voting-contract.md:311
msgid ""
"The following command deploys the voting contract and registers voter_0, voter_1, and voter_2 as eligible "
"voters. These are the constructor arguments, so add a voter account that you can later vote with."
msgstr ""
"Perintah berikut ini mendeploy kontrak pemungutan suara dan mendaftarkan voter_0, voter_1, dan voter_2 sebagai "
"pemilih yang memenuhi syarat. Ini adalah argumen konstruktor, jadi tambahkan akun pemilih yang nantinya dapat "
"Anda gunakan untuk memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:317
msgid "An example command:"
msgstr "Example command:"

#: src/ch99-01-04-01-voting-contract.md:323
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This address will be different for you. We "
"will use this address to interact with the contract."
msgstr ""
"Dalam kasus ini, kontrak telah didisposisikan pada alamat spesifik: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. Alamat ini akan berbeda untuk Anda. Kami "
"akan menggunakan alamat ini untuk berinteraksi dengan kontrak."

#: src/ch99-01-04-01-voting-contract.md:325
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:327
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, `voter_can_vote` and "
"`is_voter_registered`. These are external read functions, which mean they don't alter the state of the contract "
"but only read the current state."
msgstr ""
"Dalam kontrak pemungutan suara kami, kami memiliki dua fungsi untuk memvalidasi kelayakan pemilih, "
"`voter_can_vote` dan `is_voter_registered`. Ini adalah fungsi baca eksternal, yang berarti mereka tidak mengubah "
"status kontrak tetapi hanya membaca status saat ini."

#: src/ch99-01-04-01-voting-contract.md:329
msgid ""
"The `is_voter_registered` function checks whether a particular address is registered as an eligible voter in the "
"contract. The `voter_can_vote` function, on the other hand, checks whether the voter at a specific address is "
"currently eligible to vote, i.e., they are registered and haven't voted already."
msgstr ""
"Fungsi `is_voter_registered` memeriksa apakah suatu alamat tertentu terdaftar sebagai pemilih yang memenuhi "
"syarat dalam kontrak. Sementara itu, fungsi `voter_can_vote` memeriksa apakah pemilih pada alamat tertentu saat "
"ini berhak untuk memberikan suara, yaitu, mereka terdaftar dan belum memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:331
msgid ""
"You can call these functions using the `starkli call` command. Note that the `call` command is used for read "
"functions, while the `invoke` command is used for functions that can also write to storage. The `call` command "
"does not require signing, while the `invoke` command does."
msgstr ""
"Anda dapat memanggil fungsi-fungsi ini menggunakan perintah `starkli call`. Perhatikan bahwa perintah `call` "
"digunakan untuk fungsi baca, sementara perintah `invoke` digunakan untuk fungsi yang juga dapat menulis ke "
"penyimpanan. Perintah `call` tidak memerlukan penandatanganan, sedangkan perintah `invoke` memerlukan "
"penandatanganan."

#: src/ch99-01-04-01-voting-contract.md:333
msgid ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:337
msgid ""
"First we added the address of the contract, then the function we want to call, and finally the input for the "
"function. In this case, we are checking whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can vote."
msgstr ""
"Pertama, kami menambahkan alamat kontrak, kemudian fungsi yang ingin kami panggil, dan akhirnya masukan untuk "
"fungsi tersebut. Dalam hal ini, kami sedang memeriksa apakah pemilih di alamat "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` dapat memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:339
msgid ""
"Since we provided a registered voter address as an input, the result is 1 (boolean true), indicating the voter "
"is eligible to vote."
msgstr ""
"Karena kami memberikan alamat pemilih yang terdaftar sebagai masukan, hasilnya adalah 1 (benar dalam bentuk "
"boolean), menunjukkan bahwa pemilih memenuhi syarat untuk memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:341
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered account address to observe the output:"
msgstr ""
"Selanjutnya, mari panggil fungsi `is_voter_registered` menggunakan alamat akun yang tidak terdaftar untuk "
"mengamati keluarannya:"

#: src/ch99-01-04-01-voting-contract.md:347
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., false), confirming that the account is not "
"eligible to vote."
msgstr ""
"Dengan alamat akun yang tidak terdaftar, keluaran terminal adalah 0 (yakni, salah), mengkonfirmasi bahwa akun "
"tersebut tidak memenuhi syarat untuk memberikan suara."

#: src/ch99-01-04-01-voting-contract.md:349
msgid "Casting a Vote"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:351
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! To vote, we interact with the `vote` "
"function, which is flagged as external, necessitating the use of the `starknet invoke` command."
msgstr ""
"Sekarang bahwa kita telah menetapkan cara untuk memverifikasi kelayakan pemilih, kita dapat memberikan suara! "
"Untuk memberikan suara, kita berinteraksi dengan fungsi `vote`, yang ditandai sebagai eksternal, memerlukan "
"penggunaan perintah `starknet invoke`."

#: src/ch99-01-04-01-voting-contract.md:353
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we submit either `1` (for Yes) or `0` "
"(for No) as our input. When we invoke the `vote` function, we are charged a fee, and the transaction must be "
"signed by the voter; we are writing to the contract's storage."
msgstr ""
"Sintaks perintah `invoke` mirip dengan perintah `call`, tetapi untuk memberikan suara, kita mengirimkan entah "
"`1` (untuk Ya) atau `0` (untuk Tidak) sebagai masukan kita. Saat kita memanggil fungsi `vote`, kita dikenakan "
"biaya, dan transaksi harus ditandatangani oleh pemilih; kita sedang menulis ke penyimpanan kontrak."

#: src/ch99-01-04-01-voting-contract.md:363
msgid ""
"You will be prompted to enter the password for the signer. Once you enter the password, the transaction will be "
"signed and submitted to the Starknet network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""
"Anda akan diminta untuk memasukkan kata sandi untuk penandatangan. Setelah Anda memasukkan kata sandi, transaksi "
"akan ditandatangani dan dikirimkan ke jaringan Starknet. Anda akan menerima hash transaksi sebagai keluaran. "
"Dengan perintah starkli transaction, Anda dapat mendapatkan lebih banyak rincian tentang transaksi:"

#: src/ch99-01-04-01-voting-contract.md:369
msgid "This returns:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:373
msgid "\"transaction_hash\""
msgstr "\"transaction_hash\""

#: src/ch99-01-04-01-voting-contract.md:373
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""

#: src/ch99-01-04-01-voting-contract.md:374
msgid "\"max_fee\""
msgstr "\"max_fee\""

#: src/ch99-01-04-01-voting-contract.md:374
msgid "\"0x430e81\""
msgstr "\"0x430e81\""

#: src/ch99-01-04-01-voting-contract.md:375 src/ch99-01-04-01-voting-contract.md:384
#: src/ch99-01-04-01-voting-contract.md:388 src/ch99-01-04-01-voting-contract.md:389
#: src/ch99-01-04-01-voting-contract.md:390
msgid "\"0x1\""
msgstr "\"0x1\""

#: src/ch99-01-04-01-voting-contract.md:376
msgid "\"signature\""
msgstr "\"signature\""

#: src/ch99-01-04-01-voting-contract.md:377
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""

#: src/ch99-01-04-01-voting-contract.md:378
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""

#: src/ch99-01-04-01-voting-contract.md:380
msgid "\"nonce\""
msgstr "\"nonce\""

#: src/ch99-01-04-01-voting-contract.md:380
msgid "\"0x3\""
msgstr "\"0x3\""

#: src/ch99-01-04-01-voting-contract.md:381
msgid "\"INVOKE\""
msgstr "\"INVOKE\""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "\"sender_address\""
msgstr "\"sender_address\""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""

#: src/ch99-01-04-01-voting-contract.md:383
msgid "\"calldata\""
msgstr "\"calldata\""

#: src/ch99-01-04-01-voting-contract.md:385
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"0x0\""
msgstr "\"0x0\""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""
"Jika Anda mencoba memberikan suara dua kali dengan penandatangan yang sama, Anda akan mendapatkan kesalahan:"

#: src/ch99-01-04-01-voting-contract.md:398
msgid "\"Contract error\""
msgstr "\"Contract error\""

#: src/ch99-01-04-01-voting-contract.md:401
msgid ""
"The error is not very informative, but you can get more details when looking at the output in the terminal where "
"you started `katana` (our local Starknet node):"
msgstr ""
"Error ini tidak memberikan informasi yang sangat informatif, tetapi Anda dapat mendapatkan lebih banyak detail "
"saat melihat output di terminal di mana Anda memulai `katana` (node Starknet lokal kita):"

#: src/ch99-01-04-01-voting-contract.md:405
msgid ""
"\"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\"
"\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:411
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:414
msgid "'USER_ALREADY_VOTED'"
msgstr "'USER_ALREADY_VOTED'"

#: src/ch99-01-04-01-voting-contract.md:417
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the accounts we want to use for voting. "
"Remember that each Signer must be created from a private key, and each Account Descriptor must be created from a "
"public key, a smart wallet address, and the smart wallet class hash (which is the same for each voter)."
msgstr ""
"Kita dapat mengulangi proses ini untuk membuat Signer dan Account Descriptor untuk akun yang ingin kita gunakan "
"untuk memberikan suara. Ingatlah bahwa setiap Signer harus dibuat dari kunci pribadi, dan setiap Account "
"Descriptor harus dibuat dari kunci publik, alamat smart wallet, dan hash kelas smart wallet (yang sama untuk "
"setiap pemilih)."

#: src/ch99-01-04-01-voting-contract.md:425
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:427
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, another view function, through the "
"`starknet call` command."
msgstr ""
"Untuk meneliti hasil pemungutan suara, kita memanggil fungsi `get_vote_status`, fungsi tampilan lain, melalui "
"perintah `starknet call`."

#: src/ch99-01-04-01-voting-contract.md:433
msgid "The output reveals the tally of \"Yes\" and \"No\" votes along with their relative percentages."
msgstr "Output menunjukkan jumlah suara \"Ya\" dan \"Tidak\" beserta persentasenya."

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr "Fitur penting dari Layer 2 adalah kemampuannya untuk berinteraksi dengan Layer 1."

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its consensus mechanism and the "
"submission of state updates on L1. Messaging is a way for smart-contracts on L1 to interact with smart-contracts "
"on L2 (or the other way around), allowing us to do \"cross-chain\" transactions. For example, we can do some "
"computations on a chain and use the result of this computation on the other chain."
msgstr ""
"Starknet memiliki sistem Pengiriman Pesan `L1-L2` sendiri, yang berbeda dari mekanisme konsensusnya dan "
"pengiriman pembaruan status di L1. Pengiriman pesan adalah cara bagi smart contract di L1 untuk berinteraksi "
"dengan smart contract di L2 (atau sebaliknya), memungkinkan kita melakukan transaksi \"cross-chain\". Sebagai "
"contoh, kita dapat melakukan beberapa komputasi pada suatu rantai dan menggunakan hasil komputasi ini pada "
"rantai lain."

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to bridge tokens from Ethereum to "
"Starknet. You will simply have to deposit your tokens in the L1 bridge contract, which will automatically "
"trigger the minting of the same token on L2. Another good use case for `L1-L2` messaging would be [DeFi pooling]"
"(https://starkware.co/resource/defi-pooling/)."
msgstr ""
"Jembatan di Starknet semuanya menggunakan pesan `L1-L2`. Katakanlah Anda ingin menjembatani token dari Ethereum "
"ke Starknet. Anda hanya perlu melakukan deposit token Anda ke kontrak jembatan L1, yang akan secara otomatis "
"memicu pembuatan token yang sama di L2. Penggunaan lain yang bagus untuk pesan `L1-L2` dapat ditemukan pada "
"[DeFi pooling](https://starkware.co/resource/defi-pooling/)."

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid "On Starknet, it's important to note that the messaging system is **asynchronous** and **asymmetric**."
msgstr "Di Starknet, penting untuk dicatat bahwa sistem pesannya **asynchronous** dan **asymmetric**."

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or Cairo), you can't wait the result of "
"the message being sent on the other chain within your contract code execution."
msgstr ""
"**Asynchronous**: ini berarti bahwa dalam kode kontrak Anda (baik itu Solidity atau Cairo), Anda tidak dapat "
"menunggu hasil dari pesan yang dikirimkan ke rantai lain dalam proses eksekusi kode kontrak Anda."

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is fully automatized by the Starknet "
"sequencer, which means that the message is being automatically delivered to the target contract on L2. However, "
"when sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the message is sent on L1 by the "
"Starknet sequencer. You must then consume the message manually via a transaction on L1."
msgstr ""
"**Asymmetric**: Mengirim pesan dari Ethereum ke Starknet (`L1->L2`) sepenuhnya diotomatisasi oleh sekuen "
"Starknet, yang berarti pesan secara otomatis dikirimkan ke kontrak tujuan di L2. Namun, saat mengirim pesan dari "
"Starknet ke Ethereum (`L2->L1`), hanya hash dari pesan yang dikirimkan di L1 oleh sekuen Starknet. Anda kemudian "
"harus secara manual mengonsumsi pesan tersebut melalui transaksi di L1."

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "Mari kita masuk ke dalam detailnya."

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "The StarknetMessaging Contract"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`](https://etherscan.io/"
"address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) contract. It is a set of Solidity contracts deployed on "
"Ethereum that allows Starknet to function properly. One of the contracts of `StarknetCore` is called "
"`StarknetMessaging` and it is the contract responsible for passing messages between Starknet and Ethereum. "
"`StarknetMessaging` follows an [interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) with "
"functions allowing to send message to L2, receiving messages on L1 from L2 and canceling messages."
msgstr ""
"Komponen penting dari sistem `L1-L2` Messaging adalah kontrak [`StarknetCore`](https://etherscan.io/"
"address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4). Ini merupakan serangkaian kontrak Solidity yang dideploy di "
"Ethereum yang memungkinkan Starknet untuk berfungsi dengan baik. Salah satu kontrak dari `StarknetCore` disebut "
"`StarknetMessaging` dan bertanggung jawab dalam mengirim pesan antara Starknet dan Ethereum. `StarknetMessaging` "
"mengikuti sebuah [interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) dengan "
"fungsi-fungsi yang memungkinkan pengiriman pesan ke L2, menerima pesan di L1 dari L2, dan membatalkan pesan."

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid " Starknet messaging contract interface"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly listening to the logs emitted by the "
"`StarknetMessaging` contract on Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 contract. This takes up to 1-2 minutes "
"to be done (few seconds for ethereum block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""
"Dalam kasus pesan `L1->L2`, sekuen Starknet terus-menerus mendengarkan log yang dihasilkan oleh kontrak "
"`StarknetMessaging` di Ethereum. Begitu pesan terdeteksi dalam log, sekuen membuat dan mengeksekusi sebuah "
"`L1HandlerTransaction` untuk memanggil fungsi pada kontrak L2 yang dituju. Proses ini membutuhkan waktu 1-2 "
"menit untuk dilakukan (beberapa detik untuk blok Ethereum ditambang, kemudian sekuen harus membangun dan "
"mengeksekusi transaksi)."

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of the block produced. When the "
"sequencer produces a block, it sends the hash of each message prepared by contracts execution to the "
"`StarknetCore` contract on L1, where they can then be consumed once the block they belong to is proven and "
"verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"Pesan `L2->L1` disiapkan oleh eksekusi kontrak di L2 dan merupakan bagian dari blok yang dihasilkan. Saat sekuen "
"menghasilkan sebuah blok, ia mengirimkan hash dari setiap pesan yang disiapkan oleh eksekusi kontrak ke kontrak "
"`StarknetCore` di L1, di mana pesan tersebut kemudian dapat dikonsumsi setelah blok yang mereka miliki terbukti "
"dan diverifikasi di Ethereum (yang saat ini memakan waktu sekitar 3-4 jam)."

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity contracts must call the `sendMessageToL2` "
"function of the `StarknetMessaging` contract. To receive these messages on Starknet, you will need to annotate "
"functions that can be called from L1 with the `#[l1_handler]` attribute."
msgstr ""
"Jika Anda ingin mengirim pesan dari Ethereum ke Starknet, kontrak Solidity Anda harus memanggil fungsi "
"`sendMessageToL2` dari kontrak `StarknetMessaging`. Untuk menerima pesan-pesan ini di Starknet, Anda perlu "
"menandai fungsi-fungsi yang dapat dipanggil dari L1 dengan atribut `#[l1_handler]`."

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this tutorial](https://github.com/glihm/starknet-messaging-dev/blob/"
"main/solidity/src/ContractMsg.sol) where we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` contract. You can check those addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""
"Mari kita lihat kontrak sederhana yang diambil dari [tutorial ini](https://github.com/glihm/starknet-messaging-"
"dev/blob/main/solidity/src/ContractMsg.sol) di mana kita ingin mengirim pesan ke Starknet. Variabel state "
"`_snMessaging` sudah diinisialisasi dengan alamat kontrak `StarknetMessaging`. Anda dapat memeriksa alamat-"
"alamat tersebut [di sini](https://docs.starknet.io/documentation/tools/important_addresses/)."

#: src/ch99-04-00-L1-L2-messaging.md:65
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:74
msgid "// We \"serialize\" here the felt into a payload, which is an array of uint256.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:78
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the `StarknetMessaging` contract. Please note that if "
"you want to send more complex data you can. Just be aware that your Cairo contract will only understand "
"`felt252` data type. So you must ensure that the serialization of your data into the `uint256` array follow the "
"cairo serialization scheme."
msgstr ""
"Fungsi tersebut mengirim pesan dengan satu nilai felt ke kontrak `StarknetMessaging`. Harap dicatat bahwa jika "
"Anda ingin mengirim data yang lebih kompleks, Anda dapat melakukannya. Namun, perhatikan bahwa kontrak Cairo "
"Anda hanya akan memahami tipe data `felt252`. Jadi, pastikan bahwa serialisasi data Anda ke dalam larik "
"`uint256` mengikuti skema serialisasi Cairo."

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the minimum value we've to send here is `20k "
"wei`, due to the fact that the `StarknetMessaging` contract will register the hash of our message in the storage "
"of Ethereum."
msgstr ""
"Penting untuk dicatat bahwa kita memiliki `{value: msg.value}`. Sebenarnya, nilai minimum yang harus kita "
"kirimkan di sini adalah `20 ribu wei`, karena kontrak `StarknetMessaging` akan mendaftarkan hash pesan kita "
"dalam penyimpanan Ethereum."

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be executed by the sequencer is not "
"bound to any account (the message originates from L1), you must also ensure that you pay enough fees on L1 for "
"your message to be deserialized and processed on L2."
msgstr ""
"Selain dari `20 ribu wei` tersebut, karena `L1HandlerTransaction` yang akan dieksekusi oleh sekuen tidak terikat "
"pada akun mana pun (pesan berasal dari L1), Anda juga harus memastikan membayar biaya yang cukup di L1 agar "
"pesan Anda dapat didekripsi dan diproses di L2."

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as it would be done for an `Invoke` "
"transaction. For this, you can profile the gas consumption using `starkli` or `snforge` to estimate the cost of "
"your message execution."
msgstr ""
"Biaya dari `L1HandlerTransaction` dihitung secara normal seperti yang dilakukan untuk transaksi `Invoke`. Untuk "
"ini, Anda dapat memperkirakan konsumsi gas menggunakan `starkli` atau `snforge` untuk menaksir biaya eksekusi "
"pesan Anda."

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr "Tanda tangan dari `sendMessageToL2` adalah:"

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr "Parameter-parameter tersebut adalah sebagai berikut:"

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr "`toAddress`: Alamat kontrak di L2 yang akan dipanggil."

#: src/ch99-04-00-L1-L2-messaging.md:112
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. This selector (function) must have the "
"`#[l1_handler]` attribute to be callable."
msgstr ""
"`selector\n"
"\n"
"`: Selector dari fungsi kontrak ini di `toAddress`. Selector (fungsi) ini harus memiliki atribut `#[l1_handler]` "
"agar dapat dipanggil."

#: src/ch99-04-00-L1-L2-messaging.md:113
msgid ""
"`payload`: The payload is always an array of `felt252` (which are represented by `uint256` in Solidity). For "
"this reason we've inserted the input `myFelt` into the array. This is why we need to insert the input data into "
"an array."
msgstr ""
"`payload`: Payload selalu merupakan sebuah larik dari `felt252` (yang direpresentasikan oleh `uint256` dalam "
"Solidity). Karena itu, kami telah memasukkan input `myFelt` ke dalam larik. Inilah sebabnya mengapa kita perlu "
"memasukkan data input ke dalam sebuah larik."

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr "Di sisi Starknet, untuk menerima pesan ini, kita memiliki:"

#: src/ch99-04-00-L1-L2-messaging.md:123
msgid "// You can now use the data, automatically deserialized from the message payload.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers are special functions that can only be "
"executed by a `L1HandlerTransaction`. There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` functions, it is important to verify "
"the sender of the L1 message to ensure that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"Kita perlu menambahkan atribut `#[l1_handler]` ke dalam fungsi kita. Handler L1 adalah fungsi-fungsi khusus yang "
"hanya dapat dieksekusi oleh `L1HandlerTransaction`. Tidak ada yang perlu dilakukan secara khusus untuk menerima "
"transaksi dari L1, karena pesan disalurkan oleh sekuen secara otomatis. Pada fungsi-fungsi `#[l1_handler]` Anda, "
"penting untuk memverifikasi pengirim pesan L1 untuk memastikan bahwa kontrak kita hanya dapat menerima pesan "
"dari kontrak L1 yang terpercaya."

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "Sending messages from Starknet to Ethereum"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the `send_message_to_l1` syscall in your "
"Cairo contracts. This syscall allows you to send messages to the `StarknetMessaging` contract on L1. Unlike `L1-"
">L2` messages, `L2->L1` messages must be consumed manually, which means that you will need your Solidity "
"contract to call the `consumeMessageFromL2` function of the `StarknetMessaging` contract explicitly in order to "
"consume the message."
msgstr ""
"Ketika mengirim pesan dari Starknet ke Ethereum, Anda harus menggunakan syscall `send_message_to_l1` dalam "
"kontrak Cairo Anda. Syscall ini memungkinkan Anda untuk mengirim pesan ke kontrak `StarknetMessaging` di L1. "
"Berbeda dengan pesan `L1->L2`, pesan `L2->L1` harus dikonsumsi secara manual, yang berarti bahwa Anda perlu agar "
"kontrak Solidity Anda memanggil fungsi `consumeMessageFromL2` dari kontrak `StarknetMessaging` secara eksplisit "
"untuk mengonsumsi pesan tersebut."

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr "Untuk mengirim pesan dari L2 ke L1, yang akan kita lakukan di Starknet adalah:"

#: src/ch99-04-00-L1-L2-messaging.md:138
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid "We simply build the payload and pass it, along with the L1 contract address, to the syscall function."
msgstr "Kita hanya membangun payload dan meneruskannya, bersama dengan alamat kontrak L1, ke dalam fungsi syscall."

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload as on L2. Then you call `consumeMessageFromL2` by passing "
"the L2 contract address and the payload. Please be aware that the L2 contract address expected by the "
"`consumeMessageFromL2` is the contract address of the account that sends the transaction on L2, and not the "
"address of the contract executing the `send_message_to_l1_syscall`."
msgstr ""
"Pada L1, bagian pentingnya adalah membangun payload yang sama seperti pada L2. Kemudian Anda memanggil "
"`consumeMessageFromL2` dengan meneruskan alamat kontrak L2 dan payload. Harap diingat bahwa alamat kontrak L2 "
"yang diharapkan oleh `consumeMessageFromL2` adalah alamat kontrak dari akun yang mengirim transaksi di L2, bukan "
"alamat kontrak yang menjalankan `send_message_to_l1_syscall`."

#: src/ch99-04-00-L1-L2-messaging.md:160
msgid "// You can use the message hash if you want here.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:162
msgid "// We expect the payload to contain only a felt252 value (which is a uint256 in Solidity).\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:163
msgid "\"Invalid payload\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:167
msgid "// From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:168
msgid "\"Invalid value\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"As you can see, in this context we don't have to verify which contract from L2 is sending the message. But we "
"are actually using the `consumeMessageFromL2` to validate the inputs (the sender address on L2 and the payload) "
"to ensure we are only consuming valid messages."
msgstr ""
"Seperti yang dapat Anda lihat, dalam konteks ini kita tidak perlu memverifikasi kontrak mana dari L2 yang "
"mengirim pesan. Namun, kami sebenarnya menggunakan `consumeMessageFromL2` untuk memvalidasi masukan (alamat "
"pengirim di L2 dan payload) untuk memastikan bahwa kami hanya mengonsumsi pesan yang valid."

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of `uint256`, but the basic data type on "
"Starknet is `felt252`; however, `felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are sending. If, on L1, we build a message "
"with values above the maximum `felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"Penting untuk diingat bahwa di L1 kita mengirimkan payload berupa `uint256`, tetapi tipe data dasar pada "
"Starknet adalah `felt252`; namun, `felt252` kurang lebih 4 bit lebih kecil daripada `uint256`. Oleh karena itu, "
"kita harus memperhatikan nilai-nilai yang terdapat dalam payload pesan yang kita kirimkan. Jika, di L1, kita "
"membangun sebuah pesan dengan nilai di atas maksimum dari `felt252`, pesan tersebut akan terjebak dan tidak "
"pernah dikonsumsi di L2."

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "Cairo Serde"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet contracts, written in Cairo, can only "
"understand serialized data. And serialized data is always an array of `felt252`. In Solidity we have `uint256` "
"type, and `felt252` are approximately 4 bits smaller than `uint256`. So we have to pay attention to the values "
"contained in the payload of the messages we are sending. If, on L1, we build a message with values above the "
"maximum `felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"Sebelum mengirim pesan antara L1 dan L2, Anda harus ingat bahwa kontrak Starknet, yang ditulis dalam bahasa "
"Cairo, hanya dapat memahami data yang telah diserialisasi. Dan data yang diserialisasi selalu berupa larik "
"`felt252`. Pada Solidity, kita memiliki tipe data `uint256`, dan `felt252` kurang lebih 4 bit lebih kecil "
"daripada `uint256`. Oleh karena itu, kita harus memperhatikan nilai-nilai yang terdapat dalam payload dari pesan "
"yang kita kirimkan. Jika, di L1, kita membangun sebuah pesan dengan nilai di atas maksimum `felt252`, pesan "
"tersebut akan terjebak dan tidak pernah dikonsumsi di L2."

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid "So for instance, an actual `uint256` value in Cairo is represented by a struct like:"
msgstr "Jadi misalnya, nilai `uint256` yang sebenarnya dalam Cairo direpresentasikan oleh sebuah struktur seperti:"

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for the `high`. This means that to send "
"only one `u256` to Cairo, you'll need to send a paylaod from L1 with **TWO** values."
msgstr ""
"yang akan diserialisasikan sebagai **DUA** felt, satu untuk `low`, dan satu untuk `high`. Ini berarti bahwa "
"untuk mengirim hanya satu `u256` ke Cairo, Anda perlu mengirimkan payload dari L1 dengan **DUA** nilai."

#: src/ch99-04-00-L1-L2-messaging.md:194
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the [Starknet documentation](https://docs."
"starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""
"Jika Anda ingin mempelajari lebih lanjut tentang mekanisme pengiriman pesan, Anda dapat mengunjungi [dokumentasi "
"Starknet](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-messaging-dev) to test the messaging "
"in local."
msgstr ""
"Anda juga dapat menemukan [panduan terperinci di sini](https://github.com/glihm/starknet-messaging-dev) untuk "
"menguji mekanisme pengiriman pesan secara lokal."

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually straightforward. However, preventing "
"unintended usage and vulnerabilities can be more challenging."
msgstr ""
"Ketika mengembangkan perangkat lunak, memastikan bahwa itu berfungsi sesuai yang diinginkan biasanya cukup "
"mudah. Namun, mencegah penggunaan yang tidak disengaja dan kerentanan bisa lebih menantang."

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error can result in the loss of valuable "
"assets or the improper functioning of certain features."
msgstr ""
"Dalam pengembangan kontrak pintar (smart contract), keamanan sangat penting. Satu kesalahan saja dapat "
"mengakibatkan hilangnya aset berharga atau tidak berfungsinya fitur-fitur tertentu dengan semestinya."

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can examine the code and interact with it. Any "
"errors or vulnerabilities in the code can be exploited by malicious actors."
msgstr ""
"Kontrak pintar dieksekusi di lingkungan publik di mana siapa pun dapat memeriksa kode dan berinteraksi "
"dengannya. Setiap kesalahan atau kerentanan dalam kode dapat dimanfaatkan oleh pihak yang jahat."

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart contracts. By incorporating these "
"concepts during development, you can create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""
"Bab ini menyajikan rekomendasi umum untuk menulis kontrak pintar yang aman. Dengan menerapkan konsep-konsep ini "
"selama pengembangan, Anda dapat membuat kontrak pintar yang kokoh dan handal. Hal ini mengurangi kemungkinan "
"terjadinya perilaku yang tidak terduga atau kerentanan."

#: src/ch99-03-security-considerations.md:11
msgid "Disclaimer"
msgstr ""

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security issues, and it does not guarantee that "
"your contracts will be completely secure."
msgstr ""
"Bab ini tidak memberikan daftar lengkap dari semua masalah keamanan yang mungkin terjadi, dan tidak menjamin "
"bahwa kontrak Anda akan benar-benar aman secara keseluruhan."

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly recommended to conduct external audits "
"performed by security experts."
msgstr ""
"Jika Anda sedang mengembangkan kontrak pintar untuk penggunaan produksi, sangat disarankan untuk melakukan audit "
"eksternal yang dilakukan oleh para ahli keamanan."

#: src/ch99-03-security-considerations.md:17
msgid "Mindset"
msgstr ""

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way that forces you to cover all possible "
"cases. Security issues on Starknet mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""
"Cairo adalah bahasa yang sangat aman terinspirasi dari Rust. Dirancang sedemikian rupa sehingga memaksa Anda "
"untuk menutupi semua kasus yang mungkin. Masalah keamanan pada Starknet kebanyakan muncul dari cara alur kontrak "
"pintar dirancang, bukan begitu banyak dari bahasa itu sendiri."

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart contracts. Try to always consider all "
"possible scenarios when writing code."
msgstr ""
"Menerapkan pola pikir keamanan adalah langkah awal dalam menulis kontrak pintar yang aman. Cobalah untuk selalu "
"mempertimbangkan semua skenario yang mungkin saat menulis kode."

#: src/ch99-03-security-considerations.md:23
msgid "Viewing smart contract as Finite State Machines"
msgstr "Melihat smart contract sebagai Mesin Keadaan Terbatas"

#: src/ch99-03-security-considerations.md:25
msgid "Transactions in smart contracts are atomic, meaning they either succeed or fail without making any changes."
msgstr ""
"Transaksi dalam smart contract bersifat atomik, artinya mereka entah berhasil atau gagal tanpa membuat perubahan "
"apapun."

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial states defined by the constructor "
"constraints, and external functions represent a set of possible state transitions. A transaction is nothing more "
"than a state transition."
msgstr ""
"Pikirkan kontrak pintar sebagai mesin keadaan: mereka memiliki serangkaian keadaan awal yang ditentukan oleh "
"batasan konstruktor, dan fungsi eksternal mewakili serangkaian transisi keadaan yang mungkin. Sebuah transaksi "
"tidak lebih dari sekadar transisi keadaan."

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert` or `panic` functions can be used to validate conditions before performing specific actions. You can "
"learn more about these on the [Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-panic.md) "
"page."
msgstr ""
"Fungsi `assert` atau `panic` dapat digunakan untuk memvalidasi kondisi sebelum melakukan tindakan tertentu. Anda "
"dapat mempelajari lebih lanjut mengenai hal ini di halaman [Unrecoverable Errors with panic](./ch10-01-"
"unrecoverable-errors-with-panic.md)."

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr "Validasi tersebut dapat meliputi:"

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr "Masukan yang diberikan oleh pemanggil"

#: src/ch99-03-security-considerations.md:34
msgid "Execution requirements"
msgstr "Persyaratan eksekusi"

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr "Invarian (kondisi yang harus selalu benar)"

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr "Value return dari panggilan fungsi lain"

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert` function to validate that a user has enough funds to perform a withdraw "
"transaction. If the condition is not met, the transaction will fail and the state of the contract will not "
"change."
msgstr ""
"Sebagai contoh, Anda bisa menggunakan fungsi `assert` untuk memvalidasi bahwa seorang pengguna memiliki dana "
"yang cukup untuk melakukan transaksi penarikan. Jika kondisi tidak terpenuhi, transaksi akan gagal dan status "
"kontrak tidak akan berubah."

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly define the boundaries of possible "
"state transitions for each function in your smart contract. These checks ensure that the behavior of the "
"contract stays within the expected limits."
msgstr ""
"Menggunakan fungsi-fungsi ini untuk memeriksa kondisi menambahkan batasan-batasan yang membantu mendefinisikan "
"dengan jelas batas-batas transisi keadaan yang mungkin untuk setiap fungsi dalam kontrak pintar Anda. "
"Pemeriksaan ini memastikan bahwa perilaku kontrak tetap dalam batas-batas yang diharapkan."

#: src/ch99-03-security-considerations.md:53
msgid "Recommendations"
msgstr ""

#: src/ch99-03-security-considerations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr "Pola Periksa Efek Interaksi"

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to prevent reentrancy attacks on "
"Ethereum. While reentrancy is harder to achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"Pola Checks Effects Interactions adalah pola desain umum yang digunakan untuk mencegah serangan reentrancy di "
"Ethereum. Meskipun reentrancy lebih sulit untuk dicapai di Starknet, disarankan tetap menggunakan pola ini dalam "
"kontrak pintar Anda."

#: src/ch99-03-security-considerations.md:61
msgid "The pattern consists of following a specific order of operations in your functions:"
msgstr "Pola ini terdiri dari mengikuti urutan operasi tertentu dalam fungsi-fungsi Anda:"

#: src/ch99-03-security-considerations.md:63
msgid "**Checks**: Validate all conditions and inputs before performing any state changes."
msgstr "**Checks**: Memvalidasi semua kondisi dan masukan sebelum melakukan perubahan keadaan apapun."

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr "**Effects**: Melakukan semua perubahan keadaan."

#: src/ch99-03-security-considerations.md:65
msgid "**Interactions**: All external calls to other contracts should be made at the end of the function."
msgstr "**Interactions**: Semua panggilan eksternal ke kontrak lain sebaiknya dilakukan di akhir fungsi."

#: src/ch99-03-security-considerations.md:67
msgid "Access control"
msgstr ""

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or resources. It is a common security "
"mechanism used to prevent unauthorized access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"Kontrol akses adalah proses pembatasan akses terhadap fitur atau sumber daya tertentu. Ini adalah mekanisme "
"keamanan umum yang digunakan untuk mencegah akses tidak sah terhadap informasi atau tindakan yang sensitif. "
"Dalam kontrak pintar, beberapa fungsi mungkin sering dibatasi hanya untuk pengguna atau peran tertentu."

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. This pattern consists of defining a "
"set of roles and assigning them to specific users. Each function can then be restricted to specific roles."
msgstr ""
"Anda dapat mengimplementasikan pola kontrol akses untuk dengan mudah mengelola izin. Pola ini terdiri dari "
"menentukan serangkaian peran dan menugaskan peran tersebut kepada pengguna tertentu. Setiap fungsi kemudian "
"dapat dibatasi hanya untuk peran-peran tertentu."

#: src/ch99-03-security-considerations.md:92
msgid "// Role 'owner': only one address\n"
msgstr ""

#: src/ch99-03-security-considerations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr ""

#: src/ch99-03-security-considerations.md:103
msgid "// Guard functions to check roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""

#: src/ch99-03-security-considerations.md:131
msgid "// Functions to manage roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""

#: src/ch99-03-security-considerations.md:155
msgid "Static analysis tool"
msgstr ""

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its execution, focusing on its structure, "
"syntax, and properties. It involves analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""
"Analisis statis mengacu pada proses pemeriksaan kode tanpa eksekusinya, fokus pada struktur, sintaksis, dan "
"propertinya. Ini melibatkan analisis kode sumber untuk mengidentifikasi masalah potensial, kerentanan, atau "
"pelanggaran aturan yang ditentukan."

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, developers can utilize static analysis "
"tools to automatically check the code against these standards."
msgstr ""
"Dengan mendefinisikan aturan, seperti konvensi penulisan kode atau pedoman keamanan, para pengembang dapat "
"menggunakan alat analisis statis untuk secara otomatis memeriksa kode berdasarkan standar tersebut."

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr ""

#: src/ch99-03-security-considerations.md:163
msgid "[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"
msgstr ""

#: src/ch99-03-security-considerations.md:164
msgid "[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""

#: src/appendix-00.md:3
msgid "The following sections contain reference material you may find useful in your Cairo journey."
msgstr "Bagian-bagian berikut berisi materi referensi yang mungkin berguna dalam perjalanan Anda dengan Cairo."

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid "The following list contains keywords that are reserved for current or future use by the Cairo language."
msgstr ""
"Daftar berikut berisi kata kunci yang dicadangkan untuk penggunaan saat ini atau di masa depan oleh bahasa Cairo."

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr "Ada dua kategori kata kunci:"

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While their names are not reserved, they "
"are not recommended to be used as names of any items to follow good practices."
msgstr ""
"Ada kategori ketiga, yaitu fungsi-fungsi dari pustaka inti. Meskipun namanya tidak dipesan, tidak disarankan "
"untuk digunakan sebagai nama item apa pun untuk mengikuti praktik terbaik."

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid "These keywords can only be used in their correct contexts. They cannot be used as names of any items."
msgstr ""
"Kata kunci ini hanya dapat digunakan dalam konteks yang benar. Mereka tidak dapat digunakan sebagai nama untuk "
"item apa pun."

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at cairo1 level with this declaration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid "`implicits` - Special kind of function parameters that are required to perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid "`nopanic` - Functions marked with this notation mean that the function will never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`of` - Implementation a trait"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`trait` - Define a trait"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
msgid "Reserved keywords"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict "
"keywords. The reasoning behind this is to make current programs forward compatible with future versions of Cairo "
"by forbidding them to use these keywords."
msgstr ""
"Kata kunci-kata kunci ini belum digunakan, tetapi mereka sudah dicadangkan untuk penggunaan di masa depan. "
"Mereka memiliki batasan yang sama dengan kata kunci ketat. Alasan di balik ini adalah untuk membuat program-"
"program saat ini kompatibel ke depan dengan versi-versi masa depan Cairo dengan melarang mereka menggunakan kata "
"kunci-kata kunci ini."

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "Built-in functions"
msgstr "Fungsi Built-in"

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that serve a special purpose. We will not "
"cover all of them in this book, but using the names of these functions as names of other items is not "
"recommended."
msgstr ""
"Bahasa pemrograman Cairo menyediakan beberapa fungsi khusus yang memiliki tujuan tertentu. Kami tidak akan "
"membahas semuanya dalam buku ini, tetapi penggunaan nama-nama fungsi ini sebagai nama item lain tidak disarankan."

#: src/appendix-01-keywords.md:85
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates to false, it triggers the panic "
"function. -`panic` - This function terminates the program."
msgstr ""
"- `assert` - Fungsi ini memeriksa suatu ekspresi boolean, dan jika hasil evaluasinya adalah false, itu memicu "
"fungsi panic. - `panic` - Fungsi ini mengakhiri program."

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B: Operators and Symbols"
msgstr "Lampiran B: Operator dan Simbol"

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr "Lampiran ini mencakup glosarium sintaks Cairo."

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator would appear in context, a short "
"explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to "
"use to overload that operator is listed."
msgstr ""
"Tabel B-1 berisi operator-operator dalam Cairo, contoh bagaimana operator akan muncul dalam konteks, penjelasan "
"singkat, dan apakah operator tersebut dapat di-overload. Jika suatu operator dapat di-overload, trait yang "
"relevan untuk digunakan untuk meng-overload operator tersebut tercantum."

#: src/appendix-02-operators-and-symbols.md:9
msgid "Table B-1: Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Operator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11 src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:65 src/appendix-02-operators-and-symbols.md:75
#: src/appendix-02-operators-and-symbols.md:88 src/appendix-02-operators-and-symbols.md:96
#: src/appendix-02-operators-and-symbols.md:105 src/appendix-02-operators-and-symbols.md:119
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Bitwise or logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14 src/appendix-02-operators-and-symbols.md:39
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19 src/appendix-02-operators-and-symbols.md:22
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`MulEq`"
msgstr "`MulEq`"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@var`"
msgstr "`@var`"

#: src/appendix-02-operators-and-symbols.md:21
msgid "Snapshot"
msgstr "Snapshot"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`*var`"
msgstr "`*var`"

#: src/appendix-02-operators-and-symbols.md:22
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`expr + expr`"
msgstr "`expr + expr`"

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`Add`"
msgstr "`Add`"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`var += expr`"
msgstr "`var += expr`"

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`AddEq`"
msgstr "`AddEq`"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`expr, expr`"
msgstr "`expr, expr`"

#: src/appendix-02-operators-and-symbols.md:25
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26 src/appendix-02-operators-and-symbols.md:27
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`-expr`"
msgstr "`-expr`"

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Neg`"
msgstr "`Neg`"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`expr - expr`"
msgstr "`expr - expr`"

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Sub`"
msgstr "`Sub`"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`var -= expr`"
msgstr "`var -= expr`"

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`SubEq`"
msgstr "`SubEq`"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`fn(...) -> type`, "
msgstr "`fn(...) -> type`, "

#: src/appendix-02-operators-and-symbols.md:29
msgid "\\|...\\| -> type"
msgstr "\\|...\\| -> type"

#: src/appendix-02-operators-and-symbols.md:29
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr.ident`"
msgstr "`expr.ident`"

#: src/appendix-02-operators-and-symbols.md:30
msgid "Member access"
msgstr "Member access"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr / expr`"
msgstr "`expr / expr`"

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division"
msgstr "Pembagian aritmetika"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`Div`"
msgstr "`Div`"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`var /= expr`"
msgstr "`var /= expr`"

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division and assignment"
msgstr "Pembagian dan penugasan aritmetika"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`DivEq`"
msgstr "`DivEq`"

#: src/appendix-02-operators-and-symbols.md:33 src/appendix-02-operators-and-symbols.md:34
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`pat: type`, `ident: type`"
msgstr "`pat: type`, `ident: type`"

#: src/appendix-02-operators-and-symbols.md:33
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`ident: expr`"
msgstr "`ident: expr`"

#: src/appendix-02-operators-and-symbols.md:34
msgid "Struct field initializer"
msgstr "Penginisialisasi bidang struktur"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr;`"
msgstr "`expr;`"

#: src/appendix-02-operators-and-symbols.md:35
msgid "Statement and item terminator"
msgstr "Pernyataan dan terminator item"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr < expr`"
msgstr "`expr < expr`"

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than comparison"
msgstr "Perbandingan kurang dari"

#: src/appendix-02-operators-and-symbols.md:36 src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:41 src/appendix-02-operators-and-symbols.md:42
msgid "`PartialOrd`"
msgstr "`PartialOrd`"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr <= expr`"
msgstr "`expr <= expr`"

#: src/appendix-02-operators-and-symbols.md:37
msgid "Less than or equal to comparison"
msgstr "Perbandingan kurang dari atau sama dengan"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`var = expr`"
msgstr "`var = expr`"

#: src/appendix-02-operators-and-symbols.md:38
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`expr == expr`"
msgstr "`expr == expr`"

#: src/appendix-02-operators-and-symbols.md:39
msgid "Equality comparison"
msgstr "Perbandingan kesetaraan"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`pat => expr`"
msgstr "`pat => expr`"

#: src/appendix-02-operators-and-symbols.md:40
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr > expr`"
msgstr "`expr > expr`"

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than comparison"
msgstr "Perbandingan lebih besar dari"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr >= expr`"
msgstr "`expr >= expr`"

#: src/appendix-02-operators-and-symbols.md:42
msgid "Greater than or equal to comparison"
msgstr "Perbandingan lebih besar dari atau sama dengan"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr ^ expr`"
msgstr "`expr ^ expr`"

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise exclusive OR"
msgstr "Bitwise exclusive OR"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitXor`"
msgstr "`BitXor`"

#: src/appendix-02-operators-and-symbols.md:44
msgid "\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "expr \\| expr"
msgstr "expr \\| expr"

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitOr`"
msgstr "`BitOr`"

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\|\\| expr"
msgstr "expr \\|\\| expr"

#: src/appendix-02-operators-and-symbols.md:45
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid ""
"The following list contains all symbols that are not used as operators; that is, they do not have the same "
"behavior as a function or method call."
msgstr ""
"Daftar berikut berisi semua simbol yang tidak digunakan sebagai operator; artinya, mereka tidak memiliki "
"perilaku yang sama seperti panggilan fungsi atau metode."

#: src/appendix-02-operators-and-symbols.md:51
msgid "Table B-2 shows symbols that appear on their own and are valid in a variety of locations."
msgstr "Tabel B-2 menunjukkan simbol-simbol yang muncul sendiri dan valid dalam berbagai lokasi."

#: src/appendix-02-operators-and-symbols.md:53
msgid "Table B-2: Stand-Alone Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:55 src/appendix-02-operators-and-symbols.md:65
#: src/appendix-02-operators-and-symbols.md:75 src/appendix-02-operators-and-symbols.md:88
#: src/appendix-02-operators-and-symbols.md:96 src/appendix-02-operators-and-symbols.md:105
msgid "Symbol"
msgstr "Symbol"

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, etc."
msgstr "`..._u8`, `..._usize`, etc."

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr "Literal numerik dengan tipe tertentu"

#: src/appendix-02-operators-and-symbols.md:58
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "Short string"
msgstr "Short string"

#: src/appendix-02-operators-and-symbols.md:59
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr "Pola ikatan \"Ignored\"; juga digunakan untuk membuat literal bilangan bulat dapat dibaca"

#: src/appendix-02-operators-and-symbols.md:61
msgid "Table B-3 shows symbols that are used within the context of a module hierarchy path to access an item."
msgstr ""
"Tabel B-3 menunjukkan simbol-simbol yang digunakan dalam konteks jalur hierarki modul untuk mengakses suatu item."

#: src/appendix-02-operators-and-symbols.md:63
msgid "Table B-3: Path-Related Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:67
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:67
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "`super::path`"
msgstr "`super::path`"

#: src/appendix-02-operators-and-symbols.md:68
msgid "Path relative to the parent of the current module"
msgstr "Jalur relatif terhadap induk modul saat ini"

#: src/appendix-02-operators-and-symbols.md:69
msgid "`trait::method(...)`"
msgstr "`trait::method(...)`"

#: src/appendix-02-operators-and-symbols.md:69
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr "Membedakan panggilan metode dengan menamai trait yang mendefinisikannya"

#: src/appendix-02-operators-and-symbols.md:71
msgid "Table B-4 shows symbols that appear in the context of using generic type parameters."
msgstr "Tabel B-4 menunjukkan simbol-simbol yang muncul dalam konteks penggunaan parameter tipe generik."

#: src/appendix-02-operators-and-symbols.md:73
msgid "Table B-4: Generics"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:77
msgid "`path<...>`"
msgstr "`path<...>`"

#: src/appendix-02-operators-and-symbols.md:77
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr "Menentukan parameter ke tipe generik dalam suatu tipe (misalnya, `Vec<u8>`)"

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path::<...>`, `method::<...>`"
msgstr "`path::<...>`, `method::<...>`"

#: src/appendix-02-operators-and-symbols.md:78
msgid "Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish"
msgstr ""
"Menentukan parameter ke tipe generik, fungsi, atau metode dalam suatu ekspresi; sering disebut sebagai turbofish"

#: src/appendix-02-operators-and-symbols.md:79
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "Define generic function"
msgstr "Mendefinisikan fungsi generik"

#: src/appendix-02-operators-and-symbols.md:80
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic structure"
msgstr "Mendefinisikan struktur generik"

#: src/appendix-02-operators-and-symbols.md:81
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic enumeration"
msgstr "Define generic enumeration"

#: src/appendix-02-operators-and-symbols.md:82
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic implementation"
msgstr "Mendefinisikan implementasi generik"

#: src/appendix-02-operators-and-symbols.md:84
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining macros and specifying attributes on an "
"item."
msgstr ""
"Tabel B-5 menunjukkan simbol-simbol yang muncul dalam konteks pemanggilan atau definisi makro dan penentuan "
"atribut pada suatu item."

#: src/appendix-02-operators-and-symbols.md:86
msgid "Table B-5: Macros and Attributes"
msgstr "Table B-5: Macros dan Attributes"

#: src/appendix-02-operators-and-symbols.md:90
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:90
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Table B-6 shows symbols that create comments."
msgstr "Tabel B-6 menunjukkan simbol-simbol yang membuat komentar."

#: src/appendix-02-operators-and-symbols.md:94
msgid "Table B-6: Comments"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr "Tabel B-7 menunjukkan simbol-simbol yang muncul dalam konteks menggunakan tuple."

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7: Tuples"
msgstr "Tabel B-7 menunjukkan simbol-simbol yang muncul dalam konteks menggunakan tuple"

#: src/appendix-02-operators-and-symbols.md:107
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "Empty tuple (aka unit), both literal and type"
msgstr "Tuple kosong (alias unit), baik literal maupun tipe"

#: src/appendix-02-operators-and-symbols.md:108
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr,)`"
msgstr "`expr + expr"

#: src/appendix-02-operators-and-symbols.md:109
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants"
msgstr "Ekspresi panggilan fungsi; juga digunakan untuk menginisialisasi struktur tuple dan varian tuple enumerasi"

#: src/appendix-02-operators-and-symbols.md:115
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr "Tabel B-8 menunjukkan konteks di mana kurung kurawal digunakan."

#: src/appendix-02-operators-and-symbols.md:117
msgid "Table B-8: Curly Brackets"
msgstr "Tabel B-8: Kurung Kurawal"

#: src/appendix-02-operators-and-symbols.md:119
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`struct` literal"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr "Lampiran C: Derivable Traits"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which you can apply to a struct or enum "
"definition. The `derive` attribute generates code to implement a default trait on the type you’ve annotated with "
"the `derive` syntax."
msgstr ""
"Di berbagai tempat dalam buku ini, kita telah membahas atribut `derive`, yang dapat Anda terapkan pada definisi "
"struktur atau enumerasi. Atribut `derive` menghasilkan kode untuk mengimplementasikan sebuah trait default pada "
"tipe yang Anda anotasi dengan sintaks `derive`."

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the traits in the standard library "
"compatible with the `derive` attribute."
msgstr ""
"Pada lampiran ini, kami menyediakan referensi komprehensif yang merinci semua trait dalam pustaka standar yang "
"kompatibel dengan atribut `derive`."

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that can be implemented on your types "
"using `derive`. Other traits defined in the standard library don’t have sensible default behavior, so it’s up to "
"you to implement them in the way that makes sense for what you’re trying to accomplish."
msgstr ""
"Trait-trait yang terdaftar di sini adalah satu-satunya yang didefinisikan oleh pustaka inti yang dapat "
"diimplementasikan pada tipe-tipe Anda menggunakan `derive`. Trait-trait lain yang didefinisikan dalam pustaka "
"standar tidak memiliki perilaku default yang masuk akal, sehingga terserah Anda untuk mengimplementasikannya "
"sesuai dengan apa yang masuk akal untuk tujuan yang ingin Anda capai."

#: src/appendix-03-derivable-traits.md:9
msgid ""
"The list of derivable traits provided in this appendix does not encompass all possibilities: external libraries "
"can implement `derive` for their own traits, expanding the list of traits compatible with `derive`."
msgstr ""
"Daftar trait yang dapat diterapkan yang disediakan dalam lampiran ini tidak mencakup semua kemungkinan: pustaka "
"eksternal dapat mengimplementasikan `derive` untuk trait mereka sendiri, yang memperluas daftar trait yang "
"kompatibel dengan `derive`."

#: src/appendix-03-derivable-traits.md:11
msgid "PartialEq for equality comparison"
msgstr "`PartialEq` untuk perbandingan kesetaraan"

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for equality, thereby enabling the == "
"and != operators."
msgstr ""
"Trait `PartialEq` memungkinkan perbandingan antara instansi dari suatu tipe untuk kesetaraan, sehingga "
"memungkinkan operator == dan !=."

#: src/appendix-03-derivable-traits.md:15
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all fields are equal, and the instances "
"are not equal if any fields are not equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""
"Ketika `PartialEq` di-derive pada struktur, dua instansi dianggap sama hanya jika semua bidangnya sama, dan "
"instansi dianggap tidak sama jika ada bidang yang tidak sama. Ketika di-derive pada enumerasi, setiap varian "
"dianggap sama dengan dirinya sendiri dan tidak sama dengan varian lainnya."

#: src/appendix-03-derivable-traits.md:36
msgid "Clone and Copy for Duplicating Values"
msgstr "Clone dam Copy untuk Duplicating Values"

#: src/appendix-03-derivable-traits.md:38
msgid "The `Clone` trait provides the functionality to explicitly create a deep copy of a value."
msgstr "Trait `Clone` menyediakan fungsionalitas untuk secara eksplisit membuat salinan mendalam dari suatu nilai."

#: src/appendix-03-derivable-traits.md:40
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone on each of the type's components. "
"This means all the fields or values in the type must also implement `Clone` to derive `Clone`."
msgstr ""
"Menggunakan `Clone` mengimplementasikan metode `clone`, yang pada gilirannya, memanggil clone pada setiap "
"komponen tipe tersebut. Ini berarti semua bidang atau nilai dalam tipe tersebut juga harus mengimplementasikan "
"`Clone` untuk mendapatkan `Clone`."

#: src/appendix-03-derivable-traits.md:61
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` on any type whose parts all "
"implement `Copy`."
msgstr ""
"Trait `Copy` memungkinkan untuk duplikasi nilai. Anda dapat meng-derive `Copy` pada setiap tipe di mana semua "
"bagian implementasikan `Copy`."

#: src/appendix-03-derivable-traits.md:77
msgid "// Copy Trait prevents firs_struct from moving into second_struct\n"
msgstr ""

#: src/appendix-03-derivable-traits.md:81
msgid "Serializing with Serde"
msgstr "Serialisasi dengan Serde"

#: src/appendix-03-derivable-traits.md:83
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` functions for data structures defined "
"in your crate. It allows you to transform your structure into an array (or the opposite)."
msgstr ""
"`Serde` menyediakan implementasi trait untuk fungsi `serialize` dan `deserialize` untuk struktur data yang "
"didefinisikan dalam kerangka kerja Anda. Ini memungkinkan Anda mengubah struktur Anda menjadi sebuah array (atau "
"sebaliknya)."

#: src/appendix-03-derivable-traits.md:108
msgid "Output:"
msgstr ""

#: src/appendix-03-derivable-traits.md:111
msgid "''"
msgstr ""

#: src/appendix-03-derivable-traits.md:111
msgid "'c'"
msgstr ""

#: src/appendix-03-derivable-traits.md:114
msgid "We can see here that our struct A has been serialized into the output array."
msgstr "Dapat kita lihat di sini bahwa struktur A kita telah diserialkan ke dalam array keluaran."

#: src/appendix-03-derivable-traits.md:116
msgid "Also, we can use `deserialize` function to convert the serialized array back into our A struct."
msgstr ""
"Selain itu, kita dapat menggunakan fungsi `deserialize` untuk mengonversi kembali array yang diserialkan menjadi "
"struktur A kita."

#: src/appendix-03-derivable-traits.md:143
msgid ""
"Here we are converting a serialized array span back to the struct A. `deserialize` returns an `Option` so we "
"need to unwrap it. When using deserialize we also need to specify the type we want to deserialize into."
msgstr ""
"Di sini kita mengonversi kembali rentang array yang telah diserialkan menjadi struktur A. `deserialize` "
"mengembalikan `Option` sehingga kita perlu membukanya. Saat menggunakan deserialize, kita juga perlu menentukan "
"jenis yang ingin kita deserialkan."

#: src/appendix-03-derivable-traits.md:145
msgid "Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:147
msgid ""
"When moving out of scope, variables need to be moved first. This is where the `Drop` trait intervenes. You can "
"find more details about its usage [here](ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""
"Ketika keluar dari ruang lingkup, variabel perlu dipindahkan terlebih dahulu. Di sinilah trait `Drop` berperan. "
"Anda dapat menemukan lebih banyak detail tentang penggunaannya [di sini](ch04-01-what-is-ownership.md#the-drop-"
"trait)."

#: src/appendix-03-derivable-traits.md:149
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling manually the `squash` method on each "
"of them can be quickly redundant. `Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` [here](ch04-01-what-is-ownership.md#the-"
"destruct-trait)."
msgstr ""
"Selain itu, `Dictionary` perlu di-\"squash\" sebelum keluar dari ruang lingkup. Memanggil metode `squash` secara "
"manual pada masing-masing dari mereka dapat dengan cepat menjadi redundan. Trait `Destruct` memungkinkan "
"`Dictionary` untuk secara otomatis di-\"squash\" saat keluar dari ruang lingkup. Anda juga dapat menemukan "
"informasi lebih lanjut tentang `Destruct` [di sini](ch04-01-what-is-ownership.md#the-destruct-trait)."

#: src/appendix-03-derivable-traits.md:151
msgid "Store"
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet contract requires the `Store` trait to be "
"implemented for this type. You can automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""
"Menyimpan struktur yang ditentukan pengguna dalam variabel penyimpanan dalam kontrak Starknet memerlukan trait "
"`Store` untuk diimplementasikan pada tipe ini. Anda dapat secara otomatis mendapatkan trait `store` untuk semua "
"struktur yang tidak mengandung tipe kompleks seperti Dictionary atau Array."

#: src/appendix-03-derivable-traits.md:174
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the Store trait. This `struct A` is "
"subsequently used as a storage variable in the contract."
msgstr ""
"Berikut adalah implementasi dari `struct A` yang mendapatkan trait `Store`. `struct A` ini kemudian digunakan "
"sebagai variabel penyimpanan dalam kontrak."

#: src/appendix-03-derivable-traits.md:177
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr "PartialOrd dan Ord untuk Perbandingan Pemesanan"

#: src/appendix-03-derivable-traits.md:179
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the `PartialOrd` and `Ord` traits to "
"compare values for ordering."
msgstr ""
"Selain trait `PartialEq`, pustaka standar juga menyediakan trait `PartialOrd` dan `Ord` untuk membandingkan "
"nilai untuk pengurutan."

#: src/appendix-03-derivable-traits.md:181
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for ordering, thereby enabling the \\<, "
"\\<=, >, and >= operators."
msgstr ""
"Trait `PartialOrd` memungkinkan perbandingan antara instans suatu tipe untuk pengurutan, sehingga memungkinkan "
"operator \\<, \\<=, >, dan >=."

#: src/appendix-03-derivable-traits.md:183
msgid "When `PartialOrd` is derived on structs, two instances are ordered by comparing each field in turn."
msgstr ""
"Ketika `PartialOrd` di-derive pada struktur, dua instansi diurutkan dengan membandingkan setiap bidang secara "
"berurutan."

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr "Lampiran D - Alat Pengembangan yang Berguna"

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo project provides. We’ll look at "
"automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs."
msgstr ""
"Di lampiran ini, kita akan membahas beberapa alat pengembangan yang berguna yang disediakan oleh proyek Cairo. "
"Kita akan melihat pemformatan otomatis, cara cepat untuk menerapkan perbaikan peringatan, linter, dan integrasi "
"dengan IDE."

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr "Pemformatan otomatis dapat dilakukan dengan menggunakan perintah`scarb fmt`"

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're using the cairo binaries directly, you "
"can run `cairo-format` instead. Many collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"Proyek-proyek Scarb dapat diformat menggunakan perintah `scarb fmt`. Jika Anda menggunakan biner Cairo secara "
"langsung, Anda dapat menjalankan `cairo-format` sebagai pengganti. Banyak proyek kolaboratif menggunakan `scarb "
"fmt` untuk mencegah perdebatan tentang gaya penulisan kode: setiap orang memformat kode mereka menggunakan alat "
"ini."

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr "Untuk memformat proyek Cairo apa pun, masukkan perintah berikut:"

#: src/appendix-04-useful-development-tools.md:16
msgid "IDE Integration Using `cairo-language-server`"
msgstr "Integrasi IDE Menggunakan `cairo-language-server`"

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-language-server`](https://github.com/"
"starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)"
msgstr ""
"Untuk membantu integrasi IDE, komunitas Cairo menyarankan penggunaan [`cairo-language-server`](https://github."
"com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)"

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language Server Protocol](http://langserver."
"org/)"
msgstr ""
". Alat ini adalah kumpulan utilitas berorientasi kompilator yang berbicara dengan [Language Server Protocol]"
"(http://langserver.org/)"

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate with each other. Different clients "
"can use `cairo-language-server`, such as [the Cairo extension for Visual Studio Code](https://marketplace."
"visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""
", yang merupakan spesifikasi untuk IDE dan bahasa pemrograman berkomunikasi satu sama lain. Klien yang berbeda "
"dapat menggunakan `cairo-language-server`, seperti [ekstensi Cairo untuk Visual Studio Code](https://marketplace."
"visualstudio.com/items?itemName=starkware.cairo1)."

#: src/appendix-04-useful-development-tools.md:28
msgid "Visit the `vscode-cairo` [page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)"
msgstr ""
"Kunjungi halaman `vscode-cairo` [di sini](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)"

#: src/appendix-04-useful-development-tools.md:28
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, jump to definition, and inline errors."
msgstr ""
" untuk menginstalnya di VSCode. Anda akan mendapatkan kemampuan seperti autokomplet, lompat ke definisi, dan "
"kesalahan di baris."

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the Cairo VSCode extension, without a "
"manual installation of the language server."
msgstr ""
"Catatan: Jika Anda telah menginstal Scarb, seharusnya bekerja tanpa masalah dengan ekstensi Cairo untuk VSCode, "
"tanpa instalasi manual server bahasa."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr "Lampiran E - Jenis dan Trait Umum serta Prelude Cairo"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data types, and traits that are "
"automatically brought into scope of every module in a Cairo crate without needing explicit import statements. "
"Cairo's prelude provides the basic building blocks developers need to start Cairo programs and writing smart "
"contracts."
msgstr ""
"Prelude Cairo adalah kumpulan modul, fungsi, jenis data, dan trait yang umum digunakan yang secara otomatis "
"dimasukkan ke dalam cakupan setiap modul dalam kerangka kerja Cairo tanpa perlu pernyataan impor eksplisit. "
"Prelude Cairo menyediakan blok bangunan dasar yang dibutuhkan pengembang untuk memulai program Cairo dan menulis "
"kontrak pintar."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the [lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.2.0/"
"corelib/src/lib.cairo) file of the corelib crate and contains Cairo's primitive data types, traits, operators, "
"and utility functions. This includes: Data types - felts, bools, arrays, dicts, etc. Traits - behaviors for "
"arithmetic, comparison, serialization Operators - arithmetic, logical, bitwise Utility functions - helpers for "
"arrays, maps, boxing, etc. The core library prelude delivers the fundamental programming constructs and "
"operations needed for basic Cairo programs, without requiring the explicit import of elements. Since the core "
"library prelude is automatically imported, its contents are available for use in any Cairo crate without "
"explicit imports. This prevents repetition and provides a better devX. This is what allows you to use "
"`ArrayTrait::append()` or the `Default` trait without bringing them explicitly into scope."
msgstr ""
"Prelude pustaka inti didefinisikan dalam file [lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.2.0/"
"corelib/src/lib.cairo) dari kerangka kerja corelib dan berisi jenis data primitif, trait, operator, dan fungsi "
"utilitas Cairo. Ini mencakup: Jenis data - felts, bools, arrays, dicts, dll. Trait - perilaku untuk aritmatika, "
"perbandingan, serialisasi Operator - aritmatika, logika, bitwise Fungsi utilitas - pembantu untuk array, peta, "
"boxing, dll. Prelude pustaka inti menyediakan konstruk dan operasi pemrograman dasar yang diperlukan untuk "
"program Cairo dasar, tanpa memerlukan impor eksplisit dari elemen-elemen tersebut. Karena prelude pustaka inti "
"diimpor secara otomatis, isinya dapat digunakan di setiap kerangka kerja Cairo tanpa impor eksplisit. Ini "
"mencegah pengulangan dan memberikan pengalaman pengembangan yang lebih baik. Ini memungkinkan Anda menggunakan "
"`ArrayTrait::append()` atau trait `Default` tanpa membawanya secara eksplisit ke dalam cakupan."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid "List of common types and traits"
msgstr "Daftar tipe data dan trait umum"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"The following section provides a brief overview of commonly used types and traits when developing Cairo "
"programs. Most of these are included in the prelude and not required to be imported explicitly - but not all of "
"them."
msgstr ""
"Bagian berikut memberikan gambaran singkat tentang jenis dan trait yang umum digunakan saat mengembangkan "
"program Cairo. Sebagian besar dari ini sudah termasuk dalam prelude dan tidak perlu diimpor secara eksplisit - "
"tetapi tidak semuanya."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Import"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Path"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Usage"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`core::option::OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`OptionTrait<T>` defines a set of methods required to manipulate optional value."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`core::result::ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`ResultTrait<T, E>` Type for Starknet contract address, a value in the range \\[0, 2 \\*\\* 251)."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`starknet::ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for the `ContractAddress` type. It is "
"required to check whether a value of `t:ContractAddress` is zero or not."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`starknet::contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "The `contract_address_const!` it's a function that allows instantiating constant contract address values."
msgstr "`contract_address_const!` adalah fungsi yang memungkinkan instansiasi nilai alamat kontrak konstan."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`Into`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an implementation of Into\\<T,S> for the "
"types T and S, you can convert T into S."
msgstr ""
"`Into<T>` adalah trait yang digunakan untuk konversi antar tipe. Jika ada implementasi Into\\<T, S> untuk tipe T "
"dan S, Anda dapat mengonversi T menjadi S."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an implementation of TryInto\\<T,S> for "
"the types T and S, you can convert T into S."
msgstr ""
"`TryInto<T>` adalah trait yang digunakan untuk konversi antar tipe. Jika ada implementasi TryInto\\<T, S> untuk "
"tipe T dan S, Anda dapat mengonversi T menjadi S."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid ""
"`get_caller_address()` is a function that returns the address of the caller of the contract. It can be used to "
"identify the caller of a contract function."
msgstr ""
"`get_caller_address()` adalah fungsi yang mengembalikan alamat pemanggil kontrak. Ini dapat digunakan untuk "
"mengidentifikasi pemanggil fungsi kontrak."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid ""
"`get_contract_address()` is a function that returns the address of the current contract. It can be used to "
"obtain the address of the contract being executed."
msgstr ""
"`get_contract_address()` adalah fungsi yang mengembalikan alamat kontrak saat ini. Ini dapat digunakan untuk "
"mendapatkan alamat kontrak yang sedang dieksekusi."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used types and traits in contract "
"development. For more details, refer to the official documentation and explore the available libraries and "
"frameworks."
msgstr ""
"Ini bukan daftar lengkap, tetapi mencakup beberapa jenis dan trait yang umum digunakan dalam pengembangan "
"kontrak. Untuk informasi lebih lanjut, lihat dokumentasi resmi dan jelajahi perpustakaan dan framework yang "
"tersedia."

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr "Lampiran F: Menginstal Biner Cairo"

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you could not achieve by purely using Scarb "
"you can install them by following the instructions below."
msgstr ""
"Jika Anda ingin mengakses biner Cairo, untuk hal-hal yang tidak dapat Anda capai hanya dengan menggunakan Scarb, "
"Anda dapat menginstalnya dengan mengikuti petunjuk di bawah ini."

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using cairo repository or with an "
"installation script. You’ll need an internet connection for the download."
msgstr ""
"Langkah pertama adalah menginstal Cairo. Kami akan mengunduh Cairo secara manual, menggunakan repositori cairo "
"atau dengan skrip instalasi. Anda akan memerlukan koneksi internet untuk mengunduhnya."

#: src/appendix-06-cairo-binaries.md:7
msgid "Prerequisites"
msgstr "Prerequisites"

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr "Pertama, Anda perlu menginstal Rust dan Git."

#: src/appendix-06-cairo-binaries.md:12
msgid "# Install stable Rust\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:18
msgid ""
"Installing Cairo with a Script ([Installer](https://github.com/franalgaba/cairo-installer) by [Fran](https://"
"github.com/franalgaba))"
msgstr ""
"Menginstal Cairo dengan Skrip ([Installer](https://github.com/franalgaba/cairo-installer) oleh [Fran](https://"
"github.com/franalgaba))"

#: src/appendix-06-cairo-binaries.md:20
msgid "Install"
msgstr "Install"

#: src/appendix-06-cairo-binaries.md:22
msgid ""
"If you wish to install a specific release of Cairo rather than the latest head, set the `CAIRO_GIT_TAG` "
"environment variable (e.g. `export CAIRO_GIT_TAG=v2.2.0`)."
msgstr ""
"Jika Anda ingin menginstal rilis tertentu dari Cairo bukan yang terbaru, atur variabel lingkungan "
"`CAIRO_GIT_TAG` (contoh: `export CAIRO_GIT_TAG=v2.2.0`)."

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-environment-for-cairo) to set up your shell "
"environment."
msgstr ""
"Setelah menginstal, ikuti [instruksi ini](#set-up-your-shell-environment-for-cairo) untuk menyiapkan lingkungan "
"shell Anda."

#: src/appendix-06-cairo-binaries.md:30
msgid "Update"
msgstr "Update"

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:37
msgid "Uninstall"
msgstr "Uninstall"

#: src/appendix-06-cairo-binaries.md:39
msgid "Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, just remove it:"
msgstr "Cairo diinstal di dalam `$CAIRO_ROOT` (default: ~/.cairo). Untuk menghapusnya, cukup hapus:"

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr "kemudian hapus tiga baris ini dari .bashrc:"

#: src/appendix-06-cairo-binaries.md:48
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr "dan terakhir, restart shell Anda:"

#: src/appendix-06-cairo-binaries.md:57
msgid "Set up your shell environment for Cairo"
msgstr "Siapkan lingkungan shell Anda untuk Cairo"

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo will store its data. `$HOME/.cairo` is "
"the default. If you installed Cairo via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"Tentukan variabel lingkungan `CAIRO_ROOT` untuk menunjuk ke jalur tempat Cairo akan menyimpan datanya. `$HOME/."
"cairo` adalah nilai defaultnya. Jika Anda menginstal Cairo melalui Git checkout, kami sarankan untuk mengaturnya "
"ke lokasi yang sama dengan tempat Anda mengkloningnya."

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr "Tambahkan eksekutor `cairo-*` ke `PATH` Anda jika belum ada"

#: src/appendix-06-cairo-binaries.md:65
msgid "The below setup should work for the vast majority of users for common use cases."
msgstr "Penyiapan di bawah ini seharusnya berfungsi untuk sebagian besar pengguna untuk kasus penggunaan umum."

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr "Untuk **bash**:"

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them source which, under what "
"circumstances, in what order and what additional configuration they perform. As such, the most reliable way to "
"get Cairo in all environments is to append Cairo configuration commands to both `.bashrc` (for interactive "
"shells) and the profile file that Bash would use (for login shells)."
msgstr ""
"File startup Bash standar bervariasi secara luas antara distribusi dalam hal sumber mana yang digunakan di bawah "
"keadaan apa, urutan apa, dan konfigurasi tambahan apa yang mereka lakukan. Oleh karena itu, cara paling andal "
"untuk mendapatkan Cairo di semua lingkungan adalah dengan menambahkan perintah konfigurasi Cairo ke kedua `."
"bashrc` (untuk shell interaktif) dan file profil yang akan digunakan Bash (untuk shell login)."

#: src/appendix-06-cairo-binaries.md:75
msgid "First, add the commands to `~/.bashrc` by running the following in your terminal:"
msgstr "Pertama, tambahkan perintah-perintah ke `~/.bashrc` dengan menjalankan perintah berikut di terminal Anda:"

#: src/appendix-06-cairo-binaries.md:78 src/appendix-06-cairo-binaries.md:88 src/appendix-06-cairo-binaries.md:94
#: src/appendix-06-cairo-binaries.md:101
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr "'export CAIRO_ROOT=\"$HOME/.cairo\"'"

#: src/appendix-06-cairo-binaries.md:79 src/appendix-06-cairo-binaries.md:89 src/appendix-06-cairo-binaries.md:95
#: src/appendix-06-cairo-binaries.md:102
msgid "'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr "'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add the commands there as well. If you "
"have none of these, add them to `~/.profile`."
msgstr ""
"Kemudian, jika Anda memiliki `~/.profile`, `~/.bash_profile`, atau `~/.bash_login`, tambahkan perintah di sana "
"juga. Jika Anda tidak memiliki yang satupun dari ini, tambahkan ke `~/.profile`."

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr "untuk ditambahkan ke `~/profile`:"

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr "untuk ditambahkan ke `~/.bash_profile`:"

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr "Untuk **Zsh**:"

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add the commands to `~/.zprofile` or `~/."
"zlogin`."
msgstr ""
"Jika Anda ingin mendapatkan Cairo di shell login non-interaktif juga, tambahkan perintah ke `~/.zprofile` atau "
"`~/.zlogin` juga."

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr "Untuk **shell Fish**:"

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr "Jika Anda menggunakan Fish 3.2.0 atau yang lebih baru, jalankan ini secara interaktif:"

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr "Jika tidak, jalankan potongan kode di bawah ini:"

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which provides alternative shell completions for "
"many command line tools with an IDE-like popup interface in the terminal window. (Note that their completions "
"are independent from Cairo's codebase so they might be slightly out of sync for bleeding-edge interface changes.)"
msgstr ""
"Di MacOS, Anda mungkin juga ingin menginstal [Fig](https://fig.io/) yang menyediakan kelengkapan shell "
"alternatif untuk banyak perangkat baris perintah dengan antarmuka popup mirip IDE di jendela terminal. "
"(Perhatikan bahwa kelengkapannya independen dari kode sumber Cairo sehingga mungkin sedikit tidak sinkron untuk "
"perubahan antarmuka terbaru.)"

#: src/appendix-06-cairo-binaries.md:129
msgid "Restart your shell"
msgstr "Mulai ulang shell Anda"

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr "agar perubahan pada `PATH` dapat berlaku."

#: src/appendix-06-cairo-binaries.md:134
msgid "\"$SHELL\""
msgstr "\"$SHELL\""

#: src/appendix-06-cairo-binaries.md:137
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-template) by [Abdel](https://github.com/"
"abdelhamidbakhta))"
msgstr ""
"Memasang Cairo secara Manual ([Panduan](https://github.com/auditless/cairo-template) oleh [Abdel](https://github."
"com/abdelhamidbakhta))"

#: src/appendix-06-cairo-binaries.md:139
msgid "Step 1: Install Cairo 1.0"
msgstr "Langkah 1: Pasang Cairo 1.0"

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, download Cairo here: <https://github.com/"
"starkware-libs/cairo/releases>."
msgstr ""
"Jika Anda menggunakan sistem x86 Linux dan dapat menggunakan biner rilis, unduh Cairo di sini: <https://github."
"com/starkware-libs/cairo/releases>."

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr "Bagi semua orang lainnya, kami sarankan untuk mengompilasi Cairo dari sumber sebagai berikut:"

#: src/appendix-06-cairo-binaries.md:146
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr "# Mulai dengan mendefinisikan variabel lingkungan CAIRO_ROOT\n"

#: src/appendix-06-cairo-binaries.md:147
msgid "\"${HOME}/.cairo\""
msgstr "\"${HOME}/.cairo\""

#: src/appendix-06-cairo-binaries.md:148
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr "# Buat folder .cairo jika belum ada\n"

#: src/appendix-06-cairo-binaries.md:151
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr "# Clone kompilator Cairo di $CAIRO_ROOT (root default)\n"

#: src/appendix-06-cairo-binaries.md:154
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""
"# OPSIONAL/Disarankan: Jika Anda ingin menginstal versi tertentu dari kompilator\n"
"# Ambil semua tag (versi)\n"

#: src/appendix-06-cairo-binaries.md:157
msgid "# View tags (you can also do this in the cairo compiler repository)\n"
msgstr "# Lihat tag (Anda juga dapat melakukannya di repositori kompilator Cairo)\n"

#: src/appendix-06-cairo-binaries.md:159
msgid "# Checkout the version you want\n"
msgstr "# Periksa versi yang Anda inginkan\n"

#: src/appendix-06-cairo-binaries.md:162
msgid "# Generate release binaries\n"
msgstr "# Menghasilkan Biner Rilis\n"

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**CATATAN: Menjaga Cairo Tetap di versi Terbaru**"

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to do is pull the latest changes and "
"rebuild as follows:"
msgstr ""
"Sekarang kompilator Cairo Anda berada di dalam repositori yang telah di-kloning, yang perlu Anda lakukan adalah "
"menarik perubahan terbaru dan membangun kembali seperti berikut:"

#: src/appendix-06-cairo-binaries.md:178
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr "Langkah 2: Tambahkan eksekutor Cairo 1.0 ke path Anda"

#: src/appendix-06-cairo-binaries.md:181
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr "\"$CAIRO_ROOT/target/release:$PATH\""

#: src/appendix-06-cairo-binaries.md:184
msgid "**NOTE: If installing from a Linux binary, adapt the destination path accordingly.**"
msgstr ""
"**CATATAN: Jika menginstal dari sebuah biner Linux, sesuaikan jalur tujuan (destination path) sesuai kebutuhan.**"

#: src/appendix-06-cairo-binaries.md:186
msgid "Step 3: Setup Language Server"
msgstr "Langkah 3: Menyiapkan Language Server"

#: src/appendix-06-cairo-binaries.md:188
msgid "VS Code Extension"
msgstr "VS Code Extension"

#: src/appendix-06-cairo-binaries.md:190
msgid "If you have the previous Cairo 0 extension installed, you can disable/uninstall it."
msgstr "Jika Anda sudah menginstal ekstensi Cairo 0 sebelumnya, Anda dapat menonaktifkannya/menghapusnya."

#: src/appendix-06-cairo-binaries.md:191
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code navigation. You can find the link to the "
"extension [here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), or just search "
"for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"Instal ekstensi Cairo 1 untuk penyorotan sintaks yang tepat dan navigasi kode yang baik. Anda dapat menemukan "
"tautan ke ekstensi [di sini](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"atau cukup cari \"Cairo 1.0\" di marketplace VS Code."

#: src/appendix-06-cairo-binaries.md:192
msgid "The extension will work out of the box once you will have [Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""
"Ekstensi ini akan berfungsi secara langsung begitu Anda telah menginstal [Scarb](./ch01-03-hello-scarb.md)."

#: src/appendix-06-cairo-binaries.md:194
msgid "Cairo Language Server without Scarb"
msgstr "Cairo Language Server tanpa Scarb"

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language Server with the compiler binary. From "
"[Step 1](#installing-cairo-with-a-script-installer-by-fran), the `cairo-language-server` binary should be built "
"and executing this command will copy its path into your clipboard."
msgstr ""
"Jika Anda tidak ingin bergantung pada Scarb, Anda masih dapat menggunakan Cairo Language Server dengan biner "
"kompilator. Dari [Langkah 1](#installing-cairo-with-a-script-installer-by-fran), biner `cairo-language-server` "
"seharusnya sudah dibangun dan mengeksekusi perintah ini akan menyalin jalurnya ke clipboard Anda."

#: src/appendix-06-cairo-binaries.md:203
msgid "Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting the path."
msgstr "Perbarui `cairo1.languageServerPath` dari ekstensi Cairo 1.0 dengan cara menempelkan jalur yang dimaksud."
