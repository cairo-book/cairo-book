
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-02-08T05:36:14+03:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr ""

#: src/SUMMARY.md:3
msgid "The Cairo Programming Language Foreword Introduction"
msgstr ""

#: src/SUMMARY.md:7 src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:11 src/ch01-01-installation.md:1
#: src/ch01-01-installation.md:19
msgid "Installation"
msgstr ""

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md:14 src/SUMMARY.md:16
#: src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr ""

#: src/SUMMARY.md:17 src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr ""

#: src/SUMMARY.md:18 src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md:19 src/ch02-03-functions.md:1
msgid "Functions"
msgstr ""

#: src/SUMMARY.md:20 src/ch02-04-comments.md:1
msgid "Comments"
msgstr ""

#: src/SUMMARY.md:21 src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md:23 src/SUMMARY.md:25 src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr ""

#: src/SUMMARY.md:26 src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr ""

#: src/SUMMARY.md:27 src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr ""

#: src/SUMMARY.md:28 src/ch03-03-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr ""

#: src/SUMMARY.md:30 src/SUMMARY.md:32
msgid "Understanding Ownership"
msgstr ""

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr ""

#: src/SUMMARY.md:34 src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr ""

#: src/SUMMARY.md:36 src/SUMMARY.md:38
#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr ""

#: src/SUMMARY.md:39 src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/SUMMARY.md:40 src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr ""

#: src/SUMMARY.md:41 src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr ""

#: src/SUMMARY.md:43 src/SUMMARY.md:45
#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr ""

#: src/SUMMARY.md:46 src/ch06-01-enums.md:1
#: src/ch08-01-generic-data-types.md:186
msgid "Enums"
msgstr ""

#: src/SUMMARY.md:47 src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr ""

#: src/SUMMARY.md:49 src/SUMMARY.md:51
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr ""

#: src/SUMMARY.md:53 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr ""

#: src/SUMMARY.md:54 src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr ""

#: src/SUMMARY.md:55
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr ""

#: src/SUMMARY.md:57 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr ""

#: src/SUMMARY.md:59 src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr ""

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr ""

#: src/SUMMARY.md:63 src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr ""

#: src/SUMMARY.md:64 src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr ""

#: src/SUMMARY.md:66 src/SUMMARY.md:68 src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr ""

#: src/SUMMARY.md:70 src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr ""

#: src/SUMMARY.md:71 src/ch09-02-test-organization.md:1
msgid "Testing Organization"
msgstr ""

#: src/SUMMARY.md:73 src/SUMMARY.md:75
msgid "Error Handling"
msgstr ""

#: src/SUMMARY.md:77 src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr ""

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr ""

#: src/SUMMARY.md:80 src/SUMMARY.md:82 src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr ""

#: src/SUMMARY.md:84 src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr ""

#: src/SUMMARY.md:85 src/ch11-02-macros.md:1
msgid "Macros"
msgstr ""

#: src/SUMMARY.md:86 src/ch11-03-hash.md:19
msgid "Working with Hashes"
msgstr ""

#: src/SUMMARY.md:88
msgid "Starknet smart contracts"
msgstr ""

#: src/SUMMARY.md:90 src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md:92 src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr ""

#: src/SUMMARY.md:93 src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr ""

#: src/SUMMARY.md:94 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr ""

#: src/SUMMARY.md:96 src/ch99-01-03-01-contract-storage.md:1
msgid "Contract Storage"
msgstr ""

#: src/SUMMARY.md:97 src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr ""

#: src/SUMMARY.md:98
msgid "Contract Events"
msgstr ""

#: src/SUMMARY.md:99 src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr ""

#: src/SUMMARY.md:100
msgid "Optimizing storage costs"
msgstr ""

#: src/SUMMARY.md:102
msgid "Components"
msgstr ""

#: src/SUMMARY.md:104
msgid "Under the hood"
msgstr ""

#: src/SUMMARY.md:105 src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr ""

#: src/SUMMARY.md:106 src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr ""

#: src/SUMMARY.md:108
msgid "ABIs and Cross-contract Interactions"
msgstr ""

#: src/SUMMARY.md:110
msgid "ABIs and Interfaces"
msgstr ""

#: src/SUMMARY.md:111
msgid "Contract Dispatchers, Library Dispatchers and system calls"
msgstr ""

#: src/SUMMARY.md:113 src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr ""

#: src/SUMMARY.md:115 src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr ""

#: src/SUMMARY.md:117
msgid "L1 \\<\\> L2 Messaging"
msgstr ""

#: src/SUMMARY.md:118 src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr ""

#: src/SUMMARY.md:120 src/appendix-00.md:1
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md:122
msgid "A - Keywords"
msgstr ""

#: src/SUMMARY.md:123
msgid "B - Operators and Symbols"
msgstr ""

#: src/SUMMARY.md:124
msgid "C - Derivable Traits"
msgstr ""

#: src/SUMMARY.md:125
msgid "D - Useful Development Tools"
msgstr ""

#: src/SUMMARY.md:126
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr ""

#: src/SUMMARY.md:127
msgid "F - Installing Cairo binaries"
msgstr ""

#: src/SUMMARY.md:128
msgid "G - System Calls"
msgstr ""

#: src/title-page.md:3
msgid ""
"By the Cairo Community and its "
"[contributors](https://github.com/cairo-book/cairo-book.github.io). Special "
"thanks to [Starkware](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.5.1](https://github.com/starkware-libs/cairo/releases). See the "
"“Installation” section of Chapter 1 to install or update Cairo."
msgstr ""

#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr ""

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""

#: src/ch00-01-foreword.md:13
msgid "Acknowledgements"
msgstr ""

#: src/ch00-01-foreword.md:15
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr ""

#: src/ch00-01-foreword.md:17
msgid ""
"We would like to thank the Rust community for the [Rust "
"Book](https://doc.rust-lang.org/book/), which has been a great source of "
"inspiration for this book. Many examples and explanations have been adapted "
"from the Rust Book to fit the Cairo programming language, as the two "
"languages share many similarities."
msgstr ""

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr ""

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr ""

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr ""

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr ""

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom "
"non-deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr ""

#: src/ch00-00-introduction.md:24
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr ""

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: "
"<https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""

#: src/ch00-00-introduction.md:26
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""

#: src/ch01-00-getting-started.md:3
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr ""

#: src/ch01-00-getting-started.md:5
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr ""

#: src/ch01-00-getting-started.md:6
msgid "Writing a program that prints `Hello, world!`."
msgstr ""

#: src/ch01-00-getting-started.md:7
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr ""

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr ""

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr ""

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr ""

#: src/ch01-01-installation.md:17
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). We strongly "
"recommend that you install Scarb [via "
"asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a "
"CLI tool that can manage multiple language runtime versions on a per-project "
"basis. This will ensure that the version of Scarb you use to work on a "
"project always matches the one defined in the project settings, avoiding "
"problems related to version mismatches."
msgstr ""

#: src/ch01-01-installation.md:25
msgid ""
"Please refer to the [asdf "
"documentation](https://asdf-vm.com/guide/getting-started.html) to install "
"all prerequisites."
msgstr ""

#: src/ch01-01-installation.md:27
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the "
"following command:"
msgstr ""

#: src/ch01-01-installation.md:31
msgid "This will allow you to download specific versions:"
msgstr ""

#: src/ch01-01-installation.md:35
msgid "and set a global version: "
msgstr ""

#: src/ch01-01-installation.md:40
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""

#: src/ch01-01-installation.md:43
msgid "'=https'"
msgstr ""

#: src/ch01-01-installation.md:46
msgid ""
"In both cases, you can verify installation by running the following command "
"in a new terminal session, it should print both Scarb and Cairo language "
"versions, e.g:"
msgstr ""

#: src/ch01-01-installation.md:55
msgid "Installing the VSCode extension"
msgstr ""

#: src/ch01-01-installation.md:57
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1). "
"Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix "
"D](appendix-04-useful-development-tools.md) for more details."
msgstr ""

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr ""

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr ""

#: src/ch01-02-hello-world.md:24
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:31
msgid "For Windows CMD, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:34 src/ch01-02-hello-world.md:35
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:38
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""

#: src/ch01-02-hello-world.md:41
msgid "Creating a Project with Scarb"
msgstr ""

#: src/ch01-02-hello-world.md:43
msgid "Let’s create a new project using Scarb."
msgstr ""

#: src/ch01-02-hello-world.md:45
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr ""

#: src/ch01-02-hello-world.md:51
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our "
"project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr ""

#: src/ch01-02-hello-world.md:53
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""

#: src/ch01-02-hello-world.md:55
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""

#: src/ch01-02-hello-world.md:57
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new -help` to see "
"the available options."
msgstr ""

#: src/ch01-02-hello-world.md:60
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr ""

#: src/ch01-02-hello-world.md:62
msgid "Filename: Scarb.toml"
msgstr ""

#: src/ch01-02-hello-world.md:64
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2024_07\"\n"
"\n"
"# See more keys and their definitions at "
"https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of _Scarb.toml_ generated by `scarb new`"
msgstr ""

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""

#: src/ch01-02-hello-world.md:82
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of "
"the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix "
"E](./appendix-05-common-types-and-traits-and-cairo-prelude.md)"
msgstr ""

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""

#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""

#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""

#: src/ch01-02-hello-world.md:94
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr ""

#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr ""

#: src/ch01-02-hello-world.md:100 src/ch01-02-hello-world.md:179
msgid "\"Hello, World!\""
msgstr ""

#: src/ch01-02-hello-world.md:104
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""

#: src/ch01-02-hello-world.md:106
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr ""

#: src/ch01-02-hello-world.md:108
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""

#: src/ch01-02-hello-world.md:111
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""

#: src/ch01-02-hello-world.md:120
msgid " A sample Scarb project structure"
msgstr ""

#: src/ch01-02-hello-world.md:122
msgid "Building a Scarb Project"
msgstr ""

#: src/ch01-02-hello-world.md:124
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr ""

#: src/ch01-02-hello-world.md:132
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr ""

#: src/ch01-02-hello-world.md:134
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""

#: src/ch01-02-hello-world.md:143
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to the terminal."
msgstr ""

#: src/ch01-02-hello-world.md:146
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer—welcome!"
msgstr ""

#: src/ch01-02-hello-world.md:149
msgid "Anatomy of a Cairo Program"
msgstr ""

#: src/ch01-02-hello-world.md:151
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""

#: src/ch01-02-hello-world.md:160
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""

#: src/ch01-02-hello-world.md:165
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""

#: src/ch01-02-hello-world.md:169
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"D](appendix-04-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""

#: src/ch01-02-hello-world.md:176
msgid "The body of the `main` function holds the following code:"
msgstr ""

#: src/ch01-02-hello-world.md:182
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""

#: src/ch01-02-hello-world.md:185
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""

#: src/ch01-02-hello-world.md:187
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead, "
"it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in [Chapter Macros](./ch11-02-macros.md). For now, you "
"just need to know that using a `!` means that you’re calling a macro instead "
"of a normal function and that macros don’t always follow the same rules as "
"functions."
msgstr ""

#: src/ch01-02-hello-world.md:190
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""

#: src/ch01-02-hello-world.md:192
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""

#: src/ch01-02-hello-world.md:198 src/ch02-05-control-flow.md:302
#: src/ch03-03-custom-data-structures.md:338 src/ch05-03-method-syntax.md:285
#: src/ch07-05-separating-modules-into-different-files.md:98
#: src/ch10-02-recoverable-errors.md:190
msgid "Summary"
msgstr ""

#: src/ch01-02-hello-world.md:200
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr ""

#: src/ch01-02-hello-world.md:202
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a "
"specific one, using asdf."
msgstr ""

#: src/ch01-02-hello-world.md:203
msgid "We can create a project using `scarb new`."
msgstr ""

#: src/ch01-02-hello-world.md:204
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""

#: src/ch01-02-hello-world.md:205
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr ""

#: src/ch01-02-hello-world.md:207
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""

#: src/ch01-02-hello-world.md:209
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:83
#: src/ch02-01-variables-and-mutability.md:166 src/ch02-04-comments.md:21
#: src/ch02-04-comments.md:31 src/ch02-05-control-flow.md:11
#: src/ch02-05-control-flow.md:51 src/ch02-05-control-flow.md:104
#: src/ch02-05-control-flow.md:136 src/ch02-05-control-flow.md:173
#: src/ch04-01-what-is-ownership.md:235 src/ch04-01-what-is-ownership.md:280
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:113
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:51
#: src/ch05-01-defining-and-instantiating-structs.md:87
#: src/ch05-01-defining-and-instantiating-structs.md:123
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:47
#: src/ch05-02-an-example-program-using-structs.md:72
#: src/ch05-02-an-example-program-using-structs.md:99
#: src/ch05-02-an-example-program-using-structs.md:135
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:100
#: src/ch05-03-method-syntax.md:141 src/ch05-03-method-syntax.md:190
#: src/ch05-03-method-syntax.md:228
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-how-to-write-tests.md:28 src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:118 src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:206 src/ch09-01-how-to-write-tests.md:311
#: src/ch09-01-how-to-write-tests.md:456 src/ch09-01-how-to-write-tests.md:541
#: src/ch09-01-how-to-write-tests.md:622 src/ch09-01-how-to-write-tests.md:660
#: src/ch09-01-how-to-write-tests.md:696 src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:23
#: src/ch02-01-variables-and-mutability.md:25
#: src/ch02-01-variables-and-mutability.md:88
#: src/ch02-01-variables-and-mutability.md:90
#: src/ch02-01-variables-and-mutability.md:227
#: src/ch02-01-variables-and-mutability.md:229 src/ch02-03-functions.md:67
#: src/ch02-03-functions.md:261 src/ch02-03-functions.md:295
#: src/ch02-03-functions.md:312
msgid "\"The value of x is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:58
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole "
"class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:62
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:70
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon "
"examining the low-level Cairo Assembly code, it becomes clear that variable "
"mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only "
"difference is that at the Cairo level, the variable is not redeclared so its "
"type cannot change."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:81
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:94
msgid "When we run the program now, we get this:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:103
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:107
msgid "Constants"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:109
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:113
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:123
msgid ""
"The last difference is that constants may natively be set only to a constant "
"expression, not the result of a value that could only be computed at "
"runtime. Only literal constants are currently supported."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:127
msgid "Here’s an example of a constant declaration:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"We will dive into more detail about macros in the [dedicated "
"section](./ch11-02-macros.md)."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:141
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:144
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:150
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:155
msgid "Shadowing"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:157
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:174
msgid "\"Inner scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:176
msgid "\"Outer scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:180
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:195
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:201
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:212
msgid "\"The value of x is {} of type u64\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:213
msgid "// converts x to a felt, type annotation is required.\n"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:214
msgid "\"The value of x is {} of type felt252\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:218
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:233
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:246
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a conversion method where we specify the "
"desired output type."
msgstr ""

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr ""

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr ""

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr ""

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where `P` is a very large prime number "
"currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). When "
"adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of P is added or subtracted to bring the result back "
"within the range (i.e., the result is computed modulo P)."
msgstr ""

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} "
"\\\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\\\( "
"\\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\\\( "
"\\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` by "
"`y`."
msgstr ""

#: src/ch02-02-data-types.md:35
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\\\( "
"\\frac{6}{2} \\\\) will indeed result in `3`). But when y does not divide x, "
"you may get a surprising result: for example, since \\\\( 2 \\cdot \\frac{P "
"+ 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\\\( \\frac{1}{2} "
"\\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 or 0.5), as it "
"satisfies the above equation."
msgstr ""

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr ""

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow and underflow checks. By using these integer types, programmers "
"can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the "
"programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type "
"of an integer value."
msgstr ""

#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr ""

#: src/ch02-02-data-types.md:53 src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr ""

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr ""

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr ""

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""

#: src/ch02-02-data-types.md:74
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""

#: src/ch02-02-data-types.md:77
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type. It is also possible to use a visual "
"separator `_` for number literals, in order to improve code readability."
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "Table 3-2: Integer Literals in Cairo"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "Numeric literals"
msgstr ""

#: src/ch02-02-data-types.md:84 src/appendix-02-operators-and-symbols.md:11
#: src/appendix-07-system-calls.md:177 src/appendix-07-system-calls.md:256
#: src/appendix-07-system-calls.md:331
msgid "Example"
msgstr ""

#: src/ch02-02-data-types.md:86
msgid "Decimal"
msgstr ""

#: src/ch02-02-data-types.md:86
msgid "`98222`"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid "Hex"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid "`0xff`"
msgstr ""

#: src/ch02-02-data-types.md:88
msgid "Octal"
msgstr ""

#: src/ch02-02-data-types.md:88
msgid "`0o04321`"
msgstr ""

#: src/ch02-02-data-types.md:89
msgid "Binary"
msgstr ""

#: src/ch02-02-data-types.md:89
msgid "`0b01`"
msgstr ""

#: src/ch02-02-data-types.md:91
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""

#: src/ch02-02-data-types.md:94
msgid "Numeric Operations"
msgstr ""

#: src/ch02-02-data-types.md:96
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""

#: src/ch02-02-data-types.md:103
msgid "// addition\n"
msgstr ""

#: src/ch02-02-data-types.md:106
msgid "// subtraction\n"
msgstr ""

#: src/ch02-02-data-types.md:109
msgid "// multiplication\n"
msgstr ""

#: src/ch02-02-data-types.md:112
msgid "// division\n"
msgstr ""

#: src/ch02-02-data-types.md:113
msgid "//result is 1\n"
msgstr ""

#: src/ch02-02-data-types.md:114
msgid "//result is 2\n"
msgstr ""

#: src/ch02-02-data-types.md:116
msgid "// remainder\n"
msgstr ""

#: src/ch02-02-data-types.md:117
msgid "// result is 3\n"
msgstr ""

#: src/ch02-02-data-types.md:121
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""

#: src/ch02-02-data-types.md:124
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list "
"of all operators that Cairo provides."
msgstr ""

#: src/ch02-02-data-types.md:126
msgid "The Boolean Type"
msgstr ""

#: src/ch02-02-data-types.md:128
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""

#: src/ch02-02-data-types.md:136
msgid "// with explicit type annotation\n"
msgstr ""

#: src/ch02-02-data-types.md:140
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations. "
msgstr ""

#: src/ch02-02-data-types.md:142
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control "
"Flow”](ch02-05-control-flow.md) section."
msgstr ""

#: src/ch02-02-data-types.md:146
msgid "The Short String Type"
msgstr ""

#: src/ch02-02-data-types.md:148
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples "
"of declaring values by putting them between single quotes:"
msgstr ""

#: src/ch02-02-data-types.md:153
msgid "'C'"
msgstr ""

#: src/ch02-02-data-types.md:158
msgid "Type Conversion"
msgstr ""

#: src/ch02-02-data-types.md:160
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the "
"`try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""

#: src/ch02-02-data-types.md:162
msgid ""
"The `try_into` method allows for safe type conversion when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""

#: src/ch02-02-data-types.md:164
msgid ""
"On the other hand, the `into` method can be used for type conversion when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""

#: src/ch02-02-data-types.md:166
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to convert it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""

#: src/ch02-02-data-types.md:171
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""

#: src/ch02-02-data-types.md:177
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""

#: src/ch02-02-data-types.md:185
msgid "The Tuple Type"
msgstr ""

#: src/ch02-02-data-types.md:187
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""

#: src/ch02-02-data-types.md:191
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""

#: src/ch02-02-data-types.md:202
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""

#: src/ch02-02-data-types.md:213
msgid "\"y is 6!\""
msgstr ""

#: src/ch02-02-data-types.md:218
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"six` as the value of `y` is `6`."
msgstr ""

#: src/ch02-02-data-types.md:224
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr ""

#: src/ch02-02-data-types.md:233
msgid "The unit type ()"
msgstr ""

#: src/ch02-02-data-types.md:235
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr ""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr ""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""

#: src/ch02-03-functions.md:45
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""

#: src/ch02-03-functions.md:49
msgid "Parameters"
msgstr ""

#: src/ch02-03-functions.md:51
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""

#: src/ch02-03-functions.md:59
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch02-03-functions.md:71
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch02-03-functions.md:79
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""

#: src/ch02-03-functions.md:83
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""

#: src/ch02-03-functions.md:89
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""

#: src/ch02-03-functions.md:94
msgid "\"h\""
msgstr ""

#: src/ch02-03-functions.md:98
msgid "\"The measurement is: {value}{unit_label}\""
msgstr ""

#: src/ch02-03-functions.md:102
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second "
"is named `unit_label` and is of type `ByteArray` - Cairo's internal type to "
"represent string literals. The function then prints text containing both the "
"`value` and the `unit_label`."
msgstr ""

#: src/ch02-03-functions.md:106
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""

#: src/ch02-03-functions.md:115
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""

#: src/ch02-03-functions.md:117
msgid "Named parameters"
msgstr ""

#: src/ch02-03-functions.md:119
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and "
"self-descriptive. If you want to use named parameters, you need to specify "
"the name of the parameter and the value you want to pass to it. The syntax "
"is `parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""

#: src/ch02-03-functions.md:122
msgid "Here is an example:"
msgstr ""

#: src/ch02-03-functions.md:137
msgid "Statements and Expressions"
msgstr ""

#: src/ch02-03-functions.md:139
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""

#: src/ch02-03-functions.md:147
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr ""

#: src/ch02-03-functions.md:149
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""

#: src/ch02-03-functions.md:151
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""

#: src/ch02-03-functions.md:161
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr ""

#: src/ch02-03-functions.md:163
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""

#: src/ch02-03-functions.md:166
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""

#: src/ch02-03-functions.md:175
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""

#: src/ch02-03-functions.md:199
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""

#: src/ch02-03-functions.md:205
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`."
msgstr ""

#: src/ch02-03-functions.md:211
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""

#: src/ch02-03-functions.md:213
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr ""

#: src/ch02-03-functions.md:223
msgid "\"The value of y is: {}\""
msgstr ""

#: src/ch02-03-functions.md:227
msgid "This expression:"
msgstr ""

#: src/ch02-03-functions.md:236
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""

#: src/ch02-03-functions.md:244
msgid "Functions with Return Values"
msgstr ""

#: src/ch02-03-functions.md:246
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""

#: src/ch02-03-functions.md:265
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in "
"Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""

#: src/ch02-03-functions.md:276
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""

#: src/ch02-03-functions.md:286
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""

#: src/ch02-03-functions.md:303
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end "
"of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""

#: src/ch02-03-functions.md:320
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:324
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr ""

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr ""

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and "
"the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr ""

#: src/ch02-04-comments.md:25
msgid "// return the sum of 1 and 4\n"
msgstr ""

#: src/ch02-04-comments.md:29
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr ""

#: src/ch02-04-comments.md:35
msgid "// this function performs a simple addition\n"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr ""

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to "
"explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""

#: src/ch02-05-control-flow.md:18
msgid "\"condition was true and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:20
msgid "\"condition was false and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:37
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""

#: src/ch02-05-control-flow.md:49
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""

#: src/ch02-05-control-flow.md:59
msgid "\"number was three\""
msgstr ""

#: src/ch02-05-control-flow.md:64
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr ""

#: src/ch02-05-control-flow.md:78
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will "
"not automatically try to convert non-Boolean types to a Boolean. If we want "
"the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""

#: src/ch02-05-control-flow.md:92
msgid "\"number was something other than zero\""
msgstr ""

#: src/ch02-05-control-flow.md:98
msgid "Running this code will print `number was something other than zero`."
msgstr ""

#: src/ch02-05-control-flow.md:100
msgid "Handling Multiple Conditions with `else if`"
msgstr ""

#: src/ch02-05-control-flow.md:102
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if` "
"expression. For example:"
msgstr ""

#: src/ch02-05-control-flow.md:111
msgid "\"number is 12\""
msgstr ""

#: src/ch02-05-control-flow.md:113
msgid "\"number is 3\""
msgstr ""

#: src/ch02-05-control-flow.md:115
msgid "\"number minus 2 is 1\""
msgstr ""

#: src/ch02-05-control-flow.md:117
msgid "\"number not found\""
msgstr ""

#: src/ch02-05-control-flow.md:122
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:130
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using "
"too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter "
"6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo "
"branching construct called `match` for these cases."
msgstr ""

#: src/ch02-05-control-flow.md:132
msgid "Using `if` in a `let` statement"
msgstr ""

#: src/ch02-05-control-flow.md:134
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr ""

#: src/ch02-05-control-flow.md:148
msgid "\"condition was true and number is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:159
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr ""

#: src/ch02-05-control-flow.md:161
msgid "Repetition with Loops"
msgstr ""

#: src/ch02-05-control-flow.md:163
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""

#: src/ch02-05-control-flow.md:165
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr ""

#: src/ch02-05-control-flow.md:167
msgid "Repeating Code with `loop`"
msgstr ""

#: src/ch02-05-control-flow.md:169
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""

#: src/ch02-05-control-flow.md:171
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""

#: src/ch02-05-control-flow.md:177
msgid "\"again!\""
msgstr ""

#: src/ch02-05-control-flow.md:185
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr ""

#: src/ch02-05-control-flow.md:187
msgid ""
"When we run this program, we’ll see again! printed over and over "
"continuously until either the program runs out of gas or we stop the program "
"manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a "
"program that is stuck in a continual loop. Give it a try:"
msgstr ""

#: src/ch02-05-control-flow.md:188
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=2000000000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:198
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""

#: src/ch02-05-control-flow.md:200
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In the previous case, we set the gas limit high enough for the the program "
"to run for quite some time."
msgstr ""

#: src/ch02-05-control-flow.md:202
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""

#: src/ch02-05-control-flow.md:205
msgid ""
"Now, try running the same program again, but this time with the "
"`--available-gas` flag set to `200000` instead of `2000000000000`. You will "
"see the program only prints `again!` 3 times before it stops, as it ran out "
"of gas to keep executing the loop."
msgstr ""

#: src/ch02-05-control-flow.md:207
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""

#: src/ch02-05-control-flow.md:216 src/ch02-05-control-flow.md:236
msgid "\"i = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:222
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration.  Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""

#: src/ch02-05-control-flow.md:242
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""

#: src/ch02-05-control-flow.md:244
msgid "Returning Values from Loops"
msgstr ""

#: src/ch02-05-control-flow.md:246
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""

#: src/ch02-05-control-flow.md:264
msgid "\"The result is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:268
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""

#: src/ch02-05-control-flow.md:275
msgid "Conditional Loops with `while`"
msgstr ""

#: src/ch02-05-control-flow.md:277
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`; "
"you could try that now in a program, if you’d like. However, this pattern is "
"so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""

#: src/ch02-05-control-flow.md:283
msgid ""
"In Listing 2-3, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""

#: src/ch02-05-control-flow.md:290
msgid "\"{number}!\""
msgstr ""

#: src/ch02-05-control-flow.md:294
msgid "\"LIFTOFF!!!\""
msgstr ""

#: src/ch02-05-control-flow.md:297
msgid ""
"Listing 2-3: Using a `while` loop to run code while a condition holds `true`"
msgstr ""

#: src/ch02-05-control-flow.md:299
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""

#: src/ch02-05-control-flow.md:304
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""

#: src/ch02-05-control-flow.md:308
msgid "Generate the _n_\\-th Fibonacci number."
msgstr ""

#: src/ch02-05-control-flow.md:309
msgid "Compute the factorial of a number _n_."
msgstr ""

#: src/ch02-05-control-flow.md:311
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. "
"Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr ""

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr ""

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr ""

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr ""

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped, "
"containing the removed element, or `Option::None` if the array is empty."
msgstr ""

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr ""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr ""

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr ""

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""

#: src/ch03-01-arrays.md:71
msgid "`get()` method"
msgstr ""

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and "
"Snapshots](ch04-02-references-and-snapshots.md) chapter."
msgstr ""

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr ""

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap "
"operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
msgstr ""

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr ""

#: src/ch03-01-arrays.md:94
msgid "`at()` method"
msgstr ""

#: src/ch03-01-arrays.md:96
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""

#: src/ch03-01-arrays.md:98
msgid "Here is an example with the `at()` method:"
msgstr ""

#: src/ch03-01-arrays.md:111
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""

#: src/ch03-01-arrays.md:115
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""

#: src/ch03-01-arrays.md:128
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""

#: src/ch03-01-arrays.md:130
msgid "Size related methods"
msgstr ""

#: src/ch03-01-arrays.md:132
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return value is of type `usize`."
msgstr ""

#: src/ch03-01-arrays.md:134
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""

#: src/ch03-01-arrays.md:136 src/ch11-02-macros.md:27
msgid "`array!` macro"
msgstr ""

#: src/ch03-01-arrays.md:138
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""

#: src/ch03-01-arrays.md:141
msgid "Without `array!`:"
msgstr ""

#: src/ch03-01-arrays.md:152
msgid "With `array!`:"
msgstr ""

#: src/ch03-01-arrays.md:158
msgid "Storing multiple types with Enums"
msgstr ""

#: src/ch03-01-arrays.md:160
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [Enums and Pattern "
"Matching](ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""

#: src/ch03-01-arrays.md:178
msgid "Span"
msgstr ""

#: src/ch03-01-arrays.md:180
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""

#: src/ch03-01-arrays.md:182
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr ""

#: src/ch03-01-arrays.md:184
msgid "Turning an Array into span"
msgstr ""

#: src/ch03-01-arrays.md:186
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr ""

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr ""

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr ""

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our "
"users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr ""

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr ""

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""

#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr ""

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""

#: src/ch03-02-dictionaries.md:69
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:70
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""

#: src/ch03-02-dictionaries.md:71
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr ""

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""

#: src/ch03-02-dictionaries.md:83
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr ""

#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""

#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146 src/ch03-02-dictionaries.md:147
msgid "0"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
msgid "100"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:113
msgid "50"
msgstr ""

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr ""

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""

#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr ""

#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
msgid "150"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "70"
msgstr ""

#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138
msgid "250"
msgstr ""

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137
msgid "40"
msgstr ""

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
msgid "300"
msgstr ""

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "190"
msgstr ""

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:145
msgid "90"
msgstr ""

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr ""

#: src/ch03-02-dictionaries.md:149
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr ""

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of "
"Dictionaries](#basic-use-of-dictionaries), you'd notice that there was never "
"a call to squash dictionary, but the program compiled successfully "
"nonetheless. What happened behind the scene was that squash was called "
"automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` "
"trait. This call occurred just before the `balance` dictionary went out of "
"scope."
msgstr ""

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and "
"Destruct](/appendix-03-derivable-traits.md#drop-and-destruct)."
msgstr ""

#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"we will have a hands-on example where we implement the `Destruct<T>` trait "
"for a custom type."
msgstr ""

#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-types-not-supported-natively) "
"with other complex types such as `Array<T>` and how to "
"[implement](#dictionaries-as-struct-members) a struct with a dictionary as a "
"member."
msgstr ""

#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr ""

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never "
"panic."
msgstr ""

#: src/ch03-02-dictionaries.md:178
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""

#: src/ch03-02-dictionaries.md:184
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:186
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:188
msgid "Create the new entry to add using the `entry` method."
msgstr ""

#: src/ch03-02-dictionaries.md:189
msgid "Insert back the entry where the `new_value` equals the `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:190
msgid "Return the value."
msgstr ""

#: src/ch03-02-dictionaries.md:192
msgid "Implementing our custom get would look like this:"
msgstr ""

#: src/ch03-02-dictionaries.md:200 src/ch03-02-dictionaries.md:244
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:203 src/ch03-02-dictionaries.md:247
msgid "// Store the value to return\n"
msgstr ""

#: src/ch03-02-dictionaries.md:206 src/ch03-02-dictionaries.md:250
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:209 src/ch03-02-dictionaries.md:253
msgid "// Return the read value\n"
msgstr ""

#: src/ch03-02-dictionaries.md:214
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [References and "
"Snapshots](ch04-02-references-and-snapshots.md) section."
msgstr ""

#: src/ch03-02-dictionaries.md:217
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:225
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:230
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:236
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""

#: src/ch03-02-dictionaries.md:260
msgid "// Get the last entry associated with `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:261
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr ""

#: src/ch03-02-dictionaries.md:262
msgid "// be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:265
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr ""

#: src/ch03-02-dictionaries.md:266
msgid "// and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:273 src/ch03-02-dictionaries.md:275
msgid "'0'"
msgstr ""

#: src/ch03-02-dictionaries.md:277
msgid "\"Expecting 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:283
msgid "Dictionaries of types not supported natively"
msgstr ""

#: src/ch03-02-dictionaries.md:285
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types "
"not natively supported is not a straightforward task, because you would need "
"to write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:291
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a "
"pointer that can only be manipulated in one place at a time."
msgstr ""

#: src/ch03-02-dictionaries.md:293
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:299 src/ch03-02-dictionaries.md:353
msgid "// Create the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:302 src/ch03-02-dictionaries.md:356
msgid "// Create the array to insert\n"
msgstr ""

#: src/ch03-02-dictionaries.md:305 src/ch03-02-dictionaries.md:359
msgid "// Insert it as a `Span`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:307 src/ch03-02-dictionaries.md:322
msgid "//...\n"
msgstr ""

#: src/ch03-02-dictionaries.md:311
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""

#: src/ch03-02-dictionaries.md:313
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we didn't do that directly, but instead, we took some steps in between:"
msgstr ""

#: src/ch03-02-dictionaries.md:315
msgid ""
"We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr ""

#: src/ch03-02-dictionaries.md:316
msgid ""
"We wrapped the `Box` inside a nullable using the `nullable_from_box` "
"function."
msgstr ""

#: src/ch03-02-dictionaries.md:317
msgid "Finally, we inserted the result."
msgstr ""

#: src/ch03-02-dictionaries.md:319
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""

#: src/ch03-02-dictionaries.md:324 src/ch03-02-dictionaries.md:362
msgid "// Get value back\n"
msgstr ""

#: src/ch03-02-dictionaries.md:327 src/ch03-02-dictionaries.md:365
msgid "// Search the value and assert it is not null\n"
msgstr ""

#: src/ch03-02-dictionaries.md:329 src/ch03-02-dictionaries.md:367
msgid "\"No value found\""
msgstr ""

#: src/ch03-02-dictionaries.md:333 src/ch03-02-dictionaries.md:371
msgid "// Verify we are having the right values\n"
msgstr ""

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:372
msgid "\"Expecting 8\""
msgstr ""

#: src/ch03-02-dictionaries.md:335 src/ch03-02-dictionaries.md:373
msgid "\"Expecting 9\""
msgstr ""

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:374
msgid "\"Expecting 10\""
msgstr ""

#: src/ch03-02-dictionaries.md:340
msgid "Here we:"
msgstr ""

#: src/ch03-02-dictionaries.md:342
msgid "Read the value using `get`."
msgstr ""

#: src/ch03-02-dictionaries.md:343
msgid "Verified it is non-null using the `match_nullable` function."
msgstr ""

#: src/ch03-02-dictionaries.md:344
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr ""

#: src/ch03-02-dictionaries.md:346
msgid "The complete script would look like this:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize "
"that arrays have one big limitation - the data stored in them is immutable. "
"Once you append a value to an array, you can't modify it."
msgstr ""

#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""

#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary "
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to "
"simulate the behavior of mutable data structures. Let's first explore how to "
"create a struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""

#: src/ch03-03-custom-data-structures.md:27
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of "
"the book. We recommend you to check out the following chapter first: "
"[Structs](ch05-00-using-structs-to-structure-related-data.md), "
"[Methods](./ch05-03-method-syntax.md), [Generic "
"types](./ch08-00-generic-types-and-traits.md), "
"[Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch03-03-custom-data-structures.md:34
msgid "Dictionaries as Struct Members"
msgstr ""

#: src/ch03-03-custom-data-structures.md:36
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:51
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:53
msgid "`users_updates`, the number of users updates in the dictionary and"
msgstr ""

#: src/ch03-03-custom-data-structures.md:54
msgid "`balances`, a mapping of each user to its balance."
msgstr ""

#: src/ch03-03-custom-data-structures.md:56
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:58
msgid "`new` for easily creating new `UserDatabase` types."
msgstr ""

#: src/ch03-03-custom-data-structures.md:59
msgid "`update_user` to update the balance of users in the database."
msgstr ""

#: src/ch03-03-custom-data-structures.md:60
msgid "`get_balance` to find user's balance in the database."
msgstr ""

#: src/ch03-03-custom-data-structures.md:62
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [generic "
"types](/src/ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:64
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""

#: src/ch03-03-custom-data-structures.md:65
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""

#: src/ch03-03-custom-data-structures.md:66
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"destructible."
msgstr ""

#: src/ch03-03-custom-data-structures.md:68
msgid "The implementation, with all restrictions in place, would be as follow:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:74
#: src/ch03-03-custom-data-structures.md:119
msgid "// Creates a database\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:79
#: src/ch03-03-custom-data-structures.md:124
msgid "// Get the user's balance\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:84
#: src/ch03-03-custom-data-structures.md:129
msgid "// Add a user\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:92
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of "
"[genericity](/src/ch08-00-generic-types-and-traits.md) in the struct "
"definition. We need to code the `Destruct<T>` trait implementation by "
"ourselves:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:104
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:154
msgid "\"Expected 40\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:155
msgid "\"Expected 0\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:161
msgid "Simulating a dynamic array with dicts"
msgstr ""

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""

#: src/ch03-03-custom-data-structures.md:166
msgid "It should:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:168
msgid "Allow us to append items at the end."
msgstr ""

#: src/ch03-03-custom-data-structures.md:169
msgid "Let us access any item by index."
msgstr ""

#: src/ch03-03-custom-data-structures.md:170
msgid "Allow setting the value of an item at a specific index."
msgstr ""

#: src/ch03-03-custom-data-structures.md:171
msgid "Return the current length."
msgstr ""

#: src/ch03-03-custom-data-structures.md:173
msgid "We can define this interface in Cairo like:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:186
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""

#: src/ch03-03-custom-data-structures.md:189
msgid "Implementing a dynamic array in Cairo"
msgstr ""

#: src/ch03-03-custom-data-structures.md:191
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""

#: src/ch03-03-custom-data-structures.md:194
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the "
"[Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) "
"section:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:206
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:212
#: src/ch03-03-custom-data-structures.md:241
#: src/ch03-03-custom-data-structures.md:250
msgid "\"Index out of bounds\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:217
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr ""

#: src/ch03-03-custom-data-structures.md:219
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for "
"modifiable data structures like vectors."
msgstr ""

#: src/ch03-03-custom-data-structures.md:222
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""

#: src/ch03-03-custom-data-structures.md:259
msgid ""
"The full implementation of the `Vec` structure can be found in the "
"community-maintained library "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)."
msgstr ""

#: src/ch03-03-custom-data-structures.md:263
msgid "Simulating a Stack with dicts"
msgstr ""

#: src/ch03-03-custom-data-structures.md:265
msgid ""
"We will now look at a second example and its implementation details: a Stack."
msgstr ""

#: src/ch03-03-custom-data-structures.md:267
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""

#: src/ch03-03-custom-data-structures.md:271
msgid "Let us define what operations we need to create a stack :"
msgstr ""

#: src/ch03-03-custom-data-structures.md:273
msgid "Push an item to the top of the stack."
msgstr ""

#: src/ch03-03-custom-data-structures.md:274
msgid "Pop an item from the top of the stack."
msgstr ""

#: src/ch03-03-custom-data-structures.md:275
msgid "Check whether there are still any elements in the stack."
msgstr ""

#: src/ch03-03-custom-data-structures.md:277
msgid "From these specifications we can define the following interface :"
msgstr ""

#: src/ch03-03-custom-data-structures.md:287
msgid "Implementing a Mutable Stack in Cairo"
msgstr ""

#: src/ch03-03-custom-data-structures.md:289
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field "
"to keep track of the length of the stack to iterate over it."
msgstr ""

#: src/ch03-03-custom-data-structures.md:293
msgid "The Stack struct is defined as:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:302
msgid "Next, let's see how our main functions `push` and `pop` are implemented."
msgstr ""

#: src/ch03-03-custom-data-structures.md:325
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function retrieves the last value at position "
"`len-1` and then decreases the value of `len` to update the position of the "
"stack top accordingly."
msgstr ""

#: src/ch03-03-custom-data-structures.md:333
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures) "
"library, in the \"data_structures\" crate."
msgstr ""

#: src/ch03-03-custom-data-structures.md:340
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures.  While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to "
"implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""

#: src/ch03-03-custom-data-structures.md:347
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that doesn’t commonly exist in other programming languages: "
"ownership."
msgstr ""

#: src/ch04-00-understanding-ownership.md:1
msgid "Understanding Cairo's Ownership system"
msgstr ""

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr ""

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr ""

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr ""

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr ""

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr ""

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr ""

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr ""

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr ""

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:58
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr ""

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the [previous "
"chapter](./ch03-01-arrays.md)."
msgstr ""

#: src/ch04-01-what-is-ownership.md:67
msgid "Moving values - example with Array"
msgstr ""

#: src/ch04-01-what-is-ownership.md:69
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another "
"function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is "
"created to hold the same value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:82
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:97
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:107
msgid "The Copy trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:109
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation, because variables are a cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""

#: src/ch04-01-what-is-ownership.md:112
msgid ""
"All basic types previously described in [data types "
"chapter](ch02-02-data-types.md) implement by default the `Copy` trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:114
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:130
msgid "// do something with p\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:134
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:137
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""

#: src/ch04-01-what-is-ownership.md:139
msgid "Destroying values - example with FeltDict"
msgstr ""

#: src/ch04-01-what-is-ownership.md:141
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""

#: src/ch04-01-what-is-ownership.md:145
msgid "No-op destruction: the `Drop` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:147
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out "
"of scope:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:154
msgid "// error: Value not dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:158
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:160
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries "
"(`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:168
msgid "// Now there is no error.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:172
msgid "Destruction with a side-effect: the `Destruct` trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:174
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""

#: src/ch04-01-what-is-ownership.md:176
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:189
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:198
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:207
msgid "// No error here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:211
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""

#: src/ch04-01-what-is-ownership.md:213
msgid "Copy Array data with Clone"
msgstr ""

#: src/ch04-01-what-is-ownership.md:215
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in [Chapter "
"5-3](ch05-03-method-syntax.md), but because methods are a common feature in "
"many programming languages, you’ve probably seen them before."
msgstr ""

#: src/ch04-01-what-is-ownership.md:217
msgid "Here’s an example of the `clone` method in action."
msgstr ""

#: src/ch04-01-what-is-ownership.md:226
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""

#: src/ch04-01-what-is-ownership.md:229
msgid "Return Values and Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:231
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""

#: src/ch04-01-what-is-ownership.md:242
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:245
msgid "// a2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:251
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:254
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:258 src/ch04-01-what-is-ownership.md:266
msgid "// some_a comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:260
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:264
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:268
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:274
msgid "Listing 4-2: Moving return values"
msgstr ""

#: src/ch04-01-what-is-ownership.md:276
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the "
"function that we might want to return as well."
msgstr ""

#: src/ch04-01-what-is-ownership.md:278
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr ""

#: src/ch04-01-what-is-ownership.md:290
msgid "// len() returns the length of an array\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:296
msgid "Listing 4-3: Returning many values"
msgstr ""

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates "
"a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:62
msgid "// Calculate the current length of the array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:56
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:59
msgid "Let’s take a closer look at the function call here:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:65
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value at a specific point in time, the "
"usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:67
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:71
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:74
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:78
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:80
msgid "Desnap Operator"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:82
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator "
"reuses the old value, and so desnapping is a completely free operation, just "
"like `Copy`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:98
msgid "\"Area: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:102
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:110
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot? "
"Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:134
msgid "Listing 4-4: Attempting to modify a snapshot value"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:136
msgid "Here’s the error:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:145
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:147
msgid "Mutable References"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:149
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:152
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:154
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:166
msgid "\"height: {}, width: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:176
msgid "Listing 4-5: Use of a mutable reference to modify a value"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:178
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:180
msgid "The output of the program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:187
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:189
msgid "Small recap"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:191
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:193
msgid "At any given time, a variable can only have one owner."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:194
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:196
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:197
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full "
"advantage of Cairo's compile-time type checking."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data "
"Types](ch02-02-data-types.md) section, in that both hold multiple related "
"values. Like tuples, the pieces of a struct can be different types. Unlike "
"with tuples, in a struct you’ll name each piece of data so it’s clear what "
"the values mean. Adding these names means that structs are more flexible "
"than tuples: you don’t have to rely on the order of the data to specify or "
"access the values of an instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "Listing 5-1: A `User` struct definition"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare two particular users as shown in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:47
msgid "Listing 5-2: Creating two instances of the `User` struct"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:79
msgid "Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:115
msgid ""
"Listing 5-4: A `build_user` function that takes an email and username and "
"returns a `User` instance"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid "Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:151
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because "
"the `username` and `email` parameters have the same name as struct fields"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:15
#: src/ch05-02-an-example-program-using-structs.md:53
#: src/ch05-02-an-example-program-using-structs.md:83
#: src/ch05-03-method-syntax.md:40
msgid "\"Area is {}\""
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:23
msgid ""
"Listing 5-6: Calculating the area of a rectangle specified by separate width "
"and height variables"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:33
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:35
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:41
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [tuple section of Chapter "
"2](ch02-02-data-types.html#the-tuple-type)."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:43
msgid "Refactoring with Tuples"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:45
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:62
msgid ""
"Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:64
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:68
msgid "Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:70
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:91
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:93
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:95
msgid "Adding Useful Functionality with Trait"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-9 "
"tries to print `rectangle` using the `print` function. This won’t work."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:118
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:120
msgid "When we compile this code, we get an error with this message:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:133
msgid ""
"The `PrintTrait` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:161
msgid "Listing 5-10: Implementing the `PrintTrait` trait on Rectangle"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:163
msgid "When we run the `main` function, we get the following output:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:168
msgid "'\n'"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:173
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr ""

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on. For those familiar with Rust, Cairo's approach "
"might be confusing, as methods cannot be defined directly on types. Instead, "
"you must define a [trait](./ch08-02-traits-in-cairo.md) and an "
"implementation associated with the type for which the method is intended."
msgstr ""

#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr ""

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `RectangleTrait` "
"trait, as shown in Listing 5-11."
msgstr ""

#: src/ch05-03-method-syntax.md:44
msgid "Listing 5-11: Defining an `area` method to use on the `Rectangle` "
msgstr ""

#: src/ch05-03-method-syntax.md:47
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait` block with the signature of the method that we want to "
"implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we "
"define an `impl` (implementation) block for `RectangleTrait`, that defines "
"the behavior of the methods implemented. Everything within this `impl` block "
"will be associated with the type of the `self` parameter of the method "
"called. While it is technically possible to define methods for multiple "
"types within the same `impl` block, it is not a recommended practice, as it "
"can lead to confusion. We recommend that the type of the `self` parameter "
"stays consistent within the same `impl` block. Then we move the `area` "
"function within the `impl` curly brackets and change the first (and in this "
"case, only) parameter to be `self` in the signature and everywhere within "
"the body. In `main`, where we called the `area` function and passed `rect1` "
"as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an "
"instance: we add a dot followed by the method name, parentheses, and any "
"arguments."
msgstr ""

#: src/ch05-03-method-syntax.md:65
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter. Note that we used the `@` snapshot operator in "
"front of the `Rectangle` type in the function signature. By doing so, we "
"indicate that this method takes an immutable snapshot of the `Rectangle` "
"instance, which is automatically created by the compiler when passing the "
"instance to the method. Methods can take ownership of `self`, use `self` "
"with snapshots as we’ve done here, or use a mutable reference to `self` "
"using the `ref self: T` syntax."
msgstr ""

#: src/ch05-03-method-syntax.md:73
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in "
"the function version: we don’t want to take ownership, and we just want to "
"read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, "
"we’d use `ref self: Rectangle` as the first parameter. Having a method that "
"takes ownership of the instance by using just `self` as the first parameter "
"is rare; this technique is usually used when the method transforms `self` "
"into something else and you want to prevent the caller from using the "
"original instance after the transformation."
msgstr ""

#: src/ch05-03-method-syntax.md:82
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members. This is necessary because the struct is "
"passed as a snapshot, and all of its field values are of type `@T`, "
"requiring them to be desnapped in order to manipulate them."
msgstr ""

#: src/ch05-03-method-syntax.md:87
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide. However, we can define multiple "
"combinations of `trait` & `impl` blocks for the same type at different "
"places, which can be useful for a more granular code organization. For "
"example, you could implement the `Add` trait for your type in one `impl` "
"block, and the `Sub` trait in another block."
msgstr ""

#: src/ch05-03-method-syntax.md:96
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr ""

#: src/ch05-03-method-syntax.md:121
msgid "\"Width is {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:125
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0`, and `false` if the "
"value is `0`: we can use a field within a method of the same name for any "
"purpose. In `main`, when we follow `rect1.width` with parentheses, Cairo "
"knows we mean the method `width`. When we don’t use parentheses, Cairo knows "
"we mean the field `width`."
msgstr ""

#: src/ch05-03-method-syntax.md:132
msgid "Methods with More Parameters"
msgstr ""

#: src/ch05-03-method-syntax.md:134
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we "
"want to be able to write the program shown in Listing 5-12."
msgstr ""

#: src/ch05-03-method-syntax.md:156
msgid "\"Can rect1 hold rect2? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:157
msgid "\"Can rect1 hold rect3? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:161
msgid "Listing 5-12: Using the as-yet-unwritten `can_hold` method"
msgstr ""

#: src/ch05-03-method-syntax.md:164
msgid ""
"The expected output would look like the following because both dimensions of "
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr ""

#: src/ch05-03-method-syntax.md:176
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The "
"method name will be `can_hold`, and it will take a snapshot of another "
"`Rectangle` as a parameter. We can tell what the type of the parameter will "
"be by looking at the code that calls the method: `rect1.can_hold(@rect2)` "
"passes in `@rect2`, which is a snapshot to `rect2`, an instance of "
"`Rectangle`. This makes sense because we only need to read `rect2` (rather "
"than write, which would mean we’d need a mutable borrow), and we want `main` "
"to retain ownership of `rect2` so we can use it again after calling the "
"`can_hold` method. The return value of `can_hold` will be a Boolean, and the "
"implementation will check whether the width and height of `self` are greater "
"than the width and height of the other `Rectangle`, respectively. Let’s add "
"the new `can_hold` method to the `trait` and `impl` blocks from Listing "
"5-11, shown in Listing 5-13."
msgstr ""

#: src/ch05-03-method-syntax.md:209
msgid ""
"Listing 5-13: Implementing the `can_hold` method on `Rectangle` that takes "
"another `Rectangle` instance as a parameter"
msgstr ""

#: src/ch05-03-method-syntax.md:212
msgid ""
"When we run this code with the `main` function in Listing 5-12, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""

#: src/ch05-03-method-syntax.md:217
msgid "Accessing implementation functions"
msgstr ""

#: src/ch05-03-method-syntax.md:219
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed using the `::` operator on the implementation name. Functions in "
"traits that aren’t methods are often used for constructors that will return "
"a new instance of the struct. These are often called `new`, but `new` isn’t "
"a special name and isn’t built into the language. For example, we could "
"choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it "
"easier to create a square `Rectangle` rather than having to specify the same "
"value twice:"
msgstr ""

#: src/ch05-03-method-syntax.md:242
msgid ""
"To call this function, we use the `::` syntax with the implementation name: "
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by the implementation; the `::` syntax is used for both trait "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](ch07-02-defining-modules-to-control-scope.md)."
msgstr ""

#: src/ch05-03-method-syntax.md:247
msgid ""
"Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""

#: src/ch05-03-method-syntax.md:250
msgid "Multiple `impl` Blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:252
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing 5-13 is equivalent to the code shown in Listing 5-14, which "
"has each method in its own `trait` and `impl` blocks."
msgstr ""

#: src/ch05-03-method-syntax.md:277
msgid "Listing 5-14: Rewriting Listing 5-13 using multiple `impl` blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:280
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` "
"blocks here, but this is valid syntax. We’ll see a case in which multiple "
"blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where "
"we discuss generic types and traits."
msgstr ""

#: src/ch05-03-method-syntax.md:287
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `trait` and `impl` "
"blocks, you can define methods, which are functions associated to a type and "
"let you specify the behavior that instances of your type have."
msgstr ""

#: src/ch05-03-method-syntax.md:293
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr ""

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr ""

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""

#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""

#: src/ch06-01-enums.md:39
msgid "Enums Combined with Custom Types"
msgstr ""

#: src/ch06-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr ""

#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""

#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr ""

#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr ""

#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr ""

#: src/ch06-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr ""

#: src/ch06-01-enums.md:60
msgid "Trait Implementations for Enums"
msgstr ""

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""

#: src/ch06-01-enums.md:72 src/ch06-01-enums.md:98
msgid "\"quitting\""
msgstr ""

#: src/ch06-01-enums.md:73 src/ch06-01-enums.md:99
msgid "\"echoing {}\""
msgstr ""

#: src/ch06-01-enums.md:74 src/ch06-01-enums.md:100
msgid "\"moving\""
msgstr ""

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr ""

#: src/ch06-01-enums.md:114
msgid "The Option Enum and Its Advantages"
msgstr ""

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""

#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr ""

#: src/ch06-01-enums.md:131
msgid "Recursive Approach `find_value_recursive`"
msgstr ""

#: src/ch06-01-enums.md:132
msgid "Iterative Approach `find_value_iterative`"
msgstr ""

#: src/ch06-01-enums.md:134
msgid ""
"Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr ""

#: src/ch06-01-enums.md:183
msgid "\"found recursively at index {}\""
msgstr ""

#: src/ch06-01-enums.md:186 src/ch06-01-enums.md:194
msgid "\"not found\""
msgstr ""

#: src/ch06-01-enums.md:191
msgid "\"found iteratively at index {}\""
msgstr ""

#: src/ch06-01-enums.md:201
msgid "Running this code would print `it worked`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-3."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"Listing 6-3: An enum and a `match` expression that has the variants of the "
"enum as its patterns"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with if, but there’s a big difference: with if, the "
"condition needs to evaluate to a Boolean value, but here it can be any type. "
"The type of `coin` in this example is the `Coin` enum that we defined on the "
"first line."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a `match` arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-4."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in `println!` macro, "
"thus getting the inner state value out of the Coin enum variant for Quarter."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:102
msgid "Matching with `Option<T>`"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-5."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:125
msgid "Listing 6-5: A function that uses a `match` expression on an `Option<u8>`"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:133
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the `match` arm is "
"then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:141
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:147
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid "Matches Are Exhaustive"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:163
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:177
msgid "Catch-all with the `_` Placeholder"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:183
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that process inserted coins and returns `true` only if the "
"coin is accepted."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:186
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:197
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid "Multiple Patterns with the `|` operator"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:209
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:220
msgid "Matching Tuples"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:222
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:234
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:247
msgid "Matching `felt252` and integer variables"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:249
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However there are some restrictions:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:252
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is "
"not supported)."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:253
msgid "The first arm must be 0."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:254
msgid "Each arm must cover a sequential segment, contiguously with other arms."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:256
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:259
msgid "Here's a match that implements that logic:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:264
msgid "\"you won!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:265
msgid "\"you can roll again!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "\"you lost...\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid "These restrictions are planned to be relaxed in future versions of Cairo."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid "**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid "**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a crate?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a "
"single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""

#: src/ch07-01-packages-and-crates.md:7
msgid "What is the crate root?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts "
"from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control "
"Scope”](./ch07-02-defining-modules-to-control-scope.md) section)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:11
msgid "What is a package?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code "
"into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr ""

#: src/ch07-01-packages-and-crates.md:15
msgid "Creating a Package with Scarb"
msgstr ""

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:23
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"`src/` is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""

#: src/ch07-01-packages-and-crates.md:33
msgid ""
"`lib.cairo` is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:34
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo` "
"files within the `src` directory or its subdirectories."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden;`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at "
"`backyard::garden::vegetables::Asparagus`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "Filename: src/garden.cairo"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is "
"included too. That code is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "Grouping Related Code in Modules"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. As an example, let’s write a library crate that provides the "
"functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, "
"rather than the implementation of a restaurant."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named `restaurant` by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid ""
"Listing 7-1: A `front_of_house` module containing other modules that then "
"contain functions"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 6-1—functions."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate `restaurant`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:36
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:37
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:40
msgid "// ✅ Compiles\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:39
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"Listing 7-3: Calling the `add_to_waitlist` function using absolute and "
"relative paths"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "Starting Relative Paths with `super`"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on "
"your project, and depends on whether you’re more likely to move item "
"definition code separately from or together with the code that uses the item."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid "Listing 7-4: Calling a function using a relative path starting with super"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the "
"`use` path all the way out to the `add_to_waitlist` function to achieve the "
"same result, as in Listing 7-7."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid ""
"Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, "
"which is unidiomatic"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 7-7 accomplish the same task, Listing 7-5 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-7 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-8 shows the "
"idiomatic way to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-9 shows how you can "
"rename an import with `as`:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid "// ArrayTrait was renamed to Arr\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"Listing 7-9: Renaming a trait when it’s brought into scope with the `as` "
"keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "Importing multiple items from the same module"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid "The general syntax for importing multiple items from the same module is:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid "Here is an example where we import three structures from the same module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189
#: src/ch08-02-traits-in-cairo.md:346 src/ch08-02-traits-in-cairo.md:350
#: src/ch08-02-traits-in-cairo.md:359
#: src/ch99-03-security-considerations.md:143
#: src/ch99-03-security-considerations.md:148
msgid "// ...\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "Re-exporting Names in Module Files"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid ""
"Listing 7-11: Making a name available for any code to use from a new scope "
"with `pub use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this "
"`use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "Using External Packages in Cairo with Scarb"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"The dependencies system is still a work in progress. You can check the "
"official "
"[documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-12. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file in Listing 7-13."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"Listing 7-12: Declaring the `front_of_house` module whose body will be in "
"_src/front_of_house.cairo_"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
msgid "Filename: src/front_of_house.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:46
msgid ""
"Listing 7-13: Definitions inside the `front_of_house` module in "
"_src/front_of_house.cairo_"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module "
"Tree”](ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html)"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may "
"have seen in other programming languages."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules, "
"and Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is public by default."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:1
msgid "Generic Types and Traits"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete type like `u32` or "
"`ContractAddress`."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums, "
"traits, implementations and methods! In this chapter we are going to take a "
"look at how to effectively use generic types with all of them."
msgstr ""

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""

#: src/ch08-01-generic-data-types.md:10
msgid "// Specify generic type T between the angulars\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:31
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main` "
"function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""

#: src/ch08-01-generic-data-types.md:51
msgid "Constraints for Generic Types"
msgstr ""

#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""

#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:58
msgid ""
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:62
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:66
msgid "// The index we will use to move through the list\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:69
msgid "// Iterate through the whole list storing the smallest\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:84
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:90
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we don't require to implement the `Drop` trait for `T` as well. Why it does "
"not compile then?"
msgstr ""

#: src/ch08-01-generic-data-types.md:92
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:112
msgid "Anonymous Generic Implementation Parameter (`+` operator)"
msgstr ""

#: src/ch08-01-generic-data-types.md:114
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""

#: src/ch08-01-generic-data-types.md:116
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""

#: src/ch08-01-generic-data-types.md:118
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr ""

#: src/ch08-01-generic-data-types.md:120
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:138
msgid "Structs"
msgstr ""

#: src/ch08-01-generic-data-types.md:140
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""

#: src/ch08-01-generic-data-types.md:154
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""

#: src/ch08-01-generic-data-types.md:168
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""

#: src/ch08-01-generic-data-types.md:170
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""

#: src/ch08-01-generic-data-types.md:184
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""

#: src/ch08-01-generic-data-types.md:188
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""

#: src/ch08-01-generic-data-types.md:197
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""

#: src/ch08-01-generic-data-types.md:199
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""

#: src/ch08-01-generic-data-types.md:208 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""

#: src/ch08-01-generic-data-types.md:210
msgid "Generic Methods"
msgstr ""

#: src/ch08-01-generic-data-types.md:212
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""

#: src/ch08-01-generic-data-types.md:236
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""

#: src/ch08-01-generic-data-types.md:238
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""

#: src/ch08-01-generic-data-types.md:245
msgid "/// Generic trait for wallets\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:256
msgid "/// Trait for wallets of type u128\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:277
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""

#: src/ch08-01-generic-data-types.md:279
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one "
"with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""

#: src/ch08-01-generic-data-types.md:288
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr ""

#: src/ch08-01-generic-data-types.md:291
msgid "// This does not compile!\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:304
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr ""

#: src/ch08-01-generic-data-types.md:322
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""

#: src/ch08-01-generic-data-types.md:336
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in "
"this chapter to demonstrate how traits can be used to define shared behavior "
"for generic types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:11
msgid "Defining a Trait"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:13
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:32
msgid "\"{:?} by {:?} ({:?})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the trait keyword and then the trait’s name, "
"which is `Summary` in this case."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:45
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray`. After the method signature, "
"instead of providing an implementation within curly brackets, we use a "
"semicolon."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:47
msgid ""
"Note: the `ByteArray` type is the type used to represent Strings in Cairo."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:49
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:51
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"`aggregator` that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance. By defining the `Summary` trait on generic type `T`, we can "
"implement the `summarize` method on any type we want to be able to summarize."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:70 src/ch08-02-traits-in-cairo.md:146
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:85 src/ch08-02-traits-in-cairo.md:161
#: src/ch08-02-traits-in-cairo.md:237
msgid "\"{}: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:95 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:96 src/ch08-02-traits-in-cairo.md:172
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:100 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:101 src/ch08-02-traits-in-cairo.md:177
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n"
" @Starknet and @StarkWareLtd are about long-term vision maximization.\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:180
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:106 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:107 src/ch08-02-traits-in-cairo.md:183
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"1 new tweet: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"A `Summary` trait that consists of the behavior provided by a `summarize` "
"method"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"Each generic type implementing this trait must provide its own custom "
"behavior for the body of the method. The compiler will enforce that any type "
"that has the Summary trait will have the method summarize defined with this "
"signature exactly."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:117
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:119
msgid "Implementing a Trait on a type"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:121
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The next "
"code snippet shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to "
"create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:189
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type, "
"we place the generic type name in the angle brackets after the trait name."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:194
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior "
"that we want the methods of the trait to have for the particular type."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:199
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:274
msgid ""
"Other crates that depend on the `aggregator` crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:304
msgid "Implementing a trait, without writing its declaration."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"You can write implementations directly without defining the corresponding "
"trait. This is made possible by using the `#[generate_trait]` attribute "
"within the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` "
"as a suffix to your trait name, as the compiler will create the trait by "
"adding a `Trait` suffix to the implementation name."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:325
msgid ""
"In the aforementioned code, there is no need to manually define the trait. "
"The compiler will automatically handle its definition, dynamically "
"generating and updating it as new functions are introduced."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:329
msgid "Managing and using external trait implementations"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:331
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In the code above we imported "
"`PrintTrait` from `debug` with `use core::debug::PrintTrait;` to use the "
"`print()` methods on supported types. All traits included in the prelude "
"don't need to be explicitly imported and are freely accessible."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:333
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules. If `CircleGeometry` "
"was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:336
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant implementation is required."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:340
msgid "// struct Circle { ... } and struct Rectangle { ... }\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:353
msgid "// Could be in a different file\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:366
msgid ""
"// Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and "
"impl?\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:373
msgid "To make it work, in addition to,"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not "
"need to import `RectangleGeometry`, as it is defined in the same module as "
"the imported trait, and thus is automatically resolved."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:3 src/ch09-01-how-to-write-tests.md:13
msgid "The Anatomy of a Test Function"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert!` "
"macro, and the `should_panic` attribute."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 5. To change "
"a function into a test function, add `#[test]` on the line before `fn`. When "
"you run your tests with the `scarb cairo-test` command, Scarb runs Cairo's "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:26
msgid ""
"In _lib.cairo_, let's remove the existing content and add a first test, as "
"shown in Listing 9-1."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:34 src/ch09-01-how-to-write-tests.md:68
#: src/ch09-01-how-to-write-tests.md:630 src/ch09-01-how-to-write-tests.md:668
#: src/ch09-02-test-organization.md:25
msgid "\"result is not 4\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:38
msgid "Listing 9-1: A test module and function"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:44
msgid ""
"The `scarb cairo-test` command runs all tests founds in our project, as "
"shown in Listing 9-2."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:54
msgid "Listing 9-2: The output from running a test"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"tests`. The next line shows the name of the test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. We also haven’t filtered the tests being run, so the end of the "
"summary shows `0 filtered out`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:72
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:87
msgid "\"Make this test fail\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:92
msgid "Listing 9-3: Adding a second test that will fail"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:104
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"in the _src/lib.cairo_ file."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:112
msgid "Checking Results with the `assert!` macro"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro a first argument that evaluates to a Boolean. If the value is `true`, "
"nothing happens and the test passes. If the value is `false`, the `assert!` "
"macro calls `panic()` to cause the test to fail with a message we defined as "
"the second argument. Using the `assert!` macro helps us check that our code "
"is functioning in the way we intend."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-13](ch05-03-method-syntax.md#multiple-impl-blocks), "
"we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert!` macro."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:137
msgid ""
"Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from "
"Chapter 5"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. In Listing 9-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8` "
"and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:176 src/ch09-01-how-to-write-tests.md:184
#: src/ch09-01-how-to-write-tests.md:241 src/ch09-01-how-to-write-tests.md:249
msgid "\"rectangle cannot hold\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:191
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle "
"can indeed hold a smaller rectangle"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:193
msgid ""
"Note that we’ve added two new lines inside the tests module: `use "
"super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a "
"regular module that follows the usual visibility rules. Because the tests "
"module is an inner module, we need to bring the code under test in the outer "
"module into the scope of the inner module."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:195
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:204
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:256
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns false:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:266
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:280
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:293
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:295
msgid "Testing Equality with the `assert_eq!` and `assert_ne!` Macros"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:297
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to "
"perform this test more conveniently. These macros compare two arguments for "
"equality or inequality, respectively. They’ll also print the two values if "
"the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:308
msgid ""
"In Listing 9-7, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using the `assert_eq!` macro."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:329
msgid "Listing 9-7: Testing the function `add_two` using the `assert_eq!` macro"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:332
msgid "Let’s check that it passes!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:341
msgid ""
"We pass `4` as the argument to `assert_eq!`, which is equal to the result of "
"calling `add_two(2)`. The line for this test is `test tests::it_adds_two ... "
"ok`, and the `ok` text indicates that our test passed!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:345
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:354
msgid "Run the tests again:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:356
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 359600)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:368
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells "
"use that the assertion that fails was `` \"assertion `left == right` "
"failed`` and the `left` and `right` value are printed on the next lines as "
"`left: left_value` and `right: right_value`. This helps us start debugging: "
"the `left` argument was `4` but the `right` argument, where we had "
"`add_two(2)`, was `5`. You can imagine that this would be especially helpful "
"when we have a lot of tests going on."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:375
msgid ""
"Note that in some languages and test frameworks, the parameters to equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(add_two(2), 4)`, which would result in the same "
"failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:383
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but the way in which the input is changed "
"depends on the day of the week that we run our tests, the best thing to "
"assert might be that the output of the function is not equal to the input."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:391
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators `==` and `!=`, respectively. When the assertions fail, these "
"macros print their arguments using debug formatting, which means the values "
"being compared must implement the `PartialEq` and `Debug` traits. All "
"primitive types and most of the core library types implement these traits. "
"For structs and enums that you define yourself, you’ll need to implement "
"`PartialEq` to assert equality of those types. You’ll also need to implement "
"`Debug` to print the values when the assertion fails. Because both traits "
"are derivable traits this is usually as straightforward as adding the "
"`#[derive(Drop, Debug, PartialEq)]` annotation to your struct or enum "
"definition. See Appendix C, [“Derivable "
"Traits”](./appendix-03-derivable-traits.md), for more details about these "
"and other derivable traits."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:405
msgid "Adding Custom Failure Messages"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:407
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in [Chapter 11 - "
"Macros](./ch11-02-macros.md#format-macro) in the `format!` section), so you "
"can pass a format string that contains `{}` placeholders and values to go in "
"those placeholders. Custom messages are useful for documenting what an "
"assertion means; when a test fails, you’ll have a better idea of what the "
"problem is with the code."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:415
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:426
msgid "\"Expected {}, got add_two(2)={}\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:431
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:433
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed: "
"Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:445
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:448
msgid "Checking for panics with `should_panic`"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:450
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type "
"in Listing 9-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:452
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:454
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:471 src/ch09-01-how-to-write-tests.md:516
msgid "\"Guess must be >= 1 and <= 100\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:490
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:492
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:501
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:526
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:537
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:539
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 9-9 where the new function "
"panics with different messages depending on whether the value is too small "
"or too large."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:558 src/ch09-01-how-to-write-tests.md:594
msgid "\"Guess must be >= 1\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:560 src/ch09-01-how-to-write-tests.md:573
#: src/ch09-01-how-to-write-tests.md:592
msgid "\"Guess must be <= 100\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:582
msgid ""
"Listing 9-9: Testing for a panic with a panic message containing the error "
"message string"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:584
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:586
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:602
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:614
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:616
msgid "Running Single Tests"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:618
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:620
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 9-10, and choose which ones to run."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:636
msgid "\"result is not 5\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:641
msgid "Listing 9-10: Two tests with two different names"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:643
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:652
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:654
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:656
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:658
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude "
"them, as shown here:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:673
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:678
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:688
msgid "The `expensive_test` function is listed as ignored."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:690
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:692
msgid "Testing recursive functions or loops"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:694
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark "
"the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute on the test function. The following "
"example shows how to use it:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:716
msgid "\"result is not 55\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:721
msgid "Benchmarking the gas usage of a specific operation"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:723
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:728 src/ch09-01-how-to-write-tests.md:755
msgid "/// code we want to bench.\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:729 src/ch09-01-how-to-write-tests.md:757
msgid "\"{}\\n\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:732
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:762
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the operation benchmarked."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:775
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation "
"of the hex number). The total amount consumed by the test is slightly higher "
"at 98030, due to some extra steps required to run the entire test function."
msgstr ""

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's "
"good practice to start organizing your code as if it were. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch09-02-test-organization.md:7
msgid "Unit Tests"
msgstr ""

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the "
"test functions and to annotate the module with `cfg(test)`."
msgstr ""

#: src/ch09-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library "
"and saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb "
"cairo-test`. This includes any helper functions that might be within this "
"module, in addition to the functions annotated with `#[test]`."
msgstr ""

#: src/ch09-02-test-organization.md:34
msgid "Integration Tests"
msgstr ""

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""

#: src/ch09-02-test-organization.md:38
msgid "The `tests` Directory"
msgstr ""

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:68
msgid ""
"Enter the code in Listing 9-11 into the _src/tests/integration_tests.cairo_ "
"file:"
msgstr ""

#: src/ch09-02-test-organization.md:75
msgid "\"internal_adder failed\""
msgstr ""

#: src/ch09-02-test-organization.md:79
msgid "Filename: src/tests/integration_tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:81
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""

#: src/ch09-02-test-organization.md:83
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr ""

#: src/ch09-02-test-organization.md:94
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr ""

#: src/ch10-00-error-handling.md:1
msgid "Error handling"
msgstr ""

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide "
"an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:18
#: src/ch10-01-unrecoverable-errors-with-panic.md:54
msgid "\"This line isn't reached\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:29
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a felt252 error message as an "
"argument, making the code more readable and maintainable."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid "Let's consider an example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "`panic!` macro"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code 2 shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as argument like `panic` function."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:52
msgid "\"2\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:58
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as parameter. For example, the "
"following line of code will successfully compile: "
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:61
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:64
msgid "nopanic notation"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:66
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:68
#: src/ch10-01-unrecoverable-errors-with-panic.md:103
#: src/appendix-03-derivable-traits.md:25
#: src/appendix-03-derivable-traits.md:50
#: src/appendix-03-derivable-traits.md:71
#: src/appendix-03-derivable-traits.md:93
#: src/appendix-03-derivable-traits.md:126
#: src/appendix-03-derivable-traits.md:163
msgid "Example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:76
msgid "Wrong example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:84
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:97
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:99
msgid "panic_with attribute"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:101
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:116
msgid "// this returns None\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:117
msgid "// this panics with 'value is 0'\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr ""

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""

#: src/ch10-02-recoverable-errors.md:7
msgid "The `Result` enum"
msgstr ""

#: src/ch10-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in "
"Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and "
"`Err`, as follows:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr ""

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language. These constraints indicate that the "
"associated functions require an implementation of the `Drop` trait for the "
"generic types `T` and `E`, respectively."
msgstr ""

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a snapshot to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation of the `ResultTrait` "
"[here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr ""

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr ""

#: src/ch10-02-recoverable-errors.md:81
msgid "Let's take another example demonstrating the use of `unwrap`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:92
msgid "Listing 10-1: Using the Result type"
msgstr ""

#: src/ch10-02-recoverable-errors.md:94
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries "
"to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns "
"`Result::Err('Invalid integer')`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:96
msgid "Our two test cases are:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:112
msgid "// should not panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:120
msgid "// should panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:128
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message 'Invalid integer'."
msgstr ""

#: src/ch10-02-recoverable-errors.md:130
msgid "The `?` operator"
msgstr ""

#: src/ch10-02-recoverable-errors.md:132
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:134
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""

#: src/ch10-02-recoverable-errors.md:135
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""

#: src/ch10-02-recoverable-errors.md:139
msgid "Here is an example."
msgstr ""

#: src/ch10-02-recoverable-errors.md:144 src/ch10-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:150
msgid "Listing 10-1: Using the `?` operator"
msgstr ""

#: src/ch10-02-recoverable-errors.md:152
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr ""

#: src/ch10-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr ""

#: src/ch10-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr ""

#: src/ch10-02-recoverable-errors.md:186
msgid "The console will print the error \"Invalid Integer\"."
msgstr ""

#: src/ch10-02-recoverable-errors.md:192
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""

#: src/ch10-02-recoverable-errors.md:194
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""

#: src/ch11-01-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr ""

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr ""

#: src/ch11-02-macros.md:5
msgid "`print!` and `println!` macros"
msgstr ""

#: src/ch11-02-macros.md:7
msgid "Two macros are available for printing values:"
msgstr ""

#: src/ch11-02-macros.md:8
msgid "`println!` which prints on a new line "
msgstr ""

#: src/ch11-02-macros.md:9
msgid "`print!` with inline printing"
msgstr ""

#: src/ch11-02-macros.md:11
msgid ""
"Both can be used with curly brackets as placeholders that hold a value in "
"place:"
msgstr ""

#: src/ch11-02-macros.md:12
msgid ""
"When printing the value of a variable, the variable name can go inside the "
"curly brackets."
msgstr ""

#: src/ch11-02-macros.md:13
msgid ""
"When printing the result of evaluating an expression, use empty curly "
"brackets in the format string, then follow the format string with a "
"comma-separated list of expressions to print in each empty curly bracket "
"placeholder in the same order."
msgstr ""

#: src/ch11-02-macros.md:15
msgid "`consteval_int!` macro"
msgstr ""

#: src/ch11-02-macros.md:17
msgid ""
"In some situations, a developer might need to declare a constant that is the "
"result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""

#: src/ch11-02-macros.md:19
msgid "Here is an example of `consteval_int!`:"
msgstr ""

#: src/ch11-02-macros.md:25
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr ""

#: src/ch11-02-macros.md:29
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr ""

#: src/ch11-02-macros.md:31
msgid "`panic!`, `assert!` and `assert_eq!` macros macro"
msgstr ""

#: src/ch11-02-macros.md:33
msgid ""
"See [Unrecoverable Errors with "
"panic](./ch10-01-unrecoverable-errors-with-panic.md) page."
msgstr ""

#: src/ch11-02-macros.md:35
msgid "`format!` macro"
msgstr ""

#: src/ch11-02-macros.md:37
msgid ""
"The `format!` macro works like `println!`, but instead of printing the "
"output to the screen, it returns a  `ByteArray` with the contents. In the "
"following example, we perform string concatenation using either the `+` "
"operator or the `format!` macro.  The version of the code using `format!` is "
"much easier to read, and the code generated by the `format!` macro uses "
"snapshots so that this call doesn’t take ownership of any of its parameters."
msgstr ""

#: src/ch11-02-macros.md:46 src/ch11-02-macros.md:52
msgid "\"tic\""
msgstr ""

#: src/ch11-02-macros.md:47 src/ch11-02-macros.md:53
msgid "\"tac\""
msgstr ""

#: src/ch11-02-macros.md:48 src/ch11-02-macros.md:54
msgid "\"toe\""
msgstr ""

#: src/ch11-02-macros.md:49 src/ch11-02-macros.md:49
msgid "\"-\""
msgstr ""

#: src/ch11-02-macros.md:50
msgid "// using + operator consumes the strings, so they can't be used again!\n"
msgstr ""

#: src/ch11-02-macros.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr ""

#: src/ch11-02-macros.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr ""

#: src/ch11-02-macros.md:57
msgid "\"{}-{}-{}\""
msgstr ""

#: src/ch11-02-macros.md:58 src/ch11-02-macros.md:77
msgid "\"{}\""
msgstr ""

#: src/ch11-02-macros.md:62
msgid "`write!` macro"
msgstr ""

#: src/ch11-02-macros.md:64
msgid ""
"The `write!` and `writeln!` are two macros which are used to emit the format "
"string to a specified stream. This macro takes 2 arguments:"
msgstr ""

#: src/ch11-02-macros.md:66
msgid ""
"a Formatter, which is a struct containing a `ByteArray`, representing the "
"pending result of formatting (the _stream_)"
msgstr ""

#: src/ch11-02-macros.md:67
msgid "the 'ByteArray' to append to the formatter"
msgstr ""

#: src/ch11-02-macros.md:69
msgid ""
"Calling this macro will append the provided `ByteArray` string to the "
"formatter. Example usage is:"
msgstr ""

#: src/ch11-02-macros.md:75
msgid "\"hello\""
msgstr ""

#: src/ch11-02-macros.md:76
msgid "\"world\""
msgstr ""

#: src/ch11-02-macros.md:77
msgid "// helloworld\n"
msgstr ""

#: src/ch11-03-hash.md:1
msgid "Hashes"
msgstr ""

#: src/ch11-03-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a "
"\"hash.\" This transformation is deterministic, meaning that the same input "
"will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography, and data "
"integrity verification - and are very often when developing smart contracts, "
"especially when working with Merkle trees."
msgstr ""

#: src/ch11-03-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively "
"in the Cairo library : `Poseidon` and `Pedersen`. We will discuss about when "
"and how to use them, and see examples with cairo programs."
msgstr ""

#: src/ch11-03-hash.md:7
msgid "Hash functions in Cairo"
msgstr ""

#: src/ch11-03-hash.md:9
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr ""

#: src/ch11-03-hash.md:11
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on elliptic "
"curve cryptography. These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of "
"the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr ""

#: src/ch11-03-hash.md:13
msgid ""
"Poseidon is a family of hash functions designed for being very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a "
"'sponge construction,' which soaks up data and transforms it securely using "
"a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three element state permutation with [specific "
"parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""

#: src/ch11-03-hash.md:15
msgid "When to use them ?"
msgstr ""

#: src/ch11-03-hash.md:17
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses "
"Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""

#: src/ch11-03-hash.md:21
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or a `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""

#: src/ch11-03-hash.md:23
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` that defines the "
"basic methods to work with hashes. They allow you to initialize a hash state "
"that will contain the temporary values of the hash after each application of "
"the hash function; update the hash state, and finalize it when the "
"computation is completed. `HashStateTrait` is defined as follows:"
msgstr ""

#: src/ch11-03-hash.md:26
msgid "/// A trait for hash state accumulators.\n"
msgstr ""

#: src/ch11-03-hash.md:32
msgid "/// A trait for values that can be hashed.\n"
msgstr ""

#: src/ch11-03-hash.md:35
msgid "/// Updates the hash state with the given value.\n"
msgstr ""

#: src/ch11-03-hash.md:40
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""

#: src/ch11-03-hash.md:42
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() "
"-> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""

#: src/ch11-03-hash.md:68
msgid ""
"As our struct derives the trait HashTrait, we can call the function as "
"follows for Poseidon hashing :"
msgstr ""

#: src/ch11-03-hash.md:92
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""

#: src/ch11-03-hash.md:94
msgid "Here is a short example for Pedersen hashing :"
msgstr ""

#: src/ch11-03-hash.md:111
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr ""

#: src/ch11-03-hash.md:124
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr ""

#: src/ch11-03-hash.md:133
msgid "Advanced Hashing: Hashing arrays with Poseidon"
msgstr ""

#: src/ch11-03-hash.md:135
msgid ""
"Let us look at an example of hashing a function that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function in poseidon ` "
"poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly you can "
"hash `Array<felt252>` by calling `poseidon_hash_span` on its span."
msgstr ""

#: src/ch11-03-hash.md:139
msgid "First let us import the following trait and function :"
msgstr ""

#: src/ch11-03-hash.md:147
msgid ""
"Now we define the structure, as you might have notice we didn't derived the "
"Hash trait. If you try to derive the Hash trait on this structure it will "
"rise an error because the structure contains a field not hashable."
msgstr ""

#: src/ch11-03-hash.md:160
msgid ""
"In this example, we initialized a HashState (`hash`) and updated it and then "
"called the function `finalize()` on the HashState to get the computed hash "
"`hash_felt252`. We used the `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts "
"for the Starknet network. Starknet is a permissionless network that "
"leverages zk-STARKs technology for scalability. As a Layer-2 scalability "
"solution for Ethereum, Starknet's goal is to offer fast, secure, and "
"low-cost transactions. It functions as a Validity Rollup (commonly known as "
"a zero-knowledge Rollup) and is built on top of the Cairo language and the "
"Starknet VM."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections. If you want to learn more about the "
"Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this "
"functionality, you'll need to make some configurations in your `Scarb.toml` "
"file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a "
"`[[target.starknet-contract]]` section to enable contract compilation."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:17
msgid ""
"Below is the minimal Scarb.toml file required to compile a crate containing "
"Starknet contracts:"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please "
"refer to the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts "
"are, what are they used for, and why would blockchain developers use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "Smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party software (called `oracles`) to access external data (the "
"price of a token for instance)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs "
"(Non-fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "Use cases"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "DeFi"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "Tokenization"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "Voting"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "Royalties"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "Decentralized identities DIDs"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "The rise of Starknet and Cairo"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain "
"Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-trilemma)) "
"in the blockchain space states that it is impossible to achieve a high level "
"of scalability, decentralization, and security simultaneously; trade-offs "
"must be made. Ethereum is at the intersection of decentralization and "
"security. Eventually, it was decided that Ethereum's purpose would be to "
"serve as a secure settlement layer, while complex computations would be "
"offloaded to other networks built on top of Ethereum. These are called Layer "
"2s (L2s)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium "
"[article](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), "
"which serves as a good primer."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/chapter_4/index.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/chapter_5/index.html)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a function `main` that serves as the entry point for this program:"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, "
"and as such, have access to Starknet's state. For a module to be handled as "
"a contract by the compiler, it must be annotated with the "
"`#[starknet::contract]` attribute."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an "
"example of a basic contract. You will learn how to write a simple contract "
"that stores a single number on the blockchain."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:5
msgid "Anatomy of a simple Starknet Contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet "
"contract. It might not be easy to understand it all at once, but we will go "
"through it step by step:"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:38
msgid "Listing 99-1: A simple storage contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:40
msgid ""
"Note: Starknet contracts are defined within "
"[modules](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:42
msgid "What is this contract?"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called "
"`stored_data` of type `u128` (unsigned integer of 128 bits). You can think "
"of it as a single slot in a database that you can query and alter by calling "
"functions of the code that manages the database. The contract defines and "
"exposes publicly the functions `set` and `get` that can be used to modify or "
"retrieve the value of that variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes "
"to the outside world. Here, the interface exposes two functions: `set` and "
"`get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) "
"mechanism from Cairo, we can make sure that the actual implementation of the "
"contract matches its interface. In fact, you will get a compilation error if "
"your contract doesn’t conform with the declared interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:70
msgid ""
"Listing 99-2: A wrong implementation of the interface of the contract. This "
"does not compile."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. The `self` "
"parameter represents the contract state. Seeing the `self` argument passed "
"to `set` tells us that this function might access the state of the contract, "
"as it is what gives us access to the contract’s storage. The `ref` modifier "
"implies that `self` may be modified, meaning that the storage variables of "
"the contract may be modified inside the `set` function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which "
"immediately tells us that it does not modify the state (and indeed, the "
"compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. In the example above, `set` and `get` are "
"public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the "
"example above, `set` and `get` are public functions."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked "
"through a transaction and that can mutate the state of the contract. `set` "
"is an external function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the "
"contract, but that cannot mutate the state of the contract. `get` is a view "
"function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the external functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. "
"The implementation block must be annotated with the `#[abi(embed_v0)]` "
"attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions "
"will not be callable from the outside. All functions defined in a block "
"marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter "
"corresponding to the `self` argument in the trait must be `ContractState`. "
"The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, "
"`ContractState` gives us the ability to emit events. The name "
"`ContractState` is not surprising, as it’s a representation of the "
"contract’s state, which is what we think of `self` in the contract interface "
"trait."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the "
"contract are defined under the implementation of a trait that has a "
"`TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` "
"parameter to the function, allowing access the storage variables of the "
"contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the "
"`read` and `write` methods to either read or write the value of the storage "
"variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:118
msgid ""
"Using `self` and the `write` method to modify the value of a storage variable"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, "
"attempting to modify will result in a compilation error."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a "
"single number that is accessible by anyone in the world. Anyone could call "
"`set` again with a different value and overwrite your number, but the number "
"is still stored in the history of the blockchain. Later, you will see how "
"you can impose access restrictions so that only you can alter the number."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we "
"specified the difference between _public functions, external functions and "
"view functions_, and we mentioned how to interact with _storage_."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid ""
"Where should I define functions that do not need to access the contract's "
"state?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the following example contract that we'll be using throughout this "
"chapter:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:93
#: src/ch99-01-03-01-contract-storage.md:83
#: src/ch99-01-03-01-contract-storage.md:208
#: src/ch99-01-03-01-contract-storage.md:322
#: src/ch99-01-03-01-contract-storage.md:434
#: src/ch99-01-03-01-contract-storage.md:546
#: src/ch99-01-03-01-contract-storage.md:656
#: src/ch99-01-03-01-contract-storage.md:774
#: src/ch99-01-03-01-contract-storage.md:884
#: src/ch99-01-03-02-contract-functions.md:82
#: src/ch99-01-03-04-reducing-boilerplate.md:7
msgid "// Could be a group of functions about a same topic\n"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:111
#: src/ch99-01-03-01-contract-storage.md:101
#: src/ch99-01-03-01-contract-storage.md:226
#: src/ch99-01-03-01-contract-storage.md:340
#: src/ch99-01-03-01-contract-storage.md:452
#: src/ch99-01-03-01-contract-storage.md:564
#: src/ch99-01-03-01-contract-storage.md:674
#: src/ch99-01-03-01-contract-storage.md:792
#: src/ch99-01-03-01-contract-storage.md:902
#: src/ch99-01-03-02-contract-functions.md:100
msgid "// Free functions\n"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:123
msgid "Listing 99-3: Our reference contract for this chapter"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"modified anytime once the contract is deployed."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:115
msgid "A Storage Struct"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:117
msgid ""
"The storage struct is a "
"[struct](./ch05-00-using-structs-to-structure-related-data.md) like any "
"other, except that it **must** be annotated with `#[storage]`. This "
"annotation tells the compiler to generate the required code to interact with "
"the blockchain state, and allows you to read and write data from and to "
"storage. Moreover, this allows you to define storage mappings using the "
"`LegacyMap` type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:120
msgid ""
"Each variable stored in the storage struct is stored in a different location "
"in the contract's storage. The storage address of a variable is determined "
"by the variable's name, and the eventual keys of the variable if it is a "
"[mapping](#storing-mappings)."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:122
msgid "Storage Addresses"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:124
msgid "The address of a storage variable is computed as follows:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:126
msgid ""
"If the variable is a single value (not a mapping), the address is the "
"`sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` "
"is Starknet's version of the Keccak256 hash function, whose output is "
"truncated to 250 bits."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:127
msgid ""
"If the variable is a [mapping](#storing-mappings), the address of the value "
"at key `k_1,...,k_n` is "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ is the "
"Pedersen hash and the final value is taken `mod (2^251) − 256`."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:128
msgid ""
"If it is a mapping to complex values (e.g., tuples or structs), then this "
"complex value lies in a continuous segment starting from the address "
"calculated in the previous point. Note that 256 field elements is the "
"current limitation on the maximal size of a complex storage value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:130
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:240
msgid "Interacting with Storage Variables"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:242
msgid ""
"Variables stored in the storage struct can be accessed and modified using "
"the `read` and `write` functions, and you can get their address in storage "
"using the `address` function. These functions are automatically generated by "
"the compiler for each storage variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:244
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:354
msgid "Calling the `read` function on the `owner` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:356
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:466
msgid "Calling the `read` function on the `names` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:468
msgid ""
"To write a value to a storage variable, we call the `write` function passing "
"in the eventual keys the value as arguments. As with the `read` function, "
"the number of arguments depends on the number of keys - here, we only pass "
"in the value to write to the `owner` variable as it is a simple variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:578
msgid "Calling the `write` function on the `owner` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:688
msgid "Calling the `write` function on the `names` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:690
msgid "Storing custom types"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:692
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used "
"to specify how a type should be stored in storage. In order for a type to be "
"stored in storage, it must implement the `Store` trait. Most types from the "
"core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ContractAddress`, etc. implement the `Store` trait and "
"can thus be stored without further action."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:694
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an "
"enum or a struct? In that case, you have to explicitly tell the compiler how "
"to store this type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:696
msgid ""
"In our example, we want to store a `Person` struct in storage, which is "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be achieved by simply adding a `#[derive(starknet::Store)]` attribute on top "
"of our struct definition."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:806
msgid ""
"Similarly, Enums can be written to storage if they implement the `Store` "
"trait, which can be trivially derived as long as all associated types "
"implement the `Store` trait."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:916
msgid "Structs storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:918
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. "
"The elements of the struct are stored in the same order as they are defined "
"in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [Storage "
"Addresses](#storage-addresses) and can be obtained by calling "
"`var.address()`, and subsequent elements are stored at addresses contiguous "
"to the first element. For example, the storage layout for the `owner` "
"variable of type `Person` will result in the following layout:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:922
msgid "Fields"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:922
#: src/ch99-01-03-01-contract-storage.md:933
msgid "Address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:924
msgid "name"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:924
msgid "owner.address()"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:925
msgid "address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:925
msgid "owner.address() +1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:927
msgid "Enums storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:929
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and an eventual associated values. This index starts at 0 "
"for the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, it's stored starting from "
"the address immediately following the base address. For example, suppose we "
"have the `RegistrationType` enum with the `finite` variant, which carries an "
"associated limit date. The storage layout would look like this:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:933
msgid "Element"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:935
msgid "Variant index (e.g. 1 for finite)"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:935
msgid "registration_type.address()"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:936
msgid "Associated limit date"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:936
msgid "registration_type.address() + 1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:938
msgid "Storage mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:940
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. The only way to remove a mapping is to set its value "
"to the default zero value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:943
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:955
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:958
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"one in Listing 99-4 like the popular `allowances` storage variable in the "
"ERC20 Standard which maps an `owner` and an allowed `spender` to its "
"`allowance` amount using multiple keys passed inside a tuple:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:967
msgid "Listing 99-4: Storing mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:969
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [Storage Addresses](#storage-addresses) "
"section. If the key of a mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the `Hash` trait, "
"which can be derived with the `#[derive(Hash)]` attribute. For example, if "
"you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:972
msgid ""
"Similarly, in the case of a nested mapping such as "
"`LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be "
"computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:974
msgid ""
"For more details about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables)"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in contracts:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:5
msgid "1. Constructors"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:7
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:24
msgid "2. Public functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They must be defined inside an implementation block annotated with "
"the `#[abi(embed_v0)]` attribute. This attribute means that all functions "
"embedded inside it are implementations of the Starknet interface, and "
"therefore entry points of the contract. It only affects the visibility "
"(public vs private/internal), but it doesn't inform us on the ability of "
"these functions to modify the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:47
msgid "External functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:49
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally. "
"External functions are _public_ functions where the `self: ContractState` is "
"passed as reference with the `ref` keyword, allowing you to modify the state "
"of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:59
msgid "View functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:61
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They "
"can be called by other contracts or externally. View functions are _public_ "
"functions where the `self: ContractState` is passed as snapshot, preventing "
"you from modifying the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"**Note:** It's important to note that both external and view functions are "
"public. To create an internal function in a contract, you will need to "
"define it outside of the implementation block annotated with the "
"`#[abi(embed_v0)]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:73
msgid "3. Private functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the "
"`#[abi(embed_v0)]` attribute are private functions (also called internal "
"functions). They can only be called from within the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:77
msgid ""
"They can be grouped in a dedicated impl block (e.g in components, to easily "
"import internal functions all at once in the embedding contracts) or just be "
"added as free functions inside the contract module. Note that these 2 "
"methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:111
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next "
"section](./ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:113
msgid "4. \\[abi(per_item)\\] attribute"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:115
msgid ""
"You can also define the entrypoint type of a function individually inside an "
"impl using the`#[abi(per_item)]` attribute on top of your impl. It is often "
"used with the `#[generate_trait]` attribute, as it allows you to define "
"entrypoints without an explicit interface. In this case, the functions will "
"not be grouped under an impl in the abi. Note that when using "
"`#[abi(per_item)]` attribute, public functions need to be annotated with "
"`#[external(v0)]` attribute - otherwise, they will not be exposed."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:117
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, "
"`l1-handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet "
"interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:119
msgid "Here is a short example:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:131
msgid "// this is a constructor function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:135
msgid "// this is a public function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:139
msgid "// this is a l1_handler function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:142
msgid "// this is an internal function\n"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:1 src/ch99-01-05-00-components.md:29
msgid "Events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract "
"could lead to a bad user experience. This is because users may not see their "
"NFTs appear in their wallets (wallets use these indexers to display a user's "
"NFTs)."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:9
msgid "Defining events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, "
"which implements the `starknet::Event` trait, as enum variants. This trait "
"is defined in the core library as follows:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the Event type, "
"which in our example is the following enum:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and "
"each variant needs to implement the `starknet::Event` trait itself. "
"Moreover, the members of these variants must implement the `Serde` trait "
"(_c.f._ [Appendix C: Serializing with "
"Serde](./appendix-03-derivable-traits.md)), as keys/data are added to the "
"event using a serialization process."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the Event trait for the variant’s type ."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with "
"the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:48
msgid "Emitting events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:50
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a "
"contract that didn't have any corresponding trait."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:26
msgid ""
"It's not the first time that we encounter this attribute, we already talked "
"about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this "
"section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:28
msgid ""
"In order to access the ContractState in a function in an implementation "
"block, this implementation block must be defined with a `ContractState` "
"generic parameter. This implies that we first need to define a generic trait "
"that takes a `TContractState`, and then implement this trait for the "
"`ContractState` type. But by using the `#[generate_trait]` attribute, this "
"whole process can be skipped and we can simply define the implementation "
"block directly, without any generic parameter, and use `self: ContractState` "
"in our functions."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:31
msgid ""
"If we had to manually define the trait for the `InternalFunctions` "
"implementation, it would look something like this:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"fewer storage slots. For example, consider a `Sizes` struct with 3 fields of "
"different types. The total size is 8 + 32 + 64 = 104 bits. This is less than "
"the 128 bits of a single `u128`. This means we can pack all 3 fields into a "
"single `u128` variable. Since a storage slot can hold up to 251 bits, our "
"packed value will take only one storage slot instead of 3."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:49
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:58
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:66
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by "
"performing bitshift and additions. The `unpack` reverses this process to "
"extract the original fields back into a struct."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the "
"operations performed in the example: The goal is to pack the `tiny`, "
"`small`, and `medium` fields into a single `u128` value. First, when packing:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. "
"This creates a `u128` value with the low 8 bits set to `tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the "
"value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we "
"add `tiny` to `small` to combine them into a single `u128` value. The value "
"of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits "
"(`TWO_POW_40`) to make space for the previous fields. This takes bits 40-103."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& "
"MASK_8`). This isolates the lowest 8 bits of the packed value, which is "
"`tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the "
"bitmask, then use bitwise AND with the 32 ones bitmask."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, "
"we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr ""

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr ""

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch99-01-05-00-components.md:30
msgid "External and internal functions"
msgstr ""

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr ""

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[Contracts](./ch99-01-02-a-simple-contract.md)."
msgstr ""

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the "
"[Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md) "
"pattern."
msgstr ""

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr ""

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr ""

#: src/ch99-01-05-00-components.md:168
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""

#: src/ch99-01-05-00-components.md:172
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:178
msgid "A closer look at the `impl` block"
msgstr ""

#: src/ch99-01-05-00-components.md:189
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""

#: src/ch99-01-05-00-components.md:194
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) "
"section."
msgstr ""

#: src/ch99-01-05-00-components.md:202
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""

#: src/ch99-01-05-00-components.md:208
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""

#: src/ch99-01-05-00-components.md:211
msgid "Migrating a Contract to a Component"
msgstr ""

#: src/ch99-01-05-00-components.md:213
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""

#: src/ch99-01-05-00-components.md:217
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr ""

#: src/ch99-01-05-00-components.md:218
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""

#: src/ch99-01-05-00-components.md:220
msgid "Adding generic parameters to the `impl` block:"
msgstr ""

#: src/ch99-01-05-00-components.md:221
msgid "Adding `TContractState` as a generic parameter."
msgstr ""

#: src/ch99-01-05-00-components.md:222
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr ""

#: src/ch99-01-05-00-components.md:223
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""

#: src/ch99-01-05-00-components.md:226
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""

#: src/ch99-01-05-00-components.md:231
msgid "Using components inside a contract"
msgstr ""

#: src/ch99-01-05-00-components.md:233
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""

#: src/ch99-01-05-00-components.md:237
msgid "Declare it with the `component!()` macro, specifying"
msgstr ""

#: src/ch99-01-05-00-components.md:239
msgid "The path to the component `path::to::component`."
msgstr ""

#: src/ch99-01-05-00-components.md:240
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""

#: src/ch99-01-05-00-components.md:242
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""

#: src/ch99-01-05-00-components.md:245
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""

#: src/ch99-01-05-00-components.md:250
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""

#: src/ch99-01-05-00-components.md:253
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""

#: src/ch99-01-05-00-components.md:258
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""

#: src/ch99-01-05-00-components.md:264
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""

#: src/ch99-01-05-00-components.md:302
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""

#: src/ch99-01-05-00-components.md:315
msgid "Stacking Components for Maximum Composability"
msgstr ""

#: src/ch99-01-05-00-components.md:317
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You will be able to "
"rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""

#: src/ch99-01-05-00-components.md:323
msgid ""
"Developers can focus on their core contract logic while relying on "
"battle-tested and audited components for everything else."
msgstr ""

#: src/ch99-01-05-00-components.md:326
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch99-01-05-01-components-under-the-hood)."
msgstr ""

#: src/ch99-01-05-00-components.md:331
msgid "Troubleshooting"
msgstr ""

#: src/ch99-01-05-00-components.md:333
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""

#: src/ch99-01-05-00-components.md:337
msgid "`Trait not found. Not a trait.`"
msgstr ""

#: src/ch99-01-05-00-components.md:339
msgid ""
"This error can occur when you're not importing the component's impl block "
"correctly in your contract. Make sure to respect the following syntax:"
msgstr ""

#: src/ch99-01-05-00-components.md:347
msgid "Referring to our previous example, this would be:"
msgstr ""

#: src/ch99-01-05-00-components.md:354
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`"
msgstr ""

#: src/ch99-01-05-00-components.md:357
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on "
"the action to take. Basically, you forgot to add the component's storage to "
"your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's "
"storage."
msgstr ""

#: src/ch99-01-05-00-components.md:362
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:`"
msgstr ""

#: src/ch99-01-05-00-components.md:365
msgid ""
"Similar to the previous error, the compiler, you forgot to add the "
"component's events to your contract's events. Make sure to add the path to "
"the component's events to your contract's events."
msgstr ""

#: src/ch99-01-05-00-components.md:369
msgid "Components functions are not accessible externally"
msgstr ""

#: src/ch99-01-05-00-components.md:371
msgid ""
"This can happen if you forgot to annotate the component's impl block with "
"`#[abi(embed_v0)]`. Make sure to add this annotation when embedding the "
"component's impl in your contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid "Before digging into components, we need to understand _embeddable impls_."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:75
msgid "// generated per component\n"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch99-01-05-02-component-dependencies.md) section."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "Contract Integration"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need "
"to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined as follows:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:32
msgid "Testing the component by deploying a mock contract"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:34
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:36
msgid "We can define such a mock contract as follows:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:59
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:61
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:71
msgid ""
"We can now write tests for the component by deploying this mock contract and "
"calling its entry points, as we would with a typical contract."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:102
msgid "Testing components without deploying a contract"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:104
msgid ""
"In [Components under the "
"hood](./ch99-01-05-01-components-under-the-hood.md), we saw that components "
"leveraged genericity to define storage and logic that could be embedded in "
"multiple contracts. If a contract embeds a component, a `HasComponent` trait "
"is created in this contract, and the component methods are made available."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:106
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:108
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need "
"to deploy it."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:110
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the "
"`MockContract::ContractState` type to do so."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:118
#: src/ch99-01-05-03-testing-components.md:162
msgid "// You can derive even `Default` on this type alias\n"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:139
msgid ""
"We defined the `TestingState` type as an alias of the "
"`CounterComponent::ComponentState<MockContract::ContractState>` type. By "
"passing the `MockContract::ContractState` type as a concrete type for "
"`ComponentState`, we aliased a concrete implementation of the "
"`ComponentState` struct to `TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:141
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:143
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:145
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:147
msgid "Let's summarize what we've done so far:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:149
msgid "We defined a mock contract that embeds the component we want to test."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:150
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:151
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:153
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "Listing 99-5: A simple ERC20 Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid ""
"Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 99-5)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:37
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "Listing 99-6: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "Listing 99-7: A sample contract which uses the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:157
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "Listing 99-8: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid "Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:207
msgid "Listing 99-9: A sample contract using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:209
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in IContractA, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:211
msgid "Using low-level syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:213
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system "
"calls. The dispatchers we described in the previous sections are high-level "
"syntaxes for these low-level system calls."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:215
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:253
msgid "\"transferFrom\""
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:263
msgid "Listing 99-10: A sample contract using syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:265
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call, and the call arguments."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:267
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to "
"deserialize ourselves!"
msgstr ""

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:14
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:16
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:20
msgid "/// @dev Function that returns the current vote status\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:22
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:26
msgid "/// @dev Function that allows a user to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:29
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:39
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:48
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:56
msgid "// Register all voters by calling the _register_voters function\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:59
msgid "// Initialize the vote count to 0\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:64
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:72
msgid "/// @dev Represents a vote that was cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:79
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:85
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:88
msgid "/// @dev Returns the voting results\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:95
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:100
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:105
msgid "/// @dev Submit a vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:107
msgid "\"VOTE_0_OR_1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:123
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:126
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:144
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:147
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:156
msgid "\"USER_NOT_REGISTERED\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:157
#: src/ch99-01-04-01-voting-contract.md:427
msgid "\"USER_ALREADY_VOTED\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:161
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:164
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:172
msgid "// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:191
msgid "Voting smart contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:195
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:197
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [Katana: A Local "
"Node](https://book.starknet.io/ch02-04-katana.html) chapter of the Starknet "
"Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md). "
"It will allow you to do everything you need to do with Starknet, but "
"locally. It is a great tool for development and testing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-installation.html#katana-node-installation) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:210
msgid ""
"Note: Please verify that the version of `katana` match the specified version "
"provided below."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:215
msgid ""
"To upgrade `katana`, refer to the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-installation.html#katana-node-installation) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:218
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:224
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:229
msgid "================="
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [Account "
"Abstraction](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Smart wallets for voting"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:249
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-installation.html#starkli-installation) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:251
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:256
msgid "To upgrade `starkli` to `1.0.20`, use the `starkliup -v 0.1.20` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:258
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the [Testnet "
"Deployment](https://book.starknet.io/ch02-05-testnet-deployment.html?highlight=signer#creating-a-signer) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:260
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:262
msgid "Firstly, we create a signer from a private key:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:268
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:274
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:278
#: src/ch99-01-04-01-voting-contract.md:281
#: src/ch99-01-04-01-voting-contract.md:388
msgid "\"version\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:279
msgid "\"variant\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:280
#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"type\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:280
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"public_key\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:284
msgid "\"deployment\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"status\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"deployed\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"class_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:292
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:294
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:298
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:304
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:306
msgid "Contract Deployment"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:308
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:314
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:316
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:318
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can find it [on any block "
"explorer](https://goerli.voyager.online/class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:320
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:322
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:324
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:330
msgid "An example command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:336
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:338
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:340
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:342
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:344
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:346
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:350
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:352
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:354
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:360
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:362
msgid "Casting a Vote"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:364
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:366
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:376
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "This returns:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"transaction_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"max_fee\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"0x430e81\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:388
#: src/ch99-01-04-01-voting-contract.md:397
#: src/ch99-01-04-01-voting-contract.md:401
#: src/ch99-01-04-01-voting-contract.md:402
#: src/ch99-01-04-01-voting-contract.md:403
msgid "\"0x1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:389
msgid "\"signature\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:390
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:391
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"nonce\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"0x3\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"INVOKE\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"sender_address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:396
msgid "\"calldata\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:398
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:399
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:400
msgid "\"0x0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:408
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:411
msgid "\"Contract error\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:414
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:418
msgid ""
"\"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:424
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:430
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:438
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:440
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:446
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "The StarknetMessaging Contract"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) "
"with functions allowing to send message to L2, receiving messages on L1 from "
"L2 and canceling messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid " Starknet messaging contract interface"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) "
"where we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check those addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:65
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:74
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:78
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be "
"executed by the sequencer is not bound to any account (the message "
"originates from L1), you must also ensure that you pay enough fees on L1 for "
"your message to be deserialized and processed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:112
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:113
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:123
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "Sending messages from Starknet to Ethereum"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:138
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:158
msgid "// You can use the message hash if you want here.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:160
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256 "
"in Solidity).\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:161
msgid "\"Invalid payload\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:165
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:166
msgid "\"Invalid value\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:170
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs "
"(the contract address on L2 and the payload) to ensure we are only consuming "
"valid messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract "
"is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "Cairo Serde"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a payload from L1 with **TWO** values."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:194
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid ""
"You can also find a [detailed guide "
"here](https://github.com/glihm/starknet-messaging-dev) to test the messaging "
"in local."
msgstr ""

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""

#: src/ch99-03-security-considerations.md:11
msgid "Disclaimer"
msgstr ""

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""

#: src/ch99-03-security-considerations.md:17
msgid "Mindset"
msgstr ""

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""

#: src/ch99-03-security-considerations.md:23
msgid "Viewing smart contract as Finite State Machines"
msgstr ""

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with "
"panic](./ch10-01-unrecoverable-errors-with-panic.md) page."
msgstr ""

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr ""

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr ""

#: src/ch99-03-security-considerations.md:34
msgid "Execution requirements"
msgstr ""

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr ""

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr ""

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""

#: src/ch99-03-security-considerations.md:45
msgid "\"Insufficient funds\""
msgstr ""

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""

#: src/ch99-03-security-considerations.md:53
msgid "Recommendations"
msgstr ""

#: src/ch99-03-security-considerations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr ""

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""

#: src/ch99-03-security-considerations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr ""

#: src/ch99-03-security-considerations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch99-03-security-considerations.md:67
msgid "Access control"
msgstr ""

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""

#: src/ch99-03-security-considerations.md:92
msgid "// Role 'owner': only one address\n"
msgstr ""

#: src/ch99-03-security-considerations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr ""

#: src/ch99-03-security-considerations.md:103
msgid "// Guard functions to check roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:118
msgid "\"Not owner\""
msgstr ""

#: src/ch99-03-security-considerations.md:123
msgid "\"Not role A\""
msgstr ""

#: src/ch99-03-security-considerations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""

#: src/ch99-03-security-considerations.md:128
msgid "\"Not allowed\""
msgstr ""

#: src/ch99-03-security-considerations.md:131
msgid "// Functions to manage roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""

#: src/ch99-03-security-considerations.md:155
msgid "Static analysis tool"
msgstr ""

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr ""

#: src/ch99-03-security-considerations.md:163
msgid ""
"[Semgrep Cairo 1.0 "
"support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"
msgstr ""

#: src/ch99-03-security-considerations.md:164
msgid "[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr ""

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`trait` - Define a trait"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
msgid "Reserved keywords"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "Built-in functions"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""

#: src/appendix-01-keywords.md:85
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates "
"to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B: Operators and Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "Table B-1: Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Operator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
#: src/appendix-02-operators-and-symbols.md:120
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:14
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Bitwise NOT"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
#: src/appendix-02-operators-and-symbols.md:40
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
#: src/appendix-02-operators-and-symbols.md:23
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`MulEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "Snapshot"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`*var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`Add`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`var += expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`AddEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr, expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
#: src/appendix-02-operators-and-symbols.md:28
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Neg`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`Sub`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`var -= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`SubEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`fn(...) -> type`, "
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "\\|...\\| -> type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr.ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "Member access"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`Div`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`var /= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "Arithmetic division and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`DivEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
#: src/appendix-02-operators-and-symbols.md:35
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`pat: type`, `ident: type`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:38
#: src/appendix-02-operators-and-symbols.md:42
#: src/appendix-02-operators-and-symbols.md:43
msgid "`PartialOrd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Less than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`var = expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "Equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "Greater than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "\\|\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "expr \\|\\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "`?`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "expr?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "Error propagation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:55
msgid "Table B-2: Stand-Alone Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "`..._u8`, `..._usize`, etc."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "Short string"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:63
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:65
msgid "Table B-3: Path-Related Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:73
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:75
msgid "Table B-4: Generics"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:86
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:88
msgid "Table B-5: Macros and Attributes"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid "Table B-6 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:96
msgid "Table B-6: Comments"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:104
msgid "Table B-7: Tuples"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:116
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:118
msgid "Table B-8: Curly Brackets"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:120
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "`struct` literal"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:9
msgid "Debug for Programmer Output"
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `Debug` trait allows you to print instances of a type for debugging "
"purposes, so you and other programmers using your type can inspect an "
"instance at a particular point in a program’s execution."
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid ""
"The `Debug` trait is required, for example, in use of the `assert_eq!` "
"macro. This macro prints the values of instances given as arguments if the "
"equality assertion fails so programmers can see why the two instances "
"weren’t equal."
msgstr ""

#: src/appendix-03-derivable-traits.md:17
msgid "PartialEq for equality comparison"
msgstr ""

#: src/appendix-03-derivable-traits.md:19
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:21
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:23
msgid ""
"The `PartialEq` trait is required, for example, with the use of the "
"`assert_eq!` macro, which needs to be able to compare two instances of a "
"type for equality."
msgstr ""

#: src/appendix-03-derivable-traits.md:44
msgid "Clone and Copy for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:46
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""

#: src/appendix-03-derivable-traits.md:48
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:69
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:85
msgid "// Copy Trait prevents firs_struct from moving into second_struct\n"
msgstr ""

#: src/appendix-03-derivable-traits.md:89
msgid "Serializing with Serde"
msgstr ""

#: src/appendix-03-derivable-traits.md:91
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""

#: src/appendix-03-derivable-traits.md:116
msgid "Output:"
msgstr ""

#: src/appendix-03-derivable-traits.md:119
msgid "''"
msgstr ""

#: src/appendix-03-derivable-traits.md:119
msgid "'c'"
msgstr ""

#: src/appendix-03-derivable-traits.md:122
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr ""

#: src/appendix-03-derivable-traits.md:124
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back "
"into our A struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid "Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:155
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:157
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` "
"[here](ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:159
msgid "Store"
msgstr ""

#: src/appendix-03-derivable-traits.md:161
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet "
"contract requires the `Store` trait to be implemented for this type. You can "
"automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""

#: src/appendix-03-derivable-traits.md:182
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the "
"Store trait. This `struct A` is subsequently used as a storage variable in "
"the contract."
msgstr ""

#: src/appendix-03-derivable-traits.md:185
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:187
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the "
"`PartialOrd` and `Ord` traits to compare values for ordering."
msgstr ""

#: src/appendix-03-derivable-traits.md:189
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for "
"ordering, thereby enabling the \\<, \\<=, >, and >= operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:191
msgid ""
"When `PartialOrd` is derived on structs, two instances are ordered by "
"comparing each field in turn."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:16
msgid "IDE Integration Using `cairo-language-server`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the "
"[`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language "
"Server Protocol](http://langserver.org/)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate "
"with each other. Different clients can use `cairo-language-server`, such as "
"[the Cairo extension for Visual Studio "
"Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, "
"jump to definition, and inline errors."
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"[lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.4.0/corelib/src/lib.cairo) "
"file of the corelib crate and contains Cairo's primitive data types, traits, "
"operators, and utility functions. This includes: Data types - felts, bools, "
"arrays, dicts, etc. Traits - behaviors for arithmetic, comparison, "
"serialization Operators - arithmetic, logical, bitwise Utility functions - "
"helpers for arrays, maps, boxing, etc. The core library prelude delivers the "
"fundamental programming constructs and operations needed for basic Cairo "
"programs, without requiring the explicit import of elements. Since the core "
"library prelude is automatically imported, its contents are available for "
"use in any Cairo crate without explicit imports. This prevents repetition "
"and provides a better devX. This is what allows you to use "
"`ArrayTrait::append()` or the `Default` trait without bringing them "
"explicitly into scope."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_10\"` in `Scarb.toml` configuration file will load the prelude from "
"October 2023, which is more restricted than the one from January 2023. The "
"compiler currently exposes 2 different versions of the prelude:"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:28
msgid ""
"A restricted version, including the most essential traits needed for general "
"cairo programming, corresponding to `edition = 2023_10`."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:30
msgid "List of common types and traits"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:32
msgid ""
"The following section provides a brief overview of commonly used types and "
"traits when developing Cairo programs. Most of these are included in the "
"prelude and not required to be imported explicitly - but not all of them."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Import"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Path"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Usage"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`core::option::OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`OptionTrait<T>` defines a set of methods required to manipulate optional "
"value."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`core::result::ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`ResultTrait<T, E>` Type for Starknet contract address, a value in the range "
"\\[0, 2 \\*\\* 251)."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of "
"`t:ContractAddress` is zero or not."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`starknet::contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid ""
"The `contract_address_const!` it's a function that allows instantiating "
"constant contract address values."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`Into`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an "
"implementation of Into\\<T,S> for the types T and S, you can convert T into "
"S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an "
"implementation of TryInto\\<T,S> for the types T and S, you can convert T "
"into S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`starknet::get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid ""
"`get_caller_address()` is a function that returns the address of the caller "
"of the contract. It can be used to identify the caller of a contract "
"function."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid ""
"`get_contract_address()` is a function that returns the address of the "
"current contract. It can be used to obtain the address of the contract being "
"executed."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:48
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr ""

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""

#: src/appendix-06-cairo-binaries.md:7
msgid "Prerequisites"
msgstr ""

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:12
msgid "# Install stable Rust\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:18
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:20
msgid "Install"
msgstr ""

#: src/appendix-06-cairo-binaries.md:22
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these "
"instructions](#set-up-your-shell-environment-for-cairo) to set up your shell "
"environment."
msgstr ""

#: src/appendix-06-cairo-binaries.md:30
msgid "Update"
msgstr ""

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:37
msgid "Uninstall"
msgstr ""

#: src/appendix-06-cairo-binaries.md:39
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:48
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:57
msgid "Set up your shell environment for Cairo"
msgstr ""

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/appendix-06-cairo-binaries.md:65
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:75
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:78 src/appendix-06-cairo-binaries.md:88
#: src/appendix-06-cairo-binaries.md:94 src/appendix-06-cairo-binaries.md:101
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:79 src/appendix-06-cairo-binaries.md:89
#: src/appendix-06-cairo-binaries.md:95 src/appendix-06-cairo-binaries.md:102
msgid ""
"'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent from Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""

#: src/appendix-06-cairo-binaries.md:129
msgid "Restart your shell"
msgstr ""

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr ""

#: src/appendix-06-cairo-binaries.md:134
msgid "\"$SHELL\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:137
msgid ""
"Installing Cairo Manually "
"([Guide](https://github.com/auditless/cairo-template) by "
"[Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:139
msgid "Step 1: Install Cairo 1.0"
msgstr ""

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:146
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:147
msgid "\"${HOME}/.cairo\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:148
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:151
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:154
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:157
msgid "# View tags (you can also do this in the cairo compiler repository)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:159
msgid "# Checkout the version you want\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:162
msgid "# Generate release binaries\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr ""

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:178
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr ""

#: src/appendix-06-cairo-binaries.md:181
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:184
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:186
msgid "Step 3: Setup Language Server"
msgstr ""

#: src/appendix-06-cairo-binaries.md:188
msgid "VS Code Extension"
msgstr ""

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:191
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""

#: src/appendix-06-cairo-binaries.md:192
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:194
msgid "Cairo Language Server without Scarb"
msgstr ""

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step "
"1](#installing-cairo-with-a-script-installer-by-fran), the "
"`cairo-language-server` binary should be built and executing this command "
"will copy its path into your clipboard."
msgstr ""

#: src/appendix-06-cairo-binaries.md:203
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""

#: src/appendix-07-system-calls.md:1
msgid "System Calls"
msgstr ""

#: src/appendix-07-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/)."
msgstr ""

#: src/appendix-07-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""

#: src/appendix-07-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""

#: src/appendix-07-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr ""

#: src/appendix-07-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr ""

#: src/appendix-07-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr ""

#: src/appendix-07-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr ""

#: src/appendix-07-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr ""

#: src/appendix-07-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr ""

#: src/appendix-07-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr ""

#: src/appendix-07-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr ""

#: src/appendix-07-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr ""

#: src/appendix-07-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr ""

#: src/appendix-07-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr ""

#: src/appendix-07-system-calls.md:22
msgid "`get_block_hash`"
msgstr ""

#: src/appendix-07-system-calls.md:24 src/appendix-07-system-calls.md:51
#: src/appendix-07-system-calls.md:79 src/appendix-07-system-calls.md:117
#: src/appendix-07-system-calls.md:153 src/appendix-07-system-calls.md:198
#: src/appendix-07-system-calls.md:230 src/appendix-07-system-calls.md:273
#: src/appendix-07-system-calls.md:305 src/appendix-07-system-calls.md:348
msgid "Syntax"
msgstr ""

#: src/appendix-07-system-calls.md:32 src/appendix-07-system-calls.md:59
#: src/appendix-07-system-calls.md:87 src/appendix-07-system-calls.md:128
#: src/appendix-07-system-calls.md:161 src/appendix-07-system-calls.md:206
#: src/appendix-07-system-calls.md:238 src/appendix-07-system-calls.md:281
#: src/appendix-07-system-calls.md:313 src/appendix-07-system-calls.md:356
msgid "Description"
msgstr ""

#: src/appendix-07-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""

#: src/appendix-07-system-calls.md:36 src/appendix-07-system-calls.md:69
#: src/appendix-07-system-calls.md:103 src/appendix-07-system-calls.md:139
#: src/appendix-07-system-calls.md:173 src/appendix-07-system-calls.md:220
#: src/appendix-07-system-calls.md:252 src/appendix-07-system-calls.md:295
#: src/appendix-07-system-calls.md:327 src/appendix-07-system-calls.md:372
msgid "Return values"
msgstr ""

#: src/appendix-07-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr ""

#: src/appendix-07-system-calls.md:40
msgid "Error messages"
msgstr ""

#: src/appendix-07-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr ""

#: src/appendix-07-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr ""

#: src/appendix-07-system-calls.md:45 src/appendix-07-system-calls.md:73
#: src/appendix-07-system-calls.md:107 src/appendix-07-system-calls.md:147
#: src/appendix-07-system-calls.md:192 src/appendix-07-system-calls.md:224
#: src/appendix-07-system-calls.md:267 src/appendix-07-system-calls.md:299
#: src/appendix-07-system-calls.md:342 src/appendix-07-system-calls.md:376
msgid "Common library"
msgstr ""

#: src/appendix-07-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)"
msgstr ""

#: src/appendix-07-system-calls.md:49
msgid "`get_execution_info`"
msgstr ""

#: src/appendix-07-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr ""

#: src/appendix-07-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr ""

#: src/appendix-07-system-calls.md:65 src/appendix-07-system-calls.md:97
#: src/appendix-07-system-calls.md:132 src/appendix-07-system-calls.md:167
#: src/appendix-07-system-calls.md:212 src/appendix-07-system-calls.md:246
#: src/appendix-07-system-calls.md:291 src/appendix-07-system-calls.md:321
#: src/appendix-07-system-calls.md:364
msgid "Arguments"
msgstr ""

#: src/appendix-07-system-calls.md:67 src/appendix-07-system-calls.md:175
#: src/appendix-07-system-calls.md:254 src/appendix-07-system-calls.md:297
#: src/appendix-07-system-calls.md:374
msgid "None."
msgstr ""

#: src/appendix-07-system-calls.md:71
msgid ""
"Returns a "
"[struct](https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) "
"containing the execution info."
msgstr ""

#: src/appendix-07-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"
msgstr ""

#: src/appendix-07-system-calls.md:77
msgid "`call_contract`"
msgstr ""

#: src/appendix-07-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call arguments."
msgstr ""

#: src/appendix-07-system-calls.md:91 src/appendix-07-system-calls.md:285
msgid "**Note:**"
msgstr ""

#: src/appendix-07-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr ""

#: src/appendix-07-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr ""

#: src/appendix-07-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr ""

#: src/appendix-07-system-calls.md:100
msgid "_`entry_point_selector`_: A selector for a function within that contract."
msgstr ""

#: src/appendix-07-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr ""

#: src/appendix-07-system-calls.md:105 src/appendix-07-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr ""

#: src/appendix-07-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"
msgstr ""

#: src/appendix-07-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""

#: src/appendix-07-system-calls.md:115
msgid "`deploy`"
msgstr ""

#: src/appendix-07-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr ""

#: src/appendix-07-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr ""

#: src/appendix-07-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender, used in the computation of the contract’s address."
msgstr ""

#: src/appendix-07-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr ""

#: src/appendix-07-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""

#: src/appendix-07-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr ""

#: src/appendix-07-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr ""

#: src/appendix-07-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of "
"type `Span::<felt252>`."
msgstr ""

#: src/appendix-07-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"
msgstr ""

#: src/appendix-07-system-calls.md:151
msgid "`emit_event`"
msgstr ""

#: src/appendix-07-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr ""

#: src/appendix-07-system-calls.md:165
msgid ""
"For more information, and for a higher-level syntax for emitting events, see "
"[Starknet "
"events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/)."
msgstr ""

#: src/appendix-07-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""

#: src/appendix-07-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr ""

#: src/appendix-07-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and "
"`deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""

#: src/appendix-07-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"
msgstr ""

#: src/appendix-07-system-calls.md:196
msgid "`library_call`"
msgstr ""

#: src/appendix-07-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr ""

#: src/appendix-07-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr ""

#: src/appendix-07-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr ""

#: src/appendix-07-system-calls.md:216
msgid "_`function_selector`_: A selector for a function within that class."
msgstr ""

#: src/appendix-07-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr ""

#: src/appendix-07-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"
msgstr ""

#: src/appendix-07-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr ""

#: src/appendix-07-system-calls.md:240
msgid "Sends a message to L1."
msgstr ""

#: src/appendix-07-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 once "
"the state update, including the transaction, is received."
msgstr ""

#: src/appendix-07-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging "
"mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/appendix-07-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr ""

#: src/appendix-07-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr ""

#: src/appendix-07-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr ""

#: src/appendix-07-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"
msgstr ""

#: src/appendix-07-system-calls.md:271
msgid "`replace_class`"
msgstr ""

#: src/appendix-07-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the "
"syscall is called) will be replaced by the class whose hash is given by the "
"class_hash argument."
msgstr ""

#: src/appendix-07-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr ""

#: src/appendix-07-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""

#: src/appendix-07-system-calls.md:293
msgid "_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr ""

#: src/appendix-07-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"
msgstr ""

#: src/appendix-07-system-calls.md:303
msgid "`storage_read`"
msgstr ""

#: src/appendix-07-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-07-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that "
"are defined explicitly in the contract."
msgstr ""

#: src/appendix-07-system-calls.md:319 src/appendix-07-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage "
"variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables)."
msgstr ""

#: src/appendix-07-system-calls.md:323 src/appendix-07-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""

#: src/appendix-07-system-calls.md:325 src/appendix-07-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr ""

#: src/appendix-07-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr ""

#: src/appendix-07-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"
msgstr ""

#: src/appendix-07-system-calls.md:346
msgid "`storage_write`"
msgstr ""

#: src/appendix-07-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-07-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables "
"that are defined explicitly in the contract."
msgstr ""

#: src/appendix-07-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr ""

#: src/appendix-07-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
msgstr ""
