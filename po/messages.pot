
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2023-10-13T15:22:19+02:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
#: src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr ""

#: src/SUMMARY.md:4
#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr ""

#: src/SUMMARY.md:5
#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:7
#: src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:11
#: src/ch01-01-installation.md:1
#: src/ch01-01-installation.md:19
msgid "Installation"
msgstr ""

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md:14
#: src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr ""

#: src/SUMMARY.md:17
#: src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr ""

#: src/SUMMARY.md:18
#: src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md:19
#: src/ch02-03-functions.md:1
msgid "Functions"
msgstr ""

#: src/SUMMARY.md:20
#: src/ch02-04-comments.md:1
msgid "Comments"
msgstr ""

#: src/SUMMARY.md:21
#: src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md:23
#: src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr ""

#: src/SUMMARY.md:26
#: src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr ""

#: src/SUMMARY.md:27
#: src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr ""

#: src/SUMMARY.md:29
msgid "Understanding Ownership"
msgstr ""

#: src/SUMMARY.md:32
msgid "What is Ownership?"
msgstr ""

#: src/SUMMARY.md:33
#: src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr ""

#: src/SUMMARY.md:35
#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr ""

#: src/SUMMARY.md:38
#: src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/SUMMARY.md:39
#: src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr ""

#: src/SUMMARY.md:40
#: src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr ""

#: src/SUMMARY.md:42
#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr ""

#: src/SUMMARY.md:42
#: src/ch06-01-enums.md:1
#: src/ch08-01-generic-data-types.md:163
msgid "Enums"
msgstr ""

#: src/SUMMARY.md:46
#: src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr ""

#: src/SUMMARY.md:48
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr ""

#: src/SUMMARY.md:52
#: src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr ""

#: src/SUMMARY.md:54
#: src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr ""

#: src/SUMMARY.md:55
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr ""

#: src/SUMMARY.md:57
#: src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr ""

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr ""

#: src/SUMMARY.md:63
#: src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr ""

#: src/SUMMARY.md:64
#: src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr ""

#: src/SUMMARY.md:66
#: src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr ""

#: src/SUMMARY.md:70
#: src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr ""

#: src/SUMMARY.md:71
#: src/ch09-02-test-organization.md:1
msgid "Testing Organization"
msgstr ""

#: src/SUMMARY.md:73
msgid "Error Handling"
msgstr ""

#: src/SUMMARY.md:76
#: src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr ""

#: src/SUMMARY.md:77
msgid "Recoverable Errors with Result"
msgstr ""

#: src/SUMMARY.md:79
#: src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr ""

#: src/SUMMARY.md:82
#: src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr ""

#: src/SUMMARY.md:83
#: src/ch11-02-macros.md:1
msgid "Macros"
msgstr ""

#: src/SUMMARY.md:87
#: src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md:89
#: src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr ""

#: src/SUMMARY.md:90
#: src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr ""

#: src/SUMMARY.md:91
#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr ""

#: src/SUMMARY.md:92
#: src/ch99-01-03-01-storage-variables.md:1
msgid "Storage Variables"
msgstr ""

#: src/SUMMARY.md:93
#: src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr ""

#: src/SUMMARY.md:94
msgid "Contract Events"
msgstr ""

#: src/SUMMARY.md:95
#: src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr ""

#: src/SUMMARY.md:96
msgid "Optimizing storage costs"
msgstr ""

#: src/SUMMARY.md:97
msgid "Components"
msgstr ""

#: src/SUMMARY.md:98
msgid "Under the hood"
msgstr ""

#: src/SUMMARY.md:99
#: src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr ""

#: src/SUMMARY.md:100
#: src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr ""

#: src/SUMMARY.md:101
msgid "ABIs and Cross-contract Interactions"
msgstr ""

#: src/SUMMARY.md:102
msgid "ABIs and Interfaces"
msgstr ""

#: src/SUMMARY.md:103
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr ""

#: src/SUMMARY.md:104
#: src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr ""

#: src/SUMMARY.md:105
#: src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr ""

#: src/SUMMARY.md:106
msgid "L1 <> L2 Messaging"
msgstr ""

#: src/SUMMARY.md:107
#: src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr ""

#: src/SUMMARY.md:109
#: src/appendix-00.md:1
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md:110
msgid "A - Keywords"
msgstr ""

#: src/SUMMARY.md:111
msgid "B - Operators and Symbols"
msgstr ""

#: src/SUMMARY.md:112
msgid "C - Derivable Traits"
msgstr ""

#: src/SUMMARY.md:113
msgid "D - Useful Development Tools"
msgstr ""

#: src/SUMMARY.md:114
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr ""

#: src/SUMMARY.md:115
msgid "F - Installing Cairo binaries"
msgstr ""

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its "
"[contributors](https://github.com/cairo-book/cairo-book.github.io). Special "
"thanks to [Starkware](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.2.0](https://github.com/starkware-libs/cairo/releases). See the "
"“Installation” section of Chapter 1 to install or update Cairo."
msgstr ""

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr ""

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr ""

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a more high level language. It first compiles to Sierra, an "
"intermediate representation of Cairo which will compile later down to a safe "
"subset of CASM. The point of Sierra is to ensure your CASM will always be "
"provable, even when the computation fails."
msgstr ""

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr ""

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr ""

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom "
"non-deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr ""

#: src/ch00-00-introduction.md:24
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr ""

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: "
"<https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""

#: src/ch00-00-introduction.md:26
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr ""

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr ""

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr ""

#: src/ch01-01-installation.md:17
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). You can simply run "
"the following command in your terminal, then follow the onscreen "
"instructions. This will install the latest stable release."
msgstr ""

#: src/ch01-01-installation.md:24
msgid ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:28
msgid ""
"Verify installation by running the following command in new terminal "
"session, it should print both Scarb and Cairo language versions, e.g:"
msgstr ""

#: src/ch01-01-installation.md:30
msgid ""
"```bash\n"
"$ scarb --version\n"
"scarb 2.3.0-rc1 (58cc88efb 2023-08-23)\n"
"cairo: 2.2.0 (https://crates.io/crates/cairo-lang-compiler/2.2.0)\n"
"sierra: 1.3.0\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:37
msgid "Installing the VSCode extension"
msgstr ""

#: src/ch01-01-installation.md:39
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1). "
"Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix "
"D](appendix-04-useful-development-tools.md) for more details."
msgstr ""

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr ""

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory and a directory for the “Hello, world!” project within the "
"_cairo_projects_ directory."
msgstr ""

#: src/ch01-02-hello-world.md:25
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""

#: src/ch01-02-hello-world.md:28
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:35
msgid "For Windows CMD, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:37
msgid ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\cairo_projects\"\n"
"> cd /d \"%USERPROFILE%\\cairo_projects\"\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:42
msgid "Creating a Project with Scarb"
msgstr ""

#: src/ch01-02-hello-world.md:44
msgid "Let’s create a new project using Scarb."
msgstr ""

#: src/ch01-02-hello-world.md:46
msgid ""
"Navigate to your projects directory (or wherever you decided to store your "
"code). Then run the following:"
msgstr ""

#: src/ch01-02-hello-world.md:52
msgid ""
"It creates a new directory and project called `hello_world`. We’ve named our "
"project `hello_world`, and Scarb creates its files in a directory of the "
"same name."
msgstr ""

#: src/ch01-02-hello-world.md:54
msgid ""
"Go into the `hello_world` directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"`Scarb.toml` file and a src directory with a `lib.cairo` file inside."
msgstr ""

#: src/ch01-02-hello-world.md:56
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""

#: src/ch01-02-hello-world.md:58
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--vcs` flag. Run `scarb new -help` to see the "
"available options."
msgstr ""

#: src/ch01-02-hello-world.md:61
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr ""

#: src/ch01-02-hello-world.md:63
#: src/ch01-02-hello-world.md:76
#: src/ch01-02-hello-world.md:96
#: src/ch01-02-hello-world.md:208
#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:77
#: src/ch02-01-variables-and-mutability.md:155
#: src/ch02-02-data-types.md:47
#: src/ch02-02-data-types.md:78
#: src/ch02-03-functions.md:167
#: src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58
#: src/ch02-05-control-flow.md:90
#: src/ch02-05-control-flow.md:130
#: src/ch04-01-what-is-ownership.md:50
#: src/ch04-01-what-is-ownership.md:252
#: src/ch04-01-what-is-ownership.md:280
#: src/ch04-01-what-is-ownership.md:294
#: src/ch04-01-what-is-ownership.md:334
#: src/ch04-01-what-is-ownership.md:347
#: src/ch04-01-what-is-ownership.md:363
#: src/ch04-02-references-and-snapshots.md:23
#: src/ch04-02-references-and-snapshots.md:134
#: src/ch04-02-references-and-snapshots.md:155
#: src/ch04-02-references-and-snapshots.md:199
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:19
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:44
#: src/ch05-01-defining-and-instantiating-structs.md:48
#: src/ch05-01-defining-and-instantiating-structs.md:76
#: src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:112
#: src/ch05-01-defining-and-instantiating-structs.md:120
#: src/ch05-01-defining-and-instantiating-structs.md:148
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:23
#: src/ch05-02-an-example-program-using-structs.md:48
#: src/ch05-02-an-example-program-using-structs.md:64
#: src/ch05-02-an-example-program-using-structs.md:74
#: src/ch05-02-an-example-program-using-structs.md:95
#: src/ch05-02-an-example-program-using-structs.md:103
#: src/ch05-02-an-example-program-using-structs.md:119
#: src/ch05-02-an-example-program-using-structs.md:136
#: src/ch05-02-an-example-program-using-structs.md:161
#: src/ch05-03-method-syntax.md:18
#: src/ch05-03-method-syntax.md:45
#: src/ch05-03-method-syntax.md:93
#: src/ch05-03-method-syntax.md:135
#: src/ch05-03-method-syntax.md:158
#: src/ch05-03-method-syntax.md:192
#: src/ch05-03-method-syntax.md:211
#: src/ch05-03-method-syntax.md:231
#: src/ch05-03-method-syntax.md:279
#: src/ch06-02-the-match-control-flow-construct.md:141
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:92
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-02-defining-modules-to-control-scope.md:150
#: src/ch07-02-defining-modules-to-control-scope.md:184
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch07-05-separating-modules-into-different-files.md:30
#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:46
#: src/ch07-05-separating-modules-into-different-files.md:66
#: src/ch07-05-separating-modules-into-different-files.md:75
#: src/ch09-01-how-to-write-tests.md:28
#: src/ch09-01-how-to-write-tests.md:38
#: src/ch09-01-how-to-write-tests.md:54
#: src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:92
#: src/ch09-01-how-to-write-tests.md:104
#: src/ch09-01-how-to-write-tests.md:118
#: src/ch09-01-how-to-write-tests.md:137
#: src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:192
#: src/ch09-01-how-to-write-tests.md:207
#: src/ch09-01-how-to-write-tests.md:305
#: src/ch09-01-how-to-write-tests.md:341
#: src/ch09-01-how-to-write-tests.md:394
#: src/ch09-01-how-to-write-tests.md:433
#: src/ch09-01-how-to-write-tests.md:489
#: src/ch09-01-how-to-write-tests.md:508
#: src/ch09-01-how-to-write-tests.md:527
#: src/ch09-01-how-to-write-tests.md:563
#: src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59
#: src/ch09-02-test-organization.md:66
#: src/ch09-02-test-organization.md:80
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
#: src/ch10-02-recoverable-errors.md:103
#: src/ch10-02-recoverable-errors.md:161
#: src/ch99-01-02-a-simple-contract.md:38
#: src/ch99-01-02-a-simple-contract.md:70
#: src/ch99-01-02-a-simple-contract.md:118
#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:95
#: src/ch99-01-03-01-storage-variables.md:19
#: src/ch99-01-03-01-storage-variables.md:61
#: src/ch99-01-03-01-storage-variables.md:79
#: src/ch99-01-03-01-storage-variables.md:91
#: src/ch99-01-03-05-optimizing-storage.md:75
#: src/ch99-02-01-abis-and-interfaces.md:55
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:208
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:252
#: src/ch99-01-04-01-voting-contract.md:191
#: src/ch99-04-00-L1-L2-messaging.md:49
#: src/appendix-02-operators-and-symbols.md:9
#: src/appendix-02-operators-and-symbols.md:53
#: src/appendix-02-operators-and-symbols.md:63
#: src/appendix-02-operators-and-symbols.md:73
#: src/appendix-02-operators-and-symbols.md:86
#: src/appendix-02-operators-and-symbols.md:94
#: src/appendix-02-operators-and-symbols.md:102
#: src/appendix-02-operators-and-symbols.md:117
msgid ""
msgstr ""

#: src/ch01-02-hello-world.md:63
msgid "Filename: Scarb.toml"
msgstr ""

#: src/ch01-02-hello-world.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at "
"https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of Scarb.toml generated by `scarb new`"
msgstr ""

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""

#: src/ch01-02-hello-world.md:82
msgid ""
"The next two lines set the configuration information Scarb needs to compile "
"your program: the name and the version of Scarb to use."
msgstr ""

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""

#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""

#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is `src/lib.cairo`, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""

#: src/ch01-02-hello-world.md:94
msgid ""
"Then create a new file called `src/hello_world.cairo` and put the following "
"code in it:"
msgstr ""

#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr ""

#: src/ch01-02-hello-world.md:105
msgid ""
"We have just created a file called `lib.cairo`, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file `hello_world.cairo`, containing the implementation details of the "
"`hello_world` module."
msgstr ""

#: src/ch01-02-hello-world.md:107
msgid ""
"Scarb requires your source files to be located within the `src` directory."
msgstr ""

#: src/ch01-02-hello-world.md:109
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""

#: src/ch01-02-hello-world.md:112
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the src directory "
"and create an appropriate `Scarb.toml` file."
msgstr ""

#: src/ch01-02-hello-world.md:114
msgid "Building a Scarb Project"
msgstr ""

#: src/ch01-02-hello-world.md:116
msgid ""
"From your `hello_world` directory, build your project by entering the "
"following command:"
msgstr ""

#: src/ch01-02-hello-world.md:118
msgid ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_world v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:124
msgid ""
"This command creates a `sierra` file in `target/dev`, let's ignore the "
"`sierra` file for now."
msgstr ""

#: src/ch01-02-hello-world.md:126
msgid ""
"If you have installed Cairo correctly, you should be able to run and see the "
"following output:"
msgstr ""

#: src/ch01-02-hello-world.md:136
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to the terminal."
msgstr ""

#: src/ch01-02-hello-world.md:139
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer—welcome!"
msgstr ""

#: src/ch01-02-hello-world.md:142
msgid "Anatomy of a Cairo Program"
msgstr ""

#: src/ch01-02-hello-world.md:144
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""

#: src/ch01-02-hello-world.md:153
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""

#: src/ch01-02-hello-world.md:158
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""

#: src/ch01-02-hello-world.md:162
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"D](appendix-04-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""

#: src/ch01-02-hello-world.md:169
msgid ""
"Prior to the main function declaration, The line `use debug::PrintTrait;` is "
"responsible for importing an item defined in another module. In this case, "
"we are importing the `PrintTrait` item from the Cairo core library. By doing "
"so, we gain the ability to use the `print()` method on data types that are "
"compatible with printing."
msgstr ""

#: src/ch01-02-hello-world.md:171
msgid "The body of the `main` function holds the following code:"
msgstr ""

#: src/ch01-02-hello-world.md:177
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""

#: src/ch01-02-hello-world.md:180
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""

#: src/ch01-02-hello-world.md:182
msgid ""
"Second, the `print()` function called is a method from the trait "
"`PrintTrait`. This trait is imported from the Cairo core library, and it "
"defines how to print values to the screen for different data types. In our "
"case, our text is defined as a \"short string\", which is an ASCII string "
"that can fit in Cairo's basic data type, which is the `felt252` type. By "
"calling `Hello, world!'.print()`, we're calling the `print()` method of the "
"`felt252` implementation of the `PrintTrait` trait."
msgstr ""

#: src/ch01-02-hello-world.md:184
msgid ""
"Third, you see the `'Hello, World!'` short string. We pass this short string "
"as an argument to `print()`, and the short string is printed to the screen."
msgstr ""

#: src/ch01-02-hello-world.md:187
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""

#: src/ch01-02-hello-world.md:193
msgid "Running tests"
msgstr ""

#: src/ch01-02-hello-world.md:195
msgid ""
"To run all the tests associated with a particular package, you can use the "
"`scarb test` command. It is not a test runner by itself, but rather "
"delegates work to a testing solution of choice. Scarb comes with "
"preinstalled `scarb cairo-test` extension, which bundles Cairo's native test "
"runner. It is the default test runner used by scarb test. To use third-party "
"test runners, please refer to [Scarb's "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/testing.html#using-third-party-test-runners)."
msgstr ""

#: src/ch01-02-hello-world.md:199
msgid ""
"Test functions are marked with the `#[test]` attributes, and running `scarb "
"test` will run all test functions in your codebase under the `src/` "
"directory."
msgstr ""

#: src/ch01-02-hello-world.md:208
msgid " A sample Scarb project structure"
msgstr ""

#: src/ch01-02-hello-world.md:210
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr ""

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr ""

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""

#: src/ch01-02-hello-world.md:214
msgid ""
"We can define custom scripts in `Scarb.toml` and call them with the `scarb "
"run` command."
msgstr ""

#: src/ch01-02-hello-world.md:215
msgid "We can run tests using the `scarb test` command."
msgstr ""

#: src/ch01-02-hello-world.md:217
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""

#: src/ch01-02-hello-world.md:220
#: src/ch02-05-control-flow.md:242
#: src/ch03-02-dictionaries.md:528
#: src/ch05-03-method-syntax.md:286
#: src/ch07-05-separating-modules-into-different-files.md:98
#: src/ch10-02-recoverable-errors.md:202
msgid "Summary"
msgstr ""

#: src/ch01-02-hello-world.md:222
msgid ""
"You’re already off to a great start on your Cairo journey! In this chapter, "
"you’ve learned how to:"
msgstr ""

#: src/ch01-02-hello-world.md:224
msgid "Install the latest stable version of Cairo"
msgstr ""

#: src/ch01-02-hello-world.md:225
msgid "Write and run a “Hello, Scarb!” program using `scarb` directly"
msgstr ""

#: src/ch01-02-hello-world.md:226
msgid "Create and run a new project using the conventions of Scarb"
msgstr ""

#: src/ch01-02-hello-world.md:227
msgid "Execute tests using the `scarb test` command"
msgstr ""

#: src/ch01-02-hello-world.md:229
msgid ""
"This is a great time to build a more substantial program to get used to "
"reading and writing Cairo code."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:77
#: src/ch02-01-variables-and-mutability.md:155
#: src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58
#: src/ch02-05-control-flow.md:90
#: src/ch02-05-control-flow.md:130
#: src/ch04-01-what-is-ownership.md:252
#: src/ch04-01-what-is-ownership.md:294
#: src/ch04-01-what-is-ownership.md:347
#: src/ch04-02-references-and-snapshots.md:23
#: src/ch04-02-references-and-snapshots.md:134
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:48
#: src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:120
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:48
#: src/ch05-02-an-example-program-using-structs.md:74
#: src/ch05-02-an-example-program-using-structs.md:103
#: src/ch05-02-an-example-program-using-structs.md:136
#: src/ch05-03-method-syntax.md:18
#: src/ch05-03-method-syntax.md:93
#: src/ch05-03-method-syntax.md:135
#: src/ch05-03-method-syntax.md:192
#: src/ch05-03-method-syntax.md:231
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-how-to-write-tests.md:28
#: src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:118
#: src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:207
#: src/ch09-01-how-to-write-tests.md:305
#: src/ch09-01-how-to-write-tests.md:394
#: src/ch09-01-how-to-write-tests.md:489
#: src/ch09-01-how-to-write-tests.md:527
#: src/ch09-01-how-to-write-tests.md:563
#: src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but really they only mean your program "
"isn’t safely doing what you want it to do yet; they do _not_ mean that "
"you’re not a good programmer! Experienced Caironautes still get compiler "
"errors."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_. The Cairo compiler guarantees that when you state that a value "
"won’t change, it really won’t change, so you don’t have to keep track of it "
"yourself. Your code is thus easier to reason through."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing this variable’s value."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:67
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that Cairo's memory is immutable, but the "
"memory address the variable points to can be changed. Upon examining the "
"low-level Cairo Assembly code, it becomes clear that variable mutation is "
"implemented as syntactic sugar, which translates mutation operations into a "
"series of steps equivalent to variable shadowing. The only difference is "
"that at the Cairo level, the variable is not redeclared so its type cannot "
"change."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:75
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:89
msgid "When we run the program now, we get this:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:100
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:104
msgid "Constants"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:106
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:110
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:117
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"The last difference is that constants may be set only to a constant "
"expression, not the result of a value that could only be computed at "
"runtime. Only literal constants are currently supported."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:124
msgid "Here’s an example of a constant declaration:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:144
msgid "Shadowing"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:146
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:172
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:194
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:200
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:208
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x: u64 = 2;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is "
"required.\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:219
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:235
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:237
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: "
"\"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:247
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr ""

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr ""

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr ""

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range `0 <= x < P`, where `P` is a very large prime number currently equal "
"to `P = 2^{251} + 17 * 2^{192}+1`. When adding, subtracting, or multiplying, "
"if the result falls outside the specified range of the prime number, an "
"overflow occurs, and an appropriate multiple of P is added or subtracted to "
"bring the result back within the range (i.e., the result is computed modulo "
"P)."
msgstr ""

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division `x / y` is defined as "
"`[x/y]` where the integer part of the quotient is returned (so you get `7 / "
"3 = 2`) and it may or may not satisfy the equation `(x / y) * y == x`, "
"depending on the divisibility of `x` by `y`."
msgstr ""

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation `(x "
"/ y) * y == x`. If y divides x as integers, you will get the expected result "
"in Cairo (for example `6 / 2` will indeed result in `3`). But when y does "
"not divide x, you may get a surprising result: For example, since `2 * "
"((P+1)/2) = P+1 ≡ 1 mod[P]`, the value of `1 / 2` in Cairo is `(P+1)/2` (and "
"not 0 or 0.5), as it satisfies the above equation."
msgstr ""

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr ""

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow checks. By using these integer types, programmers can ensure "
"that their programs are more secure and less susceptible to attacks or other "
"security threats. An _integer_ is a number without a fractional component. "
"This type declaration indicates the number of bits the programmer can use to "
"store the integer. Table 3-1 shows the built-in integer types in Cairo. We "
"can use any of these variants to declare the type of an integer value."
msgstr ""

#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr ""

#: src/ch02-02-data-types.md:53
#: src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr ""

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr ""

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr ""

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`"
msgstr ""

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type."
msgstr ""

#: src/ch02-02-data-types.md:78
msgid "Table 3-2: Integer Literals in Cairo"
msgstr ""

#: src/ch02-02-data-types.md:80
msgid "Numeric literals"
msgstr ""

#: src/ch02-02-data-types.md:80
#: src/appendix-02-operators-and-symbols.md:11
msgid "Example"
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""

#: src/ch02-02-data-types.md:90
msgid "Numeric Operations"
msgstr ""

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""

#: src/ch02-02-data-types.md:97
msgid ""
"```rust\n"
"fn main() {\n"
"    // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""

#: src/ch02-02-data-types.md:120
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list "
"of all operators that Cairo provides."
msgstr ""

#: src/ch02-02-data-types.md:122
msgid "The Boolean Type"
msgstr ""

#: src/ch02-02-data-types.md:124
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one felt252 in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""

#: src/ch02-02-data-types.md:128
msgid ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:136
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control "
"Flow”](ch02-05-control-flow.md) section."
msgstr ""

#: src/ch02-02-data-types.md:140
msgid "The Short String Type"
msgstr ""

#: src/ch02-02-data-types.md:142
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples "
"of declaring values by putting them between single quotes:"
msgstr ""

#: src/ch02-02-data-types.md:152
msgid "Type casting"
msgstr ""

#: src/ch02-02-data-types.md:154
msgid ""
"In Cairo, you can convert types scalar types from one type to another by "
"using the `try_into` and `into` methods provided by the `TryInto` and `Into` "
"traits, respectively."
msgstr ""

#: src/ch02-02-data-types.md:156
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""

#: src/ch02-02-data-types.md:158
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""

#: src/ch02-02-data-types.md:160
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""

#: src/ch02-02-data-types.md:162
msgid ""
"```rust\n"
"fn main() {\n"
"    let my_felt252 = 10;\n"
"    // Since a felt252 might not fit in a u8, we need to unwrap the "
"Option<T> type\n"
"    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
"    let my_u16: u16 = my_u8.into();\n"
"    let my_u32: u32 = my_u16.into();\n"
"    let my_u64: u64 = my_u32.into();\n"
"    let my_u128: u128 = my_u64.into();\n"
"    // As a felt252 is smaller than a u256, we can use the into() method\n"
"    let my_u256: u256 = my_felt252.into();\n"
"    let my_usize: usize = my_felt252.try_into().unwrap();\n"
"    let my_other_felt252: felt252 = my_u8.into();\n"
"    let my_third_felt252: felt252 = my_u16.into();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:179
msgid "The Tuple Type"
msgstr ""

#: src/ch02-02-data-types.md:181
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""

#: src/ch02-02-data-types.md:185
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""

#: src/ch02-02-data-types.md:196
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""

#: src/ch02-02-data-types.md:213
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"six` as the value of `y` is `6`."
msgstr ""

#: src/ch02-02-data-types.md:219
msgid ""
"We can also declare the tuple with value and types at the same time. For "
"example:"
msgstr ""

#: src/ch02-02-data-types.md:228
msgid "The unit type ()"
msgstr ""

#: src/ch02-02-data-types.md:230
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""

#: src/ch02-03-functions.md:25
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""

#: src/ch02-03-functions.md:29
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""

#: src/ch02-03-functions.md:36
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""

#: src/ch02-03-functions.md:46
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""

#: src/ch02-03-functions.md:50
msgid "Parameters"
msgstr ""

#: src/ch02-03-functions.md:52
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""

#: src/ch02-03-functions.md:60
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch02-03-functions.md:74
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch02-03-functions.md:81
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `.print()` function outputs `5` in the console."
msgstr ""

#: src/ch02-03-functions.md:85
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""

#: src/ch02-03-functions.md:91
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""

#: src/ch02-03-functions.md:107
msgid ""
"This example creates a function named `another_function` with two "
"parameters. The first parameter is named `x` and is an `felt252`. The second "
"is named `y` and is type `felt252` too. The function then prints the content "
"of the felt `x` and then the content of the felt `y`."
msgstr ""

#: src/ch02-03-functions.md:111
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""

#: src/ch02-03-functions.md:120
msgid ""
"Because we called the function with `5` as the value for `x` and `6` as the "
"value for `y`, the program output contains those values."
msgstr ""

#: src/ch02-03-functions.md:123
msgid "Named parameters"
msgstr ""

#: src/ch02-03-functions.md:125
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and "
"self-descriptive. If you want to use named parameters, you need to specify "
"the name of the parameter and the value you want to pass to it. The syntax "
"is `parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""

#: src/ch02-03-functions.md:128
msgid "Here is an example:"
msgstr ""

#: src/ch02-03-functions.md:143
msgid "Statements and Expressions"
msgstr ""

#: src/ch02-03-functions.md:145
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""

#: src/ch02-03-functions.md:153
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr ""

#: src/ch02-03-functions.md:155
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""

#: src/ch02-03-functions.md:157
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""

#: src/ch02-03-functions.md:167
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr ""

#: src/ch02-03-functions.md:169
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""

#: src/ch02-03-functions.md:172
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""

#: src/ch02-03-functions.md:181
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""

#: src/ch02-03-functions.md:205
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""

#: src/ch02-03-functions.md:211
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`. Calling a function is an "
"expression. A new scope block created with curly brackets is an expression, "
"for example:"
msgstr ""

#: src/ch02-03-functions.md:231
msgid "This expression:"
msgstr ""

#: src/ch02-03-functions.md:240
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""

#: src/ch02-03-functions.md:248
msgid "Functions with Return Values"
msgstr ""

#: src/ch02-03-functions.md:250
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""

#: src/ch02-03-functions.md:271
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in "
"Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""

#: src/ch02-03-functions.md:281
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""

#: src/ch02-03-functions.md:291
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""

#: src/ch02-03-functions.md:310
msgid ""
"Running this code will print `[DEBUG]                    (raw: 6)`. But if "
"we place a semicolon at the end of the line containing `x + 1`, changing it "
"from an expression to a statement, we’ll get an error:"
msgstr ""

#: src/ch02-03-functions.md:328
msgid "Compiling this code produces an error, as follows:"
msgstr ""

#: src/ch02-03-functions.md:330
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:334
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using "
"comments. To create a comment, use the // syntax, after which any text on "
"the same line will be ignored by the compiler."
msgstr ""

#: src/ch02-04-comments.md:5
msgid ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr ""

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:36
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""

#: src/ch02-05-control-flow.md:47
msgid ""
"It’s also worth noting that the condition in this code must be a bool. If "
"the condition isn’t a bool, we’ll get an error."
msgstr ""

#: src/ch02-05-control-flow.md:54
msgid "Handling Multiple Conditions with `else if`"
msgstr ""

#: src/ch02-05-control-flow.md:56
msgid ""
"You can use multiple conditions by combining if and else in an else if "
"expression. For example:"
msgstr ""

#: src/ch02-05-control-flow.md:78
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1'.print()`, nor do we see the `number not found` text "
"from the `else` block. That’s because Cairo only executes the block for the "
"first true condition, and once it finds one, it doesn’t even check the rest. "
"Using too many `else if` expressions can clutter your code, so if you have "
"more than one, you might want to refactor your code. [Chapter "
"6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo "
"branching construct called `match` for these cases."
msgstr ""

#: src/ch02-05-control-flow.md:86
msgid "Using `if` in a `let` statement"
msgstr ""

#: src/ch02-05-control-flow.md:88
msgid ""
"Because if is an expression, we can use it on the right side of a let "
"statement to assign the outcome to a variable."
msgstr ""

#: src/ch02-05-control-flow.md:114
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression. Which will be 5 here."
msgstr ""

#: src/ch02-05-control-flow.md:116
msgid "Repetition with Loops"
msgstr ""

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called loops."
msgstr ""

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr ""

#: src/ch02-05-control-flow.md:122
msgid "Repeating Code with `loop`"
msgstr ""

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""

#: src/ch02-05-control-flow.md:127
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until we stop the program manually, because the stop condition "
"is never reached. While the compiler prevents us from writing programs "
"without a stop condition (`break` statement), the stop condition might never "
"be reached, resulting in an infinite loop. Most terminals support the "
"keyboard shortcut "
msgstr ""

#: src/ch02-05-control-flow.md:149
msgid "ctrl-c"
msgstr ""

#: src/ch02-05-control-flow.md:149
msgid " to interrupt a program that is stuck in a continual loop. Give it a try:"
msgstr ""

#: src/ch02-05-control-flow.md:166
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurements that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In this case, the program panicked because it ran out of gas, as the stop "
"condition was never reached. It is particularly important in the context of "
"smart contracts deployed on Starknet, as it prevents from running infinite "
"loops on the network. If you're writing a program that needs to run a loop, "
"you will need to execute it with the `--available-gas` flag set to a value "
"that is large enough to run the program."
msgstr ""

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break` statement within the loop "
"to tell the program when to stop executing the loop. Let's fix the infinite "
"loop by adding a making the stop condition `i > 10` reachable."
msgstr ""

#: src/ch02-05-control-flow.md:187
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""

#: src/ch02-05-control-flow.md:207
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""

#: src/ch02-05-control-flow.md:209
msgid "Returning Values from Loops"
msgstr ""

#: src/ch02-05-control-flow.md:211
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""

#: src/ch02-05-control-flow.md:235
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""

#: src/ch02-05-control-flow.md:244
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""

#: src/ch02-05-control-flow.md:248
msgid "Generate the _n_\\-th Fibonacci number."
msgstr ""

#: src/ch02-05-control-flow.md:249
msgid "Compute the factorial of a number _n_."
msgstr ""

#: src/ch02-05-control-flow.md:251
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by importing the `array::ArrayTrait` trait."
msgstr ""

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modifications "
"options. Arrays are, in fact, queues whose values can't be modified. This "
"has to do with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front using `pop_front`."
msgstr ""

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr ""

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an Array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type the "
"variable."
msgstr ""

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr ""

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr ""

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr ""

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` containing the removed "
"element, or `Option::None` if the array is empty."
msgstr ""

#: src/ch03-01-arrays.md:51
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-arrays.md:65
msgid ""
"The above code will print `10` as we remove the first element that was added."
msgstr ""

#: src/ch03-01-arrays.md:67
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""

#: src/ch03-01-arrays.md:69
msgid "Reading Elements from an Array"
msgstr ""

#: src/ch03-01-arrays.md:71
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and "
"Snapshots](ch04-02-references-and-snapshots.md) chapter."
msgstr ""

#: src/ch03-01-arrays.md:75
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""

#: src/ch03-01-arrays.md:77
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""

#: src/ch03-01-arrays.md:90
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""

#: src/ch03-01-arrays.md:94
msgid "Here is an example with the `get()` method:"
msgstr ""

#: src/ch03-01-arrays.md:96
msgid ""
"```rust\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100);\n"
"    let index_to_access =\n"
"        1; // Change this value to see different results, what would happen "
"if the index doesn't exist?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x\n"
"                .unbox() // Don't worry about * for now, if you are curious "
"see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
"        },\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-arrays.md:117
msgid "Size related methods"
msgstr ""

#: src/ch03-01-arrays.md:119
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return is of type `usize`."
msgstr ""

#: src/ch03-01-arrays.md:121
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""

#: src/ch03-01-arrays.md:123
msgid "Storing multiple types with Enums"
msgstr ""

#: src/ch03-01-arrays.md:125
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [Enums and Pattern "
"Matching](ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""

#: src/ch03-01-arrays.md:143
msgid "Span"
msgstr ""

#: src/ch03-01-arrays.md:145
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""

#: src/ch03-01-arrays.md:147
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr ""

#: src/ch03-01-arrays.md:149
msgid "Turning an Array into span"
msgstr ""

#: src/ch03-01-arrays.md:151
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr ""

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252` leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr ""

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr ""

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""

#: src/ch03-02-dictionaries.md:33
msgid ""
"The first thing we do is import `Felt252DictTrait` which brings to scope all "
"the methods we need to interact with the dictionary. Next, we create a new "
"instance of `Felt252Dict<u64>` by using the `default` method of the "
"`Default` trait and added two individuals, each one with their own balance, "
"using the `insert` method. Finally, we checked the balance of our users with "
"the `get` method."
msgstr ""

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""

#: src/ch03-02-dictionaries.md:39
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut balances: Felt252Dict<u64> = Default::default();\n"
"\n"
"    // Insert Alex with 100 balance\n"
"    balances.insert('Alex', 100);\n"
"    // Check that Alex has indeed 100 asociated with him\n"
"    let alex_balance = balances.get('Alex');\n"
"    assert(alex_balance == 100, 'Alex balance is not 100');\n"
"\n"
"    // Insert Alex again, this time with 200 balance\n"
"    balances.insert('Alex', 200);\n"
"    // Check the new balance is correct\n"
"    let alex_balance_2 = balances.get('Alex');\n"
"    assert(alex_balance_2 == 200, 'Alex balance is not 200');\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the _Alex_ individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""

#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr ""

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""

#: src/ch03-02-dictionaries.md:69
msgid ""
"A `key` field that identifies the value for this key-value pair of the "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:70
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""

#: src/ch03-02-dictionaries.md:71
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr ""

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""

#: src/ch03-02-dictionaries.md:83
msgid ""
"For each time we interact with a `Felt252Dict<T>` a new `Entry<T>` will be "
"registered:"
msgstr ""

#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""

#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr ""

#: src/ch03-02-dictionaries.md:108
#: src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:108
#: src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:108
#: src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:110
#: src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr ""

#: src/ch03-02-dictionaries.md:110
#: src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:134
#: src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146
#: src/ch03-02-dictionaries.md:147
msgid "0"
msgstr ""

#: src/ch03-02-dictionaries.md:110
#: src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:135
msgid "100"
msgstr ""

#: src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr ""

#: src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:113
msgid "50"
msgstr ""

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr ""

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""

#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr ""

#: src/ch03-02-dictionaries.md:132
#: src/ch03-02-dictionaries.md:136
msgid "150"
msgstr ""

#: src/ch03-02-dictionaries.md:134
#: src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr ""

#: src/ch03-02-dictionaries.md:134
#: src/ch03-02-dictionaries.md:147
msgid "70"
msgstr ""

#: src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138
msgid "250"
msgstr ""

#: src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137
msgid "40"
msgstr ""

#: src/ch03-02-dictionaries.md:137
#: src/ch03-02-dictionaries.md:139
msgid "300"
msgstr ""

#: src/ch03-02-dictionaries.md:138
#: src/ch03-02-dictionaries.md:146
msgid "190"
msgstr ""

#: src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "90"
msgstr ""

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr ""

#: src/ch03-02-dictionaries.md:149
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr ""

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of "
"Dictionaries](#basic-use-of-dictionaries) you'd notice that there was never "
"a call to squash dictionary, but the program compiled successfully "
"nonetheless. What happened behind the scene was that squash was called "
"automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` "
"trait. This call occurred just before the `balance` dictionary went out of "
"scope."
msgstr ""

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and "
"Destruct](/appendix-03-derivable-traits.md#drop-and-destruct)."
msgstr ""

#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"we will have a hands-on example where we implement the `Destruct<T>` trait "
"for a custom type."
msgstr ""

#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr ""

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-complex-types) with other "
"complex types such as `Array<T>` and how to "
"[implement](#dictionaries-as-struct-members) a struct with a dictionary as a "
"member."
msgstr ""

#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr ""

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously."
msgstr ""

#: src/ch03-02-dictionaries.md:177
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""

#: src/ch03-02-dictionaries.md:183
msgid ""
"This method receives the entry and the new value as a parameter and returns "
"the updated dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:185
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:187
msgid "Create the new entry to add using the `entry` method"
msgstr ""

#: src/ch03-02-dictionaries.md:188
msgid "Insert back the entry where the `new_value` equals the `previous_value`."
msgstr ""

#: src/ch03-02-dictionaries.md:189
msgid "Return the value."
msgstr ""

#: src/ch03-02-dictionaries.md:191
msgid "Implementing our custom get would look like this:"
msgstr ""

#: src/ch03-02-dictionaries.md:193
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, "
"impl TCopy: Copy<T>>(\n"
"    ref dict: Felt252Dict<T>, key: felt252\n"
") -> T {\n"
"    // Get the new entry and the previous value held at `key`\n"
"    let (entry, prev_value) = dict.entry(key);\n"
"\n"
"    // Store the value to return\n"
"    let return_value = prev_value;\n"
"\n"
"    // Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
"    dict = entry.finalize(prev_value);\n"
"\n"
"    // Return the read value\n"
"    return_value\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:213
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""

#: src/ch03-02-dictionaries.md:215
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictEntryTrait;\n"
"\n"
"fn custom_insert<\n"
"    T,\n"
"    impl TDefault: Felt252DictValue<T>,\n"
"    impl TDestruct: Destruct<T>,\n"
"    impl TPrint: PrintTrait<T>,\n"
"    impl TDrop: Drop<T>\n"
">(\n"
"    ref dict: Felt252Dict<T>, key: felt252, value: T\n"
") {\n"
"    // Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exists, _prev_value will\n"
"    // be the default value of T.\n"
"    let (entry, _prev_value) = dict.entry(key);\n"
"\n"
"    // Insert `entry` back in the dictionary with the updated value,\n"
"    // and recieve ownership of the dictionary\n"
"    dict = entry.finalize(value);\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:238
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""

#: src/ch03-02-dictionaries.md:240
msgid ""
"```rust\n"
"# use dict::Felt252DictEntryTrait;\n"
"# \n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn custom_get<T, impl TDefault: Felt252DictValue<T>, impl TDrop: Drop<T>, "
"impl TCopy: Copy<T>>(\n"
"#     ref dict: Felt252Dict<T>, key: felt252\n"
"# ) -> T {\n"
"#     // Get the new entry and the previous value held at `key`\n"
"#     let (entry, prev_value) = dict.entry(key);\n"
"# \n"
"#     // Store the value to return\n"
"#     let return_value = prev_value;\n"
"# \n"
"#     // Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
"#     dict = entry.finalize(prev_value);\n"
"# \n"
"#     // Return the read value\n"
"#     return_value\n"
"# }\n"
"# \n"
"# fn custom_insert<\n"
"#     T,\n"
"#     impl TDefault: Felt252DictValue<T>,\n"
"#     impl TDestruct: Destruct<T>,\n"
"#     impl TPrint: PrintTrait<T>,\n"
"#     impl TDrop: Drop<T>\n"
"# >(\n"
"#     ref dict: Felt252Dict<T>, key: felt252, value: T\n"
"# ) {\n"
"#     // Get the last entry associated with `key`\n"
"#     // Notice that if `key` does not exists, _prev_value will\n"
"#     // be the default value of T.\n"
"#     let (entry, _prev_value) = dict.entry(key);\n"
"# \n"
"#     // Insert `entry` back in the dictionary with the updated value,\n"
"#     // and recieve ownership of the dictionary\n"
"#     dict = entry.finalize(value);\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut dict: Felt252Dict<u64> = Default::default();\n"
"\n"
"    custom_insert(ref dict, '0', 100);\n"
"\n"
"    let val = custom_get(ref dict, '0');\n"
"\n"
"    assert(val == 100, 'Expecting 100');\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:293
msgid "Dictionaries of types not supported natively"
msgstr ""

#: src/ch03-02-dictionaries.md:295
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types "
"not natively supported is not a straightforward task, because you would need "
"to write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:301
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a "
"pointer that can only be manipulated in one place at a time."
msgstr ""

#: src/ch03-02-dictionaries.md:303
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""

#: src/ch03-02-dictionaries.md:305
msgid ""
"```rust,noplayground\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"//...\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:325
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""

#: src/ch03-02-dictionaries.md:327
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we didn't do that directly, but instead, we took some steps in between:"
msgstr ""

#: src/ch03-02-dictionaries.md:329
msgid ""
"We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr ""

#: src/ch03-02-dictionaries.md:330
msgid ""
"We wrapped the `Box` inside a nullable using the `nullable_from_box` "
"function."
msgstr ""

#: src/ch03-02-dictionaries.md:331
msgid "Finally, we inserted the result."
msgstr ""

#: src/ch03-02-dictionaries.md:333
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""

#: src/ch03-02-dictionaries.md:335
msgid ""
"```rust,noplayground\n"
"//...\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value "
"found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:354
msgid "Here we:"
msgstr ""

#: src/ch03-02-dictionaries.md:356
msgid "Read the value using `get`."
msgstr ""

#: src/ch03-02-dictionaries.md:357
msgid "Verified it is non-null using the `match_nullable` function."
msgstr ""

#: src/ch03-02-dictionaries.md:358
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr ""

#: src/ch03-02-dictionaries.md:360
msgid "The complete script would look like this:"
msgstr ""

#: src/ch03-02-dictionaries.md:362
msgid ""
"```rust\n"
"\n"
"use dict::Felt252DictTrait;\n"
"use nullable::{nullable_from_box, match_nullable, FromNullableResult};\n"
"\n"
"fn main() {\n"
"    // Create the dictionary\n"
"    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n"
"\n"
"    // Crate the array to insert\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(8);\n"
"    a.append(9);\n"
"    a.append(10);\n"
"\n"
"    // Insert it as a `Span`\n"
"    d.insert(0, nullable_from_box(BoxTrait::new(a.span())));\n"
"\n"
"    // Get value back\n"
"    let val = d.get(0);\n"
"\n"
"    // Search the value and assert it is not null\n"
"    let span = match match_nullable(val) {\n"
"        FromNullableResult::Null(()) => panic_with_felt252('No value "
"found'),\n"
"        FromNullableResult::NotNull(val) => val.unbox(),\n"
"    };\n"
"\n"
"    // Verify we are having the right values\n"
"    assert(*span.at(0) == 8, 'Expecting 8');\n"
"    assert(*span.at(1) == 9, 'Expecting 9');\n"
"    assert(*span.at(2) == 10, 'Expecting 10');\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:397
msgid "Dictionaries as Struct Members"
msgstr ""

#: src/ch03-02-dictionaries.md:399
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""

#: src/ch03-02-dictionaries.md:414
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""

#: src/ch03-02-dictionaries.md:416
msgid "`users_amount`, the number of users currently inserted and"
msgstr ""

#: src/ch03-02-dictionaries.md:417
msgid "`balances`, a mapping of each user to its balance."
msgstr ""

#: src/ch03-02-dictionaries.md:419
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""

#: src/ch03-02-dictionaries.md:421
msgid "`new` for easily creating new `UserDatabase` types."
msgstr ""

#: src/ch03-02-dictionaries.md:422
msgid "`add_user` to insert users in the database."
msgstr ""

#: src/ch03-02-dictionaries.md:423
msgid "`get_balance` to find user's balance in the database."
msgstr ""

#: src/ch03-02-dictionaries.md:425
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [generic "
"types](/src/ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""

#: src/ch03-02-dictionaries.md:427
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""

#: src/ch03-02-dictionaries.md:428
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""

#: src/ch03-02-dictionaries.md:429
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"destructible."
msgstr ""

#: src/ch03-02-dictionaries.md:431
msgid "The implementation, with all restriction in place, would be as follow:"
msgstr ""

#: src/ch03-02-dictionaries.md:433
msgid ""
"```rust,noplayground\n"
"\n"
"\n"
"impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of "
"UserDatabaseTrait<T> {\n"
"    // Creates a database\n"
"    fn new() -> UserDatabase<T> {\n"
"        UserDatabase { users_amount: 0, balances: Default::default() }\n"
"    }\n"
"\n"
"    // Get the user's balance\n"
"    fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: "
"felt252) -> T {\n"
"        self.balances.get(name)\n"
"    }\n"
"\n"
"    // Add a user\n"
"    fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: "
"felt252, balance: T) {\n"
"        self.balances.insert(name, balance);\n"
"        self.users_amount += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:455
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of "
"[genericity](/src/ch08-00-generic-types-and-traits.md) in the struct "
"definition. We need to code the `Destruct<T>` trait implementation by "
"ourselves:"
msgstr ""

#: src/ch03-02-dictionaries.md:469
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""

#: src/ch03-02-dictionaries.md:471
msgid ""
"```rust\n"
"# struct UserDatabase<T> {\n"
"#     users_amount: u64,\n"
"#     balances: Felt252Dict<T>,\n"
"# }\n"
"# \n"
"# trait UserDatabaseTrait<T> {\n"
"#     fn new() -> UserDatabase<T>;\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: "
"felt252, balance: T);\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: "
"felt252) -> T;\n"
"# }\n"
"# \n"
"# impl UserDatabaseImpl<T, impl TDefault: Felt252DictValue<T>> of "
"UserDatabaseTrait<T> {\n"
"#     // Creates a database\n"
"#     fn new() -> UserDatabase<T> {\n"
"#         UserDatabase { users_amount: 0, balances: Default::default() }\n"
"#     }\n"
"# \n"
"#     // Get the user's balance\n"
"#     fn get_balance<impl TCopy: Copy<T>>(ref self: UserDatabase<T>, name: "
"felt252) -> T {\n"
"#         self.balances.get(name)\n"
"#     }\n"
"# \n"
"#     // Add a user\n"
"#     fn add_user<impl TDrop: Drop<T>>(ref self: UserDatabase<T>, name: "
"felt252, balance: T) {\n"
"#         self.balances.insert(name, balance);\n"
"#         self.users_amount += 1;\n"
"#     }\n"
"# }\n"
"# \n"
"# impl UserDatabaseDestruct<\n"
"#     T, impl TDrop: Drop<T>, impl TDefault: Felt252DictValue<T>\n"
"# > of Destruct<UserDatabase<T>> {\n"
"#     fn destruct(self: UserDatabase<T>) nopanic {\n"
"#         self.balances.squash();\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let mut db = UserDatabaseTrait::new();\n"
"\n"
"    db.add_user('Alex', 100);\n"
"    db.add_user('Maria', 80);\n"
"\n"
"    db.add_user('Alex', 40);\n"
"    db.add_user('Maria', 0);\n"
"\n"
"    let alex_latest_balance = db.get_balance('Alex');\n"
"    let maria_latest_balance = db.get_balance('Maria');\n"
"\n"
"    assert(alex_latest_balance == 40, 'Expected 40');\n"
"    assert(maria_latest_balance == 0, 'Expected 0');\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch03-02-dictionaries.md:530
msgid ""
"Well done! You finished this chapter on arrays and dictionaries in Cairo. "
"These data structures may be a bit challenging to grasp, but they are really "
"useful."
msgstr ""

#: src/ch03-02-dictionaries.md:532
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that _doesn’t_ commonly exist in other programming languages: "
"ownership."
msgstr ""

#: src/ch04-00-understanding-ownership.md:1
msgid "Understanding Cairo's Ownership system"
msgstr ""

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""

#: src/ch04-01-what-is-ownership.md:1
msgid "What Is Ownership?"
msgstr ""

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of "
"its compiled code. The ownership mechanism complements the linear type "
"system, which enforces that objects are used exactly once. This helps "
"prevent common operations that can produce runtime errors, such as illegal "
"memory address references or multiple writes to the same memory address, and "
"ensures the soundness of Cairo programs by checking at compile time that all "
"the dictionaries are squashed."
msgstr ""

#: src/ch04-01-what-is-ownership.md:9
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a `main` function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:15
msgid "Ownership Rules"
msgstr ""

#: src/ch04-01-what-is-ownership.md:17
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as "
"we work through the examples that illustrate them:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:20
msgid "Each value in Cairo has an _owner_."
msgstr ""

#: src/ch04-01-what-is-ownership.md:21
msgid "There can only be one owner at a time."
msgstr ""

#: src/ch04-01-what-is-ownership.md:22
msgid "When the owner goes out of scope, the value will be _dropped_."
msgstr ""

#: src/ch04-01-what-is-ownership.md:24
msgid "Variable Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some "
"variables. A scope is the range within a program for which an item is valid. "
"Take the following variable:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:34
msgid ""
"The variable `s` refers to a short string, where the value of the string is "
"hardcoded into the text of our program. The variable is valid from the point "
"at which it’s declared until the end of the current _scope_. Listing 4-1 "
"shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:39
msgid ""
"```rust\n"
"# //TAG: ignore_fmt\n"
"# fn main() {\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer "
"valid\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:50
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr ""

#: src/ch04-01-what-is-ownership.md:53
msgid "In other words, there are two important points in time here:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:55
msgid "When `s` comes _into_ scope, it is valid."
msgstr ""

#: src/ch04-01-what-is-ownership.md:56
msgid "It remains valid until it goes _out of_ scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:58
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the [previous "
"chapter](./ch03-01-arrays.md)."
msgstr ""

#: src/ch04-01-what-is-ownership.md:62
msgid "Ownership with the `Array` Type"
msgstr ""

#: src/ch04-01-what-is-ownership.md:64
msgid ""
"To illustrate the rules of ownership, we need a data type that is more "
"complex. The types covered in the [Data "
"Types](ch02-02-data-types.html#data-types)"
msgstr ""

#: src/ch04-01-what-is-ownership.md:65
msgid ""
" section of Chapter 2 are of a known size, can be quickly and trivially "
"copied to make a new, independent instance if another part of code needs to "
"use the same value in a different scope, and can easily be dropped when "
"they're no longer used. But what is the behavior with the `Array` type whose "
"size is unknown at compile time and which can't be trivially copied?"
msgstr ""

#: src/ch04-01-what-is-ownership.md:72
msgid "Here is a short reminder of what an array looks like:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:82
msgid ""
"So, how does the ownership system ensure that each cell is never written to "
"more than once? Consider the following code, where we try to pass the same "
"instance of an array in two consecutive function calls:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the "
"functions `foo` and `bar`, which means that the parameter used in both "
"function calls is the same instance of the array. If you append a value to "
"the array in `foo`, and then try to append another value to the same array "
"in `bar`, what would happen is that you would attempt to try to write to the "
"same memory cell twice, which is not allowed in Cairo. To prevent this, the "
"ownership of the `arr` variable moves from the `main` function to the `foo` "
"function. When trying to call `bar` with `arr` as a parameter, the ownership "
"of `arr` was already moved to the first call. The ownership system thus "
"prevents us from using the same instance of `arr` in `foo`."
msgstr ""

#: src/ch04-01-what-is-ownership.md:107
msgid "Running the code above will result in a compile-time error:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:116
msgid "The `Copy` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:118
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not "
"move the ownership of the value to the function called, but will instead "
"pass a copy of the value. You can implement the `Copy` trait on your type by "
"adding the `#[derive(Copy)]` annotation to your type definition. However, "
"Cairo won't allow a type to be annotated with Copy if the type itself or any "
"of its components don't implement the Copy trait. While Arrays and "
"Dictionaries can't be copied, custom types that don't contain either of them "
"can be."
msgstr ""

#: src/ch04-01-what-is-ownership.md:122
msgid ""
"```rust,ignore_format\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) { // do something with p\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:139
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, and the ownership of `p1` "
"remains with the main function. If you remove the `Copy` trait derivation "
"from the `Point` type, you will get a compile-time error when trying to "
"compile the code."
msgstr ""

#: src/ch04-01-what-is-ownership.md:142
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""

#: src/ch04-01-what-is-ownership.md:144
msgid "The `Drop` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:146
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. In Cairo, a value cannot go out of scope unless "
"it has been previously moved. For example, the following code will not "
"compile, because the struct `A` is not moved before it goes out of scope:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:149
msgid ""
"```rust,does_not_compile\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:157
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the "
"fact that if a statement during the execution of the program is false, no "
"cheating prover can convince an honest verifier that it is true. In our "
"case, we want to ensure the consistency of consecutive dictionary key "
"updates during program execution, which is only checked when the "
"dictionaries are `squashed` - which moves the ownership of the dictionary to "
"the `squash` method, thus allowing the dictionary to go out of scope. "
"Unsquashed dictionaries are dangerous, as a malicious prover could prove the "
"correctness of inconsistent updates."
msgstr ""

#: src/ch04-01-what-is-ownership.md:165
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of "
"scope without being explicitly moved. When a value of a type that implements "
"the `Drop` trait goes out of scope, the `Drop` implementation is called on "
"the type, which moves the value to the `drop` function, allowing it to go "
"out of scope - This is what we call \"dropping\" a value. It is important to "
"note that the implementation of drop is a \"no-op\", meaning that it doesn't "
"perform any actions other than allowing the value to go out of scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:168
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be "
"dropped when going out of scope, except for dictionaries (`Felt252Dict`) and "
"types containing dictionaries. For example, the following code compiles:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:171
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:180
msgid "The `Destruct` Trait"
msgstr ""

#: src/ch04-01-what-is-ownership.md:182
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, "
"and it is easy to forget to do so. To make it easier to use dictionaries, "
"Cairo provides the `Destruct` trait, which allows you to specify the "
"behavior of a type when it goes out of scope. While Dictionaries don't "
"implement the `Drop` trait, they do implement the `Destruct` trait, which "
"allows them to automatically be `squashed` when they go out of scope. This "
"means that you can use dictionaries without having to manually call the "
"`squash` method."
msgstr ""

#: src/ch04-01-what-is-ownership.md:184
msgid ""
"Consider the following example, in which we define a custom type that "
"contains a dictionary:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:197
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:206
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""

#: src/ch04-01-what-is-ownership.md:208
msgid ""
"```rust\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Default::default() }; // No error here\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:219
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""

#: src/ch04-01-what-is-ownership.md:221
msgid "Copy Array data with Clone"
msgstr ""

#: src/ch04-01-what-is-ownership.md:223
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in Chapter 6, but because "
"methods are a common feature in many programming languages, you’ve probably "
"seen them before."
msgstr ""

#: src/ch04-01-what-is-ownership.md:226
msgid "Here’s an example of the `clone` method in action."
msgstr ""

#: src/ch04-01-what-is-ownership.md:228
msgid ""
"Note: in the following example, we need to import the `Clone` trait from the "
"corelib `clone` module, and its implementation for the array type from the "
"`array` module."
msgstr ""

#: src/ch04-01-what-is-ownership.md:239
msgid ""
"Note: you will need to run `scarb cairo-run` with the "
"`--available-gas=2000000` option to run this example, because it uses a loop "
"and must be ran with a gas limit."
msgstr ""

#: src/ch04-01-what-is-ownership.md:241
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on."
msgstr ""

#: src/ch04-01-what-is-ownership.md:245
msgid "Ownership and Functions"
msgstr ""

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in "
"the Array section, passing an `Array` as a function parameter transfers its "
"ownership; let's see what happens with other types."
msgstr ""

#: src/ch04-01-what-is-ownership.md:249
msgid ""
"Listing 4-3 has an example with some annotations showing where variables go "
"into and out of scope."
msgstr ""

#: src/ch04-01-what-is-ownership.md:254
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the "
"function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is "
"okay to still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is "
"dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:280
msgid "Listing 4-3: Functions with ownership and scope annotated"
msgstr ""

#: src/ch04-01-what-is-ownership.md:283
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo "
"would throw a compile-time error. These static checks protect us from "
"mistakes. Try adding code to `main` that uses `my_struct` and `x` to see "
"where you can use them and where the ownership rules prevent you from doing "
"so."
msgstr ""

#: src/ch04-01-what-is-ownership.md:288
msgid "Return Values and Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:290
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example "
"of a function that returns some value, with similar annotations as those in "
"Listing 4-3."
msgstr ""

#: src/ch04-01-what-is-ownership.md:296
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its "
"return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A {};                        // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A {};                    // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:334
msgid "Listing 4-4: Transferring ownership of return values"
msgstr ""

#: src/ch04-01-what-is-ownership.md:337
msgid ""
"When a variable goes out of scope, its value is dropped, unless ownership of "
"the value has been moved to another variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:339
msgid ""
"While this works, taking ownership and then returning ownership with every "
"function is a bit tedious. What if we want to let a function use a value but "
"not take ownership? It’s quite annoying that anything we pass in also needs "
"to be passed back if we want to use it again, in addition to any data "
"resulting from the body of the function that we might want to return as well."
msgstr ""

#: src/ch04-01-what-is-ownership.md:345
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-5."
msgstr ""

#: src/ch04-01-what-is-ownership.md:349
msgid ""
"```rust\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:363
msgid "Listing 4-5: Returning ownership of parameters"
msgstr ""

#: src/ch04-01-what-is-ownership.md:365
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for using a value without "
"transferring ownership, called _references_ and _snapshots_."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the "
"`Array` to the calling function so we can still use the `Array` after the "
"call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a "
"snapshot is an immutable view of a value at a certain point in time. In the "
"previous chapter, we talked about how Cairo's ownership system prevents us "
"from using a value after we've moved it, protecting us from potentially "
"writing twice to the same memory cell when appending values to arrays. "
"However, it's not very convenient. Let's see how we can retain ownership of "
"the value in the calling function using snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:17
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot to an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as parameter. As we're passing it as "
"a snapshot, which is an immutable view of the array, we can be sure that the "
"`calculate_length` function will not mutate the array, and ownership of the "
"array is kept in the main function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:25
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point "
"in time\n"
"    arr1.append(1); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(\n"
"        first_snapshot\n"
"    ); // Calculate the length of the array when the snapshot was taken\n"
"    //ANCHOR: function_call\n"
"    let second_length = calculate_length(@arr1); // Calculate the current "
"length of the array\n"
"    //ANCHOR_END: function_call\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:47
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:49
msgid "The output of this program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:59
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:62
msgid "Let’s take a closer look at the function call here:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:64
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut arr1 = ArrayTrait::<u128>::new();\n"
"#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point "
"in time\n"
"#     arr1.append(1); // Mutate `arr1` by appending a value\n"
"#     let first_length = calculate_length(\n"
"#         first_snapshot\n"
"#     ); // Calculate the length of the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current "
"length of the array\n"
"#     first_length.print();\n"
"#     second_length.print();\n"
"# }\n"
"# \n"
"# fn calculate_length(arr: @Array<u128>) -> usize {\n"
"#     arr.len()\n"
"# }\n"
"```"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value, the value it points to cannot be "
"modified through the snapshot, and the value it refers to will not be "
"dropped once the snapshot stops being used."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:88
msgid ""
"```rust, noplayground\n"
"fn calculate_length(\n"
"    array_snapshot: @Array<u128>\n"
") -> usize { // array_snapshot is a snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
"```"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:97
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:99
msgid "Desnap Operator"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:101
msgid ""
"To convert a snapshot back into a regular value, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator: the snapshot "
"value is copied to a new variable."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:103
msgid ""
"It's important to note that during this conversion process, the value it "
"points to is copied into a new variable. This enables multiple uses of the "
"underlying value without concerns about ownership transfers. This also means "
"that the value pointed to by the snapshot must be copyable (which is not the "
"case for Arrays, as they don't implement `Copy`)."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:105
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:107
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of "
"the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:131
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? "
"Try the code in Listing 4-6. Spoiler alert: it doesn’t work!"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:155
msgid "Listing 4-6: Attempting to modify a snapshot value"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:157
msgid "Here’s the error:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:166
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:168
msgid "Mutable References"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:170
msgid ""
"We can achieve the behavior we want in Listing 4-6 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:173
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:175
msgid ""
"In Listing 4-7, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:199
msgid "Listing 4-7: Use of a mutable reference to modify a value"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:201
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:203
msgid "The output of the program is:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:212
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:214
msgid "Small recap"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:216
msgid ""
"Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:218
msgid "At any given time, a variable can only have one owner."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:222
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the next chapter) are the building blocks for "
"creating new types in your program’s domain to take full advantage of "
"Cairo's compile-time type checking."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data "
"Types](ch02-02-data-types.md) section, in that both hold multiple related "
"values. Like tuples, the pieces of a struct can be different types. Unlike "
"with tuples, in a struct you’ll name each piece of data so it’s clear what "
"the values mean. Adding these names means that structs are more flexible "
"than tuples: you don’t have to rely on the order of the data to specify or "
"access the values of an instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "Listing 5-1: A `User` struct definition"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:44
msgid "Listing 5-2: Creating an instance of the `User` struct"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:46
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:76
msgid "Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:78
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:80
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:82
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:112
msgid ""
"Listing 5-4: A `build_user` function that takes an email and username and "
"returns a `User` instance"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:114
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:116
msgid "Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:118
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:148
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because "
"the `username` and `email` parameters have the same name as struct fields"
msgstr ""

#: src/ch05-01-defining-and-instantiating-structs.md:150
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:23
msgid ""
"Listing 5-6: Calculating the area of a rectangle specified by separate width "
"and height variables"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in [Chapter 2](ch02-02-data-types.html#the-tuple-type): "
"using tuples."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:44
msgid "Refactoring with Tuples"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:50
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30, 10);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x, y) = dimension;\n"
"    x * y\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:64
msgid ""
"Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:70
msgid "Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:72
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:76
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10, };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:95
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:99
msgid "Adding Useful Functionality with Trait"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:101
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-9 "
"tries using the `print` as we have used in previous chapters. This won’t "
"work."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:119
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:121
msgid "When we compile this code, we get an error with this message:"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:123
msgid ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you "
"import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:133
msgid ""
"The `print` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:161
msgid "Listing 5-10: Implementing the `PrintTrait` trait on `Rectangle`"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:163
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr ""

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on. For those familiar with Rust, Cairo's approach "
"might be confusing, as methods cannot be defined directly on types. Instead, "
"you must define a trait and an implementation associated with the type for "
"which the method is intended."
msgstr ""

#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr ""

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `RectangleTrait` "
"trait, as shown in Listing 5-13."
msgstr ""

#: src/ch05-03-method-syntax.md:45
msgid "Listing 5-13: Defining an `area` method to use on the `Rectangle` "
msgstr ""

#: src/ch05-03-method-syntax.md:48
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait` block with the signature of the method that we want to "
"implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we "
"define an `impl` (implementation) block for `RectangleTrait`, that defines "
"the behavior of the methods implemented. Everything within this `impl` block "
"will be associated with the type of the `self` parameter of the method "
"called. While it is technically possible to define methods for multiple "
"types within the same `impl` block, it is not a recommended practice, as it "
"can lead to confusion. We recommend that the type of the `self` parameter "
"stays consistent within the same `impl` block. Then we move the `area` "
"function within the `impl` curly brackets and change the first (and in this "
"case, only) parameter to be `self` in the signature and everywhere within "
"the body. In `main`, where we called the `area` function and passed `rect1` "
"as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an "
"instance: we add a dot followed by the method name, parentheses, and any "
"arguments."
msgstr ""

#: src/ch05-03-method-syntax.md:64
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter. Note that we used the `@` snapshot operator in "
"front of the `Rectangle` type in the function signature. By doing so, we "
"indicate that this method takes an immutable snapshot of the `Rectangle` "
"instance, which is automatically created by the compiler when passing the "
"instance to the method. Methods can take ownership of `self`, use `self` "
"with snapshots as we’ve done here, or use a mutable reference to `self` "
"using the `ref self: T` syntax."
msgstr ""

#: src/ch05-03-method-syntax.md:71
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in "
"the function version: we don’t want to take ownership, and we just want to "
"read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, "
"we’d use `ref self: Rectangle` as the first parameter. Having a method that "
"takes ownership of the instance by using just `self` as the first parameter "
"is rare; this technique is usually used when the method transforms `self` "
"into something else and you want to prevent the caller from using the "
"original instance after the transformation."
msgstr ""

#: src/ch05-03-method-syntax.md:80
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members. This is necessary because the struct is "
"passed as a snapshot, and all of its field values are of type `@T`, "
"requiring them to be desnapped in order to manipulate them."
msgstr ""

#: src/ch05-03-method-syntax.md:84
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide. However, we can define multiple "
"combinations of `trait` & `impl` blocks for the same type at different "
"places, which can be useful for a more granular code organization. For "
"example, you could implement the `Add` trait for your type in one `impl` "
"block, and the `Sub` trait in another block."
msgstr ""

#: src/ch05-03-method-syntax.md:89
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr ""

#: src/ch05-03-method-syntax.md:119
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0` and `false` if the value "
"is `0`: we can use a field within a method of the same name for any purpose. "
"In `main`, when we follow `rect1.width` with parentheses, Cairo knows we "
"mean the method `width`. When we don’t use parentheses, Cairo knows we mean "
"the field `width`."
msgstr ""

#: src/ch05-03-method-syntax.md:126
msgid "Methods with More Parameters"
msgstr ""

#: src/ch05-03-method-syntax.md:128
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we "
"want to be able to write the program shown in Listing 5-14."
msgstr ""

#: src/ch05-03-method-syntax.md:158
msgid "Listing 5-14: Using the as-yet-unwritten `can_hold` method"
msgstr ""

#: src/ch05-03-method-syntax.md:161
msgid ""
"The expected output would look like the following because both dimensions of "
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr ""

#: src/ch05-03-method-syntax.md:177
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The "
"method name will be `can_hold`, and it will take a snapshot of another "
"`Rectangle` as a parameter. We can tell what the type of the parameter will "
"be by looking at the code that calls the method: `rect1.can_hold(@rect2)` "
"passes in `@rect2`, which is a snapshot to `rect2`, an instance of "
"`Rectangle`. This makes sense because we only need to read `rect2` (rather "
"than write, which would mean we’d need a mutable borrow), and we want `main` "
"to retain ownership of `rect2` so we can use it again after calling the "
"`can_hold` method. The return value of `can_hold` will be a Boolean, and the "
"implementation will check whether the width and height of `self` are greater "
"than the width and height of the other `Rectangle`, respectively. Let’s add "
"the new `can_hold` method to the `trait` and `impl` blocks from Listing "
"5-13, shown in Listing 5-15."
msgstr ""

#: src/ch05-03-method-syntax.md:211
msgid ""
"Listing 5-15: Implementing the `can_hold` method on `Rectangle` that takes "
"another `Rectangle` instance as a parameter"
msgstr ""

#: src/ch05-03-method-syntax.md:214
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""

#: src/ch05-03-method-syntax.md:219
msgid "Accessing implementation functions"
msgstr ""

#: src/ch05-03-method-syntax.md:221
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed using the `::` operator on the implementation name. Functions in "
"traits that aren’t methods are often used for constructors that will return "
"a new instance of the struct. These are often called `new`, but `new` isn’t "
"a special name and isn’t built into the language. For example, we could "
"choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it "
"easier to create a square `Rectangle` rather than having to specify the same "
"value twice:"
msgstr ""

#: src/ch05-03-method-syntax.md:245
msgid ""
"To call this function, we use the `::` syntax with the implementation name; "
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by the implementation; the `::` syntax is used for both trait "
"functions and namespaces created by modules. We’ll discuss modules in "
"\\[Chapter 8\\]\\[modules\\]"
msgstr ""

#: src/ch05-03-method-syntax.md:248
#: src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr ""

#: src/ch05-03-method-syntax.md:250
msgid ""
"Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""

#: src/ch05-03-method-syntax.md:252
msgid "Multiple `impl` Blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:254
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which "
"has each method in its own `trait` and `impl` blocks."
msgstr ""

#: src/ch05-03-method-syntax.md:279
msgid "Listing 5-16: Rewriting Listing 5-15 using multiple `impl` blocks"
msgstr ""

#: src/ch05-03-method-syntax.md:282
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` "
"blocks here, but this is valid syntax. We’ll see a case in which multiple "
"blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where "
"we discuss generic types and traits."
msgstr ""

#: src/ch05-03-method-syntax.md:288
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `trait` and `impl` "
"blocks, you can define methods, which are functions associated to a type and "
"let you specify the behavior that instances of your type have."
msgstr ""

#: src/ch05-03-method-syntax.md:294
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr ""

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr ""

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""

#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""

#: src/ch06-01-enums.md:39
msgid "Enums Combined with Custom Types"
msgstr ""

#: src/ch06-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr ""

#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""

#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr ""

#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr ""

#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr ""

#: src/ch06-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr ""

#: src/ch06-01-enums.md:60
msgid "Trait Implementations for Enums"
msgstr ""

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr ""

#: src/ch06-01-enums.md:114
msgid "The Option Enum and Its Advantages"
msgstr ""

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""

#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr ""

#: src/ch06-01-enums.md:131
msgid "Recursive Approach `find_value_recursive`"
msgstr ""

#: src/ch06-01-enums.md:132
msgid "Iterative Approach `find_value_iterative`"
msgstr ""

#: src/ch06-01-enums.md:134
msgid ""
"Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr ""

#: src/ch06-01-enums.md:202
msgid "Running this code would print `it worked`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of match "
"comes from the expressiveness of the patterns and the fact that the compiler "
"confirms that all possible cases are handled."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:9
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a "
"function that takes an unknown US coin and, in a similar way as the counting "
"machine, determines which coin it is and returns its value in cents, as "
"shown in Listing 6-3."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Listing 6-3: An enum and a match expression that has the variants of the "
"enum as its patterns"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list "
"the `match` keyword followed by an expression, which in this case is the "
"value `coin`. This seems very similar to a conditional expression used with "
"if, but there’s a big difference: with if, the condition needs to evaluate "
"to a Boolean value, but here it can be any type. The type of coin in this "
"example is the `Coin` enum that we defined on the first line."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny(_)` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in order. If a pattern matches the value, "
"the code associated with that pattern is executed. If that pattern doesn’t "
"match the value, execution continues to the next arm, much as in a "
"coin-sorting machine. We can have as many arms as we need: in the above "
"example, our match has four arms."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:41
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it "
"is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a match arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny(())`, but still "
"returns the last value of the block, `1`:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid "Patterns That Bind to Values"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:59
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-4."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:79
msgid ""
"Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:81
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:83
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:99
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an "
"implementation for the `print` function for the `debug::PrintTrait`:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:112
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, "
"`coin` would be `Coin::Quarter(UsState::Alaska())`. When we compare that "
"value with each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for state will be the "
"value `UsState::Alaska()`. We can then use that binding in the `PrintTrait`, "
"thus getting the inner state value out of the `Coin` enum variant for "
"`Quarter`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:114
msgid "Matching with Options"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:116
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same. You can use Options by importing the "
"`option::OptionTrait` trait."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:118
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:120
msgid ""
"This function is very easy to write, thanks to match, and will look like "
"Listing 6-5."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:141
msgid "Listing 6-5: A function that uses a match expression on an `Option<u8>`"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:144
msgid ""
"Note that your arms must respect the same order as the enum defined in the "
"`OptionTrait` of the core Cairo lib."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:159
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the match arm is "
"then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:161
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None(())`. We enter the match and compare to the first arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:167
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:173
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`Option::None(())` value on the right side of `=>`."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:177
msgid "Matches Are Exhaustive"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:201
msgid "Match 0 and the \\_ Placeholder"
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:203
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. Currently only `0` and the "
"`_`operator are supported."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 "
"and 7. If you have 0, you win. For all other values you lose. Here's a match "
"that implements that logic, with the number hardcoded rather than a random "
"value."
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:216
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that "
"covers every other possible value, the pattern is the character `_`. This "
"code compiles, even though we haven’t listed all the possible values a "
"`felt252` can have, because the last pattern will match all values not "
"specifically listed. This catch-all pattern meets the requirement that "
"`match` must be exhaustive. Note that we have to put the catch-all arm last "
"because the patterns are evaluated in order. If we put the catch-all arm "
"earlier, the other arms would never run, so Cairo will warn us if we add "
"arms after a catch-all!"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid "**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid "**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a crate?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a "
"single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""

#: src/ch07-01-packages-and-crates.md:7
msgid "What is the crate root?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts "
"from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control "
"Scope”](./ch07-02-defining-modules-to-control-scope.md) section)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:11
msgid "What is a package?"
msgstr ""

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code "
"into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr ""

#: src/ch07-01-packages-and-crates.md:15
msgid "Creating a Package with Scarb"
msgstr ""

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:23
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"`src/` is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""

#: src/ch07-01-packages-and-crates.md:33
msgid ""
"`lib.cairo` is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:34
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo` "
"files within the `src` directory or its subdirectories."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden;`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:27
msgid ""
"```rust,noplayground\n"
"  // crate root file (src/lib.cairo)\n"
"    mod garden {\n"
"    // code defining the garden module goes here\n"
"    }\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:44
msgid ""
"```rust,noplayground\n"
"// src/garden.cairo file\n"
"mod vegetables {\n"
"    // code defining the vegetables submodule goes here\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at "
"`backyard::garden::vegetables::Asparagus`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "Filename: src/garden.cairo"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is "
"included too. That code is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the "
"`Asparagus` type into scope, so we can use it in the `main` function."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "Grouping Related Code in Modules"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. As an example, let’s write a library crate that provides the "
"functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, "
"rather than the implementation of a restaurant."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named `restaurant` by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid ""
"Listing 7-1: A `front_of_house` module containing other modules that then "
"contain functions"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 6-1—functions."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate `restaurant`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:17
msgid ""
"```rust,noplayground\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"Listing 7-3: Calling the `add_to_waitlist` function using absolute and "
"relative paths"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "Starting Relative Paths with `super`"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on "
"your project, and depends on whether you’re more likely to move item "
"definition code separately from or together with the code that uses the item."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid "Listing 7-4: Calling a function using a relative path starting with super"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:12
msgid ""
"```rust\n"
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
"\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the "
"`use` path all the way out to the `add_to_waitlist` function to achieve the "
"same result, as in Listing 7-7."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid ""
"Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, "
"which is unidiomatic"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 6-7 accomplish the same task, Listing 7-5 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-7 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-8 shows the "
"idiomatic way to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-9 shows how you can "
"rename an import with `as`:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
msgid ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main() {\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"Listing 7-9: Renaming a trait when it’s brought into scope with the `as` "
"keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "Importing multiple items from the same module"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid "The general syntax for importing multiple items from the same module is:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid "Here is an example where we import three structures from the same module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:162
msgid ""
"```rust\n"
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
"mod shapes {\n"
"    #[derive(Drop)]\n"
"    struct Square {\n"
"        side: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Circle {\n"
"        radius: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Triangle {\n"
"        base: u32,\n"
"        height: u32,\n"
"    }\n"
"}\n"
"\n"
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
"use shapes::{Square, Circle, Triangle};\n"
"\n"
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
"fn main() {\n"
"    let sq = Square { side: 5 };\n"
"    let cr = Circle { radius: 3 };\n"
"    let tr = Triangle { base: 5, height: 2 };\n"
"// ...\n"
"}\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "Re-exporting Names in Module Files"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid ""
"Listing 7-11: Making a name available for any code to use from a new scope "
"with `pub use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this "
"`use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "Using External Packages in Cairo with Scarb"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"The dependencies system is still a work in progress. You can check the "
"official "
"[documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-12. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file in Listing 7-13."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"Listing 7-12: Declaring the `front_of_house` module whose body will be in "
"_src/front_of_house.cairo_"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
msgid "Filename: src/front_of_house.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:46
msgid ""
"Listing 7-13: Definitions inside the `front_of_house` module in "
"_src/front_of_house.cairo_"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module "
"Tree”](ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html)"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may "
"have seen in other programming languages."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules, "
"and Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is public by default."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:1
msgid "Generic Types and Traits"
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behaviour of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete types like `u32` or "
"`ContractAddress`."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""

#: src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr ""

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums, "
"traits, implementations and methods! In this chapter we are going to take a "
"look at how to effectively use generic types with all of them."
msgstr ""

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""

#: src/ch08-01-generic-data-types.md:9
msgid ""
"```rust\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main` "
"function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""

#: src/ch08-01-generic-data-types.md:51
msgid "Constraints for Generic Types"
msgstr ""

#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compilers requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""

#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:57
msgid ""
"```rust\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> "
"T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list: Array<u8> = ArrayTrait::new();\n"
"    list.append(5);\n"
"    list.append(3);\n"
"    list.append(10);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-generic-data-types.md:93
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we don't require to implement the `Drop` trait for `T` as well. Why it does "
"not compile then?"
msgstr ""

#: src/ch08-01-generic-data-types.md:95
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr ""

#: src/ch08-01-generic-data-types.md:115
msgid "Structs"
msgstr ""

#: src/ch08-01-generic-data-types.md:117
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""

#: src/ch08-01-generic-data-types.md:131
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""

#: src/ch08-01-generic-data-types.md:145
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""

#: src/ch08-01-generic-data-types.md:147
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""

#: src/ch08-01-generic-data-types.md:161
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""

#: src/ch08-01-generic-data-types.md:165
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""

#: src/ch08-01-generic-data-types.md:174
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""

#: src/ch08-01-generic-data-types.md:176
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""

#: src/ch08-01-generic-data-types.md:185
#: src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""

#: src/ch08-01-generic-data-types.md:187
msgid "Generic Methods"
msgstr ""

#: src/ch08-01-generic-data-types.md:189
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""

#: src/ch08-01-generic-data-types.md:213
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `address` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""

#: src/ch08-01-generic-data-types.md:215
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""

#: src/ch08-01-generic-data-types.md:217
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"/// Generic trait for wallets\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"/// Trait for wallets of type u128\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"\n"
"    w.receive(100);\n"
"    assert(w.balance() == 150, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-generic-data-types.md:254
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""

#: src/ch08-01-generic-data-types.md:256
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one "
"with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""

#: src/ch08-01-generic-data-types.md:265
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr ""

#: src/ch08-01-generic-data-types.md:267
msgid ""
"```rust,noplayground\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
"Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
"Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch08-01-generic-data-types.md:281
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr ""

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""

#: src/ch08-01-generic-data-types.md:313
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The "
"blueprint specification includes a set of function signatures containing "
"type annotations for the parameters and return value. This sets a standard "
"to implement the specific functionality."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:5
msgid "Defining a Trait"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"To define a trait, you use the keyword `trait` followed by the name of the "
"trait in `PascalCase` then the function signatures in a pair of curly braces."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We "
"want our application to be able to perform geometry operations on these "
"shapes, So we define a trait `ShapeGeometry` that contains a blueprint to "
"implement geometry operations on a shape like this:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods "
"`boundary` and `area`. When implemented, both these functions should return "
"a `u64` and accept parameters as specified by the trait."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:20
msgid "Implementing a Trait"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your "
"implementation followed by `of` then the name of trait being implemented. "
"Here's an example implementing `ShapeGeometry` trait."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` "
"defining what the methods `boundary` and `area` should do. Note that the "
"function parameters and return value types are identical to the trait "
"specification."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:37
msgid "Implementing a trait, without writing its declaration."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:39
msgid ""
"You can write implementations directly without definining the corresponding "
"trait. This is made possible by using the `#[generate_trait]` attribute with "
"on the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` "
"as a suffix to your trait name, as the compiler will create the trait by "
"adding a `Trait` suffix to the implementation name."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:58
msgid ""
"In the aforementioned code, there is no need to manually define the trait. "
"The compiler will automatically handle its definition, dynamically "
"generating and updating it as new functions are introduced."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:60
msgid "Parameter `self`"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:62
msgid ""
"In the example above, `self` is a special parameter. When a parameter with "
"name `self` is used, the implemented functions are also [attached to the "
"instances of the type as "
"methods](ch05-03-method-syntax.md#defining-methods). Here's an illustration,"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:64
msgid ""
"When the `ShapeGeometry` trait is implemented, the function `area` from the "
"`ShapeGeometry` trait can be called in two ways:"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:66
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# \n"
"# #[derive(Drop, Copy)]\n"
"# struct Rectangle {\n"
"#     height: u64,\n"
"#     width: u64,\n"
"# }\n"
"# \n"
"# trait ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64;\n"
"#     fn area(self: Rectangle) -> u64;\n"
"# }\n"
"# \n"
"# impl RectangleGeometry of ShapeGeometry {\n"
"#     fn boundary(self: Rectangle) -> u64 {\n"
"#         2 * (self.height + self.width)\n"
"#     }\n"
"#     fn area(self: Rectangle) -> u64 {\n"
"#         self.height * self.width\n"
"#     }\n"
"# }\n"
"# \n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 10 }; // Rectangle "
"instantiation\n"
"\n"
"    // First way, as a method on the struct instance\n"
"    let area1 = rect.area();\n"
"    // Second way, from the implementation\n"
"    let area2 = RectangleGeometry::area(rect);\n"
"    // Third way, from the trait\n"
"    let area3 = ShapeGeometry::area(rect);\n"
"\n"
"    // `area1` has same value as `area2` and `area3`\n"
"    area1.print();\n"
"    area2.print();\n"
"    area3.print();\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:108
msgid ""
"And the implementation of the `area` method will be accessed via the `self` "
"parameter."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:110
msgid "Generic Traits"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:112
msgid ""
"Usually we want to write a trait when we want multiple types to implement a "
"functionality in a standard way. However, in the example above the "
"signatures are static and cannot be used for multiple types. To do this, we "
"use generic types when defining traits."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:114
msgid ""
"In the example below, we use generic type `T` and our method signatures can "
"use this alias which can be provided during implementation."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:116
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Circle {\n"
"    radius: u64\n"
"}\n"
"\n"
"// Here T is an alias type which will be provided during implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2 * 314 * self.radius) / 100\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314 * self.radius * self.radius) / 100\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:169
msgid "Managing and using external trait implementations"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:171
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In the code above we imported "
"`PrintTrait` from `debug` with `use debug::PrintTrait;` to use the `print()` "
"methods on supported types."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:173
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules. If `CircleGeometry` "
"was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:176
msgid ""
"If the code was organised into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant implementation is required."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:178
msgid ""
"```rust,noplayground\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    let circ = Circle { radius: 5 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and "
"impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:213
msgid "To make it work, in addition to,"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:219
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not "
"need to import `RectangleGeometry`, as it is defined in the same module as "
"the imported trait, and thus is automatically resolved."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:3
#: src/ch09-01-how-to-write-tests.md:13
msgid "The Anatomy of a Test Function"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert` "
"function, and the `should_panic` attribute."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 5. To change "
"a function into a test function, add `#[test]` on the line before `fn`. When "
"you run your tests with the `scarb cairo-test` command, Scarb runs Cairo's "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:26
msgid ""
"In _lib.cairo_, let's remove the existing content and add a first test, as "
"shown in Listing 9-1."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:38
msgid "Listing 9-1: A test module and function"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert` function, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:44
msgid ""
"The `scarb cairo-test` command runs all tests founds in our project, as "
"shown in Listing 9-2."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:54
msgid "Listing 9-2: The output from running a test"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"tests`. The next line shows the name of the test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. We also haven’t filtered the tests being run, so the end of the "
"summary shows `0 filtered out`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:72
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:92
msgid "Listing 9-3: Adding a second test that will fail"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:104
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"in the _src/lib.cairo_ file."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:112
msgid "Checking Results with the assert function"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert` "
"function a first argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"assert function calls `panic()` to cause the test to fail with a message we "
"defined as the second argument of the `assert` function. Using the `assert` "
"function helps us check that our code is functioning in the way we intend."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-15](ch05-03-method-syntax.md#multiple-impl-blocks), "
"we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert` function."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:137
msgid ""
"Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from "
"Chapter 5"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the assert function. In Listing 9-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8` "
"and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:192
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle "
"can indeed hold a smaller rectangle"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:194
msgid ""
"Note that we’ve added two new lines inside the tests module: `use "
"super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a "
"regular module that follows the usual visibility rules. Because the tests "
"module is an inner module, we need to bring the code under test in the outer "
"module into the scope of the inner module."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:196
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the assert function and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:205
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:258
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the assert "
"function. As a result, our test will pass if `can_hold` returns false:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:268
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:282
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:295
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:297
msgid "Checking for panics with `should_panic`"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:299
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type "
"in Listing 9-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:301
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:303
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:341
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:343
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:352
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:379
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:390
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:392
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 9-9 where the new function "
"panics with different messages depending on whether the value is too small "
"or too large."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:433
msgid ""
"Listing 9-9: Testing for a panic with a panic message containing the error "
"message string"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:435
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:437
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:469
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:481
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:483
msgid "Running Single Tests"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:485
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:487
msgid ""
"To demonstrate how to run a single test, we’ll first create two tests "
"functions, as shown in Listing 9-10, and choose which ones to run."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:508
msgid "Listing 9-10: Two tests with two different names"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:510
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:519
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:521
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:523
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:525
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude "
"them, as shown here:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:529
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() { // code that takes an hour to run\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:545
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:555
msgid "The `expensive_test` function is listed as ignored."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:557
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:559
msgid "Testing recursive functions or loops"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:561
msgid ""
"When testing recursive functions or loops, you must provide the test with a "
"maximum amount of gas that it can consume. This prevents running infinite "
"loops or consuming too much gas, and can help you benchmark the efficiency "
"of your implementations. To do so, you must add the "
"`#[available_gas(<Number>)]` attribute on the test function. The following "
"example shows how to use it:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:592
msgid "Benchmarking the gas usage of a specific operation"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:594
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:596
msgid ""
"```rust\n"
"let initial = testing::get_available_gas();\n"
"gas::withdraw_gas().unwrap();\n"
"    /// code we want to bench.\n"
"(testing::get_available_gas() - x).print();\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:603
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:605
msgid ""
"```rust\n"
"fn sum_n(n: usize) -> usize {\n"
"    let mut i = 0;\n"
"    let mut sum = 0;\n"
"    loop {\n"
"        if i == n {\n"
"            sum += i;\n"
"            break;\n"
"        };\n"
"        sum += i;\n"
"        i += 1;\n"
"    };\n"
"    sum\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod test {\n"
"    use super::sum_n;\n"
"    use debug::PrintTrait;\n"
"    #[test]\n"
"    #[available_gas(2000000)]\n"
"    fn benchmark_sum_n_gas() {\n"
"        let initial = testing::get_available_gas();\n"
"        gas::withdraw_gas().unwrap();\n"
"        /// code we want to bench.\n"
"        let result = sum_n(10);\n"
"        (initial - testing::get_available_gas()).print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:636
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the operation benchmarked."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:649
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation "
"of the hex number). The total amount consumed by the test is slightly higher "
"at 98030, due to some extra steps required to run the entire test function."
msgstr ""

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's "
"good practice to start organizing your code as if it were. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch09-02-test-organization.md:7
msgid "Unit Tests"
msgstr ""

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the "
"test functions and to annotate the module with `cfg(test)`."
msgstr ""

#: src/ch09-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library "
"and saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb "
"cairo-test`. This includes any helper functions that might be within this "
"module, in addition to the functions annotated with `#[test]`."
msgstr ""

#: src/ch09-02-test-organization.md:34
msgid "Integration Tests"
msgstr ""

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""

#: src/ch09-02-test-organization.md:38
msgid "The `tests` Directory"
msgstr ""

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:68
msgid ""
"Enter the code in Listing 9-11 into the _src/tests/integration_test.cairo_ "
"file:"
msgstr ""

#: src/ch09-02-test-organization.md:80
msgid "Filename: src/tests/integration_test.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:82
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""

#: src/ch09-02-test-organization.md:84
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr ""

#: src/ch09-02-test-organization.md:95
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr ""

#: src/ch10-00-error-handling.md:1
msgid "Error handling"
msgstr ""

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as argument, which can be used to provide an "
"error message and performs an unwind process where all variables are dropped "
"and dictionaries squashed to ensure the soundness of the program to safely "
"terminate the execution."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:24
msgid "Running the program will produce the following output:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a felt252 error message as argument, "
"making the code more readable and maintainable."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:35
msgid "Let's consider an example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "nopanic notation"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:49
#: src/ch10-01-unrecoverable-errors-with-panic.md:84
#: src/appendix-03-derivable-traits.md:17
#: src/appendix-03-derivable-traits.md:42
#: src/appendix-03-derivable-traits.md:63
#: src/appendix-03-derivable-traits.md:85
#: src/appendix-03-derivable-traits.md:118
#: src/appendix-03-derivable-traits.md:155
msgid "Example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:57
msgid "Wrong example:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:65
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:78
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:80
msgid "panic_with attribute"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:82
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:86
msgid ""
"```rust\n"
"#[panic_with('value is 0', wrap_not_zero)]\n"
"fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
"    if value == 0 {\n"
"        Option::None\n"
"    } else {\n"
"        Option::Some(value)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    wrap_if_not_zero(0); // this returns None\n"
"    wrap_not_zero(0); // this panic with 'value is 0'\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:102
msgid "Using assert"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:104
msgid ""
"The assert function from the Cairo core library is actually a utility "
"function based on panics. It asserts that a boolean expression is true at "
"runtime, and if it is not, it calls the panic function with an error value. "
"The assert function takes two arguments: the boolean expression to verify, "
"and the error value. The error value is specified as a felt252, so any "
"string passed must be able to fit inside a felt252."
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:106
msgid "Here is an example of its usage:"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:118
msgid ""
"We are asserting in main that `my_number` is not zero to ensure that we're "
"not performing a division by 0. In this example, `my_number` is zero so the "
"assertion will fail, and the program will panic with the string 'number is "
"zero' (as a felt252) and the division will not be reached."
msgstr ""

#: src/ch10-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr ""

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""

#: src/ch10-02-recoverable-errors.md:7
msgid "The `Result` enum"
msgstr ""

#: src/ch10-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in "
"Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and "
"`Err`, as follows:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr ""

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl "
"EDrop: Drop<E>>` in the first four methods signatures. This syntax "
"represents generic type constraints in the Cairo language. These constraints "
"indicate that the associated functions require an implementation of the "
"`Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation ot the `ResultTrait` "
"[here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr ""

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None(())` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr ""

#: src/ch10-02-recoverable-errors.md:81
msgid ""
"Let's take another example demonstrating the use of `unwrap`. First we "
"import the necessary modules:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries "
"to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns "
"`Result::Err('Invalid integer')`."
msgstr ""

#: src/ch10-02-recoverable-errors.md:103
msgid "Listing 10-1: Using the Result type"
msgstr ""

#: src/ch10-02-recoverable-errors.md:105
msgid "Our two test cases are:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:107
msgid ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None(_) => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::parse_u8;\n"
"    #[test]\n"
"    fn test_felt252_to_u8() {\n"
"        let number: felt252 = 5_felt252;\n"
"        // should not panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_felt252_to_u8_panic() {\n"
"        let number: felt252 = 256_felt252;\n"
"        // should panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message 'Invalid integer'."
msgstr ""

#: src/ch10-02-recoverable-errors.md:139
msgid "We could have also used the #\\[should_panic\\] attribute here."
msgstr ""

#: src/ch10-02-recoverable-errors.md:141
msgid "The `?` operator ?"
msgstr ""

#: src/ch10-02-recoverable-errors.md:143
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:145
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""

#: src/ch10-02-recoverable-errors.md:146
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""

#: src/ch10-02-recoverable-errors.md:148
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""

#: src/ch10-02-recoverable-errors.md:150
msgid "Here is an example."
msgstr ""

#: src/ch10-02-recoverable-errors.md:152
msgid ""
"```rust,noplayground\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"
msgstr ""

#: src/ch10-02-recoverable-errors.md:161
msgid "Listing 10-1: Using the `?` operator"
msgstr ""

#: src/ch10-02-recoverable-errors.md:163
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr ""

#: src/ch10-02-recoverable-errors.md:165
msgid "And with a little test case:"
msgstr ""

#: src/ch10-02-recoverable-errors.md:167
msgid ""
"```rust,noplayground\n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None(_) => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"#     let input_to_u8: u8 = parse_u8(input)?;\n"
"#     // DO SOMETHING\n"
"#     let res = input_to_u8 - 1;\n"
"#     Result::Ok(res)\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::do_something_with_parse_u8;\n"
"#     use debug::PrintTrait;\n"
"    #[test]\n"
"    fn test_function_2() {\n"
"        let number: felt252 = 258_felt252;\n"
"        match do_something_with_parse_u8(number) {\n"
"            Result::Ok(value) => value.print(),\n"
"            Result::Err(e) => e.print()\n"
"        }\n"
"    }\n"
"# }\n"
"# \n"
"```"
msgstr ""

#: src/ch10-02-recoverable-errors.md:198
msgid "The console will print the error \"Invalid Integer\"."
msgstr ""

#: src/ch10-02-recoverable-errors.md:204
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""

#: src/ch10-02-recoverable-errors.md:206
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""

#: src/ch11-01-operator-overloading.md:10
msgid ""
"```rust\n"
"struct Potion {\n"
"    health: felt252,\n"
"    mana: felt252\n"
"}\n"
"\n"
"impl PotionAdd of Add<Potion> {\n"
"    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
"        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana, "
"}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
"    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
"    let super_potion: Potion = health_potion + mana_potion;\n"
"    // Both potions were combined with the `+` operator.\n"
"    assert(super_potion.health == 100, '');\n"
"    assert(super_potion.mana == 100, '');\n"
"}\n"
"```"
msgstr ""

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code. In Cairo, there are only two `macros`: `array![]` and "
"`consteval_int!()`."
msgstr ""

#: src/ch11-02-macros.md:5
msgid "Let's start by `array!`"
msgstr ""

#: src/ch11-02-macros.md:7
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will create an array and append all values passed to the "
"`array!` macro sequentially."
msgstr ""

#: src/ch11-02-macros.md:10
msgid "Without `array!`:"
msgstr ""

#: src/ch11-02-macros.md:21
msgid "With `array!`:"
msgstr ""

#: src/ch11-02-macros.md:27
msgid "`consteval_int!`"
msgstr ""

#: src/ch11-02-macros.md:29
msgid ""
"In some situtations, a developer might need to declare a constant that is "
"the result of a computation of integers. To compute a constant expression "
"and use its result at compile time, it is required to use the "
"`consteval_int!` macro."
msgstr ""

#: src/ch11-02-macros.md:31
msgid "Here is an example of `consteval_int!`:"
msgstr ""

#: src/ch11-02-macros.md:37
msgid "This will be interprated as `const a: felt252 = 8;` by the compiler."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts "
"for the Starknet network. Starknet is a permissionless network that "
"leverages zk-STARKs technology for scalability. As a Layer-2 scalability "
"solution for Ethereum, Starknet's goal is to offer fast, secure, and "
"low-cost transactions. It functions as a Validity Rollup (commonly known as "
"a zero-knowledge Rollup) and is built on top of the Cairo language and the "
"StarkNet VM."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections. If you want to learn more about the "
"Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this "
"functionality, you'll need to make some configurations in your `Scarb.toml` "
"file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a "
"`[[target.starknet-contract]]` section to enable contract compilation."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:17
msgid ""
"Below is the minimal Scarb.toml file required to compile a crate containing "
"Starknet contracts:"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0-rc0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please "
"refer to the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts "
"are, what are they used for and why would blockchain developers use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "Smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party softwares (called `oracles`) to access external data "
"(the price of a token for instance)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs "
"(Non-fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "Use cases"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "DeFi"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "Tokenization"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "Voting"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "Royalties"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "Decentralized identities DIDs"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "The rise of Starknet and Cairo"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain "
"Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-trilemma)) "
"in the blockchain space states that it is impossible to achieve a high level "
"of scalability, decentralization, and security simultaneously; trade-offs "
"must be made. Ethereum is at the intersection of decentralization and "
"security. Eventually, it was decided that Ethereum's purpose would be to "
"serve as a secure settlement layer, while complex computations would be "
"offloaded to other networks built on top of Ethereum. These are called Layer "
"2s (L2s)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium "
"[article](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), "
"which serves as a good primer."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/chapter_4/index.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/chapter_5/index.html)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a function `main` that serves as the entry point for this program:"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, "
"and as such, have access to Starknet's state. For a module to be handled as "
"a contract by the compiler, it must be annotated with the "
"`#[starknet::contract]` attribute."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an "
"example of a basic contract. You will learn how to write a simple contract "
"that stores a single number on the blockchain."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:5
msgid "Anatomy of a simple Starknet Contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet "
"contract. It might not be easy to understand it all at once, but we will go "
"through it step by step:"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:38
msgid "Listing 99-1: A simple storage contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:40
msgid ""
"Note: Starknet contracts are defined within "
"[modules](./ch07-02-defining-modules-to-control-scope.md)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:42
msgid "What is this contract?"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called "
"`stored_data` of type `u128` (unsigned integer of 128 bits). You can think "
"of it as a single slot in a database that you can query and alter by calling "
"functions of the code that manages the database. The contract defines and "
"exposes publically the functions `set` and `get` that can be used to modify "
"or retrieve the value of that variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes "
"to the outside world. Here, the interface exposes two functions: `set` and "
"`get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) "
"mechanism from Cairo, we can make sure that the actual implementation of the "
"contract matches its interface. In fact, you will get a compilation error if "
"your contract doesn’t conform with the declared interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:70
msgid ""
"Listing 99-1-bis: A wrong implementation of the interface of the contract. "
"This does not compile."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. The `self` "
"parameter represents the contract state. Seeing the `self` argument passed "
"to `set` tells us that this function might access the state of the contract, "
"as it is what gives us access to the contract’s storage. The `ref` modifier "
"implies that `self` may be modified, meaning that the storage variables of "
"the contract may be modified inside the `set` function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which "
"immediately tells us that it does not modify the state (and indeed, the "
"compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. In the example above, `set` and `get` are "
"public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the "
"example above, `set` and `get` are public functions."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked "
"through a transaction and that can mutate the state of the contract. `set` "
"is an external function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the "
"contract, but that cannot mutate the state of the contract. `get` is a view "
"function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the external functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. "
"The implementation block must be annotated with the `#[external(v0)]` "
"attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions "
"will not be callable from the outside. All functions defined in a block "
"marked as `#[external(v0)]` are consequently _public functions_."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter "
"corresponding to the `self` argument in the trait must be `ContractState`. "
"The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, "
"`ContractState` gives us the ability to emit events. The name "
"`ContractState` is not surprising, as it’s a representation of the "
"contract’s state, which is what we think of `self` in the contract interface "
"trait."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the "
"contract are defined under the implementation of a trait that has a "
"`TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` "
"parameter to the function, allowing access the storage variables of the "
"contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the "
"`read` and `write` methods to either read or write the value of the storage "
"variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:118
msgid ""
"Using `self` and the `write` method to modify the value of a storage variable"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, "
"attempting to modify will result in a compilation error."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a "
"single number that is accessible by anyone in the world. Anyone could call "
"`set` again with a different value and overwrite your number, but the number "
"is still stored in the history of the blockchain. Later, you will see how "
"you can impose access restrictions so that only you can alter the number."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we "
"specified the difference between _public functions, external functions and "
"view functions_, and we mentioned how to interact with _storage_."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid ""
"Where should I define functions that do not need to access the contract's "
"state?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the following example contract that we'll be using throughout this "
"chapter:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:95
msgid "Listing 99-1bis: Our reference contract for this chapter"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:3
msgid ""
"As stated previously, storage variables allow you to store data that will be "
"stored in the contract's storage that is itself stored on the blockchain. "
"These data are persistent and can be accessed and modified anytime once the "
"contract is deployed."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:19
msgid "Listing 99-2: A Storage Struct"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:21
msgid ""
"The storage struct is a "
"[struct](./ch05-00-using-structs-to-structure-related-data.md) like any "
"other, except that it **must** be annotated with `#[storage]` allowing you "
"to store mappings using the `LegacyMap` type."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:24
msgid "Storing data types"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:26
msgid ""
"The base address `StorageBaseAddress` of a value in storage is "
"`sn_keccak(variable_name)`, with `variable_name` as the ASCII encoding of "
"the variable's name. As the keccak256 hash function produces an output of "
"256 bits that doesn't fit in a `felt252`, we use `sn_keccak` which is "
"defined as the first 250 bits of the Keccak256 hash."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:28
msgid "Storing structs"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:30
msgid ""
"Most types from the core library, such as unsigned integers (`u8`, `u128`, "
"`u256`...), `felt252`, `bool`, `ContractAddress`, etc. implement the `Store` "
"trait and can thus be stored without further action. But what if you wanted "
"to store a struct that you defined yourself? In that case, you have to "
"explicitly tell the compiler how to store your struct. In our example, we "
"want to store a `Person` struct in storage, which is possible by "
"implementing the `Store` trait for the `Person` type. This can be achieved "
"by simply adding a `#[derive(starknet::Store)]` attribute on top of our "
"struct definition."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:41
msgid ""
"The base storage address for structs remains `sn_keccak(variable_name)`, and "
"the value contained at this address is the first primitive type contained by "
"the struct."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:43
msgid ""
"Subsequent fields are stored in addresses contiguous to the first elements "
"at addresses `base_address + i`."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:45
msgid "Storing mappings"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:47
msgid ""
"Mappings are a key-value data structure that you can use to store data "
"within a smart contract. They are essentially hash tables that allow you to "
"associate a unique key with a corresponding value. Mappings are also useful "
"to store sets of data, as it's impossible to store arrays in storage."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:49
msgid ""
"A mapping is a variable of type `LegacyMap`, in which the key and value "
"types are specified within angular brackets `<>`. It is important to note "
"that the `LegacyMap` type can only be used inside the `Storage` struct, and "
"can't be used to define mappings in user-defined structs."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:52
msgid ""
"You can also create more complex mappings than that; you can find one in "
"Listing 99-2bis like the popular `allowances` storage variable in the ERC20 "
"Standard which maps the `owner` and `spender` to the `allowance` using "
"tuples:"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:61
msgid "Listing 99-2bis: Storing mappings"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:63
msgid ""
"In mappings, the address of the value at key `k_1,...,k_n` is "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ is the "
"Pedersen hash and the final value is taken `mod (2^251) − 256`."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:65
msgid ""
"If the key of the mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the Hash trait, "
"which can be derived with the `#[derive(Hash)]` attribute. For example, if "
"you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:67
msgid ""
"Similarly, in the case of a nested mapping such as "
"`LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be "
"computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:69
msgid ""
"You can learn more about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:71
msgid "Reading from Storage"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:73
msgid ""
"To read the value of the storage variable `names`, we call the `read` "
"function on the `names` storage variable, passing in the key `address` as a "
"parameter."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:79
msgid "Listing 99-3: Calling the `read` function on the `names` variable"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:81
msgid ""
"Note: When the storage variable does not store a mapping, its value is "
"accessed without passing any parameters to the read method"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:83
msgid "Writing to Storage"
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:85
msgid ""
"To write a value to the storage variable `names`, we call the `write` "
"function on the `names` storage variable, passing in the key and values as "
"arguments."
msgstr ""

#: src/ch99-01-03-01-storage-variables.md:91
msgid "Listing 99-4: Writing to the `names` variable"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in contracts:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:5
msgid "1. Constructors"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:7
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:24
msgid "2. Public functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They must be defined inside an implementation block annotated with "
"the `#[external(v0)]` attribute. This attribute only affects the visibility "
"(public vs private/internal), but it doesn't inform us on the ability of "
"these functions to modify the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:43
msgid "External functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:45
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally. "
"External functions are _public_ functions where the `self: ContractState` is "
"passed as reference with the `ref` keyword, allowing you to modify the state "
"of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:55
msgid "View functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:57
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They "
"can be called by other contracts or externally. View functions are _public_ "
"functions where the `self: ContractState` is passed as snapshot, preventing "
"you from modifying the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:67
msgid ""
"**Note:** It's important to note that both external and view functions are "
"public. To create an internal function in a contract, you will need to "
"define it outside of the implementation block annotated with the "
"`#[external(v0)]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:69
msgid "3. Private functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"Functions that are not defined in a block annotated with the "
"`#[external(v0)]` attribute are private functions (also called internal "
"functions). They can only be called from within the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:86
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next "
"section](./ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:88
msgid ""
"At this point, you might still be wondering if all of this is really "
"necessary if you don't need to access the contract's state in your function "
"(for example, a helper/library function). As a matter of fact, you can also "
"define internal functions outside of implementation blocks. The only reason "
"why we _need_ to define functions inside impl blocks is if we want to access "
"the contract's state."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:1
#: src/ch99-01-05-00-components.md:29
msgid "Events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract "
"could lead to a bad user experience. This is because users may not see their "
"NFTs appear in their wallets (wallets use these indexers to display a user's "
"NFTs)."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:9
msgid "Defining events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, "
"which implements the `starknet::Event` trait, as enum variants. This trait "
"is defined in the core library as follows:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the Event type, "
"which in our example is the following enum:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and "
"each variant needs to implement the `starknet::Event` trait itself. "
"Moreover, the members of these variants must implement the `Serde` trait "
"(_c.f._ [Appendix C: Serializing with "
"Serde](./appendix-03-derivable-traits.md)), as keys/data are added to the "
"event using a serialization process."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the Event trait for the variant’s type ."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with "
"the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [address]`."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:48
msgid "Emitting events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:50
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a "
"contract that didn't have any corresponding trait."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:18
msgid ""
"It's not the first time that we encounter this attribute, we already talked "
"about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this "
"section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:20
msgid ""
"Recall that in order to access the ContractState in a function, this "
"function must be defined in an implementation block whose generic parameter "
"is `ContractState`. This implies that we first need to define a generic "
"trait that takes a `TContractState`, and then implement this trait for the "
"`ContractState` type. But by using the `#[generate_trait]` attribute, this "
"whole process can be skipped and we can simply define the implementation "
"block directly, without any generic parameter, and use `self: ContractState` "
"in our functions."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:23
msgid ""
"If we had to manually define the trait for the `InternalFunctions` "
"implementation, it would look something like this:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bit as possible to store a piece "
"of data. When done well, it can significantly reduce the size of the data "
"you need to store. This is especially important in smart contracts, where "
"storage is expensive."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated to a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred to the users of your smart contract."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"a fewer number of storage slots. For example, consider a `Sizes` struct with "
"3 fields of different types. The total size is 8 + 32 + 64 = 104 bits. This "
"is less than the 128 bits of a single `u128`. This means we can pack all 3 "
"fields into a single `u128` variable. Since a storage slot can hold up to "
"251 bits, our packed value will take only one storage slot instead of 3."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:10
msgid ""
"```rust\n"
"use starknet::{StorePacking};\n"
"use integer::{u128_safe_divmod, u128_as_non_zero};\n"
"\n"
"#[derive(Drop, Serde)]\n"
"struct Sizes {\n"
"    tiny: u8,\n"
"    small: u32,\n"
"    medium: u64,\n"
"}\n"
"\n"
"const TWO_POW_8: u128 = 0x100;\n"
"const TWO_POW_40: u128 = 0x10000000000;\n"
"\n"
"const MASK_8: u128 = 0xff;\n"
"const MASK_32: u128 = 0xffffffff;\n"
"\n"
"\n"
"impl SizesStorePacking of StorePacking<Sizes, u128> {\n"
"    fn pack(value: Sizes) -> u128 {\n"
"        value.tiny.into() + (value.small.into() * TWO_POW_8) + "
"(value.medium.into() * TWO_POW_40)\n"
"    }\n"
"\n"
"    fn unpack(value: u128) -> Sizes {\n"
"        let tiny = value & MASK_8;\n"
"        let small = (value / TWO_POW_8) & MASK_32;\n"
"        let medium = (value / TWO_POW_40);\n"
"\n"
"        Sizes {\n"
"            tiny: tiny.try_into().unwrap(),\n"
"            small: small.try_into().unwrap(),\n"
"            medium: medium.try_into().unwrap(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SizeFactory {\n"
"    use super::Sizes;\n"
"    use super::SizesStorePacking; //don't forget to import it!\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        remaining_sizes: Sizes\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    fn update_sizes(ref self: ContractState, sizes: Sizes) {\n"
"        // This will automatically pack the\n"
"        // struct into a single u128\n"
"        self.remaining_sizes.write(sizes);\n"
"    }\n"
"\n"
"\n"
"    #[external(v0)]\n"
"    fn get_sizes(ref self: ContractState) -> Sizes {\n"
"        // this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
"        self.remaining_sizes.read()\n"
"    }\n"
"}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by "
"performing bitshift and additions. The `unpack` reverses this process to "
"extract the original fields back into a struct."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the "
"operations performed in the example: The goal is to pack the `tiny`, "
"`small`, and `medium` fields into a single `u128` value. First, when packing:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. "
"This creates a `u128` value with the low 8 bits set to `tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the "
"value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we "
"add `tiny` to `small` to combine them into a single `u128` value. The value "
"of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits "
"(`TWO_POW_40`) to make space for the previous fields. This takes bits 40-103."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& "
"MASK_8`). This isolates the lowest 8 bits of the packed value, which is "
"`tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the "
"bitmask, then use bitwise AND with the 32 ones bitmask."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, "
"we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important details, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr ""

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr ""

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch99-01-05-00-components.md:30
msgid "External and internal functions"
msgstr ""

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr ""

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[Contracts](./ch99-01-02-a-simple-contract.md)."
msgstr ""

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the "
"[Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md) "
"pattern."
msgstr ""

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr ""

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr ""

#: src/ch99-01-05-00-components.md:167
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""

#: src/ch99-01-05-00-components.md:171
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:177
msgid "A closer look at the `impl` block"
msgstr ""

#: src/ch99-01-05-00-components.md:188
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""

#: src/ch99-01-05-00-components.md:193
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) "
"section."
msgstr ""

#: src/ch99-01-05-00-components.md:201
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""

#: src/ch99-01-05-00-components.md:207
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""

#: src/ch99-01-05-00-components.md:210
msgid "Migrating a Contract to a Component"
msgstr ""

#: src/ch99-01-05-00-components.md:212
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""

#: src/ch99-01-05-00-components.md:216
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr ""

#: src/ch99-01-05-00-components.md:217
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""

#: src/ch99-01-05-00-components.md:219
msgid "Adding generic parameters to the `impl` block:"
msgstr ""

#: src/ch99-01-05-00-components.md:220
msgid "Adding `TContractState` as a generic parameter."
msgstr ""

#: src/ch99-01-05-00-components.md:221
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr ""

#: src/ch99-01-05-00-components.md:222
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""

#: src/ch99-01-05-00-components.md:225
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""

#: src/ch99-01-05-00-components.md:230
msgid "Using components inside a contract"
msgstr ""

#: src/ch99-01-05-00-components.md:232
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""

#: src/ch99-01-05-00-components.md:236
msgid "Declare it with the `component!()` macro, specifying"
msgstr ""

#: src/ch99-01-05-00-components.md:238
msgid "The path to the component `path::to::component`."
msgstr ""

#: src/ch99-01-05-00-components.md:239
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""

#: src/ch99-01-05-00-components.md:241
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""

#: src/ch99-01-05-00-components.md:244
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""

#: src/ch99-01-05-00-components.md:249
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""

#: src/ch99-01-05-00-components.md:252
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""

#: src/ch99-01-05-00-components.md:257
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""

#: src/ch99-01-05-00-components.md:263
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""

#: src/ch99-01-05-00-components.md:301
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""

#: src/ch99-01-05-00-components.md:314
msgid "Stacking Components for Maximum Composability"
msgstr ""

#: src/ch99-01-05-00-components.md:316
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You will be able to "
"rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""

#: src/ch99-01-05-00-components.md:322
msgid ""
"Developers can focus on their core contract logic while relying on "
"battle-tested and audited components for everything else."
msgstr ""

#: src/ch99-01-05-00-components.md:325
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch99-01-05-01-components-under-the-hood)."
msgstr ""

#: src/ch99-01-05-00-components.md:330
msgid "Troubleshooting"
msgstr ""

#: src/ch99-01-05-00-components.md:332
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""

#: src/ch99-01-05-00-components.md:336
msgid "`Trait not found. Not a trait.`"
msgstr ""

#: src/ch99-01-05-00-components.md:338
msgid ""
"This error can occur when you're not importing the component's impl block "
"correctly in your contract. Make sure to respect the following syntax:"
msgstr ""

#: src/ch99-01-05-00-components.md:346
msgid "Referring to our previous example, this would be:"
msgstr ""

#: src/ch99-01-05-00-components.md:353
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`"
msgstr ""

#: src/ch99-01-05-00-components.md:356
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on "
"the action to take. Basically, you forgot to add the component's storage to "
"your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's "
"storage."
msgstr ""

#: src/ch99-01-05-00-components.md:361
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:`"
msgstr ""

#: src/ch99-01-05-00-components.md:364
msgid ""
"Similar to the previous error, the compiler, you forgot to add the "
"component's events to your contract's events. Make sure to add the path to "
"the component's events to your contract's events."
msgstr ""

#: src/ch99-01-05-00-components.md:368
msgid "Components functions are not accessible externally"
msgstr ""

#: src/ch99-01-05-00-components.md:370
msgid ""
"This can happen if you forgot to annotate the component's impl block with "
"`#[abi(embed_v0)]`. Make sure to add this annotation when embedding the "
"component's impl in your contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to StarkNet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid "Before digging into components, we need to understand _embeddable impls_."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:74
msgid ""
"```rust\n"
"// generated per component\n"
"trait HasComponent<TContractState> {\n"
"    fn get_component(self: @TContractState) -> "
"@ComponentState<TContractState>;\n"
"    fn get_component_mut(ref self: TContractState) -> "
"ComponentState<TContractState>;\n"
"    fn get_contract(self: @ComponentState<TContractState>) -> "
"@TContractState;\n"
"    fn get_contract_mut(ref self: ComponentState<TContractState>) -> "
"TContractState;\n"
"    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: "
"ComponentState<TContractState>, event: S);\n"
"}\n"
"```"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch99-01-05-02-component-dependencies.md) section."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "Contract Integration"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes "
"publically. It specifies the function signatures (name, parameters, "
"visibility and return value) contained in a smart contract without including "
"the function body."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "Listing 99-4: A simple ERC20 Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid ""
"Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 99-4):"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:21
msgid ""
"```rust,noplayground\n"
"use starknet::{ContractAddress};\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: ContractAddress,\n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
"    fn name(\n"
"        self: IERC20Dispatcher\n"
"    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "Listing 99-5: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:56
msgid ""
"```rust,noplayground\n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait IERC20<TContractState> {\n"
"#     fn name(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn symbol(self: @TContractState) -> felt252;\n"
"# \n"
"#     fn decimals(self: @TContractState) -> u8;\n"
"# \n"
"#     fn total_supply(self: @TContractState) -> u256;\n"
"# \n"
"#     fn balance_of(self: @TContractState, account: ContractAddress) -> "
"u256;\n"
"# \n"
"#     fn allowance(self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress) -> u256;\n"
"# \n"
"#     fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"# \n"
"#     fn transfer_from(\n"
"#         ref self: TContractState, sender: ContractAddress, recipient: "
"ContractAddress, amount: u256\n"
"#     ) -> bool;\n"
"# \n"
"#     fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"u256) -> bool;\n"
"# }\n"
"# \n"
"# #[starknet::interface]\n"
"# trait ITokenWrapper<TContractState> {\n"
"#     fn token_name(self: @TContractState, contract_address: "
"ContractAddress) -> felt252;\n"
"# \n"
"#     fn transfer_token(\n"
"#         ref self: TContractState,\n"
"#         contract_address: ContractAddress,\n"
"#         recipient: ContractAddress,\n"
"#         amount: u256\n"
"#     ) -> bool;\n"
"# }\n"
"# \n"
"# \n"
"//**** Specify interface here ****//\n"
"#[starknet::contract]\n"
"mod TokenWrapper {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use super::ITokenWrapper;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    impl TokenWrapper of ITokenWrapper<ContractState> {\n"
"        fn token_name(self: @ContractState, contract_address: "
"ContractAddress) -> felt252 {\n"
"            IERC20Dispatcher { contract_address }.name()\n"
"        }\n"
"\n"
"        fn transfer_token(\n"
"            ref self: ContractState,\n"
"            contract_address: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) -> bool {\n"
"            IERC20Dispatcher { contract_address }.transfer(recipient, "
"amount)\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "Listing 99-6: A sample contract which uses the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:141
msgid ""
"```rust,noplayground\n"
"use starknet::ContractAddress;\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Store, Serde)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash,\n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of "
"IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
"    fn name(\n"
"        self: IERC20LibraryDispatcher\n"
"    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called in "
"here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: "
"u256\n"
"    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "Listing 99-7: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid "Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:208
msgid "Listing 99-8: A sample contract using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractBDispatcherTrait` and `IContractBLibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractBLibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in ContractB, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:212
msgid "Using low-level syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:214
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system "
"calls. The dispatchers we described in the previous sections are high-level "
"syntaxes for these low-level system calls."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:216
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:252
msgid "Listing 99-9: A sample contract using syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:254
msgid ""
"To use this syscall, we passed in the contract address, the function "
"selector (which is the `starknet_keccak` hash of the function name), and the "
"calldata (function arguments). At the end, we get returned a serialized "
"value which we'll need to deserialize ourselves!"
msgstr ""

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:13
msgid ""
"```rust,noplayground\n"
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
"use starknet::ContractAddress;\n"
"\n"
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
"#[starknet::interface]\n"
"trait VoteTrait<T> {\n"
"    /// @dev Function that returns the current vote status\n"
"    fn get_vote_status(self: @T) -> (u8, u8, u8, u8);\n"
"    /// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
"    fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool;\n"
"    /// @dev Function that checks if the specified address is registered as "
"a voter\n"
"    fn is_voter_registered(self: @T, address: ContractAddress) -> bool;\n"
"    /// @dev Function that allows a user to vote\n"
"    fn vote(ref self: T, vote: u8);\n"
"}\n"
"\n"
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
"#[starknet::contract]\n"
"mod Vote {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    const YES: u8 = 1_u8;\n"
"    const NO: u8 = 0_u8;\n"
"\n"
"    /// @dev Structure that stores vote counts and voter states\n"
"    #[storage]\n"
"    struct Storage {\n"
"        yes_votes: u8,\n"
"        no_votes: u8,\n"
"        can_vote: LegacyMap::<ContractAddress, bool>,\n"
"        registered_voter: LegacyMap::<ContractAddress, bool>,\n"
"    }\n"
"\n"
"    /// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        voter_1: ContractAddress,\n"
"        voter_2: ContractAddress,\n"
"        voter_3: ContractAddress\n"
"    ) {\n"
"        // Register all voters by calling the _register_voters function\n"
"        self._register_voters(voter_1, voter_2, voter_3);\n"
"\n"
"        // Initialize the vote count to 0\n"
"        self.yes_votes.write(0_u8);\n"
"        self.no_votes.write(0_u8);\n"
"    }\n"
"\n"
"    /// @dev Event that gets emitted when a vote is cast\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        VoteCast: VoteCast,\n"
"        UnauthorizedAttempt: UnauthorizedAttempt,\n"
"    }\n"
"\n"
"    /// @dev Represents a vote that was cast\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct VoteCast {\n"
"        voter: ContractAddress,\n"
"        vote: u8,\n"
"    }\n"
"\n"
"    /// @dev Represents an unauthorized attempt to vote\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UnauthorizedAttempt {\n"
"        unauthorized_address: ContractAddress,\n"
"    }\n"
"\n"
"    /// @dev Implementation of VoteTrait for ContractState\n"
"    #[external(v0)]\n"
"    impl VoteImpl of super::VoteTrait<ContractState> {\n"
"        /// @dev Returns the voting results\n"
"        fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) {\n"
"            let (n_yes, n_no) = self._get_voting_result();\n"
"            let (yes_percentage, no_percentage) = "
"self._get_voting_result_in_percentage();\n"
"            (n_yes, n_no, yes_percentage, no_percentage)\n"
"        }\n"
"\n"
"        /// @dev Check whether a voter is allowed to vote\n"
"        fn voter_can_vote(self: @ContractState, user_address: "
"ContractAddress) -> bool {\n"
"            self.can_vote.read(user_address)\n"
"        }\n"
"\n"
"        /// @dev Check whether an address is registered as a voter\n"
"        fn is_voter_registered(self: @ContractState, address: "
"ContractAddress) -> bool {\n"
"            self.registered_voter.read(address)\n"
"        }\n"
"\n"
"        /// @dev Submit a vote\n"
"        fn vote(ref self: ContractState, vote: u8) {\n"
"            assert(vote == NO || vote == YES, 'VOTE_0_OR_1');\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            self._assert_allowed(caller);\n"
"            self.can_vote.write(caller, false);\n"
"\n"
"            if (vote == NO) {\n"
"                self.no_votes.write(self.no_votes.read() + 1_u8);\n"
"            }\n"
"            if (vote == YES) {\n"
"                self.yes_votes.write(self.yes_votes.read() + 1_u8);\n"
"            }\n"
"\n"
"            self.emit(VoteCast { voter: caller, vote: vote, });\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Internal Functions implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        /// @dev Registers the voters and initializes their voting status to "
"true (can vote)\n"
"        fn _register_voters(\n"
"            ref self: ContractState,\n"
"            voter_1: ContractAddress,\n"
"            voter_2: ContractAddress,\n"
"            voter_3: ContractAddress\n"
"        ) {\n"
"            self.registered_voter.write(voter_1, true);\n"
"            self.can_vote.write(voter_1, true);\n"
"\n"
"            self.registered_voter.write(voter_2, true);\n"
"            self.can_vote.write(voter_2, true);\n"
"\n"
"            self.registered_voter.write(voter_3, true);\n"
"            self.can_vote.write(voter_3, true);\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Asserts implementation for the Vote contract\n"
"    #[generate_trait]\n"
"    impl AssertsImpl of AssertsTrait {\n"
"        // @dev Internal function that checks if an address is allowed to "
"vote\n"
"        fn _assert_allowed(ref self: ContractState, address: "
"ContractAddress) {\n"
"            let is_voter: bool = self.registered_voter.read((address));\n"
"            let can_vote: bool = self.can_vote.read((address));\n"
"\n"
"            if (can_vote == false) {\n"
"                self.emit(UnauthorizedAttempt { unauthorized_address: "
"address, });\n"
"            }\n"
"\n"
"            assert(is_voter == true, 'USER_NOT_REGISTERED');\n"
"            assert(can_vote == true, 'USER_ALREADY_VOTED');\n"
"        }\n"
"    }\n"
"\n"
"    /// @dev Implement the VotingResultTrait for the Vote contract\n"
"    #[generate_trait]\n"
"    impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {\n"
"        // @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
"        fn _get_voting_result(self: @ContractState) -> (u8, u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            (n_yes, n_no)\n"
"        }\n"
"\n"
"        // @dev Internal function to calculate the voting results in "
"percentage\n"
"        fn _get_voting_result_in_percentage(self: @ContractState) -> (u8, "
"u8) {\n"
"            let n_yes: u8 = self.yes_votes.read();\n"
"            let n_no: u8 = self.no_votes.read();\n"
"\n"
"            let total_votes: u8 = n_yes + n_no;\n"
"\n"
"            if (total_votes == 0_u8) {\n"
"                return (0, 0);\n"
"            }\n"
"            let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);\n"
"            let no_percentage: u8 = (n_no * 100_u8) / (total_votes);\n"
"\n"
"            (yes_percentage, no_percentage)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:191
msgid "Voting smart contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:195
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:197
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [Local Development with "
"Katana](https://book.starknet.io/chapter_3/katana.html) chapter of the "
"Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md). "
"It will allow you to do everything you need to do with Starknet, but "
"locally. It is a great tool for development and testing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Local "
"Development with Katana](https://book.starknet.io/chapter_3/katana.html) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:210
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:216
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:237
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [Account "
"Abstraction](https://book.starknet.io/chapter_4/index.html) chapter of the "
"Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:239
msgid "Smart wallets for voting"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:241
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the [Environment "
"setup](https://book.starknet.io/chapter_1/environment_setup.html) chapter of "
"the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:243
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the [Environment "
"setup](https://book.starknet.io/chapter_1/environment_setup.html) chapter of "
"the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Firstly, we create a signer from a private key:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:253
msgid "Then, we create the Account Descriptor:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:259
msgid ""
"The Account Descriptor will look like this. You can get the public key and "
"the smart wallet address from the output of the initial `katana` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:261
msgid ""
"```bash\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"        \"type\": \"open_zeppelin\",\n"
"        \"version\": 1,\n"
"        \"public_key\": \"<SMART_WALLET_PUBLIC_KEY>\"\n"
"  },\n"
"    \"deployment\": {\n"
"        \"status\": \"deployed\",\n"
"        \"class_hash\": \"<SMART_WALLET_CLASS_HASH>\",\n"
"        \"address\": \"<SMART_WALLET_ADDRESS>\"\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:277
msgid ""
"Copy the Account Descriptor above and paste in the newly created "
"`account0_account.json file`, then replace \"\\<SMART_WALLET_PUBLIC_KEY>\", "
"\"\\<SMART_WALLET_CLASS_HASH>\" and \"\\<SMART_WALLET_ADDRESS>\" with values "
"from the `katana` account used."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:279
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:281
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:291
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:293
msgid "Contract Deployment"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:295
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:297
msgid ""
"```bash\n"
"starkli declare target/dev/starknetbook_chapter_2_Vote.sierra.json --rpc "
"http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:301
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:303
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:305
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can find it [on any block "
"explorer](https://goerli.voyager.online/class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:307
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:309
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:311
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:313
msgid ""
"```bash\n"
"starkli deploy <class_hash_of_the_contract_to_be_deployed> <voter_0_address> "
"<voter_1_address> <voter_2_address> --rpc http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:317
msgid "An example command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:319
msgid ""
"```bash\n"
"starkli deploy "
"0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c "
"0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc "
"http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:323
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:325
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:327
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:329
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:331
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:333
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:337
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:339
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:341
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:343
msgid ""
"```bash\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:347
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:349
msgid "Casting a Vote"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:351
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:353
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:355
msgid ""
"```bash\n"
"//Voting Yes\n"
"starkli invoke "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 "
"--rpc http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"\n"
"//Voting No\n"
"starkli invoke "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 "
"--rpc http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:363
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:365
msgid ""
"```bash\n"
"starkli transaction <TRANSACTION_HASH> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:369
msgid "This returns:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:371
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": "
"\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\",\n"
"  \"max_fee\": \"0x430e81\",\n"
"  \"version\": \"0x1\",\n"
"  \"signature\": [\n"
"    \"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\",\n"
"    \"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\"\n"
"  ],\n"
"  \"nonce\": \"0x3\",\n"
"  \"type\": \"INVOKE\",\n"
"  \"sender_address\": "
"\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\",\n"
"  \"calldata\": [\n"
"    \"0x1\",\n"
"    \"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\",\n"
"    \"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\",\n"
"    \"0x0\",\n"
"    \"0x1\",\n"
"    \"0x1\",\n"
"    \"0x1\"\n"
"  ]\n"
"}\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:397
msgid ""
"```bash\n"
"Error: code=ContractError, message=\"Contract error\"\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:401
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:403
msgid ""
"```bash\n"
"...\n"
"Transaction execution error: \"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:411
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:417
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:419
msgid ""
"```bash\n"
"starkli invoke "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 "
"--rpc http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account1_account.json --keystore "
"~/.starkli-wallets/deployer/account1_keystore.json\n"
"\n"
"starkli invoke "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 "
"--rpc http://0.0.0.0:5050 --account "
"~/.starkli-wallets/deployer/account2_account.json --keystore "
"~/.starkli-wallets/deployer/account2_keystore.json\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:425
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:427
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:429
msgid ""
"```bash\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"get_vote_status --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:433
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being solidity or "
"cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automatized by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "The StarknetMessaging Contract"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6) "
"with functions allowing to send message to L2, receiving messages on L1 from "
"L2 and canceling messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid " Starknet messaging contract interface"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) "
"where we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check those addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:64
msgid ""
"```js\n"
"// Sends a message on Starknet with a single felt.\n"
"function sendMessageFelt(\n"
"    uint256 contractAddress,\n"
"    uint256 selector,\n"
"    uint256 myFelt\n"
")\n"
"    external\n"
"    payable\n"
"{\n"
"    // We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
"    uint256[] memory payload = new uint256[](1);\n"
"    payload[0] = myFelt;\n"
"\n"
"    // msg.value must always be >= 20_000 wei.\n"
"    _snMessaging.sendMessageToL2{value: msg.value}(\n"
"        contractAddress,\n"
"        selector,\n"
"        payload\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the cairo serialization scheme."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be "
"executed by the sequencer is not bound to any account (the message "
"originates from L1), you must also ensure that you pay enough fees on L1 for "
"your message to be deserialized and processed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:108
msgid "The parameters are as follow:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:110
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:114
msgid "On the Starknet side, to receive this message, we have:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid ""
"```rust\n"
"    #[l1_handler]\n"
"    fn msg_handler_felt(ref self: ContractState, from_address: felt252, "
"my_felt: felt252) {\n"
"        assert(from_address == self.allowed_message_sender.read(), 'Invalid "
"message sender');\n"
"\n"
"        // You can now use the data, automatically deserialized from the "
"message payload.\n"
"        assert(my_felt == 123, 'Invalid value');\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:126
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid "Sending messages from Starknet to Ethereum"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid ""
"```rust\n"
"        fn send_message_felt(ref self: ContractState, to_address: "
"EthAddress, my_felt: felt252) {\n"
"            // Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
"            starknet::send_message_to_l1_syscall(to_address.into(), "
"array![my_felt].span())\n"
"                .unwrap();\n"
"        }\n"
"```"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:143
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid ""
"On L1, the important part is to build the same payload as on L2. Then you "
"call `consumeMessageFromL2` by passing the L2 contract address and the "
"payload. Please be aware that the L2 contract address expected by the "
"`consumeMessageFromL2` is the contract address of the account that sends the "
"transaction on L2, and not the address of the contract executing the "
"`send_message_to_l1_syscall`."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:149
msgid ""
"```js\n"
"function consumeMessageFelt(\n"
"    uint256 fromAddress,\n"
"    uint256[] calldata payload\n"
")\n"
"    external\n"
"{\n"
"    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, "
"payload);\n"
"    \n"
"    // You can use the message hash if you want here.\n"
"\n"
"    // We expect the payload to contain only a felt252 value (which is a "
"uint256 in solidity).\n"
"    require(payload.length == 1, \"Invalid payload\");\n"
"\n"
"    uint256 my_felt = payload[0];\n"
"    \n"
"    // From here, you can safely use `my_felt` as the message has beed "
"verified by StarknetMessaging.\n"
"    require(my_felt > 0, \"Invalid value\");\n"
"}\n"
"```"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:170
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message. But we are actually using the "
"`consumeMessageFromL2` to validate the inputs (the sender address on L2 and "
"the payload) to ensure we are only consuming valid messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximatively 4 bits smaller than `uint256`. So we have to "
"pay attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid "Cairo Serde"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:175
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. On solidity, we have "
"`uint256` type, and `felt252` are approximatively 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:179
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:188
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a paylaod from L1 with **TWO** values."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:190
msgid ""
"```js\n"
"uint256[] memory payload = new uint256[](2);\n"
"// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
"payload[0] = 1;\n"
"payload[1] = 0;\n"
"```"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:197
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:199
msgid ""
"You can also find a [detailed guide "
"here](https://github.com/glihm/starknet-messaging-dev) to test the messaging "
"in local."
msgstr ""

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chances of "
"unexpected behavior or vulnerabilities."
msgstr ""

#: src/ch99-03-security-considerations.md:11
msgid "Disclaimer"
msgstr ""

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""

#: src/ch99-03-security-considerations.md:17
msgid "Mindset"
msgstr ""

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contracts flows are designed, not much from "
"the language itself."
msgstr ""

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""

#: src/ch99-03-security-considerations.md:23
msgid "Viewing smart contract as Finite State Machines"
msgstr ""

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert` or `panic` functions can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with "
"panic](./ch10-01-unrecoverable-errors-with-panic.md) page."
msgstr ""

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr ""

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr ""

#: src/ch99-03-security-considerations.md:34
msgid "Execution requirements"
msgstr ""

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr ""

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr ""

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert` function to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""

#: src/ch99-03-security-considerations.md:53
msgid "Recommendations"
msgstr ""

#: src/ch99-03-security-considerations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr ""

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""

#: src/ch99-03-security-considerations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr ""

#: src/ch99-03-security-considerations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch99-03-security-considerations.md:67
msgid "Access control"
msgstr ""

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""

#: src/ch99-03-security-considerations.md:73
msgid ""
"```rust,noplayground\n"
"#[starknet::contract]\n"
"mod access_control_contract {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    trait IContract<TContractState> {\n"
"        fn is_owner(self: @TContractState) -> bool;\n"
"        fn is_role_a(self: @TContractState) -> bool;\n"
"        fn only_owner(self: @TContractState);\n"
"        fn only_role_a(self: @TContractState);\n"
"        fn only_allowed(self: @TContractState);\n"
"        fn set_role_a(ref self: TContractState, _target: ContractAddress, "
"_active: bool);\n"
"        fn role_a_action(ref self: ContractState);\n"
"        fn allowed_action(ref self: ContractState);\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Role 'owner': only one address\n"
"        owner: ContractAddress,\n"
"        // Role 'role_a': a set of addresses\n"
"        role_a: LegacyMap::<ContractAddress, bool>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    // Guard functions to check roles\n"
"\n"
"    impl Contract of IContract<ContractState> {\n"
"        #[inline(always)]\n"
"        fn is_owner(self: @ContractState) -> bool {\n"
"            self.owner.read() == get_caller_address()\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn is_role_a(self: @ContractState) -> bool {\n"
"            self.role_a.read(get_caller_address())\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_owner(self: @ContractState) {\n"
"            assert(Contract::is_owner(self), 'Not owner');\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn only_role_a(self: @ContractState) {\n"
"            assert(Contract::is_role_a(self), 'Not role A');\n"
"        }\n"
"\n"
"        // You can easily combine guards to perfom complex checks\n"
"        fn only_allowed(self: @ContractState) {\n"
"            assert(Contract::is_owner(self) || Contract::is_role_a(self), "
"'Not allowed');\n"
"        }\n"
"\n"
"        // Functions to manage roles\n"
"\n"
"        fn set_role_a(ref self: ContractState, _target: ContractAddress, "
"_active: bool) {\n"
"            Contract::only_owner(@self);\n"
"            self.role_a.write(_target, _active);\n"
"        }\n"
"\n"
"        // You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
"\n"
"        fn role_a_action(ref self: ContractState) {\n"
"            Contract::only_role_a(@self);\n"
"        // ...\n"
"        }\n"
"\n"
"        fn allowed_action(ref self: ContractState) {\n"
"            Contract::only_allowed(@self);\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch99-03-security-considerations.md:155
msgid "Static analysis tool"
msgstr ""

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr ""

#: src/ch99-03-security-considerations.md:163
msgid ""
"[Semgrep Cairo 1.0 "
"support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr ""

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`of` - Implementation a trait"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`trait` - Define a trait"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
msgid "Reserved keywords"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "Built-in functions"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""

#: src/appendix-01-keywords.md:85
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates "
"to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B: Operators and Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "Table B-1: Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Operator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:65
#: src/appendix-02-operators-and-symbols.md:75
#: src/appendix-02-operators-and-symbols.md:88
#: src/appendix-02-operators-and-symbols.md:96
#: src/appendix-02-operators-and-symbols.md:105
#: src/appendix-02-operators-and-symbols.md:119
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Bitwise or logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
#: src/appendix-02-operators-and-symbols.md:39
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
#: src/appendix-02-operators-and-symbols.md:22
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`MulEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "Snapshot"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`*var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`Add`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`var += expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`AddEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`expr, expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
#: src/appendix-02-operators-and-symbols.md:27
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`-expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Neg`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Sub`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`var -= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`SubEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`fn(...) -> type`, "
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "\\|...\\| -> type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr.ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "Member access"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`Div`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`var /= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`DivEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
#: src/appendix-02-operators-and-symbols.md:34
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`pat: type`, `ident: type`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:41
#: src/appendix-02-operators-and-symbols.md:42
msgid "`PartialOrd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "Less than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`var = expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "Equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "Greater than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "expr \\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\|\\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:53
msgid "Table B-2: Stand-Alone Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:65
#: src/appendix-02-operators-and-symbols.md:75
#: src/appendix-02-operators-and-symbols.md:88
#: src/appendix-02-operators-and-symbols.md:96
#: src/appendix-02-operators-and-symbols.md:105
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, etc."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "Short string"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:63
msgid "Table B-3: Path-Related Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:67
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:67
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:73
msgid "Table B-4: Generics"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:77
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:77
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid ""
"Specifies parameters to generic type, function, or method in an expression; "
"often referred to as turbofish"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "Define generic function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:86
msgid "Table B-5: Macros and Attributes"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:90
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:90
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Table B-6 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid "Table B-6: Comments"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7: Tuples"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:115
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:117
msgid "Table B-8: Curly Brackets"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:119
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`struct` literal"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:9
msgid ""
"The list of derivable traits provided in this appendix does not encompass "
"all possibilities: external libraries can implement `derive` for their own "
"traits, expanding the list of traits compatible with `derive`."
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid "PartialEq for equality comparison"
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:36
msgid "Clone and Copy for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:38
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""

#: src/appendix-03-derivable-traits.md:40
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:61
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:65
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct;\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents "
"firs_struct from moving into second_struct\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:81
msgid "Serializing with Serde"
msgstr ""

#: src/appendix-03-derivable-traits.md:83
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""

#: src/appendix-03-derivable-traits.md:108
msgid "Output:"
msgstr ""

#: src/appendix-03-derivable-traits.md:114
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr ""

#: src/appendix-03-derivable-traits.md:116
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back "
"into our A struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:143
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""

#: src/appendix-03-derivable-traits.md:145
msgid "Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:147
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:149
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` "
"[here](ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid "Store"
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet "
"contract requires the `Store` trait to be implemented for this type. You can "
"automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""

#: src/appendix-03-derivable-traits.md:174
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the "
"Store trait. This `struct A` is subsequently used as a storage variable in "
"the contract."
msgstr ""

#: src/appendix-03-derivable-traits.md:177
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:179
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the "
"`PartialOrd` and `Ord` traits to compare values for ordering."
msgstr ""

#: src/appendix-03-derivable-traits.md:181
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for "
"ordering, thereby enabling the \\<, \\<=, >, and >= operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:183
msgid ""
"When `PartialOrd` is derived on structs, two instances are ordered by "
"comparing each field in turn."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:16
msgid "IDE Integration Using `cairo-language-server`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the "
"[`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language "
"Server Protocol](http://langserver.org/)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate "
"with each other. Different clients can use `cairo-language-server`, such as "
"[the Cairo extension for Visual Studio "
"Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, "
"jump to definition, and inline errors."
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"[lib.cairo](https://github.com/starkware-libs/cairo/blob/v2.2.0/corelib/src/lib.cairo) "
"file of the corelib crate and contains Cairo's primitive data types, traits, "
"operators, and utility functions. This includes: Data types - felts, bools, "
"arrays, dicts, etc. Traits - behaviors for arithmetic, comparison, "
"serialization Operators - arithmetic, logical, bitwise Utility functions - "
"helpers for arrays, maps, boxing, etc. The core library prelude delivers the "
"fundamental programming constructs and operations needed for basic Cairo "
"programs, without requiring the explicit import of elements. Since the core "
"library prelude is automatically imported, its contents are available for "
"use in any Cairo crate without explicit imports. This prevents repetition "
"and provides a better devX. This is what allows you to use "
"`ArrayTrait::append()` or the `Default` trait without bringing them "
"explicitly into scope."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid "List of common types and traits"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"The following section provides a brief overview of commonly used types and "
"traits when developping Cairo programs. Most of these are included in the "
"prelude and not required to be imported explicitly - but not all of them."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Import"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Path"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Usage"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`core::option::OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid ""
"`OptionTrait<T>` defines a set of methods required to manipulate optional "
"value."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`core::result::ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid ""
"`ResultTrait<T, E>` Type for Starknet contract address, a value in the range "
"\\[0, 2 \\*\\* 251)."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`starknet::ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of "
"`t:ContractAddress` is zero or not."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`starknet::contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid ""
"The `contract_address_const!` it's a function that allows instantiating "
"constant contract address values."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`Into`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an "
"implementation of Into\\<T,S> for the types T and S, you can convert T into "
"S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an "
"implementation of TryInto\\<T,S> for the types T and S, you can convert T "
"into S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid ""
"`get_caller_address()` is a function that returns the address of the caller "
"of the contract. It can be used to identify the caller of a contract "
"function."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid ""
"`get_contract_address()` is a function that returns the address of the "
"current contract. It can be used to obtain the address of the contract being "
"executed."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr ""

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""

#: src/appendix-06-cairo-binaries.md:7
msgid "Prerequisites"
msgstr ""

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:18
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:20
msgid "Install"
msgstr ""

#: src/appendix-06-cairo-binaries.md:22
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.2.0`)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:24
msgid ""
"```bash\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these "
"instructions](#set-up-your-shell-environment-for-cairo) to set up your shell "
"environment."
msgstr ""

#: src/appendix-06-cairo-binaries.md:30
msgid "Update"
msgstr ""

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:37
msgid "Uninstall"
msgstr ""

#: src/appendix-06-cairo-binaries.md:39
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:47
msgid ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:57
msgid "Set up your shell environment for Cairo"
msgstr ""

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/appendix-06-cairo-binaries.md:65
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:75
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:77
msgid ""
"```bash\n"
"echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bashrc\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:87
msgid ""
"```bash\n"
"echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
"echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:93
msgid ""
"```bash\n"
"echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:100
msgid ""
"```zsh\n"
"echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent from Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""

#: src/appendix-06-cairo-binaries.md:129
msgid "Restart your shell"
msgstr ""

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr ""

#: src/appendix-06-cairo-binaries.md:133
msgid ""
"```sh\n"
"exec \"$SHELL\"\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:137
msgid ""
"Installing Cairo Manually "
"([Guide](https://github.com/auditless/cairo-template) by "
"[Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:139
msgid "Step 1: Install Cairo 1.0"
msgstr ""

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:145
msgid ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v2.2.0\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:178
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr ""

#: src/appendix-06-cairo-binaries.md:180
msgid ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:184
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:186
msgid "Step 3: Setup Language Server"
msgstr ""

#: src/appendix-06-cairo-binaries.md:188
msgid "VS Code Extension"
msgstr ""

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:191
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""

#: src/appendix-06-cairo-binaries.md:192
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:194
msgid "Cairo Language Server without Scarb"
msgstr ""

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step "
"1](#installing-cairo-with-a-script-installer-by-fran), the "
"`cairo-language-server` binary should be built and executing this command "
"will copy its path into your clipboard."
msgstr ""

#: src/appendix-06-cairo-binaries.md:203
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""

