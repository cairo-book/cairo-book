
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "The Cairo Programming Language"
msgstr ""

#: src/SUMMARY.md:4
msgid "Foreword"
msgstr ""

#: src/SUMMARY.md:5
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:7
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:11
msgid "Installation"
msgstr ""

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md:13
msgid "Hello, Scarb!"
msgstr ""

#: src/SUMMARY.md:15
msgid "Common Programming Concepts"
msgstr ""

#: src/SUMMARY.md:18
msgid "Variables and Mutability"
msgstr ""

#: src/SUMMARY.md:19
msgid "Data Types"
msgstr ""

#: src/SUMMARY.md:20
msgid "Functions"
msgstr ""

#: src/SUMMARY.md:21
msgid "Comments"
msgstr ""

#: src/SUMMARY.md:22
msgid "Control Flow"
msgstr ""

#: src/SUMMARY.md:23
msgid "Common Collections"
msgstr ""

#: src/SUMMARY.md:25
msgid "Understanding Ownership"
msgstr ""

#: src/SUMMARY.md:28
msgid "What is Ownership?"
msgstr ""

#: src/SUMMARY.md:29
msgid "References and Snapshots"
msgstr ""

#: src/SUMMARY.md:31
msgid "Using Structs to Structure Related Data"
msgstr ""

#: src/SUMMARY.md:34
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/SUMMARY.md:35
msgid "An Example Program Using Structs"
msgstr ""

#: src/SUMMARY.md:36
msgid "Method Syntax"
msgstr ""

#: src/SUMMARY.md:38
msgid "Enums and Pattern Matching"
msgstr ""

#: src/SUMMARY.md:38
msgid "Enums"
msgstr ""

#: src/SUMMARY.md:42
msgid "The Match Control Flow Construct"
msgstr ""

#: src/SUMMARY.md:44
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr ""

#: src/SUMMARY.md:48
msgid "Packages and Crates"
msgstr ""

#: src/SUMMARY.md:50
msgid "Defining Modules to Control Scope"
msgstr ""

#: src/SUMMARY.md:51
msgid "Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/SUMMARY.md:52
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr ""

#: src/SUMMARY.md:53
msgid "Separating Modules into Different Files"
msgstr ""

#: src/SUMMARY.md:57
msgid "Generic Types"
msgstr ""

#: src/SUMMARY.md:59
msgid "Generic Functions"
msgstr ""

#: src/SUMMARY.md:60
msgid "Traits in Cairo"
msgstr ""

#: src/SUMMARY.md:62
msgid "Testing Cairo Programs"
msgstr ""

#: src/SUMMARY.md:66
msgid "How To Write Tests"
msgstr ""

#: src/SUMMARY.md:67
msgid "Testing Organization"
msgstr ""

#: src/SUMMARY.md:69
msgid "Error Handling"
msgstr ""

#: src/SUMMARY.md:72
msgid "Unrecoverable Errors with panic"
msgstr ""

#: src/SUMMARY.md:73
msgid "Recoverable Errors with Result"
msgstr ""

#: src/SUMMARY.md:75
msgid "Advanced Features"
msgstr ""

#: src/SUMMARY.md:78
msgid "Operator Overloading"
msgstr ""

#: src/SUMMARY.md:82
msgid "Starknet Smart Contracts"
msgstr ""

#: src/SUMMARY.md:84
msgid "Introduction to smart-contracts"
msgstr ""

#: src/SUMMARY.md:85
msgid "Writing Starknet Contracts"
msgstr ""

#: src/SUMMARY.md:86
msgid "ABIs and Cross-contract Interactions"
msgstr ""

#: src/SUMMARY.md:87
msgid "ABIs and Interfaces"
msgstr ""

#: src/SUMMARY.md:88
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr ""

#: src/SUMMARY.md:89
msgid "Security Considerations"
msgstr ""

#: src/SUMMARY.md:91
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md:92
msgid "A - Keywords"
msgstr ""

#: src/SUMMARY.md:93
msgid "B - Operators and Symbols"
msgstr ""

#: src/SUMMARY.md:94
msgid "C - Derivable Traits"
msgstr ""

#: src/SUMMARY.md:95
msgid "D - Useful Development Tools"
msgstr ""

#: src/SUMMARY.md:96
msgid "E - Cairo Most Common Types and Traits"
msgstr ""

#: src/title-page.md:1
msgid "# The Cairo Programming Language"
msgstr ""

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its "
"[contributors](https://github.com/cairo-book/cairo-book.github.io). Special "
"thanks to [Starkware](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using Cairo v1.1.0. See the "
"“Installation” section of Chapter 1 to install or update Cairo."
msgstr ""

#: src/ch00-01-foreword.md:1
msgid "# Foreword"
msgstr ""

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr ""

#: src/ch00-00-introduction.md:1
msgid "# Introduction"
msgstr ""

#: src/ch00-00-introduction.md:3
msgid "## What is Cairo?"
msgstr ""

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine.\n"
"While Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, "
"Cairo 1 is a more high level language. It first compiles to Sierra, an "
"intermediate representation of Cairo which will compile later down to a safe "
"subset of CASM. The point of Sierra is to ensure your CASM will always be "
"provable, even when the computation fails."
msgstr ""

#: src/ch00-00-introduction.md:8
msgid "## What can you do with it?"
msgstr ""

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""

#: src/ch00-00-introduction.md:12
msgid "## What are the differences with other programming languages?"
msgstr ""

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""

#: src/ch00-00-introduction.md:16
msgid ""
"- When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize.\n"
"\n"
"- When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom "
"non-deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""

#: src/ch00-00-introduction.md:22
msgid "## References"
msgstr ""

#: src/ch00-00-introduction.md:24
msgid ""
"- Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>\n"
"- Cairo, Sierra and Casm: "
"<https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5>\n"
"- State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""

#: src/ch01-01-installation.md:1
msgid "# Installation"
msgstr ""

#: src/ch01-01-installation.md:3
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""

#: src/ch01-01-installation.md:5
msgid "### Prerequisites"
msgstr ""

#: src/ch01-01-installation.md:7
msgid "First you will need to have Rust and Git installed."
msgstr ""

#: src/ch01-01-installation.md:9
msgid ""
"```bash\n"
"# Install stable Rust\n"
"rustup override set stable && rustup update\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:14
msgid "Install [Git](https://git-scm.com/)."
msgstr ""

#: src/ch01-01-installation.md:16
msgid ""
"## Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""

#: src/ch01-01-installation.md:18
msgid "### Install"
msgstr ""

#: src/ch01-01-installation.md:20
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v1.1.0`)."
msgstr ""

#: src/ch01-01-installation.md:22
msgid ""
"```bash\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:26
msgid ""
"After installing, follow [these "
"instructions](#set-up-your-shell-environment-for-cairo) to set up your shell "
"environment."
msgstr ""

#: src/ch01-01-installation.md:28
msgid "### Update"
msgstr ""

#: src/ch01-01-installation.md:30
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L "
"https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | "
"bash\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:35
msgid "### Uninstall"
msgstr ""

#: src/ch01-01-installation.md:37
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""

#: src/ch01-01-installation.md:39
msgid ""
"```bash\n"
"rm -fr ~/.cairo\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:43
msgid "then remove these three lines from .bashrc:"
msgstr ""

#: src/ch01-01-installation.md:45
msgid ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:49
msgid "and finally, restart your shell:"
msgstr ""

#: src/ch01-01-installation.md:51
msgid ""
"```bash\n"
"exec $SHELL\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:55
msgid "### Set up your shell environment for Cairo"
msgstr ""

#: src/ch01-01-installation.md:57
msgid ""
"- Define environment variable `CAIRO_ROOT` to point to the path where\n"
"  Cairo will store its data. `$HOME/.cairo` is the default.\n"
"  If you installed Cairo via Git checkout, we recommend\n"
"  to set it to the same location as where you cloned it.\n"
"- Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/ch01-01-installation.md:63
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""

#: src/ch01-01-installation.md:65
msgid ""
"- For **bash**:\n"
"\n"
"  Stock Bash startup files vary widely between distributions in which of "
"them source\n"
"  which, under what circumstances, in what order and what additional "
"configuration they perform.\n"
"  As such, the most reliable way to get Cairo in all environments is to "
"append Cairo\n"
"  configuration commands to both `.bashrc` (for interactive shells)\n"
"  and the profile file that Bash would use (for login shells).\n"
"\n"
"  First, add the commands to `~/.bashrc` by running the following in your "
"terminal:\n"
"\n"
"  ```bash\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"  echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bashrc\n"
"  ```\n"
"\n"
"  Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well.\n"
"  If you have none of these, add them to `~/.profile`.\n"
"\n"
"  - to add to `~/.profile`:\n"
"\n"
"    ```bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
"    echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile\n"
"    ```\n"
"\n"
"  - to add to `~/.bash_profile`:\n"
"    ```bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"    echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
"    ```\n"
"\n"
"- For **Zsh**:\n"
"\n"
"  ```zsh\n"
"  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"  echo 'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc\n"
"  ```\n"
"\n"
"  If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`.\n"
"\n"
"- For **Fish shell**:\n"
"\n"
"  If you have Fish 3.2.0 or newer, execute this interactively:\n"
"\n"
"  ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  fish_add_path $CAIRO_ROOT/target/release\n"
"  ```\n"
"\n"
"  Otherwise, execute the snippet below:\n"
"\n"
"  ```fish\n"
"  set -Ux CAIRO_ROOT $HOME/.cairo\n"
"  set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
"  ```"
msgstr ""

#: src/ch01-01-installation.md:121
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which\n"
"provides alternative shell completions for many command line tools with an\n"
"IDE-like popup interface in the terminal window.\n"
"(Note that their completions are independent from Cairo's codebase\n"
"so they might be slightly out of sync for bleeding-edge interface changes.)"
msgstr ""

#: src/ch01-01-installation.md:127
msgid "### Restart your shell"
msgstr ""

#: src/ch01-01-installation.md:129
msgid "for the `PATH` changes to take effect."
msgstr ""

#: src/ch01-01-installation.md:131
msgid ""
"```sh\n"
"exec \"$SHELL\"\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:135
msgid ""
"## Installing Cairo Manually "
"([Guide](https://github.com/auditless/cairo-template) by "
"[Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""

#: src/ch01-01-installation.md:137
msgid "### Step 1: Install Cairo 1.0"
msgstr ""

#: src/ch01-01-installation.md:139
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""

#: src/ch01-01-installation.md:141
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""

#: src/ch01-01-installation.md:143
msgid ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v1.1.0\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:165
msgid "."
msgstr ""

#: src/ch01-01-installation.md:167
msgid "**NOTE: Keeping Cairo up to date**"
msgstr ""

#: src/ch01-01-installation.md:169
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do\n"
"is pull the latest changes and rebuild as follows:"
msgstr ""

#: src/ch01-01-installation.md:172
msgid ""
"```bash\n"
"cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:176
msgid "### Step 2: Add Cairo 1.0 executables to your path"
msgstr ""

#: src/ch01-01-installation.md:178
msgid ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:182
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""

#: src/ch01-01-installation.md:184
msgid "### Step 3: Setup Language Server"
msgstr ""

#: src/ch01-01-installation.md:186
msgid "#### VS Code Extension"
msgstr ""

#: src/ch01-01-installation.md:188
msgid ""
"- If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it.\n"
"- Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), "
"or just search for \"Cairo 1.0\" in the VS Code marketplace.\n"
"- The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr ""

#: src/ch01-01-installation.md:192
msgid "#### Cairo Language Server without Scarb"
msgstr ""

#: src/ch01-01-installation.md:194
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary.\n"
"From [Step 1](#installing-cairo-with-a-script-installer-by-fran), the "
"`cairo-language-server` binary should be built and executing this command "
"will copy its path into your clipboard."
msgstr ""

#: src/ch01-01-installation.md:197
msgid ""
"```bash\n"
"which cairo-language-server | pbcopy\n"
"```"
msgstr ""

#: src/ch01-01-installation.md:201
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""

#: src/ch01-02-hello-world.md:1
msgid "## Hello, World"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo, it’s time to write your first Cairo "
"program.\n"
"It’s traditional when learning a new language to write a little program "
"that\n"
"prints the text `Hello, world!` to the screen, so we’ll do the same here!"
msgstr ""

#: src/ch01-02-hello-world.md:7
msgid ""
"> Note: This book assumes basic familiarity with the command line. Cairo "
"makes\n"
"> no specific demands about your editing or tooling or where your code "
"lives, so\n"
"> if you prefer to use an integrated development environment (IDE) instead "
"of\n"
"> the command line, feel free to use your favorite IDE. The Cairo team has "
"developed\n"
"> a VSCode extension for the Cairo language that you can use to get the "
"features from\n"
"> the language server and code highlighting. See [Appendix D][devtools]\n"
"> for more details."
msgstr ""

#: src/ch01-02-hello-world.md:15
msgid "### Creating a Project Directory"
msgstr ""

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter\n"
"to Cairo where your code lives, but for the exercises and projects in this "
"book,\n"
"we suggest making a _cairo_projects_ directory in your home directory and "
"keeping all\n"
"your projects there."
msgstr ""

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory\n"
"and a directory for the “Hello, world!” project within the _cairo_projects_ "
"directory."
msgstr ""

#: src/ch01-02-hello-world.md:25
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:27
msgid ""
"```console\n"
"mkdir ~/cairo_projects\n"
"cd ~/cairo_projects\n"
"mkdir hello_world\n"
"cd hello_world\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:34
msgid "For Windows CMD, enter this:"
msgstr ""

#: src/ch01-02-hello-world.md:36
msgid ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\projects\"\n"
"> cd /d \"%USERPROFILE%\\projects\"\n"
"> mkdir hello_world\n"
"> cd hello_world\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:43
msgid "### Writing and Running a Cairo Program"
msgstr ""

#: src/ch01-02-hello-world.md:45
msgid ""
"Next, make a new source file and call it _main.cairo_. Cairo files always "
"end with\n"
"the _.cairo_ extension. If you’re using more than one word in your filename, "
"the\n"
"convention is to use an underscore to separate them. For example, use\n"
"_hello_world.cairo_ rather than _helloworld.cairo_."
msgstr ""

#: src/ch01-02-hello-world.md:50
msgid ""
"Now open the _main.cairo_ file you just created and enter the code in "
"Listing 1-1."
msgstr ""

#: src/ch01-02-hello-world.md:52
#: src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58
#: src/ch02-05-control-flow.md:90
msgid "<span class=\"filename\">Filename: main.cairo</span>"
msgstr ""

#: src/ch01-02-hello-world.md:54
msgid ""
"```rust,file=hello_world.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:61
msgid ""
"<span class=\"caption\">Listing 1-1: A program that prints `Hello, "
"world!`</span>"
msgstr ""

#: src/ch01-02-hello-world.md:63
msgid ""
"Save the file and go back to your terminal window in the\n"
"_~/cairo_projects/hello_world_ directory. Enter the following\n"
"commands to compile and run the file:"
msgstr ""

#: src/ch01-02-hello-world.md:67
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:72
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to\n"
"the terminal."
msgstr ""

#: src/ch01-02-hello-world.md:75
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo\n"
"program. That makes you a Cairo programmer—welcome!"
msgstr ""

#: src/ch01-02-hello-world.md:78
msgid "### Anatomy of a Cairo Program"
msgstr ""

#: src/ch01-02-hello-world.md:80
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of\n"
"the puzzle:"
msgstr ""

#: src/ch01-02-hello-world.md:83
msgid ""
"```rust,ignore_format\n"
"fn main() {\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:89
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it\n"
"is always the first code that runs in every executable Cairo program. Here, "
"the\n"
"first line declares a function named `main` that has no parameters and "
"returns\n"
"nothing. If there were parameters, they would go inside the parentheses `()`."
msgstr ""

#: src/ch01-02-hello-world.md:94
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all\n"
"function bodies. It’s good style to place the opening curly bracket on the "
"same\n"
"line as the function declaration, adding one space in between."
msgstr ""

#: src/ch01-02-hello-world.md:98
msgid ""
"> Note: If you want to stick to a standard style across Cairo projects, you "
"can\n"
"> use the automatic formatter tool called `cairo-format` to format your code "
"in a\n"
"> particular style (more on `cairo-format` in\n"
"> [Appendix D][devtools]). The Cairo team has included this tool\n"
"> with the standard Cairo distribution, as `cairo-run` is, so it should "
"already be\n"
"> installed on your computer!"
msgstr ""

#: src/ch01-02-hello-world.md:105
msgid ""
"Prior to the main function declaration, The line `use debug::PrintTrait;` is "
"responsible for importing an item defined in another module. In this case, "
"we are importing the `PrintTrait` item from the Cairo core library. By doing "
"so, we gain the ability to use the `print()` method on data types that are "
"compatible with printing."
msgstr ""

#: src/ch01-02-hello-world.md:107
msgid "The body of the `main` function holds the following code:"
msgstr ""

#: src/ch01-02-hello-world.md:109
msgid ""
"```rust\n"
"    'Hello, world!'.print();\n"
"```"
msgstr ""

#: src/ch01-02-hello-world.md:113
msgid ""
"This line does all the work in this little program: it prints text to the\n"
"screen. There are four important details to notice here."
msgstr ""

#: src/ch01-02-hello-world.md:116
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""

#: src/ch01-02-hello-world.md:118
msgid ""
"Second, the `print()` function called is a method from the trait "
"`PrintTrait`. This trait is imported from the Cairo core library, and it "
"defines how to print values to the screen for different data types. In our "
"case, our text is defined as a \"short string\", which is an ASCII string "
"that can fit in Cairo's basic data type, which is the `felt252` type. By "
"calling `Hello, world!'.print()`, we're calling the `print()` method of the "
"`felt252` implementation of the `PrintTrait` trait."
msgstr ""

#: src/ch01-02-hello-world.md:120
msgid ""
"Third, you see the `'Hello, world!'` short string. We pass this short string "
"as an argument\n"
"to `print()`, and the short string is printed to the screen."
msgstr ""

#: src/ch01-02-hello-world.md:123
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this\n"
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code\n"
"end with a semicolon."
msgstr ""

#: src/ch01-02-hello-world.md:127
msgid ""
"Just running with `cairo-run` is fine for simple programs, but as your "
"project\n"
"grows, you’ll want to manage all the options and make it easy to share your\n"
"code. Next, we’ll introduce you to the Scarb tool, which will help you "
"write\n"
"real-world Cairo programs."
msgstr ""

#: src/ch01-03-hello-scarb.md:1
msgid "# Hello, Scarb"
msgstr ""

#: src/ch01-03-hello-scarb.md:3
msgid ""
"Scarb is the Cairo package manager and heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""

#: src/ch01-03-hello-scarb.md:5
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""

#: src/ch01-03-hello-scarb.md:7
msgid ""
"If we were to build the 'Hello, world!' project using Scarb, only the part "
"of Scarb that handles building the code would be utilized, since the program "
"doesn't require any external dependencies. As you write more complex Cairo "
"programs, you’ll add dependencies, and if you start a project using Scarb, "
"adding dependencies will be much easier to do."
msgstr ""

#: src/ch01-03-hello-scarb.md:9
msgid "Let's start by installing Scarb."
msgstr ""

#: src/ch01-03-hello-scarb.md:11
msgid "## Installing Scarb"
msgstr ""

#: src/ch01-03-hello-scarb.md:13
msgid "### Requirements"
msgstr ""

#: src/ch01-03-hello-scarb.md:15
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""

#: src/ch01-03-hello-scarb.md:17
msgid "### Installation"
msgstr ""

#: src/ch01-03-hello-scarb.md:19
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download.html).\n"
"You can simply run the following command in your terminal, then follow the "
"onscreen instructions. This will install the latest stable release."
msgstr ""

#: src/ch01-03-hello-scarb.md:22
msgid ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:26
msgid ""
"- Verify installation by running the following command in new terminal "
"session, it should print both Scarb and Cairo language versions, e.g:\n"
"\n"
"  ```bash\n"
"  $ scarb --version\n"
"  scarb 0.4.0 (f813517bf 2023-06-06)\n"
"  cairo: 1.1.0 (43b83560d)\n"
"  ```"
msgstr ""

#: src/ch01-03-hello-scarb.md:34
msgid "### Creating a Project with Scarb"
msgstr ""

#: src/ch01-03-hello-scarb.md:36
msgid ""
"Let’s create a new project using Scarb and look at how it differs from our "
"original “Hello, world!” project."
msgstr ""

#: src/ch01-03-hello-scarb.md:38
msgid ""
"Navigate back to your projects directory (or wherever you decided to store "
"your code). Then run the following:"
msgstr ""

#: src/ch01-03-hello-scarb.md:40
msgid ""
"```bash\n"
"$ scarb new hello_scarb\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:44
msgid ""
"It creates a new directory and project called hello_scarb. We’ve named our "
"project hello_scarb, and Scarb creates its files in a directory of the same "
"name."
msgstr ""

#: src/ch01-03-hello-scarb.md:46
msgid ""
"Go into the hello_scarb directory with the command `cd hello_scarb`. You’ll "
"see that Scarb has generated two files and one directory for us: a "
"`Scarb.toml` file and a src directory with a `lib.cairo` file inside."
msgstr ""

#: src/ch01-03-hello-scarb.md:48
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""

#: src/ch01-03-hello-scarb.md:50
msgid ""
"> Note: Git is a common version control system. You can stop using version "
"control system by using the `--vcs` flag.\n"
"> Run `scarb new -help` to see the available options."
msgstr ""

#: src/ch01-03-hello-scarb.md:53
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr ""

#: src/ch01-03-hello-scarb.md:55
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr ""

#: src/ch01-03-hello-scarb.md:57
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at "
"https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:68
msgid ""
"<span class=\"caption\">Listing 1-2: Contents of Scarb.toml generated by "
"`scarb new`</span>"
msgstr ""

#: src/ch01-03-hello-scarb.md:70
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""

#: src/ch01-03-hello-scarb.md:72
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""

#: src/ch01-03-hello-scarb.md:74
msgid ""
"The next two lines set the configuration information Scarb needs to compile "
"your program: the name and the version of Scarb to use."
msgstr ""

#: src/ch01-03-hello-scarb.md:76
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""

#: src/ch01-03-hello-scarb.md:78
msgid ""
"> Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/starknet/starknet-package.html)."
msgstr ""

#: src/ch01-03-hello-scarb.md:80
msgid ""
"The other file created by Scarb is `src/lib.cairo`, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""

#: src/ch01-03-hello-scarb.md:82
msgid ""
"```rust\n"
"mod hello_scarb;\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:86
msgid ""
"Then create a new file called `src/hello_scarb.cairo` and put the following "
"code in it:"
msgstr ""

#: src/ch01-03-hello-scarb.md:88
msgid "<span class=\"filename\">Filename: src/hello_scarb.cairo</span>"
msgstr ""

#: src/ch01-03-hello-scarb.md:90
msgid ""
"```rust,file=hello_scarb.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:97
msgid ""
"We have just created a file called `lib.cairo`, which contains a module "
"declaration referencing another module named \"hello_scarb\", as well as the "
"file `hello_scarb.cairo`, containing the implementation details of the "
"\"hello_scarb\" module."
msgstr ""

#: src/ch01-03-hello-scarb.md:99
msgid "Scarb requires your source files to be located within the src directory."
msgstr ""

#: src/ch01-03-hello-scarb.md:101
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content.\n"
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""

#: src/ch01-03-hello-scarb.md:104
msgid ""
"If you started a project that doesn’t use Scarb, as we did with the “Hello, "
"world!” project, you can convert it to a project that does use Scarb. Move "
"the project code into the src directory and create an appropriate "
"`Scarb.toml` file."
msgstr ""

#: src/ch01-03-hello-scarb.md:106
msgid "### Building a Scarb Project"
msgstr ""

#: src/ch01-03-hello-scarb.md:108
msgid ""
"From your hello_scarb directory, build your project by entering the "
"following command:"
msgstr ""

#: src/ch01-03-hello-scarb.md:110
msgid ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:116
msgid ""
"This command creates a `sierra` file in `target/release`, let's ignore the "
"`sierra` file for now."
msgstr ""

#: src/ch01-03-hello-scarb.md:118
msgid ""
"If you have installed Cairo correctly, you should be able to run and see the "
"following output:"
msgstr ""

#: src/ch01-03-hello-scarb.md:120
msgid ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, Scarb!                   (raw: "
"5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:127
msgid ""
"> Note: You will notice here that we didn't use a Scarb command, but rather "
"a command from the Cairo binaries directly.\n"
"> As Scarb doesn't have a command to execute Cairo code yet, we have to use "
"the `cairo-run` command directly.\n"
"> We will use this command in the rest of the tutorial, but we will also use "
"Scarb commands to initialize projects."
msgstr ""

#: src/ch01-03-hello-scarb.md:131
msgid "### Defining Custom Scripts"
msgstr ""

#: src/ch01-03-hello-scarb.md:133
msgid ""
"We can define Scarb scripts in `Scarb.toml` file, which can be used to "
"execute custom shell scripts.\n"
"Add the following line to your `Scarb.toml` file:"
msgstr ""

#: src/ch01-03-hello-scarb.md:136
msgid ""
"```toml\n"
"[scripts]\n"
"run-lib = \"cairo-run src/lib.cairo\"\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:141
msgid "Now you can run the following command to run the project:"
msgstr ""

#: src/ch01-03-hello-scarb.md:143
msgid ""
"```bash\n"
"$ scarb run run-lib\n"
"[DEBUG] Hello, Scarb!                   (raw: "
"5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch01-03-hello-scarb.md:150
msgid ""
"Using `scarb run` is a convenient way to run custom shell scripts that can "
"be useful to run files and test your project."
msgstr ""

#: src/ch01-03-hello-scarb.md:152
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr ""

#: src/ch01-03-hello-scarb.md:154
msgid ""
"- We can create a project using `scarb new`.\n"
"- We can build a project using `scarb build` to generate the compiled Sierra "
"code.\n"
"- We can define custom scripts in `Scarb.toml` and call them with the `scarb "
"run` command."
msgstr ""

#: src/ch01-03-hello-scarb.md:158
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""

#: src/ch01-03-hello-scarb.md:160
msgid "# Summary"
msgstr ""

#: src/ch01-03-hello-scarb.md:162
msgid ""
"You’re already off to a great start on your Cairo journey! In this chapter, "
"you’ve learned how to:"
msgstr ""

#: src/ch01-03-hello-scarb.md:164
msgid ""
"- Install the latest stable version of Cairo\n"
"- Write and run a “Hello, world!” program using `cairo-run` directly\n"
"- Create and run a new project using the conventions of Scarb"
msgstr ""

#: src/ch01-03-hello-scarb.md:168
msgid ""
"This is a great time to build a more substantial program to get used to "
"reading and writing Cairo code."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:1
msgid "# Common Programming Concepts"
msgstr ""

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:1
msgid "## Variables and Mutability"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to,\n"
"it can't be overwritten but only read from. To reflect this immutable memory "
"model,\n"
"variables in Cairo are immutable by default.\n"
"However, the language abstracts this model and gives you the option to make "
"your\n"
"variables mutable. Let’s explore how and why Cairo enforces immutability, "
"and how\n"
"you can make your variables mutable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change\n"
"that value. To illustrate this, generate a new project called _variables_ "
"in\n"
"your _cairo_projects_ directory by using `scarb new variables`."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its\n"
"code with the following code, which won’t compile just yet:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:77
#: src/ch02-01-variables-and-mutability.md:155
#: src/ch02-05-control-flow.md:130
#: src/ch03-02-references-and-snapshots.md:23
#: src/ch03-02-references-and-snapshots.md:130
#: src/ch04-02-an-example-program-using-structs.md:7
#: src/ch04-02-an-example-program-using-structs.md:48
#: src/ch04-02-an-example-program-using-structs.md:74
#: src/ch04-02-an-example-program-using-structs.md:103
#: src/ch04-02-an-example-program-using-structs.md:136
#: src/ch04-03-method-syntax.md:18
#: src/ch04-03-method-syntax.md:93
#: src/ch04-03-method-syntax.md:135
#: src/ch04-03-method-syntax.md:192
#: src/ch04-03-method-syntax.md:231
#: src/ch06-02-defining-modules-to-control-scope.md:90
#: src/ch06-02-defining-modules-to-control-scope.md:143
#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:36
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:76
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:132
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:206
#: src/ch06-05-separating-modules-into-different-files.md:18
#: src/ch08-01-how-to-write-tests.md:512
#: src/ch08-01-how-to-write-tests.md:550
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:19
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `cairo-run src/lib.cairo`. You should receive "
"an error message\n"
"regarding an immutability error, as shown in this output:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:33
msgid ""
"```console\n"
"error: Cannot assign to an immutable variable.\n"
" --> lib.cairo:5:5\n"
"    x = 6;\n"
"    ^***^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs.\n"
"Compiler errors can be frustrating, but really they only mean your program\n"
"isn’t safely doing what you want it to do yet; they do _not_ mean that "
"you’re\n"
"not a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.`\n"
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a\n"
"value that’s designated as immutable because this specific situation can "
"lead to\n"
"bugs. If one part of our code operates on the assumption that a value will\n"
"never change and another part of our code changes that value, it’s possible\n"
"that the first part of the code won’t do what it was designed to do. The "
"cause\n"
"of this kind of bug can be difficult to track down after the fact, "
"especially\n"
"when the second piece of code changes the value only _sometimes_. The Cairo\n"
"compiler guarantees that when you state that a value won’t change, it "
"really\n"
"won’t change, so you don’t have to keep track of it yourself. Your code is "
"thus\n"
"easier to reason through."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:61
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write.\n"
"Although variables are immutable by default, you can make them mutable by\n"
"adding `mut` in front of the variable name. Adding `mut` also conveys\n"
"intent to future readers of the code by indicating that other parts of the "
"code\n"
"will be changing this variable’s value."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:67
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable\n"
"is declared as `mut`, as we previously mentioned that Cairo's memory is "
"immutable.\n"
"The answer is that Cairo's memory is immutable, but the memory address the "
"variable points\n"
"to can be changed. Upon examining the low-level Cairo Assembly code, it "
"becomes clear that\n"
"variable mutation is implemented as syntactic sugar, which translates "
"mutation operations\n"
"into a series of steps equivalent to variable shadowing. The only difference "
"is that at the Cairo\n"
"level, the variable is not redeclared so its type cannot change."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:75
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:79
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:89
msgid "When we run the program now, we get this:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:91
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\t                              \t(raw: 5)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:100
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` "
"is\n"
"used. Ultimately, deciding whether to use mutability or not is up to you "
"and\n"
"depends on what you think is clearest in that particular situation."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:104
msgid "### Constants"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:106
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and\n"
"are not allowed to change, but there are a few differences between "
"constants\n"
"and variables."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:110
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t "
"just\n"
"immutable by default—they’re always immutable. You declare constants using "
"the\n"
"`const` keyword instead of the `let` keyword, and the type of the value "
"_must_\n"
"be annotated. We’ll cover types and type annotations in the next section,\n"
"[“Data Types”][data-types], so don’t worry about the details\n"
"right now. Just know that you must always annotate the type."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:117
msgid ""
"Constants can only be declared in the global scope, which makes\n"
"them useful for values that many parts of code need to know about."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"The last difference is that constants may be set only to a constant "
"expression,\n"
"not the result of a value that could only be computed at runtime. Only "
"literal constants\n"
"are currently supported."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:124
msgid "Here’s an example of a constant declaration:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:126
msgid ""
"```rust\n"
"const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"Cairo's naming convention for constants is to use all uppercase with\n"
"underscores between words."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Constants are valid for the entire time a program runs, within the scope in\n"
"which they were declared. This property makes constants useful for values "
"in\n"
"your application domain that multiple parts of the program might need to "
"know\n"
"about, such as the maximum number of points any player of a game is allowed "
"to\n"
"earn, or the speed of light."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in\n"
"conveying the meaning of that value to future maintainers of the code. It "
"also\n"
"helps to have only one place in your code you would need to change if the\n"
"hardcoded value needed to be updated in the future."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:144
msgid "### Shadowing"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:146
msgid ""
"Variable shadowing refers to the declaration of a\n"
"new variable with the same name as a previous variable. Caironautes say that "
"the\n"
"first variable is _shadowed_ by the second, which means that the second\n"
"variable is what the compiler will see when you use the name of the "
"variable.\n"
"In effect, the second variable overshadows the first, taking any uses of "
"the\n"
"variable name to itself until either it itself is shadowed or the scope "
"ends.\n"
"We can shadow a variable by using the same variable’s name and repeating "
"the\n"
"use of the `let` keyword as follows:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:157
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    let x = x + 1;\n"
"    {\n"
"        let x = x * 2;\n"
"        'Inner scope x value is:'.print();\n"
"        x.print()\n"
"    }\n"
"    'Outer scope x value is:'.print();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:172
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable\n"
"`x` by repeating `let x =`, taking the original value and adding `1` so the\n"
"value of `x` is then `6`. Then, within an inner scope created with the "
"curly\n"
"brackets, the third `let` statement also shadows `x` and creates a new\n"
"variable, multiplying the previous value by `2` to give `x` a value of "
"`12`.\n"
"When that scope is over, the inner shadowing ends and `x` returns to being "
"`6`.\n"
"When we run this program, it will output the following:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:180
msgid ""
"```console\n"
"cairo-run src/lib.cairo\n"
"[DEBUG]\tInner scope x value is:        \t(raw: "
"7033328135641142205392067879065573688897582790068499258)\n"
"\n"
"[DEBUG]\n"
"                                      \t(raw: 12)\n"
"\n"
"[DEBUG]\tOuter scope x value is:        \t(raw: "
"7610641743409771490723378239576163509623951327599620922)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:194
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a\n"
"compile-time error if we accidentally try to reassign to this variable "
"without\n"
"using the `let` keyword. By using `let`, we can perform a few "
"transformations\n"
"on a value but have the variable be immutable after those transformations "
"have\n"
"been completed."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:200
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again,\n"
"we are effectively creating a new variable, which allows us to change the "
"type of the\n"
"value while reusing the same name. As mentioned before, variable shadowing "
"and mutable variables\n"
"are equivalent at the lower level.\n"
"The only difference is that by shadowing a variable, the compiler will not "
"complain\n"
"if you change its type. For example, say our program performs a type "
"conversion between the\n"
"`u64` and `felt252` types."
msgstr ""

#: src/ch02-01-variables-and-mutability.md:208
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let x = 2;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is "
"required.\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:219
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type.\n"
"Shadowing thus spares us from having to come up with different names, such "
"as `x_u64`\n"
"and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we "
"try to use\n"
"`mut` for this, as shown here, we’ll get a compile-time error:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:224
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let mut x = 2;\n"
"    x.print();\n"
"    x = x.into();\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:235
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:237
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: "
"\"core::felt252\".\n"
" --> lib.cairo:6:9\n"
"    x = x.into();\n"
"        ^******^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:247
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they\n"
"can have."
msgstr ""

#: src/ch02-02-data-types.md:1
msgid "## Data Types"
msgstr ""

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of\n"
"data is being specified so it knows how to work with that data. This section "
"covers two subsets of data types: scalars and compounds."
msgstr ""

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it\n"
"must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases\n"
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""

#: src/ch02-02-data-types.md:10
msgid ""
"```rust\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"fn main() {\n"
"    let x: felt252 = 3;\n"
"    let y: u32 = x.try_into().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:19
msgid "You’ll see different type annotations for other data types."
msgstr ""

#: src/ch02-02-data-types.md:21
msgid "### Scalar Types"
msgstr ""

#: src/ch02-02-data-types.md:23
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types:\n"
"felts, integers, and booleans. You may recognize\n"
"these from other programming languages. Let’s jump into how they work in "
"Cairo."
msgstr ""

#: src/ch02-02-data-types.md:27
msgid "#### Felt Type"
msgstr ""

#: src/ch02-02-data-types.md:29
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range `0 <= x < P`,\n"
"where `P` is a very large prime number currently equal to `P = 2^{251} + 17 "
"* 2^{192}+1`. When adding, subtracting, or multiplying, if the result falls "
"outside the specified range of the prime number, an overflow occurs, and an "
"appropriate multiple of P is added or subtracted to bring the result back "
"within the range (i.e., the result is computed modulo P)."
msgstr ""

#: src/ch02-02-data-types.md:32
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where\n"
"integer division `x / y` is defined as `[x/y]` where the integer part of the "
"quotient is returned (so you get `7 / 3 = 2`) and it may or may not satisfy "
"the equation `(x / y) * y == x`,\n"
"depending on the divisibility of `x` by `y`."
msgstr ""

#: src/ch02-02-data-types.md:36
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation `(x "
"/ y) * y == x`. If y divides x as integers, you will get the expected result "
"in Cairo (for example `6 / 2`\n"
"will indeed result in `3`).\n"
"But when y does not divide x, you may get a surprising result: For example, "
"since `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, the value of `1 / 2` in Cairo is "
"`(P+1)/2` (and not 0 or 0.5), as it satisfies the above equation."
msgstr ""

#: src/ch02-02-data-types.md:40
msgid "#### Integer Types"
msgstr ""

#: src/ch02-02-data-types.md:42
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library.\n"
"However, it is highly recommended for programmers to use the integer types "
"instead of the `felt252` type whenever possible, as the `integer` types come "
"with added security features that provide extra protection against potential "
"vulnerabilities in the code, such as overflow checks. By using these integer "
"types, programmers can ensure that their programs are more secure and less "
"susceptible to attacks or other security threats.\n"
"An _integer_ is a number without a fractional component. This type "
"declaration indicates the number of bits the programmer can use to store the "
"integer.\n"
"Table 3-1 shows\n"
"the built-in integer types in Cairo. We can use any of these variants to "
"declare\n"
"the type of an integer value."
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "<span class=\"caption\">Table 3-1: Integer Types in Cairo</span>"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid ""
"| Length  | Unsigned |\n"
"| ------- | -------- |\n"
"| 8-bit   | `u8`     |\n"
"| 16-bit  | `u16`    |\n"
"| 32-bit  | `u32`    |\n"
"| 64-bit  | `u64`    |\n"
"| 128-bit | `u128`   |\n"
"| 256-bit | `u256`   |\n"
"| 32-bit  | `usize`  |"
msgstr ""

#: src/ch02-02-data-types.md:61
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR.\n"
"As variables are unsigned, they can't contain a negative number. This code "
"will cause the program to panic:"
msgstr ""

#: src/ch02-02-data-types.md:64
msgid ""
"```rust\n"
"fn sub_u8s(x: u8, y: u8) -> u8 {\n"
"    x - y\n"
"}\n"
"\n"
"fn main() {\n"
"    sub_u8s(1, 3);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note\n"
"that number literals that can be multiple numeric types allow a type "
"suffix,\n"
"such as `57_u8`, to designate the type."
msgstr ""

#: src/ch02-02-data-types.md:78
msgid "<span class=\"caption\">Table 3-2: Integer Literals in Cairo</span>"
msgstr ""

#: src/ch02-02-data-types.md:80
msgid ""
"| Numeric literals | Example   |\n"
"| ---------------- | --------- |\n"
"| Decimal          | `98222`   |\n"
"| Hex              | `0xff`    |\n"
"| Octal            | `0o04321` |\n"
"| Binary           | `0b01`    |"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size.\n"
"The primary situation in which you’d use `usize` is when indexing some sort "
"of collection."
msgstr ""

#: src/ch02-02-data-types.md:90
msgid "#### Numeric Operations"
msgstr ""

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer\n"
"types: addition, subtraction, multiplication, division, and remainder. "
"Integer\n"
"division truncates toward zero to the nearest integer. The following code "
"shows\n"
"how you’d use each numeric operation in a `let` statement:"
msgstr ""

#: src/ch02-02-data-types.md:97
msgid ""
"```rust\n"
"fn main() {\n"
"    // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates\n"
"to a single value, which is then bound to a variable."
msgstr ""

#: src/ch02-02-data-types.md:120
msgid ""
"[Appendix B][appendix_b] contains a list of all operators that Cairo "
"provides."
msgstr ""

#: src/ch02-02-data-types.md:122
msgid "#### The Boolean Type"
msgstr ""

#: src/ch02-02-data-types.md:124
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible\n"
"values: `true` and `false`. Booleans are one felt252 in size. The Boolean "
"type in\n"
"Cairo is specified using `bool`. For example:"
msgstr ""

#: src/ch02-02-data-types.md:128
msgid ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:136
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if`\n"
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control\n"
"Flow”][control-flow] section."
msgstr ""

#: src/ch02-02-data-types.md:140
msgid "#### The Short String Type"
msgstr ""

#: src/ch02-02-data-types.md:142
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits).\n"
"Here are some examples of declaring values by putting them between single "
"quotes:"
msgstr ""

#: src/ch02-02-data-types.md:145
msgid ""
"```rust\n"
"# fn main() {\n"
"    let my_first_char = 'C';\n"
"    let my_first_string = 'Hello world';\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:152
msgid "### Type casting"
msgstr ""

#: src/ch02-02-data-types.md:154
msgid ""
"In Cairo, you can convert types scalar types from one type to another by "
"using the `try_into` and `into` methods provided by the `TryInto` and `Into` "
"traits, respectively."
msgstr ""

#: src/ch02-02-data-types.md:156
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""

#: src/ch02-02-data-types.md:158
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""

#: src/ch02-02-data-types.md:160
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""

#: src/ch02-02-data-types.md:162
msgid ""
"```rust\n"
"use traits::TryInto;\n"
"use traits::Into;\n"
"use option::OptionTrait;\n"
"\n"
"fn main() {\n"
"    let my_felt252 = 10;\n"
"    // Since a felt252 might not fit in a u8, we need to unwrap the "
"Option<T> type\n"
"    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
"    let my_u16: u16 = my_u8.into();\n"
"    let my_u32: u32 = my_u16.into();\n"
"    let my_u64: u64 = my_u32.into();\n"
"    let my_u128: u128 = my_u64.into();\n"
"    // As a felt252 is smaller than a u256, we can use the into() method\n"
"    let my_u256: u256 = my_felt252.into();\n"
"    let my_usize: usize = my_felt252.try_into().unwrap();\n"
"    let my_other_felt252: felt252 = my_u8.into();\n"
"    let my_third_felt252: felt252 = my_u16.into();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:183
msgid "### The Tuple Type"
msgstr ""

#: src/ch02-02-data-types.md:185
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a\n"
"variety of types into one compound type. Tuples have a fixed length: once\n"
"declared, they cannot grow or shrink in size."
msgstr ""

#: src/ch02-02-data-types.md:189
msgid ""
"We create a tuple by writing a comma-separated list of values inside\n"
"parentheses. Each position in the tuple has a type, and the types of the\n"
"different values in the tuple don’t have to be the same. We’ve added "
"optional\n"
"type annotations in this example:"
msgstr ""

#: src/ch02-02-data-types.md:194
msgid ""
"```rust\n"
"fn main() {\n"
"    let tup: (u32, u64, bool) = (10, 20, true);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:200
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered "
"a\n"
"single compound element. To get the individual values out of a tuple, we "
"can\n"
"use pattern matching to destructure a tuple value, like this:"
msgstr ""

#: src/ch02-02-data-types.md:204
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let tup = (500, 6, true);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    if y == 6 {\n"
"        'y is six!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:217
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then\n"
"uses a pattern with `let` to take `tup` and turn it into three separate\n"
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks\n"
"the single tuple into three parts. Finally, the program prints `y is six` as "
"the value of\n"
"`y` is `6`."
msgstr ""

#: src/ch02-02-data-types.md:223
msgid ""
"We can also declare the tuple with value and types at the same time.\n"
"For example:"
msgstr ""

#: src/ch02-02-data-types.md:226
msgid ""
"```rust\n"
"fn main() {\n"
"    let (x, y): (felt252, felt252) = (2, 3);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-data-types.md:232
msgid "### The unit type ()"
msgstr ""

#: src/ch02-02-data-types.md:234
msgid ""
"A _unit type_ is a type which has only one value `()`.\n"
"It is represented by a tuple with no elements.\n"
"Its size is always zero, and it is guaranteed to not exist in the compiled "
"code."
msgstr ""

#: src/ch02-03-functions.md:1
#: src/ch99-01-02-writing-starknet-contracts.md:137
msgid "## Functions"
msgstr ""

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most\n"
"important functions in the language: the `main` function, which is the "
"entry\n"
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to\n"
"declare new functions."
msgstr ""

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable\n"
"names, in which all letters are lowercase and underscores separate words.\n"
"Here’s a program that contains an example function definition:"
msgstr ""

#: src/ch02-03-functions.md:12
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn another_function() {\n"
"    'Another function.'.print();\n"
"}\n"
"\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"    another_function();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:25
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a\n"
"set of parentheses. The curly brackets tell the compiler where the function\n"
"body begins and ends."
msgstr ""

#: src/ch02-03-functions.md:29
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set\n"
"of parentheses. Because `another_function` is defined in the program, it can "
"be\n"
"called from inside the `main` function. Note that we defined "
"`another_function`\n"
"_before_ the `main` function in the source code; we could have defined it "
"after\n"
"as well. Cairo doesn’t care where you define your functions, only that "
"they’re\n"
"defined somewhere in a scope that can be seen by the caller."
msgstr ""

#: src/ch02-03-functions.md:36
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions\n"
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You\n"
"should see the following output:"
msgstr ""

#: src/ch02-03-functions.md:40
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)\n"
"[DEBUG] Another function.            (raw: "
"22265147635379277118623944509513687592494)\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:46
msgid ""
"The lines execute in the order in which they appear in the `main` function.\n"
"First the “Hello, world!” message prints, and then `another_function` is "
"called\n"
"and its message is printed."
msgstr ""

#: src/ch02-03-functions.md:50
msgid "### Parameters"
msgstr ""

#: src/ch02-03-functions.md:52
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that\n"
"are part of a function’s signature. When a function has parameters, you can\n"
"provide it with concrete values for those parameters. Technically, the "
"concrete\n"
"values are called _arguments_, but in casual conversation, people tend to "
"use\n"
"the words _parameter_ and _argument_ interchangeably for either the "
"variables\n"
"in a function’s definition or the concrete values passed in when you call a\n"
"function."
msgstr ""

#: src/ch02-03-functions.md:60
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch02-03-functions.md:62
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: felt252) {\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:74
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch02-03-functions.md:76
#: src/ch02-03-functions.md:276
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:81
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of\n"
"`x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the\n"
"`.print()` function outputs `5` in the console."
msgstr ""

#: src/ch02-03-functions.md:85
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is\n"
"a deliberate decision in Cairo’s design: requiring type annotations in "
"function\n"
"definitions means the compiler almost never needs you to use them elsewhere "
"in\n"
"the code to figure out what type you mean. The compiler is also able to "
"give\n"
"more helpful error messages if it knows what types the function expects."
msgstr ""

#: src/ch02-03-functions.md:91
msgid ""
"When defining multiple parameters, separate the parameter declarations with\n"
"commas, like this:"
msgstr ""

#: src/ch02-03-functions.md:94
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5, 6);\n"
"}\n"
"\n"
"fn another_function(x: felt252, y: felt252) {\n"
"    x.print();\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:107
msgid ""
"This example creates a function named `another_function` with two\n"
"parameters. The first parameter is named `x` and is an `felt252`. The second "
"is\n"
"named `y` and is type `felt252` too. The function then prints the content of "
"the felt `x` and then the content of the felt `y`."
msgstr ""

#: src/ch02-03-functions.md:111
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_\n"
"project’s _src/lib.cairo_ file with the preceding example and run it using "
"`cairo-run src/lib.cairo`:"
msgstr ""

#: src/ch02-03-functions.md:114
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"[DEBUG]                                 (raw: 6)\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:120
msgid ""
"Because we called the function with `5` as the value for `x` and `6` as\n"
"the value for `y`, the program output contains those values."
msgstr ""

#: src/ch02-03-functions.md:123
msgid "#### Named parameters"
msgstr ""

#: src/ch02-03-functions.md:125
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and "
"self-descriptive.\n"
"If you want to use named parameters, you need to specify the name of the "
"parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""

#: src/ch02-03-functions.md:128
msgid "Here is an example:"
msgstr ""

#: src/ch02-03-functions.md:130
msgid ""
"```rust\n"
"fn foo(x: u8, y: u8) {}\n"
"\n"
"fn main() {\n"
"    let first_arg = 3;\n"
"    let second_arg = 4;\n"
"    foo(x: first_arg, y: second_arg);\n"
"    let x = 1;\n"
"    let y = 2;\n"
"    foo(:x, :y)\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:143
msgid "### Statements and Expressions"
msgstr ""

#: src/ch02-03-functions.md:145
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an\n"
"expression. So far, the functions we’ve covered haven’t included an ending\n"
"expression, but you have seen an expression as part of a statement. Because\n"
"Cairo is an expression-based language, this is an important distinction to\n"
"understand. Other languages don’t have the same distinctions, so let’s look "
"at\n"
"what statements and expressions are and how their differences affect the "
"bodies\n"
"of functions."
msgstr ""

#: src/ch02-03-functions.md:153
msgid ""
"- **Statements** are instructions that perform some action and do not "
"return\n"
"  a value.\n"
"- **Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""

#: src/ch02-03-functions.md:157
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and\n"
"assigning a value to it with the `let` keyword is a statement. In Listing "
"2-1,\n"
"`let y = 6;` is a statement."
msgstr ""

#: src/ch02-03-functions.md:161
msgid ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:167
msgid ""
"<span class=\"caption\">Listing 2-1: A `main` function declaration "
"containing one statement</span>"
msgstr ""

#: src/ch02-03-functions.md:169
msgid ""
"Function definitions are also statements; the entire preceding example is a\n"
"statement in itself."
msgstr ""

#: src/ch02-03-functions.md:172
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement\n"
"to another variable, as the following code tries to do; you’ll get an error:"
msgstr ""

#: src/ch02-03-functions.md:175
msgid ""
"```rust,does_not_compile,ignore_format\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:181
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""

#: src/ch02-03-functions.md:183
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"error: Missing token TerminalRParen.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"                      ^\n"
"\n"
"error: Skipped tokens. Expected: statement.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:205
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for\n"
"`x` to bind to. This is different from what happens in other languages, such "
"as\n"
"C and Ruby, where the assignment returns the value of the assignment. In "
"those\n"
"languages, you can write `x = y = 6` and have both `x` and `y` have the "
"value\n"
"`6`; that is not the case in Cairo."
msgstr ""

#: src/ch02-03-functions.md:211
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that\n"
"you’ll write in Cairo. Consider a math operation, such as `5 + 6`, which is "
"an\n"
"expression that evaluates to the value `11`. Expressions can be part of\n"
"statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an\n"
"expression that evaluates to the value `6`. Calling a function is an\n"
"expression. A new scope block created with\n"
"curly brackets is an expression, for example:"
msgstr ""

#: src/ch02-03-functions.md:219
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:231
msgid "This expression:"
msgstr ""

#: src/ch02-03-functions.md:233
msgid ""
"```rust, does_not_compile, ignore_format\n"
"{\n"
"        let x = 3;\n"
"        x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:240
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y`\n"
"as part of the `let` statement. Note that the `x + 1` line doesn’t have a\n"
"semicolon at the end, which is unlike most of the lines you’ve seen so far.\n"
"Expressions do not include ending semicolons. If you add a semicolon to the "
"end\n"
"of an expression, you turn it into a statement, and it will then not return "
"a\n"
"value. Keep this in mind as you explore function return values and "
"expressions\n"
"next."
msgstr ""

#: src/ch02-03-functions.md:248
msgid "### Functions with Return Values"
msgstr ""

#: src/ch02-03-functions.md:250
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return\n"
"values, but we must declare their type after an arrow (`->`). In Cairo, the\n"
"return value of the function is synonymous with the value of the final\n"
"expression in the block of the body of a function. You can return early from "
"a\n"
"function by using the `return` keyword and specifying a value, but most\n"
"functions return the last expression implicitly. Here’s an example of a\n"
"function that returns a value:"
msgstr ""

#: src/ch02-03-functions.md:258
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn five() -> u32 {\n"
"    5\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:271
msgid ""
"There are no function calls, or even `let` statements in the `five`\n"
"function—just the number `5` by itself. That’s a perfectly valid function "
"in\n"
"Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try\n"
"running this code; the output should look like this:"
msgstr ""

#: src/ch02-03-functions.md:281
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type\n"
"is `u32`. Let’s examine this in more detail. There are two important bits:\n"
"first, the line `let x = five();` shows that we’re using the return value of "
"a\n"
"function to initialize a variable. Because the function `five` returns a "
"`5`,\n"
"that line is the same as the following:"
msgstr ""

#: src/ch02-03-functions.md:287
msgid ""
"```rust, does_not_compile\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:291
msgid ""
"Second, the `five` function has no parameters and defines the type of the\n"
"return value, but the body of the function is a lonely `5` with no "
"semicolon\n"
"because it’s an expression whose value we want to return.\n"
"Let’s look at another example:"
msgstr ""

#: src/ch02-03-functions.md:296
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:310
msgid ""
"Running this code will print `[DEBUG]                    (raw: 6)`. But if "
"we place a\n"
"semicolon at the end of the line containing `x + 1`, changing it from an\n"
"expression to a statement, we’ll get an error:"
msgstr ""

#: src/ch02-03-functions.md:314
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1;\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:328
msgid "Compiling this code produces an error, as follows:"
msgstr ""

#: src/ch02-03-functions.md:330
msgid ""
"```console\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"
msgstr ""

#: src/ch02-03-functions.md:334
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this\n"
"code. The definition of the function `plus_one` says that it will return an\n"
"`u32`, but statements don’t evaluate to a value, which is expressed by "
"`()`,\n"
"the unit type. Therefore, nothing is returned, which contradicts the "
"function\n"
"definition and results in an error."
msgstr ""

#: src/ch02-04-comments.md:1
msgid "# Comments"
msgstr ""

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using "
"comments. To create a comment, use the // syntax, after which any text on "
"the same line will be ignored by the compiler."
msgstr ""

#: src/ch02-04-comments.md:5
msgid ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:1
msgid "## Control Flow"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""

#: src/ch02-05-control-flow.md:5
msgid "### `if` Expressions"
msgstr ""

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""

#: src/ch02-05-control-flow.md:11
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    } else {\n"
"        'condition was false'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:31
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was false\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:36
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""

#: src/ch02-05-control-flow.md:38
msgid ""
"```rust, does_not_compile\n"
"    let number = 5;\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:42
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"condition was true\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:47
msgid ""
"It’s also worth noting that the condition in this code must be a bool. If "
"the condition isn’t a bool, we’ll get an error."
msgstr ""

#: src/ch02-05-control-flow.md:49
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. "
"Error: Could not specialize libfunc `enum_match` with generic_args: "
"[Type(ConcreteTypeId { id: 1, debug_name: None })]. Error: Provided generic "
"argument is unsupported.', "
"crates/cairo-lang-sierra-generator/src/utils.rs:256:9\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:54
msgid "### Handling Multiple Conditions with `else if`"
msgstr ""

#: src/ch02-05-control-flow.md:56
msgid ""
"You can use multiple conditions by combining if and else in an else if "
"expression. For example:"
msgstr ""

#: src/ch02-05-control-flow.md:60
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 12 {\n"
"        'number is 12'.print();\n"
"    } else if number == 3 {\n"
"        'number is 3'.print();\n"
"    } else if number - 2 == 1 {\n"
"        'number minus 2 is 1'.print();\n"
"    } else {\n"
"        'number not found'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:78
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""

#: src/ch02-05-control-flow.md:80
msgid ""
"```console\n"
"[DEBUG]\tnumber is 3\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1'.print()`, nor do we see the `number not found` text "
"from the `else` block. That’s because Cairo only executes the block for the "
"first true condition, and once it finds one, it doesn’t even check the rest. "
"Using too many `else if` expressions can clutter your code, so if you have "
"more than one, you might want to refactor your code. Chapter 5 describes a "
"powerful Cairo branching construct called `match` for these cases."
msgstr ""

#: src/ch02-05-control-flow.md:86
msgid "### Using `if` in a `let` statement"
msgstr ""

#: src/ch02-05-control-flow.md:88
msgid ""
"Because if is an expression, we can use it on the right side of a let "
"statement to assign the outcome to a variable."
msgstr ""

#: src/ch02-05-control-flow.md:92
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition {\n"
"        5\n"
"    } else {\n"
"        6\n"
"    };\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:109
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was true\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:114
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression. Which will be 5 here."
msgstr ""

#: src/ch02-05-control-flow.md:116
msgid "### Repetition with Loops"
msgstr ""

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called loops."
msgstr ""

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr ""

#: src/ch02-05-control-flow.md:122
msgid "#### Repeating Code with `loop`"
msgstr ""

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again\n"
"forever or until you explicitly tell it to stop."
msgstr ""

#: src/ch02-05-control-flow.md:127
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look\n"
"like this:"
msgstr ""

#: src/ch02-05-control-flow.md:132
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ();\n"
"        }\n"
"        'again!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously\n"
"until we stop the program manually, because the stop condition is never "
"reached.\n"
"While the compiler prevents us from writing programs without a stop "
"condition (`break` statement),\n"
"the stop condition might never be reached, resulting in an infinite loop.\n"
"Most terminals support the keyboard shortcut <span "
"class=\"keystroke\">ctrl-c</span> to interrupt a program that is\n"
"stuck in a continual loop. Give it a try:"
msgstr ""

#: src/ch02-05-control-flow.md:152
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo --available-gas=20000000\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"Run panicked with err values: [375233589013918064796019]\n"
"Remaining gas: 1050\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:166
msgid ""
"> Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurements that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In this case, the program panicked because it ran out of gas, as the stop "
"condition was never reached.\n"
"> It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network.\n"
"> If you're writing a program that needs to run a loop, you will need to "
"execute it with the `--available-gas` flag set to a value that is large "
"enough to run the program."
msgstr ""

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break` statement within the loop "
"to tell the program when to stop\n"
"executing the loop. Let's fix the infinite loop by adding a making the stop "
"condition `i > 10` reachable."
msgstr ""

#: src/ch02-05-control-flow.md:173
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ();\n"
"        }\n"
"        'again'.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:187
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""

#: src/ch02-05-control-flow.md:189
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ();\n"
"        }\n"
"        if i == 5 {\n"
"            i += 1;\n"
"            continue;\n"
"        }\n"
"        i.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:207
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""

#: src/ch02-05-control-flow.md:209
msgid "#### Returning Values from Loops"
msgstr ""

#: src/ch02-05-control-flow.md:211
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such\n"
"as checking whether an operation has succeeded. You might also need to pass\n"
"the result of that operation out of the loop to the rest of your code. To "
"do\n"
"this, you can add the value you want returned after the `break` expression "
"you\n"
"use to stop the loop; that value will be returned out of the loop so you "
"can\n"
"use it, as shown here:"
msgstr ""

#: src/ch02-05-control-flow.md:218
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"        counter += 1;\n"
"    };\n"
"\n"
"    'The result is '.print();\n"
"    result.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:235
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to\n"
"`0`. Then we declare a variable named `result` to hold the value returned "
"from\n"
"the loop. On every iteration of the loop, we check whether the `counter` is "
"equal to `10`, and then add `1` to the `counter` variable.\n"
"When the condition is met, we use the `break` keyword with the value "
"`counter * 2`. After the loop, we use a\n"
"semicolon to end the statement that assigns the value to `result`. Finally, "
"we\n"
"print the value in `result`, which in this case is `20`."
msgstr ""

#: src/ch02-06-common-collections.md:1
msgid "## Common Collections"
msgstr ""

#: src/ch02-06-common-collections.md:3
msgid ""
"Cairo1 provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo1: `Array` and `Felt252Dict` (coming soon)."
msgstr ""

#: src/ch02-06-common-collections.md:5
msgid "### Array"
msgstr ""

#: src/ch02-06-common-collections.md:7
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by importing the `array::ArrayTrait` trait."
msgstr ""

#: src/ch02-06-common-collections.md:9
msgid ""
"An important thing to note is that arrays have limited modifications "
"options. Arrays are, in fact, queues whose values can't be modified.\n"
"This has to do with the fact that once a memory slot is written to, it "
"cannot be overwritten, but only read from it. You can only append items to "
"the end of an array and remove items from the front using `pop_front`."
msgstr ""

#: src/ch02-06-common-collections.md:12
msgid "#### Creating an Array"
msgstr ""

#: src/ch02-06-common-collections.md:14
msgid ""
"Creating an Array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""

#: src/ch02-06-common-collections.md:16
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:27
msgid ""
"You can pass the expected type of items inside the array when instantiating "
"the array like this"
msgstr ""

#: src/ch02-06-common-collections.md:29
msgid ""
"```rust, does_not_compile\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:33
msgid "#### Updating an Array"
msgstr ""

#: src/ch02-06-common-collections.md:35
msgid "##### Adding Elements"
msgstr ""

#: src/ch02-06-common-collections.md:37
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""

#: src/ch02-06-common-collections.md:39
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"#     a.append(1);\n"
"#     a.append(2);\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:50
msgid "##### Removing Elements"
msgstr ""

#: src/ch02-06-common-collections.md:52
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method.\n"
"This method returns an `Option` containing the removed element, or "
"`Option::None` if the array is empty."
msgstr ""

#: src/ch02-06-common-collections.md:55
msgid ""
"```rust\n"
"use option::OptionTrait;\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:71
msgid ""
"The above code will print `10` as we remove the first element that was added."
msgstr ""

#: src/ch02-06-common-collections.md:73
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""

#: src/ch02-06-common-collections.md:75
msgid "#### Reading Elements from an Array"
msgstr ""

#: src/ch02-06-common-collections.md:77
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""

#: src/ch02-06-common-collections.md:79
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and "
"Snapshots](ch03-02-references-and-snapshots.md) chapter."
msgstr ""

#: src/ch02-06-common-collections.md:81
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use at when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""

#: src/ch02-06-common-collections.md:83
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""

#: src/ch02-06-common-collections.md:85
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"\n"
"    let first = *a.at(0);\n"
"    let second = *a.at(1);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:97
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that\n"
"is the value at index `0` in the array. The variable named `second` will "
"get\n"
"the value `1` from index `1` in the array."
msgstr ""

#: src/ch02-06-common-collections.md:101
msgid "Here is an example with the `get()` method:"
msgstr ""

#: src/ch02-06-common-collections.md:103
msgid ""
"```rust,ignore_format\n"
"use array::ArrayTrait;\n"
"use box::BoxTrait;\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100);\n"
"    let index_to_access =\n"
"        1; // Change this value to see different results, what would happen "
"if the index doesn't exist?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x.unbox()\n"
"        // Don't worry about * for now, if you are curious see Chapter 3.2 "
"#desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
"        },\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:126
msgid "#### Size related methods"
msgstr ""

#: src/ch02-06-common-collections.md:128
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return is of type `usize`."
msgstr ""

#: src/ch02-06-common-collections.md:130
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""

#: src/ch02-06-common-collections.md:132
msgid "#### Storing multiple types with Enums"
msgstr ""

#: src/ch02-06-common-collections.md:134
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types."
msgstr ""

#: src/ch02-06-common-collections.md:136
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use traits::Into;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"enum Data {\n"
"    Integer: u128,\n"
"    Felt: felt252,\n"
"    Tuple: (u32, u32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut messages: Array<Data> = ArrayTrait::new();\n"
"    messages.append(Data::Integer(100));\n"
"    messages.append(Data::Felt('hello world'));\n"
"    messages.append(Data::Tuple((10, 30)));\n"
"}\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:155
msgid "#### Span"
msgstr ""

#: src/ch02-06-common-collections.md:157
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch03-02-references-and-snapshots.md))"
msgstr ""

#: src/ch02-06-common-collections.md:159
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr ""

#: src/ch02-06-common-collections.md:161
msgid "##### Turning an Array into span"
msgstr ""

#: src/ch02-06-common-collections.md:163
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr ""

#: src/ch02-06-common-collections.md:165
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut array = ArrayTrait::new();\n"
"    array.span()\n"
"# }\n"
"```"
msgstr ""

#: src/ch02-06-common-collections.md:174
#: src/ch04-03-method-syntax.md:286
#: src/ch06-05-separating-modules-into-different-files.md:99
msgid "## Summary"
msgstr ""

#: src/ch02-06-common-collections.md:176
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments,\n"
"`if` expressions, loops, and common collections! To practice with the "
"concepts discussed in this chapter,\n"
"try building programs to do the following:"
msgstr ""

#: src/ch02-06-common-collections.md:180
msgid ""
"- Generate the _n_-th Fibonacci number.\n"
"- Compute the factorial of a number _n_."
msgstr ""

#: src/ch02-06-common-collections.md:183
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that _doesn’t_\n"
"commonly exist in other programming languages: ownership."
msgstr ""

#: src/ch03-00-understanding-ownership.md:1
msgid "# Understanding Cairo's Ownership system"
msgstr ""

#: src/ch03-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to\n"
"statically ensure that in every Cairo program, a value is used exactly "
"once.\n"
"This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time.\n"
"This is achieved by implementing an ownership system\n"
"and forbidding copying and dropping values by default. In this chapter, "
"we’ll\n"
"talk about Cairo's ownership system as well as references and snapshots."
msgstr ""

#: src/ch03-01-what-is-ownership.md:1
msgid "## What Is Ownership?"
msgstr ""

#: src/ch03-01-what-is-ownership.md:3
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of "
"its compiled code.\n"
"The ownership mechanism complements the linear type system, which enforces "
"that objects are used exactly once.\n"
"This helps prevent common operations that can produce runtime errors, such "
"as illegal memory address\n"
"references or multiple writes to the same memory address, and ensures the "
"soundness of Cairo programs\n"
"by checking at compile time that all the dictionaries are squashed."
msgstr ""

#: src/ch03-01-what-is-ownership.md:9
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{`\n"
"code in examples, so if you’re following along, make sure to put the "
"following\n"
"examples inside a `main` function manually. As a result, our examples will "
"be a\n"
"bit more concise, letting us focus on the actual details rather than\n"
"boilerplate code."
msgstr ""

#: src/ch03-01-what-is-ownership.md:15
msgid "### Ownership Rules"
msgstr ""

#: src/ch03-01-what-is-ownership.md:17
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as "
"we\n"
"work through the examples that illustrate them:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:20
msgid ""
"- Each value in Cairo has an _owner_.\n"
"- There can only be one owner at a time.\n"
"- When the owner goes out of scope, the value will be _dropped_."
msgstr ""

#: src/ch03-01-what-is-ownership.md:24
msgid "### Variable Scope"
msgstr ""

#: src/ch03-01-what-is-ownership.md:26
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some "
"variables. A\n"
"scope is the range within a program for which an item is valid. Take the\n"
"following variable:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:30
msgid ""
"```rust\n"
"let s = 'hello';\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:34
msgid ""
"The variable `s` refers to a short string, where the value of the string is\n"
"hardcoded into the text of our program. The variable is valid from the point "
"at\n"
"which it’s declared until the end of the current _scope_. Listing 3-1 shows "
"a\n"
"program with comments annotating where the variable `s` would be valid."
msgstr ""

#: src/ch03-01-what-is-ownership.md:39
msgid ""
"```rust\n"
"# fn main() {\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer "
"valid\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:49
msgid ""
"<span class=\"caption\">Listing 3-1: A variable and the scope in which it "
"is\n"
"valid</span>"
msgstr ""

#: src/ch03-01-what-is-ownership.md:52
msgid "In other words, there are two important points in time here:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:54
msgid ""
"- When `s` comes _into_ scope, it is valid.\n"
"- It remains valid until it goes _out of_ scope."
msgstr ""

#: src/ch03-01-what-is-ownership.md:57
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is\n"
"similar to that in other programming languages. Now we’ll build on top of "
"this\n"
"understanding by using the `Array` type we introduced in the [previous "
"chapter](ch02-06-common-collections.md)."
msgstr ""

#: src/ch03-01-what-is-ownership.md:61
msgid "### Ownership with the `Array` Type"
msgstr ""

#: src/ch03-01-what-is-ownership.md:63
msgid ""
"To illustrate the rules of ownership, we need a data type that is more "
"complex.\n"
"The types covered in the [“Data Types”][data-types]<!-- ignore --> section\n"
"of Chapter 2 are of a known size, can be\n"
"quickly and trivially copied to make a new, independent instance if another\n"
"part of code needs to use the same value in a different scope, and can "
"easily\n"
"be dropped when they're no longer used. But what is the behavior with the "
"`Array` type whose size\n"
"is unknown at compile time and which can't be trivially copied?"
msgstr ""

#: src/ch03-01-what-is-ownership.md:71
msgid "Here is a short reminder of what an array looks like:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:73
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(1);\n"
"    arr.append(2);\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:82
msgid ""
"So, how does the ownership system ensure that each cell is never written to "
"more than once?\n"
"Consider the following code, where we try to pass the same instance of an "
"array in two consecutive\n"
"function calls:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:86
msgid ""
"```rust,does_not_compile\n"
"use array::ArrayTrait;\n"
"fn foo(arr: Array<u128>) {}\n"
"\n"
"fn bar(arr: Array<u128>) {}\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    foo(arr);\n"
"    bar(arr);\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:99
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the "
"functions `foo` and `bar`, which means\n"
"that the parameter used in both function calls is the same instance of the "
"array. If you append a value to the array\n"
"in `foo`, and then try to append another value to the same array in `bar`, "
"what would happen is that\n"
"you would attempt to try to write to the same memory cell twice, which is "
"not allowed in Cairo.\n"
"To prevent this, the ownership of the `arr` variable moves from the `main` "
"function to the `foo` function. When trying\n"
"to call `bar` with `arr` as a parameter, the ownership of `arr` was already "
"moved to the first call. The ownership\n"
"system thus prevents us from using the same instance of `arr` in `foo`."
msgstr ""

#: src/ch03-01-what-is-ownership.md:107
msgid "Running the code above will result in a compile-time error:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:109
msgid ""
"```console\n"
"error: Variable was previously moved. Trait has no implementation in "
"context: core::traits::Copy::<core::array::Array::<core::integer::u128>>\n"
" --> array.cairo:6:9\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"        ^*****^\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:116
msgid "### The `Copy` Trait"
msgstr ""

#: src/ch03-01-what-is-ownership.md:118
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not "
"move the ownership of the value to the function called, but will instead "
"pass a copy of the value.\n"
"You can implement the `Copy` trait on your type by adding the "
"`#[derive(Copy)]` annotation to your type definition. However, Cairo won't "
"allow a type to be annotated with Copy if the type itself or any of its "
"components don't implement the Copy trait.\n"
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be."
msgstr ""

#: src/ch03-01-what-is-ownership.md:122
msgid ""
"```rust,ignore_format\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) {\n"
"    // do something with p\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:140
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, and the ownership of `p1` "
"remains with the main function.\n"
"If you remove the `Copy` trait derivation from the `Point` type, you will "
"get a compile-time error when trying to compile the code."
msgstr ""

#: src/ch03-01-what-is-ownership.md:143
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"4](ch04-00-using-structs-to-structure-related-data.md)._"
msgstr ""

#: src/ch03-01-what-is-ownership.md:145
msgid "### The `Drop` Trait"
msgstr ""

#: src/ch03-01-what-is-ownership.md:147
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. In Cairo, a value cannot go out of scope unless "
"it has been previously moved.\n"
"For example, the following code will not compile, because the struct `A` is "
"not moved before it goes out of scope:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:150
msgid ""
"```rust,does_not_compile\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:158
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the "
"fact that if a\n"
"statement during the execution of the program is false, no cheating prover "
"can convince an\n"
"honest verifier that it is true. In our case, we want to ensure the "
"consistency of\n"
"consecutive dictionary key updates during program execution, which is only "
"checked when\n"
"the dictionaries are `squashed` - which moves the ownership of the "
"dictionary to the\n"
"`squash` method, thus allowing the dictionary to go out of scope. Unsquashed "
"dictionaries\n"
"are dangerous, as a malicious prover could prove the correctness of "
"inconsistent updates."
msgstr ""

#: src/ch03-01-what-is-ownership.md:166
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of "
"scope without being explicitly moved. When a value of a type that implements "
"the `Drop` trait goes out of scope, the `Drop` implementation is called on "
"the type, which moves the value to the `drop` function, allowing it to go "
"out of scope - This is what we call \"dropping\" a value.\n"
"It is important to note that the implementation of drop is a \"no-op\", "
"meaning that it doesn't perform any actions other than allowing the value to "
"go out of scope."
msgstr ""

#: src/ch03-01-what-is-ownership.md:169
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be "
"dropped when going out of scope, except for dictionaries (`Felt252Dict`) and "
"types containing dictionaries.\n"
"For example, the following code compiles:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:172
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:181
msgid "### The `Destruct` Trait"
msgstr ""

#: src/ch03-01-what-is-ownership.md:183
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, "
"and it is easy to forget to do so. To make it easier to use dictionaries, "
"Cairo provides the `Destruct` trait, which allows you to specify the "
"behavior of a type when it goes out of scope. While Dictionaries don't "
"implement the `Drop` trait, they do implement the `Destruct` trait, which "
"allows them to automatically be `squashed` when they go out of scope. This "
"means that you can use dictionaries without having to manually call the "
"`squash` method."
msgstr ""

#: src/ch03-01-what-is-ownership.md:185
msgid ""
"Consider the following example, in which we define a custom type that "
"contains a dictionary:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:187
msgid ""
"```rust,does_not_compile\n"
"use dict::Felt252DictTrait;\n"
"\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Felt252DictTrait::new() };\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:199
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:201
msgid ""
"```console\n"
"error: Variable not dropped. Trait has no implementation in context: "
"core::traits::Drop::<temp7::temp7::A>. Trait has no implementation in "
"context: core::traits::Destruct::<temp7::temp7::A>.\n"
" --> temp7.cairo:7:5\n"
"    A {\n"
"    ^*^\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:208
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""

#: src/ch03-01-what-is-ownership.md:210
msgid ""
"```rust\n"
"use dict::Felt252DictTrait;\n"
"\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A { dict: Felt252DictTrait::new() }; // No error here\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:223
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""

#: src/ch03-01-what-is-ownership.md:225
msgid "### Copy Array data with Clone"
msgstr ""

#: src/ch03-01-what-is-ownership.md:227
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in Chapter 5, but because "
"methods are a common feature in many\n"
"programming languages, you’ve probably seen them before."
msgstr ""

#: src/ch03-01-what-is-ownership.md:230
msgid "Here’s an example of the `clone` method in action."
msgstr ""

#: src/ch03-01-what-is-ownership.md:232
msgid ""
"> Note: in the following example, we need to import the `Clone` trait from "
"the corelib `clone` module, and its implementation for the array type from "
"the `array` module."
msgstr ""

#: src/ch03-01-what-is-ownership.md:234
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use clone::Clone;\n"
"use array::ArrayTCloneImpl;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"    let arr2 = arr1.clone();\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:244
msgid ""
"> Note: you will need to run `cairo-run` with the `--available-gas=2000000` "
"option to run this example, because it uses a loop and must be ran with a "
"gas limit."
msgstr ""

#: src/ch03-01-what-is-ownership.md:246
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being\n"
"executed and that code may be expensive. It’s a visual indicator that "
"something\n"
"different is going on."
msgstr ""

#: src/ch03-01-what-is-ownership.md:250
msgid "### Ownership and Functions"
msgstr ""

#: src/ch03-01-what-is-ownership.md:252
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in "
"the Array section, passing an `Array` as a function parameter transfers its "
"ownership; let's see what happens with other types."
msgstr ""

#: src/ch03-01-what-is-ownership.md:254
msgid ""
"Listing 3-3 has an example with some annotations\n"
"showing where variables go into and out of scope."
msgstr ""

#: src/ch03-01-what-is-ownership.md:257
#: src/ch03-01-what-is-ownership.md:299
#: src/ch03-01-what-is-ownership.md:352
msgid "<span class=\"filename\">Filename: src/main.cairo</span>"
msgstr ""

#: src/ch03-01-what-is-ownership.md:259
msgid ""
"```rust,ignore_format\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the "
"function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is "
"okay to still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is "
"dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:285
msgid ""
"<span class=\"caption\">Listing 3-3: Functions with ownership and scope\n"
"annotated</span>"
msgstr ""

#: src/ch03-01-what-is-ownership.md:288
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo "
"would throw a\n"
"compile-time error. These static checks protect us from mistakes. Try "
"adding\n"
"code to `main` that uses `my_struct` and `x` to see where you can use them "
"and where\n"
"the ownership rules prevent you from doing so."
msgstr ""

#: src/ch03-01-what-is-ownership.md:293
msgid "### Return Values and Scope"
msgstr ""

#: src/ch03-01-what-is-ownership.md:295
msgid ""
"Returning values can also transfer ownership. Listing 3-4 shows an example "
"of a\n"
"function that returns some value, with similar annotations as those in "
"Listing\n"
"4-3."
msgstr ""

#: src/ch03-01-what-is-ownership.md:301
msgid ""
"```rust,ignore_format\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its "
"return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A {};                        // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A {};                    // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:339
msgid ""
"<span class=\"caption\">Listing 3-4: Transferring ownership of return\n"
"values</span>"
msgstr ""

#: src/ch03-01-what-is-ownership.md:342
msgid ""
"When a variable goes out of scope, its value is dropped, unless ownership of "
"the value has been moved to another variable."
msgstr ""

#: src/ch03-01-what-is-ownership.md:344
msgid ""
"While this works, taking ownership and then returning ownership with every\n"
"function is a bit tedious. What if we want to let a function use a value "
"but\n"
"not take ownership? It’s quite annoying that anything we pass in also needs "
"to\n"
"be passed back if we want to use it again, in addition to any data "
"resulting\n"
"from the body of the function that we might want to return as well."
msgstr ""

#: src/ch03-01-what-is-ownership.md:350
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"3-5."
msgstr ""

#: src/ch03-01-what-is-ownership.md:354
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"
msgstr ""

#: src/ch03-01-what-is-ownership.md:369
msgid ""
"<span class=\"caption\">Listing 3-5: Returning ownership of parameters</span>"
msgstr ""

#: src/ch03-01-what-is-ownership.md:371
msgid ""
"But this is too much ceremony and a lot of work for a concept that should "
"be\n"
"common. Luckily for us, Cairo has two features for using a value without\n"
"transferring ownership, called _references_ and _snapshots_."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:1
msgid "## References and Snapshots"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in Listing 3-5 is that we have to return the\n"
"`Array` to the calling function so we can still use the `Array` after the\n"
"call to `calculate_length`, because the `Array` was moved into\n"
"`calculate_length`."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:8
msgid "### Snapshots"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:10
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a "
"snapshot\n"
"is an immutable view of a value at a certain point in time. In the previous "
"chapter,\n"
"we talked about how Cairo's ownership system prevents us from using a value "
"after\n"
"we've moved it, protecting us from potentially writing twice to the same "
"memory cell when\n"
"appending values to arrays. However, it's not very convenient. Let's see how "
"we can retain ownership\n"
"of the value in the calling function using snapshots."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:17
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a\n"
"snapshot to an array as a parameter instead of taking ownership of the "
"underlying value. In this example,\n"
"the `calculate_length` function returns the length of the array passed as "
"parameter.\n"
"As we're passing it as a snapshot, which is an immutable view of the array, "
"we can be sure that\n"
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the main function."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:25
msgid ""
"```rust,ignore_format\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point "
"in time\n"
"    arr1.append(1); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(\n"
"        first_snapshot\n"
"    ); // Calculate the length of the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current "
"length of the array\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:46
msgid ""
"> Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:50
msgid ""
"```console\n"
"[DEBUG]\t                               \t(raw: 0)\n"
"\n"
"[DEBUG]\t                              \t(raw: 1)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:58
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note\n"
"that we pass `@arr1` into `calculate_length` and, in its definition, we take "
"`@Array<u128>` rather than `Array<u128>`."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:61
msgid "Let’s take a closer look at the function call here:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:63
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# use debug::PrintTrait;\n"
"# \n"
"# fn main() {\n"
"#     let mut arr1 = ArrayTrait::<u128>::new();\n"
"#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point "
"in time\n"
"#     arr1.append(1); // Mutate `arr1` by appending a value\n"
"#     let first_length = calculate_length(\n"
"#         first_snapshot\n"
"#     ); // Calculate the length of the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current "
"length of the array\n"
"#     first_length.print();\n"
"#     second_length.print();\n"
"# }\n"
"# \n"
"# fn calculate_length(arr: @Array<u128>) -> usize {\n"
"#     arr.len()\n"
"# }\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:84
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value, the value it points to cannot be "
"modified through the snapshot, and the value it refers to will not be "
"dropped once the snapshot stops being used."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:86
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:88
msgid ""
"```rust\n"
"fn calculate_length(\n"
"    array_snapshot: @Array<u128>\n"
") -> usize { // array_snapshot is a snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:97
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:99
msgid ""
"Snapshots can be converted back into regular values using the `desnap` "
"operator `*`, as long as the value type is copyable (which is not the case "
"for Arrays, as they don't implement `Copy`). In the following example, we "
"want to calculate the area of a rectangle, but we don't want to take "
"ownership of the rectangle in the `calculate_area` function, because we "
"might want to use the rectangle again after the function call. Since our "
"function doesn't mutate the rectangle instance, we can pass the snapshot of "
"the rectangle to the function, and then transform the snapshots back into "
"values using the `desnap` operator `*`."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:101
msgid ""
"The snapshot type is always copyable and droppable, so that you can use it "
"multiple times without worrying about ownership transfers."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:103
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of "
"the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:127
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? "
"Try the code in\n"
"Listing 3-6. Spoiler alert: it doesn’t work!"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:132
msgid ""
"```rust,does_not_compile\n"
"// does_not_compile\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    flip(@rec);\n"
"}\n"
"\n"
"fn flip(rec: @Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:152
msgid ""
"<span class=\"caption\">Listing 3-6: Attempting to modify a snapshot "
"value</span>"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:154
msgid "Here’s the error:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:156
msgid ""
"```console\n"
"error: Invalid left-hand side of assignment.\n"
" --> ownership.cairo:15:5\n"
"    rec.height = rec.width;\n"
"    ^********^\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:163
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:165
msgid "### Mutable References"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:167
msgid ""
"We can achieve the behavior we want in Listing 3-6 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution.\n"
"In Cairo, a parameter can be passed as _mutable reference_ using the `ref` "
"modifier."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:170
msgid ""
"> **Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:172
msgid ""
"In Listing 3-7, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:174
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rec = Rectangle { height: 3, width: 10 };\n"
"    flip(ref rec);\n"
"    rec.height.print();\n"
"    rec.width.print();\n"
"}\n"
"\n"
"fn flip(ref rec: Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:196
msgid ""
"<span class=\"caption\">Listing 3-7: Use of a mutable reference to modify a "
"value</span>"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:198
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:200
msgid "The output of the program is:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:202
msgid ""
"```console\n"
"[DEBUG]\n"
"                                (raw: 10)\n"
"\n"
"[DEBUG]\t                        (raw: 3)\n"
"```"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:209
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""

#: src/ch03-02-references-and-snapshots.md:211
msgid "### Small recap"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:213
msgid ""
"Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr ""

#: src/ch03-02-references-and-snapshots.md:215
msgid ""
"- At any given time, a variable can only have one owner.\n"
"- You can pass a variable by-value, by-snapshot, or by-reference to a "
"function.\n"
"- If you pass-by-value, ownership of the variable is transferred to the "
"function.\n"
"- If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`.\n"
"- If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""

#: src/ch04-00-using-structs-to-structure-related-data.md:1
msgid "# Using Structs to Structure Related Data"
msgstr ""

#: src/ch04-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""

#: src/ch04-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the next chapter) are the building blocks for "
"creating new types in your program’s domain to take full advantage of "
"Cairo's compile-time type checking."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:1
msgid "# Defining and Instantiating Structs"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in [The Data "
"Types](ch02-02-data-types.md) section, in that both hold multiple related "
"values. Like tuples, the pieces of a struct can be different types. Unlike "
"with tuples, in a struct you’ll name each piece of data so it’s clear what "
"the values mean. Adding these names means that structs are more flexible "
"than tuples: you don’t have to rely on the order of the data to specify or "
"access the values of an instance."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 4-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:7
#: src/ch04-01-defining-and-instantiating-structs.md:26
#: src/ch04-01-defining-and-instantiating-structs.md:48
#: src/ch04-01-defining-and-instantiating-structs.md:83
#: src/ch04-01-defining-and-instantiating-structs.md:118
msgid "<span class=\"filename\">Filename: structs.cairo</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:9
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:19
msgid "<span class=\"caption\">Listing 4-1: A `User` struct definition</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields.\n"
"We create an instance by stating the name of the struct and then add curly "
"brackets containing _key: value_ pairs, where the keys are the names of the "
"fields and the values are the data we want to store in those fields. We "
"don’t have to specify the fields in the same order in which we declared them "
"in the struct. In other words, the struct definition is like a general "
"template for the type, and instances fill in that template with particular "
"data to create values of the type."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 4-2."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:28
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true, username: 'someusername123', email: "
"'someone@example.com', sign_in_count: 1\n"
"    };\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:44
msgid ""
"<span class=\"caption\">Listing 4-2: Creating an instance of the `User` "
"struct</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:46
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 4-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:50
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true, username: 'someusername123', email: "
"'someone@example.com', sign_in_count: 1\n"
"    };\n"
"    user1.email = 'anotheremail@example.com';\n"
"}\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: "
"1,  }\n"
"# }\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1,  }\n"
"# }\n"
"# \n"
"```"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:75
msgid ""
"<span class=\"caption\">Listing 4-3: Changing the value in the email field "
"of a `User` instance</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:77
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:79
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:81
msgid ""
"Listing 4-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:85
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: "
"'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username: username, email: email, sign_in_count: 1, "
" }\n"
"}\n"
"# \n"
"# fn build_user_short(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username, email, sign_in_count: 1,  }\n"
"# }\n"
"# \n"
"```"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:110
msgid ""
"<span class=\"caption\">Listing 4-4: A `build_user` function that takes an "
"email and username and returns a `User` instance</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:112
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:114
msgid "## Using the Field Init Shorthand"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:116
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 4-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 4-5."
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:120
msgid ""
"```rust\n"
"# #[derive(Copy, Drop)]\n"
"# struct User {\n"
"#     active: bool,\n"
"#     username: felt252,\n"
"#     email: felt252,\n"
"#     sign_in_count: u64,\n"
"# }\n"
"# fn main() {\n"
"#     let mut user1 = User {\n"
"#         active: true, username: 'someusername123', email: "
"'someone@example.com', sign_in_count: 1\n"
"#     };\n"
"#     user1.email = 'anotheremail@example.com';\n"
"# }\n"
"# \n"
"# fn build_user(email: felt252, username: felt252) -> User {\n"
"#     User { active: true, username: username, email: email, sign_in_count: "
"1,  }\n"
"# }\n"
"# \n"
"fn build_user_short(email: felt252, username: felt252) -> User {\n"
"    User { active: true, username, email, sign_in_count: 1,  }\n"
"}\n"
"# \n"
"```"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:145
msgid ""
"<span class=\"caption\">Listing 4-5: A `build_user` function that uses field "
"init shorthand because the `username` and `email` parameters have the same "
"name as struct fields</span>"
msgstr ""

#: src/ch04-01-defining-and-instantiating-structs.md:147
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:1
msgid "# An Example Program Using Structs"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 4-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:9
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let width1 = 30;\n"
"    let height1 = 10;\n"
"    let area = area(width1, height1);\n"
"    area.print();\n"
"}\n"
"\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"    width * height\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:23
msgid ""
"<span class=\"caption\">Listing 4-6: Calculating the area of a rectangle "
"specified by separate width and height variables</span>"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:25
msgid "Now run the program with `cairo-run src/lib.cairo`:"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:27
msgid ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] ,                               (raw: 300)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:38
msgid ""
"```rust\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in [Chapter 3](ch02-02-data-types.html#the-tuple-type): "
"using tuples."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:44
msgid "## Refactoring with Tuples"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:46
msgid "Listing 4-7 shows another version of our program that uses tuples."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:50
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30, 10);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x, y) = dimension;\n"
"    x * y\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:64
msgid ""
"<span class=\"caption\">Listing 4-7: Specifying the width and height of the "
"rectangle with a tuple</span>"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:70
msgid "## Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:72
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:76
msgid ""
"```rust,ignore_format\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10,  };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:95
msgid "<span class=\"caption\">Listing 4-8: Defining a `Rectangle` struct</span>"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:97
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:99
msgid "## Adding Useful Functionality with Trait"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:101
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 4-9 "
"tries using the `print` as we have used in previous chapters. This won’t "
"work."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:105
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10,  };\n"
"    rectangle.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:119
msgid ""
"<span class=\"caption\">Listing 4-9: Attempting to print a `Rectangle` "
"instance</span>"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:121
msgid "When we compile this code, we get an error with this message:"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:123
msgid ""
"```bash\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you "
"import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:133
msgid ""
"The `print` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 4-10.\n"
"To learn more about traits, see [Traits in "
"Cairo](ch07-02-traits-in-cairo.md)."
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:138
msgid ""
"```rust,ignore_format\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle { width: 30, height: 10,  };\n"
"    rectangle.print();\n"
"}\n"
"\n"
"impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
"    fn print(self: Rectangle) {\n"
"        self.width.print();\n"
"        self.height.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:159
msgid ""
"<span class=\"caption\">Listing 4-10: Implementing the `PrintTrait` trait on "
"`Rectangle`</span>"
msgstr ""

#: src/ch04-02-an-example-program-using-structs.md:161
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr ""

#: src/ch04-03-method-syntax.md:1
msgid "## Method Syntax"
msgstr ""

#: src/ch04-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a\n"
"name, they can have parameters and a return value, and they contain some "
"code\n"
"that’s run when the method is called from somewhere else. Unlike functions,\n"
"methods are defined within the context of a type and their first parameter "
"is\n"
"always `self`, which represents the instance of the type the method is "
"being\n"
"called on. For those familiar with Rust, Cairo's approach might be "
"confusing,\n"
"as methods cannot be defined directly on types. Instead, you must define a "
"trait\n"
"and an implementation associated with the type for which the method is "
"intended."
msgstr ""

#: src/ch04-03-method-syntax.md:12
msgid "### Defining Methods"
msgstr ""

#: src/ch04-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter\n"
"and instead make an `area` method defined on the `RectangleTrait` trait, as "
"shown\n"
"in Listing 4-13."
msgstr ""

#: src/ch04-03-method-syntax.md:20
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50,  };\n"
"\n"
"    rect1.area().print();\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:45
msgid ""
"<span class=\"caption\">Listing 4-13: Defining an `area` method to use on "
"the\n"
"`Rectangle` </span>"
msgstr ""

#: src/ch04-03-method-syntax.md:48
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait`\n"
"block with the signature of the method that we want to implement. Traits are "
"not linked to\n"
"a specific type; only the `self` parameter of the method defines which type "
"it can be used\n"
"with. Then, we define an `impl` (implementation) block for `RectangleTrait`, "
"that defines\n"
"the behavior of the methods implemented. Everything within this `impl` block "
"will be\n"
"associated with the type of the `self` parameter of the method called. While "
"it is technically\n"
"possible to define methods for multiple types within the same `impl` block, "
"it is not\n"
"a recommended practice, as it can lead to confusion. We recommend that the "
"type of the `self` parameter\n"
"stays consistent within the same `impl` block.\n"
"Then we move the `area` function within the `impl` curly brackets and change "
"the first (and in this case, only)\n"
"parameter to be `self` in the signature and everywhere within the body. In\n"
"`main`, where we called the `area` function and passed `rect1` as an "
"argument,\n"
"we can instead use the _method syntax_ to call the `area` method on our "
"`Rectangle`\n"
"instance. The method syntax goes after an instance: we add a dot followed "
"by\n"
"the method name, parentheses, and any arguments."
msgstr ""

#: src/ch04-03-method-syntax.md:64
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter.\n"
"Note that we used the `@` snapshot operator in front of the `Rectangle` type "
"in the function signature.\n"
"By doing so, we indicate that this method takes an immutable snapshot of the "
"`Rectangle` instance, which is\n"
"automatically created by the compiler when passing the instance to the "
"method.\n"
"Methods can take ownership of `self`, use `self` with snapshots as we’ve "
"done here, or use a mutable reference to `self`\n"
"using the `ref self: T` syntax."
msgstr ""

#: src/ch04-03-method-syntax.md:71
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in "
"the function\n"
"version: we don’t want to take ownership, and we just want to read the data "
"in\n"
"the struct, not write to it. If we wanted to change the instance that we’ve\n"
"called the method on as part of what the method does, we’d use `ref self: "
"Rectangle` as\n"
"the first parameter. Having a method that takes ownership of the instance "
"by\n"
"using just `self` as the first parameter is rare; this technique is usually\n"
"used when the method transforms `self` into something else and you want to\n"
"prevent the caller from using the original instance after the transformation."
msgstr ""

#: src/ch04-03-method-syntax.md:80
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members.\n"
"This is necessary because the struct is passed as a snapshot, and all of its "
"field values are of type `@T`,\n"
"requiring them to be desnapped in order to manipulate them."
msgstr ""

#: src/ch04-03-method-syntax.md:84
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users\n"
"of our code search for capabilities of `Rectangle` in various places in the\n"
"library we provide. However, we can define multiple combinations of `trait` "
"& `impl` blocks for the same type at different places, which can be useful "
"for a more granular code organization. For example, you could implement\n"
"the `Add` trait for your type in one `impl` block, and the `Sub` trait in "
"another block."
msgstr ""

#: src/ch04-03-method-syntax.md:89
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s\n"
"fields. For example, we can define a method on `Rectangle` that is also "
"named\n"
"`width`:"
msgstr ""

#: src/ch04-03-method-syntax.md:95
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool {\n"
"        (*self.width) > 0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50,  };\n"
"    rect1.width().print();\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:119
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in\n"
"the instance’s `width` field is greater than `0` and `false` if the value "
"is\n"
"`0`: we can use a field within a method of the same name for any purpose. "
"In\n"
"`main`, when we follow `rect1.width` with parentheses, Cairo knows we mean "
"the\n"
"method `width`. When we don’t use parentheses, Cairo knows we mean the "
"field\n"
"`width`."
msgstr ""

#: src/ch04-03-method-syntax.md:126
msgid "### Methods with More Parameters"
msgstr ""

#: src/ch04-03-method-syntax.md:128
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle`\n"
"struct. This time we want an instance of `Rectangle` to take another "
"instance\n"
"of `Rectangle` and return `true` if the second `Rectangle` can fit "
"completely\n"
"within `self` (the first `Rectangle`); otherwise, it should return `false`.\n"
"That is, once we’ve defined the `can_hold` method, we want to be able to "
"write\n"
"the program shown in Listing 4-14."
msgstr ""

#: src/ch04-03-method-syntax.md:137
msgid ""
"```rust,does_not_compile\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30, height: 50,  };\n"
"    let rect2 = Rectangle { width: 10, height: 40,  };\n"
"    let rect3 = Rectangle { width: 60, height: 45,  };\n"
"\n"
"    'Can rect1 hold rect2?'.print();\n"
"    rect1.can_hold(@rect2).print();\n"
"\n"
"    'Can rect1 hold rect3?'.print();\n"
"    rect1.can_hold(@rect3).print();\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:158
msgid ""
"<span class=\"caption\">Listing 4-14: Using the as-yet-unwritten `can_hold`\n"
"method</span>"
msgstr ""

#: src/ch04-03-method-syntax.md:161
msgid ""
"The expected output would look like the following because both dimensions "
"of\n"
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than\n"
"`rect1`:"
msgstr ""

#: src/ch04-03-method-syntax.md:165
msgid ""
"```text\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\tCan rec1 hold rect2?           \t(raw: "
"384675147322001379018464490539350216396261044799)\n"
"\n"
"[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
"\n"
"[DEBUG]\tCan rect1 hold rect3?          \t(raw: "
"384675147322001384331925548502381811111693612095)\n"
"\n"
"[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
"\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:177
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait`\n"
"and `impl RectangleImpl of RectangleTrait` blocks.\n"
"The method name will be `can_hold`, and it will take a snapshot\n"
"of another `Rectangle` as a parameter. We can tell what the type of the\n"
"parameter will be by looking at the code that calls the method:\n"
"`rect1.can_hold(@rect2)` passes in `@rect2`, which is a snapshot to\n"
"`rect2`, an instance of `Rectangle`. This makes sense because we only need "
"to\n"
"read `rect2` (rather than write, which would mean we’d need a mutable "
"borrow),\n"
"and we want `main` to retain ownership of `rect2` so we can use it again "
"after\n"
"calling the `can_hold` method. The return value of `can_hold` will be a\n"
"Boolean, and the implementation will check whether the width and height of\n"
"`self` are greater than the width and height of the other `Rectangle`,\n"
"respectively. Let’s add the new `can_hold` method to the `trait` and `impl` "
"blocks from\n"
"Listing 4-13, shown in Listing 4-15."
msgstr ""

#: src/ch04-03-method-syntax.md:194
#: src/ch08-01-how-to-write-tests.md:134
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:211
msgid ""
"<span class=\"caption\">Listing 4-15: Implementing the `can_hold` method on\n"
"`Rectangle` that takes another `Rectangle` instance as a parameter</span>"
msgstr ""

#: src/ch04-03-method-syntax.md:214
msgid ""
"When we run this code with the `main` function in Listing 4-14, we’ll get "
"our\n"
"desired output. Methods can take multiple parameters that we add to the\n"
"signature after the `self` parameter, and those parameters work just like\n"
"parameters in functions."
msgstr ""

#: src/ch04-03-method-syntax.md:219
msgid "### Accessing implementation functions"
msgstr ""

#: src/ch04-03-method-syntax.md:221
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed\n"
"using the `::` operator on the implementation name.\n"
"Functions in traits that aren’t methods are often used for constructors "
"that\n"
"will return a new instance of the struct. These are often called `new`, but\n"
"`new` isn’t a special name and isn’t built into the language. For example, "
"we\n"
"could choose to provide an associated function named `square` that would "
"have\n"
"one dimension parameter and use that as both width and height, thus making "
"it\n"
"easier to create a square `Rectangle` rather than having to specify the "
"same\n"
"value twice:"
msgstr ""

#: src/ch04-03-method-syntax.md:233
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle {\n"
"        Rectangle { width: size, height: size }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:245
msgid ""
"To call this function, we use the `::` syntax with the implementation name;\n"
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by\n"
"the implementation; the `::` syntax is used for both trait functions and\n"
"namespaces created by modules. We’ll discuss modules in [Chapter "
"7][modules]<!-- ignore -->."
msgstr ""

#: src/ch04-03-method-syntax.md:250
msgid ""
"> Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""

#: src/ch04-03-method-syntax.md:252
msgid "### Multiple `impl` Blocks"
msgstr ""

#: src/ch04-03-method-syntax.md:254
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing\n"
"5-15 is equivalent to the code shown in Listing 4-16, which has each method "
"in\n"
"its own `trait` and `impl` blocks."
msgstr ""

#: src/ch04-03-method-syntax.md:258
msgid ""
"```rust\n"
"trait RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"impl RectangleCalcImpl of RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"trait RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleCmpImpl of RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-method-syntax.md:279
msgid ""
"<span class=\"caption\">Listing 4-16: Rewriting Listing 4-15 using multiple "
"`impl`\n"
"blocks</span>"
msgstr ""

#: src/ch04-03-method-syntax.md:282
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` "
"blocks here,\n"
"but this is valid syntax. We’ll see a case in which multiple blocks are\n"
"useful in [Chapter 7](ch07-00-generic-types-and-traits.md), where we discuss "
"generic types and traits."
msgstr ""

#: src/ch04-03-method-syntax.md:288
msgid ""
"Structs let you create custom types that are meaningful for your domain. By\n"
"using structs, you can keep associated pieces of data connected to each "
"other\n"
"and name each piece to make your code clear. In `trait` and `impl` blocks, "
"you can define\n"
"methods, which are functions associated to a type and let you specify the "
"behavior that instances of your\n"
"type have."
msgstr ""

#: src/ch04-03-method-syntax.md:294
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to\n"
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""

#: src/ch05-00-enums-and-pattern-matching.md:1
msgid "# Enums and Pattern Matching"
msgstr ""

#: src/ch05-01-enums.md:1
msgid "# Enums"
msgstr ""

#: src/ch05-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""

#: src/ch05-01-enums.md:5
msgid "## Enum Variants and Values"
msgstr ""

#: src/ch05-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr ""

#: src/ch05-01-enums.md:9
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"enum Direction {\n"
"    North: (),\n"
"    East: (),\n"
"    South: (),\n"
"    West: (),\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-enums.md:19
msgid ""
"Unlike other languages like Rust, every variant has a type. In this example, "
"we've defined an enum called `Direction` with four variants: `North`, "
"`East`, `South`, and `West`. The naming convention is to use PascalCase for "
"enum variants. Each variant represents a distinct value of the Direction "
"type and is associated with a unit type `()`. One variant can be "
"instantiated using this syntax:"
msgstr ""

#: src/ch05-01-enums.md:21
msgid ""
"```rust\n"
"# #[derive(Drop)]\n"
"# enum Direction {\n"
"#     North: (),\n"
"#     East: (),\n"
"#     South: (),\n"
"#     West: (),\n"
"# }\n"
"# \n"
"# fn main() {\n"
"    let direction = Direction::North(());\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch05-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch05-02-the-match-control-flow-construct.md)."
msgstr ""

#: src/ch05-01-enums.md:39
msgid "## Enums Combined with Custom Types"
msgstr ""

#: src/ch05-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr ""

#: src/ch05-01-enums.md:43
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"enum Message {\n"
"    Quit: (),\n"
"    Echo: felt252,\n"
"    Move: (u128, u128),\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""

#: src/ch05-01-enums.md:54
msgid ""
"- `Quit` is the unit type - it has no data associated with it at all.\n"
"- `Echo` is a single felt.\n"
"- `Move` is a tuple of two u128 values."
msgstr ""

#: src/ch05-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr ""

#: src/ch05-01-enums.md:60
msgid "## Trait Implementations for Enums"
msgstr ""

#: src/ch05-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""

#: src/ch05-01-enums.md:64
msgid ""
"```rs\n"
"trait Processing {\n"
"    fn process(self: Message);\n"
"}\n"
"\n"
"impl ProcessingImpl of Processing {\n"
"    fn process(self: Message) {\n"
"        match self {\n"
"            Message::Quit(()) => {\n"
"                'quitting'.print();\n"
"            },\n"
"            Message::Echo(value) => {\n"
"                value.print();\n"
"            },\n"
"            Message::Move((x, y)) => {\n"
"                'moving'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-enums.md:86
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""

#: src/ch05-01-enums.md:88
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Drop)]\n"
"# enum Message {\n"
"#     Quit: (),\n"
"#     Echo: felt252,\n"
"#     Move: (u128, u128),\n"
"# }\n"
"# \n"
"# trait Processing {\n"
"#     fn process(self: Message);\n"
"# }\n"
"# \n"
"# impl ProcessingImpl of Processing {\n"
"#     fn process(self: Message) {\n"
"#         match self {\n"
"#             Message::Quit(()) => {\n"
"#                 'quitting'.print();\n"
"#             },\n"
"#             Message::Echo(value) => {\n"
"#                 value.print();\n"
"#             },\n"
"#             Message::Move((x, y)) => {\n"
"#                 'moving'.print();\n"
"#             },\n"
"#         }\n"
"#     }\n"
"# }\n"
"# fn main() {\n"
"    let msg: Message = Message::Quit(());\n"
"    msg.process();\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch05-01-enums.md:124
msgid "Running this code would print `quitting`."
msgstr ""

#: src/ch05-01-enums.md:126
msgid "## The Option Enum and Its Advantages"
msgstr ""

#: src/ch05-01-enums.md:128
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""

#: src/ch05-01-enums.md:130
#: src/ch05-02-the-match-control-flow-construct.md:136
#: src/ch07-01-generic-data-types.md:174
msgid ""
"```rust\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None: (),\n"
"}\n"
"```"
msgstr ""

#: src/ch05-01-enums.md:137
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""

#: src/ch05-01-enums.md:139
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""

#: src/ch05-01-enums.md:141
msgid "We are demonstrating two approaches for the above function:"
msgstr ""

#: src/ch05-01-enums.md:143
msgid ""
"- Recursive Approach `find_value_recursive`\n"
"- Iterative Approach `find_value_iterative`"
msgstr ""

#: src/ch05-01-enums.md:146
msgid ""
"> Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr ""

#: src/ch05-01-enums.md:148
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"use option::OptionTrait;\n"
"fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: usize) "
"-> Option<usize> {\n"
"    if index >= arr.len() {\n"
"        return Option::None(());\n"
"    }\n"
"\n"
"    if *arr.at(index) == value {\n"
"        return Option::Some(index);\n"
"    }\n"
"\n"
"    find_value_recursive(arr, value, index + 1)\n"
"}\n"
"\n"
"fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> "
"Option<usize> {\n"
"    let length = arr.len();\n"
"    let mut index = 0;\n"
"    let mut found: Option<usize> = Option::None(());\n"
"    loop {\n"
"        if index < length {\n"
"            if *arr.at(index) == value {\n"
"                found = Option::Some(index);\n"
"                break ();\n"
"            }\n"
"        } else {\n"
"            break ();\n"
"        }\n"
"        index += 1;\n"
"    };\n"
"    return found;\n"
"}\n"
"\n"
"#[test]\n"
"#[available_gas(999999)]\n"
"fn test_increase_amount() {\n"
"    let mut my_array = ArrayTrait::new();\n"
"    my_array.append(3);\n"
"    my_array.append(7);\n"
"    my_array.append(2);\n"
"    my_array.append(5);\n"
"\n"
"    let value_to_find = 7;\n"
"    let result = find_value_recursive(@my_array, value_to_find, 0);\n"
"    let result_i = find_value_iterative(@my_array, value_to_find);\n"
"\n"
"    match result {\n"
"        Option::Some(index) => {\n"
"            if index == 1 {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"    match result_i {\n"
"        Option::Some(index) => {\n"
"            if index == 1 {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch05-01-enums.md:219
msgid "Running this code would print `it worked`."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:1
msgid "# The Match Control Flow Construct"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:3
msgid ""
"<!-- TODO : update mention of chapter 18 (on patterns and matching chapter) "
"in paragraph below -->"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of match "
"comes from the expressiveness of the patterns and the fact that the compiler "
"confirms that all possible cases are handled."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:9
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a "
"function that takes an unknown US coin and, in a similar way as the counting "
"machine, determines which coin it is and returns its value in cents, as "
"shown in Listing 5-3."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:11
msgid ""
"```rust\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (),\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(_) => 25,\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:29
msgid ""
"Listing 5-3: An enum and a match expression that has the variants of the "
"enum as its patterns"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list "
"the `match` keyword followed by an expression, which in this case is the "
"value `coin`. This seems very similar to a conditional expression used with "
"if, but there’s a big difference: with if, the condition needs to evaluate "
"to a Boolean value, but here it can be any type. The type of coin in this "
"example is the `Coin` enum that we defined on the first line."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny(_)` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in order. If a pattern matches the value, "
"the code associated with that pattern is executed. If that pattern doesn’t "
"match the value, execution continues to the next arm, much as in a "
"coin-sorting machine. We can have as many arms as we need: in the above "
"example, our match has four arms."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:41
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it "
"is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a match arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny(())`, but still "
"returns the last value of the block, `1`:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:43
msgid ""
"```rust\n"
"\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:47
msgid "## Patterns That Bind to Values"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:49
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:51
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 5-4."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:53
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"enum UsState {\n"
"    Alabama: (),\n"
"    Alaska: (),\n"
"}\n"
"\n"
"#[derive(Drop)]\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (UsState, ),\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:69
msgid ""
"Listing 5-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:71
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:73
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:75
msgid ""
"```rust\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(state) => {\n"
"            state.print();\n"
"            25\n"
"        },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:89
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an "
"implementation for the `print` function for the `debug::PrintTrait`:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:91
msgid ""
"```rust\n"
"impl UsStatePrintImpl of PrintTrait<UsState> {\n"
"    fn print(self: UsState) {\n"
"        match self {\n"
"            UsState::Alabama(_) => ('Alabama').print(),\n"
"            UsState::Alaska(_) => ('Alaska').print(),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:102
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, "
"`coin` would be `Coin::Quarter(UsState::Alaska())`. When we compare that "
"value with each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for state will be the "
"value `UsState::Alaska()`. We can then use that binding in the `PrintTrait`, "
"thus getting the inner state value out of the `Coin` enum variant for "
"`Quarter`."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:104
msgid "## Matching with Options"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:106
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same. You can use Options by importing the "
"`option::OptionTrait` trait."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:108
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:110
msgid ""
"This function is very easy to write, thanks to match, and will look like "
"Listing 5-5."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:112
msgid ""
"```rust\n"
"use option::OptionTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"        Option::None(_) => Option::None(()),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let five: Option<u8> = Option::Some(5);\n"
"    let six: Option<u8> = plus_one(five);\n"
"    six.unwrap().print();\n"
"    let none = plus_one(Option::None(()));\n"
"    none.unwrap().print();\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:132
msgid "Listing 5-5: A function that uses a match expression on an `Option<u8>`"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:134
msgid ""
"Note that your arms must respect the same order as the enum defined in the "
"`OptionTrait` of the core Cairo lib."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:143
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:145
#: src/ch05-02-the-match-control-flow-construct.md:153
msgid ""
"```rust\n"
"        Option::Some(val) => Option::Some(val + 1),\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:149
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the match arm is "
"then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:151
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None(())`. We enter the match and compare to the first arm:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:157
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:159
msgid ""
"```rust\n"
"        Option::None(_) => Option::None(()),\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:163
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`Option::None(())` value on the right side of `=>`."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:165
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:167
msgid "## Matches Are Exhaustive"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:169
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:171
msgid ""
"```rust\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1), \n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:179
msgid ""
"```bash\n"
"$ cairo-run src/test.cairo\n"
"    error: Unsupported match. Currently, matches require one arm per "
"variant,\n"
"    in the order of variant definition.\n"
"    --> test.cairo:34:5\n"
"        match x {\n"
"        ^*******^\n"
"    Error: failed to compile: ./src/test.cairo\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:189
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:191
msgid "## Match 0 and the \\_ Placeholder"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:193
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. Currently only `0` and the "
"`_`operator are supported."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:195
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 "
"and 7. If you have 0, you win. For all other values you lose. Here's a match "
"that implements that logic, with the number hardcoded rather than a random "
"value."
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:197
msgid ""
"```rust\n"
"fn did_i_win(nb: felt252) {\n"
"    match nb {\n"
"        0 => ('You won!').print(),\n"
"        _ => ('You lost...').print(),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:206
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that "
"covers every other possible value, the pattern is the character `_`. This "
"code compiles, even though we haven’t listed all the possible values a "
"`felt252` can have, because the last pattern will match all values not "
"specifically listed. This catch-all pattern meets the requirement that "
"`match` must be exhaustive. Note that we have to put the catch-all arm last "
"because the patterns are evaluated in order. If we put the catch-all arm "
"earlier, the other arms would never run, so Cairo will warn us if we add "
"arms after a catch-all!"
msgstr ""

#: src/ch05-02-the-match-control-flow-construct.md:208
msgid ""
"<!-- TODO : might need to link the end of this chapter to patterns and "
"matching chapter -->"
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "# Managing Cairo Projects with Packages, Crates and Modules"
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly\n"
"important. By grouping related functionality and separating code with "
"distinct\n"
"features, you’ll clarify where to find code that implements a particular\n"
"feature and where to go to change how a feature works."
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a\n"
"project grows, you should organize code by splitting it into multiple "
"modules\n"
"and then multiple files. As a package grows, you can extract parts into\n"
"separate crates that become external dependencies. This chapter covers all\n"
"these techniques."
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse\n"
"code at a higher level: once you’ve implemented an operation, other code "
"can\n"
"call your code without having to know how the\n"
"implementation works."
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a\n"
"set of names that are defined as “in scope.” When reading, writing, and\n"
"compiling code, programmers and compilers need to know whether a particular\n"
"name at a particular spot refers to a variable, function, struct, enum, "
"module,\n"
"constant, or other item and what that item means. You can create scopes and\n"
"change which names are in or out of scope. You can’t have two items with "
"the\n"
"same name in the same scope."
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s\n"
"organization. These features, sometimes\n"
"collectively referred to as the _module system_, include:"
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"- **Packages:** A Scarb feature that lets you build, test, and share crates\n"
"- **Crates:** A tree of modules that corresponds to a single compilation "
"unit.\n"
"  It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory.\n"
"- **Modules** and **use:** Let you control the organization and scope of "
"items.\n"
"- **Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and\n"
"explain how to use them to manage scope. By the end, you should have a "
"solid\n"
"understanding of the module system and be able to work with scopes like a "
"pro!"
msgstr ""

#: src/ch06-01-packages-and-crates.md:1
msgid "# Packages and Crates"
msgstr ""

#: src/ch06-01-packages-and-crates.md:3
msgid "## What is a crate?"
msgstr ""

#: src/ch06-01-packages-and-crates.md:4
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a "
"single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""

#: src/ch06-01-packages-and-crates.md:6
msgid "## What is the crate root?"
msgstr ""

#: src/ch06-01-packages-and-crates.md:7
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts "
"from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control "
"Scope”](./ch06-02-defining-modules-to-control-scope.md) section)."
msgstr ""

#: src/ch06-01-packages-and-crates.md:9
msgid "## What is a package?"
msgstr ""

#: src/ch06-01-packages-and-crates.md:10
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code "
"into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr ""

#: src/ch06-01-packages-and-crates.md:12
msgid "## Creating a Package with Scarb"
msgstr ""

#: src/ch06-01-packages-and-crates.md:14
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""

#: src/ch06-01-packages-and-crates.md:16
msgid ""
"```bash\n"
"scarb new my_package\n"
"```"
msgstr ""

#: src/ch06-01-packages-and-crates.md:20
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr ""

#: src/ch06-01-packages-and-crates.md:22
msgid ""
"```\n"
"my_package/\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""

#: src/ch06-01-packages-and-crates.md:29
msgid ""
"- `src/` is the main directory where all the Cairo source files for the "
"package will be stored.\n"
"- `lib.cairo` is the default root module of the crate, which is also the "
"main entry point of the package. By default, it is empty.\n"
"- `Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""

#: src/ch06-01-packages-and-crates.md:33
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch06-01-packages-and-crates.md:42
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo` "
"files within the `src` directory or its subdirectories."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:1
msgid "## Defining Modules to Control Scope"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system,\n"
"namely _paths_ that allow you to name items and the `use` keyword that "
"brings a\n"
"path into scope."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re\n"
"organizing your code in the future. Then we’ll explain each of the rules in\n"
"detail."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:11
msgid "### Modules Cheat Sheet"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword\n"
"work in the compiler, and how most developers organize their\n"
"code. We’ll be going through examples of each of these rules throughout "
"this\n"
"chapter, but this is a great place to refer to as a reminder of how modules\n"
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:19
msgid ""
"- **Start from the crate root**: When compiling a crate, the compiler first\n"
"  looks in the crate root file (_src/lib.cairo_) for code to compile.\n"
"- **Declaring modules**: In the crate root file, you can declare new "
"modules;\n"
"  say, you declare a “garden” module with `mod garden;`. The compiler will "
"look\n"
"  for the module’s code in these places:\n"
"\n"
"  - Inline, within curly brackets that replace the semicolon following `mod "
"garden;`.\n"
"\n"
"    ```rust\n"
"      // crate root file (lib.cairo)\n"
"        mod garden {\n"
"        // code defining the garden module goes here\n"
"        }\n"
"    ```\n"
"\n"
"- In the file _src/garden.cairo_\n"
"- **Declaring submodules**: In any file other than the crate root, you can\n"
"  declare submodules. For example, you might declare `mod vegetables;` in\n"
"  _src/garden.cairo_. The compiler will look for the submodule’s code within "
"the\n"
"  directory named for the parent module in these places:\n"
"\n"
"  - Inline, directly following `mod vegetables`, within curly brackets "
"instead\n"
"    of the semicolon.\n"
"\n"
"    ```rust\n"
"    // src/garden.cairo file\n"
"    mod vegetables {\n"
"        // code defining the vegetables submodule goes here\n"
"    }\n"
"    ```\n"
"\n"
"  - In the file _src/garden/vegetables.cairo_\n"
"\n"
"- **Paths to code in modules**: Once a module is part of your crate, you "
"can\n"
"  refer to code in that module from anywhere else in that same crate, using "
"the path\n"
"  to the code. For example, an `Asparagus` type in the garden vegetables "
"module would be found at\n"
"  `backyard::garden::vegetables::Asparagus`.\n"
"- **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to\n"
"  items to reduce repetition of long paths. In any scope that can refer to\n"
"  `backyard::garden::vegetables::Asparagus`, you can create a shortcut with\n"
"  `use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to\n"
"  write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:62
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The\n"
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:65
msgid ""
"```text\n"
"backyard/\n"
"├── Scarb.toml\n"
"├── cairo_project.toml\n"
"└── src\n"
"    ├── garden\n"
"    │   └── vegetables.cairo\n"
"    ├── garden.cairo\n"
"    └── lib.cairo\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:76
msgid ""
"> Note: You will notice here a `cairo_project.toml` file.\n"
"> This is the configuration file for \"vanilla\" Cairo projects (i.e. not "
"managed by Scarb),\n"
"> which is required to run the `cairo-run .` command to run the code of the "
"crate.\n"
"> It is required until Scarb implements this feature. The content of the "
"file is:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> backyard = \"src\"\n"
"> ```\n"
">\n"
"> and indicates that the crate named \"backyard\" is located in the `src` "
"directory."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:88
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:92
msgid ""
"```rust\n"
"// does_not_compile\n"
"use garden::vegetables::Asparagus;\n"
"\n"
"mod garden;\n"
"\n"
"fn main() {\n"
"    let Asparagus = Asparagus {};\n"
"}\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:103
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:105
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:107
msgid ""
"```rust\n"
"mod vegetables;\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:111
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is\n"
"included too. That code is:"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:114
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Asparagus {}\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:119
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the "
"`Asparagus` type into scope,\n"
"so we can use it in the `main` function."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:122
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:124
msgid "### Grouping Related Code in Modules"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:126
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse.\n"
"As an example, let’s write a library crate that provides the functionality "
"of a\n"
"restaurant. We’ll define the signatures of functions but leave their bodies\n"
"empty to concentrate on the organization of the code, rather than the\n"
"implementation of a restaurant."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:132
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as\n"
"_front of house_ and others as _back of house_. Front of house is where\n"
"customers are; this encompasses where the hosts seat customers, servers "
"take\n"
"orders and payment, and bartenders make drinks. Back of house is where the\n"
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do\n"
"administrative work."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:139
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested\n"
"modules. Create a new package named `restaurant` by running `scarb new "
"restaurant`; then enter the code in Listing 6-1 into _src/lib.cairo_ to\n"
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:145
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:163
msgid ""
"<span class=\"caption\">Listing 6-1: A `front_of_house` module containing "
"other\n"
"modules that then contain functions</span>"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:166
msgid ""
"We define a module with the `mod` keyword followed by the name of the "
"module\n"
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly\n"
"brackets. Inside modules, we can place other modules, as in this case with "
"the\n"
"modules `hosting` and `serving`. Modules can also hold definitions for "
"other\n"
"items, such as structs, enums, constants, traits, and—as in Listing\n"
"6-1—functions."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:173
msgid ""
"By using modules, we can group related definitions together and name why\n"
"they’re related. Programmers using this code can navigate the code based on "
"the\n"
"groups rather than having to read through all the definitions, making it "
"easier\n"
"to find the definitions relevant to them. Programmers adding new "
"functionality\n"
"to this code would know where to place the code to keep the program "
"organized."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:179
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate\n"
"root. The reason for this name is that the content of this file form a "
"module named after the crate name at the root of the crate’s module "
"structure,\n"
"known as the _module tree_."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:183
msgid "Listing 6-2 shows the module tree for the structure in Listing 6-1."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:185
msgid ""
"```text\n"
"restaurant\n"
" └── front_of_house\n"
"     ├── hosting\n"
"     │   ├── add_to_waitlist\n"
"     │   └── seat_at_table\n"
"     └── serving\n"
"         ├── take_order\n"
"         ├── serve_order\n"
"         └── take_payment\n"
"```"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:197
msgid ""
"<span class=\"caption\">Listing 6-2: The module tree for the code in "
"Listing\n"
"6-1</span>"
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:200
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example,\n"
"`hosting` nests inside `front_of_house`. The tree also shows that some "
"modules\n"
"are _siblings_ to each other, meaning they’re defined in the same module;\n"
"`hosting` and `serving` are siblings defined within `front_of_house`. If "
"module\n"
"A is contained inside module B, we say that module A is the _child_ of "
"module B\n"
"and that module B is the _parent_ of module A. Notice that the entire "
"module\n"
"tree is rooted under the explicit name of the crate `restaurant`."
msgstr ""

#: src/ch06-02-defining-modules-to-control-scope.md:208
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your\n"
"computer; this is a very apt comparison! Just like directories in a "
"filesystem,\n"
"you use modules to organize your code. And just like files in a directory, "
"we\n"
"need a way to find our modules."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "## Paths for Referring to an Item in the Module Tree"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"- An _absolute path_ is the full path starting from a crate root. The "
"absolute path begins with the crate name.\n"
"- A _relative path_ starts from the current module.\n"
"\n"
"  Both absolute and relative paths are followed by one or more identifiers\n"
"  separated by double colons (`::`)."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 6-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:17
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"<span class=\"caption\">Listing 6-3: Calling the `add_to_waitlist` function "
"using absolute and relative paths</span>"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`,\n"
"we use an absolute path. The `add_to_waitlist` function is defined in the "
"same\n"
"crate as `eat_at_restaurant`. In Cairo, absolute paths start from the crate "
"root, which you need to refer to by using the crate name."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module\n"
"defined at the same level of the module tree as `eat_at_restaurant`. Here "
"the\n"
"filesystem equivalent would be using the path\n"
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name "
"means\n"
"that the path is relative to the current module."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "### Starting Relative Paths with `super`"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make\n"
"based on your project, and depends on whether you’re more likely to move "
"item\n"
"definition code separately from or together with the code that uses the item."
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:64
msgid ""
"```rust\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid ""
"<span class=\"caption\">Listing 6-4: Calling a function using a relative "
"path starting with super</span>"
msgstr ""

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "# Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 6-5, we bring the `restaurant::front_of_house::hosting` module "
"into the\n"
"scope of the `eat_at_restaurant` function so we only have to specify\n"
"`hosting::add_to_waitlist` to call the `add_to_waitlist` function in\n"
"`eat_at_restaurant`."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:12
msgid ""
"```rust\n"
"// does_not_compile\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:27
msgid ""
"<span class=\"caption\">Listing 6-5: Bringing a module into scope with\n"
"`use`</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:30
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 6-6 moves the `eat_at_restaurant` function into a "
"new\n"
"child module named `customer`, which is then a different scope than the "
"`use`\n"
"statement, so the function body won’t compile:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:38
msgid ""
"```rust\n"
"// does_not_compile\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:55
msgid ""
"<span class=\"caption\">Listing 6-6: A `use` statement only applies in the "
"scope\n"
"it’s in</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:58
msgid ""
"The compiler error shows that the shortcut no longer applies within the\n"
"`customer` module:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:61
msgid ""
"```console\n"
"❯ scarb build\n"
"error: Identifier not found.\n"
" --> lib.cairo:11:9\n"
"        hosting::add_to_waitlist();\n"
"        ^*****^\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:69
msgid "## Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:71
msgid ""
"In Listing 6-5, you might have wondered why we specified `use\n"
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in\n"
"`eat_at_restaurant` rather than specifying the `use` path all the way out "
"to\n"
"the `add_to_waitlist` function to achieve the same result, as in Listing 6-7."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:78
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:92
msgid ""
"<span class=\"caption\">Listing 6-7: Bringing the `add_to_waitlist` "
"function\n"
"into scope with `use`, which is unidiomatic</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:95
msgid ""
"Although both Listing 6-5 and 6-7 accomplish the same task, Listing 6-5 is\n"
"the idiomatic way to bring a function into scope with `use`. Bringing the\n"
"function’s parent module into scope with `use` means we have to specify the\n"
"parent module when calling the function. Specifying the parent module when\n"
"calling the function makes it clear that the function isn’t locally defined\n"
"while still minimizing repetition of the full path. The code in Listing 6-7 "
"is\n"
"unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:103
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`,\n"
"it’s idiomatic to specify the full path. Listing 6-8 shows the idiomatic "
"way\n"
"to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:107
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:116
msgid ""
"<span class=\"caption\">Listing 6-8: Bringing `ArrayTrait` into scope in an\n"
"idiomatic way</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:119
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has\n"
"emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way.\n"
"As Cairo shares many idioms with Rust, we follow this convention as well."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:123
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name\n"
"into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:126
msgid "### Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:128
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name\n"
"into the same scope with `use`: after the path, we can specify `as` and a "
"new\n"
"local name, or _alias_, for the type. Listing 6-9 shows how you can rename "
"an import with `as`:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:134
msgid ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main() {\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:143
msgid ""
"<span class=\"caption\">Listing 6-9: Renaming a trait when it’s brought "
"into\n"
"scope with the `as` keyword</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:146
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:148
msgid "### Importing multiple items from the same module"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"When you want to import multiple items (like functions, structs or enums)\n"
"from the same module in Cairo, you can use curly braces `{}` to list all of\n"
"the items that you want to import. This helps to keep your code clean and "
"easy\n"
"to read by avoiding a long list of individual use statements."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:155
msgid "The general syntax for importing multiple items from the same module is:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:157
msgid ""
"```rust\n"
"use module::{item1, item2, item3};\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:161
msgid "Here is an example where we import three structures from the same module:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid ""
"```rust\n"
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
"mod shapes {\n"
"    #[derive(Drop)]\n"
"    struct Square {\n"
"        side: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Circle {\n"
"        radius: u32\n"
"    }\n"
"\n"
"    #[derive(Drop)]\n"
"    struct Triangle {\n"
"        base: u32,\n"
"        height: u32,\n"
"    }\n"
"}\n"
"\n"
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
"use shapes::{Square, Circle, Triangle};\n"
"\n"
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
"fn main() {\n"
"    let sq = Square { side: 5 };\n"
"    let cr = Circle { radius: 3 };\n"
"    let tr = Triangle { base: 5, height: 2 };\n"
"// ...\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:195
msgid ""
"<span class=\"caption\">Listing 6-10: Importing multiple items from the same "
"module</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:197
msgid "## Re-exporting Names in Module Files"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:199
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in\n"
"the new scope can be imported as if it had been defined in that code’s "
"scope.\n"
"This technique is called _re-exporting_ because we’re bringing an item into "
"scope,\n"
"but also making that item available for others to bring into their scope."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:204
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:208
msgid ""
"```rust\n"
"// does_not_compile\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:223
msgid ""
"<span class=\"caption\">Listing 6-11: Making a name available for any code "
"to use\n"
"from a new scope with `pub use`</span>"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:226
msgid ""
"Before this change, external code would have to call the `add_to_waitlist`\n"
"function by using the path\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this "
"`use`\n"
"has re-exported the `hosting` module from the root module, external code\n"
"can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:232
msgid ""
"Re-exporting is useful when the internal structure of your code is "
"different\n"
"from how programmers calling your code would think about the domain. For\n"
"example, in this restaurant metaphor, the people running the restaurant "
"think\n"
"about “front of house” and “back of house.” But customers visiting a "
"restaurant\n"
"probably won’t think about the parts of the restaurant in those terms. With\n"
"`use`, we can write our code with one structure but expose a different\n"
"structure. Doing so makes our library well organized for programmers working "
"on\n"
"the library and programmers calling the library."
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid "## Using External Packages in Cairo with Scarb"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr ""

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:245
msgid ""
"> The dependencies system is still a work in progress. You can check the "
"official "
"[documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:1
msgid "## Separating Modules into Different Files"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file.\n"
"When modules get large, you might want to move their definitions to a "
"separate\n"
"file to make the code easier to navigate."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 6-11 that had multiple\n"
"restaurant modules. We’ll extract modules into files instead of having all "
"the\n"
"modules defined in the crate root file. In this case, the crate root file "
"is\n"
"_src/lib.cairo_."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove "
"the\n"
"code inside the curly brackets for the `front_of_house` module, leaving "
"only\n"
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code\n"
"shown in Listing 6-12. Note that this won’t compile until we create the\n"
"_src/front_of_house.cairo_ file in Listing 6-13."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:20
msgid ""
"```rust\n"
"// does_not_compile\n"
"mod front_of_house;\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:31
msgid ""
"<span class=\"caption\">Listing 6-12: Declaring the `front_of_house` module "
"whose\n"
"body will be in _src/front_of_house.cairo_</span>"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:34
msgid ""
"Next, place the code that was in the curly brackets into a new file named\n"
"_src/front_of_house.cairo_, as shown in Listing 6-13. The compiler knows to "
"look\n"
"in this file because it came across the module declaration in the crate "
"root\n"
"with the name `front_of_house`."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:39
#: src/ch06-05-separating-modules-into-different-files.md:67
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:41
msgid ""
"```rust,\n"
"mod hosting {\n"
"    fn add_to_waitlist() {}\n"
"}\n"
"```"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:47
msgid ""
"<span class=\"caption\">Listing 6-13: Definitions inside the "
"`front_of_house`\n"
"module in _src/front_of_house.cairo_</span>"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:50
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your\n"
"module tree. Once the compiler knows the file is part of the project (and "
"knows\n"
"where in the module tree the code resides because of where you’ve put the "
"`mod`\n"
"statement), other files in your project should refer to the loaded file’s "
"code\n"
"using a path to where it was declared, as covered in the [“Paths for "
"Referring\n"
"to an Item in the Module Tree”][paths]<!-- ignore --> section. In other "
"words,\n"
"`mod` is _not_ an “include” operation that you may have seen in other\n"
"programming languages."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:59
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit\n"
"different because `hosting` is a child module of `front_of_house`, not of "
"the\n"
"root module. We’ll place the file for `hosting` in a new directory that will "
"be\n"
"named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:64
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the\n"
"declaration of the `hosting` module:"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:69
msgid ""
"```rust\n"
"mod hosting;\n"
"```"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:73
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to\n"
"contain the definitions made in the `hosting` module:"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:76
msgid ""
"<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:78
msgid ""
"```rust\n"
"fn add_to_waitlist() {}\n"
"```"
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:82
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler "
"would\n"
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate\n"
"root, and not declared as a child of the `front_of_house` module. The\n"
"compiler’s rules for which files to check for which modules’ code means the\n"
"directories and files more closely match the module tree."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:88
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains\n"
"the same. The function calls in `eat_at_restaurant` will work without any\n"
"modification, even though the definitions live in different files. This\n"
"technique lets you move modules to new files as they grow in size."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:93
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in\n"
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files\n"
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Cairo\n"
"looks in a file with the same name as the module for the code that goes "
"into\n"
"that module."
msgstr ""

#: src/ch06-05-separating-modules-into-different-files.md:101
msgid ""
"Cairo lets you split a package into multiple crates and a crate into "
"modules\n"
"so you can refer to items defined in one module from another module. You can "
"do\n"
"this by specifying absolute or relative paths. These paths can be brought "
"into\n"
"scope with a `use` statement so you can use a shorter path for multiple uses "
"of\n"
"the item in that scope. Module code is public by default."
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:1
msgid "# Generic Types and Traits"
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behaviour of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete types like `u32` or "
"`ContractAddress`."
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""

#: src/ch07-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""

#: src/ch07-01-generic-data-types.md:1
msgid "# Generic Data Types"
msgstr ""

#: src/ch07-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums, "
"traits, implementations and methods! In this chapter we are going to take a "
"look at how to effectively use generic types with all of them."
msgstr ""

#: src/ch07-01-generic-data-types.md:5
msgid "## Generic Functions"
msgstr ""

#: src/ch07-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""

#: src/ch07-01-generic-data-types.md:9
msgid ""
"```rust\n"
"// does_not_compile\n"
"\n"
"use array::ArrayTrait;\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:40
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""

#: src/ch07-01-generic-data-types.md:42
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> "
"Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:53
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main` "
"function remains unchanged, the compiler is smart enough to deduct which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""

#: src/ch07-01-generic-data-types.md:55
msgid "### Constraints for Generic Types"
msgstr ""

#: src/ch07-01-generic-data-types.md:57
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compilers requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""

#: src/ch07-01-generic-data-types.md:59
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""

#: src/ch07-01-generic-data-types.md:61
msgid ""
"```rust\n"
"// does_not_compile\n"
"use array::ArrayTrait;\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> "
"T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut list: Array<u8> = ArrayTrait::new();\n"
"    list.append(5);\n"
"    list.append(3);\n"
"    list.append(10);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:99
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we don't require to implement the `Drop` trait for `T` as well. Why it does "
"not compile then?"
msgstr ""

#: src/ch07-01-generic-data-types.md:101
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr ""

#: src/ch07-01-generic-data-types.md:103
msgid ""
"```rs\n"
"use array::ArrayTrait;\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, "
"impl TDrop: Drop<T>>(\n"
"    list: @Array<T>\n"
") -> T {\n"
"    let mut smallest = *list[0];\n"
"    let mut index = 1;\n"
"    loop {\n"
"        if index >= list.len() {\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:122
msgid "## Structs"
msgstr ""

#: src/ch07-01-generic-data-types.md:124
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""

#: src/ch07-01-generic-data-types.md:126
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:138
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""

#: src/ch07-01-generic-data-types.md:140
msgid ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3 };\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:152
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""

#: src/ch07-01-generic-data-types.md:154
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""

#: src/ch07-01-generic-data-types.md:156
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3, address: 14 };\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:168
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""

#: src/ch07-01-generic-data-types.md:170
msgid "## Enums"
msgstr ""

#: src/ch07-01-generic-data-types.md:172
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""

#: src/ch07-01-generic-data-types.md:181
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""

#: src/ch07-01-generic-data-types.md:183
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""

#: src/ch07-01-generic-data-types.md:185
#: src/ch09-02-recoverable-errors.md:11
msgid ""
"```rust\n"
"enum Result<T, E> {\n"
"    Ok: T,\n"
"    Err: E,\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:192
#: src/ch09-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""

#: src/ch07-01-generic-data-types.md:194
msgid "## Generic Methods"
msgstr ""

#: src/ch07-01-generic-data-types.md:196
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""

#: src/ch07-01-generic-data-types.md:198
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:220
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `address` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""

#: src/ch07-01-generic-data-types.md:222
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""

#: src/ch07-01-generic-data-types.md:224
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T\n"
"}\n"
"\n"
"/// Generic trait for wallets\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T;\n"
"}\n"
"\n"
"impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> T {\n"
"        return *self.balance;\n"
"    }\n"
"}\n"
"\n"
"/// Trait for wallets of type u128\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"\n"
"    w.receive(100);\n"
"    assert(w.balance() == 150, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:261
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""

#: src/ch07-01-generic-data-types.md:263
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one "
"with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""

#: src/ch07-01-generic-data-types.md:265
msgid ""
"```rust\n"
"// does_not_compile\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:272
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr ""

#: src/ch07-01-generic-data-types.md:274
msgid ""
"```rust\n"
"\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
"Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
"Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:288
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr ""

#: src/ch07-01-generic-data-types.md:290
msgid ""
"```rust\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> of "
"WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:306
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""

#: src/ch07-01-generic-data-types.md:308
msgid ""
"```rust\n"
"fn main() {\n"
"    let w1 = Wallet { balance: true, address: 10 };\n"
"    let w2 = Wallet { balance: 32, address: 100 };\n"
"\n"
"    let w3 = w1.mixup(w2);\n"
"\n"
"    assert(w3.balance == true, 0);\n"
"    assert(w3.address == 100, 0);\n"
"}\n"
"```"
msgstr ""

#: src/ch07-01-generic-data-types.md:320
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:1
msgid "# Traits in Cairo"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The "
"blueprint specification includes a set of function signatures containing "
"type annotations for the parameters and return value. This sets a standard "
"to implement the specific functionality."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:5
msgid "## Defining a Trait"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:7
msgid ""
"To define a trait, you use the keyword `trait` followed by the name of the "
"trait in `PascalCase` then the function signatures in a pair of curly braces."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We "
"want our application to be able to perform geometry operations on these "
"shapes, So we define a trait `ShapeGeometry` that contains a blueprint to "
"implement geometry operations on a shape like this:"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:11
msgid ""
"```rust\n"
"trait ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64;\n"
"    fn area(self: Rectangle) -> u64;\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods "
"`boundary` and `area`. When implemented, both these functions should return "
"a `u64` and accept parameters as specified by the trait."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:20
msgid "## Implementing a Trait"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your "
"implementation followed by `of` then the name of trait being implemented. "
"Here's an example implementing `ShapeGeometry` trait."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:24
msgid ""
"```rust\n"
"impl RectangleGeometry of ShapeGeometry {\n"
"\tfn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"\tfn area(self: Rectangle) -> u64 {\n"
"\t\tself.height * self.width\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` "
"defining what the methods `boundary` and `area` should do. Note that the "
"function parameters and return value types are identical to the trait "
"specification."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:37
msgid "## Parameter `self`"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:39
msgid ""
"In the example above, `self` is a special parameter. When a parameter with "
"name `self` is used, the implemented functions are also [attached to the "
"instances of the type as "
"methods](ch04-03-method-syntax.md#defining-methods). Here's an illustration,"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:41
msgid ""
"When the `ShapeGeometry` trait is implemented, the function `area` from the "
"`ShapeGeometry` trait can be called in two ways:"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:43
msgid ""
"```rust\n"
"let rect = Rectangle { ... }; // Rectangle instantiation\n"
"\n"
"// First way, as a method on the struct instance\n"
"let area1 = rect.area();\n"
"// Second way, from the implementation\n"
"let area2 = RectangleGeometry::area(rect);\n"
"// `area1` has same value as `area2`\n"
"area1.print();\n"
"area2.print();\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:55
msgid ""
"And the implementation of the `area` method will be accessed via the `self` "
"parameter."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:57
msgid "## Generic Traits"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:59
msgid ""
"Usually we want to write a trait when we want multiple types to implement a "
"functionality in a standard way. However, in the example above the "
"signatures are static and cannot be used for multiple types. To do this, we "
"use generic types when defining traits."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:61
msgid ""
"In the example below, we use generic type `T` and our method signatures can "
"use this alias which can be provided during implementation."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:63
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Circle {\n"
"    radius: u64\n"
"}\n"
"\n"
"// Here T is an alias type which will be provided during implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2 * 314 * self.radius) / 100\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314 * self.radius * self.radius) / 100\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:116
msgid "## Managing and using external trait implementations"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:118
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In the code above we imported "
"`PrintTrait` from `debug` with `use debug::PrintTrait;` to use the `print()` "
"methods on supported types."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:120
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules.\n"
"If `CircleGeometry` was in a separate module/file `circle` then to use "
"`boundary` on `circ: Circle`, we'd need to import `CircleGeometry` in "
"addition to `ShapeGeometry`."
msgstr ""

#: src/ch07-02-traits-in-cairo.md:123
msgid "If the code was organised into modules like this,"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:125
msgid ""
"```rust,does_not_compile,ignore_format\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry::<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5, width: 7 };\n"
"    let circ = Circle { radius: 5 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and "
"impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:160
msgid "To make it work, in addition to,"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:162
msgid ""
"```rust\n"
"use geometry::ShapeGeometry;\n"
"```"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:166
msgid "you might also need to use `CircleGeometry`,"
msgstr ""

#: src/ch07-02-traits-in-cairo.md:168
msgid ""
"```rust\n"
"use circle::CircleGeometry\n"
"```"
msgstr ""

#: src/ch08-00-testing-cairo-programs.md:1
msgid "# Testing Cairo Programs"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:1
msgid "# How To Write Tests"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:3
msgid "## The Anatomy of a Test Function"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:7
msgid ""
"- Set up any needed data or state.\n"
"- Run the code you want to test.\n"
"- Assert the results are what you expect."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert` "
"function, and the `should_panic` attribute."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:13
msgid "### The Anatomy of a Test Function"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 4. To change "
"a function into a test function, add `#[test]` on the line before `fn`. When "
"you run your tests with the `cairo-test` command, Cairo builds a test runner "
"binary that runs the annotated functions and reports on whether each test "
"function passes or fails."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:19
msgid ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:27
#: src/ch08-02-test-organization.md:51
msgid "<!-- TODO: remove when Scarb test work -->"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:29
msgid ""
"> Note: You will notice here a `cairo_project.toml` file.\n"
"> This is the configuration file for \"vanilla\" Cairo projects (i.e. not "
"managed by Scarb),\n"
"> which is required to run the `scarb cairo-test` command to run the code of the "
"crate.\n"
"> It is required until Scarb implements this feature. The content of the "
"file is:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> ```\n"
">\n"
"> and indicates that the crate named \"adder\" is located in the `src` "
"directory."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:41
msgid "In _lib.cairo_, let's add a first test, as shown in Listing 8-1."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:43
#: src/ch08-01-how-to-write-tests.md:76
#: src/ch08-01-how-to-write-tests.md:132
#: src/ch08-01-how-to-write-tests.md:155
#: src/ch08-01-how-to-write-tests.md:221
#: src/ch08-01-how-to-write-tests.md:319
#: src/ch08-01-how-to-write-tests.md:411
#: src/ch08-02-test-organization.md:19
#: src/ch09-01-unrecoverable-errors-with-panic.md:9
msgid "<span class=\"filename\">Filename: lib.cairo</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:45
msgid ""
"```rust\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:53
msgid "<span class=\"caption\">Listing 8-1: A test module and function</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:55
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:57
msgid ""
"The example function body uses the `assert` function, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:59
msgid ""
"The `scarb cairo-test` command runs all tests in our project, as shown in "
"Listing 8-2."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:61
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:68
msgid ""
"<span class=\"caption\">Listing 8-2: The output from running a test</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:70
msgid ""
"`cairo-test` compiled and ran the test. We see the line `running 1 tests`. "
"The next line shows the name of the generated test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:72
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `cairo-test` command to run "
"only a test whose name matches a string; this is called filtering and we’ll "
"cover that in the [Running Single Tests](#running-single-tests) section. We "
"also haven’t filtered the tests being run, so the end of the summary shows "
"`0 filtered out`."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:74
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:78
msgid ""
"```rust\n"
"    #[test]\n"
"    fn exploration() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:86
msgid ""
"Then run `cairo-test  -- --path src` again. The output now shows "
"`exploration` instead of `it_works`:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:88
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:95
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 8-3."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:97
msgid ""
"```rust\n"
"    #[test]\n"
"    fn another() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 6, 'Make this test fail');\n"
"    }\n"
"\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:106
msgid ""
"<span class=\"caption\">Listing 8-3: Adding a second test that will "
"fail</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:108
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test adder::lib::tests::another ... fail\n"
"failures:\n"
"    adder::lib::tests::another - panicked with "
"[1725643816656041371866211894343434536761780588 ('Make this test fail'), ].\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:118
msgid ""
"<span class=\"caption\">Listing 8-4: Test results when one test passes and "
"one test fails</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:120
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"in the _src/lib.cairo_ file."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:122
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:124
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:126
msgid "## Checking Results with the assert function"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:128
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert` "
"function a first argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"assert function calls `panic()` to cause the test to fail with a message we "
"defined as the second argument of the `assert` function. Using the `assert` "
"function helps us check that our code is functioning in the way we intend."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:130
msgid ""
"In [Chapter 4, Listing 5-15](ch04-03-method-syntax.md#multiple-impl-blocks), "
"we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 8-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert` function."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:151
msgid ""
"<span class=\"caption\">Listing 8-5: Using the `Rectangle` struct and its "
"`can_hold` method from Chapter 5</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:153
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the assert function. In Listing 8-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8` "
"and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:157
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width & *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle { height: 7, width: 8,  };\n"
"        let smaller = Rectangle { height: 1, width: 5,  };\n"
"\n"
"        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"    }\n"
"# \n"
"#     #[test]\n"
"#     fn smaller_cannot_hold_larger() {\n"
"#         let larger = Rectangle { height: 7, width: 8,  };\n"
"#         let smaller = Rectangle { height: 1, width: 5,  };\n"
"# \n"
"#         assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:206
msgid ""
"<span class=\"caption\">Listing 8-6: A test for `can_hold` that checks "
"whether a larger rectangle can indeed hold a smaller rectangle</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:208
msgid ""
"Note that we’ve added two new lines inside the tests module: `use "
"super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a "
"regular module that follows the usual visibility rules. Because the tests "
"module is an inner module, we need to bring the code under test in the outer "
"module into the scope of the inner module."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:210
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the assert function and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:212
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:219
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:223
msgid ""
"```rust\n"
"# use debug::PrintTrait;\n"
"# #[derive(Copy, Drop)]\n"
"# struct Rectangle {\n"
"#     width: u64,\n"
"#     height: u64,\n"
"# }\n"
"# \n"
"# trait RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64;\n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"# }\n"
"# \n"
"# impl RectangleImpl of RectangleTrait {\n"
"#     fn area(self: @Rectangle) -> u64 {\n"
"#         *self.width * *self.height\n"
"#     }\n"
"# \n"
"#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"#         *self.width > *other.width & *self.height > *other.height\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Rectangle;\n"
"#     use super::RectangleTrait;\n"
"# \n"
"# \n"
"#     #[test]\n"
"#     fn larger_can_hold_smaller() {\n"
"#         let larger = Rectangle { height: 7, width: 8,  };\n"
"#         let smaller = Rectangle { height: 1, width: 5,  };\n"
"# \n"
"#         assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"#     }\n"
"# \n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle { height: 7, width: 8,  };\n"
"        let smaller = Rectangle { height: 1, width: 5,  };\n"
"\n"
"        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:272
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the assert "
"function. As a result, our test will pass if `can_hold` returns false:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:274
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"    running 2 tests\n"
"    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:282
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:284
msgid ""
"```rust\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width < *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:296
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:298
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"test adder::lib::tests::larger_can_hold_smaller ... fail\n"
"failures:\n"
"   adder::lib::tests::larger_can_hold_smaller - panicked with "
"[167190012635530104759003347567405866263038433127524 ('rectangle cannot "
"hold'), ].\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:309
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:311
msgid "## Checking for Panics with `should_panic`"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:313
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type "
"in Listing 8-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:315
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:317
msgid ""
"Listing 8-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:321
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Guess {\n"
"    value: u64, \n"
"}\n"
"\n"
"trait GuessTrait {\n"
"    fn new(value: u64) -> Guess;\n"
"}\n"
"\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 | value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:357
msgid ""
"<span class=\"caption\">Listing 8-8: Testing that a condition will cause a "
"panic</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:359
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:361
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:368
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:370
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# \n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64, \n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value,  }\n"
"    }\n"
"}\n"
"# \n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:396
msgid "When we run the test in Listing 8-8, it will fail:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:398
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - expected panic but finished "
"successfully.\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:407
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:409
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 8-9 where the new function "
"panics with different messages depending on whether the value is too small "
"or too large."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:413
msgid ""
"```rust\n"
"# use array::ArrayTrait;\n"
"# \n"
"# #[derive(Copy, Drop)]\n"
"# struct Guess {\n"
"#     value: u64, \n"
"# }\n"
"# \n"
"# trait GuessTrait {\n"
"#     fn new(value: u64) -> Guess;\n"
"# }\n"
"# \n"
"# impl GuessImpl of GuessTrait {\n"
"#     fn new(value: u64) -> Guess {\n"
"#         if value < 1 {\n"
"#             let mut data = ArrayTrait::new();\n"
"#             data.append('Guess must be <= 100');\n"
"#             panic(data);\n"
"#         } else if value > 100 {\n"
"#             let mut data = ArrayTrait::new();\n"
"#             data.append('Guess must be >= 1');\n"
"#             panic(data);\n"
"#         }\n"
"# \n"
"#         Guess { value,  }\n"
"#     }\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::Guess;\n"
"#     use super::GuessTrait;\n"
"# \n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:456
msgid ""
"<span class=\"caption\">Listing 8-9: Testing for a panic with a panic "
"message containing the error message string</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:458
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:460
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:462
msgid ""
"```rust\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1');\n"
"            panic(data);\n"
"        } else if value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value,  }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:492
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:494
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - panicked with "
"[6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:504
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:506
msgid "## Running Single Tests"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:508
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing "
"`cairo-test` the name of the test you want to run as an argument."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:510
msgid ""
"To demonstrate how to run a single test, we’ll first create two tests "
"functions, as shown in Listing 8-10, and choose which ones to run."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:514
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        let result = 3 + 2;\n"
"        assert(result == 5, 'result is not 5');\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:531
msgid ""
"<span class=\"caption\">Listing 8-10: Two tests with two different "
"names</span>"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:533
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:535
msgid ""
"```shell\n"
"$ scarb cairo-test -f add_two_and_two\n"
"running 1 tests\n"
"test adder::lib::tests::add_two_and_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:542
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:544
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:546
msgid "## Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:548
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `cairo-test`. Rather than "
"listing as arguments all tests you do want to run, you can instead annotate "
"the time-consuming tests using the `ignore` attribute to exclude them, as "
"shown here:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:552
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() {// code that takes an hour to run\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:568
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:570
msgid ""
"```shell\n"
"$ scarb cairo-test\n"
"running 2 tests\n"
"test adder::lib::tests::expensive_test ... ignored\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-01-how-to-write-tests.md:578
msgid "The `expensive_test` function is listed as ignored."
msgstr ""

#: src/ch08-01-how-to-write-tests.md:580
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run "
"`cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""

#: src/ch08-02-test-organization.md:1
msgid "# Testing Organization"
msgstr ""

#: src/ch08-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""

#: src/ch08-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch08-02-test-organization.md:7
msgid "## Unit Tests"
msgstr ""

#: src/ch08-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""

#: src/ch08-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the "
"test functions and to annotate the module with `cfg(test)`."
msgstr ""

#: src/ch08-02-test-organization.md:13
msgid "### The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch08-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library "
"and saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""

#: src/ch08-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""

#: src/ch08-02-test-organization.md:21
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `cairo-test`. "
"This includes any helper functions that might be within this module, in "
"addition to the functions annotated with `#[test]`."
msgstr ""

#: src/ch08-02-test-organization.md:34
msgid "## Integration Tests"
msgstr ""

#: src/ch08-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""

#: src/ch08-02-test-organization.md:38
msgid "### The `tests` Directory"
msgstr ""

#: src/ch08-02-test-organization.md:40
msgid ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── src\n"
"    ├── lib.cairo\n"
"│   └── main.cairo\n"
"└── tests\n"
"    ├── lib.cairo\n"
"    └── integration_test.cairo\n"
"```"
msgstr ""

#: src/ch08-02-test-organization.md:53
msgid ""
"> To successfully run your tests with `cairo-test` you will need to update "
"your `cairo_project.toml` file to add the declaration of your `tests` "
"crate.\n"
">\n"
"> ```rust\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> tests = \"tests\"\n"
"> ```"
msgstr ""

#: src/ch08-02-test-organization.md:61
msgid ""
"Each test file is compiled as its own separate crate, that's why whenever "
"you add a new test file you must add it to your _tests/lib.cairo_."
msgstr ""

#: src/ch08-02-test-organization.md:63
msgid "<span class=\"filename\">Filename: tests/lib.cairo</span>"
msgstr ""

#: src/ch08-02-test-organization.md:65
msgid ""
"```rust\n"
"#[cfg(tests)]\n"
"mod integration_tests;\n"
"```"
msgstr ""

#: src/ch08-02-test-organization.md:70
msgid ""
"Enter the code in Listing 8-11 into the _tests/integration_test.cairo_ file:"
msgstr ""

#: src/ch08-02-test-organization.md:72
msgid "<span class=\"filename\">Filename: tests/integration_test.cairo</span>"
msgstr ""

#: src/ch08-02-test-organization.md:74
msgid ""
"```rust\n"
"#[test]\n"
"fn internal() {\n"
"    assert(main::internal_adder(2, 2) == 4, 'internal_adder failed');\n"
"}\n"
"```"
msgstr ""

#: src/ch08-02-test-organization.md:81
msgid ""
"<span class=\"caption\">Listing 8-11: Testing functions from other "
"modules</span>"
msgstr ""

#: src/ch08-02-test-organization.md:83
msgid ""
"Each file in the tests directory is a separate crate, so we need to bring "
"our library into each test crate’s scope. For that reason we add `use "
"adder::main` at the top of the code, which we didn’t need in the unit tests."
msgstr ""

#: src/ch08-02-test-organization.md:85
msgid ""
"```shell\n"
"$ cairo-test tests/\n"
"running 1 tests\n"
"test tests::tests_integration::it_adds_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""

#: src/ch08-02-test-organization.md:92
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr ""

#: src/ch09-00-error-handling.md:1
msgid "# Error handling"
msgstr ""

#: src/ch09-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "# Unrecoverable Errors with panic"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as argument, which can be used to provide an "
"error message and performs an unwind process where all variables are dropped "
"and dictionaries squashed to ensure the soundness of the program to safely "
"terminate the execution."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:11
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append(2);\n"
"    if true == true {\n"
"        panic(data);\n"
"    }\n"
"    'This line isn\\'t reached'.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:25
msgid "Running the program will produce the following output:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:27
msgid ""
"```console\n"
"$ cairo-run test.cairo\n"
"Run panicked with [2 (''), ].\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:32
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:34
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a felt252 error message as argument, "
"making the code more readable and maintainable."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:36
msgid "Let's consider an example:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:38
msgid ""
"```rust\n"
"fn main() {\n"
"    panic_with_felt252(2);\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:44
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:46
msgid "## nopanic notation"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:48
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:50
#: src/ch09-01-unrecoverable-errors-with-panic.md:86
#: src/appendix-03-derivable-traits.md:17
#: src/appendix-03-derivable-traits.md:42
#: src/appendix-03-derivable-traits.md:63
#: src/appendix-03-derivable-traits.md:85
#: src/appendix-03-derivable-traits.md:118
msgid "Example:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:52
msgid ""
"```rust\n"
"fn function_never_panic() -> felt252 nopanic {\n"
"    42\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:58
msgid "Wrong example:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:60
msgid ""
"```rust\n"
"// does_not_compile\n"
"fn function_never_panic() nopanic {\n"
"    assert(1 == 1, 'what');\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:67
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:69
msgid ""
"```console\n"
"error: Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:12\n"
"    assert(1 == 1, 'what');\n"
"           ^****^\n"
"Function is declared as nopanic but calls a function that may panic.\n"
" --> test.cairo:2:5\n"
"    assert(1 == 1, 'what');\n"
"    ^********************^\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:80
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:82
msgid "## panic_with macro"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:84
msgid ""
"You can use the `panic_with` macro to mark a function that returns an "
"`Option` or `Result`. This macro takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:88
msgid ""
"```rust\n"
"use option::OptionTrait;\n"
"\n"
"#[panic_with('value is 0', wrap_not_zero)]\n"
"fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
"    if value == 0 {\n"
"        Option::None(())\n"
"    } else {\n"
"        Option::Some(value)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    wrap_if_not_zero(0); // this returns None\n"
"    wrap_not_zero(0); // this panic with 'value is 0'\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:106
msgid "## Using assert"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"The assert function from the Cairo core library is actually a utility "
"function based on panics. It asserts that a boolean expression is true at "
"runtime, and if it is not, it calls the panic function with an error value. "
"The assert function takes two arguments: the boolean expression to verify, "
"and the error value. The error value is specified as a felt252, so any "
"string passed must be able to fit inside a felt252."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:110
msgid "Here is an example of its usage:"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:112
msgid ""
"```rust\n"
"fn main() {\n"
"    let my_number: u8 = 0;\n"
"\n"
"    assert(my_number != 0, 'number is zero');\n"
"\n"
"    100 / my_number;\n"
"}\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:122
msgid ""
"We are asserting in main that `my_number` is not zero to ensure that we're "
"not performing a division by 0.\n"
"In this example, `my_number` is zero so the assertion will fail, and the "
"program will panic\n"
"with the string 'number is zero' (as a felt252) and the division will not be "
"reached."
msgstr ""

#: src/ch09-02-recoverable-errors.md:1
msgid "# Recoverable Errors with `Result`"
msgstr ""

#: src/ch09-02-recoverable-errors.md:3
#: src/ch09-02-recoverable-errors.md:56
msgid "<br />"
msgstr ""

#: src/ch09-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""

#: src/ch09-02-recoverable-errors.md:7
msgid "## The `Result` enum"
msgstr ""

#: src/ch09-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch07-01-generic-data-types.md#enums) in "
"Chapter 7 that the `Result` enum is defined as having two variants, `Ok` and "
"`Err`, as follows:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:20
msgid "## The `ResultTrait`"
msgstr ""

#: src/ch09-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""

#: src/ch09-02-recoverable-errors.md:24
msgid ""
"```rust\n"
"trait ResultTrait<T, E> {\n"
"    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> T;\n"
"\n"
"    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
"\n"
"    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -> "
"E;\n"
"\n"
"    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
"\n"
"    fn is_ok(self: @Result<T, E>) -> bool;\n"
"\n"
"    fn is_err(self: @Result<T, E>) -> bool;\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""

#: src/ch09-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""

#: src/ch09-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl "
"EDrop: Drop<E>>` in the first four methods signatures. This syntax "
"represents generic type constraints in the Cairo language. These constraints "
"indicate that the associated functions require an implementation of the "
"`Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""

#: src/ch09-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""

#: src/ch09-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""

#: src/ch09-02-recoverable-errors.md:54
msgid ""
"You can find the implementation ot the `ResultTrait` "
"[here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""

#: src/ch09-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr ""

#: src/ch09-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:62
msgid ""
"```rust\n"
"fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""

#: src/ch09-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:70
msgid ""
"```rust\n"
"fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
"    match u128_overflowing_add(a, b) {\n"
"        Result::Ok(r) => Option::Some(r),\n"
"        Result::Err(r) => Option::None(()),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None(())` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr ""

#: src/ch09-02-recoverable-errors.md:81
msgid ""
"Let's take another example demonstrating the use of `unwrap`.\n"
"First we import the necessary modules:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:84
msgid ""
"```rust\n"
"use core::traits::Into;\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"use result::ResultTrait;\n"
"use result::ResultTraitImpl;\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries "
"to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns "
"`Result::Err('Invalid integer')`."
msgstr ""

#: src/ch09-02-recoverable-errors.md:94
msgid ""
"```rust\n"
"fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"    match s.try_into() {\n"
"        Option::Some(value) => Result::Ok(value),\n"
"        Option::None(_) => Result::Err('Invalid integer'),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:103
msgid "<span class=\"caption\">Listing 9-1: Using the Result type</span>"
msgstr ""

#: src/ch09-02-recoverable-errors.md:105
msgid "Our two test cases are:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:107
msgid ""
"```rust\n"
"# use traits::TryInto;\n"
"# \n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None(_) => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::parse_u8;\n"
"    use result::ResultTrait;\n"
"    #[test]\n"
"    fn test_felt252_to_u8() {\n"
"        let number: felt252 = 5_felt252;\n"
"        // should not panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_felt252_to_u8_panic() {\n"
"        let number: felt252 = 256_felt252;\n"
"        // should panic\n"
"        let res = parse_u8(number).unwrap();\n"
"    }\n"
"}\n"
"# \n"
"# \n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:140
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message 'Invalid integer'."
msgstr ""

#: src/ch09-02-recoverable-errors.md:142
msgid "> We could have also used the #[should_panic] attribute here."
msgstr ""

#: src/ch09-02-recoverable-errors.md:144
msgid "### The `?` operator ?"
msgstr ""

#: src/ch09-02-recoverable-errors.md:146
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:148
msgid ""
"- If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly.\n"
"- If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""

#: src/ch09-02-recoverable-errors.md:151
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""

#: src/ch09-02-recoverable-errors.md:153
msgid "Here is an example."
msgstr ""

#: src/ch09-02-recoverable-errors.md:155
msgid ""
"```rust\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:164
msgid "<span class=\"caption\">Listing 9-1: Using the `?` operator</span>"
msgstr ""

#: src/ch09-02-recoverable-errors.md:166
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr ""

#: src/ch09-02-recoverable-errors.md:168
msgid "And with a little test case:"
msgstr ""

#: src/ch09-02-recoverable-errors.md:170
msgid ""
"```rust\n"
"# use traits::TryInto;\n"
"# \n"
"# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"#     match s.try_into() {\n"
"#         Option::Some(value) => Result::Ok(value),\n"
"#         Option::None(_) => Result::Err('Invalid integer'),\n"
"#     }\n"
"# }\n"
"# \n"
"# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"#     let input_to_u8: u8 = parse_u8(input)?;\n"
"#     // DO SOMETHING\n"
"#     let res = input_to_u8 - 1;\n"
"#     Result::Ok(res)\n"
"# }\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::do_something_with_parse_u8;\n"
"#     use debug::PrintTrait;\n"
"    #[test]\n"
"    fn test_function_2() {\n"
"        let number: felt252 = 258_felt252;\n"
"        match do_something_with_parse_u8(number) {\n"
"            Result::Ok(value) => value.print(),\n"
"            Result::Err(e) => e.print()\n"
"        }\n"
"    }\n"
"# }\n"
"# \n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors.md:203
msgid "The console will print the error \"Invalid Integer\"."
msgstr ""

#: src/ch09-02-recoverable-errors.md:205
msgid "<br/>"
msgstr ""

#: src/ch09-02-recoverable-errors.md:207
msgid "### Summary"
msgstr ""

#: src/ch09-02-recoverable-errors.md:209
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""

#: src/ch09-02-recoverable-errors.md:211
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""

#: src/ch10-00-advanced-features.md:1
msgid "# Advanced Features"
msgstr ""

#: src/ch10-01-operator-overloading.md:1
msgid "# Operator Overloading"
msgstr ""

#: src/ch10-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""

#: src/ch10-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type.\n"
"However, it's essential to use operator overloading judiciously. Misuse can "
"lead to confusion, making the code more difficult to maintain, for example "
"when there is no semantic meaning to the operator being overloaded."
msgstr ""

#: src/ch10-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""

#: src/ch10-01-operator-overloading.md:10
msgid ""
"```rust\n"
"struct Potion {\n"
"    health: felt252,\n"
"    mana: felt252\n"
"}\n"
"\n"
"impl PotionAdd of Add<Potion> {\n"
"    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
"        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana, "
" }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
"    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
"    let super_potion: Potion = health_potion + mana_potion;\n"
"    // Both potions were combined with the `+` operator.\n"
"    assert(super_potion.health == 100, '');\n"
"    assert(super_potion.mana == 100, '');\n"
"}\n"
"```"
msgstr ""

#: src/ch10-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""

#: src/ch10-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:1
msgid "# Starknet Smart Contracts"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections.\n"
"If you want to learn more about the Starknet network itself, its "
"architecture and the tooling available, you should read the [Starknet "
"Book](https://book.starknet.io/). This section will focus on writing smart "
"contracts in Cairo."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "# Introduction to smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts "
"are, what are they used for and why would blockchain developers use Cairo "
"and Starknet.\n"
"If you are already familiar with blockchain programming, feel free to skip "
"this chapter. The last part might still be interesting though."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "## Smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party softwares (called `oracles`) to access external data "
"(the price of a token for instance)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs "
"(Non-fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "## Use cases"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "#### DeFi"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "#### Tokenization"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "#### Voting"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "#### Royalties"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "#### Decentralized identities DIDs"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:40
msgid ""
"<br/>\n"
"<br/>\n"
"As Ethereum continues to mature, we can expect the use cases and "
"applications of smart contracts to expand further, bringing about exciting "
"new opportunities and reshaping traditional systems for the better."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "## The rise of Starknet and Cairo"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue. A famous theorem in the blockchain space "
"states that it is impossible to achieve a high level of scalability, "
"decentralization, and security simultaneously; trade-offs must be made. "
"Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s). "
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions. In contrast, validity "
"rollups, such as Starknet, use cryptography to prove that the new state has "
"been correctly computed. This is the purpose of STARKs, this cryptographic "
"technology could permit validity rollups to scale significantly more than "
"optimistic rollups. You can learn more about STARKs from Starkware's Medium "
"[article](https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a), "
"which serves as a good primer."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another. Unlike most (if not "
"all) of Starknet's competitors that chose to use the EVM (either as-is or "
"adapted) as a base layer, Starknet employs its own VM. This frees developers "
"from the constraints of the EVM, opening up a broader range of "
"possibilities. Coupled with decreased transaction costs, the combination of "
"Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts and transaction "
"flows. Emerging use cases include **transparent AI** and artificial "
"intelligence and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:1
msgid "# Writing Starknet Contracts"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:3
msgid ""
"This chapter will guide you on how to create smart contracts in Cairo, and "
"will clarify the distinction between Cairo programs and Starknet contracts."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:5
msgid "## Cairo programs and Starknet contracts"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:7
msgid ""
"Starknet contracts are a special subset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts.\n"
"As you may have already noticed, a Cairo program must always have a function "
"`main` that serves as the entry point for this program:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:10
msgid ""
"```rust\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:14
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, "
"and as such, have access to Starknet's state. For a module to be handled as "
"a contract by the compiler, it must be annotated with the `#[contract]` "
"attribute:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:16
msgid ""
"```rust\n"
"#[contract]\n"
"mod example {\n"
"    use starknet::get_caller_address;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>, \n"
"    }\n"
"\n"
"    #[event]\n"
"    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(_name: felt252, _address: ContractAddress) {\n"
"        names::write(_address, _name);\n"
"    }\n"
"\n"
"    #[external]\n"
"    fn store_name(_name: felt252) {\n"
"        let caller = get_caller_address();\n"
"        names::write(caller, _name);\n"
"        StoredName(caller, _name);\n"
"    }\n"
"\n"
"    #[view]\n"
"    fn get_name(_address: ContractAddress) -> felt252 {\n"
"        let name = names::read(_address);\n"
"        return name;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:49
msgid ""
"<span class=\"caption\">Listing 99-1: A simple naming service contract</span>"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:51
msgid ""
"> Note: Starknet contracts are defined within "
"[modules](./ch06-02-defining-modules-to-control-scope.md)."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:53
msgid "## Starknet Contract Attributes"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:55
msgid ""
"Attributes are special annotations that modify the behavior of certain "
"functions or methods. They are placed preceding a function and are denoted "
"by the `#[]` symbol."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:57
msgid "<!-- TODO: Appendix on attributes -->"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:59
msgid "Here is a list of common attributes used in Starknet contracts:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:61
msgid ""
"1. `#[contract]`: This attribute is used to annotate a module to be compiled "
"as a Starknet contract.\n"
"   The compiler recognizes this attribute and prepares the module with "
"necessary contract elements,\n"
"   such as the logic to handle external contract calls or how to access "
"storage variables.\n"
"\n"
"2. `#[constructor]`: This attribute marks a function as a constructor. The "
"constructor function is called only once upon deploying a contract, setting "
"the initial state of the contract.\n"
"\n"
"3. `#[external]`: This attribute marks a function as an external function. "
"External functions can be called by other contracts or externally and can "
"modify the contract's state.\n"
"\n"
"4. `#[view]`: This attribute marks a function as a view function. View "
"functions are read-only functions that allow you to access data from the "
"contract, but prevent you from modifying the state of the blockchain.\n"
"\n"
"5. `#[event]`: This is used to define events that can be emitted by the "
"contract.\n"
"\n"
"6. `#[l1_handler]`: This attribute is used to mark functions which can "
"receive messages from L1s."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:75
msgid "## Storage Variables"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:77
msgid ""
"Storage variables allow you to store data that will be stored on the "
"blockchain in the contract's storage. These data are persistent and can be "
"accessed and modified anytime once the contract is deployed."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:79
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:81
msgid ""
"```rust\n"
"# #[contract]\n"
"# mod contract {\n"
"    struct Storage {\n"
"        id: u8,\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"# }\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:91
msgid "<span class=\"caption\">Listing 99-2: A Storage Struct</span>"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:93
msgid ""
"The storage struct is a "
"[struct](./ch04-00-using-structs-to-structure-related-data.md) like any "
"other,\n"
"except that it allows you to define mappings using the `LegacyMap` type."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:96
msgid "### Storage Mappings"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:98
msgid ""
"Mappings are a key-value data structure that you can use to store data "
"within a smart contract. They are essentially hash tables that allow you to "
"associate a unique key with a corresponding value. Mappings are also useful "
"to store sets of data, as it's impossible to store arrays in storage."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:100
msgid ""
"A mapping is a variable of type LegacyMap, in which the key and value types "
"are specified within angular brackets <>.\n"
"It is important to note that the `LegacyMap` type can only be used inside "
"the `Storage` struct, and can't be used to define mappings in user-defined "
"structs.\n"
"The syntax for declaring a mapping is as follows in Listing 99-2."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:104
msgid ""
"You can also create more complex mappings than that found in Listing 99-2 "
"like the popular `allowances` storage variable in the ERC20 Standard which "
"maps the `owner` and `spender` to the `allowance` using tuples:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:106
msgid ""
"```rust\n"
"    struct Storage {\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:112
msgid ""
"In mappings, the address of the value at key `k_1,...,k_n` is "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ\n"
"is the Pedersen hash and the final value is taken `mod2251−256`. You can "
"learn more about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:115
msgid "### Reading from Storage"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:117
msgid ""
"To read the value of the storage variable `names`, we call the `read` "
"function on the `names` storage variable, passing in the key `_address` as a "
"parameter."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:119
msgid ""
"```rust\n"
"        let name = names::read(_address);\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:123
msgid ""
"<span class=\"caption\">Listing 99-3: Calling the `read` function on the "
"`names` variable</span>"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:125
msgid ""
"> Note: When the storage variable does not store a mapping, its value is "
"accessed without passing any parameters to the read method"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:127
msgid "### Writing to Storage"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:129
msgid ""
"To write a value to the storage variable `names`, we call the `write` "
"function on the `names` storage variable, passing in the key and values as "
"arguments."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:131
msgid ""
"```rust\n"
"        names::write(caller, _name);\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:135
msgid ""
"<span class=\"caption\">Listing 99-4: Writing to the `names` variable</span>"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:139
msgid ""
"In this section, we are going to be looking at some popular function types "
"you'd encounter with most contracts:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:141
msgid "### 1. Constructors"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:143
msgid ""
"Constructors are a special type of function that runs only once when "
"deploying a contract, and can be used to initialize the state of the "
"contract."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:145
msgid ""
"```rust\n"
"    #[constructor]\n"
"    fn constructor(_name: felt252, _address: ContractAddress) {\n"
"        names::write(_address, _name);\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:152
msgid "Some important rules to note:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:154
msgid ""
"1. Your contract can't have more than one constructor.\n"
"2. Your constructor function must be named `constructor`.\n"
"3. Lastly, it must be annotated with the `#[constructor]` attribute."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:158
msgid "### 2. External functions"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:160
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally.\n"
"You can define external functions by annotating them with the `#[external]` "
"attribute:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:163
msgid ""
"```rust\n"
"    #[external]\n"
"    fn store_name(_name: felt252) {\n"
"        let caller = get_caller_address();\n"
"        names::write(caller, _name);\n"
"        StoredName(caller, _name);\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:172
msgid "### 3. View functions"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:174
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They "
"can be called by other contracts or externally.\n"
"You can define view functions by annotating them with the `#[view]` "
"attribute:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:177
msgid ""
"```rust\n"
"    #[view]\n"
"    fn get_name(_address: ContractAddress) -> felt252 {\n"
"        let name = names::read(_address);\n"
"        return name;\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:185
msgid ""
"> **Note:** It's important to note that, both external and view functions "
"are public. To create an internal function in a contract, you simply don't "
"annotate it with any attribute."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:187
msgid "## Events"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:189
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution.\n"
"They provide a way for smart contracts to communicate with the external "
"world by logging information\n"
"about specific occurrences in a contract."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:193
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract "
"could lead to a bad user experience. This is because users may not see their "
"NFTs appear in their wallets (wallets use these indexers to display a user's "
"NFTs)."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:195
msgid "### Defining events"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:197
msgid ""
"An event is defined as an empty function annotated with the `#[event]` "
"attribute. The parameters of this function\n"
"are the data that will be emitted by the event."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:200
msgid ""
"In Listing 99-1, `StoredName` is an event that emits information when names "
"are stored in the contract:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:202
msgid ""
"```rust\n"
"    #[event]\n"
"    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
"```"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:207
msgid ""
"We pass in the emitted data types as parameters within the parentheses. In "
"this example, our event will emit the contract address of the caller and the "
"name stored within the contract."
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:209
msgid "### Emitting events"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:211
msgid ""
"After defining events, we can emit them by simply calling the event name "
"like we'll call functions,\n"
"passing in the values to be emitted as parameters:"
msgstr ""

#: src/ch99-01-02-writing-starknet-contracts.md:214
msgid ""
"```rust\n"
"        StoredName(caller, _name);\n"
"```"
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "# Starknet contracts: ABIs and cross-contract interactions"
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"The ability of contracts to interact with other smart contracts on the "
"blockchain is a common pattern found in smart contract development."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"This chapter covers how cross-contract interactions between Starknet "
"contracts can be achieved. Specifically, you'll learn about ABIs, contract "
"interfaces, the contract and library dispatchers and their low-level system "
"call equivalents!"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "# ABIs and Contract Interfaces"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "## Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"An interface is a list of a contract's function definitions without "
"implementations. In other words, an interface specifies the function "
"declarations (name, parameters, visibility and return value) contained in a "
"smart contract without including the function body."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"Interfaces in Cairo are traits with the `#[abi]` attribute. If you are new "
"to traits, check out the dedicated chapter on "
"[traits](./ch07-02-traits-in-cairo.md)."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"For your Cairo code to qualify as an interface, it must meet the following "
"requirements:"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid ""
"1. Must be appended with the `#[abi]` attribute.\n"
"2. Your interface functions should have no implementations.\n"
"3. You must explicitly declare the function's decorator.\n"
"4. Your interface should not declare a constructor.\n"
"5. Your interface should not declare state variables."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:21
msgid "Here's a sample interface for an ERC20 token contract:"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:23
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[abi]\n"
"trait IERC20 {\n"
"    #[view]\n"
"    fn name() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn symbol() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn decimals() -> u8;\n"
"\n"
"    #[view]\n"
"    fn total_supply() -> u256;\n"
"\n"
"    #[view]\n"
"    fn balance_of(account: ContractAddress) -> u256;\n"
"\n"
"    #[view]\n"
"    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"\n"
"    #[external]\n"
"    fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid "<span class=\"caption\">Listing 99-4: A simple ERC20 Interface</span>"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:59
msgid "## ABIs"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:61
msgid ""
"ABI stands for Application Binary Interface. ABIs gives a smart contract the "
"ability to communicate and interact with external applications or other "
"smart contracts. ABIs can be likened to APIs in traditional web development, "
"which helps data flow between applications and servers."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:63
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:65
msgid ""
"Every contract on Starknet has an Application Binary Interface (ABI) that "
"defines how to encode and decode data when calling its methods."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:67
msgid ""
"In the next chapter, we are going to be looking into how we can call other "
"smart contracts using a `Contract Dispatcher`, `Library Dispatcher`, and "
"`System calls`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid "# Contract Dispatcher, Library Dispatcher and System calls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is created on Starknet, two dispatchers are "
"automatically created and exported:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "1. The Contract Dispatcher\n2. The Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"In this chapter, we are going to extensively discuss how these dispatchers "
"work and their usage."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 99-4):"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid "## Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid ""
"Traits annotated with the `#[abi]` attribute are programmed to automatically "
"generate and export the relevant dispatcher logic on compilation. The "
"compiler also generates a new trait, two new structs (one for contract "
"calls, and the other for library calls) and their implementation of this "
"trait. Our interface is expanded into something like this:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `get_name`, and one external function `transfer`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:18
msgid ""
"```rust\n"
"//does_not_compile\n"
"use starknet::{ContractAddress};\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: starknet::ContractAddress, \n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
"    fn name(\n"
"        self: IERC20Dispatcher\n"
"    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
"    ) { // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:44
msgid ""
"<span class=\"caption\">Listing 99-5: An expanded form of the IERC20 "
"trait</span>"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid "### Calling Contracts using the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"This is an example of a contract named `Dispatcher` using the Contract "
"interface dispatcher to call an ERC-20 contract in the ERC-20 contract's "
"context and, in the case of `transfer_token`, altering the state of the "
"ERC-20 contract:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid ""
"```rust\n"
"# use starknet::ContractAddress;\n"
"# \n"
"# #[abi]\n"
"# trait IERC20 {\n"
"#     #[view]\n"
"#     fn name() -> felt252;\n"
"# \n"
"#     #[view]\n"
"#     fn symbol() -> felt252;\n"
"# \n"
"#     #[view]\n"
"#     fn decimals() -> u8;\n"
"# \n"
"#     #[view]\n"
"#     fn total_supply() -> u256;\n"
"# \n"
"#     #[view]\n"
"#     fn balance_of(account: ContractAddress) -> u256;\n"
"# \n"
"#     #[view]\n"
"#     fn allowance(owner: ContractAddress, spender: ContractAddress) -> "
"u256;\n"
"# \n"
"#     #[external]\n"
"#     fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
"# \n"
"#     #[external]\n"
"#     fn transfer_from(sender: ContractAddress, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"# \n"
"#     #[external]\n"
"#     fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
"# }\n"
"# \n"
"//**** Specify interface here ****//\n"
"#[contract]\n"
"mod dispatcher {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[view]\n"
"    fn token_name(_contract_address: ContractAddress) -> felt252 {\n"
"        IERC20Dispatcher { contract_address: _contract_address }.name()\n"
"    }\n"
"\n"
"    #[external]\n"
"    fn transfer_token(\n"
"        _contract_address: ContractAddress, recipient: ContractAddress, "
"amount: u256\n"
"    ) -> bool {\n"
"        IERC20Dispatcher { contract_address: _contract_address "
"}.transfer(recipient, amount)\n"
"    }\n"
"}\n"
"# \n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:107
msgid ""
"<span class=\"caption\">Listing 99-6: A sample contract which uses the "
"Contract Dispatcher</span>"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:109
msgid ""
"As you can see, we had to first import the `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` which was generated and exported on compiling our "
"interface, then we make calls to the methods implemented for the "
"`IERC20Dispatcher` struct (`name`, `transfer`, etc), passing in the "
"`contract_address` parameter which represents the address of the contract we "
"want to call."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:111
msgid "## Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:113
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher is that while the contract dispatcher calls an external "
"contract's logic in the external contract's context, the library dispatcher "
"calls the target contract's classhash, whilst executing the call in the "
"calling contract's context.\n"
"So unlike the contract dispatcher, calls made using the library dispatcher "
"have no possibility of tampering with the target contract's state."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:116
msgid ""
"As stated in the previous chapter, contracts annotated with the `#[abi]` "
"macro on compilation generates a new trait, two new structs (one for "
"contract calls, and the other for library calls) and their implementation of "
"this trait. The expanded form of the library traits looks like:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:118
msgid ""
"```rust\n"
"//does_not_compile\n"
"use starknet::ContractAddress;\n"
"\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash, \n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of "
"IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
"    fn name(\n"
"        self: IERC20LibraryDispatcher\n"
"    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called in "
"here\n"
"    }\n"
"    fn transfer(\n"
"        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: "
"u256\n"
"    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:144
msgid ""
"<span class=\"caption\">Listing 99-7: An expanded form of the IERC20 "
"trait</span>"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:146
msgid "### Calling Contracts using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:148
msgid "Below's a sample code on calling contracts using the Library Dispatcher:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:150
msgid ""
"```rust\n"
"#[contract]\n"
"mod contract {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20LibraryDispatcher;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[view]\n"
"    fn token_name() -> felt252 {\n"
"        IERC20LibraryDispatcher { class_hash: "
"starknet::class_hash_const::<0x1234>() }.name()\n"
"    }\n"
"\n"
"    #[external]\n"
"    fn transfer_token(recipient: ContractAddress, amount: u256) -> bool {\n"
"        IERC20LibraryDispatcher {\n"
"            class_hash: starknet::class_hash_const::<0x1234>()\n"
"        }.transfer(recipient, amount)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:171
msgid ""
"<span class=\"caption\">Listing 99-8: A sample contract using the Library "
"Dispatcher</span>"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:173
msgid ""
"As you can see, we had to first import the `IERC20DispatcherTrait` and "
"`IERC20LibraryDispatcher` which was generated and exported on compiling our "
"interface, then we make calls to the methods implemented for the "
"`IERC20LibraryDispatcher` struct (`name`, `transfer`, etc), passing in the "
"`class_hash` parameter which represents the class of the contract we want to "
"call."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:175
msgid "## Calling Contracts using low-level System calls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:177
msgid ""
"Another way to call other contracts is to use the "
"`starknet::call_contract_syscall` system call. The Dispatchers we described "
"in the previous sections are high-level syntaxes for this low-level system "
"call."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:179
msgid ""
"Using the system call `starknet::call_contract_syscall` can be handy for "
"customized error handling or possessing more control over the "
"serialization/deserialization of the call data and the returned data. Here's "
"an example demonstrating a low-level `transfer` call:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:181
msgid ""
"```rust\n"
"#[contract]\n"
"mod contract {\n"
"    use array::ArrayTrait;\n"
"    #[external]\n"
"    fn transfer_token(\n"
"        address: starknet::ContractAddress, selector: felt252, calldata: "
"Array<felt252>\n"
"    ) -> Span::<felt252> {\n"
"        starknet::call_contract_syscall(address, selector, "
"calldata.span()).unwrap_syscall()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:194
msgid ""
"<span class=\"caption\">Listing 99-9: A sample contract implementing system "
"calls</span>"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:196
msgid ""
"As you can see, rather than pass our function arguments directly, we passed "
"in the contract address, function selector (which is a keccak hash of the "
"function name), and the calldata (function arguments). At the end, we get "
"returned a serialized value which we'll need to deserialize ourselves!"
msgstr ""

#: src/ch99-03-security-considerations.md:1
msgid "# Security Considerations"
msgstr ""

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chances of "
"unexpected behavior or vulnerabilities."
msgstr ""

#: src/ch99-03-security-considerations.md:11
msgid "## Disclaimer"
msgstr ""

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""

#: src/ch99-03-security-considerations.md:17
msgid "## Mindset"
msgstr ""

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contracts flows are designed, not much from "
"the language itself."
msgstr ""

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""

#: src/ch99-03-security-considerations.md:23
msgid "### Viewing smart contract as Finite State Machines"
msgstr ""

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert` or `panic` functions can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with "
"panic](./ch09-01-unrecoverable-errors-with-panic.md) page."
msgstr ""

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr ""

#: src/ch99-03-security-considerations.md:33
msgid ""
"- Inputs provided by the caller\n"
"- Execution requirements\n"
"- Invariants (conditions that must always be true)\n"
"- Return values from other function calls"
msgstr ""

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert` function to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""

#: src/ch99-03-security-considerations.md:40
msgid ""
"```rust\n"
"    #[external]\n"
"    fn withdraw(amount: u256) {\n"
"        let current_balance = balance::read();\n"
"\n"
"        assert(balance >= amount, 'Insufficient funds');\n"
"\n"
"        balance::write(current_balance - amount);\n"
"    }\n"
"```"
msgstr ""

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""

#: src/ch99-03-security-considerations.md:53
msgid "## Recommendations"
msgstr ""

#: src/ch99-03-security-considerations.md:55
msgid "### Checks Effects Interactions Pattern"
msgstr ""

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""

#: src/ch99-03-security-considerations.md:59
msgid "<!-- TODO add reference to the reentrancy CairoByExample page -->"
msgstr ""

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""

#: src/ch99-03-security-considerations.md:63
msgid ""
"1. **Checks**: Validate all conditions and inputs before performing any "
"state changes.\n"
"2. **Effects**: Perform all state changes.\n"
"3. **Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch99-03-security-considerations.md:67
msgid "### Access control"
msgstr ""

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""

#: src/ch99-03-security-considerations.md:73
msgid ""
"```rust\n"
"#[contract]\n"
"mod access_control_contract {\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Role 'owner': only one address\n"
"        owner: ContractAddress,\n"
"        // Role 'role_a': a set of addresses\n"
"        role_a: LegacyMap::<ContractAddress, bool>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor() {\n"
"        owner::write(get_caller_address());\n"
"    }\n"
"\n"
"    // Guard functions to check roles\n"
"\n"
"    #[inline(always)]\n"
"    fn is_owner() -> bool {\n"
"        owner::read() == get_caller_address()\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn is_role_a() -> bool {\n"
"        role_a::read(get_caller_address())\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn only_owner() {\n"
"        assert(is_owner(), 'Not owner');\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn only_role_a() {\n"
"        assert(is_role_a(), 'Not role A');\n"
"    }\n"
"\n"
"    // You can easily combine guards to perfom complex checks\n"
"    fn only_allowed() {\n"
"        assert(is_owner() || is_role_a(), 'Not allowed');\n"
"    }\n"
"\n"
"    // Functions to manage roles\n"
"\n"
"    #[external]\n"
"    fn set_role_a(_target: ContractAddress, _active: bool) {\n"
"        only_owner();\n"
"        role_a::write(_target, _active);\n"
"    }\n"
"\n"
"    // You can now focus on the business logic of your contract\n"
"    // and reduce the complexity of your code by using guard functions\n"
"\n"
"    #[external]\n"
"    fn role_a_action() {\n"
"        only_role_a();\n"
"    // ...\n"
"    }\n"
"\n"
"    #[external]\n"
"    fn allowed_action() {\n"
"        only_allowed();\n"
"    // ...\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch99-03-security-considerations.md:145
msgid "### Static analysis tool"
msgstr ""

#: src/ch99-03-security-considerations.md:147
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""

#: src/ch99-03-security-considerations.md:149
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""

#: src/ch99-03-security-considerations.md:151
msgid "Reference:"
msgstr ""

#: src/ch99-03-security-considerations.md:153
msgid ""
"- [Semgrep Cairo 1.0 "
"support](https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0)"
msgstr ""

#: src/appendix-00.md:1
msgid "# Appendix"
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your\n"
"Cairo journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "## Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or "
"future\n"
"use by the Cairo language."
msgstr ""

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr ""

#: src/appendix-01-keywords.md:8
msgid "- strict\n- reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved,\n"
"they are not recommended to be used as names of any items to follow good "
"practices."
msgstr ""

#: src/appendix-01-keywords.md:16
msgid "### Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts.\n"
"They cannot be used as names of any items."
msgstr ""

#: src/appendix-01-keywords.md:21
msgid ""
"- `as` - Rename import\n"
"- `break` - Exit a loop immediately\n"
"- `const` - Define constant items\n"
"- `continue` - Continue to the next loop iteration\n"
"- `else` - Fallback for `if` and `if let` control flow constructs\n"
"- `enum` - Define an enumeration\n"
"- `extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration\n"
"- `false` - Boolean false literal\n"
"- `fn` - Define a function\n"
"- `if` - Branch based on the result of a conditional expression\n"
"- `impl` - Implement inherent or trait functionality\n"
"- `implicits` - Special kind of function parameters that are required to "
"perform certain actions\n"
"- `let` - Bind a variable\n"
"- `loop` - Loop unconditionally\n"
"- `match` - Match a value to patterns\n"
"- `mod` - Define a module\n"
"- `mut` - Denote variable mutability\n"
"- `nopanic` - Functions marked with this notation mean that the function "
"will never panic.\n"
"- `of` - Implement a trait\n"
"- `ref` - Bind by reference\n"
"- `return` - Return from function\n"
"- `struct` - Define a structure\n"
"- `trait` - Define a trait\n"
"- `true` - Boolean true literal\n"
"- `type` - Define a type alias\n"
"- `use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
msgid "### Reserved keywords"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use.\n"
"They have the same restrictions as strict keywords.\n"
"The reasoning behind this is to make current programs forward compatible "
"with future versions of\n"
"Cairo by forbidding them to use these keywords."
msgstr ""

#: src/appendix-01-keywords.md:57
msgid ""
"- `do`\n"
"- `dyn`\n"
"- `macro`\n"
"- `move`\n"
"- `Self`\n"
"- `self`\n"
"- `static_assert`\n"
"- `static`\n"
"- `super`\n"
"- `try`\n"
"- `typeof`\n"
"- `unsafe`\n"
"- `where`\n"
"- `while`\n"
"- `with`\n"
"- `yield`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "### Built-in functions"
msgstr ""

#: src/appendix-01-keywords.md:78
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""

#: src/appendix-01-keywords.md:80
msgid ""
"-`assert` - This function checks a boolean expression, and if it evaluates "
"to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:1
msgid "# Appendix B: Operators and Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:5
msgid "## Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid ""
"| Operator | Example | Explanation | Overloadable? |\n"
"|----------|---------|-------------|---------------|\n"
"| `!` | `!expr` | Bitwise or logical complement | `Not` |\n"
"| `!=` | `expr != expr` | Non-equality comparison | `PartialEq` |\n"
"| `%` | `expr % expr` | Arithmetic remainder | `Rem` |\n"
"| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemEq` |\n"
"| `&` | `expr & expr` | Bitwise AND | `BitAnd` |\n"
"| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |\n"
"| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulEq` "
"|\n"
"| `@` | `@var` | Snapshot | |\n"
"| `*` | `*var` | Desnap | |\n"
"| `+` | `expr + expr` | Arithmetic addition | `Add` |\n"
"| `+=` | `var += expr` | Arithmetic addition and assignment | `AddEq` |\n"
"| `,` | `expr, expr` | Argument and element separator | |\n"
"| `-` | `-expr` | Arithmetic negation | `Neg` |\n"
"| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |\n"
"| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubEq` |\n"
"| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function "
"and closure return type | |\n"
"| `.` | `expr.ident` | Member access | |\n"
"| `/` | `expr / expr` | Arithmetic division | `Div` |\n"
"| `/=` | `var /= expr` | Arithmetic division and assignment | `DivEq` |\n"
"| `:` | `pat: type`, `ident: type` | Constraints | |\n"
"| `:` | `ident: expr` | Struct field initializer | |\n"
"| `;` | `expr;` | Statement and item terminator | |\n"
"| `<` | `expr < expr` | Less than comparison | `PartialOrd` |\n"
"| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |\n"
"| `=` | `var = expr` | Assignment | |\n"
"| `==` | `expr == expr` | Equality comparison | `PartialEq` |\n"
"| `=>` | `pat => expr` | Part of match arm syntax | |\n"
"| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |\n"
"| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` "
"|\n"
"| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |\n"
"| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` "
"|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "## Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:51
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `..._u8`, `..._usize`, etc. | Numeric literal of specific type |\n"
"| `'...'` | Short string |\n"
"| `_` | “Ignored” pattern binding; also used to make integer literals "
"readable |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:63
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `ident::ident` | Namespace path |\n"
"| `super::path` | Path relative to the parent of the current module |\n"
"| `trait::method(...)` | Disambiguating a method call by naming the trait "
"that defines it |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:73
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `path<...>` | Specifies parameters to generic type in a type (e.g., "
"`Vec<u8>`) |\n"
"| `path::<...>`, `method::<...>` | Specifies parameters to generic type, "
"function, or method in an expression; often referred to as turbofish |\n"
"| `fn ident<...> ...` | Define generic function |\n"
"| `struct ident<...> ...` | Define generic structure |\n"
"| `enum ident<...> ...` | Define generic enumeration |\n"
"| `impl<...> ...` | Define generic implementation |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "<span class=\"caption\">Table B-5: Macros and Attributes</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:86
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `#[meta]` | Outer attribute |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:90
msgid "Table B-6 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "<span class=\"caption\">Table B-6: Comments</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `//` | Line comment |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "<span class=\"caption\">Table B-7: Tuples</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:103
msgid ""
"| Symbol | Explanation |\n"
"|--------|-------------|\n"
"| `()` | Empty tuple (aka unit), both literal and type |\n"
"| `(expr)` | Parenthesized expression |\n"
"| `(expr,)` | Single-element tuple expression |\n"
"| `(type,)` | Single-element tuple type |\n"
"| `(expr, ...)` | Tuple expression |\n"
"| `(type, ...)` | Tuple type |\n"
"| `expr(expr, ...)` | Function call expression; also used to initialize "
"tuple `struct`s and tuple `enum` variants |"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:115
msgid "<span class=\"caption\">Table B-8: Curly Brackets</span>"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:117
msgid ""
"| Context | Explanation |\n"
"|---------|-------------|\n"
"| `{...}` | Block expression |\n"
"| `Type {...}` | `struct` literal |"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "# Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:9
msgid ""
"The list of derivable traits provided in this appendix does not encompass "
"all possibilities: external libraries can implement `derive` for their own "
"traits, expanding the list of traits compatible with `derive`."
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid "## PartialEq for equality comparison"
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:19
msgid ""
"```Rust\n"
"#[derive(PartialEq, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = A {\n"
"        item: 2\n"
"    };\n"
"    assert(first_struct == second_struct, 'Structs are different');\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:36
msgid "## Clone and Copy for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:38
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""

#: src/appendix-03-derivable-traits.md:40
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:44
msgid ""
"```Rust\n"
"use clone::Clone;\n"
"\n"
"#[derive(Clone, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct.clone();\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:61
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:65
msgid ""
"```Rust\n"
"#[derive(Copy, Drop)]\n"
"struct A {\n"
"    item: felt252\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item: 2\n"
"    };\n"
"    let second_struct = first_struct;\n"
"    assert(second_struct.item == 2, 'Not equal');\n"
"    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents "
"firs_struct from moving into second_struct\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:81
msgid "## Serializing with Serde"
msgstr ""

#: src/appendix-03-derivable-traits.md:83
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""

#: src/appendix-03-derivable-traits.md:87
msgid ""
"```Rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let serialized = first_struct.serialize(ref output_array);\n"
"    panic(output_array);\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:108
msgid "Output:"
msgstr ""

#: src/appendix-03-derivable-traits.md:110
msgid ""
"```Bash\n"
"Run panicked with [2 (''), 99 ('c'), ].\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:114
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr ""

#: src/appendix-03-derivable-traits.md:116
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back "
"into our A struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:120
msgid ""
"```Rust\n"
"use serde::Serde;\n"
"use array::ArrayTrait;\n"
"use option::OptionTrait;\n"
"\n"
"#[derive(Serde, Drop)]\n"
"struct A {\n"
"    item_one: felt252,\n"
"    item_two: felt252,\n"
"}\n"
"\n"
"fn main() {\n"
"    let first_struct = A {\n"
"        item_one: 2,\n"
"        item_two: 99,\n"
"    };\n"
"    let mut output_array = ArrayTrait::new();\n"
"    let mut serialized = first_struct.serialize(ref output_array);\n"
"    let mut span_array = output_array.span();\n"
"    let deserialized_struct: A = Serde::<A>::deserialize(ref "
"span_array).unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/appendix-03-derivable-traits.md:143
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""

#: src/appendix-03-derivable-traits.md:145
msgid "## Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:147
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch03-01-what-is-ownership.md#the-drop-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:149
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` "
"[here](ch03-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid "## PartialOrd and Ord for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid "TODO (Not derivable yet ?)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "## Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the "
"Cairo\n"
"project provides. We’ll look at automatic formatting, quick ways to apply\n"
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "### Automatic Formatting with `cairo-format`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"The `cairo-format` tool reformats your code according to the community code "
"style.\n"
"Many collaborative projects use `cairo-format` to prevent arguments about "
"which\n"
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:13
msgid "To format any Cairo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:15
msgid ""
"```console\n"
"cairo-format -r\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
"Running this command reformats all the Cairo code in the current directory, "
"recursively. This\n"
"should only change the code style, not the code semantics."
msgstr ""

#: src/appendix-04-useful-development-tools.md:22
msgid "### IDE Integration Using `cairo-language-server`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:24
msgid ""
"To help IDE integration, the Cairo community recommends using the\n"
"[`cairo-language-server`][cairo-language-server]<!-- ignore -->. This tool "
"is a set of\n"
"compiler-centric utilities that speaks the [Language Server "
"Protocol][lsp]<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to\n"
"communicate with each other. Different clients can use "
"`cairo-language-server`, such as\n"
"[the Cairo extension for Visual Studio Code][vscode-cairo]."
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Visit the `vscode-cairo` [page][vscode-cairo]<!-- ignore -->\n"
"for installation instructions, You will gain abilities such as "
"autocompletion, jump to\n"
"definition, and inline errors."
msgstr ""

#: src/appendix-05-most-common-types-and-traits.md:1
msgid "## Appendix E - Most Common Types and Traits Required To Write Contracts"
msgstr ""

#: src/appendix-05-most-common-types-and-traits.md:3
msgid ""
"This appendix provides a reference for common types and traits used in "
"contract development, along with their corresponding imports, paths, and "
"usage examples."
msgstr ""

#: src/appendix-05-most-common-types-and-traits.md:5
msgid ""
"| Import                    | Path                                           "
"       | Usage                                                               "
"                                                                             "
"                                      |\n"
"| ------------------------- | "
"----------------------------------------------------- | "
"-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
"|\n"
"| `OptionTrait`             | `std::option::OptionTrait`                     "
"       | `OptionTrait<T>` defines a set of methods required to manipulate "
"optional value.                                                              "
"                                         |\n"
"| `ResultTrait`             | `std::result::ResultTrait`                     "
"       | `ResultTrait<T, E>` Type for Starknet contract address, a value in "
"the range [0, 2 \\*\\* 251).                                                 "
"                                         |\n"
"| `ContractAddress`         | `starknet::ContractAddress`                    "
"       | `ContractAddress` is a type to represent the smart contract address "
"                                                                             "
"                                      |\n"
"| `ContractAddressZeroable` | "
"`starknet::contract_address::ContractAddressZeroable` | "
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of "
"`t:ContractAddress` is zero or not. |\n"
"| `contract_address_const`  | `starknet::contract_address_const`             "
"       | The `contract_address_const!` it's a function that allows "
"instantiating constant contract address values.                              "
"                                                |\n"
"| `Into`                    | `traits::Into;`                                "
"       | `Into<T>` is a trait used for conversion between types. If there is "
"an implementation of Into<T,S> for the types T and S, you can convert T into "
"S.                                    |\n"
"| `TryInto`                 | `traits::TryInto;`                             "
"       | `TryInto<T>` is a trait used for conversion between types.If there "
"is an implementation of TryInto<T,S> for the types T and S, you can convert "
"T into S.                               |\n"
"| `get_caller_address`      | `starknet::get_caller_address`                 "
"       | `get_caller_address()` is a function that returns the address of "
"the caller of the contract. It can be used to identify the caller of a "
"contract function.                             |\n"
"| `get_contract_address`    | `starknet::info::get_contract_address`         "
"       | `get_contract_address()` is a function that returns the address of "
"the current contract. It can be used to obtain the address of the contract "
"being executed.                          |"
msgstr ""

#: src/appendix-05-most-common-types-and-traits.md:17
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""
