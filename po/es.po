msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2023-11-21T20:02:02+01:00\n"
"PO-Revision-Date: 2023-06-26 00:08+0100\n"
"Last-Translator: Leandro <carvajal.leandro.94@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.1\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr "El Lenguaje de Programación Cairo"

#: src/SUMMARY.md:3
#, fuzzy
msgid "The Cairo Programming Language Foreword Introduction"
msgstr "El lenguaje de programación Cairo"

#: src/SUMMARY.md:7 src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr "Primeros Pasos"

#: src/SUMMARY.md:11 src/ch01-01-installation.md:1
#: src/ch01-01-installation.md:19
msgid "Installation"
msgstr "Instalación"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr "¡Hola, Mundo!"

#: src/SUMMARY.md:14 src/SUMMARY.md:16
#: src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr "Conceptos Comunes de Programación"

#: src/SUMMARY.md:17 src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "Variables y Mutabilidad"

#: src/SUMMARY.md:18 src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "Tipos de Datos"

#: src/SUMMARY.md:19 src/ch02-03-functions.md:1
msgid "Functions"
msgstr "Funciones"

#: src/SUMMARY.md:20 src/ch02-04-comments.md:1
msgid "Comments"
msgstr "Comentarios"

#: src/SUMMARY.md:21 src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "Flujo de Control"

#: src/SUMMARY.md:23 src/SUMMARY.md:25 src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr "Colecciones Comunes"

#: src/SUMMARY.md:26 src/ch03-01-arrays.md:1
#, fuzzy
msgid "Arrays"
msgstr "Arrays"

#: src/SUMMARY.md:27 src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "Diccionarios"

#: src/SUMMARY.md:28 src/ch03-03-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "Estructura de Dato Personalizadas"

#: src/SUMMARY.md:30 src/SUMMARY.md:32
msgid "Understanding Ownership"
msgstr "Comprender Ownership"

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr "¿Qué es Ownership?"

#: src/SUMMARY.md:34 src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "Referencias y Snapshots"

#: src/SUMMARY.md:36 src/SUMMARY.md:38
#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr "Uso de Structs para Estructurar Datos Relacionados"

#: src/SUMMARY.md:39 src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "Definición e Instanciación de Structs"

#: src/SUMMARY.md:40 src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "Un Programa de Ejemplo Usando Structs"

#: src/SUMMARY.md:41 src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "Sintaxis de Métodos"

#: src/SUMMARY.md:43 src/SUMMARY.md:45
#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr "Enums y Comparación de Pattern"

#: src/SUMMARY.md:46 src/ch06-01-enums.md:1
#: src/ch08-01-generic-data-types.md:163
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md:47 src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "La construcción del flujo de control de coincidencias"

#: src/SUMMARY.md:49 src/SUMMARY.md:51
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Gestionando Proyectos Cairo con Paquetes, Crates y Módulos"

#: src/SUMMARY.md:53 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "Paquetes y Crates"

#: src/SUMMARY.md:54 src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "Definición de Módulos para Controlar el Alcance"

#: src/SUMMARY.md:55
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Paths Para Referirse a Un Item en el Arbol de Módulos"

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "Introducción de Rutas con la Palabra Clave 'use'"

#: src/SUMMARY.md:57 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "Separación de Módulos en Distintos Ficheros"

#: src/SUMMARY.md:59 src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "Tipos de Datos Genéricos"

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr "Tipos Genéricos"

#: src/SUMMARY.md:63 src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr "Funciones Genéricas"

#: src/SUMMARY.md:64 src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "Traits en Cairo"

#: src/SUMMARY.md:66 src/SUMMARY.md:68 src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr "Test de Programas en Cairo"

#: src/SUMMARY.md:70 src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "Cómo Escribir Tests"

#: src/SUMMARY.md:71 src/ch09-02-test-organization.md:1
msgid "Testing Organization"
msgstr "Organización de Testing"

#: src/SUMMARY.md:73 src/SUMMARY.md:75
msgid "Error Handling"
msgstr "Gestión de Errores"

#: src/SUMMARY.md:77 src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr "Errores Irrecuperables con pánico"

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr "Errores Recuperables con Resultados"

#: src/SUMMARY.md:80 src/SUMMARY.md:82 src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr "Funciones Avanzadas"

#: src/SUMMARY.md:84 src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "Sobrecarga del Operador"

#: src/SUMMARY.md:85 src/ch11-02-macros.md:1
msgid "Macros"
msgstr "Macros"

#: src/SUMMARY.md:87
#, fuzzy
msgid "Starknet smart contracts"
msgstr "Starknet Smart Contracts"

#: src/SUMMARY.md:89 src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr "Starknet Smart Contracts"

#: src/SUMMARY.md:91 src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr "Introducción a los Smart-Contracts"

#: src/SUMMARY.md:92 src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr "Un Contrato Simple"

#: src/SUMMARY.md:93 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr "Profundizar en los Contratos"

#: src/SUMMARY.md:95 src/ch99-01-03-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "Almacenamiento de Contrato"

#: src/SUMMARY.md:96 src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "Funciones de Contrato"

#: src/SUMMARY.md:97
msgid "Contract Events"
msgstr "Eventos de Contrato"

#: src/SUMMARY.md:98 src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr "Reducion de Codigo Repetitivo"

#: src/SUMMARY.md:99
msgid "Optimizing storage costs"
msgstr "Optimización de Costos de Almacenamiento"

#: src/SUMMARY.md:101
msgid "Components"
msgstr "Comentarios"

#: src/SUMMARY.md:103
msgid "Under the hood"
msgstr ""

#: src/SUMMARY.md:104 src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr "Dependencias de Componentes"

#: src/SUMMARY.md:105 src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr "Prueba de Componentes"

#: src/SUMMARY.md:107
msgid "ABIs and Cross-contract Interactions"
msgstr "ABIs e Interacciones entre Cross-contract"

#: src/SUMMARY.md:109
msgid "ABIs and Interfaces"
msgstr "ABIs e Interfaces"

#: src/SUMMARY.md:110
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr "Contract Dispatchers, Library Dispachers y system calls"

#: src/SUMMARY.md:112 src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr "Otros Ejemplos"

#: src/SUMMARY.md:114 src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "Desplegando e Interactuando con Un Contrato de Votación"

#: src/SUMMARY.md:116
msgid "L1 \\<\\> L2 Messaging"
msgstr ""

#: src/SUMMARY.md:117 src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr "Consideraciones de Seguridad"

#: src/SUMMARY.md:119 src/appendix-00.md:1
msgid "Appendix"
msgstr "Apéndice"

#: src/SUMMARY.md:121
msgid "A - Keywords"
msgstr "A - Palabras Clave"

#: src/SUMMARY.md:122
msgid "B - Operators and Symbols"
msgstr "B - Operadores y Símbolos"

#: src/SUMMARY.md:123
msgid "C - Derivable Traits"
msgstr "C - Traits Derivables"

#: src/SUMMARY.md:124
msgid "D - Useful Development Tools"
msgstr "D - Herramientas de Desarrollo Útiles"

#: src/SUMMARY.md:125
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr "E - Tipos Comunes, Traits y Cairo Prelude"

#: src/SUMMARY.md:126
msgid "F - Installing Cairo binaries"
msgstr "F - Instalación de los binarios de Cairo"

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its [contributors](https://github.com/cairo-book/"
"cairo-book.github.io). Special thanks to [Starkware](https://starkware.co/) "
"through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager."
"online/) for supporting the creation of this book."
msgstr ""
"creado por la Comunidad Cairo y sus [colaboradores](https://github.com/cairo-"
"book/cairo-book.github.io). Un agradecimiento especial a [Starkware](https://"
"starkware.co/) a través de [OnlyDust](https://www.onlydust.xyz/), y [Voyager]"
"(https://voyager.online/) por apoyar la creación de este libro."

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo Compiler](https://"
"github.com/starkware-libs/cairo) [version 2.2.0](https://github.com/"
"starkware-libs/cairo/releases). See the “Installation” section of Chapter 1 "
"to install or update Cairo."
msgstr ""
"Esta versión del libro asume que estás usando [Cairo Compiler](https://"
"github.com/starkware-libs/cairo) [version 2.2.0](https://github.com/"
"starkware-libs/cairo/releases). Consulte la sección "Instalación" del "
"Capítulo 1 para instalar o actualizar Cairo."

#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr "Prólogo"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"En 2020, StarkWare lanzó Cairo 0, un lenguaje de programación Turing "
"completo que admite cálculo verificable. Cairo comenzó como un lenguaje "
"ensamblador y gradualmente se volvió más expresivo. La curva de aprendizaje "
"fue inicialmente pronunciada, ya que Cairo 0.x era un lenguaje de bajo nivel "
"que no abstraía por completo las primitivas criptográficas subyacentes "
"requeridas para construir una prueba para la ejecución de un programa."

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"Con el lanzamiento de Cairo 1, la experiencia del desarrollador ha mejorado "
"considerablemente, abstrayendo el modelo de memoria inmutable subyacente de "
"la arquitectura de Cairo siempre que sea posible. Inspirado en Rust, Cairo 1 "
"ha sido construido para ayudarte a crear programas comprobables sin "
"conocimientos específicos de su arquitectura subyacente, para que puedas "
"concentrarte en el programa en sí, aumentando la seguridad general de los "
"programas de Cairo. Alimentado por una máquina virtual Rust, la ejecución de "
"los programas de Cairo es ahora _extremadamente_ rápida, lo que te permite "
"construir una amplia suite de pruebas sin comprometer el rendimiento."

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"Los desarrolladores de blockchain que desean implementar contratos en "
"Starknet utilizarán el lenguaje de programación Cairo para codificar sus "
"contratos inteligentes. Esto permite al sistema operativo Starknet generar "
"trazas de ejecución para transacciones que deben ser demostradas por un "
"probador, que luego se verifica en Ethereum L1 antes de actualizar la raíz "
"del estado de Starknet."

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"Sin embargo, Cairo no es solo para desarrolladores de blockchain. Como "
"lenguaje de programación de propósito general, se puede utilizar para "
"cualquier cálculo que se beneficie de ser demostrado en una computadora y "
"verificado en otras máquinas con requisitos de hardware más bajos."

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"Este libro está diseñado para desarrolladores con una comprensión básica de "
"los conceptos de programación. Es un texto amigable y accesible destinado a "
"ayudarte a mejorar tus conocimientos de Cairo, pero también a ayudarte a "
"desarrollar tus habilidades de programación en general. ¡Así que sumérgete y "
"prepárate para aprender todo lo que hay que saber sobre Cairo!"

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr "— La comunidad de Cairo"

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr "Introducción"

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr "¿Qué Es Cairo?"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a more high level language. It first compiles to Sierra, an "
"intermediate representation of Cairo which will compile later down to a safe "
"subset of CASM. The point of Sierra is to ensure your CASM will always be "
"provable, even when the computation fails."
msgstr ""
"Cairo es un lenguaje de programación diseñado para una CPU virtual del mismo "
"nombre. El aspecto único de este procesador es que no fue creado para las "
"restricciones físicas de nuestro mundo, sino para las criptográficas, lo que "
"lo hace capaz de probar eficientemente la ejecución de cualquier programa "
"que se ejecute en él. Esto significa que puedes realizar operaciones que "
"consumen mucho tiempo en una máquina en la que no confías, y comprobar el "
"resultado muy rápidamente en una máquina más barata. "
"Mientras que Cairo 0 solía compilarse directamente a CASM, el ensamblador de "
"CPU de Cairo, Cairo 1 es un lenguaje de más alto nivel. Primero compila a "
"Sierra, una representación intermedia de Cairo que compilará más tarde a un "
"subconjunto seguro de CASM. El objetivo de Sierra es garantizar que tu CASM "
"sea siempre demostrable, incluso cuando falle el cálculo."

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr "¿Qué Puedes Hacer con Cairo?"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"Cairo permite calcular valores confiables en máquinas no confiables. Un caso "
"de uso importante es Starknet, una solución para escalar Ethereum. Ethereum "
"es una plataforma de blockchain descentralizada que permite la creación de "
"aplicaciones descentralizadas donde cada interacción entre un usuario y una "
"dApp es verificada por todos los participantes. Starknet es una capa 2 "
"construida sobre Ethereum. En lugar de requerir que todos los participantes "
"de la red verifiquen todas las interacciones del usuario, solo un nodo, "
"llamado probador (prover), ejecuta los programas y genera pruebas de que los "
"cálculos se realizaron correctamente. Estas pruebas luego son verificadas "
"por un contrato inteligente de Ethereum, lo que requiere significativamente "
"menos potencia de cómputo en comparación con ejecutar las interacciones en "
"sí mismas. Este enfoque permite aumentar la capacidad de procesamiento y "
"reducir los costos de transacción, al tiempo que se preserva la seguridad de "
"Ethereum."

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr "¿Cuáles Son las Diferencias con Otros Lenguajes de Programación?"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""
"Cairo es bastante diferente de los lenguajes de programación tradicionales, "
"especialmente en cuanto a los costos generales y sus ventajas principales. "
"Tu programa se puede ejecutar de dos formas diferentes:"

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"Cuando es ejecutado por el prover(Probador), es similar a cualquier otro " 
"lenguaje. Debido a que Cairo está virtualizado, y a que las operaciones no " 
"fueron específicamente diseñadas para una máxima eficiencia, esto puede llevar "
"a una cierta costos de rendimiento, pero no es la parte más relevante a optimizar."

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"Sin embargo, cuando la prueba generada es verificada por un verificador, "
"es un poco diferente. Esto debe ser lo más económico posible, ya que "
"potencialmente podría ser verificado en muchas máquinas muy pequeñas. "
"Afortunadamente, la verificación es más rápida que el cálculo y Cairo tiene "
"algunas ventajas únicas para mejorar aún más este proceso. Una notable es la "
"no determinación. Este es un tema que se tratará con más detalle más "
"adelante en este libro, pero la idea es que teóricamente puedes usar un "
"algoritmo diferente para verificar que para calcular. Actualmente, no se "
"admite la escritura de código no determinista personalizado para los "
"desarrolladores, pero la biblioteca estándar aprovecha la no determinación "
"para mejorar el rendimiento. Por ejemplo, ordenar un arreglo en Cairo tiene "
"el mismo costo que copiarlo. Debido a que el verificador no ordena el "
"array, solo verifica que esté ordenado, lo cual es más barato."

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"Otro aspecto que diferencia al lenguaje es su modelo de memoria. En Cairo, "
"el acceso a la memoria es inmutable, lo que significa que una vez que se "
"escribe un valor en la memoria, no se puede cambiar. Cairo 1 proporciona "
"abstracciones que ayudan a los desarrolladores a trabajar con estas "
"limitaciones, pero no simula completamente la mutabilidad. Por lo tanto, los "
"desarrolladores deben pensar cuidadosamente en cómo administran la memoria y "
"las estructuras de datos en sus programas para optimizar el rendimiento."

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr "Referencias"

#: src/ch00-00-introduction.md:24
msgid ""
"Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr ""
"Arquitectura del CPU de Cairo: <https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"Cairo, Sierra y Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md:26
msgid ""
"State of non determinism: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"
msgstr ""
"Estado no determinista: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading [Scarb](https://docs.swmansion."
"com/scarb/docs). Scarb bundles the Cairo compiler and the Cairo language "
"server together in an easy-to-install package so that you can start writing "
"Cairo code right away."
msgstr ""
"Cairo puede instalarse simplemente descargando [Scarb](https://docs.swmansion."
"com/scarb/docs). Scarb incluye el compilador Cairo y el servidor de lenguaje "
"Cairo en un paquete fácil de instalar para que puedas empezar a escribir código "
"Cairo inmediatamente."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by [Cargo]"
"(https://doc.rust-lang.org/cargo/), Rust’s build system and package manager."
msgstr ""
"Scarb es el gestor de paquetes de Cairo y está fuertemente inspirado en "
"[Cargo](https://doc.rust-lang.org/cargo/), el sistema de construcción y "
"gestor de paquetes de Rust."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb se encarga de muchas tareas por ti, como construir tu código (ya sea "
"en Cairo puro o contratos Starknet), descargar las librerias necesarias "
"para tu código, construir esas librerias y proporcionar soporte LSP "
"(Language Server Protocol) para la extensión de Cairo 1 en VSCode."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""
"A medida que escribas programas Cairo más complejos, es posible que añadas "
"dependencias, y si comienzas un proyecto utilizando Scarb, gestionar el"
"código externo y las dependencias será mucho más fácil de hacer. "

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Empecemos instalando Scarb."

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr "Instalando Scarb"

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr "Requisitos"

#: src/ch01-01-installation.md:17
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""
"Scarb requiere un ejecutable Git disponible en la variable de entorno `PATH`."

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation instructions](https://"
"docs.swmansion.com/scarb/download). We strongly recommend that you install "
"Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-"
"asdf), a CLI tool that can manage multiple language runtime versions on a "
"per-project basis. This will ensure that the version of Scarb you use to "
"work on a project always matches the one defined in the project settings, "
"avoiding problems lead to version mismatch. Otherwise, you can simply run "
"the following command in your terminal, and follow the onscreen "
"instructions. This will install the latest stable release of Scarb."
msgstr ""
"Para instalar Scarb, por favor consulte las [installation instructions](https://"
"docs.swmansion.com/scarb/download). Recomendamos que instale Scarb a través de "
"[via asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf) una "
"herramienta CLI que puede gestionar múltiples versiones de tiempo de ejecución "
"del lenguaje en una base por proyecto. Esto asegurará que la versión de Scarb "
"que utilices para trabajar en un proyecto siempre coincida con la definida en "
"la configuración del proyecto, evitando problemas que conduzcan a que las "
"versiones no coincidan. De lo contrario, puede simplemente ejecutar el siguiente "
"comando en tu terminal, y seguir las instrucciones en pantalla. Esto instalará "
"la última versión estable de Scarb."

#: src/ch01-01-installation.md:27
msgid "'=https'"
msgstr ""

#: src/ch01-01-installation.md:30
msgid ""
"Verify installation by running the following command in new terminal "
"session, it should print both Scarb and Cairo language versions, e.g:"
msgstr ""
"Verifique la instalación ejecutando el siguiente comando en una nueva"
"terminal, debería imprimir las versiones en Scarb y Cairo, p.ej: "

#: src/ch01-01-installation.md:39
msgid "Installing the VSCode extension"
msgstr "Instalación de la Extensión VSCode"

#: src/ch01-01-installation.md:41
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1). Once installed, go into the extension settings, and make sure to "
"tick the `Enable Language Server` and `Enable Scarb` options."
msgstr ""
"Cairo tiene una extensión VSCode que proporciona resaltado de sintaxis, "
completado de código,y otras características útiles. Puedes instalarla desde "
[VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1). Una vez instalada, ve a la configuración de la extensión, y asegúrate "
"de marcar las opciones `Enable Language Server` y `Enable Scarb` options.""

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "¡Hola, Mundo!"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"Ahora que has instalado Cairo, es hora de escribir tu primer programa "
"Cairo. Es tradicional cuando se aprende un nuevo lenguaje se escriba "
"un pequeño programa que imprima el texto `Hello, world!` en la pantalla, "
"¡así que haremos lo mismo aquí!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix D]"
"(appendix-04-useful-development-tools.md) for more details."
msgstr ""
"Nota: Este libro asume una familiaridad básica con la línea de comandos. "
"Cairo no hace ninguna demanda específica sobre tu edición o herramientas "
"o donde vive tu código, así que si prefiere usar un entorno de desarrollo "
"integrado (IDE) en lugar de la línea de comandos, siéntase libre de usar "
"tu IDE favorito. El equipo de Cairo ha desarrollado una extensión VSCode "
"para el lenguaje Cairo que puedes usar para obtener las características de "
"el servidor de lenguajes y el resaltado de código. Vea el [Appendix D]"
"(appendix-04-useful-development-tools.md) para más detalles."

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr "Creando un Directorio de Proyecto"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"Empezarás creando un directorio para almacenar tu código de Cairo. A Cairo "
"no le importa a Cairo dónde vive tu código, pero para los ejercicios y "
"proyectos de este libro, sugerimos hacer un directorio _cairo_projects_ "
"en tu directorio home y mantener todos tus proyectos allí."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory and a directory for the “Hello, world!” project within the "
"_cairo_projects_ directory."
msgstr ""
"Abre una terminal e introduce los siguientes comandos para crear un "
"directorio _cairo_projects_. y un directorio para el proyecto “¡Hola, mundo!” "
"dentro del directorio _cairo_projects_."

#: src/ch01-02-hello-world.md:25
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"Nota: De ahora en adelante, para cada ejemplo mostrado en el libro, asumimos "
"que estarás trabajando desde un directorio de proyecto Scarb. Si no estás "
"utilizando Scarb, e intentas ejecutar los ejemplos desde un directorio "
"diferente, puede que tengas que ajustar los comandos en consecuencia o crear "
"un proyecto Scarb."

#: src/ch01-02-hello-world.md:28
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Para Linux, macOS y PowerShell en Windows, introduce esto:"

#: src/ch01-02-hello-world.md:35
msgid "For Windows CMD, enter this:"
msgstr "Para Windows CMD, introduzca esto:"

#: src/ch01-02-hello-world.md:38 src/ch01-02-hello-world.md:39
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:42
msgid "Creating a Project with Scarb"
msgstr "Crear un Proyecto con Scarb"

#: src/ch01-02-hello-world.md:44
msgid "Let’s create a new project using Scarb."
msgstr "Vamos a crear un nuevo proyecto usando Scarb."

#: src/ch01-02-hello-world.md:46
msgid ""
"Navigate to your projects directory (or wherever you decided to store your "
"code). Then run the following:"
msgstr ""
"Navegue de nuevo a su directorio de proyectos (o donde hayas decidido "
"almacenar tu código).Luego, ejecute lo siguiente:"

#: src/ch01-02-hello-world.md:52
msgid ""
"It creates a new directory and project called `hello_world`. We’ve named our "
"project `hello_world`, and Scarb creates its files in a directory of the "
"same name."
msgstr ""
"Esto crea un nuevo directorio y proyecto llamado `hello_world`. Hemos nombrado "
"a nuestro proyecto `hello_world`, y Scarb crea sus archivos en un directorio "
"con el mismo nombre."

#: src/ch01-02-hello-world.md:54
msgid ""
"Go into the `hello_world` directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"`Scarb.toml` file and a src directory with a `lib.cairo` file inside."
msgstr ""
"Entre en el directorio `hello_world` con el comando `cd hello_world`. "
"Verás que Scarb ha generado dos archivos y un directorio para nosotros: un "
"archivo `Scarb.toml` y un directorio src con un archivo `lib.cairo` dentro."

#: src/ch01-02-hello-world.md:56
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""
"También ha inicializado un nuevo repositorio Git junto con un archivo `."
"gitignore`"

#: src/ch01-02-hello-world.md:58
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--vcs` flag. Run `scarb new -help` to see the "
"available options."
msgstr ""
"Nota: Git es un sistema de control de versiones común. Puede dejar de usar "
"el sistema de control de versiones usando la bandera `--vcs`. Ejecute "
"`scarb new -help` para ver las opciones disponibles."

#: src/ch01-02-hello-world.md:61
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr ""
"Abra _Scarb.toml_ en su editor de texto preferido. Debería parecerse al "
"código del Listado 1-2."

#: src/ch01-02-hello-world.md:63
msgid "Filename: Scarb.toml"
msgstr "Archivo: Scarb.toml"

#: src/ch01-02-hello-world.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/"
"docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"# Vea más claves y sus definiciones en https://docs.swmansion.com/scarb/docs/"
"reference/manifest.html\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of Scarb.toml generated by `scarb new`"
msgstr "Listado 1-2: Contenido de Scarb.toml generado por `scarb new`"

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""
"Este archivo se encuentra en formato [TOML](https://toml.io/) (Tom’s "
"Obvious, Minimal Language), que es el formato de configuración de Scarb."

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""
"La primera línea, `[package]`, es un encabezado de sección que indica que "
"las siguientes sentencias están configurando un paquete. A medida que "
"agreguemos más información a este archivo, agregaremos otras secciones."

#: src/ch01-02-hello-world.md:82
msgid ""
"The next three lines set the configuration information Scarb needs to compile "
"your program: the name and the version of Scarb to use, and the edition of the "
"prelude to use. The prelude is the collection of the most commonly used items "
"that are automatically imported into every Cairo program. You can learn more "
"about the prelude in [Appendix E](./appendix-05-common-types-and-traits-and-cairo-prelude.md)"
msgstr ""
"Las siguientes tres líneas establecen la información de configuración que Scarb "
"necesita para compilar tu programa: el nombre y la versión de Scarb a utilizar, "
"y la edición del prelude a utilizar. El prelude es la colección de los elementos "
"comúnmente utilizados que se importan automáticamente en cada programa de Cairo. "
"Puedes obtener más información sobre el prelude en el [Appendix E]"
"(./appendix-05-common-types-and-traits-and-cairo-prelude.md)"

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""
"La última línea, `[dependencies]`, es el comienzo de una sección para que "
"puedas listar cualquiera de las dependencias de tu proyecto. En Cairo, los "
"paquetes de código se conocen como crates. No necesitaremos ninguna otra "
"crate para este proyecto."

#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb documentation](https://docs."
"swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""
"Nota: Si estás construyendo contratos para Starknet, deberás agregar la "
"dependencia `starknet` como se menciona en la [Scarb documentation]"
"(https://docs.swmansion.com/scarb/docs/starknet/starknet-package.html)."

#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is `src/lib.cairo`, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""
"El otro archivo creado por Scarb es `src/lib.cairo`, borremos todo el "
"contenido y pongamos el siguiente contenido, explicaremos la razón más "
"adelante."

#: src/ch01-02-hello-world.md:94
msgid ""
"Then create a new file called `src/hello_world.cairo` and put the following "
"code in it:"
msgstr ""
"A continuación, cree un nuevo archivo llamado `src/hello_scarb.cairo` y "
"ponle el siguiente código:"

#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr "Archivo: src/hello_world.cairo"

#: src/ch01-02-hello-world.md:105
msgid ""
"We have just created a file called `lib.cairo`, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file `hello_world.cairo`, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"Acabamos de crear un archivo llamado `lib.cairo`, que contiene una "
"declaración de módulo que hace referencia a otro módulo llamado "
"`hello_world` así como el archivo `hello_scarb.cairo`, que contiene los "
"detalles de implementación del módulo `hello_world`."

#: src/ch01-02-hello-world.md:107
msgid ""
"Scarb requires your source files to be located within the `src` directory."
msgstr ""
"Scarb requiere que sus archivos fuente se encuentren dentro del directorio "
"`src`."

#: src/ch01-02-hello-world.md:109
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"El directorio principal del proyecto está reservado para archivos README, "
"información de licencia, archivos de configuración y cualquier otro contenido "
"no relacionado con el código. Scarb asegura una ubicación designada para "
"todos los componentes del proyecto, manteniendo una organización estructurada."

#: src/ch01-02-hello-world.md:112
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the src directory "
"and create an appropriate `Scarb.toml` file."
msgstr ""
"Si has iniciado un proyecto que no utiliza Scarb, puedes convertirlo en "
"un proyecto que sí lo use, Scarb. Mueva el código del proyecto al directorio "
"src y cree un archivo `Scarb.toml` apropiado."

#: src/ch01-02-hello-world.md:114
msgid "Building a Scarb Project"
msgstr "Crear un Proyecto con Scarb"

#: src/ch01-02-hello-world.md:116
msgid ""
"From your `hello_world` directory, build your project by entering the "
"following command:"
msgstr ""
"Desde tu directorio `hello_world`, construya su proyecto introduciendo el "
"siguiente comando:"

#: src/ch01-02-hello-world.md:124
msgid ""
"This command creates a `sierra` file in `target/dev`, let's ignore the "
"`sierra` file for now."
msgstr ""
"Este comando crea un archivo `sierra` en `target/dev`, ignoremos el "
"archivo `sierra` por ahora."

#: src/ch01-02-hello-world.md:126
msgid ""
"If you have installed Cairo correctly, you should be able to run and see the "
"following output:"
msgstr ""
"Si has instalado Cairo correctamente, deberías ser capaz de ejecutarlo y ver "
"la siguiente salida:"

#: src/ch01-02-hello-world.md:136
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to the terminal."
msgstr ""
"Independientemente de tu sistema operativo, el string `Hello, world!` "
"debería imprimirse en la terminal."

#: src/ch01-02-hello-world.md:139
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer—welcome!"
msgstr ""
"Si `Hello, world!` se imprime, ¡felicidades! Has escrito oficialmente un "
"programa en Cairo. Eso te convierte en un programador de Cairo ¡Bienvenido!"

#: src/ch01-02-hello-world.md:142
msgid "Anatomy of a Cairo Program"
msgstr "Anatomía de un Programa Cairo"

#: src/ch01-02-hello-world.md:144
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""
"Revisemos este programa “Hello, world!” en detalle. Aquí está la primera "
"pieza del rompecabezas:"

#: src/ch01-02-hello-world.md:153
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"Estas líneas definen una función llamada `main`. La función `main` es "
"especial: siempre es el primer código que se ejecuta en cada programa "
"ejecutable de Cairo. Aquí, la primera línea declara una función llamada "
"`main` que no tiene parámetros y devuelve nada. Si hubiera parámetros, "
"irían dentro de los paréntesis `()`."

#: src/ch01-02-hello-world.md:158
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"El cuerpo de la función está envuelto en `{}`. Cairo requiere llaves "
"alrededor de todos los cuerpos de funciones. Es una buena práctica colocar "
"la llave de apertura en la misma línea que la declaración de la función, "
"añadiendo un espacio en medio."

#: src/ch01-02-hello-world.md:162
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix D]"
"(appendix-04-useful-development-tools.md)). The Cairo team has included this "
"tool with the standard Cairo distribution, as `cairo-run` is, so it should "
"already be installed on your computer!"
msgstr ""
"Nota: Si quieres mantener un estilo estándar en todos los proyectos de Cairo, "
"puedes usar la herramienta de formateo automático llamada `scarb fmt` para "
"formatear tu código en un estilo específico (más sobre `scarb fmt` en "
"[Apéndice D](appendix-04-useful-development-tools.md)). El equipo de Cairo ha "
"incluido esta herramienta con la distribución estándar de Cairo, como `cairo-run`, "
"¡así que ya debería estar instalada en tu ordenador!"

#: src/ch01-02-hello-world.md:169
msgid "The body of the `main` function holds the following code:"
msgstr "El cuerpo de la función `main` contiene el siguiente código:"

#: src/ch01-02-hello-world.md:175
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""
"Esta línea hace todo el trabajo en este pequeño programa: imprime texto en "
"la pantalla. Hay cuatro detalles importantes a tener en cuenta aquí."

#: src/ch01-02-hello-world.md:178
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "Primero, el estilo de Cairo es identar con cuatro espacios, no con una tabulación."

#: src/ch01-02-hello-world.md:180
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead, it "
"would be entered as `println` (without the `!`). We’ll discuss Cairo macros in "
"more detail in [Chapter Macros](./ch11-02-macros.md). For now, you just need to "
"know that using a `!` means that you’re calling a macro instead of a normal "
"function and that macros don’t always follow the same rules as functions."
msgstr ""
"En segundo lugar, las llamadas a `println` hacen uso de un macro de Cairo. Si en "
"su lugar se hubiera llamado a una función, se escribiría como `println` (sin el `!`). "
"Discutiremos los macros de Cairo con más detalle en [Chapter Macros]"
"(./ch11-02-macros.md). Por ahora, solo necesitas saber que el uso del `!` indica "
"que estás llamando a un macro en lugar de una función normal, y que los macros "
"no siempre siguen las mismas reglas que las funciones."

#: src/ch01-02-hello-world.md:183
msgid ""
"Third, you see the `"Hello, world!"` string. We pass this string as an argument "
"to `println!`, and the string is printed to the screen."
msgstr ""
"En tercer lugar, ves la short string `'Hello, world!'`. Pasamos este short "
"string como argumento a `print()`, y la cadena corta se imprime en la pantalla."

#: src/ch01-02-hello-world.md:187
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""
"Cuarto, terminamos la línea con un punto y coma (`;`), que indica que esta "
"expresión ha terminado y la siguiente está lista para comenzar. La mayoría "
"de las líneas de código de Cairo terminan con punto y coma."

#: src/ch01-02-hello-world.md:193
msgid "Running tests"
msgstr "Ejecución de Test"

#: src/ch01-02-hello-world.md:195
msgid ""
"To run all the tests associated with a particular package, you can use the "
"`scarb test` command. It is not a test runner by itself, but rather "
"delegates work to a testing solution of choice. Scarb comes with "
"preinstalled `scarb cairo-test` extension, which bundles Cairo's native test "
"runner. It is the default test runner used by scarb test. To use third-party "
"test runners, please refer to [Scarb's documentation](https://docs.swmansion."
"com/scarb/docs/extensions/testing.html#using-third-party-test-runners)."
msgstr ""
"Para ejecutar todos los test asociados con un paquete específico, puedes usar "
"el comando `scarb test`. No es un ejecutor de test en sí mismo, sino que delega "
"el trabajo a una solución de test a elección. Scarb viene con la extensión "
"`scarb cairo-test` preinstalada, que incluye el ejecutor de test nativo de Cairo."
"Es el ejecutor de test predeterminado utilizado por scarb test. Para utilizar "
"ejecutores de test de terceros, por favor consulta la documentación [Scarb's "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/testing."
"html#using-third-party-test-runners)."

#: src/ch01-02-hello-world.md:199
msgid ""
"Test functions are marked with the `#[test]` attributes, and running `scarb "
"test` will run all test functions in your codebase under the `src/` "
"directory."
msgstr ""
"Las funciones de test se marcan con el atributo `#[test]`, y al ejecutar "
"`scarb test` se ejecutarán todas las funciones de test en tu código bajo el "
"`src/` directory."

#: src/ch01-02-hello-world.md:208
msgid " A sample Scarb project structure"
msgstr " Ejemplo de estructura de un proyecto Scarb"

#: src/ch01-02-hello-world.md:210
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "Recapitulemos lo que hemos aprendido hasta ahora sobre Scarb:"

#: src/ch01-02-hello-world.md:212
msgid "We can create a project using `scarb new`."
msgstr "Podemos crear un proyecto utilizando `scarb new`."

#: src/ch01-02-hello-world.md:213
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""
"Podemos construir un proyecto usando `scarb build` para generar el código "
"compilado de Sierra."

#: src/ch01-02-hello-world.md:214
msgid ""
"We can define custom scripts in `Scarb.toml` and call them with the `scarb "
"run` command."
msgstr ""
"Podemos definir scripts personalizados en `Scarb.toml` y llamarlos con el "
"comando `Scarb.run`."

#: src/ch01-02-hello-world.md:215
msgid "We can run tests using the `scarb test` command."
msgstr "Podemos ejecutar tests usando el comando `scarb test`."

#: src/ch01-02-hello-world.md:217
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Una ventaja adicional de usar Scarb es que los comandos son los mismos sin "
"importar el sistema operativo en el que estemos trabajando. Así que, en este "
"punto, ya no proporcionaremos instrucciones específicas para Linux y macOS "
"frente a Windows."

#: src/ch01-02-hello-world.md:220 src/ch02-05-control-flow.md:242
#: src/ch03-02-dictionaries.md:528 src/ch03-03-custom-data-structures.md:214
#: src/ch05-03-method-syntax.md:286
#: src/ch07-05-separating-modules-into-different-files.md:98
#: src/ch10-02-recoverable-errors.md:202
msgid "Summary"
msgstr "Resumen"

#: src/ch01-02-hello-world.md:222
msgid ""
"You’re already off to a great start on your Cairo journey! In this chapter, "
"you’ve learned how to:"
msgstr ""
"¡Ya has tenido un gran comienzo en tu viaje con Cairo!. En este capítulo, has "
"aprendido cómo:"

#: src/ch01-02-hello-world.md:224
msgid "Install the latest stable version of Cairo"
msgstr "Instalar la última versión estable de Cairo"

#: src/ch01-02-hello-world.md:225
msgid "Write and run a “Hello, Scarb!” program using `scarb` directly"
msgstr "Escribir y ejecutar un programa "¡Hola, Scarb!" usando `scarb` directamente"

#: src/ch01-02-hello-world.md:226
msgid "Create and run a new project using the conventions of Scarb"
msgstr "Crear y ejecutar un nuevo proyecto siguiendo las convenciones de Scarb"

#: src/ch01-02-hello-world.md:227
msgid "Execute tests using the `scarb test` command"
msgstr "Ejecutar pruebas usando el comando `scarb test`"

#: src/ch01-02-hello-world.md:229
msgid ""
"This is a great time to build a more substantial program to get used to "
"reading and writing Cairo code."
msgstr ""
"Este es un buen momento para construir un programa más sustancial para "
"acostumbrarte a leer y escribir código de Cairo."

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de "
"programación y cómo funcionan en Cairo. Muchos lenguajes de programación "
"tienen mucho en común en su núcleo. Ninguno de los conceptos presentados en "
"este capítulo son exclusivos de Cairo, pero los discutiremos en el contexto "
"de Cairo y explicaremos las convenciones sobre el uso de estos conceptos."

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""
"Específicamente, aprenderás sobre variables, tipos básicos, funciones, "
"comentarios y flujo de control. Estos fundamentos estarán en cada programa "
"de Cairo, y aprenderlos desde el principio te dará un núcleo fuerte desde el "
"que empezar."

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"Cairo usa un modelo de memoria inmutable, lo que significa que una vez que "
"se escribe en una celda de memoria, no se puede sobrescribir, sino solo leer. "
"Para reflejar este modelo de memoria inmutable, las variables en Cairo son "
"inmutables por defecto. Sin embargo, el lenguaje abstrae este modelo y te da "
"la opción de hacer tus variables mutables. Exploremos cómo y por qué Cairo "
"impone la inmutabilidad, y cómo puedes hacer tus variables mutables."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a variable is bound to a value, you can’t "
"change that variable. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"Cuando una variable es inmutable, una vez que un valor está ligado a un "
"nombre, no puedes cambiar ese valor. Para ilustrar esto, genera un nuevo "
"proyecto llamado _variables_ en tu directorio _cairo_projects_ usando "
"`scarb new variables`."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""
"A continuación, en tu nuevo directorio _variables_, abra _src/lib.cairo_ y "
"sustituya su código por el siguiente, que todavía no compilará:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:77
#: src/ch02-01-variables-and-mutability.md:155 src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58 src/ch02-05-control-flow.md:90
#: src/ch02-05-control-flow.md:130 src/ch04-01-what-is-ownership.md:252
#: src/ch04-01-what-is-ownership.md:294 src/ch04-01-what-is-ownership.md:347
#: src/ch04-02-references-and-snapshots.md:23
#: src/ch04-02-references-and-snapshots.md:134
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:48
#: src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:120
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:48
#: src/ch05-02-an-example-program-using-structs.md:74
#: src/ch05-02-an-example-program-using-structs.md:103
#: src/ch05-02-an-example-program-using-structs.md:136
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:93
#: src/ch05-03-method-syntax.md:135 src/ch05-03-method-syntax.md:192
#: src/ch05-03-method-syntax.md:231
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-how-to-write-tests.md:28 src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:118 src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:207 src/ch09-01-how-to-write-tests.md:305
#: src/ch09-01-how-to-write-tests.md:394 src/ch09-01-how-to-write-tests.md:489
#: src/ch09-01-how-to-write-tests.md:527 src/ch09-01-how-to-write-tests.md:563
#: src/ch09-02-test-organization.md:30 src/ch09-02-test-organization.md:59
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr "Archivo: src/lib.cairo"

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run --available-gas=200000000`. "
"You should receive an error message regarding an immutability error, as "
"shown in this output:"
msgstr ""
"Guarda y ejecuta el programa usando scarb cairo-run --available-gas=200000000. "
"Deberías recibir un mensaje de error relacionado con un error de inmutabilidad, "
"como se muestra en esta salida:"

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but really they only mean your program "
"isn’t safely doing what you want it to do yet; they do _not_ mean that "
"you’re not a good programmer! Experienced Caironautes still get compiler "
"errors."
msgstr ""
"Este ejemplo muestra cómo el compilador te ayuda a encontrar errores en "
"tus programas. Los errores del compilador pueden ser frustrantes, pero en "
"realidad sólo significan que tu programa aún no está haciendo de manera "
"segura lo que deseas; ¡no significan que seas un buen programador! Los "
"Caironautas experimentados siguen teniendo errores de compilador."

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"Recibiste el mensaje de error `Cannot assign to an immutable variable.` "
"porque intentaste asignar un segundo valor a la variable inmutable `x`."

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"Es importante que obtengamos errores en tiempo de compilación cuando "
"intentamos cambiar un valor designado como inmutable porque esta situación "
"específica puede conducir a errores. Si una parte de nuestro código opera "
"bajo la suposición de que un valor nunca cambiará y otra parte de nuestro "
"código cambia ese valor, es posible que la primera parte del código no haga "
"lo que fue diseñada para hacer. La causa de este tipo de error puede ser "
"difícil de rastrear después de los hechos, especialmente cuando la segunda "
"parte del código cambia el valor sólo _a veces_."

#: src/ch02-01-variables-and-mutability.md:58
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole "
"class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""
"Cairo, a diferencia de la mayoría de los otros lenguajes, tiene memoria inmutable. "
"Esto hace que una clase completa de errores sea imposible, porque los valores nunca "
"cambiarán inesperadamente. Esto facilita el razonamiento sobre el código."

#: src/ch02-01-variables-and-mutability.md:62
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"Pero la mutabilidad puede ser muy útil, y puede hacer que el código sea más "
"cómodo de escribir. Aunque las variables son inmutables por defecto, puedes "
"hacerlas mutables añadiendo `mut` delante del nombre de la variable. Añadir "
"`mut` también transmite intención a los futuros lectores del código indicando "
"que otras partes del código cambiarán el valor de esta variable."

#: src/ch02-01-variables-and-mutability.md:67
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that Cairo's memory is immutable, but the "
"memory address the variable points to can be changed. Upon examining the low-"
"level Cairo Assembly code, it becomes clear that variable mutation is "
"implemented as syntactic sugar, which translates mutation operations into a "
"series of steps equivalent to variable shadowing. The only difference is "
"that at the Cairo level, the variable is not redeclared so its type cannot "
"change."
msgstr ""
"Sin embargo, puede que en este punto te estés preguntando qué ocurre "
"exactamente cuando una variable es declarada como `mut`, ya que "
"previamente mencionamos que la memoria de Cairo es inmutable. La respuesta "
"es que la memoria de Cairo es inmutable, pero la dirección de memoria a la "
"que apunta la variable puede ser cambiada. Al examinar el código ensamblador "
"de bajo nivel de Cairo, queda claro que la mutación de variables se implementa "
"como azúcar sintáctico, que traduce las operaciones de mutación en una serie "
"de pasos equivalentes al shadowing de variables. La única diferencia es que "
"en el nivel la variable no se vuelve a declarar, por lo que su tipo no puede cambiar."

#: src/ch02-01-variables-and-mutability.md:75
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Por ejemplo, cambiemos _src/lib.cairo_ por lo siguiente:"

#: src/ch02-01-variables-and-mutability.md:89
msgid "When we run the program now, we get this:"
msgstr "Cuando ejecutamos el programa ahora, obtenemos esto:"

#: src/ch02-01-variables-and-mutability.md:70
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. What value the variable points to can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon "
"examining the low-level Cairo Assembly code, it becomes clear that variable "
"mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only "
"difference is that at the Cairo level, the variable is not redeclared so its "
"type cannot change."
msgstr ""
"Sin embargo, puede que te estés preguntando en este punto qué ocurre exactamente "
"cuando una variable se declara como `mut`, ya que anteriormente mencionamos que "
"la memoria de Cairo es inmutable. La respuesta es que el _valor_ es inmutable, "
"pero la _variable_ no lo es. El valor al que apunta la variable puede ser cambiado. "
"Asignar a una variable mutable en Cairo es esencialmente equivalente a redeclararla "
"para referirse a otro valor en otra celda de memoria, pero el compilador se encarga "
"de ello, y la palabra clave `mut` lo hace explícito. Al examinar el código ensamblador "
"de bajo nivel de Cairo, queda claro que la mutación se implementa como azúcar "
"sintáctico, que traduce las operaciones de mutación las operaciones de mutación en una "
"serie de pasos equivalentes al shadowing de variables. La única diferencia es que en "
"el nivel Cairo, la variable no se vuelve a declarar, por lo que su tipo no puede cambiar."

#: src/ch02-01-variables-and-mutability.md:100
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""
"Se nos permite cambiar el valor ligado a `x` de `5` a `6` cuando se usa "
"`mut`. En última instancia, la decisión de utilizar la mutabilidad o no "
"es suya y depende de lo que usted piensa que es más claro en esa situación particular."

#: src/ch02-01-variables-and-mutability.md:104
msgid "Constants"
msgstr "Constantes"

#: src/ch02-01-variables-and-mutability.md:106
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""
"Al igual que las variables inmutables, las _constants_ son valores que "
"están vinculados a un nombre y no se les permite cambiar, pero hay algunas "
"diferencias entre las constantes y las variables."

#: src/ch02-01-variables-and-mutability.md:110
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"En primer lugar, no se permite el uso de `mut` con las constantes. Las "
"constantes no son solo inmutables por defecto, sino que siempre son inmutables. "
"Se declaran constantes usando la palabra clave `const` en lugar de la palabra "
"clave `let`, y el tipo de valor _must_ ser anotado. Cubriremos los tipos y las "
"anotaciones de tipo en la próxima sección, [“Data Types”](ch02-02-data-types.md), "
"así que no se preocupe por los detalles por ahora. Solo sepa que siempre debe "
"anotar el tipo."

#: src/ch02-01-variables-and-mutability.md:117
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""
"Las constantes solo se pueden declarar en el ámbito global, lo que las "
"hace útiles para valores que muchas partes del código necesitan conocer."

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"The last difference is that constants may be set only to a constant "
"expression, not the result of a value that could only be computed at "
"runtime. Only literal constants are currently supported."
msgstr ""
"La última diferencia es que las constantes solo pueden ser asignadas a una "
"expresión constante, no al resultado de un valor que solo se podría calcular "
"en tiempo de ejecución. Actualmente, solo se admiten constantes literales."

#: src/ch02-01-variables-and-mutability.md:124
msgid "Here’s an example of a constant declaration:"
msgstr "Aquí hay un ejemplo de declaración de constante:"

#: src/ch02-01-variables-and-mutability.md:130
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""
"La convención de nomenclatura de Cairo para las constantes es utilizar "
"mayúsculas con guiones bajos entre palabras."

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"Las constantes son válidas durante todo el tiempo que se ejecuta un "
"programa, dentro del ámbito en el que fueron declaradas. Esta propiedad "
"hace que las constantes sean útiles para los valores en el dominio de su "
"aplicación que varias partes del programa podrían necesitar conocer, "
"como el número máximo de puntos que cualquier jugador de un juego puede "
"ganar o la velocidad de la luz."

#: src/ch02-01-variables-and-mutability.md:139  
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"Nombrar los valores codificados en el programa como constantes y usarlas en "
"todo el código es útil para transmitir el significado de ese valor a los futuros "
"mantenedores del código. También ayuda a tener solo un lugar en tu código que "
"necesitarías cambiar si el valor codificado necesitara ser actualizado en el futuro."

#: src/ch02-01-variables-and-mutability.md:144
#, fuzzy
msgid "Shadowing"
msgstr "Shadowing"

#: src/ch02-01-variables-and-mutability.md:146
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""
"El shadowing (sombreado) de variables se refiere a la declaración de una nueva "
"variable con el mismo nombre que una variable anterior. Los Caironautas dicen "
"que la primera variable está sombreada por la segunda, lo que significa que la "
"segunda variable es la que el compilador verá cuando uses el nombre de la "
"variable. En efecto, la segunda variable eclipsa a la primera, tomando cualquier "
"uso del nombre de la variable para sí misma hasta que ella misma sea sombreada o "
"termine el ámbito. Podemos sombrear una variable usando el mismo nombre de la "
"variable y repitiendo el uso de la palabra clave `let` de la siguiente manera:"

#: src/ch02-01-variables-and-mutability.md:172
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""
"Este programa primero asigna un valor de `5` a `x`. Luego crea una nueva "
"variable `x` repitiendo `let x =`, tomando el valor original y sumando "
"`1`, por lo que el valor de `x` es ahora `6`. Luego, dentro de un ámbito "
"interno creado con llaves, la tercera instrucción `let` también sombrea "
"`x` y crea una nueva variable, multiplicando el valor anterior por `2` "
"para darle a `x` un valor de `12`. Cuando ese ámbito termina, la sombra "
"interna termina y `x` vuelve a ser `6`. Al ejecutar este programa, se "
"mostrará lo siguiente:"

#: src/ch02-01-variables-and-mutability.md:194
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"El shadowing es diferente a marcar una variable como `mut`, porque obtendremos "
"un error en tiempo de compilación si intentamos reasignar a esta variable sin "
"usar la palabra clave `let`. Al usar `let`, podemos realizar algunas "
"transformaciones en un valor pero hacer que la variable sea inmutable después "
"de que se hayan completado esas transformaciones."

#: src/ch02-01-variables-and-mutability.md:200
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"Otra distinción entre `mut` y el shadowing es que al usar nuevamente la "
"palabra clave `let`, estamos creando efectivamente una nueva variable, lo "
"que nos permite cambiar el tipo del valor mientras reutilizamos el mismo "
"nombre. Como se mencionó anteriormente, el shadowing de variables y las "
"variables mutables son equivalentes a un nivel más bajo. La única diferencia "
"es que al hacer shadowing de una variable, el compilador no mostrará un "
"error si cambias su tipo. Por ejemplo, supongamos que nuestro programa "
"realiza una conversión de tipo entre los tipos `u64` y `felt252`."

#: src/ch02-01-variables-and-mutability.md:214
msgid "// converts x to a felt, type annotation is required.\n"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:219
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"El primer variable `x` tiene un tipo `u64`, mientras que la segunda variable "
"`x` tiene un tipo `felt252`. Por lo tanto, el shadowing nos ahorra tener que "
"inventar diferentes nombres, como `x_u64` y `x_felt252`; en su lugar, podemos "
"reutilizar el nombre más simple `x`. Sin embargo, si intentamos usar `mut` "
"para esto, como se muestra aquí, obtendremos un error en tiempo de compilación:"

#: src/ch02-01-variables-and-mutability.md:235
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""
"El error indica que se esperaba un `u64` (el tipo original), pero se obtuvo "
"un tipo diferente:"

#: src/ch02-01-variables-and-mutability.md:237
#, fuzzy
msgid ""
"```shell\n"
"$ scarb cairo-run\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: "
"\"core::felt252\".\n"
" --> lib.cairo:9:9\n"
"    x = 100_felt252;\n"
"        ^*********^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""


#: src/ch02-01-variables-and-mutability.md:247
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""
"Ahora que hemos explorado cómo funcionan las variables, veamos otros tipos "
"de datos que pueden tener."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""
"Cada valor en Cairo tiene un cierto _tipo de dato_, lo que le dice a Cairo "
"qué tipo de datos se están especificando para que sepa cómo trabajar con esos "
"datos. Esta sección cubre dos subconjuntos de tipos de datos: escalares y compuestos."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a cast method where we specify the "
"desired output type."
msgstr ""
"Ten en cuenta que Cairo es un lenguaje de _tipado estático_, lo que significa "
"que debe conocer los tipos de todas las variables en tiempo de compilación. El "
"compilador suele inferir el tipo deseado en función del valor y su uso. En "
"casos en que pueden ser posibles varios tipos, podemos utilizar un método de "
"conversión donde especificamos el tipo de salida deseado."

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr "Verás diferentes anotaciones de tipo para otros tipos de datos."

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr "Tipo Escalar"

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Un tipo _escalar_ representa un único valor. Cairo tiene tres tipos escalares "
"primarios:felts, integers(enteros) y booleans. Puede que reconozca de otros "
"lenguajes de programación. Veamos cómo funcionan en Cairo."

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr "Tipo Felt"

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range `0 <= x < P`, where `P` is a very large prime number currently equal "
"to `P = 2^{251} + 17 * 2^{192}+1`. When adding, subtracting, or multiplying, "
"if the result falls outside the specified range of the prime number, an "
"overflow occurs, and an appropriate multiple of P is added or subtracted to "
"bring the result back within the range (i.e., the result is computed modulo "
"P)."
msgstr ""
"En Cairo, si no especificas el tipo de una variable o argumento, su tipo por "
"defecto es un elemento de campo, representado por la palabra clave `felt252`. "
"En el contexto de Cairo, cuando decimos \"un elemento de campo\" nos referimos "
"a un entero en el rango `0 <= x < P`, donde `P` es un número primo muy grande "
"actualmente igual a `P = 2^{251} + 17 * 2^{192}+1`. Al sumar, restar o multiplicar, "
"si el resultado queda fuera del rango especificado del número primo, se produce "
"un desbordamiento y se suma o resta un múltiplo apropiado de P para que el resultado "
"vuelva a estar dentro del rango (es decir, el resultado se calcula módulo P)."

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division `x / y` is defined as "
"`[x/y]` where the integer part of the quotient is returned (so you get `7 / "
"3 = 2`) and it may or may not satisfy the equation `(x / y) * y == x`, "
"depending on the divisibility of `x` by `y`."
msgstr ""
"La diferencia más importante entre los números enteros y los elementos de "
"campo es la división: La división de elementos de campo (y, por tanto, la "
"división en Cairo) es distinta de la división normal de las CPU, en la que\n"
"la división entera `x / y` se define como `[x/y]` donde se devuelve la parte "
"entera del cociente (por lo que se obtiene `7 / 3 = 2`) y puede o no "
"satisfacer la ecuación `(x / y) * y == x`, dependiendo de la divisibilidad "
"de `x` por `y`."

#: src/ch02-02-data-types.md:34
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation "
"`(x / y) * y == x`. If y divides x as integers, you will get the expected "
"result in Cairo (for example `6 / 2` will indeed result in `3`). But when y "
"does not divide x, you may get a surprising result: For example, since `2 * "
"((P+1)/2) = P+1 ≡ 1 mod[P]`, the value of `1 / 2` in Cairo is `(P+1)/2` (and "
"not 0 or 0.5), as it satisfies the above equation."
msgstr ""
"En Cairo, el resultado de `x/y` está definido para satisfacer siempre la "
"ecuación `(x / y) * y == x`. Si `y` divide a `x` entre enteros, obtendrás el "
"resultado esperado en Cairo (por ejemplo `6 / 2` dará como resultado `3`). "
"Pero cuando `y` no divide a `x`, puedes obtener un resultado sorprendente: "
"Por ejemplo, como `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, el valor de `1 / 2` en "
"Cairo es `(P+1)/2` (y no 0 ó 0,5), ya que satisface la ecuación anterior."

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr "Tipo Integer"

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow checks. By using these integer types, programmers can ensure "
"that their programs are more secure and less susceptible to attacks or other "
"security threats. An _integer_ is a number without a fractional component. "
"This type declaration indicates the number of bits the programmer can use to "
"store the integer. Table 3-1 shows the built-in integer types in Cairo. We "
"can use any of these variants to declare the type of an integer value."
msgstr ""
"El tipo felt252 es un tipo fundamental que sirve como base para la creación "
"de todos los tipos en la librería central. Sin embargo, se recomienda "
"encarecidamente a los programadores que utilicen los tipos integer en lugar "
"del tipo `felt252` siempre que sea posible, ya que los tipos `integer` vienen "
"con características de seguridad añadidas que proporcionan protección extra "
"contra posibles vulnerabilidades en el código, como comprobaciones de "
"desbordamiento. Utilizando estos tipos de integer, los programadores pueden "
"asegurarse de que sus programas son más seguros y menos susceptibles a ataques "
"u otras amenazas de seguridad. Un _integer_ es un número sin componente "
"fraccionario. Esta declaración de tipo indica el número de bits que el "
"programador puede utilizar para almacenar el entero. La Tabla 3-1 muestra "
"los tipos de integer integrados en Cairo. Podemos usar cualquiera de estas "
"variantes para declarar el tipo de un valor entero."


#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr "Tabla 3-1: Tipos de Integer en Cairo"

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr ""

#: src/ch02-02-data-types.md:53 src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr ""

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr ""

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr ""

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""
"Cada variante tiene un tamaño explícito. Tenga en cuenta que por ahora, el "
"tipo `usize` es sólo un alias para `u32`; sin embargo, podría ser útil "
"cuando en el futuro Cairo pueda ser compilado a MLIR.Como las variables son "
"sin signo, no pueden contener un número negativo. Este código hará que el "
"programa genere un error:"

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`"
msgstr ""
"Todos los tipos de integer mencionados anteriormente encajan en un `felt252`, "
"excepto `u256`, que necesita 4 bits adicionales para almacenarse. Por debajo, "
"`u256` es básicamente una estructura con 2 campos: `u256 {low: u128, high: u128}`"

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type."
msgstr ""
"Puede escribir literales integer en cualquiera de las formas mostradas en la "
"Tabla 3-2. Observe que los literales numéricos que pueden ser múltiples tipos "
"numéricos permiten un sufijo de tipo como `57_u8`, para designar el tipo."

#: src/ch02-02-data-types.md:78
msgid "Table 3-2: Integer Literals in Cairo"
msgstr "Tabla 3-2: Literales de Integer en Cairo"

#: src/ch02-02-data-types.md:80
#, fuzzy
msgid "Numeric literals"
msgstr "Literales Numericos"

#: src/ch02-02-data-types.md:80 src/appendix-02-operators-and-symbols.md:11
#, fuzzy
msgid "Example"
msgstr "Ejemplo:"

#: src/ch02-02-data-types.md:82
msgid "Decimal"
msgstr ""

#: src/ch02-02-data-types.md:82
msgid "`98222`"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "Hex"
msgstr ""

#: src/ch02-02-data-types.md:83
msgid "`0xff`"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "Octal"
msgstr ""

#: src/ch02-02-data-types.md:84
msgid "`0o04321`"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "Binary"
msgstr ""

#: src/ch02-02-data-types.md:85
msgid "`0b01`"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"Entonces, ¿cómo saber qué tipo de entero utilizar? Intenta estimar el valor "
"máximo que puede tener tu int y elige el tamaño adecuado."La principal "
"situación en la que usarías `usize` es al indexar algún tipo de colección."

#: src/ch02-02-data-types.md:90
msgid "Numeric Operations"
msgstr "Operaciones Numéricas"

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"Cairo soporta las operaciones matemáticas básicas que esperarías para todos "
"los tipos de integer: suma, resta, multiplicación y resto (u256 no soporta "
"división y resto todavía). Entero trunca hacia cero al entero más cercano. "
"El siguiente código muestra cómo utilizar cada operación numérica en una "
"sentencia `let`:"

#: src/ch02-02-data-types.md:99
msgid "// addition\n"
msgstr ""

#: src/ch02-02-data-types.md:102
msgid "// subtraction\n"
msgstr ""

#: src/ch02-02-data-types.md:105
msgid "// multiplication\n"
msgstr ""

#: src/ch02-02-data-types.md:108
msgid "// division\n"
msgstr ""

#: src/ch02-02-data-types.md:109
msgid "//result is 1\n"
msgstr ""

#: src/ch02-02-data-types.md:110
msgid "//result is 2\n"
msgstr ""

#: src/ch02-02-data-types.md:112
msgid "// remainder\n"
msgstr ""

#: src/ch02-02-data-types.md:113
msgid "// result is 3\n"
msgstr ""

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""
"Cada expresión de estas sentencias utiliza un operador matemático y se "
"evalúa a un único valor, que se asigna a una variable."

#: src/ch02-02-data-types.md:120
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list "
"of all operators that Cairo provides."
msgstr ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contiene una lista "
"de todos los operadores que Cairo proporciona."

#: src/ch02-02-data-types.md:122
msgid "The Boolean Type"
msgstr "Tipo Boolean"

#: src/ch02-02-data-types.md:124
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one felt252 in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"Como en la mayoría de los lenguajes de programación, un tipo booleano en "
"Cairo tiene dos posibles valores: `true` y `false`. Los booleanos tienen "
"un byte de tamaño. El tipo booleano en Cairo se especifica usando `bool`. "
"Por ejemplo:"

#: src/ch02-02-data-types.md:132
msgid "// with explicit type annotation\n"  
msgstr ""

#: src/ch02-02-data-types.md:136
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control "
"Flow”](ch02-05-control-flow.md) section."
msgstr ""
"La principal forma de utilizar valores booleanos es a través de condicionales, "
"como una expresión `if`. Cubriremos cómo funcionan las expresiones "
"`if` en Cairo en la sección [“Control "Flow”](ch02-05-control-flow.md)"

#: src/ch02-02-data-types.md:140
msgid "The Short String Type"
msgstr "Tipo Short String"

#: src/ch02-02-data-types.md:142
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples "
"of declaring values by putting them between single quotes:"
msgstr ""
"Cairo no tiene un tipo nativo para strings, pero puedes almacenar caracteres "
"formando lo que llamamos un \"short string\" dentro de `felt252`. Un short "
"string tiene una longitud máxima de 31 caracteres. Esto es para asegurar que "
"puede caber en un solo felt (un felt son 252 bits, un char ASCII son 8 bits). "
"He aquí algunos ejemplos de declaración de valores entre comillas simples:"

#: src/ch02-02-data-types.md:147
msgid "'C'"
msgstr ""

#: src/ch02-02-data-types.md:152
msgid "Type casting"
msgstr "Conversión de Tipos"

#: src/ch02-02-data-types.md:154
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the "
"`try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"En Cairo, puedes convertir tipos escalares de un tipo a otro utilizando los "
"métodos `try_into` e `into` proporcionados por los traits `TryInto` e "
"`Into`, respectivamente."

#: src/ch02-02-data-types.md:156
msgid ""
"The `try_into` method allows for safe type casting when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"El método `try_into` permite una conversión de tipos segura cuando el tipo "
"de destino puede no encajar con el valor de origen. Ten en cuenta que "
"`try_into` devuelve un tipo `Option<T>`, que tendrás que desenvolver para "
"acceder al nuevo valor."

#: src/ch02-02-data-types.md:158
msgid ""
"On the other hand, the `into` method can be used for type casting when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""
"Por otro lado, el método `into` se puede utilizar para la conversión de "
"tipos cuando el éxito está garantizado, como cuando el tipo de destino es "
"más pequeño que el tipo de origen."

#: src/ch02-02-data-types.md:160
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to cast it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"Para realizar la conversión, llame a `var.into()` o `var.try_into()` sobre "
"el valor fuente para convertirlo a otro tipo. El tipo de la nueva variable "
"debe definirse explícitamente, como se muestra en el siguiente ejemplo."

#: src/ch02-02-data-types.md:165
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""

#: src/ch02-02-data-types.md:171
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""

#: src/ch02-02-data-types.md:179
msgid "The Tuple Type"
msgstr "Tipo Tupla"

#: src/ch02-02-data-types.md:181
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""
"Una _tuple_ es una forma general de agrupar un número de valores con una "
"variedad de tipos en un tipo compuesto. Las tuplas tienen una longitud "
"fija: una vez declaradas, no pueden aumentar ni disminuir de tamaño."

#: src/ch02-02-data-types.md:185
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"Se crea una tupla escribiendo una lista de valores separados por comas "
"entre paréntesis. Cada posición de la tupla tiene un tipo, y los tipos de "
"los distintos valores de la tupla no tienen por qué ser iguales. Hemos "
"añadido anotaciones opcionales de tipo en este ejemplo:"

#: src/ch02-02-data-types.md:196
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""
"La variable `tup` se vincula a toda la tupla porque una tupla se considera "
"un único elemento compuesto. Para obtener los valores individuales de una tupla, "
"podemos utilizar la concordancia de patrones para desestructurar un valor de "
"tupla, así:"

#: src/ch02-02-data-types.md:213
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"six` as the value of `y` is `6`."
msgstr ""
"Este programa crea primero una tupla y la asocia a la variable `tup`. A "
"continuación, utiliza un patrón con `let` para tomar `tup` y convertirla "
"en tres variables separadas, `x`, `y`, y `z`. Esto se llama "
"_desestructuración_ porque divide la tupla en tres partes. Finalmente, "
"el programa imprime `y es seis` ya que el valor de `y` es `6`."

#: src/ch02-02-data-types.md:219
msgid ""
"We can also declare the tuple with value and types at the same time. For "
"example:"
msgstr ""
"También podemos declarar la tupla con los valores y los tipos al mismo "
"tiempo. Por ejemplo:"

#: src/ch02-02-data-types.md:228
msgid "The unit type ()"
msgstr "Tipo Unidad ()"

#: src/ch02-02-data-types.md:230
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""
"Un _tipo unidad_ es un tipo que sólo tiene un valor `()`.Se representa "
"mediante una tupla sin elementos. Su tamaño es siempre cero y se garantiza "
"que no existirá en el código compilado."

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""
"Las funciones son frecuentes en el código de Cairo. Ya has visto una de "
"las funciones más importantes del lenguaje: la función `main`, que es el punto "
"de entrada de muchos programas. También has visto la palabra clave `fn`, que "
"te permite declarar nuevas funciones."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"El código de Cairo utiliza el estilo _snake case_ como convención para los "
"nombres de funciones y variables, en el cual todas las letras están en "
"minúscula y los guiones bajos separan las palabras. Aquí hay un programa que "
"contiene un ejemplo de definición de función:"

#: src/ch02-03-functions.md:25
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""
"Definimos una función en Cairo introduciendo `fn` seguido de un nombre de "
"función y un conjunto de paréntesis. Las llaves indican al compilador dónde "
"empieza y termina el cuerpo de la función."

#: src/ch02-03-functions.md:29
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"Podemos llamar a cualquier función que hayamos definido introduciendo su "
"nombre seguido de paréntesis. Dado que `otra_funcion` está definida "
"en el programa, puede ser llamada desde dentro de la función `main`. Tenga "
"en cuenta que hemos definido `otra_funcion` _antes_ de la función `main` "
"en el código fuente; también podríamos haberla definido después también. "
"A Cairo no le importa dónde definas tus funciones, sólo que estén definidas "
"en algún lugar en un ámbito que pueda ser visto por quien las llame."

#: src/ch02-03-functions.md:36
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""
"Empecemos un nuevo proyecto con Scarb llamado _functions_ para explorar las "
"funciones más a fondo. Coloque el ejemplo `another_function` en _src/lib.cairo_ "
"y ejecútelo. Usted Debería ver la siguiente salida:"

#: src/ch02-03-functions.md:46
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""
"Las líneas se ejecutan en el orden en que aparecen en la función `main`. "
"Primero se imprime el mensaje “Hello, world!”, luego se llama a "
"`another_function` y se imprime su mensaje."

#: src/ch02-03-functions.md:50
msgid "Parameters"
msgstr "Parámetros"

#: src/ch02-03-functions.md:52
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"Podemos definir funciones para que tengan _parameters_, que son variables "
"especiales que forman parte de la firma de una función. Cuando una función tiene "
"parámetros, puedes proporcionarle valores concretos para esos parámetros. "
"Técnicamente, los valores valores concretos se llaman _arguments_, pero en la "
"conversación informal, la gente tiende a usar las palabras _parameters_ y _arguments_ "
"indistintamente para las variables en la definición de una función o los valores "
"concretos que se pasan cuando se llama a una función."

#: src/ch02-03-functions.md:60
msgid "In this version of `another_function` we add a parameter:"
msgstr "En esta versión de `another_function` añadimos un parámetro:"

#: src/ch02-03-functions.md:74
msgid "Try running this program; you should get the following output:"
msgstr "Intente ejecutar este programa; debería obtener la siguiente salida:"

#: src/ch02-03-functions.md:79
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"La declaración de `another_function` tiene un parámetro llamado x. El tipo de "
"`x` se especifica cómo `felt252`. Cuando pasamos 5 a `another_function`, la "
"macro `println!` coloca 5 donde estaba el par de llaves que contenían a `x` en "
"el formato string."

#: src/ch02-03-functions.md:83
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""
"En las firmas de función, _must_ declarar el tipo de cada parámetro. Esta "
"es una decisión deliberada en el diseño de Cairo: requerir anotaciones de "
"tipo en las significa que el compilador casi nunca necesita usarlas en otra "
"parte del código el código para averiguar a qué tipo se refiere. El compilador "
"también puede dar mensajes de error más útiles si sabe qué tipos espera la función."

#: src/ch02-03-functions.md:89
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""
"Cuando defina múltiples parámetros, separe las declaraciones de parámetros "
"con comas, así:"

#: src/ch02-03-functions.md:102
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second "
"is named `unit_label` and is of type `ByteArray` - Cairo's internal type to "
"represent string literals. The function then prints text containing both the "
"`value` and the `unit_label`."
msgstr ""
"Este ejemplo crea una función llamada `print_labeled_measurement` con dos "
"parámetros. El primer parámetro se llama `value` y es un `u128`. El segundo "
"se llama `unit_label` y es de tipo `ByteArray`, el tipo interno de Cairo "
"para representar literales de string. La función luego imprime texto que "
"contiene tanto el valor como la etiqueta de unidad `unit_label`."

#: src/ch02-03-functions.md:106
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run --available-gas=200000000`:"
msgstr ""
"Intentemos ejecutar este código. Sustituye el programa que actualmente está "
"en tu proyecto _functions_ de tu proyecto _src/lib.cairo_ con el ejemplo "
"anterior y ejecútalo usando `scarb cairo-run --available-gas=200000000`:"

#: src/ch02-03-functions.md:116
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""
"Dado que llamamos a la función con `5` como el valor para valor y `\"h\"` como "
"el valor para `unit_label`, la salida del programa contiene esos valores."


#: src/ch02-03-functions.md:123
msgid "Named parameters"
msgstr "Parámetros con Nombre"

#: src/ch02-03-functions.md:125
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"En Cairo, los parámetros con nombre permiten especificar los nombres de los "
"argumentos cuando se llama a una función. Esto hace que las llamadas a "
"funciones sean más legibles y autodescriptivas. Si quieres usar parámetros "
"con nombre, necesitas especificar el nombre del parámetro y el valor que "
"quieres pasarle. La sintaxis es `parameter_name: value`. Si pasas una "
"variable que tiene el mismo nombre que el parámetro, puedes escribir "
"simplemente `:parameter_name` en lugar de `parameter_name: variable_name`."

#: src/ch02-03-functions.md:128
msgid "Here is an example:"
msgstr "Aquí un ejemplo:"

#: src/ch02-03-functions.md:143
msgid "Statements and Expressions"
msgstr "Declaraciones y Expresiones"

#: src/ch02-03-functions.md:145
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"Los cuerpos de las funciones están compuestos por una serie de sentencias "
"que terminan opcionalmente en una expresión. Hasta ahora, las funciones que "
"hemos cubierto no han incluido una expresión final, pero ya has visto una "
"expresión como parte de una sentencia. Como Cairo es un lenguaje basado en "
"expresiones, esta es una distinción importante que debemos entender. Otros "
"lenguajes no tienen las mismas distinciones, así que veamos qué son las "
"sentencias y expresiones y cómo sus diferencias afectan los cuerpos de las "
"funciones."

#: src/ch02-03-functions.md:153
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr ""
"**Declaraciones** son instrucciones que realizan alguna acción y no "
"devuelven un valor."

#: src/ch02-03-functions.md:155
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""
"**Expresiones** se evalúan a un valor resultante. Veamos algunos ejemplos."

#: src/ch02-03-functions.md:157
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"De hecho, ya hemos utilizado declaraciones y expresiones. Crear una variable "
"y asignarle un valor con la palabra clave `let` es una declaración. En el "
"Listado 2-1, `let y = 6;` es una declaración."

#: src/ch02-03-functions.md:167
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr "Listado 2-1: Declaración de una función main que contiene una instrucción"


#: src/ch02-03-functions.md:169
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""
"Las definiciones de funciones también son sentencias; todo el ejemplo "
"anterior es una sentencia en sí misma."

#: src/ch02-03-functions.md:172
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""
"Las declaraciones no devuelven valores. Por lo tanto, no se puede asignar "
"una sentencia `let` a otra variable, como intenta hacer el siguiente "
"código; se producirá un error:"

#: src/ch02-03-functions.md:181
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "Cuando ejecutes este programa, el error que obtendrás se verá así:"

#: src/ch02-03-functions.md:205
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"La declaración `let y = 6` no devuelve un valor, por lo que no hay nada a lo "
"que `x` pueda enlazar. Esto es diferente de lo que sucede en otros lenguajes, "
"como C y Ruby, donde la asignación devuelve el valor de la asignación. En esos "
"lenguajes, puedes escribir `x = y = 6` y tanto `x` como `y` tendrán el valor "
"`6`; esto no es así en Cairo."

#: src/ch02-03-functions.md:211
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`. Calling a function is an "
"expression. A new scope block created with curly brackets is an expression, "
"for example:"
msgstr ""
"Las expresiones se evalúan a un valor y forman la mayor parte del resto del "
"código que escribirás en Cairo. Considera una operación matemática, como `5 + 6`"
", que es una expresión que se evalúa al valor `11`. Las expresiones pueden ser "
"parte de sentencias: en el Listado 2-1, el `6` en la sentencia `let y = 6;` es "
"una es una expresión que se evalúa al valor `6`. Llamar a una función es una"
"expresión. Un nuevo bloque de ámbito creado con es una expresión, por ejemplo:"

#: src/ch02-03-functions.md:231
msgid "This expression:"
msgstr "Esta expresión:"

#: src/ch02-03-functions.md:240
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""
"Este bloque de código, en este caso, se evalúa como 4. Ese valor se asigna "
"a y como parte de la declaración let. Ten en cuenta que la línea x + 1 no "
"tiene un punto y coma al final, lo que es diferente a la mayoría de las líneas "
"que has visto hasta ahora. Las expresiones no incluyen un punto y coma al final. "
"Si agregas un punto y coma al final de una expresión, la conviertes en una "
"declaración, y en ese caso no se devolverá ningún valor. Tenlo en cuenta mientras "
"exploras los valores de retorno de las funciones y las expresiones a continuación."

#: src/ch02-03-functions.md:248
msgid "Functions with Return Values"
msgstr "Funciones con Valores de Retorno"

#: src/ch02-03-functions.md:250
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""
"Las funciones pueden devolver valores al código que las llama. No nombramos "
"los valores de retorno, pero debemos declarar su tipo después de una flecha "
"(`->`). En Cairo, el valor de retorno de la función es sinónimo del valor "
"de la última expresión en el bloque del cuerpo de una función. Puede salir "
"temprano de una función usando la palabra clave `return` y especificando un "
"valor, pero la mayoría de las funciones devuelven la última expresión "
"implícitamente. Aquí hay un ejemplo de una función que devuelve un valor:"

#: src/ch02-03-functions.md:271
msgid ""
"There are no function calls, or even `let` statements in the `five` function—"
"just the number `5` by itself. That’s a perfectly valid function in Cairo. "
"Note that the function’s return type is specified too, as `-> u32`. Try "
"running this code; the output should look like this:"
msgstr ""
"No hay llamadas a funciones ni declaraciones `let` en la función `five`, "
"solo el número `5` por sí mismo. Esa es una función perfectamente válida en "
"Cairo. Observa que se especifica el tipo de retorno de la función como `-> u32`. "
"Intenta ejecutar este código; la salida debería verse así:"

#: src/ch02-03-functions.md:281
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"El `5` en `five` es el valor de retorno de la función, por eso el tipo de "
"retorno es `u32`. Vamos a examinar esto con más detalle. Hay dos partes "
"importantes: en primer lugar, la línea `let x = five();` muestra que estamos "
"usando el valor de retorno de una función para inicializar una variable. "
"Debido a que la función `five` devuelve un `5`, esa línea es lo mismo que:"

#: src/ch02-03-functions.md:291
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""
"Segundo, la función `five` no tiene parámetros y define el tipo del valor "
"de retorno, pero el cuerpo de la función es un solitario `5` sin punto "
"y coma porque es una expresión cuyo valor queremos devolver. Veamos otro ejemplo:"

#: src/ch02-03-functions.md:310
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end "
"of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"Al ejecutar este código se imprimirá `x = 6`. Pero si agregamos un punto y "
"coma al final de la línea que contiene `x + 1`, cambiándola de una expresión "
"a una declaración, obtendremos un error:"

#: src/ch02-03-functions.md:328
msgid "Compiling this code produces an error, as follows:"
msgstr "La compilación de este código produce un error, como se muestra a continuación:"

#: src/ch02-03-functions.md:330
#, fuzzy
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"
msgstr ""
"```console\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"

#: src/ch02-03-functions.md:334
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"El mensaje principal de error, `Unexpected return type`, revela el problema "
"principal con este código. La definición de la función `plus_one` indica que "
"devolverá un `u32`, pero las sentencias no se evalúan a un valor, lo cual "
"se expresa por `()`, el tipo unit. Por lo tanto, no se devuelve nada, lo que "
"contradice la definición de la función y resulta en un error."

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using "
"comments. To create a comment, use the // syntax, after which any text on "
"the same line will be ignored by the compiler."
msgstr ""
"En programas de Cairo, puedes incluir texto explicativo dentro del código "
"mediante comentarios. Para crear un comentario, usa la sintaxis //, después "
"de lo cual cualquier texto en la misma línea será ignorado por el compilador."

#: src/ch02-04-comments.md:7
msgid "// start of the function\n"
msgstr ""

#: src/ch02-04-comments.md:8
msgid "// return the sum of 1 and 4\n"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""
"La capacidad de ejecutar cierto código dependiendo de si una condición es "
"verdadera y de ejecutar código repetidamente mientras una condición es "
"verdadera son bloques de construcción básicos en la mayoría de los lenguajes "
"de programación. Las construcciones más comunes que le permiten controlar el "
"flujo de ejecución del código en Cairo son las expresiones if y los bucles."

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "Expresiones `if`"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Una expresión if le permite ramificar su código según condiciones. "
"Proporciona una condición y luego establece: "Si se cumple esta condición, "
"ejecute este bloque de código. Si no se cumple la condición, no ejecute este "
"bloque de código"."

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"Todos las expresiones `if` comienzan con la palabra clave `if`, seguido de "
"una condición. En este caso, la condición verifica si la variable `number` "
"tiene un valor igual a 5. Colocamos el bloque de código a ejecutar si la "
"condición es `true` inmediatamente después de la condición dentro de llaves."

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""
"Opcionalmente, también podemos incluir una expresión `else`, que elegimos "
"hacer aquí, para dar al programa un bloque de código alternativo para "
"ejecutar si la condición se evalúa como `false`. Si no proporciona una "
"expresión `else` y la condición es `false`, el programa simplemente omitirá "
"el bloque `if` y pasará al siguiente fragmento de código."

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "Intente ejecutar este código; debería ver la siguiente salida:"

#: src/ch02-05-control-flow.md:36
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""
"Intentaré cambiar el valor de `number` por uno que haga que la condición sea "
"`true` para ver qué sucede:"

#: src/ch02-05-control-flow.md:47
msgid ""
"It’s also worth noting that the condition in this code must be a bool. If "
"the condition isn’t a bool, we’ll get an error."
msgstr ""
"También vale la pena señalar que la condición en este código debe ser un "
"bool. Si la condición no es un bool, obtendremos un error."

#: src/ch02-05-control-flow.md:54

msgid "Handling Multiple Conditions with `else if`"
msgstr "Manejando de Múltiples Condiciones con `else if`"

#: src/ch02-05-control-flow.md:56
msgid ""
"You can use multiple conditions by combining if and else in an else if "
"expression. For example:"
msgstr ""
"Puede usar múltiples condiciones combinando `if` y `else` en una expresión "
"`else if`. Por ejemplo:"

#: src/ch02-05-control-flow.md:78
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""
"Este programa tiene cuatro posibles caminos que puede seguir. Después de "
"ejecutarlo, debería ver la siguiente salida:"

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1'` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using "
"too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter "
"6](./ch06-02-the-match-control-flow-construct.md) describes a powerful Cairo "
"branching construct called `match` for these cases."
msgstr ""
"Cuando este programa se ejecuta, verifica cada expresión `if` sucesivamente y "
"ejecuta el cuerpo correspondiente a la primera condición que se evalúa como "
"`true`. Observa que, aunque `number - 2 == 1` es `true`, no vemos la "
"salida `number minus 2 is 1'.print()`, ni el texto `number not found` del bloque "
"`else`. Esto se debe a que Cairo solo ejecuta el bloque correspondiente a la "
"primera condición verdadera y, una vez que encuentra una, ni siquiera verifica el "
"resto. El uso excesivo de expresiones `else if` puede ensuciar tu código, así "
"que si tienes más de una, podrías considerar refactorizar tu código. [Chapter 6]"
"(./ch06-02-the-match-control-flow-construct.md) describe una poderosa "
"construcción de ramificación en Cairo llamada match para estos casos."

#: src/ch02-05-control-flow.md:86
msgid "Using `if` in a `let` statement"
msgstr "Usando `if` en una Declaración `let`"

#: src/ch02-05-control-flow.md:88
msgid ""
"Because if is an expression, we can use it on the right side of a let "
"statement to assign the outcome to a variable."
msgstr ""
"Dado que `if` es una expresión, podemos usarla en el lado derecho de una "
"declaración `let` para asignar el resultado a una variable."

#: src/ch02-05-control-flow.md:114
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression. Which will be 5 here."
msgstr ""
"La variable `number` quedará ligada a un valor basado en el resultado de la "
"expresión `if`. En este caso, será 5."

#: src/ch02-05-control-flow.md:116
msgid "Repetition with Loops"
msgstr "Repetición con Loops"

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called loops."
msgstr ""
"A menudo es útil ejecutar un bloque de código más de una vez. Para esta "
"tarea, Cairo proporciona una simple sintaxis de bucle, que recorrerá el "
"código dentro del cuerpo del bucle hasta el final y luego comenzará "
"inmediatamente de vuelta al principio. Para experimentar con bucles, creemos "
"un nuevo proyecto llamado bucles."

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr "Cairo sólo tiene un tipo de bucle por ahora: `loop`."

#: src/ch02-05-control-flow.md:122
msgid "Repeating Code with `loop`"
msgstr "Repetición de Código con `loop`"

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""
"La palabra clave `loop` le dice a Cairo que ejecute un bloque de código una "
"y otra vez para siempre o hasta que le digas explícitamente que pare."

#: src/ch02-05-control-flow.md:127
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""
"Como ejemplo, cambie el archivo _src/lib.cairo_ en tu directorio _loops_ para "
"quede de la siguiente manera:"

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `i = 0` printed over and over "
"continuously until we stop the program manually, because the stop condition "
"is never reached. While the compiler prevents us from writing programs "
"without a stop condition (`break` statement), the stop condition might never "
"be reached, resulting in an infinite loop. Most terminals support the "
"keyboard shortcut "
msgstr ""
"Cuando ejecutamos este programa, veremos que se imprime "i = 0" una y "
"otra vez continuamente hasta que detengamos el programa manualmente, "
"porque la condición de detención nunca se cumple. Si bien el compilador "
"nos impide escribir programas sin una condición de detención (declaración `break`), "
"la condición de detención puede no alcanzarse nunca, lo que resulta en un bucle "
"infinito. La mayoría de las terminales admiten el atajo de teclado "

#: src/ch02-05-control-flow.md:149
msgid "ctrl-c"
msgstr "ctrl-c "

#: src/ch02-05-control-flow.md:149
msgid " to interrupt a program that is stuck in a continual loop. Give it a try:"
msgstr "para interrumpir un programa que está atrapado en un bucle continuo. Pruébalo:"

#: src/ch02-05-control-flow.md:166
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the `--"
"available-gas` flag, we can set the maximum amount of gas available to the "
"program. Gas is a unit of measurement that expresses the computation cost of "
"an instruction. When the gas meter runs out, the program will stop. In this "
"case, the program panicked because it ran out of gas, as the stop condition "
"was never reached. It is particularly important in the context of smart "
"contracts deployed on Starknet, as it prevents from running infinite loops "
"on the network. If you're writing a program that needs to run a loop, you "
"will need to execute it with the `--available-gas` flag set to a value that "
"is large enough to run the program."
msgstr ""
"Nota: Cairo nos previene de ejecutar programas con bucles infinitos "
"incluyendo un contador de gas. El contador de gas es un mecanismo que limita "
"la cantidad de computación que se puede hacer en un programa. Estableciendo "
"un valor a la bandera `--available-gas`, podemos establecer la cantidad "
"máxima de gas disponible para el programa. El gas es una unidad de medida "
"que expresa el coste de cálculo de una instrucción. Cuando el contador de "
"gas se agote, el programa se detendrá. En este caso, el programa entró en "
"pánico porque se quedó sin gas, ya que nunca se alcanzó la condición de "
"parada. Es particularmente importante en el contexto de los contratos "
"inteligentes desplegados en Starknet, ya que evita que se ejecuten bucles "
"infinitos en la red. Si estás escribiendo un programa que necesita ejecutar "
"un bucle, tendrás que ejecutarlo con la bandera `--available-gas` establecida "
"en un valor que sea lo suficientemente grande como para ejecutar el programa."

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break` statement within the loop "
"to tell the program when to stop executing the loop. Let's fix the infinite "
"loop by adding a making the stop condition `i > 10` reachable."
msgstr ""
"Para salir de un bucle, puedes colocar la instrucción `break` dentro del "
"bucle para indicarle al programa cuándo detener la ejecución del bucle. "
"Vamos a solucionar el bucle infinito haciendo que la condición de parada "
"`i > 10` sea alcanzable."

#: src/ch02-05-control-flow.md:187
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration. Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""
"La palabra clave `continue` le indica al programa que pase a la siguiente "
"iteración del bucle y omita el resto del código en esta iteración. "
"Agreguemos una instrucción `continue` a nuestro bucle para saltar la "
"declaración `print` cuando `i` sea igual a `5`."

#: src/ch02-05-control-flow.md:207
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr ""
"Al ejecutar este programa, no se imprimirá el valor de `i` cuando sea igual "
"a `5`."

#: src/ch02-05-control-flow.md:209
msgid "Returning Values from Loops"
msgstr "Retorno de Valores de Loops"

#: src/ch02-05-control-flow.md:211
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"Uno de los usos de un `loop` es volver a intentar una operación que sabes que "
"podría fallar, como verificar si una operación ha tenido éxito. También es "
"posible que necesites pasar el resultado de esa operación fuera del bucle "
"para el resto de tu código. Para hacer esto, puedes agregar el valor que "
"deseas devolver después de la expresión `break` que utilizas para detener el "
"bucle; ese valor se devolverá fuera del bucle para que puedas utilizarlo, "
"como se muestra aquí:"

#: src/ch02-05-control-flow.md:235
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"Antes del bucle, declaramos una variable llamada `counter` y la inicializamos "
"en `0`. Luego declaramos una variable llamada `result` para mantener el "
"valor devuelto por el bucle. En cada iteración del bucle, comprobamos si `counter` "
"es igual a `10`, y añadimos `1` a la variable `counter`. Cuando se cumple la "
"condición, utilizamos la palabra clave `break` con el valor `counter * 2`. Después "
"del bucle, usamos un punto y coma para terminar la sentencia que asigna el valor a "
"`result`. Finalmente el valor en `result`, que en este caso es `20`."

#: src/ch02-05-control-flow.md:244
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"¡Lo has conseguido! Este fue un capítulo considerable: aprendiste sobre variables, "
"tipos de datos, funciones, comentarios, expresiones `if` y bucles. Para practicar "
"con los conceptos discutidos en este capítulo, intenta construir programas para "
"hacer lo siguiente:"

#: src/ch02-05-control-flow.md:248
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "Generar el _n_\\-th número de Fibonacci.\n"


#: src/ch02-05-control-flow.md:249
msgid "Compute the factorial of a number _n_."
msgstr "Calcular el factorial de un número _n_."

#: src/ch02-05-control-flow.md:251
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""
"Ahora, revisaremos los tipos de colección comunes en Cairo en el próximo capítulo."

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""
"Cairo ofrece un conjunto de tipos de colecciones comunes que pueden utilizarse "
"para almacenar y manipular datos. Estas colecciones están diseñadas para ser "
"eficientes, flexibles y fáciles de usar. Esta sección presenta los tipos principales "
"de colecciones disponibles en Cairo: Arrays y Diccionarios."

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""
"Un array es una colección de elementos del mismo tipo. Puedes crear y utilizar "
"métodos de array mediante el uso del rasgo `ArrayTrait` de la libreria principal."

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. "
"Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front using `pop_front`."
msgstr ""
"Algo importante a tener en cuenta es que las arrays tienen opciones de "
"modificación limitadas. Las arrays son, de hecho, colas cuyos valores no "
"pueden modificarse. Esto tiene que ver con el hecho de que una vez que se "
"escribe en un espacio de memoria, no se puede sobrescribir, sino sólo leer "
"de él. Sólo se pueden añadir elementos al final de un array y eliminar "
"elementos de la parte delantera utilizando `pop_front`."

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "Crear un Array"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an Array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""
"Crear un Array se realiza con la llamada `ArrayTrait::new()`. Aquí tienes "
"un ejemplo de la creación de una array a la que agregamos 3 elementos:"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""
"Cuando sea necesario, puedes pasar el tipo esperado de elementos dentro del "
"array al instanciarlo de esta manera, o definir explícitamente el tipo del mismo."

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "Actualizar un Array"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "Añadir Elementos"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""
"Para añadir un elemento al final de un array, puedes utilizar el método `append()`:"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "Eliminar Elementos"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` containing the removed "
"element, or `Option::None` if the array is empty."
msgstr ""
"Sólo se pueden eliminar elementos de la parte frontal de un array utilizando "
"el método `pop_front()`. Este método devuelve un `Option` que contiene el "
"elemento eliminado, o `Option::None` si el array está vacío."

#: src/ch03-01-arrays.md:61
msgid "// print '10'\n"
msgstr ""

#: src/ch03-01-arrays.md:65
msgid ""
"The above code will print `10` as we remove the first element that was added."
msgstr ""
"El código anterior imprimirá `10` cuando eliminemos el primer elemento "
"añadido."

#: src/ch03-01-arrays.md:67
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""
"En Cairo, la memoria es inmutable, lo que significa que no es posible "
"modificar los elementos de un array una vez que han sido añadidos. Sólo se "
"pueden añadir elementos al final de un array y eliminar elementos de la "
"parte frontal de un array. Estas operaciones no requieren mutación de "
"memoria, ya que implican actualizar punteros en lugar de modificar "
"directamente las celdas de memoria."

#: src/ch03-01-arrays.md:69
msgid "Reading Elements from an Array"
msgstr "Lectura de Elementos en un Array"

#: src/ch03-01-arrays.md:71
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"Para acceder a los elementos de un array, puedes utilizar los métodos "
"`get()` o `at()` que devuelven diferentes tipos. Utilizar `arr.at(index)` es "
"equivalente a utilizar el operador de subíndice `arr[index]`."

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and Snapshots](ch04-02-"
"references-and-snapshots.md) chapter."
msgstr ""
"La función `get` devuelve una `Option<Box<@T>>`, lo que significa que "
"devuelve una opción a un tipo Box (el tipo smart-pointer de Cairo) que "
"contiene una instantánea al elemento en el índice especificado si ese "
"elemento existe en el array. Si el elemento no existe, `get` devuelve "
"`None`. Este método es útil cuando esperas acceder a índices que pueden no "
"estar dentro de los límites del array y quieres manejar tales casos con "
"gracia sin pánicos. Las instantáneas se explicarán con más detalle en el "
"capítulo [References and Snapshots](ch03-02-references-and-snapshots.md)."

#: src/ch03-01-arrays.md:75
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"La función `at`, por otro lado, devuelve directamente una instantánea al "
"elemento en el índice especificado utilizando el operador `unbox()` para "
"extraer el valor almacenado en una caja. Si el índice está fuera de los "
"límites, se produce un error de pánico. Sólo debe utilizar at cuando desee "
"que el programa entre en pánico si el índice proporcionado está fuera de los "
"límites del array, lo que puede evitar comportamientos inesperados."

#: src/ch03-01-arrays.md:77
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""
"En resumen, usa `at` cuando quieras que el programa entre en pánico ante "
"intentos de acceso fuera de los límites, y usa `get` cuando prefieras "
"manejar estos casos con gracia sin entrar en pánico."

#: src/ch03-01-arrays.md:90
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""
"En este ejemplo, la variable llamada `first` obtendrá el valor `0` porque es "
"el valor del índice `0` del array. La variable llamada `second` obtendrá el "
"valor `1` del índice `1` del array."

#: src/ch03-01-arrays.md:94
msgid "Here is an example with the `get()` method:"
msgstr "He aquí un ejemplo con el método `get()`:"

#: src/ch03-01-arrays.md:101
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""

#: src/ch03-01-arrays.md:105
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap "
"operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
msgstr ""

#: src/ch03-01-arrays.md:117
msgid "Size related methods"
msgstr "Métodos Relacionados con el Tamaño"

#: src/ch03-01-arrays.md:113
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return is of type `usize`."
msgstr ""
"Para determinar el número de elementos de un array, utilice el método "
"`len()`. El valor devuelto es de tipo `usize`."

#: src/ch03-01-arrays.md:115
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""
"Si quieres comprobar si un array está vacío o no, puedes utilizar el método "
"`is_empty()`, que devuelve `true` si el array está vacío y `false` en caso "
"contrario."

#: src/ch03-01-arrays.md:117 src/ch11-02-macros.md:27
msgid "`array!` macro"
msgstr "`Array!` Macro"

#: src/ch03-01-arrays.md:119
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"A veces, necesitamos crear arrays con valores que ya se conocen en tiempo "
"de compilación. La forma básica de hacerlo es redundante. Primero declararías "
"el array y luego añadirías cada valor uno por uno. `array!` es una forma más "
"sencilla de realizar esta tarea al combinar los dos pasos. En tiempo de "
"compilación, el compilador expandirá la macro para generar el código que añade "
"los elementos de forma secuencial "

#: src/ch03-01-arrays.md:122 src/ch11-02-macros.md:10
msgid "Without `array!`:"
msgstr "Sin `array!`:"

#: src/ch03-01-arrays.md:133 src/ch11-02-macros.md:21
msgid "With `array!`:"
msgstr "Con `array!`:"

#: src/ch03-01-arrays.md:139
msgid "Storing multiple types with Enums"
msgstr "Almacenar Multiples Tipos con Enums"

#: src/ch03-01-arrays.md:141
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [Enums and Pattern Matching](ch06-00-"
"enums-and-pattern-matching.md) chapter."
msgstr ""
"Si deseas almacenar elementos de diferentes tipos en un array, puedes utilizar "
"un "Enum" para definir un tipo de datos personalizado que puede contener "
"múltiples tipos. Los Enums se explicarán con más detalle en el capítulo [Enums "
"and Pattern Matching](ch06-00-enums-and-pattern-matching.md)."

#: src/ch03-01-arrays.md:143
#, fuzzy
msgid "Span"
msgstr "Span"

#: src/ch03-01-arrays.md:145
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""
"`Span` es una estructura que representa una instantánea de un `Array`. Está "
"diseñada para proporcionar un acceso seguro y controlado a los elementos de "
"un array sin modificar el array original. Span es particularmente útil para "
"asegurar la integridad de los datos y evitar problemas de préstamo cuando se "
"pasan arrays entre funciones o cuando se realizan operaciones de sólo "
"lectura (cf. [References and Snapshots](ch03-02-references-and-snapshots.md))."

#: src/ch03-01-arrays.md:147
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr ""
"Todos los métodos proporcionados por `Array` también se pueden utilizar con "
"`Span`, a excepción del método `append()`."

#: src/ch03-01-arrays.md:149
msgid "Turning an Array into span"
msgstr "Convertir un Array en Span"

#: src/ch03-01-arrays.md:151
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "Para crear un `Span` de un `Array`, llama al método `span()`:"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"Cairo proporciona en su libreria principal un tipo de datos similar a un "
"diccionario. El tipo de datos Felt252Dict<T> representa una colección de pares "
"key-value donde cada key es única y está asociada con un value correspondiente. "
"Este tipo de estructura de datos se conoce de manera diferente en varios lenguajes "
"de programación, como mapas, tablas hash, arrays asociativos y muchos otros."

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"El tipo Felt252Dict<T> es útil cuando deseas organizar tus datos de una manera "
"específica para la cual el uso de un Array<T> e indexación no es suficiente. "
"Los diccionarios en Cairo también permiten al programador simular fácilmente "
"la existencia de memoria mutable cuando no la hay."

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "Uso Basico de Diccionarios"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252` leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"Es común en otros lenguajes especificar los tipos de datos tanto para la key "
"como para el value al crear un nuevo diccionario. En Cairo, el tipo de key está "
"restringido a `felt252`, lo que deja solo la posibilidad de especificar el tipo "
"de dato del value, representado por `T` en `Felt252Dict<T>`."


#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""
"La funcionalidad principal de un Felt252Dict<T> se implementa en el rasgo "
"`Felt252DictTrait`, que incluye todas las operaciones básicas. Entre ellas "
"podemos encontrar:"

#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "`insert(felt252, T) -> ()` para escribir valores en una instancia de diccionario."

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "`get(felt252) -> T` para leer sus valores."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""
"Estas funciones nos permiten manipular diccionarios como en cualquier otro lenguaje. "
"En el siguiente ejemplo, creamos un diccionario para representar una relación entre "
"individuos y sus saldos:"

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our "
"users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"Podemos crear una nueva instancia de `Felt252Dict<u64>` utilizando el método "
"`default` del rasgo `Default` y añadir dos individuos, cada uno con su propio "
"saldo, utilizando el método `insert`. Por último, comprobamos el saldo de "
"nuestros usuarios con el método `get`. Estos métodos están definidos en el trait "
"`Felt252DictTrait` de la librería principal."

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""
"A lo largo del libro, hemos hablado sobre cómo la memoria en Cairo es inmutable, "
"lo que significa que solo puedes escribir en una celda de memoria una vez, pero "
"el tipo Felt252Dict<T> representa una manera de superar este obstáculo. Explicaremos "
"cómo se implementa esto más adelante en [Dictionaries Underneath]"
"(#dictionaries-underneath)."

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""
"Basándonos en nuestro ejemplo anterior, vamos a mostrar un ejemplo de código "
"en el que cambia el saldo del mismo usuario:"

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr ""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the _Alex_ individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"¡Fíjate cómo en este ejemplo hemos añadido el individuo _Alex_ dos veces, "
"cada vez usando un saldo diferente y cada vez que comprobamos su saldo tenía "
"el último valor insertado! `Felt252Dict<T>` nos permite efectivamente \"reescribir\" "
"el valor almacenado para cualquier key dada."

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"Antes de seguir adelante y explicar cómo se implementan los diccionarios "
"vale la pena mencionar que una vez que instanciar un `Felt252Dict<T>`, detrás "
"de las escenas de todas las claves tienen sus valores asociados inicializado "
"como cero. Esto significa que si, por ejemplo, intentas obtener el saldo de un "
"usuario inexistente obtendrás 0 en lugar de un error o un valor indefinido. "
"Esto también significa que no hay forma de borrar datos de un diccionario. "
"Algo a tener en cuenta a la hora de incorporar esta estructura a tu código."

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
" Hasta este punto, hemos visto todas las características básicas de "
"`Felt252Dict<T>` y cómo imita el mismo comportamiento que las estructuras de "
"datos correspondientes en cualquier otro lenguaje, es decir, externamente, "
"por supuesto. Cairo es en su núcleo un lenguaje de programación Turing-completo "
"no determinista, muy diferente de cualquier otro lenguaje popular existente, "
"lo que como consecuencia significa que ¡los diccionarios se implementan también "
"de forma muy diferente!"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""
"En las siguientes secciones, vamos a dar algunas ideas sobre `Felt252Dict<T>` "
"mecanismos internos y los compromisos que se tomaron para que funcionen. Después "
"de eso, vamos a echar un vistazo a cómo utilizar los diccionarios con otras "
"estructuras de datos, así como utilizar el método `entry` como otra forma de "
"interactuar con ellos."

#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr "Diccionarios por Debajo"

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for reading/updating/"
"writing purposes. An entry has three fields:"
msgstr ""
"Una de las restricciones del diseño no determinista de Cairo es que su sistema "
"de memoria es inmutable, así que para simular la mutabilidad, el lenguaje implementa "
"`Felt252Dict<T>` como una lista de entradas. Cada una de las entradas representa un "
"momento en el que se accedió al diccionario para leer/actualizar/escribir. Una entrada "
"tiene tres campos:"

#: src/ch03-02-dictionaries.md:69
msgid ""
"A `key` field that identifies the value for this key-value pair of the dictionary."
msgstr ""
"Un campo `key` que identifica el valor para este par key-value del diccionario."

#: src/ch03-02-dictionaries.md:70
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""
"Un campo `previous_value` que indica qué valor anterior tenía `key`."

#: src/ch03-02-dictionaries.md:71
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr "Un campo `new_value` que indica el nuevo valor que se tiene en `key`."

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"Si intentamos implementar `Felt252Dict<T>` usando estructuras de alto nivel "
"lo definiríamos internamente como `Array<Entry<T>>` donde cada `Entry<T>` tiene "
"información sobre qué par key-value representa y los valores anteriores y "
"nuevos que contiene. La definición de `Entry<T>` sería:"

#: src/ch03-02-dictionaries.md:83
msgid ""
"For each time we interact with a `Felt252Dict<T>` a new `Entry<T>` will be "
"registered:"
msgstr ""
"Por cada vez que interactuemos con un `Felt252Dict<T>` se registrará una "
"nueva `Entrada<T>`:"

#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""
"Un `get` registraría una entrada en la que no hay cambio de estado, los "
"valores anteriores y nuevos se almacenan con el mismo valor."

#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"Un `insert` registraría una nueva `Entry<T>` donde el `new_value` sería "
"el elemento que se inserta, y el `previous_value` el último elemento insertado "
"antes de este. En caso de que sea la primera entrada para una determinada clave, "
"entonces el valor anterior será cero."

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"El uso de esta lista de entradas muestra cómo no hay ninguna reescritura, "
"sólo la creación de nuevas celdas de memoria por interacción `Felt252Dict<T>`. "
"Vamos a mostrar un ejemplo de esto usando el diccionario `balances` de la sección "
"anterior e insertando los usuarios `Alex` y `Maria`:"

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr "Estas instrucciones producirían la siguiente lista de entradas:"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146 src/ch03-02-dictionaries.md:147
msgid "0"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
msgid "100"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
msgid "50"
msgstr ""

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr ""

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"Observe que como 'Alex' se insertó dos veces, aparece dos veces y los "
"valores `previous` y `current` se establecen correctamente. También la "
"lectura de 'Maria' registró una entrada sin cambios de los valores "
"anteriores a los actuales."

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each read/"
"write operation, there is a scan for the whole entry list in search of the "
"last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"Este enfoque para implementar `Felt252Dict<T>` significa que para cada operación "
"de lectura/escritura, hay un escaneo de toda la lista de entradas en busca de la "
"última entrada con la misma `clave`. Una vez encontrada la entrada, se extrae su "
"`nuevo_valor` y se utiliza en la nueva entrada que se añade como `valor_anterior`. "
"Esto significa que interactuar con `Felt252Dict<T>` tiene una complejidad temporal "
"en el peor de los casos de `O(n)` donde `n` es el número de entradas de la lista."

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"Si te pones a pensar en formas alternativas de implementar `Felt252Dict<T>` seguramente "
"las encontrarás, probablemente incluso eliminando completamente la necesidad de un campo "
"`previous_value`, sin embargo, como Cairo no es un lenguaje normal esto no funcionará. "
"Uno de los propósitos de Cairo es, con el sistema de pruebas STARK, generar pruebas de "
"integridad computacional. Esto significa que necesitas verificar que la ejecución del "
"programa es correcta y dentro de los límites de las restricciones de Cairo. Una de esas "
"comprobaciones de límites consiste en "comprimir diccionarios" y eso requiere información "
"tanto de los valores anteriores como de los nuevos para cada entrada."

#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr "Comprimir Diccionarios"

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"Para verificar que la prueba generada por la ejecución de un programa Cairo que "
"utilizó un `Felt252Dict<T>` es correcta necesitamos comprobar que no hubo ninguna "
"manipulación ilegal del diccionario. Esto se hace mediante un método llamado "
"`squash_dict` que revisa cada entrada de la lista de entradas y comprueba que el "
"acceso al diccionario sigue siendo coherente durante toda la ejecución."

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"El proceso de comprimir es el siguiente: dadas todas las entradas con cierta clave `k`, "
"tomadas en el mismo orden en que fueron insertadas, verificar que la i-ésima entrada "
"`new_value` es igual a la i-th + 1 entrada `previous_value`."

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr "Por ejemplo, dada la siguiente lista de entradas:"

#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
msgid "150"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "70"
msgstr ""

#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138
msgid "250"
msgstr ""

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137
msgid "40"
msgstr ""

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
msgid "300"
msgstr ""

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "190"
msgstr ""

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:145
msgid "90"
msgstr ""

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr "Después de comprimir, la lista de entradas se reduciría a:"

#: src/ch03-02-dictionaries.md:149
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""
"En caso de un cambio en alguno de los valores de la primera tabla, la compresión "
"habría fallado durante la ejecución."

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr "Destrucción de Diccionarios"

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of Dictionaries](#basic-use-of-"
"dictionaries) you'd notice that there was never a call to squash dictionary, "
"but the program compiled successfully nonetheless. What happened behind the "
"scene was that squash was called automatically via the `Felt252Dict<T>` "
"implementation of the `Destruct<T>` trait. This call occurred just before "
"the `balance` dictionary went out of scope."
msgstr ""
"Pruebas los ejemplos de [Basic Use of Dictionaries](#basic-use-of-"
"dictionaries), notarás que nunca se hizo una llamada a para comprimir el diccionario, "
"pero el programa se compiló exitosamente de todos modos. Lo que ocurrió en segundo "
"plano es que la operación de compresión se llamó automáticamente mediante la "
"implementación de `Felt252Dict<T>` del rasgo `Destruct<T>`. Esta llamada ocurrió "
"justo antes de que el diccionario `balance` saliera del scope."

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-"
"destruct)."
msgstr ""
"El `Destruct<T>` representa otra forma de eliminar instancias fuera del scope "
"aparte de `Drop<T>`. La principal diferencia entre estos dos es que `Drop<T>` se "
"trata como una operación no-op, lo que significa que no genera nuevos CASM mientras "
"que `Destruct<T>` no tiene esta restricción. El único tipo que utiliza activamente "
"el rasgo `Destruct<T>` es `Felt252Dict<T>`, para cualquier otro tipo `Destruct<T>` "
"y `Drop<T>` son sinónimos. Puedes leer más sobre estos rasgos en [Drop and Destruct]"
"(/appendix-03-derivable-traits.md#drop-and-destruct)."

#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"we will have a hands-on example where we implement the `Destruct<T>` trait "
"for a custom type."
msgstr ""
"Más adelante en [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"tendremos un ejemplo práctico donde implementaremos el rasgo `Destruct<T>` para un "
"tipo personalizado."

#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr "Más Diccionarios"

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"Hasta este punto, hemos dado una visión general de la funcionalidad de `Felt252Dict<T>` "
"de cómo y por qué se implementa de una determinada manera. Si no lo has entendido todo, "
"no te preocupes porque en esta sección tendremos algunos ejemplos más utilizando "
"diccionarios."

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-complex-types) with other "
"complex types such as `Array<T>` and how to [implement](#dictionaries-as-"
"struct-members) a struct with a dictionary as a member."
msgstr ""
"Empezaremos explicando el método `entry` que forma parte de una funcionalidad "
"básica del diccionario incluida en `Felt252DictTrait<T>` que no mencionamos al "
"principio. Poco después, veremos ejemplos de cómo `Felt252Dict<T>` [interacts]"
"(#dictionaries-of-complex-types) con otros tipos complejos como `Array<T>` y cómo "
"[implement](#dictionaries-as-struct-members) una struct con un diccionario "
"como miembro."

#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr "Entrada y Finalización"

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""
"En la sección [Dictionaries Underneath](#diccionarios-debajo), explicamos "
"cómo funcionaba internamente `Felt252Dict<T>`. Era una lista de entradas cada "
"vez que se accedía al diccionario de cualquier manera. Primero encontraba la "
"última entrada dada una cierta `clave` y luego la actualizaba según la operación "
"que estuviera ejecutando. El lenguaje Cairo nos da las herramientas para replicar "
"esto nosotros mismos a través de los métodos `entry` y `finalize`."

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"El método `entry` viene como parte de `Felt252DictTrait<T>` con el propósito de "
"crear una nueva entrada dada una determinada clave. Una vez llamado, este método "
"toma posesión del diccionario y devuelve la entrada a actualizar. La característica "
"del método es la siguiente:"

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously."
msgstr ""
"El primer parámetro de entrada toma posesión del diccionario mientras que el segundo "
"se utiliza para crear la entrada apropiada. Devuelve una tupla que contiene una "
"`Felt252DictEntry<T>`, que es el tipo utilizado por Cairo para representar entradas de "
"diccionario, y una `T` que representa el valor mantenido anteriormente."

#: src/ch03-02-dictionaries.md:177
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""
"Lo siguiente que hay que hacer es actualizar la entrada con el nuevo valor. Para esto, "
"utilizamos el método `finalize` que inserta la entrada y devuelve la propiedad del diccionario:"

#: src/ch03-02-dictionaries.md:183
msgid ""
"This method receives the entry and the new value as a parameter and returns "
"the updated dictionary."
msgstr ""
"Este método recibe la entrada y el nuevo valor como parámetro, devolviendo el "
"diccionario actualizado."

#: src/ch03-02-dictionaries.md:185
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""
"Veamos un ejemplo utilizando `entry` y `finalize`. Imaginemos que queremos implementar nuestra "
"propia versión del método `get` de un diccionario. Deberíamos hacer lo siguiente:"

#: src/ch03-02-dictionaries.md:187
msgid "Create the new entry to add using the `entry` method"
msgstr "Crear la nueva entrada que deseamos agregar utilizando el método `entry`."

#: src/ch03-02-dictionaries.md:188
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr ""
"Insertar nuevamente la entrada donde el `new_value` sea igual al `previous_value`."

#: src/ch03-02-dictionaries.md:189
msgid "Return the value."
msgstr "Devolver el valor."

#: src/ch03-02-dictionaries.md:191
msgid "Implementing our custom get would look like this:"
msgstr "Implementar nuestra propia función get se vería así:"

#: src/ch03-02-dictionaries.md:199 src/ch03-02-dictionaries.md:248
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:202 src/ch03-02-dictionaries.md:251
msgid "// Store the value to return\n"
msgstr ""

#: src/ch03-02-dictionaries.md:205 src/ch03-02-dictionaries.md:254
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:208 src/ch03-02-dictionaries.md:257
msgid "// Return the read value\n"
msgstr ""

#: src/ch03-02-dictionaries.md:213
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""
"Implementar el método `insert` seguiría un flujo de trabajo similar, excepto "
"por la inserción de un nuevo valor al finalizar. Si lo implementáramos, tendría "
"el siguiente aspecto:"

#: src/ch03-02-dictionaries.md:227
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exists, _prev_value will\n"
"    // be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:232
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:238
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""
"Como nota final, estos dos métodos se implementan de manera similar a cómo "
"`insert` y `get` se implementan para `Felt252Dict<T>`. Este código muestra "
"algunos ejemplos de uso:"

#: src/ch03-02-dictionaries.md:270
msgid "// Get the last entry associated with `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:271
msgid "// Notice that if `key` does not exists, _prev_value will\n"
msgstr ""

#: src/ch03-02-dictionaries.md:272
msgid "// be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:275
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr ""

#: src/ch03-02-dictionaries.md:276
msgid "// and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:283 src/ch03-02-dictionaries.md:285
msgid "'0'"
msgstr ""

#: src/ch03-02-dictionaries.md:293
msgid "Dictionaries of types not supported natively"
msgstr "Tipos de Diccionarios No Soportados Nativamente"

#: src/ch03-02-dictionaries.md:295
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types "
"not natively supported is not a straightforward task, because you would need "
"to write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"Una restricción de `Felt252Dict<T>` de la que no hemos hablado es el rasgo "
"`Felt252DictValue<T>`. Este rasgo define el método `zero_default` que es el "
"que se llama cuando un valor no existe en el diccionario. Esto está implementado "
"para algunos tipos de datos comunes, como la mayoría de los enteros sin signo, "
"`bool` y `felt252` - pero no está implementado para tipos más complejos como "
"arrays, structs (incluyendo `u256`), y otros tipos de la librería principal. "
"Esto significa que hacer un diccionario de tipos no soportados nativamente no "
"es una tarea sencilla, porque necesitarías escribir un par de implementaciones "
"de rasgos para hacer del tipo de datos un tipo de valor de diccionario válido. "
"Para compensar esto, puedes envolver tu tipo dentro de un `Nullable<T>`."

#: src/ch03-02-dictionaries.md:301
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a "
"pointer that can only be manipulated in one place at a time."
msgstr ""
"`Nullable<T>` es un tipo de puntero inteligente que puede apuntar a un valor o "
"ser `null` en ausencia de valor. Suele utilizarse en Lenguajes de Programación "
"Orientados a Objetos cuando una referencia no apunta a ningún sitio. La diferencia "
"con `Option` es que el valor envuelto se almacena dentro de un tipo de datos "
"`Box<T>`. El tipo `Box<T>`, inspirado en Rust, nos permite asignar un nuevo segmento "
"de memoria para nuestro tipo, y acceder a este segmento utilizando un puntero que "
"sólo puede ser manipulado en un lugar a la vez."

#: src/ch03-02-dictionaries.md:303
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"Vamos a mostrarlo con un ejemplo. Intentaremos almacenar un `Span<felt252>` dentro "
"de un diccionario. Para ello utilizaremos `Nullable<T>` y `Box<T>`. Además, estamos "
"almacenando un `Span<T>` y no un `Array<T>` porque este último no implementa el rasgo "
"`Copy<T>` que es necesario para leer de un diccionario."

#: src/ch03-02-dictionaries.md:310 src/ch03-02-dictionaries.md:368
msgid "// Create the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:313 src/ch03-02-dictionaries.md:371
msgid "// Crate the array to insert\n"
msgstr ""

#: src/ch03-02-dictionaries.md:319 src/ch03-02-dictionaries.md:377
msgid "// Insert it as a `Span`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:321 src/ch03-02-dictionaries.md:336
msgid "//...\n"
msgstr ""

#: src/ch03-02-dictionaries.md:325
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"En este fragmento de código, lo primero que hicimos fue crear un nuevo "
"diccionario `d`. Queremos que contenga un  `Nullable<Span>`. Después, "
"creamos un array y lo llenamos de valores."

#: src/ch03-02-dictionaries.md:327
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we didn't do that directly, but instead, we took some steps in between:"
msgstr ""
"El último paso es insertar el array como un span dentro del diccionario. Fíjate "
"que no lo hemos hecho directamente, sino que hemos dado algunos pasos intermedios:"

#: src/ch03-02-dictionaries.md:329
msgid ""
"We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr ""
"Envolvimos el array dentro de un `Box` usando el método `new` de `BoxTrait`."

#: src/ch03-02-dictionaries.md:330
msgid ""
"We wrapped the `Box` inside a nullable using the `nullable_from_box` "
"function."
msgstr ""
"Envolvemos el `Box` dentro de un tipo nullable usando la función `nullable_from_box`."

#: src/ch03-02-dictionaries.md:331
msgid "Finally, we inserted the result."
msgstr "Por último, introducimos el resultado."

#: src/ch03-02-dictionaries.md:333
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""
"Una vez que el elemento está dentro del diccionario, y queremos obtenerlo, seguimos "
"los mismos pasos pero en orden inverso. El siguiente código muestra cómo conseguirlo:"

#: src/ch03-02-dictionaries.md:338 src/ch03-02-dictionaries.md:380
msgid "// Get value back\n"
msgstr ""

#: src/ch03-02-dictionaries.md:341 src/ch03-02-dictionaries.md:383
msgid "// Search the value and assert it is not null\n"
msgstr ""

#: src/ch03-02-dictionaries.md:347 src/ch03-02-dictionaries.md:389
msgid "// Verify we are having the right values\n"
msgstr ""

#: src/ch03-02-dictionaries.md:354
msgid "Here we:"
msgstr "Aquí tenemos:"

#: src/ch03-02-dictionaries.md:356
msgid "Read the value using `get`."
msgstr "Lee el valor utilizando `get`."

#: src/ch03-02-dictionaries.md:357
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "Verificado que no es nulo usando la función `match_nullable`."

#: src/ch03-02-dictionaries.md:358
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "Desenvolvió el valor dentro de la caja y afirmó que era correcto."

#: src/ch03-02-dictionaries.md:360
msgid "The complete script would look like this:"
msgstr "El script completo tendría este aspecto:"

#: src/ch03-02-dictionaries.md:397
msgid "Dictionaries as Struct Members"
msgstr "Diccionarios como Miembros del Struct"

#: src/ch03-02-dictionaries.md:399
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""
"Definir diccionarios como miembros de struct es posible en Cairo, pero interactuar "
"correctamente con ellos puede no ser del todo fluido. Intentemos implementar una "
"_user database_ personalizada que nos permita añadir usuarios y consultarlos. "
"Necesitaremos definir un struct para representar el nuevo tipo y un trait para "
"definir su funcionalidad:"

#: src/ch03-02-dictionaries.md:414
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""
"Nuestro nuevo tipo `UserDatabase<T>` representa una base de datos de usuarios. "
"Es genérico sobre los saldos de los usuarios, dando mayor flexibilidad a quien "
"utilice nuestro tipo de datos. Sus dos miembros son:"

#: src/ch03-02-dictionaries.md:416
msgid "`users_amount`, the number of users currently inserted and"
msgstr "`users_amount`, el número de usuarios insertados actualmente."

#: src/ch03-02-dictionaries.md:417
msgid "`balances`, a mapping of each user to its balance."
msgstr "`balances`, una asignación de cada usuario a su balance."

#: src/ch03-02-dictionaries.md:419
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""
"La funcionalidad central de la base de datos está definida por `UserDatabaseTrait`. "
"Donde se definen los siguientes métodos:"

#: src/ch03-02-dictionaries.md:421
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "`new` para crear fácilmente nuevos tipos de `UserDatabase`."

#: src/ch03-02-dictionaries.md:422
msgid "`add_user` to insert users in the database."
msgstr "`add_user` para insertar usuarios en la base de datos."

#: src/ch03-02-dictionaries.md:423
msgid "`get_balance` to find user's balance in the database."
msgstr "`get_balance` para encontrar el saldo del usuario en la base de datos."

#: src/ch03-02-dictionaries.md:425
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [generic types](/src/"
"ch08-00-generic-types-and-traits.md) we also need to correctly establish the "
"requirements of `T` so it can be a valid `Felt252Dict<T>` value type:"
msgstr ""
"El único paso restante es implementar cada uno de los métodos en `UserDatabaseTrait`, "
"pero como estamos trabajando con [generic types](/src/ch08-00-generic-types-and-traits.md) "
"también necesitamos establecer correctamente los requisitos de `T` para que pueda ser un "
"tipo de valor `Felt252Dict<T>` válido:"

#: src/ch03-02-dictionaries.md:427
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""
"`T` debería implementar el `Copy<T>` ya que es necesario para obtener valores "
"de un `Felt252Dict<T>`."

#: src/ch03-02-dictionaries.md:428
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""
"Todos los tipos de valor de un diccionario implementan el `Felt252DictValue<T>`, "
"nuestro tipo genérico debería hacerlo también."

#: src/ch03-02-dictionaries.md:429
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"destructible."
msgstr ""
"Para insertar valores, `Felt252DictTrait<T>` requiere que todos los tipos "
"de valores sean destructibles."

#: src/ch03-02-dictionaries.md:431
msgid "The implementation, with all restriction in place, would be as follow:"
msgstr "La implementación, con todas las restricciones, sería la siguiente:"

#: src/ch03-02-dictionaries.md:437 src/ch03-02-dictionaries.md:484
msgid "// Creates a database\n"
msgstr ""

#: src/ch03-02-dictionaries.md:442 src/ch03-02-dictionaries.md:489
msgid "// Get the user's balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:447 src/ch03-02-dictionaries.md:494
msgid "// Add a user\n"
msgstr ""

#: src/ch03-02-dictionaries.md:455
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [genericity](/src/ch08-00-"
"generic-types-and-traits.md) in the struct definition. We need to code the "
"`Destruct<T>` trait implementation by ourselves:"
msgstr ""
"Nuestra implementación de la base de datos está casi completa, excepto por una "
"cosa: el compilador no sabe cómo hacer que una `UserDatabase<T>` salga de ámbito, "
"ya que no implementa el rasgo `Drop<T>`, ni el rasgo `Destruct<T>`. Como tiene un "
"`Felt252Dict<T>` como miembro, no se puede soltar, así que nos vemos obligados a "
"implementar el rasgo `Destruct<T>` manualmente (consulta el capítulo [Ownership]"
"(ch04-01-what-is-ownership.md#the-drop-trait) para más información). Utilizar "
"`#[derive(Destruct)]` sobre la definición de `UserDatabase<T>` no funcionará debido "
"al uso de [genericity](/src/ch08-00-generic-types-and-traits.md) en la definición de "
"la estructura. Necesitamos implementar manualmente el rasgo `Destruct<T>`."

#: src/ch03-02-dictionaries.md:469
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""
"Implementar `Destruct<T>` para `UserDatabase` fue nuestro último paso para "
"conseguir una base de datos completamente funcional. Ahora podemos probarla:"

#: src/ch03-02-dictionaries.md:530
msgid ""
"Well done! You finished this chapter on arrays and dictionaries in Cairo. "
"These data structures may be a bit challenging to grasp, but they are really "
"useful."
msgstr ""
"¡Bien hecho! Has terminado este capítulo sobre array y diccionarios en Cairo. "
"Estas estructuras de datos pueden ser un poco difíciles de entender, pero son "
"realmente útiles."

#: src/ch03-02-dictionaries.md:532
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that _doesn’t_ commonly exist in other programming languages: "
"ownership."
msgstr ""
"Cuando estés listo para continuar, hablaremos de un concepto que Cairo "
"comparte con Rust y que _no_ existe comúnmente en otros lenguajes de programación: "
"Ownership."

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize "
"that arrays have one big limitation - the data stored in them is immutable. "
"Once you append a value to an array, you can't modify it."
msgstr ""
"Cuando empieces a programar en Cairo, probablemente querrás usar arrays (`Array<T>`) "
"para almacenar colecciones de datos. Sin embargo, rápidamente te darás cuenta de que "
"los arrays tienen una gran limitación - los datos almacenados en ellos son inmutables. "
"Una vez que añades un valor a un array, no puedes modificarlo."

#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"Esto puede resultar frustrante cuando se desea utilizar una estructura de datos mutable. "
"Por ejemplo, digamos que estás haciendo un juego donde los jugadores tienen un nivel, y "
"pueden subir de nivel. Podrías intentar almacenar el nivel de los jugadores en un array:"

#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""
"Pero entonces te das cuenta de que no puedes aumentar el nivel en un índice específico "
"una vez que está fijado. Si un jugador muere, no puedes eliminarlo de la matriz a menos "
"que casualmente esté en la primera posición."

#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary type](./ch03-02-"
"dictionaries.md) called `Felt252Dict<T>` that allows us to simulate the "
"behavior of mutable data structures. Let's first explore how to use it to "
"create a dynamic array implementation."
msgstr ""
"Afortunadamente, Cairo proporciona una útil funcionalidad integrada [dictionary type]"
"(./ch03-02-dictionaries.md) llamado `Felt252Dict<T>` que nos permite simular el "
"comportamiento de estructuras de datos mutables. Exploremos primero cómo usarlo "
"para crear una implementación de array dinámico."

#: src/ch03-03-custom-data-structures.md:28
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of "
"the book. We recommend you to check out the following chapter first: "
"[Structs](ch05-00-using-structs-to-structure-related-data), [Methods](./"
"ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-types-and-"
"traits.md), [Traits](./ch08-02-traits-in-cairo.md)"
msgstr ""
"Nota: Varios conceptos utilizados en este capítulo se presentan en partes posteriores "
"del libro. Le recomendamos que consulte primero el capítulo siguiente: [Structs]"
"(ch05-00-using-structs-to-structure-related-data), [Methods](./ch05-03-method-syntax.md), "
"[Generic types](./ch08-00-generic-types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."

#: src/ch03-03-custom-data-structures.md:35
msgid "Simulating a dynamic array with dicts"
msgstr "Simular un Array Dinámico con Dicts"

#: src/ch03-03-custom-data-structures.md:37
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""
"En primer lugar, pensemos en cómo queremos que se comporte nuestro array dinámico mutable. "
"¿Qué operaciones debería soportar?"

#: src/ch03-03-custom-data-structures.md:40
msgid "It should:"
msgstr "Deberia:"

#: src/ch03-03-custom-data-structures.md:42
msgid "Allow us to append items at the end"
msgstr "Permitirnos añadir elementos al final."

#: src/ch03-03-custom-data-structures.md:43
msgid "Let us access any item by index"
msgstr "Permitir el acceso a cualquier elemento por índice."

#: src/ch03-03-custom-data-structures.md:44
msgid "Allow setting the value of an item at a specific index"
msgstr "Permitir establecer el valor de un elemento en un índice específico."

#: src/ch03-03-custom-data-structures.md:45
msgid "Return the current length"
msgstr "Devolver la longitud actual."

#: src/ch03-03-custom-data-structures.md:47
msgid "We can define this interface in Cairo like:"
msgstr "Podemos definir esta interfaz en Cairo como:"

#: src/ch03-03-custom-data-structures.md:60
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it Vec as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"Esto proporciona un modelo para la implementación de nuestra array dinámica. "
"Lo llamamos Vec porque es similar a la estructura de datos `Vec<T>` de Rust."

#: src/ch03-03-custom-data-structures.md:63
msgid "Implementing a dynamic array in Cairo"
msgstr "Implementar un Array Dinámico en Cairo"

#: src/ch03-03-custom-data-structures.md:65
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"Para almacenar nuestros datos, utilizaremos un `Felt252Dict<T>` que asigna números "
"de índice (felts) a valores. También almacenaremos un campo `len` separado para rastrear la longitud."

#: src/ch03-03-custom-data-structures.md:68
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"Este es el aspecto de nuestra estructura. Envolvemos el tipo `T` dentro del puntero `Nullable` "
"para permitir el uso de cualquier tipo `T` en nuestra estructura de datos, como se explica en "
"la sección [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively):"

#: src/ch03-03-custom-data-structures.md:80
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""
"La clave que hace que este vector sea mutable es que podemos insertar valores en el diccionario "
"para establecer o actualizar valores en nuestra estructura de datos. Por ejemplo, para actualizar "
"un valor en un índice específico, hacemos:"

#: src/ch03-03-custom-data-structures.md:91
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr ""
"Esto sobrescribe el valor existente anteriormente en ese índice del "
"diccionario."

#: src/ch03-03-custom-data-structures.md:93
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for "
"modifiable data structures like vectors."
msgstr ""
"Mientras que las arrays son inmutables, los diccionarios proporcionan la flexibilidad "
"que necesitamos para las estructuras de datos modificables, como los vectores."

#: src/ch03-03-custom-data-structures.md:96
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""
"La implementación del resto de la interfaz es sencilla. La implementación de "
"todos los métodos definidos en nuestra interfaz se puede hacer de la siguiente manera:"

#: src/ch03-03-custom-data-structures.md:133
msgid ""
"The full implementation of the `Vec` structure can be found in the community-"
"maintained library [Alexandria](https://github.com/keep-starknet-strange/"
"alexandria/tree/main/src/data_structures)."
msgstr ""
"La implementación completa de la estructura `Vec` puede encontrarse en la libreria "
"mantenida por la comunidad."

#: src/ch03-03-custom-data-structures.md:137
msgid "Simulating a Stack with dicts"
msgstr "Simular un Stack con Dicts"

#: src/ch03-03-custom-data-structures.md:139
msgid ""
"We will now look at a second example and its implementation details: a Stack."
msgstr ""
"A continuación veremos un segundo ejemplo y sus detalles de implementación: un Stack."

#: src/ch03-03-custom-data-structures.md:141
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"Un Stack es una colección LIFO (último en entrar, primero en salir). La inserción de un "
"nuevo elemento y la eliminación de un elemento existente tiene lugar en el mismo extremo, "
"representado como la parte superior de la pila."

#: src/ch03-03-custom-data-structures.md:145
msgid "Let us define what operations we need to create a stack :"
msgstr "Definamos qué operaciones necesitamos para crear una stack:"

#: src/ch03-03-custom-data-structures.md:147
msgid "Push an item to the top of the stack"
msgstr "Push un elemento a la parte superior de la stack."

#: src/ch03-03-custom-data-structures.md:148
msgid "Pop an item from the top of the stack"
msgstr "Pop un elemento de la parte superior de la stack."

#: src/ch03-03-custom-data-structures.md:149
msgid "Check whether there are still any elements in the stack."
msgstr "Check si todavía hay elementos en la stack."

#: src/ch03-03-custom-data-structures.md:151
msgid "From these specifications we can define the following interface :"
msgstr "A partir de estas especificaciones podemos definir la siguiente interfaz:"

#: src/ch03-03-custom-data-structures.md:161
msgid "Implementing a Mutable Stack in Cairo"
msgstr "Implementar un Stack Mutable en Cairo"

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field "
"to keep track of the length of the stack to iterate over it."
msgstr ""
"Para crear una estructura de datos de stack en Cairo, podemos utilizar de nuevo un "
"`Felt252Dict<T>` para almacenar los valores de la pila junto con un campo `usize` para "
"llevar la cuenta de la longitud de la stack para iterar sobre ella."

#: src/ch03-03-custom-data-structures.md:167
msgid "The Stack struct is defined as:"
msgstr "La estructura Stack se define como:"

#: src/ch03-03-custom-data-structures.md:176
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr "A continuación, veamos cómo se implementan nuestras funciones principales `push` y `pop`."

#: src/ch03-03-custom-data-structures.md:201
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element at the top of the stack, the `push` "
"function inserts the element in the dict at index `len` - and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function retrieves the last value at position "
"`len-1` and then decreases the value of `len` to update the position of the "
"stack top accordingly."
msgstr ""
"El código utiliza los métodos `insert` y `get` para acceder a los valores del `Felt252Dict<T>`. "
"Para empujar un elemento a la parte superior del stack, la función `push` inserta el elemento en "
"el dict en el índice `len` - y aumenta el campo `len` del stack para mantener la pista de la posición "
"de la parte superior del stack. Para eliminar un valor, la función `pop` recupera el último valor en "
"la posición `len-1` y luego disminuye el valor de `len` para actualizar la posición de la parte superior "
"del stack en consecuencia."

#: src/ch03-03-custom-data-structures.md:209
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/"
"src/data_structures) library, in the \"data_structures\" crate."
msgstr ""
"La implementación completa del stack, junto con otras estructuras de datos que puedes utilizar en tu código, "
"se encuentra en la libreria mantenida por la comunidad [Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/"
"src/data_structures), en el paquete  \"data_structures\"."

#: src/ch03-03-custom-data-structures.md:216
msgid ""
"While Cairo's memory model is immutable and can make it difficult to "
"implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to "
"implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"Aunque el modelo de memoria de Cairo es inmutable y puede dificultar la implementación de estructuras de datos "
"mutables, afortunadamente podemos utilizar el tipo `Felt252Dict<T>` para simular estructuras de datos mutables. "
"Esto nos permite implementar una amplia gama de estructuras de datos que son útiles para muchas aplicaciones, "
"ocultando eficazmente la complejidad del modelo de memoria subyacente."

#: src/ch04-00-understanding-ownership.md:1
#, fuzzy
msgid "Understanding Cairo's Ownership system"
msgstr "# Entendiendo el Ownership de Cairo"

#: src/ch04-00-understanding-ownership.md:3
#, fuzzy
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"Cairo es un lenguaje construido alrededor de un sistema de tipos lineales "
"que \n"
"nos permite asegurarnos estáticamente de que en cada programa de Cairo, un "
"valor se utiliza exactamente una vez. \n"
"Este sistema de tipos lineales ayuda a prevenir errores en tiempo de "
"ejecución asegurando que las operaciones que podrían causar dichos errores, "
"como escribir dos veces en una celda de memoria, se detecten en tiempo de "
"compilación. \n"
"Esto se logra implementando un Ownership y prohibiendo la copia y "
"eliminación \n"
"de valores por defecto. En este capítulo, hablaremos sobre el Ownership de "
"Cairo, así como \n"
"sobre las referencias y snapshots."

#: src/ch04-01-what-is-ownership.md:1
#, fuzzy
msgid "What Is Ownership?"
msgstr "¿Qué es Ownership?"

#: src/ch04-01-what-is-ownership.md:3
#, fuzzy
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of "
"its compiled code. The ownership mechanism complements the linear type "
"system, which enforces that objects are used exactly once. This helps "
"prevent common operations that can produce runtime errors, such as illegal "
"memory address references or multiple writes to the same memory address, and "
"ensures the soundness of Cairo programs by checking at compile time that all "
"the dictionaries are squashed."
msgstr ""
"Cairo implementa un sistema de propiedad para garantizar la seguridad y "
"corrección de su código compilado. \n"
"El mecanismo de propiedad complementa el sistema de tipos lineales, que "
"obliga a que los objetos se usen exactamente una vez. \n"
"Esto ayuda a prevenir operaciones comunes que pueden producir errores en "
"tiempo de ejecución, como referencias ilegales de direcciones\n"
" de memoria o múltiples escrituras en la misma dirección de memoria, y "
"garantiza la corrección de los programas de Cairo comprobando \n"
"en tiempo de compilación que todos los diccionarios están aplastados."

#: src/ch04-01-what-is-ownership.md:9
#, fuzzy
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a `main` function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""
"Ahora que hemos pasado la sintaxis básica de Cairo, no incluiremos todo el "
"código\n"
" `fn main() {` en los ejemplos, así que si estás siguiendo, asegúrate de "
"colocar los siguientes \n"
"ejemplos dentro de una función `main` manualmente. Como resultado, nuestros "
"ejemplos\n"
" serán un poco más concisos, lo que nos permitirá enfocarnos en los detalles "
"reales en lugar \n"
"del código de plantilla."

#: src/ch04-01-what-is-ownership.md:15
#, fuzzy
msgid "Ownership Rules"
msgstr "### Reglas de Ownership"

#: src/ch04-01-what-is-ownership.md:17
#, fuzzy
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as "
"we work through the examples that illustrate them:"
msgstr ""
"En primer lugar, echemos un vistazo a las reglas de propiedad. Mantenga "
"estas \n"
"reglas en mente mientras trabajamos a través de los ejemplos que las "
"ilustran:"

#: src/ch04-01-what-is-ownership.md:20
msgid "Each value in Cairo has an _owner_."
msgstr ""

#: src/ch04-01-what-is-ownership.md:21
msgid "There can only be one owner at a time."
msgstr ""

#: src/ch04-01-what-is-ownership.md:22
#, fuzzy
msgid "When the owner goes out of scope, the value will be _dropped_."
msgstr ""
"- Cada valor en Cairo tiene un _propietario_.\n"
"- Solo puede haber un propietario a la vez.\n"
"- Cuando el propietario sale del ámbito, el valor será _descartado_."

#: src/ch04-01-what-is-ownership.md:24
#, fuzzy
msgid "Variable Scope"
msgstr "### Ámbito de Variables"

#: src/ch04-01-what-is-ownership.md:26
#, fuzzy
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some "
"variables. A scope is the range within a program for which an item is valid. "
"Take the following variable:"
msgstr ""
"Como primer ejemplo de propiedad, veremos el _ámbito_ de algunas "
"variables. \n"
"Un ámbito es el alcance dentro de un programa para el cual un elemento es "
"válido. \n"
"Tomemos la siguiente variable:"

#: src/ch04-01-what-is-ownership.md:34
#, fuzzy
msgid ""
"The variable `s` refers to a short string, where the value of the string is "
"hardcoded into the text of our program. The variable is valid from the point "
"at which it’s declared until the end of the current _scope_. Listing 4-1 "
"shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr ""
"La variable `s` hace referencia a una cadena corta, donde el valor de la "
"cadena \n"
"está codificado en el texto de nuestro programa. La variable es válida desde "
"el\n"
" momento en que se declara hasta el final del _ámbito_ actual. La Lista 3-1 "
"muestra \n"
"un programa con comentarios que anotan dónde sería válida la variable `s`."

#: src/ch04-01-what-is-ownership.md:40
msgid "//TAG: ignore_fmt\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:42
msgid "// s is not valid here, it’s not yet declared\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:43
msgid "// s is valid from this point forward\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:45
msgid "// do stuff with s\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:46
msgid "// this scope is now over, and s is no longer valid\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:50
#, fuzzy
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr ""
"<span class=\"caption\">Lista 3-1: Una variable y el ámbito en el que es "
"válida</span>"

#: src/ch04-01-what-is-ownership.md:53
msgid "In other words, there are two important points in time here:"
msgstr "En otras palabras, hay dos puntos importantes en el tiempo aquí:"

#: src/ch04-01-what-is-ownership.md:55
#, fuzzy
msgid "When `s` comes _into_ scope, it is valid."
msgstr ""
"- Cuando `s` entra en el _ámbito_, es válida.\n"
"- Permanece válida hasta que sale del _ámbito_."

#: src/ch04-01-what-is-ownership.md:56
#, fuzzy
msgid "It remains valid until it goes _out of_ scope."
msgstr ""
"- Cuando `s` entra en el _ámbito_, es válida.\n"
"- Permanece válida hasta que sale del _ámbito_."

#: src/ch04-01-what-is-ownership.md:58
#, fuzzy
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the [previous "
"chapter](./ch03-01-arrays.md)."
msgstr ""
"En este punto, la relación entre los ámbitos y cuándo las variables son "
"válidas es \n"
"similar a la de otros lenguajes de programación. Ahora nos basaremos en "
"este\n"
"utilizando el tipo `Array` que introdujimos en el [capítulo anterior]"
"(ch02-06-common-collections.md)."

#: src/ch04-01-what-is-ownership.md:62
#, fuzzy
msgid "Ownership with the `Array` Type"
msgstr "### Ownership con el tipo `Array"

#: src/ch04-01-what-is-ownership.md:64
msgid ""
"To illustrate the rules of ownership, we need a data type that is more "
"complex. The types covered in the [Data Types](ch02-02-data-types.html#data-"
"types)"
msgstr ""

#: src/ch04-01-what-is-ownership.md:65
#, fuzzy
msgid ""
" section of Chapter 2 are of a known size, can be quickly and trivially "
"copied to make a new, independent instance if another part of code needs to "
"use the same value in a different scope, and can easily be dropped when "
"they're no longer used. But what is the behavior with the `Array` type whose "
"size is unknown at compile time and which can't be trivially copied?"
msgstr ""
"Para ilustrar las reglas de propiedad, necesitamos un tipo de datos más "
"complejo. \n"
"Los tipos cubiertos en la sección [\"Tipos de datos\"][data-types]<!-- "
"ignore -->section\n"
"el Capítulo 2 son de un tamaño conocido, pueden ser copiados rápidamente y "
"trivialmente para crear una nueva instancia independiente si otra \n"
"parte del código necesita usar el mismo valor en un ámbito diferente, y "
"pueden ser fácilmente\n"
"eliminados cuando ya no se usan. Pero, ¿cuál es el comportamiento con el "
"tipo `Array`, cuyo tamaño\n"
"es desconocido en tiempo de compilación y no puede ser copiado trivialmente?"

#: src/ch04-01-what-is-ownership.md:72
msgid "Here is a short reminder of what an array looks like:"
msgstr "Aquí tienes un breve recordatorio de cómo es un array:"

#: src/ch04-01-what-is-ownership.md:82
#, fuzzy
msgid ""
"So, how does the ownership system ensure that each cell is never written to "
"more than once? Consider the following code, where we try to pass the same "
"instance of an array in two consecutive function calls:"
msgstr ""
"Entonces, ¿cómo garantiza el sistema de propiedad que nunca se escriba en "
"cada celda más de una vez?\n"
"Consideremos el siguiente código, en el que intentamos pasar la misma "
"instancia de un array en dos llamadas consecutivas a la función\n"
"consecutivas:"

#: src/ch04-01-what-is-ownership.md:99
#, fuzzy
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the "
"functions `foo` and `bar`, which means that the parameter used in both "
"function calls is the same instance of the array. If you append a value to "
"the array in `foo`, and then try to append another value to the same array "
"in `bar`, what would happen is that you would attempt to try to write to the "
"same memory cell twice, which is not allowed in Cairo. To prevent this, the "
"ownership of the `arr` variable moves from the `main` function to the `foo` "
"function. When trying to call `bar` with `arr` as a parameter, the ownership "
"of `arr` was already moved to the first call. The ownership system thus "
"prevents us from using the same instance of `arr` in `foo`."
msgstr ""
"En este caso, intentamos pasar la misma instancia de matriz `arr` por valor "
"a las funciones `foo` y `bar`, lo que significa \n"
"que el parámetro utilizado en ambas llamadas de función es la misma "
"instancia de la matriz. Si agrega un valor a la matriz e\n"
"n `foo` y luego intenta agregar otro valor a la misma matriz en `bar`, lo "
"que sucederá es que intentará escribir en la misma celda de memoria dos "
"veces, lo que no está permitido en Cairo.\n"
"Para evitar esto, la propiedad de la variable `arr` se mueve de la función "
"`main` a la función `foo`. Cuando se intenta llamar a \n"
"`bar` con `arr` como parámetro, la propiedad de `arr` ya se movió a la "
"primera llamada. El sistema de propiedad nos impide usar \n"
"la misma instancia de `arr` en `foo`."

#: src/ch04-01-what-is-ownership.md:107
msgid "Running the code above will result in a compile-time error:"
msgstr ""
"Ejecutar el código anterior resultará en un error en tiempo de compilación:"

#: src/ch04-01-what-is-ownership.md:116
#, fuzzy
msgid "The `Copy` Trait"
msgstr "### El Trait `Copy`"

#: src/ch04-01-what-is-ownership.md:118
#, fuzzy
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not "
"move the ownership of the value to the function called, but will instead "
"pass a copy of the value. You can implement the `Copy` trait on your type by "
"adding the `#[derive(Copy)]` annotation to your type definition. However, "
"Cairo won't allow a type to be annotated with Copy if the type itself or any "
"of its components don't implement the Copy trait. While Arrays and "
"Dictionaries can't be copied, custom types that don't contain either of them "
"can be."
msgstr ""
"Si un tipo implementa el trait `Copy`, pasar su valor a una función no "
"moverá la propiedad del valor a la función llamada, sino que pasará una "
"copia del valor.\n"
"Puedes implementar el trait `Copy` en tu tipo agregando la anotación "
"`#[derive(Copy)]` a la definición de tu tipo. Sin embargo, Cairo no "
"permitirá que un tipo sea anotado con `Copy` si el tipo en sí mismo o "
"cualquiera de sus componentes no implementan el trait `Copy`.\n"
"Mientras que los Arrays y Diccionarios no pueden ser copiados, los tipos "
"personalizados que no los contienen sí pueden serlo."

#: src/ch04-01-what-is-ownership.md:135
msgid "// do something with p\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:139
#, fuzzy
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, and the ownership of `p1` "
"remains with the main function. If you remove the `Copy` trait derivation "
"from the `Point` type, you will get a compile-time error when trying to "
"compile the code."
msgstr ""
"En este ejemplo, podemos pasar `p1` dos veces a la función `foo` porque el "
"tipo `Point` implementa el trait `Copy`. Esto significa que cuando pasamos "
"`p1` a `foo`, en realidad estamos pasando una copia de `p1`, y la propiedad "
"de `p1` permanece en la función principal.\n"
"Si eliminamos la derivación del trait `Copy` del tipo `Point`, obtendremos "
"un error en tiempo de compilación al intentar compilar el código."

#: src/ch04-01-what-is-ownership.md:142
#, fuzzy
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"_No te preocupes por la palabra clave `Struct`. La introduciremos en el "
"[Capítulo 4](ch04-00-using-structs-to-structure-related-data.md)._"

#: src/ch04-01-what-is-ownership.md:144
#, fuzzy
msgid "The `Drop` Trait"
msgstr "### El Trait `Drop`"

#: src/ch04-01-what-is-ownership.md:146
#, fuzzy
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. In Cairo, a value cannot go out of scope unless "
"it has been previously moved. For example, the following code will not "
"compile, because the struct `A` is not moved before it goes out of scope:"
msgstr ""
"Es posible que hayas notado que el tipo `Point` en el ejemplo anterior "
"también implementa el trait `Drop`. En Cairo, un valor no puede salir del "
"ámbito a menos que se haya movido previamente.\n"
"Por ejemplo, el siguiente código no se compilará porque la estructura `A` no "
"se mueve antes de que salga del ámbito:"

#: src/ch04-01-what-is-ownership.md:153
msgid "// error: Value not dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:157
#, fuzzy
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the "
"fact that if a statement during the execution of the program is false, no "
"cheating prover can convince an honest verifier that it is true. In our "
"case, we want to ensure the consistency of consecutive dictionary key "
"updates during program execution, which is only checked when the "
"dictionaries are `squashed` - which moves the ownership of the dictionary to "
"the `squash` method, thus allowing the dictionary to go out of scope. "
"Unsquashed dictionaries are dangerous, as a malicious prover could prove the "
"correctness of inconsistent updates."
msgstr ""
"Con ello se pretende garantizar la solidez de los programas de Cairo. La "
"solidez se refiere al hecho de que si una\n"
"durante la ejecución del programa es falsa, ningún probador tramposo puede "
"convencer a un verificador honesto de que es verdadera.\n"
"verificador honesto de que es verdadera. En nuestro caso, queremos "
"garantizar la coherencia de\n"
"actualizaciones consecutivas de las claves del diccionario durante la "
"ejecución del programa, que sólo se comprueba cuando\n"
"los diccionarios son `squashed` - que mueve la propiedad del diccionario al "
"método\n"
"`squash`, lo que permite que el diccionario salga del ámbito. Los "
"diccionarios Unsquashed\n"
"son peligrosos, ya que un prover malicioso podría probar la corrección de "
"actualizaciones inconsistentes."

#: src/ch04-01-what-is-ownership.md:165
#, fuzzy
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of "
"scope without being explicitly moved. When a value of a type that implements "
"the `Drop` trait goes out of scope, the `Drop` implementation is called on "
"the type, which moves the value to the `drop` function, allowing it to go "
"out of scope - This is what we call \"dropping\" a value. It is important to "
"note that the implementation of drop is a \"no-op\", meaning that it doesn't "
"perform any actions other than allowing the value to go out of scope."
msgstr ""
"Sin embargo, los tipos que implementan el trait `Drop` se permiten que "
"salgan de ámbito sin ser movidos explícitamente. Cuando un valor de un tipo "
"que implementa el trait `Drop` sale de ámbito, se llama a la implementación "
"`Drop` en el tipo, lo que mueve el valor a la función `drop`, permitiendo "
"que salga de ámbito: esto es lo que llamamos \"eliminar\" un valor. \n"
"Es importante tener en cuenta que la implementación de `Drop` es una "
"\"operación nula\", lo que significa que no realiza ninguna acción aparte de "
"permitir que el valor salga de ámbito."

#: src/ch04-01-what-is-ownership.md:168
#, fuzzy
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be "
"dropped when going out of scope, except for dictionaries (`Felt252Dict`) and "
"types containing dictionaries. For example, the following code compiles:"
msgstr ""
"La implementación `Drop` puede ser derivada para todos los tipos, "
"permitiéndoles ser descartados cuando salen del ámbito, excepto para los "
"diccionarios (`Felt252Dict`) y los tipos que contienen diccionarios.\n"
"Por ejemplo, el siguiente código compila:"

#: src/ch04-01-what-is-ownership.md:176
msgid "// Now there is no error.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:180
#, fuzzy
msgid "The `Destruct` Trait"
msgstr "### El Trait `Destruct`"

#: src/ch04-01-what-is-ownership.md:182
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, "
"and it is easy to forget to do so. To make it easier to use dictionaries, "
"Cairo provides the `Destruct` trait, which allows you to specify the "
"behavior of a type when it goes out of scope. While Dictionaries don't "
"implement the `Drop` trait, they do implement the `Destruct` trait, which "
"allows them to automatically be `squashed` when they go out of scope. This "
"means that you can use dictionaries without having to manually call the "
"`squash` method."
msgstr ""
"Llamar manualmente al método `squash` en un diccionario no es muy "
"conveniente y es fácil de olvidar hacerlo. Para facilitar el uso de los "
"diccionarios, Cairo proporciona el trait `Destruct`, que te permite "
"especificar el comportamiento de un tipo cuando sale del ámbito. Si bien los "
"diccionarios no implementan el trait `Drop`, sí implementan el trait "
"`Destruct`, lo que les permite ser `aplastados` automáticamente cuando salen "
"del ámbito. Esto significa que puedes usar diccionarios sin tener que llamar "
"manualmente al método `squash`."

#: src/ch04-01-what-is-ownership.md:184
msgid ""
"Consider the following example, in which we define a custom type that "
"contains a dictionary:"
msgstr ""
"Considera el siguiente ejemplo, en el que definimos un tipo personalizado "
"que contiene un diccionario:"

#: src/ch04-01-what-is-ownership.md:197
msgid "If you try to run this code, you will get a compile-time error:"
msgstr ""
"Si intenta ejecutar este código, obtendrá un error de tiempo de compilación:"

#: src/ch04-01-what-is-ownership.md:206
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"Cuando `A` sale del alcance, no puede ser liberado ya que no implementa ni "
"el `Drop` (ya que contiene un diccionario y no puede `derive(Drop)`) ni el "
"trait `Destruct`. Para solucionar esto, podemos derivar la implementación "
"del trait `Destruct` para el tipo `A`:"

#: src/ch04-01-what-is-ownership.md:215
msgid "// No error here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:219
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr ""
"Ahora, cuando `A` salga del ámbito, su diccionario será automáticamente "
"`squashed`, y el programa compilará."

#: src/ch04-01-what-is-ownership.md:221
#, fuzzy
msgid "Copy Array data with Clone"
msgstr "### Copiar datos de un Array con Clone"

#: src/ch04-01-what-is-ownership.md:223
#, fuzzy
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in Chapter 6, but because "
"methods are a common feature in many programming languages, you’ve probably "
"seen them before."
msgstr ""
"Si queremos copiar profundamente los datos de un `Array`, podemos utilizar "
"un método común llamado `clone`. Discutiremos la sintaxis de los métodos en "
"el Capítulo 5, pero como los métodos son una característica común en muchos "
"lenguajes de programación, es probable que ya los hayas visto antes."

#: src/ch04-01-what-is-ownership.md:226
msgid "Here’s an example of the `clone` method in action."
msgstr "Aquí hay un ejemplo del método `clone` en acción."

#: src/ch04-01-what-is-ownership.md:228
#, fuzzy
msgid ""
"Note: in the following example, we need to import the `Clone` trait from the "
"corelib `clone` module, and its implementation for the array type from the "
"`array` module."
msgstr ""
"> Nota: en el siguiente ejemplo, necesitamos importar el rasgo `Clone` del "
"módulo `clone` de la biblioteca estándar, y su implementación para el tipo "
"`array` del módulo `array`."

#: src/ch04-01-what-is-ownership.md:239
#, fuzzy
msgid ""
"Note: you will need to run `scarb cairo-run` with the `--available-"
"gas=2000000` option to run this example, because it uses a loop and must be "
"ran with a gas limit."
msgstr ""
"> Nota: necesitarás ejecutar `cairo-run` con la opción `--available-"
"gas=2000000` para ejecutar este ejemplo, ya que utiliza un bucle y debe ser "
"ejecutado con un límite de gas."

#: src/ch04-01-what-is-ownership.md:241
#, fuzzy
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on."
msgstr ""
"Cuando ves una llamada a `clone`, sabes que se está ejecutando algún código "
"arbitrario\n"
" y ese código puede ser costoso. Es un indicador visual de que algo "
"diferente está sucediendo."

#: src/ch04-01-what-is-ownership.md:245
#, fuzzy
msgid "Ownership and Functions"
msgstr "### Ownership y Funciones"

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in "
"the Array section, passing an `Array` as a function parameter transfers its "
"ownership; let's see what happens with other types."
msgstr ""
"Pasar una variable a una función puede moverla o copiarla. Como se vio en la "
"sección de Array, pasar un `Array` como parámetro de función transfiere su "
"propiedad; veamos qué sucede con otros tipos."

#: src/ch04-01-what-is-ownership.md:249
#, fuzzy
msgid ""
"Listing 4-3 has an example with some annotations showing where variables go "
"into and out of scope."
msgstr ""
"El Listado 3-3 tiene un ejemplo con algunas anotaciones \n"
"que muestran dónde las variables entran y salen de ámbito."

#: src/ch04-01-what-is-ownership.md:259
msgid "// my_struct comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:261
msgid ""
"// my_struct's value moves into the function...\n"
"                                    // ... and so is no longer valid here\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:264
msgid "// x comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:266
msgid ""
"// x would move into the function,\n"
"                                    // but u128 implements Copy, so it is "
"okay to still\n"
"                                    // use x afterward\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:270
msgid "// Here, x goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:273
msgid "// some_struct comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:274
msgid "// Here, some_struct goes out of scope and `drop` is called.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:276
msgid "// some_uinteger comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:277
msgid "// Here, some_integer goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:280
#, fuzzy
msgid "Listing 4-3: Functions with ownership and scope annotated"
msgstr ""
"<span class=\"caption\">Listing 3-3: Functions with ownership and scope\n"
"annotated</span>"

#: src/ch04-01-what-is-ownership.md:283
#, fuzzy
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo "
"would throw a compile-time error. These static checks protect us from "
"mistakes. Try adding code to `main` that uses `my_struct` and `x` to see "
"where you can use them and where the ownership rules prevent you from doing "
"so."
msgstr ""
"Si intentamos usar `my_struct` después de la llamada a `takes_ownership`, "
"Cairo lanzará un \n"
"error en tiempo de compilación. Estas verificaciones estáticas nos protegen "
"de errores. Intenta \n"
"agregar código a `main` que use `my_struct` y `x` para ver dónde puedes "
"usarlos y dónde las \n"
"reglas de propiedad te impiden hacerlo."

#: src/ch04-01-what-is-ownership.md:288
#, fuzzy
msgid "Return Values and Scope"
msgstr "### Valores de retorno y alcance"

#: src/ch04-01-what-is-ownership.md:290
#, fuzzy
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example "
"of a function that returns some value, with similar annotations as those in "
"Listing 4-3."
msgstr ""
"La devolución de valores también puede transferir la propiedad. El Listado "
"3-4 muestra \n"
"un ejemplo de una función que devuelve algún valor, con anotaciones "
"similares a las del Listado 4-3."

#: src/ch04-01-what-is-ownership.md:301
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:304
msgid "// a2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:306
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:310
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:313
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:317
msgid "// some_a comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:319
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:323
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:325
msgid ""
"// some_a comes into\n"
"                                          // scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:328
msgid ""
"// some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:334
#, fuzzy
msgid "Listing 4-4: Transferring ownership of return values"
msgstr ""
"<span class=\"caption\">Listado 3-4: Transferencia de propiedad de \n"
"valores devueltos</span>"

#: src/ch04-01-what-is-ownership.md:337
msgid ""
"When a variable goes out of scope, its value is dropped, unless ownership of "
"the value has been moved to another variable."
msgstr ""
"Cuando una variable sale del ámbito, su valor se elimina, a menos que la "
"propiedad del valor se haya transferido a otra variable."

#: src/ch04-01-what-is-ownership.md:339
#, fuzzy
msgid ""
"While this works, taking ownership and then returning ownership with every "
"function is a bit tedious. What if we want to let a function use a value but "
"not take ownership? It’s quite annoying that anything we pass in also needs "
"to be passed back if we want to use it again, in addition to any data "
"resulting from the body of the function that we might want to return as well."
msgstr ""
"Si bien esto funciona, tomar propiedad y luego devolver la propiedad con "
"cada\n"
" función es un poco tedioso. ¿Qué sucede si queremos permitir que una "
"función use \n"
"un valor pero no tome posesión de él? Es bastante molesto que todo lo que "
"pasemos \n"
"también deba ser devuelto si queremos usarlo nuevamente, además de "
"cualquier\n"
" dato que resulte del cuerpo de la función que también podríamos querer "
"devolver."

#: src/ch04-01-what-is-ownership.md:345
#, fuzzy
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-5."
msgstr ""
"Cairo nos permite devolver múltiples valores usando una tupla, como se "
"muestra en el Listado 3-5."

#: src/ch04-01-what-is-ownership.md:357
msgid "// len() returns the length of an array\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:363
#, fuzzy
msgid "Listing 4-5: Returning ownership of parameters"
msgstr ""
"<span class=\"caption\">Listado 3-5: Devolviendo propiedad de los "
"parámetros</span>"

#: src/ch04-01-what-is-ownership.md:365
#, fuzzy
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for using a value without "
"transferring ownership, called _references_ and _snapshots_."
msgstr ""
"Pero esto es demasiado ceremonioso y mucho trabajo para un concepto que \n"
"debería ser común. Afortunadamente, Cairo tiene dos características para "
"usar\n"
" un valor sin transferir la propiedad, llamadas _referencias_ y _snapshots_."

#: src/ch04-02-references-and-snapshots.md:3
#, fuzzy
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the "
"`Array` to the calling function so we can still use the `Array` after the "
"call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"El problema con el código de tupla en el Listado 3-5 es que tenemos que \n"
"devolver el `Array` a la función de llamada para que podamos seguir usando \n"
"el `Array` después de la llamada a `calculate_length`, ya que el `Array` "
"se \n"
"movió a `calculate_length`."

#: src/ch04-02-references-and-snapshots.md:8
#, fuzzy
msgid "Snapshots"
msgstr "### Snapshots"

#: src/ch04-02-references-and-snapshots.md:10
#, fuzzy
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a "
"snapshot is an immutable view of a value at a certain point in time. In the "
"previous chapter, we talked about how Cairo's ownership system prevents us "
"from using a value after we've moved it, protecting us from potentially "
"writing twice to the same memory cell when appending values to arrays. "
"However, it's not very convenient. Let's see how we can retain ownership of "
"the value in the calling function using snapshots."
msgstr ""
"En su lugar, podemos proporcionar una _instantánea_ del valor `Array`. En "
"Cairo, una instantánea\n"
" es una vista inmutable de un valor en un cierto momento en el tiempo. En el "
"capítulo anterior, \n"
"hablamos de cómo el sistema de propiedad de Cairo nos impide usar un valor "
"después de \n"
"haberlo movido, protegiéndonos de escribir potencialmente dos veces en la "
"misma celda de \n"
"memoria al agregar valores a los arreglos. Sin embargo, no es muy "
"conveniente. Veamos cómo \n"
"podemos mantener la propiedad del valor en la función de llamada usando "
"instantáneas."

#: src/ch04-02-references-and-snapshots.md:17
#, fuzzy
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot to an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as parameter. As we're passing it as "
"a snapshot, which is an immutable view of the array, we can be sure that the "
"`calculate_length` function will not mutate the array, and ownership of the "
"array is kept in the main function."
msgstr ""
"Aquí es cómo definiría y usaría una función `calculate_length` que toma una "
"instantánea \n"
"de un arreglo como parámetro en lugar de tomar propiedad del valor "
"subyacente. En este ejemplo, \n"
"la función `calculate_length` devuelve la longitud del arreglo pasado como "
"parámetro.\n"
"Como lo estamos pasando como una instantánea, que es una vista inmutable del "
"arreglo, podemos estar seguros\n"
" de que la función `calculate_length` no mutará el arreglo, y la propiedad "
"del arreglo se mantiene en la función principal."

#: src/ch04-02-references-and-snapshots.md:30
#: src/ch04-02-references-and-snapshots.md:69
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:31
#: src/ch04-02-references-and-snapshots.md:70
msgid "// Mutate `arr1` by appending a value\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:34
msgid ""
"// Calculate the length of the array when the snapshot was taken\n"
"    //ANCHOR: function_call\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:36
msgid ""
"// Calculate the current length of the array\n"
"    //ANCHOR_END: function_call\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:47
#, fuzzy
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on non-"
"snapshot types."
msgstr ""
"> Nota: Solo es posible llamar al método `len()` en un snapshot de un array "
"porque está definido así en el trait `ArrayTrait`. Si intentas llamar a un "
"método que no está definido para snapshots en un snapshot, obtendrás un "
"error de compilación. Sin embargo, puedes llamar a métodos que esperan un "
"snapshot en tipos que no son snapshots."

#: src/ch04-02-references-and-snapshots.md:49
msgid "The output of this program is:"
msgstr "La salida de este programa es:"

#: src/ch04-02-references-and-snapshots.md:59
#, fuzzy
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""
"La primera observación es que todo el código de tuplas en la declaración de "
"variables y en el valor de retorno de la función \n"
"ha desaparecido. La segunda observación es que pasamos `@arr1` a "
"`calculate_length` y, en su definición, tomamos\n"
" `@Array<u128>` en lugar de `Array<u128>`."

#: src/ch04-02-references-and-snapshots.md:62
msgid "Let’s take a closer look at the function call here:"
msgstr "Veamos más de cerca la llamada a la función aquí:"

#: src/ch04-02-references-and-snapshots.md:73
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:74
msgid "// Calculate the current length of the array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value, the value it points to cannot be "
"modified through the snapshot, and the value it refers to will not be "
"dropped once the snapshot stops being used."
msgstr ""
"La sintaxis `@arr1` nos permite crear una instantánea (snapshot) del valor "
"en `arr1`. Como una instantánea es una vista inmutable de un valor, el valor "
"al que apunta no puede ser modificado a través de la instantánea y el valor "
"al que se refiere no será eliminado una vez que la instantánea deje de ser "
"usada."

#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""
"De manera similar, la firma de la función utiliza `@` para indicar que el "
"tipo del parámetro `arr` es una instantánea. Añadamos algunas anotaciones "
"explicativas:"

#: src/ch04-02-references-and-snapshots.md:91
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:93
#, fuzzy
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
msgstr ""
"```rust\n"
"fn calculate_length(\n"
"    array_snapshot: @Array<u128>\n"
") -> usize { // array_snapshot is a snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
"```"

#: src/ch04-02-references-and-snapshots.md:97
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"El alcance en el que la variable `array_snapshot` es válida es el mismo que "
"el alcance de cualquier parámetro de función, pero el valor subyacente del "
"snapshot no se eliminará cuando `array_snapshot` deje de usarse. Cuando las "
"funciones tienen snapshots como parámetros en lugar de los valores reales, "
"no necesitamos devolver los valores para devolver la propiedad del valor "
"original, porque nunca la tuvimos."

#: src/ch04-02-references-and-snapshots.md:99
#, fuzzy
msgid "Desnap Operator"
msgstr "## Operadores"

#: src/ch04-02-references-and-snapshots.md:101
msgid ""
"To convert a snapshot back into a regular value, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator: the snapshot "
"value is copied to a new variable."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:103
msgid ""
"It's important to note that during this conversion process, the value it "
"points to is copied into a new variable. This enables multiple uses of the "
"underlying value without concerns about ownership transfers. This also means "
"that the value pointed to by the snapshot must be copyable (which is not the "
"case for Arrays, as they don't implement `Copy`)."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:105
#, fuzzy
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Los snapshots se pueden convertir de nuevo en valores regulares usando el "
"operador `desnap` `*`, siempre y cuando el tipo de valor sea copiable (lo "
"cual no es el caso para los Arrays, ya que no implementan `Copy`). En el "
"siguiente ejemplo, queremos calcular el área de un rectángulo, pero no "
"queremos tomar la propiedad del rectángulo en la función `calculate_area`, "
"porque podríamos querer usar el rectángulo de nuevo después de la llamada a "
"la función. Dado que nuestra función no muta la instancia del rectángulo, "
"podemos pasar el snapshot del rectángulo a la función, y luego transformar "
"los snapshots de nuevo en valores usando el operador `desnap` `*`."

#: src/ch04-02-references-and-snapshots.md:123
#, fuzzy
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rec = Rectangle { height: 3, width: 10 };\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of "
"the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"

#: src/ch04-02-references-and-snapshots.md:131
#, fuzzy
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? "
"Try the code in Listing 4-6. Spoiler alert: it doesn’t work!"
msgstr ""
"Pero, ¿qué sucede si intentamos modificar algo que estamos pasando como "
"instantánea? Prueba el código \n"
"en la Lista 3-6. ¡Alerta de spoiler: no funciona!"

#: src/ch04-02-references-and-snapshots.md:155
#, fuzzy
msgid "Listing 4-6: Attempting to modify a snapshot value"
msgstr ""
"<span class=\"caption\">Listado 3-6: Intentando modificar un valor de "
"snapshot</span>"

#: src/ch04-02-references-and-snapshots.md:157
msgid "Here’s the error:"
msgstr "Aquí está el error:"

#: src/ch04-02-references-and-snapshots.md:166
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr ""
"El compilador nos impide modificar los valores asociados a las instantáneas."

#: src/ch04-02-references-and-snapshots.md:168
#, fuzzy
msgid "Mutable References"
msgstr "### Referencias Mutables"

#: src/ch04-02-references-and-snapshots.md:170
#, fuzzy
msgid ""
"We can achieve the behavior we want in Listing 4-6 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Podemos lograr el comportamiento que queremos en el Listado 3-6 utilizando "
"una _referencia mutable_ en lugar de un snapshot. Las referencias mutables "
"son valores mutables pasados a una función que se devuelven implícitamente "
"al final de la función, devolviendo la propiedad al contexto de llamada. Al "
"hacerlo, le permiten mutar el valor pasado y mantener su propiedad "
"devolviéndolo automáticamente al final de la ejecución.\n"
"En Cairo, se puede pasar un parámetro como _referencia mutable_ utilizando "
"el modificador `ref`."

#: src/ch04-02-references-and-snapshots.md:173
#, fuzzy
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"> **Nota**: En Cairo, un parámetro solo se puede pasar como _referencia "
"mutable_ utilizando el modificador `ref` si la variable se declara como "
"mutable con `mut`."

#: src/ch04-02-references-and-snapshots.md:175
#, fuzzy
msgid ""
"In Listing 4-7, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""
"En el Listado 3-7, usamos una referencia mutable para modificar el valor del "
"campo `height` de la instancia de `Rectangle` en la función `flip`."

#: src/ch04-02-references-and-snapshots.md:199
#, fuzzy
msgid "Listing 4-7: Use of a mutable reference to modify a value"
msgstr ""
"<span class=\"caption\">Listing 3-7: Uso de una referencia mutable para "
"modificar un valor</span>"

#: src/ch04-02-references-and-snapshots.md:201
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"Primero, cambiamos `rec` a `mut`. Luego, pasamos una referencia mutable de "
"`rec` a `flip` con `ref rec` y actualizamos la firma de la función para "
"aceptar una referencia mutable con `ref rec: Rectangle`. Esto deja muy claro "
"que la función `flip` modificará el valor de la instancia de `Rectangle` "
"pasada como parámetro."

#: src/ch04-02-references-and-snapshots.md:203
msgid "The output of the program is:"
msgstr "La salida del programa es:"

#: src/ch04-02-references-and-snapshots.md:212
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""
"Como era de esperar, los campos `height` y `width` de la variable `rec` se "
"han intercambiado."

#: src/ch04-02-references-and-snapshots.md:214
#, fuzzy
msgid "Small recap"
msgstr "### Pequeño resumen"

#: src/ch04-02-references-and-snapshots.md:216
msgid ""
"Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr ""
"Como resumen, lo que hemos discutido acerca de ownership, snapshots y las "
"referencias es:"

#: src/ch04-02-references-and-snapshots.md:218
msgid "At any given time, a variable can only have one owner."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:219
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:220
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:221
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""

#: src/ch04-02-references-and-snapshots.md:222
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""
"Un struct, o estructura, es un tipo de datos personalizado que te permite "
"empaquetar y nombrar múltiples valores relacionados que conforman un grupo "
"significativo. Si estás familiarizado con un lenguaje orientado a objetos, "
"un struct es como los atributos de datos de un objeto. En este capítulo, "
"compararemos y contrastaremos las tuplas con los structs para construir "
"sobre lo que ya sabes y demostrar cuándo los structs son una mejor manera de "
"agrupar datos."

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the next chapter) are the building blocks for "
"creating new types in your program’s domain to take full advantage of "
"Cairo's compile-time type checking."
msgstr ""
"Demostraremos cómo definir e instanciar structs. Discutiremos cómo definir "
"funciones asociadas, especialmente el tipo de funciones asociadas llamadas "
"métodos, para especificar el comportamiento asociado con un tipo de struct. "
"Los structs y los enums (discutidos en el Capítulo 6) son los bloques de "
"construcción para crear nuevos tipos en el dominio de tu programa para "
"aprovechar al máximo la verificación de tipos en tiempo de compilación de "
"Cairo."

#: src/ch05-01-defining-and-instantiating-structs.md:3
#, fuzzy
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Las estructuras son similares a las tuplas, discutidas en la sección [Tipos "
"de datos](ch02-02-data-types.md), en el sentido de que ambas contienen "
"múltiples valores relacionados. Al igual que las tuplas, las piezas de una "
"estructura pueden ser de diferentes tipos. A diferencia de las tuplas, en "
"una estructura se nombra cada dato para que quede claro lo que significan "
"los valores. Agregar estos nombres significa que las estructuras son más "
"flexibles que las tuplas: no se tiene que depender del orden de los datos "
"para especificar o acceder a los valores de una instancia."

#: src/ch05-01-defining-and-instantiating-structs.md:5
#, fuzzy
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"Para definir una estructura, introducimos la palabra clave `struct` y "
"nombramos la estructura completa. El nombre de una estructura debe describir "
"el significado de los datos que se agrupan. Después, entre llaves, definimos "
"los nombres y tipos de los datos, que llamamos campos. Por ejemplo, el "
"Listado 4-1 muestra una estructura que almacena información sobre una cuenta "
"de usuario."

#: src/ch05-01-defining-and-instantiating-structs.md:19
#, fuzzy
msgid "Listing 5-1: A `User` struct definition"
msgstr "<span class=\"caption\">Listing 4-1: A `User` struct definition</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:21
#, fuzzy
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""
"Para usar una estructura después de haberla definido, creamos una instancia "
"de esa estructura especificando valores concretos para cada uno de los "
"campos. \n"
"Creamos una instancia indicando el nombre de la estructura y luego agregamos "
"corchetes que contienen pares de *clave: valor*, donde las claves son los "
"nombres de los campos y los valores son los datos que queremos almacenar en "
"esos campos. No tenemos que especificar los campos en el mismo orden en que "
"los declaramos en la estructura. En otras palabras, la definición de una "
"estructura es como una plantilla general para el tipo y las instancias "
"completan esa plantilla con datos particulares para crear valores del tipo."

#: src/ch05-01-defining-and-instantiating-structs.md:24
#, fuzzy
msgid "For example, we can declare a particular user as shown in Listing 5-2."
msgstr ""
"Por ejemplo, podemos declarar un usuario particular como se muestra en el "
"Listado 4-2."

#: src/ch05-01-defining-and-instantiating-structs.md:44
#, fuzzy
msgid "Listing 5-2: Creating an instance of the `User` struct"
msgstr ""
"<span class=\"caption\">Listado 4-2: Creando una instancia de la estructura "
"`User`</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:46
#, fuzzy
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""
"Para obtener un valor específico de una estructura, usamos la notación "
"punto. Por ejemplo, para acceder a la dirección de correo electrónico de "
"este usuario, usamos `user1.email`. Si la instancia es mutable, podemos "
"cambiar un valor usando la notación punto y asignándolo a un campo en "
"particular. El listado 4-3 muestra cómo cambiar el valor en el campo "
"`email`de una instancia mutable de `User`."

#: src/ch05-01-defining-and-instantiating-structs.md:76
#, fuzzy
msgid "Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr ""
"<span class=\"caption\">Listado 4-3: Cambiando el valor del campo email de "
"la instancia `User`</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:78
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""
"Tenga en cuenta que toda la instancia debe ser mutable; Cairo no nos permite "
"marcar solo ciertos campos como mutables."

#: src/ch05-01-defining-and-instantiating-structs.md:80
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""
"Como con cualquier expresión, podemos construir una nueva instancia de la "
"estructura como la última expresión en el cuerpo de la función para devolver "
"implícitamente esa nueva instancia."

#: src/ch05-01-defining-and-instantiating-structs.md:82
#, fuzzy
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"Listado 4-4 muestra la función `build_user` que retorna una instancia de la "
"estructura `User` con el email y el username. Al campo `active` se le asigna "
"el valor `true`,y el campo `sign_in_count` obtiene el valor de `1`."

#: src/ch05-01-defining-and-instantiating-structs.md:112
#, fuzzy
msgid ""
"Listing 5-4: A `build_user` function that takes an email and username and "
"returns a `User` instance"
msgstr ""
"<span class=\"caption\">Listado 4-4: Función `build_user` que toma los "
"argumentos email y username, y retorna una instancia de la estructura "
"`User`</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:114
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"Tiene sentido nombrar los parámetros de la función con el mismo nombre que "
"los campos de la estructura, porque tener que repetir los nombres y "
"variables de los campos `email`y `username` es un poco tedioso. Si la "
"estructura tuviera más campos, repetir cada nombre sería aún más molesto. "
"¡Afortunadamente, hay una forma abreviada!"

#: src/ch05-01-defining-and-instantiating-structs.md:116
#, fuzzy
msgid "Using the Field Init Shorthand"
msgstr "## Usando la Abreviatura Field Init"

#: src/ch05-01-defining-and-instantiating-structs.md:118
#, fuzzy
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"Como los nombres de los parámetros y los nombres de los campos struct son "
"exactamente los mismos en el Listado 4-4, podemos usar la sintaxis abreviada "
"de field init para reescribir `build_user` de forma que se comporte "
"exactamente igual pero sin la repetición de `username` y `email`, como se "
"muestra en el Listado 4-5."

#: src/ch05-01-defining-and-instantiating-structs.md:148
#, fuzzy
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because "
"the `username` and `email` parameters have the same name as struct fields"
msgstr ""
"<span class=\"caption\">Lista 4-5: Una función `build_user` que utiliza la "
"abreviatura field init porque los parámetros `username` y `email` tienen el "
"mismo nombre que los campos struct</span>"

#: src/ch05-01-defining-and-instantiating-structs.md:150
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"Aquí, estamos creando una nueva instancia de la estructura `User`, que tiene "
"un campo llamado `email`. Queremos establecer el valor del campo `email` con "
"el valor del parámetro `email` de la función `build_user`. Debido a que el "
"campo `email` y el parámetro `email` tienen el mismo nombre, solo "
"necesitamos escribir `email` en lugar de `email: email`."

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""
"Para entender cuándo podríamos usar estructuras, escribamos un programa que "
"calcule el área de un rectángulo. Comenzaremos usando variables individuales "
"y luego reescribiremos el programa hasta que estemos usando estructuras en "
"su lugar."

#: src/ch05-02-an-example-program-using-structs.md:5
#, fuzzy
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Hagamos un nuevo proyecto con Scarb llamado _rectangles_ que tomará el ancho "
"y la altura de un rectángulo en píxeles y calculará el área del rectángulo. "
"El Listado 4-6 muestra un pequeño programa con una forma de hacer "
"exactamente eso en el _src/lib.cairo_ de nuestro proyecto."

#: src/ch05-02-an-example-program-using-structs.md:23
#, fuzzy
msgid ""
"Listing 5-6: Calculating the area of a rectangle specified by separate width "
"and height variables"
msgstr ""
"<span class=\"caption\">Listado 4-6: Cálculo del área de un rectángulo "
"especificado por variables separadas de ancho y alto</span>"

#: src/ch05-02-an-example-program-using-structs.md:25
#, fuzzy
msgid "Now run the program with `scarb cairo-run`:"
msgstr "Para compilar el programa usamos `cairo-run src/lib.cairo`:"

#: src/ch05-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""
"Este código logra calcular el área del rectángulo llamando a la función "
"`area` con cada dimensión, pero podemos hacer más para que este código sea "
"claro y legible."

#: src/ch05-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""
"El problema con este código es evidente en la declaración de la función "
"`area`:"

#: src/ch05-02-an-example-program-using-structs.md:42
#, fuzzy
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in [Chapter 2](ch02-02-data-types.html#the-tuple-type): "
"using tuples."
msgstr ""
"Se supone que la función `area` calcula el área de un rectángulo, pero la "
"función que escribimos tiene dos parámetros, y no está claro en ninguna "
"parte de nuestro programa que los parámetros estén relacionados. Sería más "
"legible y manejable agrupar el ancho y el alto juntos. Ya discutimos una "
"forma en que podríamos hacer eso en el [Capítulo 3](ch02-02-data-types."
"html#the-tuple-type): usando tuplas."

#: src/ch05-02-an-example-program-using-structs.md:44
#, fuzzy
msgid "Refactoring with Tuples"
msgstr "## Reescribiendo con Tuplas"

#: src/ch05-02-an-example-program-using-structs.md:46
#, fuzzy
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr "El listado 4-7 muestra otra versión de nuestro programa usando tuplas."

#: src/ch05-02-an-example-program-using-structs.md:55
#: src/ch05-02-an-example-program-using-structs.md:87
msgid "// print out the area\n"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:64
#, fuzzy
msgid ""
"Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr ""
"<span class=\"caption\">Listing 4-7: Especificando el ancho y alto de un "
"rectángulo con una tupla</span>"

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"En cierto modo, este programa es mejor. Las tuplas nos permiten agregar un "
"poco de estructura y ahora estamos pasando solo un argumento. Pero en otro "
"sentido, esta versión es menos clara: las tuplas no nombran sus elementos, "
"por lo que tenemos que indexar las partes de la tupla, lo que hace que "
"nuestro cálculo sea menos obvio."

#: src/ch05-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"Mezclar el ancho y la altura no importaría para el cálculo del área, pero si "
"queremos calcular la diferencia, ¡sería importante! Tendríamos que tener en "
"cuenta que `width` es el índice de tupla `0` y `height` es el índice de "
"tupla `1`. Esto sería aún más difícil de entender y tener en cuenta para "
"otra persona si usara nuestro código. Debido a que no hemos transmitido el "
"significado de nuestros datos en nuestro código, ahora es más fácil "
"introducir errores."

#: src/ch05-02-an-example-program-using-structs.md:70
#, fuzzy
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "## Reescribiendo con `struct`: Agrega Más Significado"

#: src/ch05-02-an-example-program-using-structs.md:72
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""
"Usamos estructuras para agregar significado al etiquetar los datos. Podemos "
"transformar la tupla que estamos usando en una estructura con un nombre para "
"el todo y nombres para las partes."

#: src/ch05-02-an-example-program-using-structs.md:95
#, fuzzy
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr ""
"<span class=\"caption\">Listado 4-8: Definición de una estructura llamada "
"`Rectangle`</span>"

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""
"Aquí hemos definido una estructura y la hemos llamado `Rectangle`. Dentro de "
"las llaves, definimos los campos como `width` y `height`, los cuales tienen "
"el tipo `u64`. Luego, en `main`, creamos una instancia particular de "
"`Rectangle` que tiene un ancho de `30` y una altura de `10`. Nuestra función "
"`area` ahora está definida con un parámetro, al que hemos llamado "
"`rectangle` que es de tipo de la estructura `Rectangle`. Luego podemos "
"acceder a los campos de la instancia con notación de punto, y dar nombres "
"descriptivos a los valores en lugar de usar los valores de índice de tupla "
"de `0` y `1`."

#: src/ch05-02-an-example-program-using-structs.md:99
#, fuzzy
msgid "Adding Useful Functionality with Trait"
msgstr "## Agregando Funcionalidades Útiles con Trait"

#: src/ch05-02-an-example-program-using-structs.md:101
#, fuzzy
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-9 "
"tries using the `print` as we have used in previous chapters. This won’t "
"work."
msgstr ""
"Sería útil poder imprimir una instancia de `Rectangle` mientras estamos "
"depurando nuestro programa y ver los valores de todos sus campos. El Listado "
"4-9 intenta usar `print` como lo hemos usado en capítulos anteriores. Esto "
"no funcionará."

#: src/ch05-02-an-example-program-using-structs.md:119
#, fuzzy
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr ""
"<span class=\"caption\">Listado 4-9: Intentando imprimir una instancia de "
"`Rectangle`</span>"

#: src/ch05-02-an-example-program-using-structs.md:121
msgid "When we compile this code, we get an error with this message:"
msgstr ""
"Cuando compilamos este código, obtenemos un error con el siguiente mensaje:"

#: src/ch05-02-an-example-program-using-structs.md:123
#, fuzzy
msgid ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you "
"import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""
"```bash\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you "
"import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"

#: src/ch05-02-an-example-program-using-structs.md:133
#, fuzzy
msgid ""
"The `print` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""
"El trait `print` está implementado para muchos tipos de datos, pero no para "
"la estructura `Rectangle`. Podemos arreglar esto implementando el trait "
"`PrintTrait` en la estructura `Rectangle` como se muestra en el Listado "
"4-10.\n"
"Para aprender más sobre traits,[Traits en Cairo](ch07-02-traits-in-cairo.md)."

#: src/ch05-02-an-example-program-using-structs.md:161
#, fuzzy
msgid "Listing 5-10: Implementing the `PrintTrait` trait on `Rectangle`"
msgstr ""
"<span class=\"caption\">Listado 4-10:  Implementación del trait `PrintTrait` "
"en `Rectangle`</span>"

#: src/ch05-02-an-example-program-using-structs.md:163
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr ""
"¡Bien! No es el resultado más bonito, pero muestra los valores de todos los "
"campos para esta instancia, lo que definitivamente ayudaría durante la "
"depuración."

#: src/ch05-03-method-syntax.md:3
#, fuzzy
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on. For those familiar with Rust, Cairo's approach "
"might be confusing, as methods cannot be defined directly on types. Instead, "
"you must define a trait and an implementation associated with the type for "
"which the method is intended."
msgstr ""
"Los métodos son similares a las funciones: los declaramos con la palabra "
"clave `fn` \n"
"y un nombre, pueden tener parámetros, retornar un valor, y contener código "
"que se \n"
"ejecuta cuando el método es llamado desde otro lugar. A diferencia de las "
"funciones, \n"
"los métodos se definen dentro del contexto de un tipo y su primer parámetro "
"siempre es \n"
"`self`, que representa la instancia del tipo al que se llama el método. Para "
"aquellos familiarizados \n"
"con Rust, el enfoque de Cairo puede resultar confuso, ya que los métodos no "
"se pueden definir \n"
"directamente en los tipos. En su lugar, debe definir un `trait` y una "
"implementación asociados con el\n"
" tipo para el que está destinado el método."

#: src/ch05-03-method-syntax.md:12
#, fuzzy
msgid "Defining Methods"
msgstr "### Definición de Détodos"

#: src/ch05-03-method-syntax.md:14
#, fuzzy
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `RectangleTrait` "
"trait, as shown in Listing 5-13."
msgstr ""
"Cambiemos la función `area` que tiene una instancia `Rectangle` como "
"parámetro\n"
"y en su lugar hagamos un método `area` definido en el rasgo "
"`RectangleTrait`, como se muestra en el Listado 4-13.\n"
"en el Listado 4-13."

#: src/ch05-03-method-syntax.md:45
#, fuzzy
msgid "Listing 5-13: Defining an `area` method to use on the `Rectangle` "
msgstr ""
"<span class=\"caption\">Listado 4-13: Definiendo el método `area` para usar "
"en la \n"
"estructura `Rectangle` </span>"

#: src/ch05-03-method-syntax.md:48
#, fuzzy
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait` block with the signature of the method that we want to "
"implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we "
"define an `impl` (implementation) block for `RectangleTrait`, that defines "
"the behavior of the methods implemented. Everything within this `impl` block "
"will be associated with the type of the `self` parameter of the method "
"called. While it is technically possible to define methods for multiple "
"types within the same `impl` block, it is not a recommended practice, as it "
"can lead to confusion. We recommend that the type of the `self` parameter "
"stays consistent within the same `impl` block. Then we move the `area` "
"function within the `impl` curly brackets and change the first (and in this "
"case, only) parameter to be `self` in the signature and everywhere within "
"the body. In `main`, where we called the `area` function and passed `rect1` "
"as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an "
"instance: we add a dot followed by the method name, parentheses, and any "
"arguments."
msgstr ""
"Para definir la función en el contexto de `Rectangle`, empezamos definiendo "
"un bloque `trait`\n"
"con la firma del método que queremos implementar. Los traits no están "
"vinculados a\n"
"sólo el parámetro `self` del método define con qué tipo se puede utilizar.\n"
"puede utilizar. A continuación, definimos un bloque `impl` (implementación) "
"para `RectangleTrait`, que define\n"
"el comportamiento de los métodos implementados. Todo dentro de este bloque "
"`impl` será\n"
"asociado con el tipo del parámetro `self` del método llamado. Aunque "
"técnicamente es posible\n"
"definir métodos para múltiples tipos dentro del mismo bloque `impl`, no es "
"una\n"
"una práctica recomendada, ya que puede dar lugar a confusión. Recomendamos "
"que el tipo del parámetro `self\n"
"sea consistente dentro del mismo bloque `impl`.\n"
"Entonces movemos la función `area` dentro de las llaves `impl` y cambiamos "
"el primer (y en este caso, único) parámetro\n"
"para que sea `self` en la firma y en todo el cuerpo. En\n"
"donde llamamos a la función `area` y pasamos `rect1` como argumento,\n"
"podemos usar la sintaxis _method_ para llamar al método `area` en nuestra "
"instancia `Rectangle`.\n"
"de nuestro `Rectángulo`. La sintaxis de método va después de una instancia: "
"añadimos un punto seguido de\n"
"el nombre del método, los paréntesis y los argumentos."

#: src/ch05-03-method-syntax.md:64
#, fuzzy
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter. Note that we used the `@` snapshot operator in "
"front of the `Rectangle` type in the function signature. By doing so, we "
"indicate that this method takes an immutable snapshot of the `Rectangle` "
"instance, which is automatically created by the compiler when passing the "
"instance to the method. Methods can take ownership of `self`, use `self` "
"with snapshots as we’ve done here, or use a mutable reference to `self` "
"using the `ref self: T` syntax."
msgstr ""
"Los métodos deben tener un parámetro llamado `self` del tipo al que se "
"aplicarán como primer parámetro.\n"
"Observa que hemos utilizado el operador de instantánea `@` delante del tipo "
"`Rectangle` en la firma de la función.\n"
"Al hacerlo, indicamos que este método toma una instantánea inmutable de la "
"instancia `Rectangle`, que es\n"
"automáticamente por el compilador al pasar la instancia al método.\n"
"Los métodos pueden tomar posesión de `self`, usar `self` con instantáneas "
"como hemos hecho aquí, o usar una referencia mutable a `self\n"
"usando la sintaxis `ref self: T`."

#: src/ch05-03-method-syntax.md:71
#, fuzzy
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in "
"the function version: we don’t want to take ownership, and we just want to "
"read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, "
"we’d use `ref self: Rectangle` as the first parameter. Having a method that "
"takes ownership of the instance by using just `self` as the first parameter "
"is rare; this technique is usually used when the method transforms `self` "
"into something else and you want to prevent the caller from using the "
"original instance after the transformation."
msgstr ""
"Elegimos `self: @Rectangle` por la misma razón que usamos `@Rectangle` en la "
"función versión:\n"
" no queremos tomar posesión, y solo queremos leer los datos en la "
"estructura, no escribir en ella.\n"
" Si quisiéramos cambiar la instancia que hemos llamado al método como parte "
"de lo que hace el método,\n"
" usaríamos `ref self: Rectangle` como el primer parámetro. Tener un método "
"que tome posesión de la \n"
"instancia por usar solo `self` como primer parámetro es raro; esta técnica "
"suele ser usada cuando el\n"
" método transforma `self` en otra cosa y desea evitar que la persona que "
"llama use la instancia original\n"
" después de la transformación."

#: src/ch05-03-method-syntax.md:80
#, fuzzy
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members. This is necessary because the struct is "
"passed as a snapshot, and all of its field values are of type `@T`, "
"requiring them to be desnapped in order to manipulate them."
msgstr ""
"Observe el uso del operador *desnap* `*` dentro del método *area* cuando "
"accede a los miembros de la \n"
"estructura. Esto es necesario porque la estructura se pasa como una "
"*snapshot* y todos sus valores de campo \n"
"son del tipo `@T`, requiriendo que sean *desnapped* para poder manipularlos."

#: src/ch05-03-method-syntax.md:84
#, fuzzy
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide. However, we can define multiple "
"combinations of `trait` & `impl` blocks for the same type at different "
"places, which can be useful for a more granular code organization. For "
"example, you could implement the `Add` trait for your type in one `impl` "
"block, and the `Sub` trait in another block."
msgstr ""
"La principal razón para utilizar métodos en lugar de funciones es la "
"organización y la claridad del código. Hemos puesto todas las cosas que "
"podemos hacer con una instancia de un tipo en una combinación de bloques "
"`trait` & `impl`, en lugar de hacer que los futuros usuarios de nuestro "
"código busquen las capacidades de `Rectangle` en varios lugares del código.\n"
"de nuestro código busquen las capacidades de `Rectangle` en varios lugares "
"de la\n"
"biblioteca que proporcionamos. Sin embargo, podemos definir múltiples "
"combinaciones de bloques `trait` & `impl` para el mismo tipo en diferentes "
"lugares, lo que puede ser útil para una organización más granular del "
"código. Por ejemplo, puedes implementar\n"
"el rasgo `Add` para tu tipo en un bloque `impl`, y el rasgo `Sub` en otro "
"bloque."

#: src/ch05-03-method-syntax.md:89
#, fuzzy
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr ""
"Tenga en cuenta que podemos optar por dar a un método el mismo nombre que "
"uno de los campos de la estructura\n"
"de la estructura. Por ejemplo, podemos definir un método en `Rectangle` que "
"también se llame\n"
"ancho`:"

#: src/ch05-03-method-syntax.md:119
#, fuzzy
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0` and `false` if the value "
"is `0`: we can use a field within a method of the same name for any purpose. "
"In `main`, when we follow `rect1.width` with parentheses, Cairo knows we "
"mean the method `width`. When we don’t use parentheses, Cairo knows we mean "
"the field `width`."
msgstr ""
"Aquí, elegimos hacer que el método `width` devuelva `true` si el valor en el "
"campo `width` \n"
"de la instancia es mayor que `0` y `false` si el valor es `0`: podemos usar "
"un campo dentro \n"
"de un método del mismo nombre para cualquier propósito. En `main`, cuando "
"colocamos \n"
"`rect1.width` entre paréntesis, Cairo sabe que nos referimos al método "
"`width`. Cuando no \n"
"usamos paréntesis, Cairo sabe que nos referimos al campo `widht`."

#: src/ch05-03-method-syntax.md:126
#, fuzzy
msgid "Methods with More Parameters"
msgstr "### Métodos con Más Parámetros"

#: src/ch05-03-method-syntax.md:128
#, fuzzy
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we "
"want to be able to write the program shown in Listing 5-14."
msgstr ""
"Practiquemos el uso de métodos implementando un segundo método en la "
"estructura `Rectangle`.\n"
"struct. Esta vez queremos que una instancia de `Rectangle` tome otra "
"instancia de `Rectangle\n"
"de `Rectangle` y devuelva `true` si el segundo `Rectangle` cabe "
"completamente dentro de\n"
"dentro de `self` (el primer `Rectangle`); en caso contrario, devolverá "
"`false`.\n"
"Es decir, una vez que hemos definido el método `can_hold`, queremos ser "
"capaces de escribir\n"
"el programa mostrado en el Listado 4-14."

#: src/ch05-03-method-syntax.md:158
#, fuzzy
msgid "Listing 5-14: Using the as-yet-unwritten `can_hold` method"
msgstr ""
"<span class=\"caption\">Listado 4-14: Utilizando el método `can_hold` \n"
"aún no escrito</span>"

#: src/ch05-03-method-syntax.md:161
#, fuzzy
msgid ""
"The expected output would look like the following because both dimensions of "
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr ""
"La salida esperada sería similar a la siguiente porque ambas dimensiones de "
"`rect2` son más\n"
" pequeñas que las dimensiones de `rect1`, pero `rect3` es más ancha que` "
"rect1`:"

#: src/ch05-03-method-syntax.md:177
#, fuzzy
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The "
"method name will be `can_hold`, and it will take a snapshot of another "
"`Rectangle` as a parameter. We can tell what the type of the parameter will "
"be by looking at the code that calls the method: `rect1.can_hold(@rect2)` "
"passes in `@rect2`, which is a snapshot to `rect2`, an instance of "
"`Rectangle`. This makes sense because we only need to read `rect2` (rather "
"than write, which would mean we’d need a mutable borrow), and we want `main` "
"to retain ownership of `rect2` so we can use it again after calling the "
"`can_hold` method. The return value of `can_hold` will be a Boolean, and the "
"implementation will check whether the width and height of `self` are greater "
"than the width and height of the other `Rectangle`, respectively. Let’s add "
"the new `can_hold` method to the `trait` and `impl` blocks from Listing "
"5-13, shown in Listing 5-15."
msgstr ""
"Sabemos que queremos definir un método, así que estará dentro de los bloques "
"`trait RectangleTrait`\n"
"y `impl RectangleImpl of RectangleTrait`.\n"
"El nombre del método será `can_hold`, y tomará una instantánea\n"
"de otro `Rectangle` como parámetro. Podemos saber cuál será el tipo del "
"parámetro\n"
"mirando el código que llama al método:\n"
"rect1.can_hold(@rect2)` pasa `@rect2`, que es una instantánea de\n"
"`rect2`, una instancia de `Rectangle`. Esto tiene sentido porque sólo "
"necesitamos\n"
"leer `rect2` (en lugar de escribir, lo que significaría que necesitaríamos "
"un préstamo mutable),\n"
"y queremos que `main` conserve la propiedad de `rect2` para poder volver a "
"usarla después de\n"
"llamar al método `can_hold`. El valor de retorno de `can_hold` será un "
"booleano\n"
"y la implementación comprobará si la anchura y la altura de\n"
"`self` son mayores que la anchura y la altura del otro `Rectangle`,\n"
"respectivamente. Añadamos el nuevo método `can_hold` a los bloques `trait` e "
"`impl` de\n"
"Listado 4-13, mostrados en el Listado 4-15."

#: src/ch05-03-method-syntax.md:211
#, fuzzy
msgid ""
"Listing 5-15: Implementing the `can_hold` method on `Rectangle` that takes "
"another `Rectangle` instance as a parameter"
msgstr ""
"<span class=\"caption\">Listado 4-15: Implementación del método `can_hold` "
"en\n"
"`Rectangle` que toma otra instancia de `Rectangle` como parámetro</span>"

#: src/ch05-03-method-syntax.md:214
#, fuzzy
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""
"Cuando ejecutemos este código con la función `main` del Listado 4-14, "
"obtendremos\n"
"salida deseada. Los métodos pueden tomar múltiples parámetros que añadimos a "
"la firma\n"
"después del parámetro `self`, y esos parámetros funcionan igual que los\n"
"parámetros en las funciones."

#: src/ch05-03-method-syntax.md:219
#, fuzzy
msgid "Accessing implementation functions"
msgstr "### Acceso a las funciones de implementación"

#: src/ch05-03-method-syntax.md:221
#, fuzzy
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed using the `::` operator on the implementation name. Functions in "
"traits that aren’t methods are often used for constructors that will return "
"a new instance of the struct. These are often called `new`, but `new` isn’t "
"a special name and isn’t built into the language. For example, we could "
"choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it "
"easier to create a square `Rectangle` rather than having to specify the same "
"value twice:"
msgstr ""
"Todas las funciones definidas dentro de un bloque `trait` e `impl` se pueden "
"direccionar directamente\n"
"utilizando el operador `::` en el nombre de la implementación.\n"
"Las funciones en traits que no son métodos se utilizan a menudo para "
"constructores que\n"
"devolverán una nueva instancia de la estructura. A menudo se llaman `new`, "
"pero\n"
"`new` no es un nombre especial y no está incorporado en el lenguaje. Por "
"ejemplo\n"
"una función asociada llamada `square` que tendría un parámetro de\n"
"un parámetro de dimensión y utilizarlo como anchura y altura, facilitando "
"así la creación de un cuadrado.\n"
"un `Rectángulo` cuadrado en lugar de tener que especificar el mismo valor "
"dos veces\n"
"valor dos veces:"

#: src/ch05-03-method-syntax.md:245
#, fuzzy
msgid ""
"To call this function, we use the `::` syntax with the implementation name; "
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by the implementation; the `::` syntax is used for both trait "
"functions and namespaces created by modules. We’ll discuss modules in "
"\\[Chapter 8\\]\\[modules\\]"
msgstr ""
"Para llamar a esta función, usamos la sintaxis `::` con el nombre\n"
"de implementación; `let square = RectangleImpl::square(10);` es un ejemplo. "
"Esta función está en el espacio de nombres \n"
"de la implementación; la sintaxis `::` se utiliza tanto para las funciones \n"
"de los traits como para los espacios de nombres creados por los módulos. "
"Discutiremos los módulos en el [Capítulo 7][modules]<!-- ignore -->."

#: src/ch05-03-method-syntax.md:248 src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr "."

#: src/ch05-03-method-syntax.md:250
#, fuzzy
msgid ""
"Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""
"> Nota: También es posible llamar a esta función utilizando el nombre del "
"trait, con `RectangleTrait::square(10)`."

#: src/ch05-03-method-syntax.md:252
#, fuzzy
msgid "Multiple `impl` Blocks"
msgstr "### Multiples Bloques con `impl`"

#: src/ch05-03-method-syntax.md:254
#, fuzzy
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which "
"has each method in its own `trait` and `impl` blocks."
msgstr ""
"Cada estructura puede tener múltiples bloques `trait` e `impl`. Por ejemplo, "
"el Listado \n"
"5-15 es equivalente al código mostrado en el Listado 4-16, que tiene cada "
"método en\n"
"sus propios bloques `trait` e `impl`."

#: src/ch05-03-method-syntax.md:279
#, fuzzy
msgid "Listing 5-16: Rewriting Listing 5-15 using multiple `impl` blocks"
msgstr ""
"<span class=\"caption\">Listado 4-16: Reescribiendo el Listado 4-15 usando "
"múltiples bloques `impl`</span>"

#: src/ch05-03-method-syntax.md:282
#, fuzzy
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` "
"blocks here, but this is valid syntax. We’ll see a case in which multiple "
"blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where "
"we discuss generic types and traits."
msgstr ""
"No hay razón para separar estos métodos en múltiples bloques `trait` e "
"`impl` aquí,\n"
"pero es una sintaxis válida. Veremos un caso en el que los bloques múltiples "
"son\n"
"útiles en el [Capítulo 7](ch07-00-generic-types-and-traits.md), donde "
"hablamos de tipos genéricos y traits."

#: src/ch05-03-method-syntax.md:288
#, fuzzy
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `trait` and `impl` "
"blocks, you can define methods, which are functions associated to a type and "
"let you specify the behavior that instances of your type have."
msgstr ""
"Las estructuras permiten crear tipos personalizados que son significativos "
"para su dominio. \n"
"Usando estructuras, puede mantener partes de datos asociadas conectadas "
"entre sí y nombra \n"
"cada pieza para que tu código quede claro. En los bloques `trait` e `impl`, "
"puedes definir métodos, \n"
"que son funciones asociadas a un tipo y le permiten especificar el "
"comportamiento que las instancias \n"
"de su tipo pueden tener."

#: src/ch05-03-method-syntax.md:294
#, fuzzy
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""
"Pero las estructuras (`struct`) no son la única manera de crear tipos "
"personalizados: \n"
"pasemos a la función de enumeración (`enum`) de Cairo para agregar otra "
"herramienta."

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Los Enums, abreviatura de \"enumeraciones\", son una forma de definir un "
"tipo de datos personalizado que consiste en un conjunto fijo de valores "
"nombrados, llamados _variantes_. Los enums son útiles para representar una "
"colección de valores relacionados donde cada valor es distinto y tiene un "
"significado específico."

#: src/ch06-01-enums.md:5
#, fuzzy
msgid "Enum Variants and Values"
msgstr "## Variantes y Valores de Enum"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "Aquí hay un ejemplo sencillo de un enum:"

#: src/ch06-01-enums.md:19
#, fuzzy
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""
"A diferencia de otros lenguajes como Rust, cada variante tiene un tipo. En "
"este ejemplo, hemos definido un enum llamado `Direction` con cuatro "
"variantes: `North`, `East`, `South` y `West`. La convención de nomenclatura "
"es utilizar PascalCase para las variantes del enum. Cada variante representa "
"un valor distinto del tipo `Direction` y está asociada con un tipo unitario "
"`()`. Una variante puede ser instanciada utilizando esta sintaxis:"

#: src/ch06-01-enums.md:37
#, fuzzy
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""
"Es fácil escribir código que se comporte de manera diferente según la "
"variante de una instancia de enum, en este ejemplo para ejecutar código "
"específico según una dirección (`Direction`). Puedes obtener más información "
"al respecto en la página [La construcción de flujo de control Match](ch05-02-"
"the-match-control-flow-construct.md)."

#: src/ch06-01-enums.md:39
#, fuzzy
msgid "Enums Combined with Custom Types"
msgstr "## Enums combinados con Tipos Personalizados"

#: src/ch06-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr ""
"Los enums también pueden ser utilizados para almacenar datos más "
"interesantes asociados con cada variante. Por ejemplo:"

#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""
"En este ejemplo, el enum `Message` tiene tres variantes: `Quit`, `Echo` y "
"`Move`, todas con tipos diferentes:"

#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr ""

#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr ""

#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr ""

#: src/ch06-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr ""
"Incluso puedes usar una estructura o otro enum que hayas definido dentro de "
"una de las variantes de tu enum."

#: src/ch06-01-enums.md:60
#, fuzzy
msgid "Trait Implementations for Enums"
msgstr "## Implementaciones de Traits para Enums"

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"En Cairo, puedes definir traits e implementarlos para tus enums "
"personalizados. Esto te permite definir métodos y comportamientos asociados "
"con el enum. Aquí hay un ejemplo de cómo definir un trait e implementarlo "
"para el enum `Message` anterior:"

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""
"En este ejemplo, implementamos el trait `Processing` para `Message`. Así es "
"cómo podría ser utilizado para procesar un mensaje Quit:"

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr "Al ejecutar este código se imprimiría `quitting`."

#: src/ch06-01-enums.md:114
#, fuzzy
msgid "The Option Enum and Its Advantages"
msgstr "## El Enum Option y sus Ventajas"

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"El enum Option es un enum estándar en Cairo que representa el concepto de un "
"valor opcional. Tiene dos variantes: `Some: T` y `None: ()`. `Some: T` "
"indica que hay un valor de tipo `T`, mientras que `None` representa la "
"ausencia de un valor."

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""
"El enum `Option` es útil porque te permite representar explícitamente la "
"posibilidad de que un valor esté ausente, lo que hace que tu código sea más "
"expresivo y fácil de entender. Usar `Option` también puede ayudar a prevenir "
"errores causados por el uso de valores `null` no inicializados o inesperados."

#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""
"Para darte un ejemplo, aquí hay una función que devuelve el índice del "
"primer elemento de un arreglo con un valor dado, o `None` si el elemento no "
"está presente."

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr "Estamos demostrando dos enfoques para la función anterior:"

#: src/ch06-01-enums.md:131
#, fuzzy
msgid "Recursive Approach `find_value_recursive`"
msgstr ""
"- Método recursivo `find_value_recursive`\n"
"- Método iterativo find_value_iterative"

#: src/ch06-01-enums.md:132
#, fuzzy
msgid "Iterative Approach `find_value_iterative`"
msgstr ""
"- Método recursivo `find_value_recursive`\n"
"- Método iterativo find_value_iterative"

#: src/ch06-01-enums.md:134
#, fuzzy
msgid ""
"Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr ""
"> Nota: en el futuro sería bueno reemplazar este ejemplo con algo más simple "
"que use un ciclo y sin código relacionado con el gas."

#: src/ch06-01-enums.md:202
msgid "Running this code would print `it worked`."
msgstr "Al ejecutar este código se imprimiría `it worked`."

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of match "
"comes from the expressiveness of the patterns and the fact that the compiler "
"confirms that all possible cases are handled."
msgstr ""
"Cairo tiene una construcción de control de flujo extremadamente poderosa "
"llamada `match` que te permite comparar un valor con una serie de patrones y "
"luego ejecutar código basado en el patrón que coincide. Los patrones pueden "
"estar compuestos por valores literales, nombres de variables, comodines y "
"muchas otras cosas. El poder de `match` proviene de la expresividad de los "
"patrones y del hecho de que el compilador confirma que se manejan todos los "
"casos posibles."

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"Piensa en una expresión `match` como una máquina clasificadora de monedas: "
"las monedas se deslizan por una pista con agujeros de diferentes tamaños a "
"lo largo de ella, y cada moneda cae por el primer agujero que encuentra en "
"el que encaja. De la misma manera, los valores pasan por cada patrón en un "
"`match`, y en el primer patrón en el que el valor \"encaja\", el valor cae "
"en el bloque de código asociado para ser utilizado durante la ejecución."

#: src/ch06-02-the-match-control-flow-construct.md:9
#, fuzzy
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a "
"function that takes an unknown US coin and, in a similar way as the counting "
"machine, determines which coin it is and returns its value in cents, as "
"shown in Listing 6-3."
msgstr ""
"Hablando de monedas, ¡usemoslas como ejemplo con `match`! Podemos escribir "
"una función que toma una moneda de EE. UU. desconocida y, de manera similar "
"a la máquina de contar, determina qué moneda es y devuelve su valor en "
"centavos, como se muestra en el Listado 5-3."

#: src/ch06-02-the-match-control-flow-construct.md:29
#, fuzzy
msgid ""
"Listing 6-3: An enum and a match expression that has the variants of the "
"enum as its patterns"
msgstr ""
"Listado 5-3: Un enum y una expresión `match` que tiene las variantes del "
"enum como sus patrones"

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list "
"the `match` keyword followed by an expression, which in this case is the "
"value `coin`. This seems very similar to a conditional expression used with "
"if, but there’s a big difference: with if, the condition needs to evaluate "
"to a Boolean value, but here it can be any type. The type of coin in this "
"example is the `Coin` enum that we defined on the first line."
msgstr ""
"Desglosemos el `match` en la función `value_in_cents`. Primero enumeramos la "
"palabra clave `match` seguida de una expresión, que en este caso es el valor "
"`coin`. Esto parece muy similar a una expresión condicional utilizada con "
"`if`, pero hay una gran diferencia: con `if`, la condición debe evaluarse a "
"un valor booleano, pero aquí puede ser de cualquier tipo. El tipo de moneda "
"en este ejemplo es el enum `Coin` que definimos en la primera línea."

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny(_)` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""
"A continuación, están los brazos del `match`. Un brazo tiene dos partes: un "
"patrón y algún código. El primer brazo aquí tiene un patrón que es el valor "
"`Coin::Penny(_)` y luego el operador `=>` que separa el patrón y el código a "
"ejecutar. El código en este caso es simplemente el valor `1`. Cada brazo "
"está separado del siguiente con una coma."

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in order. If a pattern matches the value, "
"the code associated with that pattern is executed. If that pattern doesn’t "
"match the value, execution continues to the next arm, much as in a coin-"
"sorting machine. We can have as many arms as we need: in the above example, "
"our match has four arms."
msgstr ""
"Cuando se ejecuta la expresión `match`, compara el valor resultante con el "
"patrón de cada brazo, en orden. Si un patrón coincide con el valor, se "
"ejecuta el código asociado con ese patrón. Si ese patrón no coincide con el "
"valor, la ejecución continúa con el siguiente brazo, como en una máquina "
"clasificadora de monedas. Podemos tener tantos brazos como necesitemos: en "
"el ejemplo anterior, nuestro `match` tiene cuatro brazos."

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr ""
"En Cairo, el orden de los brazos debe seguir el mismo orden que el enum."

#: src/ch06-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""
"El código asociado con cada brazo es una expresión, y el valor resultante de "
"la expresión en el brazo coincidente es el valor que se devuelve para toda "
"la expresión match."

#: src/ch06-02-the-match-control-flow-construct.md:41
#, fuzzy
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it "
"is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a match arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"Normalmente no usamos llaves si el código del brazo del `match` es corto, "
"como en nuestro ejemplo donde cada brazo simplemente devuelve un valor. Si "
"desea ejecutar varias líneas de código en un brazo del `match`, debe usar "
"llaves, con una coma después del brazo. Por ejemplo, el siguiente código "
"imprime \"¡Moneda de la suerte!\" cada vez que se llama al método con una "
"`Coin::Penny(())`, pero aún devuelve el último valor del bloque, `1`:"

#: src/ch06-02-the-match-control-flow-construct.md:57
#, fuzzy
msgid "Patterns That Bind to Values"
msgstr "## Patrones que se Vinculan con Valores"

#: src/ch06-02-the-match-control-flow-construct.md:59
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""
"Otra característica útil de los brazos de coincidencia es que pueden "
"vincularse con las partes de los valores que coinciden con el patrón. Así es "
"como podemos extraer valores de las variantes de una enum."

#: src/ch06-02-the-match-control-flow-construct.md:61
#, fuzzy
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-4."
msgstr ""
"Como ejemplo, cambiemos una de nuestras variantes de enum para que contenga "
"datos en su interior. Desde 1999 hasta 2008, la Casa de la Moneda de los "
"Estados Unidos acuñó monedas de 25 centavos con diseños diferentes para cada "
"uno de los 50 estados en un lado. Ninguna otra moneda tenía diseños "
"estatales, por lo que solo los cuartos tienen este valor adicional. Podemos "
"agregar esta información a nuestra `enum` cambiando la variante `Quarter` "
"para incluir un valor `UsState` almacenado en su interior, lo cual hemos "
"hecho en la Lista 5-4."

#: src/ch06-02-the-match-control-flow-construct.md:79
#, fuzzy
msgid ""
"Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr ""
"Listado 5-4: Un enum `Coin` en el que la variante `Quarter` también tiene un "
"valor `UsState`"

#: src/ch06-02-the-match-control-flow-construct.md:81
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"Imaginemos que un amigo está tratando de recolectar todas las 50 monedas de "
"cuarto de estado. Mientras clasificamos nuestro cambio suelto por tipo de "
"moneda, también llamaremos el nombre del estado asociado con cada cuarto "
"para que si es uno que nuestro amigo no tiene, puedan agregarlo a su "
"colección."

#: src/ch06-02-the-match-control-flow-construct.md:83
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"En la expresión `match` de este código, agregamos una variable llamada "
"`state` al patrón que coincide con los valores de la variante `Coin::"
"Quarter`. Cuando se hace una coincidencia de `Coin::Quarter`, la variable "
"`state` se vinculará al valor del estado de ese cuarto. Luego podemos usar "
"`state` en el código para ese brazo, así:"

#: src/ch06-02-the-match-control-flow-construct.md:99
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an "
"implementation for the `print` function for the `debug::PrintTrait`:"
msgstr ""
"Para imprimir el valor de una variante de un enum en Cairo, necesitamos "
"agregar una implementación para la función `print` de `debug::PrintTrait`:"

#: src/ch06-02-the-match-control-flow-construct.md:112
#, fuzzy
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach `Coin::"
"Quarter(state)`. At that point, the binding for state will be the value "
"`UsState::Alaska`. We can then use that binding in the `PrintTrait`, thus "
"getting the inner state value out of the `Coin` enum variant for `Quarter`."
msgstr ""
"Si llamáramos a `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, `coin` "
"sería `Coin::Quarter(UsState::Alaska())`. Cuando comparamos ese valor con "
"cada uno de los brazos del `match`, ninguno coincide hasta que llegamos a "
"`Coin::Quarter (state)`. En ese momento, la asignación para `state` será el "
"valor `UsState::Alaska()`. Luego podemos usar esa asignación en el "
"`PrintTrait`, obteniendo así el valor interno de estado fuera de la variante "
"`Coin` para `Quarter`."

#: src/ch06-02-the-match-control-flow-construct.md:114
#, fuzzy
msgid "Matching with Options"
msgstr "## Coincidencia Con Opciones"

#: src/ch06-02-the-match-control-flow-construct.md:116
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same. You can use Options by importing the `option::"
"OptionTrait` trait."
msgstr ""
"En la sección anterior, queríamos obtener el valor interno `T` fuera del "
"caso `Some` al usar `Option<T>`; ¡también podemos manejar `Option<T>` usando "
"`match`, como lo hicimos con el `enum` `Coin`! En lugar de comparar monedas, "
"compararemos las variantes de `Option<T>`, pero la forma en que funciona la "
"expresión `match` sigue siendo la misma. Puedes usar opciones importando el "
"trait `option::OptionTrait`."

#: src/ch06-02-the-match-control-flow-construct.md:118
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""
"Digamos que queremos escribir una función que tome una `Opción<u8>` y, si "
"hay un valor dentro, añada `1` a ese valor. Si no hay ningún valor dentro, "
"la función debería devolver el valor `None` y no intentar realizar ninguna "
"operación."

#: src/ch06-02-the-match-control-flow-construct.md:120
#, fuzzy
msgid ""
"This function is very easy to write, thanks to match, and will look like "
"Listing 6-5."
msgstr ""
"Esta función es muy fácil de escribir, gracias a `match`, y se verá como en "
"el listado 5-5."

#: src/ch06-02-the-match-control-flow-construct.md:141
#, fuzzy
msgid "Listing 6-5: A function that uses a match expression on an `Option<u8>`"
msgstr ""
"Listado 5-5: Una función que usa una expresión `match` en un `Option<u8>`"

#: src/ch06-02-the-match-control-flow-construct.md:144
msgid ""
"Note that your arms must respect the same order as the enum defined in the "
"`OptionTrait` of the core Cairo lib."
msgstr ""
"Tenga en cuenta que los brazos (`arms`) deben respetar el mismo orden que el "
"enum definido en `OptionTrait` de la librería central de Cairo."

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""
"Examinemos más detalladamente la primera ejecución de `plus_one`. Cuando "
"llamamos a `plus_one(five)`, la variable `x` en el cuerpo de `plus_one` "
"tendrá el valor `Some(5)`. Luego comparamos eso con cada rama del `match`:"

#: src/ch06-02-the-match-control-flow-construct.md:159
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in `Option::"
"Some`, so `val` takes the value `5`. The code in the match arm is then "
"executed, so we add `1` to the value of `val` and create a new `Option::"
"Some` value with our total `6` inside. Because the first arm matched, no "
"other arms are compared."
msgstr ""
"¿El valor `Option::Some(5)` coincide con el patrón `Option::Some(val)`? ¡Sí "
"lo hace! Tenemos la misma variante. El `val` se enlaza al valor contenido en "
"`Option::Some`, por lo que `val` toma el valor `5`. Luego se ejecuta el "
"código en el brazo del `match`, por lo que sumamos `1` al valor de `val` y "
"creamos un nuevo valor `Option::Some` con nuestro total `6` en su interior. "
"Debido a que el primer brazo coincide, no se comparan los demás brazos."

#: src/ch06-02-the-match-control-flow-construct.md:161
#, fuzzy
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None`. We enter the match and compare to the first arm:"
msgstr ""
"Ahora consideremos la segunda llamada de `plus_one` en nuestra función "
"principal, donde `x` es `Option::None(())`. Entramos en el `match` y "
"comparamos con el primer brazo:"

#: src/ch06-02-the-match-control-flow-construct.md:167
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""
"El valor `Option::Some(5_u8)` no coincide con el patrón `Option::None`, así "
"que continuamos con el siguiente brazo:"

#: src/ch06-02-the-match-control-flow-construct.md:173
#, fuzzy
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`Option::None` value on the right side of `=>`."
msgstr ""
"¡Coincide! No hay valor al que agregar, por lo que el programa se detiene y "
"devuelve el valor `Option::None(())` en el lado derecho de `=>`."

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"Combinar `match` y enumeraciones es útil en muchas situaciones. Verás este "
"patrón mucho en el código de Cairo: `match` contra una enumeración, enlaza "
"una variable con los datos internos y luego ejecuta código basado en ella. "
"Es un poco complicado al principio, pero una vez que te acostumbras, "
"desearás tenerlo en todos los lenguajes. Es consistentemente favorito de los "
"usuarios."

#: src/ch06-02-the-match-control-flow-construct.md:177
#, fuzzy
msgid "Matches Are Exhaustive"
msgstr "## Los Matches Son Exhaustivos"

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""
"Hay otro aspecto de los matches que necesitamos discutir: los patrones de "
"los brazos deben cubrir todas las posibilidades. Considera esta versión de "
"nuestra función `plus_one`, que tiene un error y no se compilará:"

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""
"Cairo sabe que no cubrimos todos los casos posibles, ¡e incluso sabe qué "
"patrón olvidamos! Los matches en Cairo son exhaustivos: debemos cubrir todas "
"las posibilidades para que el código sea válido. Especialmente en el caso de "
"`Option<T>`, cuando Cairo nos impide olvidar manejar explícitamente el caso "
"`None`, nos protege de asumir que tenemos un valor cuando podríamos tener "
"nulo, lo que hace imposible el error de mil millones de dólares discutido "
"anteriormente."

#: src/ch06-02-the-match-control-flow-construct.md:201
#, fuzzy
msgid "Match 0 and the \\_ Placeholder"
msgstr "## Match 0 y el Comodín \\_"

#: src/ch06-02-the-match-control-flow-construct.md:203
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. Currently only `0` and the "
"`_`operator are supported."
msgstr ""
"Usando enums, también podemos tomar acciones especiales para algunos valores "
"particulares, pero para todos los demás valores tomar una acción "
"predeterminada. Actualmente solo se admiten `0` y el operador `_`."

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 "
"and 7. If you have 0, you win. For all other values you lose. Here's a match "
"that implements that logic, with the number hardcoded rather than a random "
"value."
msgstr ""
"Imaginemos que estamos implementando un juego en el que obtienes un número "
"aleatorio entre 0 y 7. Si tienes 0, ganas. Para todos los demás valores, "
"pierdes. Aquí hay un `match` que implementa esa lógica, con el número "
"codificado en lugar de ser un valor aleatorio."

#: src/ch06-02-the-match-control-flow-construct.md:216
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that "
"covers every other possible value, the pattern is the character `_`. This "
"code compiles, even though we haven’t listed all the possible values a "
"`felt252` can have, because the last pattern will match all values not "
"specifically listed. This catch-all pattern meets the requirement that "
"`match` must be exhaustive. Note that we have to put the catch-all arm last "
"because the patterns are evaluated in order. If we put the catch-all arm "
"earlier, the other arms would never run, so Cairo will warn us if we add "
"arms after a catch-all!"
msgstr ""
"Para el primer brazo, el patrón es el valor literal 0. Para el último brazo, "
"que cubre todos los demás valores posibles, el patrón es el carácter `_`. "
"Este código compila, aunque no hayamos enumerado todos los valores posibles "
"que puede tener `felt252`, porque el último patrón coincidirá con todos los "
"valores no enumerados específicamente. Este patrón catch-all cumple el "
"requisito de que `match` debe ser exhaustivo. Tenga en cuenta que tenemos "
"que poner la rama catch-all en último lugar porque los patrones se evalúan "
"en orden. Si pusiéramos el brazo catch-all antes, los otros brazos nunca se "
"ejecutarían, ¡así que Cairo nos avisará si añadimos brazos después de un "
"catch-all!"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
#, fuzzy
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"A medida que escriba programas grandes, la organización de su código se "
"volverá cada \n"
"vez más importante. Al agrupar funcionalidades relacionadas y separar el "
"código con \n"
"características distintas, aclarará dónde encontrar el código que implementa "
"una característica\n"
" en particular y dónde ir para cambiar cómo funciona una característica."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
#, fuzzy
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"Los programas que hemos escrito hasta ahora han estado en un módulo en un "
"archivo. A medida que\n"
"proyecto crece, debe organizar el código dividiéndolo en varios módulos\n"
"y luego en varios archivos. A medida que un paquete crece, puede extraer "
"partes en\n"
"cajas separadas que se convierten en dependencias externas. Este capítulo "
"cubre todas\n"
"estas técnicas."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
#, fuzzy
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""
"También discutiremos la encapsulación de detalles de implementación, lo que "
"le \n"
"permite reutilizar el código a un nivel superior: una vez que ha "
"implementado una\n"
" operación, otro código puede llamar a su código sin tener que saber cómo "
"funciona \n"
"la implementación."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
#, fuzzy
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"Un concepto relacionado es el ámbito: el contexto anidado en el que se "
"escribe el \n"
"código tiene un conjunto de nombres que se definen como \"en ámbito\". Al "
"leer, escribir \n"
"y compilar código, los programadores y compiladores deben saber si un nombre "
"particular \n"
"en un lugar particular se refiere a una variable, función, estructura, "
"enumeración, módulo, \n"
"constante u otro elemento y qué significa ese elemento. Puede crear ámbitos "
"y cambiar \n"
"qué nombres están dentro o fuera de ámbito. No puede tener dos elementos con "
"el mismo nombre en el mismo ámbito."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
#, fuzzy
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""
"Cairo tiene varias características que le permiten gestionar la organización "
"de \n"
"su código. Estas características, a veces denominadas colectivamente el "
"_sistema de módulos_,\n"
" incluyen:"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
#, fuzzy
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"En este capítulo, cubriremos todas estas características, discutiremos cómo "
"interactúan, y\n"
"cómo utilizarlas para gestionar el alcance. Al final, ¡Deberías tener una "
"sólida\n"
"comprensión del sistema de módulos y serás capaz de trabajar con ámbitos "
"como un profesional!"

#: src/ch07-01-packages-and-crates.md:3
#, fuzzy
msgid "What is a crate?"
msgstr "## ¿Qué es un Crate?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a "
"single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""
"Un crate es la cantidad más pequeña de código que el compilador de Cairo "
"considera a la vez. Incluso si ejecuta `cairo-compile` en lugar de `scarb "
"build` y pasa un solo archivo de código fuente, el compilador considera que "
"ese archivo es un crate. Los crates pueden contener módulos, y los módulos "
"pueden estar definidos en otros archivos que se compilan junto con el crate, "
"como se discutirá en las secciones siguientes."

#: src/ch07-01-packages-and-crates.md:7
#, fuzzy
msgid "What is the crate root?"
msgstr "## ¿Qué es la Raíz del Crate?"

#: src/ch07-01-packages-and-crates.md:9
#, fuzzy
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts "
"from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control Scope”](./ch07-02-defining-"
"modules-to-control-scope.md) section)."
msgstr ""
"La raíz del crate es el fichero fuente `lib.cairo` desde el que arranca el "
"compilador de Cairo y constituye el módulo raíz de tu crate (explicaremos "
"los módulos en profundidad en la sección [\"Definición de módulos para "
"controlar el alcance\"](./ch06-02-defining-modules-to-control-scope.md) "
"section)."

#: src/ch07-01-packages-and-crates.md:11
#, fuzzy
msgid "What is a package?"
msgstr "## ¿Qué es un Paquete?"

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code "
"into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr ""
"Un paquete de Cairo es un conjunto de uno o más crates con un archivo Scarb."
"toml que describe cómo construir esos crates. Esto permite la división del "
"código en partes más pequeñas y reutilizables, y facilita la gestión de "
"dependencias más estructurada."

#: src/ch07-01-packages-and-crates.md:15
#, fuzzy
msgid "Creating a Package with Scarb"
msgstr "## Creación de un Paquete con Scarb"

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""
"Puede crear un nuevo paquete de Cairo utilizando la herramienta de línea de "
"comandos scarb. Para crear un nuevo paquete, ejecute el siguiente comando:"

#: src/ch07-01-packages-and-crates.md:23
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr ""
"Este comando generará un nuevo directorio de paquete llamado my_crate con la "
"siguiente estructura:"

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"`src/` is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr ""

#: src/ch07-01-packages-and-crates.md:33
msgid ""
"`lib.cairo` is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr ""

#: src/ch07-01-packages-and-crates.md:34
#, fuzzy
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"- `src/` es el directorio principal donde se almacenarán todos los archivos "
"de origen de Cairo para el paquete.\n"
"- `lib.cairo` es el módulo raíz predeterminado del crate, que también es el "
"punto de entrada principal del paquete. Por defecto, está vacío.\n"
"- `Scarb.toml` es el archivo de manifiesto del paquete, que contiene "
"metadatos y opciones de configuración para el paquete, como dependencias, "
"nombre del paquete, versión y autores. Puede encontrar documentación al "
"respecto en la [referencia de Scarb](https://docs.swmansion.com/scarb/docs/"
"reference/manifest.html)."

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo` "
"files within the `src` directory or its subdirectories."
msgstr ""
"A medida que desarrolla su paquete, es posible que desee organizar su código "
"en varios archivos de origen de Cairo. Puede hacer esto creando archivos `."
"cairo` adicionales dentro del directorio `src` o sus subdirectorios."

#: src/ch07-02-defining-modules-to-control-scope.md:3
#, fuzzy
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""
"En esta sección, hablaremos sobre los módulos y otras partes del sistema de "
"módulos, \n"
"como las _rutas_ que le permiten nombrar elementos y la palabra clave "
"`use` \n"
"que introduce una ruta en el ámbito."

#: src/ch07-02-defining-modules-to-control-scope.md:7
#, fuzzy
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr ""
"Primero, vamos a comenzar con una lista de reglas para su fácil referencia \n"
"cuando esté organizando su código en el futuro. Luego explicaremos cada "
"una \n"
"de las reglas en detalle."

#: src/ch07-02-defining-modules-to-control-scope.md:11
#, fuzzy
msgid "Modules Cheat Sheet"
msgstr "### Hoja de Trucos de Módulos"

#: src/ch07-02-defining-modules-to-control-scope.md:13
#, fuzzy
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr ""
"Aquí ofrecemos una referencia rápida sobre cómo funcionan los módulos, las "
"rutas y la palabra clave use\n"
"y cómo la mayoría de los desarrolladores organizan su código.\n"
"código. Veremos ejemplos de cada una de estas reglas a lo largo de este\n"
"capítulo, pero este es un buen lugar para recordar cómo funcionan los "
"módulos.\n"
"funcionan. Puede crear un nuevo proyecto Scarb con `scarb new backyard` para "
"seguirlo."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden;`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in _src/"
"garden.cairo_. The compiler will look for the submodule’s code within the "
"directory named for the parent module in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at `backyard::garden::vegetables::"
"Asparagus`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:63
#, fuzzy
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""
"Aquí creamos un paquete llamado `backyard` que ilustra estas reglas. El \n"
"directorio del paquete, también llamado `backyard`, contiene estos archivos "
"y directorios:"

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr ""
"El archivo raíz de la caja en este caso es _src/lib.cairo_, y contiene:"

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr ""
"La línea `mod garden;` le indica al compilador que incluya el código que "
"encuentra en _src/garden.cairo_, que es:"

#: src/ch07-02-defining-modules-to-control-scope.md:92
#, fuzzy
msgid "Filename: src/garden.cairo"
msgstr "<span class=\"filename\">Filename: src/garden.cairo</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:98
#, fuzzy
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is "
"included too. That code is:"
msgstr ""
"Aquí, `mod vegetables;` significa que el código en _src/garden/vegetables."
"cairo_ también está incluido. Ese código es:"

#: src/ch07-02-defining-modules-to-control-scope.md:106
#, fuzzy
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the "
"`Asparagus` type into scope, so we can use it in the `main` function."
msgstr ""
"La línea `use garden::vegetables::Asparagus;` nos permite traer el tipo "
"`Asparagus` al ámbito de alcance, \n"
"para que podamos usarlo en la función `main`."

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""
"¡Ahora vamos a entrar en los detalles de estas reglas y demostrarlas en "
"acción!"

#: src/ch07-02-defining-modules-to-control-scope.md:111
#, fuzzy
msgid "Grouping Related Code in Modules"
msgstr "### Agrupando el Código Relacionado en Módulos"

#: src/ch07-02-defining-modules-to-control-scope.md:113
#, fuzzy
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. As an example, let’s write a library crate that provides the "
"functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, "
"rather than the implementation of a restaurant."
msgstr ""
"_Los módulos_ nos permiten organizar el código dentro de un paquete para "
"hacerlo más legible y fácil de reutilizar. \n"
"Como ejemplo, escribiremos un paquete de biblioteca que proporcione la "
"funcionalidad de un \n"
"restaurante. Definiremos las firmas de las funciones pero dejaremos sus "
"cuerpos \n"
"vacíos para concentrarnos en la organización del código, en lugar de \n"
"en la implementación de un restaurante."

#: src/ch07-02-defining-modules-to-control-scope.md:119
#, fuzzy
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""
"En la industria de la restauración, algunas partes de un restaurante se "
"denominan \n"
"_front of house_ (delante de la casa) y otras como _back of house_. Front of "
"house es donde \n"
"están los clientes; esto abarca desde donde los anfitriones sientan a los "
"clientes, los servidores toman \n"
"órdenes y pagos, y los barman hacen bebidas. Back of house es donde los \n"
"chefs y cocineros trabajan en la cocina, los lavaplatos limpian y los "
"gerentes hacen\n"
" trabajo administrativo."

#: src/ch07-02-defining-modules-to-control-scope.md:126
#, fuzzy
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named `restaurant` by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""
"Para estructurar nuestro paquete de esta manera, podemos organizar sus "
"funciones en módulos \n"
"anidados. Cree un nuevo paquete llamado `restaurant` ejecutando el comando "
"`scarb new restaurant`; luego ingrese el código en el Listado 6-1 en _src/"
"lib.cairo_ para definir algunos módulos y firmas de funciones. Aquí está la "
"sección de front of house:"

#: src/ch07-02-defining-modules-to-control-scope.md:150
#, fuzzy
msgid ""
"Listing 7-1: A `front_of_house` module containing other modules that then "
"contain functions"
msgstr ""
"<span class=\"caption\">Listado 6-1: Un módulo `front_of_house` que contiene "
"otros \n"
"módulos que a su vez contienen funciones</span>"

#: src/ch07-02-defining-modules-to-control-scope.md:153
#, fuzzy
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 6-1—functions."
msgstr ""
"Definimos un módulo con la palabra clave `mod` seguida del nombre del "
"módulo \n"
"(en este caso, `front_of_house`). El cuerpo del módulo va entre \n"
"llaves. Dentro de los módulos, podemos colocar otros módulos, como en este "
"caso con los \n"
"módulos `hosting` y `serving`. Los módulos también pueden contener "
"definiciones de otros\n"
" elementos, como structs, enums, constantes, traits y, como en el Listado \n"
"6-1, funciones."

#: src/ch07-02-defining-modules-to-control-scope.md:160
#, fuzzy
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""
"Al utilizar módulos, podemos agrupar las definiciones relacionadas y darles "
"un nombre que \n"
"indique por qué están relacionadas. Los programadores que usan este código "
"pueden navegar por el código en función de los \n"
"grupos en lugar de tener que leer todas las definiciones, lo que hace que "
"sea más fácil \n"
"encontrar las definiciones relevantes para ellos. Los programadores que "
"agregan nueva funcionalidad \n"
"a este código sabrían dónde colocar el código para mantener el programa "
"organizado."

#: src/ch07-02-defining-modules-to-control-scope.md:166
#, fuzzy
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""
"Anteriormente, mencionamos que _src/lib.cairo_ se llama raíz de la \n"
"caja. La razón de este nombre es que el contenido de este archivo forma un "
"módulo con el nombre de la caja en la raíz de la estructura de módulos de la "
"caja, conocido como el _árbol de módulos_."

#: src/ch07-02-defining-modules-to-control-scope.md:170
#, fuzzy
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr ""
"El Listado 6-2 muestra el árbol de módulos para la estructura en el Listado "
"6-1."

#: src/ch07-02-defining-modules-to-control-scope.md:184
#, fuzzy
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr ""
"El Listado 6-2 muestra el árbol de módulos para la estructura en el Listado "
"6-1."

#: src/ch07-02-defining-modules-to-control-scope.md:187
#, fuzzy
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate `restaurant`."
msgstr ""
"Este árbol muestra cómo algunos módulos se anidan dentro de otros; por "
"ejemplo,\n"
"`hosting` se anida dentro de `front_of_house`. El árbol también muestra que "
"algunos módulos\n"
"son _hermanos_ entre sí, lo que significa que están definidos en el mismo "
"módulo;\n"
"`hosting` y `serving` son hermanos definidos dentro de `front_of_house`. Si "
"el módulo\n"
"A está contenido dentro del módulo B, decimos que el módulo A es el _hijo_ "
"del módulo B\n"
"y que el módulo B es el _padre_ del módulo A. Observa que todo el árbol de "
"módulos \n"
"está enraizado en el nombre explícito del paquete `restaurant`."

#: src/ch07-02-defining-modules-to-control-scope.md:195
#, fuzzy
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""
"El árbol de módulos podría recordarte al árbol de directorios del sistema "
"de \n"
"archivos en tu computadora; ¡esta es una comparación muy adecuada! Al igual "
"que los directorios \n"
"en un sistema de archivos, utilizamos los módulos para organizar nuestro "
"código. Y al igual que los archivos en un directorio, necesitamos\n"
" una manera de encontrar nuestros módulos."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""
"Para indicarle a Cairo dónde encontrar un elemento en el árbol de módulos, "
"usamos un camino de la misma forma que usamos una ruta al navegar por un "
"sistema de archivos. Para llamar a una función, necesitamos conocer su "
"camino."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Un camino puede tomar dos formas:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
#, fuzzy
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"Para ilustrar esta noción, tomemos de nuevo nuestro ejemplo del restaurante "
"que usamos en el último capítulo. Tenemos un crate llamado `restaurant` en "
"el cual tenemos un módulo llamado `front_of_house` que contiene un módulo "
"llamado `hosting`. El módulo `hosting` contiene una función llamada "
"`add_to_waitlist`. Queremos llamar a la función `add_to_waitlist` desde la "
"función `eat_at_restaurant`. Necesitamos decirle a Cairo el camino hacia la "
"función `add_to_waitlist` para que pueda encontrarla."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:36
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:37
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:40
msgid "// ✅ Compiles\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:39
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
#, fuzzy
msgid ""
"Listing 7-3: Calling the `add_to_waitlist` function using absolute and "
"relative paths"
msgstr ""
"<span class=\"caption\">Lista 6-3: Llamada a la función `add_to_waitlist` "
"utilizando rutas absolutas y relativas</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
#, fuzzy
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name."
msgstr ""
"La primera vez que llamamos a la función `add_to_waitlist` en "
"`eat_at_restaurant`, \n"
"usamos una ruta absoluta. La función `add_to_waitlist` está definida en la "
"misma \n"
"caja que `eat_at_restaurant`. En Cairo, las rutas absolutas comienzan desde "
"la raíz de la caja, a la cual se refiere usando el nombre de la caja."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
#, fuzzy
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path `./front_of_house/hosting/"
"add_to_waitlist`. Starting with a module name means that the path is "
"relative to the current module."
msgstr ""
"La segunda vez que llamamos a `add_to_waitlist`, usamos una ruta relativa. "
"La ruta comienza con `front_of_house`, el nombre del módulo \n"
"definido en el mismo nivel del árbol de módulos que `eat_at_restaurant`. "
"Aquí, el \n"
"equivalente en el sistema de archivos sería usar la ruta \n"
"`./front_of_house/hosting/add_to_waitlist`. Comenzar con un nombre de módulo "
"significa \n"
"que la ruta es relativa al módulo actual."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
#, fuzzy
msgid "Starting Relative Paths with `super`"
msgstr "### Comenzando Rutas Relativas con `super`"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
#, fuzzy
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on "
"your project, and depends on whether you’re more likely to move item "
"definition code separately from or together with the code that uses the item."
msgstr ""
"Elegir si usar o no `super` es una decisión que tomarás \n"
"basada en tu proyecto y dependerá de si es más probable que muevas el código "
"de \n"
"definición de elementos por separado o junto con el código que usa el "
"elemento."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
#, fuzzy
msgid ""
"Listing 7-4: Calling a function using a relative path starting with super"
msgstr ""
"<span class=\"caption\">Lista 6-4: Llamada a una función utilizando una ruta "
"relativa que empieza por super</span>"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr ""
"Aquí se puede ver directamente que se accede fácilmente a un módulo padre "
"usando `super`, lo que no era el caso anteriormente."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
#, fuzzy
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "# Introducir Rutas con la Palabra Clave `use"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"Tener que escribir las rutas para llamar a las funciones puede resultar "
"incómodo y repetitivo. Afortunadamente, hay una manera de simplificar este "
"proceso: podemos crear un acceso directo a una ruta con la palabra clave "
"`use` una vez, y luego utilizar el nombre más corto en todas partes en el "
"ámbito."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
#, fuzzy
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""
"En el Listado 6-5, incluimos el módulo `restaurant::front_of_house::hosting` "
"en el ámbito de la función\n"
"de la función `eat_at_restaurant` para que sólo tengamos que especificar\n"
"`hosting::add_to_waitlist` para llamar a la función `add_to_waitlist` de\n"
"en `eat_at_restaurant`."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
#, fuzzy
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr ""
"<span class=\"caption\">Listado 6-5: Introducir un módulo en el ámbito con\n"
"`use`</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""
"Añadir use y una ruta en un ámbito es similar a crear un enlace simbólico en "
"el sistema de ficheros. Al añadir `use restaurant::front_of_house::hosting` "
"en la raíz de crate, hosting es ahora un nombre válido en ese ámbito, como "
"si el módulo `hosting` se hubiera definido en la raíz de un crate."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
#, fuzzy
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""
"Ten en cuenta que `use` sólo crea el acceso directo para el ámbito concreto "
"en el que se produce el `use`. El listado 6-6 mueve la función "
"`eat_at_restaurant` a un nuevo módulo hijo llamado\n"
"módulo hijo llamado `customer`, que es un ámbito diferente al de la "
"sentencia `use\n"
"por lo que el cuerpo de la función no compilará:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
#, fuzzy
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr ""
"<span class=\"caption\">Listado 6-6: Una sentencia `use` sólo se aplica en "
"el ámbito\n"
"en el que se encuentra</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
#, fuzzy
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""
"El error del compilador muestra que el acceso directo ya no se aplica dentro "
"del módulo\n"
"módulo `customer`:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
#, fuzzy
msgid "Creating Idiomatic `use` Paths"
msgstr "## Crear Rutas idiomáticas `use`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
#, fuzzy
msgid ""
"In Listing 7-5, you might have wondered why we specified `use restaurant::"
"front_of_house::hosting` and then called `hosting::add_to_waitlist` in "
"`eat_at_restaurant` rather than specifying the `use` path all the way out to "
"the `add_to_waitlist` function to achieve the same result, as in Listing 7-7."
msgstr ""
"En el Listado 6-5, puede que te hayas preguntado por qué especificamos `use\n"
"restaurant::front_of_house::hosting` y luego llamamos a `hosting::"
"add_to_waitlist` en\n"
"en `eat_at_restaurant` en lugar de especificar la ruta `use\n"
"la función `add_to_waitlist` para conseguir el mismo resultado, como en el "
"Listado 6-7."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
#, fuzzy
msgid ""
"Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, "
"which is unidiomatic"
msgstr ""
"<span class=\"caption\">Listado 6-7: Introduciendo la función "
"`add_to_waitlist\n"
"con `use`, que es poco idiomático</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
#, fuzzy
msgid ""
"Although both Listing 7-5 and 6-7 accomplish the same task, Listing 7-5 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-7 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"Aunque tanto el Listado 6-5 como el 6-7 realizan la misma tarea, el Listado "
"6-5 es\n"
"la forma idiomática de traer una función al ámbito con `use`. Traer el\n"
"módulo padre de la función al ámbito con `use` significa que tenemos que "
"especificar el\n"
"módulo padre al llamar a la función. Especificar el módulo padre al\n"
"al llamar a la función deja claro que la función no está definida "
"localmente\n"
"a la vez que minimiza la repetición de la ruta completa. El código del "
"Listado 6-7 es\n"
"no está claro dónde está definido `add_to_waitlist`."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
#, fuzzy
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-8 shows the "
"idiomatic way to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""
"Por otro lado, cuando se introducen structs, enums, traits y otros elementos "
"con `use`,\n"
"es idiomático especificar la ruta completa. El listado 6-8 muestra la forma "
"idiomática\n"
"de traer el trait `ArrayTrait` de la librería core al ámbito."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
#, fuzzy
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr ""
"<span class=\"caption\">Listado 6-8: Introducir `ArrayTrait` en el ámbito de "
"forma\n"
"forma idiomática</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
#, fuzzy
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr ""
"No hay ninguna razón de peso detrás de este modismo: es sólo la convención "
"que ha \n"
"surgido en la comunidad Rust y la gente se ha acostumbrado a leer y escribir "
"código Rust de esta manera.\n"
"Como Cairo comparte muchos modismos con Rust, nosotros también seguimos esta "
"convención."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
#, fuzzy
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"La excepción a este modismo es si estamos trayendo dos elementos con el "
"mismo nombre\n"
"con sentencias `use`, porque Cairo no lo permite."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
#, fuzzy
msgid "Providing New Names with the `as` Keyword"
msgstr "### Proporcionar nuevos nombres con la Palabra Clave `as`"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
#, fuzzy
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-9 shows how you can "
"rename an import with `as`:"
msgstr ""
"Hay otra solución al problema de meter dos tipos del mismo nombre\n"
"en el mismo ámbito con `use`: después de la ruta, podemos especificar `as` y "
"un nuevo\n"
"nombre local, o _alias_, para el tipo. El listado 6-9 muestra cómo puedes "
"renombrar una importación con `as`:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid "// ArrayTrait was renamed to Arr\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
#, fuzzy
msgid ""
"Listing 7-9: Renaming a trait when it’s brought into scope with the `as` "
"keyword"
msgstr ""
"<span class=\"caption\">Listado 6-9: Renombrar un trait cuando es traído a\n"
"scope con la palabra clave `as`</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""
"En este caso, hemos introducido `ArrayTrait` en el ámbito con el alias "
"`Arr`. Ahora podemos acceder a los métodos del rasgo con el identificador "
"`Arr`."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
#, fuzzy
msgid "Importing multiple items from the same module"
msgstr "### Importar varios elementos desde el mismo módulo"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
#, fuzzy
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr ""
"Cuando quieras importar múltiples elementos (como funciones, structs o "
"enums)\n"
"del mismo módulo en Cairo, puede usar llaves `{}` para listar todos los\n"
"los elementos que desea importar. Esto ayuda a mantener su código limpio y "
"fácil\n"
"de leer evitando una larga lista de sentencias use individuales."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr ""
"La sintaxis general para importar varios elementos del mismo módulo es:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr ""
"He aquí un ejemplo en el que importamos tres estructuras del mismo módulo:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189
#: src/ch08-02-traits-in-cairo.md:186 src/ch08-02-traits-in-cairo.md:190
#: src/ch08-02-traits-in-cairo.md:199
#: src/ch99-03-security-considerations.md:143
#: src/ch99-03-security-considerations.md:148
msgid "// ...\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
#, fuzzy
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr "### Importar varios elementos desde el mismo módulo"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
#, fuzzy
msgid "Re-exporting Names in Module Files"
msgstr "## Re-exportación de Nombres en Archivos de Módulo"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
#, fuzzy
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope."
msgstr ""
"Cuando traemos un nombre al ámbito con la palabra clave `use`, el nombre "
"disponible en\n"
"el nuevo ámbito puede ser importado como si hubiera sido definido en el "
"ámbito de ese código.\n"
"Esta técnica se llama _re-exporting_ porque estamos trayendo un elemento al "
"ámbito,\n"
"pero también haciendo que ese elemento esté disponible para que otros lo "
"introduzcan en su ámbito."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr ""
"Por ejemplo, reexportemos la función `add_to_waitlist` del ejemplo del "
"restaurante:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
#, fuzzy
msgid ""
"Listing 7-11: Making a name available for any code to use from a new scope "
"with `pub use`"
msgstr ""
"<span class=\"caption\">Listado 6-11: Hacer que un nombre esté disponible "
"para que lo use cualquier código\n"
"desde un nuevo ámbito con `pub use`</span>"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
#, fuzzy
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path `restaurant::front_of_house::hosting::"
"add_to_waitlist()`. Now that this `use` has re-exported the `hosting` module "
"from the root module, external code can now use the path `restaurant::"
"hosting::add_to_waitlist()` instead."
msgstr ""
"Antes de este cambio, el código externo tenía que llamar a la función "
"`add_to_waitlist`\n"
"utilizando la ruta\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Ahora que este "
"`use`\n"
"ha reexportado el módulo `hosting` desde el módulo raíz, el código externo\n"
"puede usar la ruta `restaurant::hosting::add_to_waitlist()` en su lugar."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
#, fuzzy
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""
"La Re-exportación es útil cuando la estructura interna de su código es "
"diferente\n"
"de cómo los programadores que llaman a su código pensarían sobre el dominio. "
"En\n"
"ejemplo, en esta metáfora del restaurante, las personas que lo dirigen "
"piensan\n"
"piensan en \"la parte delantera\" y \"la parte trasera\". Pero los clientes "
"que visitan un restaurante\n"
"probablemente no piensen en las partes del restaurante en esos términos. "
"Con\n"
"`use`, podemos escribir nuestro código con una estructura pero exponer una "
"estructura diferente.\n"
"Esto hace que nuestra biblioteca esté bien organizada para los programadores "
"que trabajan \n"
"en ella y para los programadores que la llaman."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
#, fuzzy
msgid "Using External Packages in Cairo with Scarb"
msgstr "## Usando Paquetes Externos en Cairo con Scarb"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr ""
"Puede que necesite utilizar paquetes externos para aprovechar la "
"funcionalidad proporcionada por la comunidad. Para utilizar un paquete "
"externo en su proyecto con Scarb, siga estos pasos:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
#, fuzzy
msgid ""
"The dependencies system is still a work in progress. You can check the "
"official [documentation](https://docs.swmansion.com/scarb/docs/guides/"
"dependencies.html)."
msgstr ""
"> El sistema de dependencias es todavía un trabajo en curso. Puede consultar "
"la [documentación oficial](https://docs.swmansion.com/scarb/docs/guides/"
"dependencies.html)."

#: src/ch07-05-separating-modules-into-different-files.md:3
#, fuzzy
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""
"Hasta ahora, todos los ejemplos de este capítulo definían varios módulos en "
"un solo archivo.\n"
"Cuando los módulos se hacen grandes, es posible que desee mover sus "
"definiciones a una separada\n"
"para facilitar la navegación por el código."

#: src/ch07-05-separating-modules-into-different-files.md:7
#, fuzzy
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""
"Por ejemplo, partamos del código del Listado 6-11 que tenía múltiples\n"
"módulos de restaurante. Extraeremos los módulos en archivos en lugar de "
"tener todos los\n"
"módulos definidos en el archivo raíz del crate. En este caso, el archivo "
"raíz es\n"
"_src/lib.cairo_."

#: src/ch07-05-separating-modules-into-different-files.md:12
#, fuzzy
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-12. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file in Listing 7-13."
msgstr ""
"Primero, extraeremos el módulo `front_of_house` a su propio archivo. Elimina "
"el código\n"
"dentro de las llaves del módulo `front_of_house`, dejando sólo la "
"declaración\n"
"la declaración `mod front_of_house;`, de forma que _src/lib.cairo_ contenga "
"el código\n"
"mostrado en el Listado 6-12. Ten en cuenta que esto no compilará hasta que "
"creemos el módulo\n"
"_src/front_of_house.cairo_ del Listado 6-13."

#: src/ch07-05-separating-modules-into-different-files.md:30
#, fuzzy
msgid ""
"Listing 7-12: Declaring the `front_of_house` module whose body will be in "
"_src/front_of_house.cairo_"
msgstr ""
"<span class=\"caption\">Listado 6-12: Declarando el módulo `front_of_house` "
"cuyo\n"
"cuerpo estará en _src/front_of_house.cairo_</span>"

#: src/ch07-05-separating-modules-into-different-files.md:33
#, fuzzy
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr ""
"A continuación, coloque el código que estaba entre llaves en un nuevo "
"archivo llamado\n"
"_src/front_of_house.cairo_, como se muestra en el Listado 6-13. El "
"compilador sabe que debe buscar\n"
"en este archivo porque se encontró con la declaración del módulo en la raíz "
"del crate\n"
"con el nombre `front_of_house`."

#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
#, fuzzy
msgid "Filename: src/front_of_house.cairo"
msgstr "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:46
#, fuzzy
msgid ""
"Listing 7-13: Definitions inside the `front_of_house` module in _src/"
"front_of_house.cairo_"
msgstr ""
"<span class=\"caption\">Listado 6-13: Definiciones dentro del módulo "
"`front_of_house`\n"
"en _src/front_of_house.cairo_</span>"

#: src/ch07-05-separating-modules-into-different-files.md:49
#, fuzzy
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module Tree”](ch06-03-paths-for-"
"referring-to-an-item-in-the-module-tree.html)"
msgstr ""
"Tenga en cuenta que sólo es necesario cargar un archivo mediante una "
"declaración `mod` _una vez_ en su\n"
"árbol de módulos. Una vez que el compilador sabe que el archivo es parte del "
"proyecto (y sabe\n"
"donde en el árbol de módulos reside el código debido a donde has puesto la "
"declaración `mod`\n"
"), otros archivos en su proyecto debe hacer referencia al código del archivo "
"cargado\n"
"cargado utilizando una ruta hacia el lugar donde se declaró, como se explica "
"en la sección [\"Rutas para Referirse \n"
"a un elemento en el árbol de módulos\"][rutas]<!-- ignorar --> sección. En "
"otras palabras,\n"
"`mod` no es una operación \"include\" que pueda haber visto en otros \n"
"lenguajes de programación."

#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may "
"have seen in other programming languages."
msgstr ""

#: src/ch07-05-separating-modules-into-different-files.md:58
#, fuzzy
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case _src/"
"front_of_house/_."
msgstr ""
"A continuación, extraeremos el módulo `hosting` a su propio archivo. El "
"proceso es un poco diferente\n"
"porque `hosting` es un módulo hijo de `front_of_house`, no del \n"
"módulo raíz. Colocaremos el archivo para `hosting` en un nuevo directorio "
"que será\n"
"nombre de sus antepasados en el árbol de módulos, en este caso _src/"
"front_of_house/_."

#: src/ch07-05-separating-modules-into-different-files.md:63
#, fuzzy
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""
"Para empezar a mover `hosting`, cambiamos _src/front_of_house.cairo_ para "
"que contenga sólo la\n"
"declaración del módulo `hosting`:"

#: src/ch07-05-separating-modules-into-different-files.md:72
#, fuzzy
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""
"Luego creamos un directorio _src/front_of_house_ y un archivo _hosting."
"cairo_ para\n"
"contener las definiciones hechas en el módulo `hosting`:"

#: src/ch07-05-separating-modules-into-different-files.md:75
#, fuzzy
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr ""
"<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"

#: src/ch07-05-separating-modules-into-different-files.md:81
#, fuzzy
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr ""
"Si en su lugar ponemos _hosting.cairo_ en el directorio _src_, el "
"compilador\n"
"esperaría que el código _hosting.cairo_ estuviera en un módulo `hosting` "
"declarado en el crate\n"
"y no declarado como hijo del módulo `front_of_house`. Las reglas del "
"compilador de\n"
"reglas del compilador sobre qué archivos comprobar para qué código de los "
"módulos significa que los\n"
"directorios y archivos se ajustan más al árbol de módulos."

#: src/ch07-05-separating-modules-into-different-files.md:87
#, fuzzy
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""
"Hemos movido el código de cada módulo a un archivo separado, y el árbol de "
"módulos sigue siendo\n"
"el mismo. Las llamadas a funciones en `eat_at_restaurant` funcionarán sin "
"ninguna\n"
"aunque las definiciones estén en archivos diferentes. Esta\n"
"técnica le permite mover módulos a nuevos archivos a medida que crecen en "
"tamaño."

#: src/ch07-05-separating-modules-into-different-files.md:92
#, fuzzy
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in _src/"
"lib.cairo_ also hasn’t changed, nor does `use` have any impact on what files "
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr ""
"Tenga en cuenta que la declaración `use restaurant::front_of_house::hosting` "
"en\n"
"_src/lib.cairo_ tampoco ha cambiado, ni `use` tiene ningún impacto sobre qué "
"archivos\n"
"se compilan como parte de la caja. La palabra clave `mod` declara módulos, y "
"Cairo\n"
"busca en un fichero con el mismo nombre que el módulo el código que va en \n"
"ese módulo."

#: src/ch07-05-separating-modules-into-different-files.md:100
#, fuzzy
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is public by default."
msgstr ""
"Cairo le permite dividir un paquete en múltiples crates y un crate en "
"módulos\n"
"para que pueda referirse a elementos definidos en un módulo desde otro "
"módulo. Puede hacer esto\n"
"esto especificando rutas absolutas o relativas. Estas rutas pueden ser\n"
"con una sentencia `use` para que pueda utilizar una ruta más corta para "
"múltiples usos\n"
"del elemento en ese ámbito. El código del módulo es público por defecto."

#: src/ch08-00-generic-types-and-traits.md:1
#, fuzzy
msgid "Generic Types and Traits"
msgstr "# Tipos Genéricos y Traits"

#: src/ch08-00-generic-types-and-traits.md:3
#, fuzzy
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract stand-"
"ins for concrete types or other properties. We can express the behavior of "
"generics or how they relate to other generics without knowing what will be "
"in their place when compiling and running the code."
msgstr ""
"Cada lenguaje de programación tiene herramientas para manejar eficazmente la "
"duplicación de conceptos. En Cairo, una de esas herramientas son los "
"genéricos: sustitutos abstractos de tipos concretos u otras propiedades. "
"Podemos expresar el comportamiento de los genéricos o cómo se relacionan con "
"otros genéricos sin saber qué habrá en su lugar al compilar y ejecutar el "
"código."

#: src/ch08-00-generic-types-and-traits.md:5
#, fuzzy
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete type like `u32` or "
"`ContractAddress`."
msgstr ""
"Las funciones, estructuras, enumeraciones y traits pueden incorporar tipos "
"genéricos como parte de su definición en lugar de tipos concretos como `u32` "
"o `ContractAddress`."

#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr ""
"Los genéricos nos permiten reemplazar tipos específicos con un marcador de "
"posición que representa múltiples tipos para eliminar la duplicación de "
"código."

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""
"Para cada tipo concreto que reemplaza a un tipo genérico, el compilador crea "
"una nueva definición, reduciendo el tiempo de desarrollo para el "
"programador, pero la duplicación de código a nivel de compilación todavía "
"existe. Esto puede ser importante si estás escribiendo contratos Starknet y "
"usando un genérico para múltiples tipos que hará que el tamaño del contrato "
"aumente."

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""
"Luego aprenderás cómo usar traits para definir comportamientos de manera "
"genérica. Puedes combinar traits con tipos genéricos para restringir un tipo "
"genérico para que acepte solo aquellos tipos que tienen un comportamiento "
"particular, en lugar de cualquier tipo."

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums, "
"traits, implementations and methods! In this chapter we are going to take a "
"look at how to effectively use generic types with all of them."
msgstr ""
"Usamos genéricos para crear definiciones de elementos, como estructuras y "
"funciones, que luego podemos utilizar con muchos tipos de datos concretos "
"diferentes. En Cairo podemos usar genéricos al definir funciones, structs, "
"enums, traits, implementaciones y métodos. En este capítulo vamos a ver cómo "
"utilizar de manera efectiva los tipos genéricos con todos ellos."

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"Cuando definimos una función que utiliza genéricos, colocamos los genéricos "
"en la firma de la función, donde normalmente especificaríamos los tipos de "
"datos del parámetro y del valor de retorno. Por ejemplo, imaginemos que "
"queremos crear una función que, dados dos `Array` de elementos, devuelva el "
"mayor de ellos. Si necesitamos realizar esta operación para listas de "
"distintos tipos, tendríamos que redefinir la función cada vez. Por suerte "
"podemos implementar la función una vez usando genéricos y pasar a otras "
"tareas."

#: src/ch08-01-generic-data-types.md:10
msgid "// Specify generic type T between the angulars\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:31
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"La función `largest_list` compara dos listas del mismo tipo y devuelve la "
"que tiene más elementos y elimina la otra. Si compilas el código anterior, "
"notarás que fallará con un error diciendo que no hay traits definidos para "
"soltar un array de un tipo genérico. Esto ocurre porque el compilador no "
"tiene forma de garantizar que un `Array<T>` es soltable al ejecutar la "
"función `main`. Para poder soltar un array de `T`, el compilador debe saber "
"primero como soltar `T`. Esto puede solucionarse especificando en la firma "
"de la función `largest_list` que `T` debe implementar el rasgo drop. La "
"definición correcta de la función `largest_list` es la siguiente:"

#: src/ch08-01-generic-data-types.md:49
#, fuzzy
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main` "
"function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""
"La nueva función `largest_list` incluye en su definición el requisito de que "
"cualquier tipo genérico que se coloque allí debe poder eliminarse. La "
"función `main` sigue sin cambios, el compilador es lo suficientemente "
"inteligente como para deducir qué tipo concreto se está utilizando y si "
"implementa el trait `Drop`."

#: src/ch08-01-generic-data-types.md:51
#, fuzzy
msgid "Constraints for Generic Types"
msgstr "### Restricciones para Tipos Genéricos"

#: src/ch08-01-generic-data-types.md:53
#, fuzzy
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function "
"logic."
msgstr ""
"Al definir tipos genéricos, es útil tener información sobre ellos. Saber qué "
"traits implementa un tipo genérico nos permite usarlos de manera más "
"efectiva en la lógica de una función a costa de limitar los tipos genéricos "
"que se pueden usar con la función. Vimos un ejemplo de esto anteriormente al "
"agregar la implementación de `TDrop` como parte de los argumentos genéricos "
"de `largest_list`. Si bien `TDrop` se agregó para cumplir con los requisitos "
"del compilador, también podemos agregar restricciones para beneficiar "
"nuestra lógica de función."

#: src/ch08-01-generic-data-types.md:55
#, fuzzy
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr ""
"Imaginemos que queremos, dado una lista de elementos de algún tipo genérico "
"`T`, encontrar el elemento más pequeño entre ellos. Inicialmente, sabemos "
"que para que un elemento de tipo `T` sea comparable, debe implementar el "
"trait `PartialOrd`. La función resultante sería:"

#: src/ch08-01-generic-data-types.md:58
msgid ""
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:62
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:66
msgid "// The index we will use to move through the list\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:69
msgid "// Iterate through the whole list storing the smallest\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:87
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:93
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we don't require to implement the `Drop` trait for `T` as well. Why it does "
"not compile then?"
msgstr ""
"La función `smallest_element` utiliza un tipo genérico `T` que implementa el "
"trait `PartialOrd`, toma una instantánea de un `Array<T>` como parámetro y "
"devuelve una copia del elemento más pequeño. Debido a que el parámetro es de "
"tipo `@Array<T>`, ya no necesitamos soltarlo al final de la ejecución y por "
"lo tanto no necesitamos implementar el trait `Drop` para `T` también. ¿Por "
"qué entonces no compila?"

#: src/ch08-01-generic-data-types.md:95
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr ""
"Cuando hacemos indexación en `list`, el valor resultante es una instantánea "
"del elemento indexado, a menos que `PartialOrd` esté implementado para `@T` "
"necesitamos deshacer la instantánea del elemento usando `*`. La operación "
"`*` requiere una copia de `@T` a `T`, lo que significa que `T` necesita "
"implementar el trait `Copy`. Después de copiar un elemento de tipo `@T` a "
"`T`, ahora hay variables con tipo `T` que necesitan ser soltadas, lo que "
"requiere que `T` implemente también el trait `Drop`. Debemos entonces "
"agregar la implementación de los traits `Drop` y `Copy` para que la función "
"sea correcta. Después de actualizar la función `smallest_element`, el código "
"resultante sería:"

#: src/ch08-01-generic-data-types.md:115
#, fuzzy
msgid "Structs"
msgstr "## Structs (Estructuras)"

#: src/ch08-01-generic-data-types.md:117
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr ""
"También podemos definir estructuras que usen un parámetro de tipo genérico "
"para uno o más campos usando la sintaxis `<>`, similar a las definiciones de "
"funciones. Primero declaramos el nombre del parámetro de tipo dentro de los "
"corchetes angulares justo después del nombre de la estructura. Luego usamos "
"el tipo genérico en la definición de la estructura donde de otra manera "
"especificaríamos tipos de datos concretos. El siguiente ejemplo de código "
"muestra la definición de `Wallet<T>` que tiene un campo `balance` de tipo "
"`T`."

#: src/ch08-01-generic-data-types.md:131
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr ""
"El código anterior deriva el trait `Drop` para el tipo `Wallet` "
"automáticamente. Es equivalente a escribir el siguiente código:"

#: src/ch08-01-generic-data-types.md:145
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""
"Evitamos el uso de la macro `derive` para la implementación de `Drop` de "
"`Wallet` y en su lugar definimos nuestra propia implementación de "
"`WalletDrop`. Nótese que debemos definir, al igual que en las funciones, un "
"tipo genérico adicional para `WalletDrop` diciendo que `T` también "
"implementa el trait `Drop`. Básicamente estamos diciendo que la estructura "
"`Wallet<T>` es dropeable siempre y cuando `T` también lo sea."

#: src/ch08-01-generic-data-types.md:147
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""
"Finalmente, si queremos añadir un campo a `Wallet` que represente su "
"dirección y queremos que ese campo sea diferente de `T` pero genérico "
"también, podemos simplemente añadir otro tipo genérico entre el `<>`:"

#: src/ch08-01-generic-data-types.md:161
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""
"Añadimos a la definición de la estructura `Wallet` un nuevo tipo genérico "
"`U` y asignamos este tipo al nuevo campo miembro `address`. Observa que el "
"atributo derive del rasgo `Drop` también funciona para `U`."

#: src/ch08-01-generic-data-types.md:165
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""
"Como hicimos con las estructuras, podemos definir enumeraciones para "
"contener tipos de datos genéricos en sus variantes. Por ejemplo, la "
"enumeración `Option<T>` proporcionada por la biblioteca central de Cairo:"

#: src/ch08-01-generic-data-types.md:174
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""
"El enum `Option<T>` es genérico sobre un tipo `T` y tiene dos variantes: "
"`Some`, que contiene un valor de tipo `T`, y `None`, que no contiene ningún "
"valor. Al utilizar el enum `Option<T>`, es posible expresar el concepto "
"abstracto de un valor opcional y debido a que el valor tiene un tipo "
"genérico `T`, podemos utilizar esta abstracción con cualquier tipo."

#: src/ch08-01-generic-data-types.md:176
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""
"Los Enums también pueden utilizar múltiples tipos genéricos, como la "
"definición del enum `Result<T, E>` que proporciona la biblioteca estándar:"

#: src/ch08-01-generic-data-types.md:185 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"El enum `Result<T, E>` tiene dos tipos genéricos, `T` y `E`, y dos "
"variantes: `Ok` que tiene el valor de tipo `T` y `Err` que tiene el valor de "
"tipo `E`. Esta definición hace que sea conveniente usar el enum `Result` en "
"cualquier lugar donde tengamos una operación que pueda tener éxito "
"(devolviendo un valor de tipo `T`) o fallar (devolviendo un valor de tipo "
"`E`)."

#: src/ch08-01-generic-data-types.md:187
#, fuzzy
msgid "Generic Methods"
msgstr "## Métodos Genéricos"

#: src/ch08-01-generic-data-types.md:189
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""
"También podemos implementar métodos en structs y enums, y usar los tipos "
"genéricos en su definición. Utilizando nuestra definición anterior de la "
"struct `Wallet<T>`, definimos un método `balance` para ella:"

#: src/ch08-01-generic-data-types.md:213
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""
"Primero definimos la clase `WalletTrait<T>` usando un tipo genérico `T` que "
"define un método que devuelve una instantánea del campo `balance` de "
"`Wallet`. Luego, damos una implementación de la clase en `WalletImpl<T>`. "
"Ten en cuenta que debes incluir un tipo genérico en ambas definiciones de la "
"clase y la implementación."

#: src/ch08-01-generic-data-types.md:215
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""
"También podemos especificar restricciones en los tipos genéricos al definir "
"métodos en la clase. Por ejemplo, podríamos implementar métodos solo para "
"instancias de `Wallet<u128>` en lugar de `Wallet<T>`. En el ejemplo de "
"código, definimos una implementación para carteras que tienen un tipo "
"concreto de `u128` para el campo `balance`."

#: src/ch08-01-generic-data-types.md:222
msgid "/// Generic trait for wallets\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:233
msgid "/// Trait for wallets of type u128\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:254
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""
"El nuevo método `receive` incrementa el tamaño del saldo de cualquier "
"instancia de una `Wallet<u128>`. Observe que se cambió la función `main` "
"haciendo que `w` sea una variable mutable para que pueda actualizar su "
"saldo. Si cambiáramos la inicialización de `w` cambiando el tipo de "
"`balance`, el código anterior no se compilaría."

#: src/ch08-01-generic-data-types.md:256
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one "
"with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"Cairo nos permite definir métodos genéricos dentro de traits genéricos "
"también. Usando la implementación previa de `Wallet<U, V>`, vamos a definir "
"un trait que tome dos wallets de diferentes tipos genéricos y cree uno nuevo "
"con un tipo genérico de cada uno. Primero, reescribamos la definición de la "
"estructura:"

#: src/ch08-01-generic-data-types.md:265
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr ""
"A continuación vamos a definir ingenuamente el rasgo mixup y su "
"implementación:"

#: src/ch08-01-generic-data-types.md:268
msgid "// This does not compile!\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:281
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr ""
"Estamos creando un trait `WalletMixTrait<T1, U1>` con el método `mixup<T2, "
"U2>` que, dada una instancia de `Wallet<T1, U1>` y `Wallet<T2, U2>`, crea un "
"nuevo `Wallet<T1, U2>`. Como especifica la firma de `mixup`, tanto `self` "
"como `other` se están eliminando al final de la función, lo que hace que "
"este código no se compile. Si has estado siguiendo desde el principio hasta "
"ahora, sabrás que debemos agregar un requisito para todos los tipos "
"genéricos especificando que implementarán el trait `Drop` para que el "
"compilador sepa cómo eliminar las instancias de `Wallet<T, U>`. La "
"implementación actualizada es la siguiente:"

#: src/ch08-01-generic-data-types.md:299
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""
"Sí, agregamos los requisitos para que `T1` y `U1` sean droppables en la "
"declaración de `WalletMixImpl`. Luego hacemos lo mismo para `T2` y `U2`, "
"esta vez como parte de la firma de `mixup`. Ahora podemos probar la función "
"`mixup`:"

#: src/ch08-01-generic-data-types.md:313
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""
"Primero creamos dos instancias: una de `Wallet<bool, u128>` y la otra de "
"`Wallet<felt252, u8>`. Luego, llamamos a `mixup` y creamos una nueva "
"instancia de `Wallet<bool, u8>`."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The "
"blueprint specification includes a set of function signatures containing "
"type annotations for the parameters and return value. This sets a standard "
"to implement the specific functionality."
msgstr ""
"Los traits especifican plantillas de funcionalidad que pueden ser "
"implementadas. La especificación de la plantilla incluye un conjunto de "
"firmas de funciones que contienen anotaciones de tipos para los parámetros y "
"el valor de retorno. Esto establece un estándar para implementar la "
"funcionalidad específica."

#: src/ch08-02-traits-in-cairo.md:5
#, fuzzy
msgid "Defining a Trait"
msgstr "## Definiendo un Trait"

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"To define a trait, you use the keyword `trait` followed by the name of the "
"trait in `PascalCase` then the function signatures in a pair of curly braces."
msgstr ""
"Para definir un trait, se utiliza la palabra clave `trait` seguida del "
"nombre del trait en `PascalCase` y luego las firmas de funciones dentro de "
"un par de llaves."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We "
"want our application to be able to perform geometry operations on these "
"shapes, So we define a trait `ShapeGeometry` that contains a blueprint to "
"implement geometry operations on a shape like this:"
msgstr ""
"Por ejemplo, supongamos que tenemos múltiples estructuras que representan "
"formas. Queremos que nuestra aplicación pueda realizar operaciones de "
"geometría en estas formas, por lo que definimos un trait `ShapeGeometry` que "
"contiene una plantilla para implementar operaciones de geometría en una "
"forma de esta manera:"

#: src/ch08-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods "
"`boundary` and `area`. When implemented, both these functions should return "
"a `u64` and accept parameters as specified by the trait."
msgstr ""
"Aquí nuestro trait `ShapeGeometry` declara las firmas de dos métodos "
"`boundary` y `area`. Cuando se implementen, ambas funciones deben devolver "
"un `u64` y aceptar parámetros tal como se especifica en el trait."

#: src/ch08-02-traits-in-cairo.md:20
#, fuzzy
msgid "Implementing a Trait"
msgstr "## Implementando un Trait"

#: src/ch08-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your "
"implementation followed by `of` then the name of trait being implemented. "
"Here's an example implementing `ShapeGeometry` trait."
msgstr ""
"Un trait puede ser implementado usando la palabra clave `impl` seguida del "
"nombre de la implementación y la palabra `of`, seguida del nombre del trait "
"que está siendo implementado. Aquí hay un ejemplo de cómo implementar el "
"trait `ShapeGeometry`."

#: src/ch08-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` "
"defining what the methods `boundary` and `area` should do. Note that the "
"function parameters and return value types are identical to the trait "
"specification."
msgstr ""
"En el código anterior, `RectangleGeometry` implementa el trait "
"`ShapeGeometry` definiendo lo que deben hacer los métodos `boundary` y "
"`area`. Note que los tipos de los parámetros de las funciones y los valores "
"de retorno son idénticos a los especificados en el trait."

#: src/ch08-02-traits-in-cairo.md:37
msgid "Implementing a trait, without writing its declaration."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:39
msgid ""
"You can write implementations directly without defining the corresponding "
"trait. This is made possible by using the `#[generate_trait]` attribute "
"within the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` "
"as a suffix to your trait name, as the compiler will create the trait by "
"adding a `Trait` suffix to the implementation name."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:58
msgid ""
"In the aforementioned code, there is no need to manually define the trait. "
"The compiler will automatically handle its definition, dynamically "
"generating and updating it as new functions are introduced."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:60
#, fuzzy
msgid "Parameter `self`"
msgstr "## Parámetro `self`"

#: src/ch08-02-traits-in-cairo.md:62
#, fuzzy
msgid ""
"In the example above, `self` is a special parameter. When a parameter with "
"name `self` is used, the implemented functions are also [attached to the "
"instances of the type as methods](ch05-03-method-syntax.md#defining-"
"methods). Here's an illustration,"
msgstr ""
"En el ejemplo anterior, `self` es un parámetro especial. Cuando se usa un "
"parámetro con el nombre `self`, las funciones implementadas también [se "
"adjuntan a las instancias del tipo como métodos](ch04-03-method-syntax."
"md#defining-methods). Aquí hay una ilustración,"

#: src/ch08-02-traits-in-cairo.md:64
msgid ""
"When the `ShapeGeometry` trait is implemented, the function `area` from the "
"`ShapeGeometry` trait can be called in two ways:"
msgstr ""
"Cuando se implementa el trait `ShapeGeometry`, la función `area` del trait "
"`ShapeGeometry` se puede llamar de dos maneras:"

#: src/ch08-02-traits-in-cairo.md:90
msgid "// Rectangle instantiation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:92
msgid "// First way, as a method on the struct instance\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:94
msgid "// Second way, from the implementation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:96
msgid "// Third way, from the trait\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:99
msgid "// `area1` has same value as `area2` and `area3`\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:108
msgid ""
"And the implementation of the `area` method will be accessed via the `self` "
"parameter."
msgstr ""
"Y se accederá a la implementación del método `area` a través del parámetro "
"`self`."

#: src/ch08-02-traits-in-cairo.md:110
#, fuzzy
msgid "Generic Traits"
msgstr "## Traits Genéricos"

#: src/ch08-02-traits-in-cairo.md:112
msgid ""
"Usually we want to write a trait when we want multiple types to implement a "
"functionality in a standard way. However, in the example above the "
"signatures are static and cannot be used for multiple types. To do this, we "
"use generic types when defining traits."
msgstr ""
"Por lo general, queremos escribir un trait cuando queremos que múltiples "
"tipos implementen una funcionalidad de una manera estándar. Sin embargo, en "
"el ejemplo anterior, las firmas son estáticas y no se pueden usar para "
"múltiples tipos. Para hacer esto, usamos tipos genéricos al definir traits."

#: src/ch08-02-traits-in-cairo.md:114
msgid ""
"In the example below, we use generic type `T` and our method signatures can "
"use this alias which can be provided during implementation."
msgstr ""
"En el siguiente ejemplo, usamos el tipo genérico `T` y nuestras firmas de "
"métodos pueden usar este alias que se puede proporcionar durante la "
"implementación."

#: src/ch08-02-traits-in-cairo.md:129
msgid ""
"// Here T is an alias type which will be provided during implementation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:135
msgid ""
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:146
msgid ""
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:160
msgid "// 35\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:161
msgid "// 24\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:164
msgid "// 78\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:165
msgid "// 31\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:169
#, fuzzy
msgid "Managing and using external trait implementations"
msgstr "## Administrando y usando implementaciones de traits externos"

#: src/ch08-02-traits-in-cairo.md:171
msgid ""
"To use traits methods, you need to make sure the correct traits/"
"implementation(s) are imported. In the code above we imported `PrintTrait` "
"from `debug` with `use debug::PrintTrait;` to use the `print()` methods on "
"supported types."
msgstr ""
"Para utilizar los métodos traits, necesitas asegurarte de que se importan "
"los traits/implementaciones correctos. En el código anterior importamos "
"`PrintTrait` de `debug` con `use debug::PrintTrait;` para usar los métodos "
"`print()` en los tipos soportados."

#: src/ch08-02-traits-in-cairo.md:173
#, fuzzy
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules. If `CircleGeometry` "
"was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr ""
"En algunos casos, puede ser necesario importar no solo el trait, sino "
"también la implementación si están declarados en módulos separados. \n"
"Si `CircleGeometry` estuviera en un módulo/archivo separado `circle`, "
"entonces para usar `boundary` en `circ: Circle`, necesitaríamos importar "
"`CircleGeometry` además de `ShapeGeometry`."

#: src/ch08-02-traits-in-cairo.md:176
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant implementation is required."
msgstr ""

#: src/ch08-02-traits-in-cairo.md:180
msgid "// struct Circle { ... } and struct Rectangle { ... }\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:193
msgid "// Could be in a different file\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:206
msgid ""
"// Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and "
"impl?\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:213
msgid "To make it work, in addition to,"
msgstr "Para hacer que funcione, además de,"

#: src/ch08-02-traits-in-cairo.md:219
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not "
"need to import `RectangleGeometry`, as it is defined in the same module as "
"the imported trait, and thus is automatically resolved."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:3 src/ch09-01-how-to-write-tests.md:13
#, fuzzy
msgid "The Anatomy of a Test Function"
msgstr "## La Anatomía de una Función de Testing"

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""
"Las pruebas son funciones en Cairo que verifican que el código no "
"relacionado con las pruebas está funcionando de la manera esperada. Los "
"cuerpos de las funciones de prueba típicamente realizan estas tres acciones:"

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:8
#, fuzzy
msgid "Run the code you want to test."
msgstr "Al ejecutar este código se imprimiría `it worked`."

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert` "
"function, and the `should_panic` attribute."
msgstr ""
"Veamos las características específicas que Cairo proporciona para escribir "
"pruebas que realizan estas acciones, que incluyen el atributo `test`, la "
"función `assert` y el atributo `should_panic`."

#: src/ch09-01-how-to-write-tests.md:15
#, fuzzy
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 5. To change "
"a function into a test function, add `#[test]` on the line before `fn`. When "
"you run your tests with the `scarb cairo-test` command, Scarb runs Cairo's "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr ""
"En su forma más simple, una prueba en Cairo es una función que está anotada "
"con el atributo `test`. Los atributos son metadatos sobre piezas de código "
"en Cairo; un ejemplo es el atributo `derive` que usamos con estructuras en "
"el capítulo 4. Para convertir una función en una función de prueba, agrega "
"`#[test]` en la línea antes de `fn`. Cuando se ejecutan las pruebas con el "
"comando `cairo-test`, Cairo construye un binario de ejecución de pruebas que "
"ejecuta las funciones anotadas y reporta si cada función de prueba pasa o "
"falla."

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr ""
"Creemos un nuevo proyecto llamado `adder` que sumará dos números usando "
"Scarb con el comando `scarb new adder`:"

#: src/ch09-01-how-to-write-tests.md:26
#, fuzzy
msgid ""
"In _lib.cairo_, let's remove the existing content and add a first test, as "
"shown in Listing 9-1."
msgstr ""
"En _lib.cairo_, agreguemos una primera prueba, como se muestra en el Listado "
"8-1."

#: src/ch09-01-how-to-write-tests.md:38
#, fuzzy
msgid "Listing 9-1: A test module and function"
msgstr "Listado 8-1: Un módulo y función de prueba"

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr ""
"Por ahora, ignoraremos las dos primeras líneas y nos centraremos en la "
"función. Observa la anotación `#[test]`: este atributo indica que esta es "
"una función de prueba, por lo que el runner de pruebas sabe que debe tratar "
"esta función como una prueba. También podríamos tener funciones que no son "
"de prueba en el módulo de pruebas para ayudar a configurar escenarios "
"comunes o realizar operaciones comunes, por lo que siempre debemos indicar "
"qué funciones son pruebas."

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert` function, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr ""
"El cuerpo de la función de ejemplo utiliza la función `assert`, que "
"comprueba que el resultado de sumar 2 y 2 es igual a 4. Esta afirmación "
"sirve como ejemplo del formato de una prueba típica. Ejecutémoslo para ver "
"que esta prueba pasa."

#: src/ch09-01-how-to-write-tests.md:44
#, fuzzy
msgid ""
"The `scarb cairo-test` command runs all tests founds in our project, as "
"shown in Listing 9-2."
msgstr ""
"El comando `scarb cairo-test` ejecuta todas las pruebas en nuestro proyecto, "
"como se muestra en el Listado 8-2."

#: src/ch09-01-how-to-write-tests.md:54
#, fuzzy
msgid "Listing 9-2: The output from running a test"
msgstr "Listado 8-2: Resultados de la ejecución de una prueba"

#: src/ch09-01-how-to-write-tests.md:56
#, fuzzy
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"tests`. The next line shows the name of the test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""
"`cairo-test` compiló y ejecutó la prueba. Vemos la línea `running 1 tests`. "
"La siguiente línea muestra el nombre de la función de prueba generada, "
"llamada `it_works`, y que el resultado de ejecutar esa prueba es `ok`. El "
"resumen general `test result: ok.` significa que todas las pruebas pasaron, "
"y la porción que lee `1 passed; 0 failed` totaliza el número de pruebas que "
"pasaron o fallaron."

#: src/ch09-01-how-to-write-tests.md:58
#, fuzzy
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. We also haven’t filtered the tests being run, so the end of the "
"summary shows `0 filtered out`."
msgstr ""
"Es posible marcar una prueba como ignorada para que no se ejecute en una "
"instancia particular; cubriremos eso en la sección [Ignorando algunas "
"pruebas a menos que se soliciten específicamente](#ignoring-some-tests-"
"unless-specifically-requested) más adelante en este capítulo. Debido a que "
"no hemos hecho eso aquí, el resumen muestra `0 ignoradas`. También podemos "
"pasar un argumento al comando `cairo-test` para ejecutar solo una prueba "
"cuyo nombre coincida con una cadena; esto se llama filtrado y lo cubriremos "
"en la sección [Ejecución de pruebas individuales](#running-single-tests). "
"Tampoco hemos filtrado las pruebas que se ejecutan, por lo que el final del "
"resumen muestra `0 filtradas`."

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr ""
"Comencemos a personalizar la prueba según nuestras necesidades. Primero, "
"cambie el nombre de la función `it_works` a un nombre diferente, como "
"`exploration`, así:"

#: src/ch09-01-how-to-write-tests.md:72
#, fuzzy
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""
"A continuación, ejecute `cairo-test -- --path src` de nuevo. La salida "
"muestra ahora `exploration` en lugar de `it_works`:"

#: src/ch09-01-how-to-write-tests.md:81
#, fuzzy
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr ""
"Ahora agregaremos otra prueba, ¡pero esta vez haremos una prueba que falla! "
"Las pruebas fallan cuando algo en la función de prueba causa un pánico. Cada "
"prueba se ejecuta en un hilo nuevo y cuando el hilo principal ve que un hilo "
"de prueba ha muerto, la prueba se marca como fallida. Agregue la nueva "
"prueba como una función llamada `another`, de modo que su archivo _src/lib."
"cairo_ se vea como en el Listado 8-3."

#: src/ch09-01-how-to-write-tests.md:92
#, fuzzy
msgid "Listing 9-3: Adding a second test that will fail"
msgstr ""
"<span class=\"caption\">Lista 8-3: Agregando una segunda prueba que fallará</"
"span>"

#: src/ch09-01-how-to-write-tests.md:104
#, fuzzy
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr ""
"<span class=\"caption\">Listing 8-4: Resultados de las pruebas cuando una "
"pasa y otra falla</span>"

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"in the _src/lib.cairo_ file."
msgstr ""
"En lugar de `ok`, la línea `adder::lib::tests::another` muestra `fail`. "
"Aparece una nueva sección entre los resultados individuales y el resumen. "
"Muestra la razón detallada de cada falla de prueba. En este caso, obtenemos "
"los detalles de que `another` falló porque falló con un pánico con "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"en el archivo _src/lib.cairo_."

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""
"La línea de resumen se muestra al final: en general, nuestro resultado de "
"prueba es `FAILED`. Tuvimos una prueba que pasó y otra que falló."

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr ""
"Ahora que ha visto cómo son los resultados de las pruebas en diferentes "
"escenarios, veamos algunas funciones que son útiles en las pruebas."

#: src/ch09-01-how-to-write-tests.md:112
#, fuzzy
msgid "Checking Results with the assert function"
msgstr "## Verificar Resultados con la función assert"

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert` "
"function a first argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"assert function calls `panic()` to cause the test to fail with a message we "
"defined as the second argument of the `assert` function. Using the `assert` "
"function helps us check that our code is functioning in the way we intend."
msgstr ""
"La función `assert`, proporcionada por Cairo, es útil cuando desea "
"asegurarse de que alguna condición en una prueba se evalúe como verdadera. "
"Le damos a la función `assert` un primer argumento que se evalúa como un "
"valor booleano. Si el valor es `true`, no sucede nada y la prueba pasa. Si "
"el valor es `false`, la función `assert` llama a `panic()` para hacer que la "
"prueba falle con un mensaje que definimos como segundo argumento de la "
"función `assert`. Usar la función `assert` nos ayuda a verificar que nuestro "
"código funciona de la manera que pretendemos."

#: src/ch09-01-how-to-write-tests.md:116
#, fuzzy
msgid ""
"In [Chapter 5, Listing 5-15](ch05-03-method-syntax.md#multiple-impl-blocks), "
"we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert` function."
msgstr ""
"En [Capítulo 4, Lista 5-15](ch04-03-method-syntax.md#multiple-impl-blocks), "
"usamos una estructura `Rectangle` y un método `can_hold`, que se repiten "
"aquí en la Lista 8-5. Colocaremos este código en el archivo _src/lib.cairo_, "
"luego escribiremos algunas pruebas para él usando la función `assert`."

#: src/ch09-01-how-to-write-tests.md:137
#, fuzzy
msgid ""
"Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from "
"Chapter 5"
msgstr ""
"<span class=\"caption\">Lista 8-5: Uso de la estructura `Rectangle` y su "
"método `can_hold` del Capítulo 5</span>"

#: src/ch09-01-how-to-write-tests.md:139
#, fuzzy
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the assert function. In Listing 9-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8` "
"and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr ""
"El método `can_hold` devuelve un `bool`, lo que significa que es un caso de "
"uso perfecto para la función assert. En el Listado 8-6, escribimos una "
"prueba que ejercita el método `can_hold` creando una instancia de "
"`Rectangle` que tiene una anchura de `8` y una altura de `7` y afirmando que "
"puede contener otra instancia de `Rectangle` que tiene una anchura de `5` y "
"una altura de `1`."

#: src/ch09-01-how-to-write-tests.md:192
#, fuzzy
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle "
"can indeed hold a smaller rectangle"
msgstr ""
"<span class=\"caption\">Lista 8-6: Un test para `can_hold` que verifica si "
"un rectángulo más grande realmente puede contener un rectángulo más pequeño</"
"span>"

#: src/ch09-01-how-to-write-tests.md:194
msgid ""
"Note that we’ve added two new lines inside the tests module: `use super::"
"Rectangle;` and `use super::RectangleTrait;`. The tests module is a regular "
"module that follows the usual visibility rules. Because the tests module is "
"an inner module, we need to bring the code under test in the outer module "
"into the scope of the inner module."
msgstr ""
"Note que hemos agregado dos nuevas líneas dentro del módulo de pruebas: `use "
"super::Rectangle;` y `use super::RectangleTrait;`. El módulo de pruebas es "
"un módulo regular que sigue las reglas normales de visibilidad. Debido a que "
"el módulo de pruebas es un módulo interno, necesitamos traer el código bajo "
"prueba en el módulo externo al ámbito del módulo interno."

#: src/ch09-01-how-to-write-tests.md:196
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the assert function and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"Hemos nombrado nuestro test `larger_can_hold_smaller`, y hemos creado los "
"dos instancias de `Rectangle` que necesitamos. Luego llamamos a la función "
"assert y le pasamos el resultado de llamar a `larger.can_hold(@smaller)`. "
"Esta expresión se supone que devuelve `true`, por lo que nuestra prueba "
"debería pasar. ¡Descubramoslo!"

#: src/ch09-01-how-to-write-tests.md:205
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""
"¡Pasó la prueba! Ahora agreguemos otra prueba, esta vez afirmamos que un "
"rectángulo más pequeño no puede contener un rectángulo más grande:"

#: src/ch09-01-how-to-write-tests.md:258
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the assert "
"function. As a result, our test will pass if `can_hold` returns false:"
msgstr ""
"Como el resultado correcto de la función `can_hold` en este caso es `false`, "
"debemos negar ese resultado antes de pasarlo a la función `assert`. Como "
"resultado, nuestro test pasará si `can_hold` devuelve false:"

#: src/ch09-01-how-to-write-tests.md:268
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr ""
"¡Dos pruebas que pasan! Ahora veamos qué sucede con los resultados de "
"nuestras pruebas cuando introducimos un error en nuestro código. Cambiaremos "
"la implementación del método `can_hold` reemplazando el signo mayor que "
"(`>`) por un signo menor que (`<`) cuando compara los anchos:"

#: src/ch09-01-how-to-write-tests.md:282
msgid "Running the tests now produces the following:"
msgstr "Ejecutando los test ahora produce lo siguiente:"

#: src/ch09-01-how-to-write-tests.md:295
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr ""
"Nuestras pruebas han detectado el error. Como `mayor.anchura` es `8` y "
"`menor.anchura` es `5`, la comparación de las anchuras en `can_hold` ahora "
"devuelve `false`: `8` no es menor que `5`."

#: src/ch09-01-how-to-write-tests.md:297
#, fuzzy
msgid "Checking for panics with `should_panic`"
msgstr "## Comprobando los pánicos con `should_panic`"

#: src/ch09-01-how-to-write-tests.md:299
#, fuzzy
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type "
"in Listing 9-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr ""
"Además de comprobar los valores de retorno, es importante comprobar que "
"nuestro código maneja las condiciones de error como esperamos. Por ejemplo, "
"considere el tipo Adivinar del Listado 8-8. Otro código que utiliza `Guess` "
"depende de la garantía de que las instancias de `Guess` contendrán sólo "
"valores entre `1` y `100`. Podemos escribir una prueba que asegure que al "
"intentar crear una instancia de `Guess` con un valor fuera de ese rango se "
"produzca un pánico."

#: src/ch09-01-how-to-write-tests.md:301
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""
"Lo hacemos agregando el atributo `should_panic` a nuestra función de prueba. "
"La prueba pasa si el código dentro de la función entra en pánico; la prueba "
"falla si el código dentro de la función no entra en pánico."

#: src/ch09-01-how-to-write-tests.md:303
#, fuzzy
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr ""
"El Listing 8-8 muestra una prueba que verifica que las condiciones de error "
"de `GuessTrait::new` ocurren cuando esperamos que sucedan."

#: src/ch09-01-how-to-write-tests.md:341
#, fuzzy
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr ""
"<span class=\"caption\">Listing 8-8: Probando que una condición causará un "
"pánico</span>"

#: src/ch09-01-how-to-write-tests.md:343
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""
"Colocamos el atributo `#[should_panic]` después del atributo `#[test]` y "
"antes de la función de prueba a la que se aplica. Veamos el resultado cuando "
"esta prueba pasa:"

#: src/ch09-01-how-to-write-tests.md:352
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr ""
"¡Tiene buena pinta! Ahora vamos a introducir un error en nuestro código "
"eliminando la condición de que la nueva función entre en pánico si el valor "
"es mayor que `100`:"

#: src/ch09-01-how-to-write-tests.md:379
#, fuzzy
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr "Cuando ejecutamos la prueba en el Listado 8-8, fallará:"

#: src/ch09-01-how-to-write-tests.md:390
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""
"En este caso, no obtenemos un mensaje muy útil, pero cuando miramos la "
"función de prueba, vemos que está anotada con `#[should_panic]`. La falla "
"que obtuvimos significa que el código en la función de prueba no causó un "
"pánico."

#: src/ch09-01-how-to-write-tests.md:392
#, fuzzy
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 9-9 where the new function "
"panics with different messages depending on whether the value is too small "
"or too large."
msgstr ""
"Las pruebas que usan `should_panic` pueden ser imprecisas. Una prueba con "
"`should_panic` pasaría incluso si la prueba produce un pánico por una razón "
"diferente a la que esperábamos. Para hacer que las pruebas con "
"`should_panic` sean más precisas, podemos agregar un parámetro opcional "
"`expected` al atributo `should_panic`. El sistema de pruebas se asegurará de "
"que el mensaje de error contenga el texto proporcionado. Por ejemplo, "
"considere el código modificado para `Guess` en el Listado 8-9, donde la "
"nueva función genera un pánico con mensajes diferentes dependiendo de si el "
"valor es demasiado pequeño o demasiado grande."

#: src/ch09-01-how-to-write-tests.md:433
#, fuzzy
msgid ""
"Listing 9-9: Testing for a panic with a panic message containing the error "
"message string"
msgstr ""
"<span class=\"caption\">Listado 8-9: Prueba para una excepción con un "
"mensaje de excepción que contiene la cadena del mensaje de error</span>"

#: src/ch09-01-how-to-write-tests.md:435
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr ""
"Esta prueba pasará porque el valor que ponemos en el parámetro esperado del "
"atributo `should_panic` es la matriz de cadenas del mensaje con el que la "
"función `Guess::new` genera la excepción. Necesitamos especificar el mensaje "
"completo de la excepción que esperamos."

#: src/ch09-01-how-to-write-tests.md:437
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""
"Para ver qué ocurre cuando falla una prueba `should_panic` con un mensaje "
"esperado, introduzcamos de nuevo un error en nuestro código intercambiando "
"los cuerpos de los bloques if `value < 1` y else if `value > 100`:"

#: src/ch09-01-how-to-write-tests.md:469
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "Esta vez, cuando ejecutamos la prueba `should_panic`, fallará:"

#: src/ch09-01-how-to-write-tests.md:481
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""
"El mensaje de fallo indica que este test realmente causó un pánico como "
"esperábamos, pero el mensaje de pánico no incluyó la cadena esperada. El "
"mensaje de pánico que obtuvimos en este caso fue `Guess must be >= 1`. "
"¡Ahora podemos comenzar a descubrir dónde está nuestro error!"

#: src/ch09-01-how-to-write-tests.md:483
#, fuzzy
msgid "Running Single Tests"
msgstr "## Ejecución de Pruebas Individuales"

#: src/ch09-01-how-to-write-tests.md:485
#, fuzzy
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""
"A veces, ejecutar un conjunto completo de pruebas puede llevar mucho tiempo. "
"Si está trabajando en código en un área particular, es posible que desee "
"ejecutar solo las pruebas relacionadas con ese código. Puede elegir qué "
"pruebas ejecutar pasando el nombre de la prueba que desea ejecutar como "
"argumento a `cairo-test`."

#: src/ch09-01-how-to-write-tests.md:487
#, fuzzy
msgid ""
"To demonstrate how to run a single test, we’ll first create two tests "
"functions, as shown in Listing 9-10, and choose which ones to run."
msgstr ""
"Para demostrar cómo ejecutar una sola prueba, primero crearemos dos "
"funciones de prueba, como se muestra en el Listado 8-10, y elegiremos cuáles "
"ejecutar."

#: src/ch09-01-how-to-write-tests.md:508
#, fuzzy
msgid "Listing 9-10: Two tests with two different names"
msgstr ""
"<span class=\"caption\">Listado 8-10: Dos pruebas con dos nombres "
"diferentes</span>"

#: src/ch09-01-how-to-write-tests.md:510
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr ""
"Podemos pasar el nombre de cualquier función de prueba a `cairo-test` para "
"ejecutar solo esa prueba usando la bandera `-f`:"

#: src/ch09-01-how-to-write-tests.md:519
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr ""
"Solo se ejecutó la prueba con el nombre `add_two_and_two`; la otra prueba no "
"coincidía con ese nombre. La salida de la prueba nos indica que tuvimos una "
"prueba más que no se ejecutó al mostrar \"1 filtrado\" al final."

#: src/ch09-01-how-to-write-tests.md:521
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr ""
"También podemos especificar parte del nombre de una prueba y se ejecutarán "
"todas las pruebas cuyo nombre contenga ese valor."

#: src/ch09-01-how-to-write-tests.md:523
#, fuzzy
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "## Ignorar Algunos Test a menos que se Soliciten Específicamente"

#: src/ch09-01-how-to-write-tests.md:525
#, fuzzy
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude "
"them, as shown here:"
msgstr ""
"A veces, algunas pruebas específicas pueden ser muy lentas de ejecutar, por "
"lo que es posible que desee excluirlos durante la mayoría de las ejecuciones "
"de `cairo-test`. En lugar de enumerar como argumentos todas las pruebas que "
"desea ejecutar, puede anotar las pruebas que consumen mucho tiempo "
"utilizando el atributo `ignore` para excluirlos, como se muestra aquí:"

#: src/ch09-01-how-to-write-tests.md:540
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:545
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"Después de `#[test]` agregamos la línea `#[ignore]` al test que queremos "
"excluir. Ahora, cuando ejecutamos nuestros tests, `it_works` se ejecuta pero "
"`expensive_test` no lo hace:"

#: src/ch09-01-how-to-write-tests.md:555
msgid "The `expensive_test` function is listed as ignored."
msgstr "La función `expensive_test` está listada como ignorada."

#: src/ch09-01-how-to-write-tests.md:557
#, fuzzy
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""
"Cuando esté en un punto en el que tenga sentido verificar los resultados de "
"las pruebas ignoradas y tenga tiempo para esperar los resultados, puede "
"ejecutar `cairo-test --include-ignored` para ejecutar todas las pruebas, ya "
"sea que estén ignoradas o no."

#: src/ch09-01-how-to-write-tests.md:559
msgid "Testing recursive functions or loops"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:561
msgid ""
"When testing recursive functions or loops, you must provide the test with a "
"maximum amount of gas that it can consume. This prevents running infinite "
"loops or consuming too much gas, and can help you benchmark the efficiency "
"of your implementations. To do so, you must add the "
"`#[available_gas(<Number>)]` attribute on the test function. The following "
"example shows how to use it:"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:592
msgid "Benchmarking the gas usage of a specific operation"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:594
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:599 src/ch09-01-how-to-write-tests.md:629
msgid "/// code we want to bench.\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:603
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:636
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the operation benchmarked."
msgstr ""

#: src/ch09-01-how-to-write-tests.md:649
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation "
"of the hex number). The total amount consumed by the test is slightly higher "
"at 98030, due to some extra steps required to run the entire test function."
msgstr ""

#: src/ch09-02-test-organization.md:3
#, fuzzy
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's "
"good practice to start organizing your code as if it were. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr ""
"Pensaremos en las pruebas en términos de dos categorías principales: pruebas "
"unitarias y pruebas de integración. Las pruebas unitarias son pequeñas y más "
"enfocadas, probando un módulo a la vez en aislamiento, y pueden probar "
"funciones privadas. Las pruebas de integración utilizan su código de la "
"misma manera que cualquier otro código externo, utilizando solo la interfaz "
"pública y potencialmente ejercitando varios módulos por prueba."

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""
"Escribir ambos tipos de pruebas es importante para asegurarse de que las "
"piezas de su biblioteca estén haciendo lo que se espera de ellas, tanto "
"separadas como juntas."

#: src/ch09-02-test-organization.md:7
#, fuzzy
msgid "Unit Tests"
msgstr "## Test Unitarios"

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr ""
"El propósito de las pruebas unitarias es probar cada unidad de código en "
"aislamiento del resto del código para identificar rápidamente dónde el "
"código funciona y dónde no lo hace como se esperaba. Colocará las pruebas "
"unitarias en el directorio `src` en cada archivo con el código que están "
"probando."

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the "
"test functions and to annotate the module with `cfg(test)`."
msgstr ""
"La convención es crear un módulo llamado `tests` en cada archivo para "
"contener las funciones de prueba y anotar el módulo con `cfg(test)`."

#: src/ch09-02-test-organization.md:13
#, fuzzy
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "### El Módulo de Test y `#[cfg(test)]`"

#: src/ch09-02-test-organization.md:15
#, fuzzy
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library "
"and saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""
"La anotación `#[cfg(test)]` en el módulo de pruebas indica a Cairo que "
"compile y ejecute el código de prueba solo cuando se ejecuta `cairo-test`, "
"no cuando se ejecuta `cairo-run`. Esto ahorra tiempo de compilación cuando "
"solo desea compilar la biblioteca y ahorra espacio en el artefacto compilado "
"resultante porque las pruebas no están incluidas. Verá que debido a que las "
"pruebas de integración van en un directorio diferente, no necesitan la "
"anotación `#[cfg(test)]`. Sin embargo, debido a que las pruebas unitarias "
"van en los mismos archivos que el código, usará `#[cfg(test)]` para "
"especificar que no deben incluirse en el resultado compilado."

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr ""
"Recuerde que cuando creamos el nuevo proyecto `adder` en la primera sección "
"de este capítulo, escribimos esta primera prueba:"

#: src/ch09-02-test-organization.md:32
#, fuzzy
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb cairo-"
"test`. This includes any helper functions that might be within this module, "
"in addition to the functions annotated with `#[test]`."
msgstr ""
"El atributo `cfg` significa \"configuración\" y le indica a Cairo que el "
"siguiente elemento solo debe incluirse dado una cierta opción de "
"configuración. En este caso, la opción de configuración es `test`, que es "
"proporcionada por Cairo para compilar y ejecutar pruebas. Al usar el "
"atributo `cfg`, Cairo compila nuestro código de prueba solo si ejecutamos "
"activamente las pruebas con `cairo-test`. Esto incluye cualquier función de "
"ayuda que pueda estar dentro de este módulo, además de las funciones "
"anotadas con `#[test]`."

#: src/ch09-02-test-organization.md:34
#, fuzzy
msgid "Integration Tests"
msgstr "## Test de Integración"

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""
"Las pruebas de integración usan su biblioteca de la misma manera que "
"cualquier otro código. Su propósito es probar si muchas partes de su "
"biblioteca funcionan correctamente juntas. Las unidades de código que "
"funcionan correctamente por sí mismas podrían tener problemas cuando se "
"integran, por lo que también es importante tener cobertura de prueba del "
"código integrado. Para crear pruebas de integración, primero necesita un "
"directorio de `tests`."

#: src/ch09-02-test-organization.md:38
#, fuzzy
msgid "The `tests` Directory"
msgstr "### Directorio `tests`"

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr ""

#: src/ch09-02-test-organization.md:68
#, fuzzy
msgid ""
"Enter the code in Listing 9-11 into the _src/tests/integration_test.cairo_ "
"file:"
msgstr ""
"Ingrese el código del Listado 8-11 en el archivo _tests/integration_test."
"cairo_:"

#: src/ch09-02-test-organization.md:80
#, fuzzy
msgid "Filename: src/tests/integration_test.cairo"
msgstr "<span class=\"filename\">Filename: tests/integration_test.cairo</span>"

#: src/ch09-02-test-organization.md:82
#, fuzzy
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""
"Cada archivo en el directorio de pruebas es una creación separada, por lo "
"que debemos incluir nuestra biblioteca en el alcance de cada creación de "
"prueba. Por esa razón, agregamos `use adder::main` en la parte superior del "
"código, lo cual no necesitábamos en las pruebas unitarias."

#: src/ch09-02-test-organization.md:84
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr ""

#: src/ch09-02-test-organization.md:95
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr ""
"El resultado de las pruebas es el mismo que hemos estado viendo: una línea "
"por cada prueba."

#: src/ch10-00-error-handling.md:1
#, fuzzy
msgid "Error handling"
msgstr "# Gestión de errores"

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr ""
"En este capítulo, exploraremos varias técnicas de manejo de errores "
"proporcionadas por Cairo, que no sólo te permiten tratar problemas "
"potenciales en tu código, sino que también hacen más fácil crear programas "
"que son adaptables y mantenibles. Examinando diferentes aproximaciones a la "
"gestión de errores, como la concordancia de patrones con el enum Result, "
"usando el operador ? para una propagación de errores más ergonómica, y "
"empleando los métodos unwrap o expect para gestionar errores recuperables, "
"obtendrá una comprensión más profunda de las características de gestión de "
"errores de Cairo. Estos conceptos son cruciales para construir aplicaciones "
"robustas que puedan manejar efectivamente situaciones inesperadas, "
"asegurando que su código esté listo para producción."

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr ""
"En Cairo, pueden surgir problemas inesperados durante la ejecución del "
"programa, dando lugar a errores en tiempo de ejecución. Mientras que la "
"función de pánico de la librería principal no proporciona una resolución "
"para estos errores, sí reconoce su ocurrencia y termina el programa. Hay dos "
"formas principales en las que se puede desencadenar un pánico en Cairo: "
"inadvertidamente, a través de acciones que causan que el código entre en "
"pánico (por ejemplo, acceder a un array más allá de sus límites), o "
"deliberadamente, invocando la función de pánico."

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
#, fuzzy
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide "
"an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""
"Cuando se produce un pánico, se produce una terminación abrupta del "
"programa. La función `panic` toma como argumento un array, que puede "
"utilizarse para proporcionar un mensaje de error y realiza un proceso de "
"desenrollado en el que se eliminan todas las variables y se aplastan los "
"diccionarios para garantizar la solidez del programa y terminar la ejecución "
"de forma segura."

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr ""
"Así es como podemos `panic` desde dentro de un programa y devolver el código "
"de error `2`:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:24
msgid "Running the program will produce the following output:"
msgstr "La ejecución del programa producirá el siguiente resultado:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr ""
"Como se puede observar en la salida, la sentencia print nunca se alcanza, ya "
"que el programa termina después de encontrar la sentencia `panic`."

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
#, fuzzy
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a felt252 error message as an "
"argument, making the code more readable and maintainable."
msgstr ""
"Una aproximación alternativa y más idiomática al pánico en Cairo sería usar "
"la función `panic_with_felt252`. Esta función sirve como una abstracción del "
"proceso de definición de arrays y a menudo se prefiere debido a su expresión "
"más clara y concisa de la intención. Usando `panic_with_felt252`, los "
"desarrolladores pueden entrar en pánico en una sola línea proporcionando un "
"mensaje de error felt252 como argumento, haciendo el código más legible y "
"mantenible."

#: src/ch10-01-unrecoverable-errors-with-panic.md:35
msgid "Let's consider an example:"
msgstr "Veamos un ejemplo:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr ""
"Ejecutando este programa se obtendrá el mismo mensaje de error que antes. En "
"ese caso, si no hay necesidad de una matriz y múltiples valores a devolver "
"dentro del error, por lo que `panic_with_felt252` es una alternativa más "
"sucinta."

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
#, fuzzy
msgid "nopanic notation"
msgstr "## notación nopanic"

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""
"Puede utilizar la anotación `nopanic` para indicar que una función nunca "
"entrará en pánico. Sólo las funciones `nopanic` pueden ser llamadas en una "
"función anotada como `nopanic`."

#: src/ch10-01-unrecoverable-errors-with-panic.md:49
#: src/ch10-01-unrecoverable-errors-with-panic.md:84
#: src/appendix-03-derivable-traits.md:17
#: src/appendix-03-derivable-traits.md:42
#: src/appendix-03-derivable-traits.md:63
#: src/appendix-03-derivable-traits.md:85
#: src/appendix-03-derivable-traits.md:118
#: src/appendix-03-derivable-traits.md:155
msgid "Example:"
msgstr "Ejemplo:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:57
msgid "Wrong example:"
msgstr "Ejemplo incorrecto:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:65
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr ""
"Si escribes la siguiente función que incluye una función que puede entrar en "
"pánico obtendrás el siguiente error:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:78
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr ""
"Tenga en cuenta que hay dos funciones que pueden entrar en pánico aquí, "
"assert e equality."

#: src/ch10-01-unrecoverable-errors-with-panic.md:80
#, fuzzy
msgid "panic_with attribute"
msgstr "## macro panic_with"

#: src/ch10-01-unrecoverable-errors-with-panic.md:82
#, fuzzy
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr ""
"Puede utilizar la macro `panic_with` para marcar una función que devuelva "
"una `Option` o un `Result`. Esta macro toma dos argumentos, que son los "
"datos que se pasan como la razón de pánico, así como el nombre de una "
"función envolvente. Creará una envoltura para su función anotada que entrará "
"en pánico si la función devuelve `None` o `Err`, la función de pánico será "
"llamada con los datos dados."

#: src/ch10-01-unrecoverable-errors-with-panic.md:97
msgid "// this returns None\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:98
msgid "// this panic with 'value is 0'\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:102
#, fuzzy
msgid "Using assert"
msgstr "## Usando assert"

#: src/ch10-01-unrecoverable-errors-with-panic.md:104
msgid ""
"The assert function from the Cairo core library is actually a utility "
"function based on panics. It asserts that a boolean expression is true at "
"runtime, and if it is not, it calls the panic function with an error value. "
"The assert function takes two arguments: the boolean expression to verify, "
"and the error value. The error value is specified as a felt252, so any "
"string passed must be able to fit inside a felt252."
msgstr ""
"La función assert de la librería del núcleo de Cairo es en realidad una "
"función de utilidad basada en panics. Afirma que una expresión booleana es "
"verdadera en tiempo de ejecución, y si no lo es, llama a la función panic "
"con un valor de error. La función assert toma dos argumentos: la expresión "
"booleana a verificar y el valor de error. El valor de error se especifica "
"como un felt252, por lo que cualquier cadena que se pase debe caber dentro "
"de un felt252."

#: src/ch10-01-unrecoverable-errors-with-panic.md:106
msgid "Here is an example of its usage:"
msgstr "He aquí un ejemplo de su uso:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:118
#, fuzzy
msgid ""
"We are asserting in main that `my_number` is not zero to ensure that we're "
"not performing a division by 0. In this example, `my_number` is zero so the "
"assertion will fail, and the program will panic with the string 'number is "
"zero' (as a felt252) and the division will not be reached."
msgstr ""
"Estamos afirmando en main que `mi_número` no es cero para asegurarnos de que "
"no estamos realizando una división por 0.\n"
"En este ejemplo, `my_number` es cero por lo que la afirmación fallará, y el "
"programa entrará en pánico\n"
"con la cadena 'number is zero' (como felt252) y no se realizará la división."

#: src/ch10-02-recoverable-errors.md:1
#, fuzzy
msgid "Recoverable Errors with `Result`"
msgstr "# Errores Recuperables con `Result`"

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""
"La mayoría de los errores no son lo suficientemente graves como para que el "
"programa se detenga por completo. A veces, cuando una función falla, es por "
"una razón que usted puede interpretar fácilmente y a la que puede responder. "
"Por ejemplo, si intenta sumar dos enteros grandes y la operación se desborda "
"porque la suma excede el valor máximo representable, es posible que desee "
"devolver un error o un resultado envuelto en lugar de causar un "
"comportamiento indefinido o terminar el proceso."

#: src/ch10-02-recoverable-errors.md:7
#, fuzzy
msgid "The `Result` enum"
msgstr "## El enum `Result`"

#: src/ch10-02-recoverable-errors.md:9
#, fuzzy
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in "
"Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and "
"`Err`, as follows:"
msgstr ""
"Recordemos de [\"Tipos de datos genéricos\"](ch07-01-generic-data-types."
"md#enums) en el Capítulo 7 que el enum `Result` se define como teniendo dos "
"variantes, `Ok` y `Err`, como sigue:"

#: src/ch10-02-recoverable-errors.md:20
#, fuzzy
msgid "The `ResultTrait`"
msgstr "## El `ResultTrait`"

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"El rasgo `ResultTrait` proporciona métodos para trabajar con el enum "
"`Result<T, E>`, como desenvolver valores, comprobar si el `Result` es `Ok` o "
"`Err`, y entrar en pánico con un mensaje personalizado. La implementación de "
"`ResultTraitImpl` define la lógica de estos métodos."

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr ""
"Los métodos `expect` y `unwrap` se parecen en que ambos intentan extraer el "
"valor de tipo `T` de un `Resultado<T, E>` cuando está en la variante `Ok`. "
"Si el `Resultado` es `Ok(x)`, ambos métodos devuelven el valor `x`. Sin "
"embargo, la diferencia clave entre los dos métodos radica en su "
"comportamiento cuando el `Result` está en la variante `Err`. El método "
"`expect` te permite proporcionar un mensaje de error personalizado (como un "
"valor `felt252`) que se utilizará cuando se produzca el pánico, dándote más "
"control y contexto sobre el pánico. Por otro lado, el método `unwrap` entra "
"en pánico con un mensaje de error por defecto, proporcionando menos "
"información sobre la causa del pánico."

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""
"Los métodos `expect_err` y `unwrap_err` tienen el comportamiento exactamente "
"opuesto. Si el `Result` es `Err(x)`, ambos métodos devuelven el valor `x`. "
"Sin embargo, la diferencia clave entre los dos métodos está en el caso de "
"`Result::Ok()`. El método `expect_err` te permite proporcionar un mensaje de "
"error personalizado (como un valor `felt252`) que se utilizará cuando se "
"produzca el pánico, dándote más control y contexto sobre el pánico. Por otro "
"lado, el método `unwrap_err` entra en pánico con un mensaje de error por "
"defecto, proporcionando menos información sobre la causa del pánico."

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl "
"EDrop: Drop<E>>` in the first four methods signatures. This syntax "
"represents generic type constraints in the Cairo language. These constraints "
"indicate that the associated functions require an implementation of the "
"`Drop` trait for the generic types `T` and `E`, respectively."
msgstr ""
"Un lector atento puede haber notado el `<impl TDrop: Drop<T>>` y `<impl "
"EDrop: Drop<E>>` en las firmas de los cuatro primeros métodos. Esta sintaxis "
"representa restricciones de tipo genérico en el lenguaje Cairo. Estas "
"restricciones indican que las funciones asociadas requieren una "
"implementación del rasgo `Drop` para los tipos genéricos `T` y `E`, "
"respectivamente."

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""
"Por último, los métodos `is_ok` y `is_err` son funciones de utilidad "
"proporcionadas por el rasgo `ResultTrait` para comprobar la variante de un "
"valor del enum `Result`."

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""
"`is_ok` toma una instantánea de un valor `Result<T, E>` y devuelve `true` si "
"el `Result` es la variante `Ok`, lo que significa que la operación se ha "
"realizado correctamente. Si el `Resultado` es la variante `Err`, devuelve "
"`false`."

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"`is_err` toma una referencia a un valor `Result<T, E>` y devuelve `true` si "
"el `Result` es la variante `Err`, lo que significa que la operación ha "
"encontrado un error. Si el `Resultado` es la variante `Ok`, devuelve `false`."

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"Estos métodos son útiles cuando se desea comprobar el éxito o el fracaso de "
"una operación sin consumir el valor del Resultado, lo que permite realizar "
"operaciones adicionales o tomar decisiones basadas en la variante sin "
"desenvolverla."

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation of the `ResultTrait` [here](https://github."
"com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"Puede encontrar la implementación del `ResultTrait` [aquí](https://github."
"com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr "Siempre es más fácil entender con ejemplos."

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr "Eche un vistazo a la firma de esta función:"

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""
"Toma dos enteros u128, a y b, y devuelve un `Result<u128, u128>` donde la "
"variante `Ok` contiene la suma si la suma no se desborda, y la variante "
"`Err` contiene el valor desbordado si la suma se desborda."

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Ahora, podemos utilizar esta función en otros lugares. Por ejemplo:"

#: src/ch10-02-recoverable-errors.md:79
#, fuzzy
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None(())` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."

#: src/ch10-02-recoverable-errors.md:81
#, fuzzy
msgid ""
"Let's take another example demonstrating the use of `unwrap`. First we "
"import the necessary modules:"
msgstr ""
"Veamos otro ejemplo que demuestra el uso de `unwrap`.\n"
"Primero importamos los módulos necesarios:"

#: src/ch10-02-recoverable-errors.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries "
"to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns `Result::"
"Err('Invalid integer')`."
msgstr ""
"En este ejemplo, la función `parse_u8` toma un entero `felt252` e intenta "
"convertirlo en un entero `u8` utilizando el método `try_into`. Si tiene "
"éxito, devuelve `Result::Ok(value)`, en caso contrario devuelve `Result::"
"Err('Invalid integer')`."

#: src/ch10-02-recoverable-errors.md:103
#, fuzzy
msgid "Listing 10-1: Using the Result type"
msgstr ""
"<span class=\"caption\">Listado 9-1: Utilización del tipo de resultado</span>"

#: src/ch10-02-recoverable-errors.md:105
msgid "Our two test cases are:"
msgstr "Nuestros dos casos de prueba son:"

#: src/ch10-02-recoverable-errors.md:121
msgid "// should not panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:129
msgid "// should panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message 'Invalid integer'."
msgstr ""
"La primera prueba una conversión válida de `felt252` a `u8`, esperando que "
"el método `unwrap` no entre en pánico. La segunda función de prueba intenta "
"convertir un valor que está fuera del rango `u8`, esperando que el método "
"`unwrap` entre en pánico con el mensaje de error 'Invalid integer'."

#: src/ch10-02-recoverable-errors.md:139
#, fuzzy
msgid "We could have also used the #\\[should_panic\\] attribute here."
msgstr "> También podríamos haber utilizado aquí el atributo #[should_panic]."

#: src/ch10-02-recoverable-errors.md:141
#, fuzzy
msgid "The `?` operator ?"
msgstr "### ¿El operador `?`?"

#: src/ch10-02-recoverable-errors.md:143
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"El último operador del que hablaremos es el operador `?`. El operador `?` se "
"utiliza para un manejo de errores más idiomático y conciso. Cuando usas el "
"operador `?` en un tipo `Result` u `Option`, hará lo siguiente:"

#: src/ch10-02-recoverable-errors.md:145
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr ""

#: src/ch10-02-recoverable-errors.md:146
#, fuzzy
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""
"- Si el valor es `Result::Ok(x)` u `Opción::Some(x)`, devolverá el valor "
"interno `x` directamente.\n"
"- Si el valor es `Result::Err(e)` u `Option::None`, propagará el error o "
"`None` retornando inmediatamente de la función."

#: src/ch10-02-recoverable-errors.md:148
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr ""
"El operador `?` es útil cuando se desea manejar los errores implícitamente y "
"dejar que la función de llamada se ocupe de ellos."

#: src/ch10-02-recoverable-errors.md:150
msgid "Here is an example."
msgstr "Aquí un ejemplo."

#: src/ch10-02-recoverable-errors.md:155 src/ch10-02-recoverable-errors.md:177
msgid "// DO SOMETHING\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:161
#, fuzzy
msgid "Listing 10-1: Using the `?` operator"
msgstr ""
"<span class=\"caption\">Listado 9-1: Utilización del operador `?`</span>"

#: src/ch10-02-recoverable-errors.md:163
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr ""
"La función `do_something_with_parse_u8` toma un valor `felt252` como entrada "
"y llama a `parse_u8`. El operador `?` se utiliza para propagar el error, si "
"lo hay, o desenvolver el valor correcto."

#: src/ch10-02-recoverable-errors.md:165
msgid "And with a little test case:"
msgstr "Y con un pequeño caso de prueba:"

#: src/ch10-02-recoverable-errors.md:198
msgid "The console will print the error \"Invalid Integer\"."
msgstr "La consola mostrará el error \"Invalid Integer\"."

#: src/ch10-02-recoverable-errors.md:204
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr ""
"Vimos que los errores recuperables pueden ser manejados en Cairo usando el "
"enum Result, que tiene dos variantes: `Ok` y `Err`. El enum `Result<T, E>` "
"es genérico, con los tipos `T` y `E` representando los valores de éxito y "
"error, respectivamente. El `ResultTrait` proporciona métodos para trabajar "
"con `Result<T, E>`, como desenvolver valores, comprobar si el resultado es "
"`Ok` o `Err`, y asustar con mensajes personalizados."

#: src/ch10-02-recoverable-errors.md:206
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""
"Para gestionar errores recuperables, una función puede devolver un tipo "
"`Result` y utilizar la concordancia de patrones para gestionar el éxito o el "
"fracaso de una operación. El operador `?` puede utilizarse para gestionar "
"errores implícitamente, propagando el error o desenvolviendo el valor "
"correcto. Esto permite una gestión de errores más concisa y clara, en la que "
"el autor de la llamada es responsable de gestionar los errores generados por "
"la función llamada."

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr ""

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"La sobrecarga de operadores es una característica de algunos lenguajes de "
"programación que permite redefinir operadores estándar, como la suma (+), la "
"resta (-), la multiplicación (\\*) y la división (/), para que funcionen con "
"tipos definidos por el usuario. Esto puede hacer que la sintaxis del código "
"sea más intuitiva, al permitir que las operaciones sobre tipos definidos por "
"el usuario se expresen del mismo modo que las operaciones sobre tipos "
"primitivos."

#: src/ch11-01-operator-overloading.md:5
#, fuzzy
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""
"En Cairo, la sobrecarga de operadores se consigue mediante la implementación "
"de rasgos específicos. Cada operador tiene un rasgo asociado, y sobrecargar "
"ese operador implica proporcionar una implementación de ese rasgo para un "
"tipo personalizado.\n"
"Sin embargo, es esencial utilizar la sobrecarga de operadores con criterio. "
"Un mal uso puede llevar a confusión, haciendo el código más difícil de "
"mantener, por ejemplo cuando no hay un significado semántico para el "
"operador que se sobrecarga."

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""
"Consideremos un ejemplo en el que hay que combinar dos `Potions`. Las "
"`Potions` tienen dos campos de datos, maná y salud. Al combinar dos "
"`Potions` se deben añadir sus respectivos campos."

#: src/ch11-01-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr ""

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""
"En el código anterior, estamos implementando el rasgo `Add` para el tipo "
"`Potion`. La función add toma dos argumentos: `lhs` y `rhs` (izquierda y "
"derecha). El cuerpo de la función devuelve una nueva instancia de `Poción`, "
"cuyos valores de campo son una combinación de `lhs` y `rhs`."

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"Como se ilustra en el ejemplo, la sobrecarga de un operador requiere la "
"especificación del tipo concreto que se sobrecarga. El trait genérico "
"sobrecargado es `Add<T>`, y definimos una implementación concreta para el "
"tipo `Potion` con `Add<Potion>`."

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code. In Cairo, there are only two `macros`: `array![]` and "
"`consteval_int!()`."
msgstr ""

#: src/ch11-02-macros.md:5
#, fuzzy
msgid "Let's start by `array!`"
msgstr "Empecemos instalando Scarb."

#: src/ch11-02-macros.md:7
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will create an array and append all values passed to the `array!"
"` macro sequentially."
msgstr ""

#: src/ch11-02-macros.md:27
msgid "`consteval_int!`"
msgstr ""

#: src/ch11-02-macros.md:29
msgid ""
"In some situations, a developer might need to declare a constant that is the "
"result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""

#: src/ch11-02-macros.md:31
#, fuzzy
msgid "Here is an example of `consteval_int!`:"
msgstr "Aquí hay un ejemplo de declaración de constante:"

#: src/ch11-02-macros.md:37
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""
"En todas las secciones anteriores, principalmente ha escrito programas con "
"un punto de entrada `main`. En las próximas secciones, aprenderá a escribir "
"e implementar contratos inteligentes en Starknet."

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts "
"for the Starknet network. Starknet is a permissionless network that "
"leverages zk-STARKs technology for scalability. As a Layer-2 scalability "
"solution for Ethereum, Starknet's goal is to offer fast, secure, and low-"
"cost transactions. It functions as a Validity Rollup (commonly known as a "
"zero-knowledge Rollup) and is built on top of the Cairo language and the "
"Starknet VM."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""
"Un contrato inteligente en Starknet en términos simples, es un programa que "
"puede ejecutarse en la VM de Starknet. Dado que se ejecutan en la VM, tienen "
"acceso al estado persistente de Starknet, pueden modificar variables en los "
"estados de Starknet, comunicarse con otros contratos e interactuar sin "
"problemas con la L1 subyacente."

#: src/ch99-00-starknet-smart-contracts.md:9
#, fuzzy
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections. If you want to learn more about the "
"Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""
"Los contratos de Starknet se denotan mediante el atributo `#[contract]`. "
"Profundizaremos en esto en las próximas secciones.\n"
"Si quieres aprender más sobre la propia red Starknet, su arquitectura y las "
"herramientas disponibles, deberías leer el [Libro Starknet](https://book."
"starknet.io/). Esta sección se centrará en escribir contratos inteligentes "
"en Cairo."

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this "
"functionality, you'll need to make some configurations in your `Scarb.toml` "
"file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a `[[target."
"starknet-contract]]` section to enable contract compilation."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:17
msgid ""
"Below is the minimal Scarb.toml file required to compile a crate containing "
"Starknet contracts:"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:19
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch99-00-starknet-smart-contracts.md:30
#, fuzzy
msgid ""
"For additional configuration, such as external contract dependencies, please "
"refer to the [Scarb documentation](https://docs.swmansion.com/scarb/docs/"
"extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""
"> Nota: Si estás construyendo contratos para Starknet, deberás agregar la "
"dependencia `starknet` como se menciona en la [documentación de Scarb]"
"(https://docs.swmansion.com/scarb/docs/starknet/starknet-package.html)."

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
#, fuzzy
msgid ""
"This chapter will give you a high level introduction to what smart-contracts "
"are, what are they used for and why would blockchain developers use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""
"Este capítulo te dará una introducción de alto nivel a lo que son los "
"contratos inteligentes, para qué se usan y por qué los desarrolladores de "
"blockchain usan Cairo y Starknet.\n"
"Si ya estás familiarizado con la programación de cadenas de bloques, puedes "
"saltarte este capítulo. Sin embargo, la última parte puede seguir siendo "
"interesante."

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
#, fuzzy
msgid "Smart-contracts"
msgstr "# Smart-contracts"

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""
"Los contratos inteligentes ganaron popularidad y se generalizaron con el "
"nacimiento de Ethereum. Los contratos inteligentes son esencialmente "
"programas desplegados en una blockchain. El término \"smart contract\" es "
"algo engañoso, ya que no son ni \"inteligentes\" ni \"contratos\", sino más "
"bien código e instrucciones que se ejecutan en función de entradas "
"específicas. Constan principalmente de dos componentes: almacenamiento y "
"funciones. Una vez desplegados, los usuarios pueden interactuar con los "
"contratos inteligentes iniciando transacciones en la cadena de bloques que "
"contengan datos de ejecución (a qué función llamar y con qué datos de "
"entrada). Los contratos inteligentes pueden modificar y leer el "
"almacenamiento de la blockchain subyacente. Un contrato inteligente tiene su "
"propia dirección y se considera una cuenta de blockchain, lo que significa "
"que puede contener tokens."

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem]"
"(https://ethereum.org/en/developers/docs/evm/), the most commonly used "
"language is Solidity, while on Starknet, it is Cairo. The way the code is "
"compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""
"El lenguaje de programación utilizado para escribir contratos inteligentes "
"varía en función de la blockchain. Por ejemplo, en Ethereum y en el "
"ecosistema [compatible con EVM](https://ethereum.org/en/developers/docs/"
"evm/), el lenguaje más utilizado es Solidity, mientras que en Starknet es "
"Cairo. La forma de compilar el código también difiere en función del "
"blockchain. En Ethereum, Solidity se compila en bytecode. En Starknet, Cairo "
"se compila en Sierra y luego en Cairo Assembly (casm)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
#, fuzzy
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party software (called `oracles`) to access external data (the "
"price of a token for instance)."
msgstr ""
"Los contratos inteligentes poseen varias características únicas. Son "
"**permissionless**, lo que significa que cualquiera puede desplegar un "
"contrato inteligente en la red (dentro del contexto de una cadena de bloques "
"descentralizada, por supuesto). Los contratos inteligentes también son "
"**transparentes**; cualquiera puede acceder a los datos almacenados por el "
"contrato inteligente. El código que compone el contrato también puede ser "
"transparente, lo que permite la **composibilidad**. Esto permite a los "
"desarrolladores escribir contratos inteligentes que utilicen otros contratos "
"inteligentes. Los contratos inteligentes sólo pueden acceder e interactuar "
"con los datos de la cadena de bloques en la que están desplegados. Requieren "
"programas de terceros (llamados \"oráculos\") para acceder a datos externos "
"(el precio de un token, por ejemplo)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"Para que los desarrolladores puedan crear contratos inteligentes que "
"interactúen entre sí, es necesario saber cómo son los demás contratos. Por "
"ello, los desarrolladores de Ethereum empezaron a crear estándares para el "
"desarrollo de contratos inteligentes, los \"ERCxx\". Los dos estándares más "
"usados y famosos son el `ERC20`, usado para construir tokens como `USDC`, "
"`DAI` o `STARK`, y el `ERC721`, para NFTs (Non-fungible tokens) como "
"`CryptoPunks` o `Everai`."

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
#, fuzzy
msgid "Use cases"
msgstr "## Casos de uso"

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""
"Hay muchos casos de uso posibles para los smart-contracts. Los únicos "
"límites son las restricciones técnicas de la cadena de bloques y la "
"creatividad de los desarrolladores."

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
#, fuzzy
msgid "DeFi"
msgstr "#### DeFi"

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""
"Ahora mismo, el principal caso de uso de los smart contracts es similar al "
"de Ethereum o Bitcoin, que consiste esencialmente en manejar dinero. En el "
"contexto del sistema de pago alternativo prometido por Bitcoin, los smart "
"contracts en Ethereum permiten crear aplicaciones financieras "
"descentralizadas que ya no dependen de los intermediarios financieros "
"tradicionales. Es lo que llamamos DeFi (finanzas descentralizadas). DeFi "
"consta de varios proyectos, como aplicaciones de préstamo/endeudamiento, "
"intercambios descentralizados (DEX), derivados en cadena, stablecoins, "
"fondos de cobertura descentralizados, seguros y muchos más."

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
#, fuzzy
msgid "Tokenization"
msgstr "#### Tokenización"

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""
"Los smart contracts pueden facilitar la tokenización de activos del mundo "
"real, como bienes inmuebles, obras de arte o metales preciosos. La "
"tokenización divide un activo en fichas digitales, que pueden negociarse y "
"gestionarse fácilmente en plataformas de cadena de bloques. Esto puede "
"aumentar la liquidez, permitir la propiedad fraccionaria y simplificar el "
"proceso de compraventa."

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
#, fuzzy
msgid "Voting"
msgstr "#### Votación"

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"Los smart contracts pueden utilizarse para crear sistemas de votación "
"seguros y transparentes. Los votos pueden registrarse en la cadena de "
"bloques, lo que garantiza la inmutabilidad y la transparencia. A "
"continuación, el contrato inteligente puede contabilizar automáticamente los "
"votos y declarar los resultados, minimizando las posibilidades de fraude o "
"manipulación."

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
#, fuzzy
msgid "Royalties"
msgstr "#### Royalties"

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""
"Los smart contracts pueden automatizar el pago de derechos de autor para "
"artistas, músicos y otros creadores de contenidos. Cuando un contenido se "
"consume o se vende, el contrato inteligente puede calcular y distribuir "
"automáticamente los derechos de autor a los legítimos propietarios, "
"garantizando una compensación justa y reduciendo la necesidad de "
"intermediarios."

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
#, fuzzy
msgid "Decentralized identities DIDs"
msgstr "#### Identidades descentralizadas DID"

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""
"Los smart contracts pueden utilizarse para crear y gestionar identidades "
"digitales, permitiendo a las personas controlar su información personal y "
"compartirla con terceros de forma segura. El smart contract podría verificar "
"la autenticidad de la identidad de un usuario y conceder o revocar "
"automáticamente el acceso a servicios específicos en función de sus "
"credenciales."

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
#, fuzzy
msgid "The rise of Starknet and Cairo"
msgstr "## El auge de Starknet y Cairo"

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain Trilemma](https://vitalik.ca/"
"general/2021/04/07/sharding.html#the-scalability-trilemma)) in the "
"blockchain space states that it is impossible to achieve a high level of "
"scalability, decentralization, and security simultaneously; trade-offs must "
"be made. Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet Book]"
"(https://book.starknet.io/chapter_4/index.html), which is a great resource "
"to learn more about the Starknet network."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
#, fuzzy
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""
"¿Recuerdas Cairo? Es, de hecho, un lenguaje desarrollado específicamente "
"para trabajar con STARKs y hacerlos de propósito general. Con Cairo, podemos "
"escribir **código demostrable**. En el contexto de Starknet, esto permite "
"probar la corrección de los cálculos de un estado a otro. A diferencia de la "
"mayoría (si no todos) de los competidores de Starknet que optaron por "
"utilizar la EVM (tal cual o adaptada) como capa base, Starknet emplea su "
"propia VM. Esto libera a los desarrolladores de las limitaciones de la EVM, "
"abriendo un abanico más amplio de posibilidades. Junto con la disminución de "
"los costes de transacción, la combinación de Starknet y Cairo crea un campo "
"de juego apasionante para los desarrolladores. La abstracción nativa de "
"cuentas permite una lógica más compleja para las cuentas y los flujos de "
"transacciones. Entre los casos de uso emergentes se incluyen **AI "
"transparente** y las aplicaciones de inteligencia artificial y aprendizaje "
"automático. Por último, los **blockchain games** pueden desarrollarse "
"completamente **en la cadena**. Starknet ha sido diseñado específicamente "
"para maximizar las capacidades de las pruebas STARK para una escalabilidad "
"óptima."

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid ""
"Learn more about Account Abstraction in the [Starknet Book](https://book."
"starknet.io/chapter_5/index.html)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
#, fuzzy
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr "## Programas de Cairo y contratos Starknet"

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
#, fuzzy
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a function `main` that serves as the entry point for this program:"
msgstr ""
"Los contratos Starknet son un subconjunto especial de los programas Cairo, "
"por lo que los conceptos aprendidos previamente en este libro siguen siendo "
"aplicables para escribir contratos Starknet.\n"
"Como ya habrás notado, un programa Cairo siempre debe tener una función "
"`main` que sirve como punto de entrada para este programa:"

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
#, fuzzy
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, "
"and as such, have access to Starknet's state. For a module to be handled as "
"a contract by the compiler, it must be annotated with the `#[starknet::"
"contract]` attribute."
msgstr ""
"Los contratos de Starknet son esencialmente programas que pueden ejecutarse "
"en el SO de Starknet, y como tales, tienen acceso al estado de Starknet. "
"Para que un módulo sea tratado como un contrato por el compilador, debe ser "
"anotado con el atributo `#[contract]`:"

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an "
"example of a basic contract. You will learn how to write a simple contract "
"that stores a single number on the blockchain."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:5
#, fuzzy
msgid "Anatomy of a simple Starknet Contract"
msgstr "Escribiendo Contratos en Starknet"

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet "
"contract. It might not be easy to understand it all at once, but we will go "
"through it step by step:"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:38
#, fuzzy
msgid "Listing 99-1: A simple storage contract"
msgstr "Listado 8-1: Un módulo y función de prueba"

#: src/ch99-01-02-a-simple-contract.md:40
#, fuzzy
msgid ""
"Note: Starknet contracts are defined within [modules](./ch07-02-defining-"
"modules-to-control-scope.md)."
msgstr ""
"> NB: Los contratos Starknet se definen dentro de [modules](./ch06-02-"
"defining-modules-to-control-scope.md)."

#: src/ch99-01-02-a-simple-contract.md:42
#, fuzzy
msgid "What is this contract?"
msgstr "## ¿Qué es un Crate?"

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called "
"`stored_data` of type `u128` (unsigned integer of 128 bits). You can think "
"of it as a single slot in a database that you can query and alter by calling "
"functions of the code that manages the database. The contract defines and "
"exposes publicly the functions `set` and `get` that can be used to modify or "
"retrieve the value of that variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes "
"to the outside world. Here, the interface exposes two functions: `set` and "
"`get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) "
"mechanism from Cairo, we can make sure that the actual implementation of the "
"contract matches its interface. In fact, you will get a compilation error if "
"your contract doesn’t conform with the declared interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:70
msgid ""
"Listing 99-1-bis: A wrong implementation of the interface of the contract. "
"This does not compile."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. The `self` "
"parameter represents the contract state. Seeing the `self` argument passed "
"to `set` tells us that this function might access the state of the contract, "
"as it is what gives us access to the contract’s storage. The `ref` modifier "
"implies that `self` may be modified, meaning that the storage variables of "
"the contract may be modified inside the `set` function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which "
"immediately tells us that it does not modify the state (and indeed, the "
"compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. In the example above, `set` and `get` are "
"public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the "
"example above, `set` and `get` are public functions."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked "
"through a transaction and that can mutate the state of the contract. `set` "
"is an external function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the "
"contract, but that cannot mutate the state of the contract. `get` is a view "
"function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the external functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. "
"The implementation block must be annotated with the `#[external(v0)]` "
"attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions "
"will not be callable from the outside. All functions defined in a block "
"marked as `#[external(v0)]` are consequently _public functions_."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter "
"corresponding to the `self` argument in the trait must be `ContractState`. "
"The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, "
"`ContractState` gives us the ability to emit events. The name "
"`ContractState` is not surprising, as it’s a representation of the "
"contract’s state, which is what we think of `self` in the contract interface "
"trait."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the "
"contract are defined under the implementation of a trait that has a "
"`TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` "
"parameter to the function, allowing access the storage variables of the "
"contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the "
"`read` and `write` methods to either read or write the value of the storage "
"variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:118
msgid ""
"Using `self` and the `write` method to modify the value of a storage variable"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, "
"attempting to modify will result in a compilation error."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a "
"single number that is accessible by anyone in the world. Anyone could call "
"`set` again with a different value and overwrite your number, but the number "
"is still stored in the history of the blockchain. Later, you will see how "
"you can impose access restrictions so that only you can alter the number."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we "
"specified the difference between _public functions, external functions and "
"view functions_, and we mentioned how to interact with _storage_."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid ""
"Where should I define functions that do not need to access the contract's "
"state?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the following example contract that we'll be using throughout this "
"chapter:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:104
msgid "Listing 99-1bis: Our reference contract for this chapter"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:3
#, fuzzy
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"modified anytime once the contract is deployed."
msgstr ""
"Las Storage variables o variables de Almacenamiento permiten guardar datos "
"que se almacenarán en la blockchain en el almacenamiento del contrato. Estos "
"datos son persistentes y se puede acceder a ellos y modificarlos en "
"cualquier momento una vez desplegado el contrato."

#: src/ch99-01-03-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""
"Las variables de almacenamiento en los contratos Starknet se almacenan en "
"una estructura especial llamada `Storage`:"

#: src/ch99-01-03-01-contract-storage.md:96
msgid "A Storage Struct"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:98
msgid ""
"The storage struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"`#[storage]`. This annotation tells the compiler to generate the required "
"code to interact with the blockchain state, and allows you to read and write "
"data from and to storage. Moreover, this allows you to define storage "
"mappings using the `LegacyMap` type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:101
msgid ""
"Each variable stored in the storage struct is stored in a different location "
"in the contract's storage. The storage address of a variable is determined "
"by the variable's name, and the eventual keys of the variable if it is a "
"[mapping](#storing-mappings)."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:103
msgid "Storage Addresses"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:105
msgid "The address of a storage variable is computed as follows:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:107
msgid ""
"If the variable is a single value (not a mapping), the address is the "
"`sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` "
"is Starknet's version of the Keccak256 hash function, whose output is "
"truncated to 250 bits."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:108
#, fuzzy
msgid ""
"If the variable is a [mapping](#storing-mappings), the address of the value "
"at key `k_1,...,k_n` is `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,"
"k_n)` where ℎ is the Pedersen hash and the final value is taken `mod (2^251) "
"− 256`."
msgstr ""
"En los mapeos, la dirección del valor en la clave `k_1,...,k_n` es `h(..."
"h(h(sn_keccak(nombre_variable),k_1),k_2),...,k_n)` donde ℎ\n"
"es el hash de Pedersen y el valor final se toma `mod2251-256`. Puedes "
"obtener más información sobre el esquema de almacenamiento de contratos en "
"la [Documentación de Starknet](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Contracts/contract-storage/#storage_variables)"

#: src/ch99-01-03-01-contract-storage.md:109
msgid ""
"If it is a mapping to complex values (e.g., tuples or structs), then this "
"complex value lies in a continuous segment starting from the address "
"calculated in the previous point. Note that 256 field elements is the "
"current limitation on the maximal size of a complex storage value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:111
#, fuzzy
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""
"Para leer el valor de la variable de almacenamiento `names`, llamamos a la "
"función `read` sobre la variable de almacenamiento `names`, pasando la clave "
"`_address` como parámetro."

#: src/ch99-01-03-01-contract-storage.md:202
msgid "Interacting with Storage Variables"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:204
msgid ""
"Variables stored in the storage struct can be accessed and modified using "
"the `read` and `write` functions, and you can get their address in storage "
"using the `addr` function. These functions are automatically generated by "
"the compiler for each storage variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:206
#, fuzzy
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""
"Para leer el valor de la variable de almacenamiento `names`, llamamos a la "
"función `read` sobre la variable de almacenamiento `names`, pasando la clave "
"`_address` como parámetro."

#: src/ch99-01-03-01-contract-storage.md:297
#, fuzzy
msgid "Calling the `read` function on the `owner` variable"
msgstr ""
"<span class=\"caption\">Listado 9-3: Llamada a la función `read` sobre la "
"variable `names`</span>"

#: src/ch99-01-03-01-contract-storage.md:299
#, fuzzy
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"Para leer el valor de la variable de almacenamiento `names`, llamamos a la "
"función `read` sobre la variable de almacenamiento `names`, pasando la clave "
"`_address` como parámetro."

#: src/ch99-01-03-01-contract-storage.md:390
#, fuzzy
msgid "Calling the `read` function on the `names` variable"
msgstr ""
"<span class=\"caption\">Listado 9-3: Llamada a la función `read` sobre la "
"variable `names`</span>"

#: src/ch99-01-03-01-contract-storage.md:392
msgid ""
"To write a value to a storage variable, we call the `write` function passing "
"in the eventual keys the value as arguments. As with the `read` function, "
"the number of arguments depends on the number of keys - here, we only pass "
"in the value to write to the `owner` variable as it is a simple variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:483
#, fuzzy
msgid "Calling the `write` function on the `owner` variable"
msgstr ""
"<span class=\"caption\">Listado 9-3: Llamada a la función `read` sobre la "
"variable `names`</span>"

#: src/ch99-01-03-01-contract-storage.md:574
#, fuzzy
msgid "Calling the `write` function on the `names` variable"
msgstr ""
"<span class=\"caption\">Listado 9-3: Llamada a la función `read` sobre la "
"variable `names`</span>"

#: src/ch99-01-03-01-contract-storage.md:576
msgid "Storing custom types"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:578
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used "
"to specify how a type should be stored in storage. In order for a type to be "
"stored in storage, it must implement the `Store` trait. Most types from the "
"core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ContractAddress`, etc. implement the `Store` trait and "
"can thus be stored without further action."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:580
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an "
"enum or a struct? In that case, you have to explicitly tell the compiler how "
"to store this type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:582
msgid ""
"In our example, we want to store a `Person` struct in storage, which is "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be achieved by simply adding a `#[derive(starknet::Store)]` attribute on top "
"of our struct definition."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:673
msgid "Structs storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:675
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. "
"The elements of the struct are stored in the same order as they are defined "
"in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [Storage "
"Addresses](#storage-addresses) and can be obtained by calling `var."
"address()`, and subsequent elements are stored at addresses contiguous to "
"the first element. For example, the storage layout for the `owner` variable "
"of type `Person` will result in the following layout:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:679
msgid "Fields"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:679
msgid "Address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:681
msgid "name"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:681
msgid "owner.address()"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:682
msgid "address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:682
msgid "owner.address() +1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:684
#, fuzzy
msgid "Storage mappings"
msgstr "### Storage Mappings"

#: src/ch99-01-03-01-contract-storage.md:686
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. The only way to remove a mapping is to set its value "
"to the default zero value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:689
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:701
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:704
#, fuzzy
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"one in Listing 99-2bis like the popular `allowances` storage variable in the "
"ERC20 Standard which maps an `owner` and an allowed `spender` to its "
"`allowance` amount using multiple keys passed inside a tuple:"
msgstr ""
"También se pueden crear asignaciones más complejas que la del Listado 9-2, "
"como la popular variable de almacenamiento `allowances` de la Norma ERC20, "
"que asigna el `owner` y el `spender` a la `allowance` utilizando tuplas:"

#: src/ch99-01-03-01-contract-storage.md:713
msgid "Listing 99-2bis: Storing mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:715
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [Storage Addresses](#storage-addresses) "
"section. If the key of a mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the `Hash` trait, "
"which can be derived with the `#[derive(Hash)]` attribute. For example, if "
"you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:718
msgid ""
"Similarly, in the case of a nested mapping such as "
"`LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be "
"computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:720
#, fuzzy
msgid ""
"For more details about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Contracts/contract-storage/#storage_variables)"
msgstr ""
"En los mapeos, la dirección del valor en la clave `k_1,...,k_n` es `h(..."
"h(h(sn_keccak(nombre_variable),k_1),k_2),...,k_n)` donde ℎ\n"
"es el hash de Pedersen y el valor final se toma `mod2251-256`. Puedes "
"obtener más información sobre el esquema de almacenamiento de contratos en "
"la [Documentación de Starknet](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Contracts/contract-storage/#storage_variables)"

#: src/ch99-01-03-02-contract-functions.md:3
#, fuzzy
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in contracts:"
msgstr ""
"En esta sección, vamos a ver algunos tipos de funciones populares que se "
"encuentran en la mayoría de los contratos:"

#: src/ch99-01-03-02-contract-functions.md:5
#, fuzzy
msgid "1. Constructors"
msgstr "### 1. Constructores"

#: src/ch99-01-03-02-contract-functions.md:7
#, fuzzy
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""
"Los constructores son un tipo especial de función que sólo se ejecuta una "
"vez al desplegar un contrato, y pueden utilizarse para inicializar el estado "
"del contrato."

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr "Algunas reglas importantes a tener en cuenta:"

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:24
#, fuzzy
msgid "2. Public functions"
msgstr "### Funciones incorporadas (Built-in)"

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They must be defined inside an implementation block annotated with "
"the `#[external(v0)]` attribute. This attribute only affects the visibility "
"(public vs private/internal), but it doesn't inform us on the ability of "
"these functions to modify the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:47
#, fuzzy
msgid "External functions"
msgstr "### 2. Funciones Externas"

#: src/ch99-01-03-02-contract-functions.md:49
#, fuzzy
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally. "
"External functions are _public_ functions where the `self: ContractState` is "
"passed as reference with the `ref` keyword, allowing you to modify the state "
"of the contract."
msgstr ""
"Las funciones externas son funciones que pueden modificar el estado de un "
"contrato. Son públicas y pueden ser llamadas por cualquier otro contrato o "
"externamente.\n"
"Puedes definir funciones externas anotándolas con el atributo `#[external]`:"

#: src/ch99-01-03-02-contract-functions.md:59
#, fuzzy
msgid "View functions"
msgstr "### 3. Ver funciones"

#: src/ch99-01-03-02-contract-functions.md:61
#, fuzzy
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They "
"can be called by other contracts or externally. View functions are _public_ "
"functions where the `self: ContractState` is passed as snapshot, preventing "
"you from modifying the state of the contract."
msgstr ""
"Las funciones de vista son funciones de sólo lectura que permiten acceder a "
"los datos del contrato garantizando al mismo tiempo que no se modifica el "
"estado del contrato. Pueden ser llamadas por otros contratos o "
"externamente.\n"
"Puedes definir funciones de vista anotándolas con el atributo `#[view]`:"

#: src/ch99-01-03-02-contract-functions.md:71
#, fuzzy
msgid ""
"**Note:** It's important to note that both external and view functions are "
"public. To create an internal function in a contract, you will need to "
"define it outside of the implementation block annotated with the "
"`#[external(v0)]` attribute."
msgstr ""
"> **Nota:** Es importante tener en cuenta que, tanto las funciones externas "
"como las de vista son públicas. Para crear una función interna en un "
"contrato, simplemente no la anotes con ningún atributo."

#: src/ch99-01-03-02-contract-functions.md:73
#, fuzzy
msgid "3. Private functions"
msgstr "### 3. Ver funciones"

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the "
"`#[external(v0)]` attribute are private functions (also called internal "
"functions). They can only be called from within the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:90
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next section](./"
"ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:92
msgid ""
"At this point, you might still be wondering if all of this is really "
"necessary if you don't need to access the contract's state in your function "
"(for example, a helper/library function). As a matter of fact, you can also "
"define internal functions outside of implementation blocks. The only reason "
"why we _need_ to define functions inside impl blocks is if we want to access "
"the contract's state."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:1 src/ch99-01-05-00-components.md:29
#, fuzzy
msgid "Events"
msgstr "## Eventos"

#: src/ch99-01-03-03-contract-events.md:3
#, fuzzy
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""
"Los eventos son estructuras de datos personalizadas que emiten los contratos "
"inteligentes durante su ejecución.\n"
"Proporcionan una manera para que los contratos inteligentes se comuniquen "
"con el mundo externo mediante el registro de información\n"
"sobre sucesos específicos en un contrato."

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract "
"could lead to a bad user experience. This is because users may not see their "
"NFTs appear in their wallets (wallets use these indexers to display a user's "
"NFTs)."
msgstr ""
"Los acontecimientos desempeñan un papel crucial en la creación de contratos "
"inteligentes. Tomemos, por ejemplo, las fichas no fungibles (NFT) acuñadas "
"en Starknet. Todos ellos se indexan y almacenan en una base de datos, y "
"luego se muestran a los usuarios mediante el uso de estos eventos. Descuidar "
"la inclusión de un evento dentro de su contrato NFT podría conducir a una "
"mala experiencia de usuario. Esto se debe a que los usuarios pueden no ver "
"sus NFTs aparecer en sus carteras (las carteras utilizan estos indexadores "
"para mostrar los NFTs de un usuario)."

#: src/ch99-01-03-03-contract-events.md:9
#, fuzzy
msgid "Defining events"
msgstr "### Definición de eventos"

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, "
"which implements the `starknet::Event` trait, as enum variants. This trait "
"is defined in the core library as follows:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the Event type, "
"which in our example is the following enum:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and "
"each variant needs to implement the `starknet::Event` trait itself. "
"Moreover, the members of these variants must implement the `Serde` trait (_c."
"f._ [Appendix C: Serializing with Serde](./appendix-03-derivable-traits."
"md)), as keys/data are added to the event using a serialization process."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the Event trait for the variant’s type ."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with "
"the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: "
"name })`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [address]`."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:48
#, fuzzy
msgid "Emitting events"
msgstr "### Emisión de eventos"

#: src/ch99-01-03-03-contract-events.md:50
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a "
"contract that didn't have any corresponding trait."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:18
msgid ""
"It's not the first time that we encounter this attribute, we already talked "
"about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this "
"section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:20
msgid ""
"Recall that in order to access the ContractState in a function, this "
"function must be defined in an implementation block whose generic parameter "
"is `ContractState`. This implies that we first need to define a generic "
"trait that takes a `TContractState`, and then implement this trait for the "
"`ContractState` type. But by using the `#[generate_trait]` attribute, this "
"whole process can be skipped and we can simply define the implementation "
"block directly, without any generic parameter, and use `self: ContractState` "
"in our functions."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:23
msgid ""
"If we had to manually define the trait for the `InternalFunctions` "
"implementation, it would look something like this:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"fewer storage slots. For example, consider a `Sizes` struct with 3 fields of "
"different types. The total size is 8 + 32 + 64 = 104 bits. This is less than "
"the 128 bits of a single `u128`. This means we can pack all 3 fields into a "
"single `u128` variable. Since a storage slot can hold up to 251 bits, our "
"packed value will take only one storage slot instead of 3."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:49
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:58
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:66
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by "
"performing bitshift and additions. The `unpack` reverses this process to "
"extract the original fields back into a struct."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the "
"operations performed in the example: The goal is to pack the `tiny`, "
"`small`, and `medium` fields into a single `u128` value. First, when packing:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. "
"This creates a `u128` value with the low 8 bits set to `tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the "
"value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we "
"add `tiny` to `small` to combine them into a single `u128` value. The value "
"of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits "
"(`TWO_POW_40`) to make space for the previous fields. This takes bits 40-103."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& "
"MASK_8`). This isolates the lowest 8 bits of the packed value, which is "
"`tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the "
"bitmask, then use bitwise AND with the 32 ones bitmask."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, "
"we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr ""

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr ""

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch99-01-05-00-components.md:30
#, fuzzy
msgid "External and internal functions"
msgstr "### 2. Funciones Externas"

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr ""

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in [Contracts](./"
"ch99-01-02-a-simple-contract.md)."
msgstr ""

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [Dispatcher](./ch99-02-02-contract-"
"dispatcher-library-dispatcher-and-system-calls.md) pattern."
msgstr ""

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr ""

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr ""

#: src/ch99-01-05-00-components.md:167
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""

#: src/ch99-01-05-00-components.md:171
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:177
msgid "A closer look at the `impl` block"
msgstr ""

#: src/ch99-01-05-00-components.md:188
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""

#: src/ch99-01-05-00-components.md:193
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) "
"section."
msgstr ""

#: src/ch99-01-05-00-components.md:201
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via `self."
"storage_var_name.read()` or `self.emit(...).`"
msgstr ""

#: src/ch99-01-05-00-components.md:207
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""

#: src/ch99-01-05-00-components.md:210
msgid "Migrating a Contract to a Component"
msgstr ""

#: src/ch99-01-05-00-components.md:212
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""

#: src/ch99-01-05-00-components.md:216
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr ""

#: src/ch99-01-05-00-components.md:217
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""

#: src/ch99-01-05-00-components.md:219
msgid "Adding generic parameters to the `impl` block:"
msgstr ""

#: src/ch99-01-05-00-components.md:220
msgid "Adding `TContractState` as a generic parameter."
msgstr ""

#: src/ch99-01-05-00-components.md:221
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr ""

#: src/ch99-01-05-00-components.md:222
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""

#: src/ch99-01-05-00-components.md:225
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""

#: src/ch99-01-05-00-components.md:230
msgid "Using components inside a contract"
msgstr ""

#: src/ch99-01-05-00-components.md:232
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""

#: src/ch99-01-05-00-components.md:236
msgid "Declare it with the `component!()` macro, specifying"
msgstr ""

#: src/ch99-01-05-00-components.md:238
msgid "The path to the component `path::to::component`."
msgstr ""

#: src/ch99-01-05-00-components.md:239
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""

#: src/ch99-01-05-00-components.md:241
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""

#: src/ch99-01-05-00-components.md:244
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: ownable_component::"
"Event`)."
msgstr ""

#: src/ch99-01-05-00-components.md:249
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""

#: src/ch99-01-05-00-components.md:252
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""

#: src/ch99-01-05-00-components.md:257
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""

#: src/ch99-01-05-00-components.md:263
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""

#: src/ch99-01-05-00-components.md:301
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""

#: src/ch99-01-05-00-components.md:314
msgid "Stacking Components for Maximum Composability"
msgstr ""

#: src/ch99-01-05-00-components.md:316
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You will be able to "
"rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""

#: src/ch99-01-05-00-components.md:322
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr ""

#: src/ch99-01-05-00-components.md:325
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the hood](./"
"ch99-01-05-01-components-under-the-hood)."
msgstr ""

#: src/ch99-01-05-00-components.md:330
msgid "Troubleshooting"
msgstr ""

#: src/ch99-01-05-00-components.md:332
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""

#: src/ch99-01-05-00-components.md:336
msgid "`Trait not found. Not a trait.`"
msgstr ""

#: src/ch99-01-05-00-components.md:338
msgid ""
"This error can occur when you're not importing the component's impl block "
"correctly in your contract. Make sure to respect the following syntax:"
msgstr ""

#: src/ch99-01-05-00-components.md:346
msgid "Referring to our previous example, this would be:"
msgstr ""

#: src/ch99-01-05-00-components.md:353
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`"
msgstr ""

#: src/ch99-01-05-00-components.md:356
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on "
"the action to take. Basically, you forgot to add the component's storage to "
"your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's "
"storage."
msgstr ""

#: src/ch99-01-05-00-components.md:361
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:`"
msgstr ""

#: src/ch99-01-05-00-components.md:364
msgid ""
"Similar to the previous error, the compiler, you forgot to add the "
"component's events to your contract's events. Make sure to add the path to "
"the component's events to your contract's events."
msgstr ""

#: src/ch99-01-05-00-components.md:368
msgid "Components functions are not accessible externally"
msgstr ""

#: src/ch99-01-05-00-components.md:370
msgid ""
"This can happen if you forgot to annotate the component's impl block with "
"`#[abi(embed_v0)]`. Make sure to add this annotation when embedding the "
"component's impl in your contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:17
#, fuzzy
msgid "Let's look at an example to see this in action:"
msgstr "Aquí hay un ejemplo del método `clone` en acción."

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:75
msgid "// generated per component\n"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies ](./ch99-01-05-02-"
"component-dependencies.md) section."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:149
#, fuzzy
msgid "Contract Integration"
msgstr "ABIs e Interacciones entre Contratos Multicapa"

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
#, fuzzy
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr "# Contratos de Starknet: ABIs e interacciones entre cross-contract"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
#, fuzzy
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""
"Este capítulo cubre cómo se pueden lograr interacciones entre contratos "
"multicapa en Starknet. Específicamente, ¡Aprenderá sobre ABIs, interfaces de "
"contrato, los despachadores de contratos y bibliotecas y sus equivalentes de "
"llamadas al sistema de nivel inferior!"

#: src/ch99-02-01-abis-and-interfaces.md:1
#, fuzzy
msgid "ABIs and Contract Interfaces"
msgstr "# ABIs e Interfaces de Contrato"

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""
"Las interacciones entre contratos inteligentes en una cadena de bloques, "
"también conocidas como \"cross-contract\", son una práctica común que nos "
"permite construir contratos flexibles que puedan comunicarse entre sí."

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""
"Para lograr esto en Starknet, se requiere algo que llamamos una interfaz."

#: src/ch99-02-01-abis-and-interfaces.md:7
#, fuzzy
msgid "ABI - Application Binary Interface"
msgstr "ABIs e interfaces"

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:11
#, fuzzy
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"Si bien escribimos nuestras lógicas de contrato inteligente en Cairo de alto "
"nivel, se almacenan en la VM como bytecodes ejecutables que están en "
"formatos binarios. Dado que este bytecode no es legible por humanos, "
"requiere interpretación para ser entendido. Aquí es donde entran en juego "
"los ABI, definiendo métodos específicos que se pueden llamar a un contrato "
"inteligente para su ejecución."

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:15
#, fuzzy
msgid "Interface"
msgstr "## Interfaz"

#: src/ch99-02-01-abis-and-interfaces.md:17
#, fuzzy
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""
"Una interfaz es una lista de definiciones de funciones de un contrato sin "
"implementaciones. En otras palabras, una interfaz especifica las "
"declaraciones de función (nombre, parámetros, visibilidad y valor de "
"retorno) contenidas en un contrato inteligente sin incluir el cuerpo de la "
"función."

#: src/ch99-02-01-abis-and-interfaces.md:20
#, fuzzy
msgid ""
"Contract interfaces in Cairo are traits annotated with the `#[starknet::"
"interface]` attribute. If you are new to traits, check out the dedicated "
"chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Las interfaces en Cairo son traits con el atributo `[abi]`. Si eres nuevo en "
"los traits, consulta el capítulo dedicado a [traits](./ch07-02-traits-in-"
"cairo.md)."

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:55
#, fuzzy
msgid "Listing 99-4: A simple ERC20 Interface"
msgstr ""
"<span class=\"caption\">Listado 9-4: Una interfaz simple de ERC20</span>"

#: src/ch99-02-01-abis-and-interfaces.md:57
#, fuzzy
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""
"En el próximo capítulo, veremos cómo podemos llamar a otros contratos "
"inteligentes utilizando un `Contract Dispatcher`, un `Library Dispatcher`, y "
"`System calls`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid ""
"Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
#, fuzzy
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""
"Cada vez que se crea una interfaz de contrato en Starknet, se crean "
"automáticamente y exportan dos despachadores:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
#, fuzzy
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr ""
"1. El Despachador de Contratos\n"
"2. El Despachador de Bibliotecas"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
#, fuzzy
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""
"1. El Despachador de Contratos\n"
"2. El Despachador de Bibliotecas"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
#, fuzzy
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""
"En este capítulo, discutiremos en detalle cómo funcionan estos despachadores "
"y su uso."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 99-4):"
msgstr ""
"Para desglosar efectivamente los conceptos en este capítulo, utilizaremos la "
"interfaz IERC20 del capítulo anterior (consulte la Lista 9-4):"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
#, fuzzy
msgid "Contract Dispatcher"
msgstr "## Despachador de Contratos"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
#, fuzzy
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""
"**Nota:** El código expandido para nuestra interfaz IERC20 es mucho más "
"robusto, pero para mantener este capítulo conciso y al grano, nos enfocamos "
"en una función de vista `get_name` y una función externa `transfer`."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:37
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
#, fuzzy
msgid "Listing 99-5: An expanded form of the IERC20 trait"
msgstr ""
"<span class=\"caption\">Listado 9-5: Una forma expandida del trait IERC20</"
"span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""
"También es digno de mención que todo esto se abstrae detrás de escena, "
"gracias al poder de los complementos de Cairo."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
#, fuzzy
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "### Llamando contratos usando el Dispatcher de Contrato"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
#, fuzzy
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""
"Este es un ejemplo de un contrato llamado `Dispatcher` que utiliza la "
"interfaz Contract dispatcher para llamar a un contrato ERC-20 en el contexto "
"del contrato ERC-20 y, en el caso de `transfer_token`, alterar el estado del "
"contrato ERC-20:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
#, fuzzy
msgid "Listing 99-6: A sample contract which uses the Contract Dispatcher"
msgstr ""
"<span class=\"caption\">Listado 9-6: Un ejemplo de contrato que utiliza el "
"Contract Dispatcher</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
#, fuzzy
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""
"Como se puede observar, primero tuvimos que importar `IERC20DispatcherTrait` "
"e `IERC20Dispatcher`, los cuales fueron generados y exportados al compilar "
"nuestra interfaz. Luego realizamos llamadas a los métodos implementados para "
"la estructura `IERC20Dispatcher` (`name`, `transfer`, etc.), pasando el "
"parámetro `contract_address` que representa la dirección del contrato que "
"queremos llamar."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
#, fuzzy
msgid "Library Dispatcher"
msgstr "## Dispatcher de Biblioteca"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:157
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
#, fuzzy
msgid "Listing 99-7: An expanded form of the IERC20 trait"
msgstr ""
"<span class=\"caption\">Listado 9-7: Una forma expandida de trait IERC20</"
"span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
#, fuzzy
msgid "Calling Contracts using the Library Dispatcher"
msgstr "### Llamando a Contratos usando el Dispatcher de Biblioteca"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
#, fuzzy
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""
"A continuación se muestra un código de muestra sobre cómo llamar a contratos "
"utilizando el Dispatcher de Biblioteca:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:208
#, fuzzy
msgid "Listing 99-8: A sample contract using the Library Dispatcher"
msgstr ""
"<span class=\"caption\">Listado 9-8: Un contrato de muestra que utiliza el "
"Dispatcher de Biblioteca</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:210
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractBDispatcherTrait` and `IContractBLibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractBLibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in ContractB, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:212
#, fuzzy
msgid "Using low-level syscalls"
msgstr "## Llamando a Contratos usando llamadas de Sistema de bajo nivel"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:214
#, fuzzy
msgid ""
"Another way to call other contracts and classes is to use the `starknet::"
"call_contract_syscall`and `starknet::library_call_syscall` system calls. The "
"dispatchers we described in the previous sections are high-level syntaxes "
"for these low-level system calls."
msgstr ""
"Otra forma de llamar a otros contratos es mediante la llamada de sistema "
"`starknet::call_contract_syscall`. Los Dispatchers que describimos en las "
"secciones anteriores son sintaxis de alto nivel para esta llamada de sistema "
"de bajo nivel."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:216
#, fuzzy
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"El uso de la llamada de sistema `starknet::call_contract_syscall` puede ser "
"útil para la personalización del manejo de errores o para tener más control "
"sobre la serialización/deserialización de los datos de llamada y los datos "
"devueltos. Aquí hay un ejemplo que demuestra una llamada de `transfer` de "
"bajo nivel:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:254
msgid "\"transferFrom\""
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:264
#, fuzzy
msgid "Listing 99-9: A sample contract using syscalls"
msgstr ""
"<span class=\"caption\">Listado 9-9 Un contrato de muestra que implementa "
"llamadas de sistema</span>"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:266
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call, and the call arguments."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:268
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to "
"deserialize ourselves!"
msgstr ""

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:14
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:16
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:20
msgid "/// @dev Function that returns the current vote status\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:22
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:26
msgid "/// @dev Function that allows a user to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:29
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:39
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:48
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:56
msgid "// Register all voters by calling the _register_voters function\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:59
msgid "// Initialize the vote count to 0\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:64
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:72
msgid "/// @dev Represents a vote that was cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:79
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:85
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:88
msgid "/// @dev Returns the voting results\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:95
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:100
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:105
msgid "/// @dev Submit a vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:123
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:126
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:144
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:147
msgid ""
"// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:161
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:164
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:172
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:191
#, fuzzy
msgid "Voting smart contract"
msgstr "Introducción a los smart-contracts"

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:195
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:197
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [Local Development with Katana]"
"(https://book.starknet.io/chapter_3/katana.html) chapter of the Starknet "
"Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo team](https://"
"github.com/dojoengine/dojo/blob/main/crates/katana/README.md). It will allow "
"you to do everything you need to do with Starknet, but locally. It is a "
"great tool for development and testing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Local "
"Development with Katana](https://book.starknet.io/chapter_3/katana.html) "
"chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:210
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:216
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:221
msgid "================="
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:237
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [Account Abstraction]"
"(https://book.starknet.io/chapter_4/index.html) chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:239
msgid "Smart wallets for voting"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:241
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the [Environment setup](https://book."
"starknet.io/chapter_1/environment_setup.html) chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:243
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the [Environment setup](https://book.starknet.io/chapter_1/"
"environment_setup.html) chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Firstly, we create a signer from a private key:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:253
msgid "Then, we create the Account Descriptor:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:259
msgid ""
"The Account Descriptor will look like this. You can get the public key and "
"the smart wallet address from the output of the initial `katana` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:263
#: src/ch99-01-04-01-voting-contract.md:266
#: src/ch99-01-04-01-voting-contract.md:375
msgid "\"version\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:264
msgid "\"variant\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:265
#: src/ch99-01-04-01-voting-contract.md:381
msgid "\"type\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:265
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:267
msgid "\"public_key\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:267
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:269
msgid "\"deployment\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:270
msgid "\"status\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:270
msgid "\"deployed\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:271
msgid "\"class_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:271
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:272
msgid "\"address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:272
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:277
msgid ""
"Copy the Account Descriptor above and paste in the newly created "
"`account0_account.json file`, then replace \"\\<SMART_WALLET_PUBLIC_KEY>\", "
"\"\\<SMART_WALLET_CLASS_HASH>\" and \"\\<SMART_WALLET_ADDRESS>\" with values "
"from the `katana` account used."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:279
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the `--"
"rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:281
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:291
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:293
#, fuzzy
msgid "Contract Deployment"
msgstr "# Apéndice Desarrollo de Contratos"

#: src/ch99-01-04-01-voting-contract.md:295
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:301
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the `--"
"compiler-version x.y.z` flag."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:303
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:305
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can find it [on any block explorer](https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:307
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:309
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:311
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:317
#, fuzzy
msgid "An example command:"
msgstr "Ejemplo incorrecto:"

#: src/ch99-01-04-01-voting-contract.md:323
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:325
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:327
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:329
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:331
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:333
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:337
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:339
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:341
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:347
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:349
msgid "Casting a Vote"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:351
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:353
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:363
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:369
#, fuzzy
msgid "This returns:"
msgstr "Esta expresión:"

#: src/ch99-01-04-01-voting-contract.md:373
msgid "\"transaction_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:373
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:374
msgid "\"max_fee\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:374
msgid "\"0x430e81\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:375
#: src/ch99-01-04-01-voting-contract.md:384
#: src/ch99-01-04-01-voting-contract.md:388
#: src/ch99-01-04-01-voting-contract.md:389
#: src/ch99-01-04-01-voting-contract.md:390
msgid "\"0x1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:376
msgid "\"signature\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:377
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:378
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:380
msgid "\"nonce\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:380
msgid "\"0x3\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:381
msgid "\"INVOKE\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "\"sender_address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:383
msgid "\"calldata\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:385
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"0x0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
#, fuzzy
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""
"Si intenta ejecutar este código, obtendrá un error de tiempo de compilación:"

#: src/ch99-01-04-01-voting-contract.md:398
#, fuzzy
msgid "\"Contract error\""
msgstr "##  Contract StorageVariables de Almacenamiento"

#: src/ch99-01-04-01-voting-contract.md:401
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:405
msgid ""
"\"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:411
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:414
msgid "'USER_ALREADY_VOTED'"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:417
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:425
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:427
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:433
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being solidity or "
"cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automatized by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:16
#, fuzzy
msgid "The StarknetMessaging Contract"
msgstr "# Contratos Inteligentes en Starknet"

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`]"
"(https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/"
"IStarknetMessaging.sol#L6) with functions allowing to send message to L2, "
"receiving messages on L1 from L2 and canceling messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:49
#, fuzzy
msgid " Starknet messaging contract interface"
msgstr "# Contratos de Starknet: ABIs e interacciones entre cross-contract"

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this tutorial](https://github.com/"
"glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) where "
"we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check those addresses [here](https://docs.starknet.io/"
"documentation/tools/important_addresses/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:65
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:74
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:78
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the cairo serialization scheme."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be "
"executed by the sequencer is not bound to any account (the message "
"originates from L1), you must also ensure that you pay enough fees on L1 for "
"your message to be deserialized and processed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:112
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:113
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:123
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "Sending messages from Starknet to Ethereum"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike `L1-"
">L2` messages, `L2->L1` messages must be consumed manually, which means that "
"you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:138
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload as on L2. Then you "
"call `consumeMessageFromL2` by passing the L2 contract address and the "
"payload. Please be aware that the L2 contract address expected by the "
"`consumeMessageFromL2` is the contract address of the account that sends the "
"transaction on L2, and not the address of the contract executing the "
"`send_message_to_l1_syscall`."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:160
msgid "// You can use the message hash if you want here.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:162
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256 "
"in solidity).\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:163
msgid "\"Invalid payload\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:167
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:168
msgid "\"Invalid value\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message. But we are actually using the "
"`consumeMessageFromL2` to validate the inputs (the sender address on L2 and "
"the payload) to ensure we are only consuming valid messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "Cairo Serde"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. On solidity, we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a paylaod from L1 with **TWO** values."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:194
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging in local."
msgstr ""

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""
"Cuando se desarrolla software, asegurarse de que funciona según lo previsto "
"suele ser sencillo. Sin embargo, evitar usos no previstos y vulnerabilidades "
"puede ser más difícil."

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""
"En el desarrollo de contratos inteligentes, la seguridad es muy importante. "
"Un solo error puede provocar la pérdida de activos valiosos o el "
"funcionamiento incorrecto de determinadas características."

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""
"Los Smart contracts se ejecutan en un entorno público en el que cualquiera "
"puede examinar el código e interactuar con él. Cualquier error o "
"vulnerabilidad en el código puede ser explotado por actores maliciosos."

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chances of "
"unexpected behavior or vulnerabilities."
msgstr ""
"Este capítulo presenta recomendaciones generales para escribir contratos "
"inteligentes seguros. Al incorporar estos conceptos durante el desarrollo, "
"puedes crear contratos inteligentes robustos y confiables. Esto reduce las "
"posibilidades de comportamientos inesperados o vulnerabilidades."

#: src/ch99-03-security-considerations.md:11
#, fuzzy
msgid "Disclaimer"
msgstr "## Descargo de responsabilidad"

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""
"Este capítulo no proporciona una lista exhaustiva de todos los posibles "
"problemas de seguridad, y no garantiza que sus contratos sean completamente "
"seguros."

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""
"Si está desarrollando contratos inteligentes para su uso en producción, es "
"muy recomendable llevar a cabo auditorías externas realizadas por expertos "
"en seguridad."

#: src/ch99-03-security-considerations.md:17
#, fuzzy
msgid "Mindset"
msgstr "## Mentalidad"

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contracts flows are designed, not much from "
"the language itself."
msgstr ""
"Cairo es un lenguaje altamente seguro inspirado en rust. Está diseñado de "
"forma que obliga a cubrir todos los casos posibles. Los problemas de "
"seguridad en Starknet surgen principalmente de la forma en que se diseñan "
"los flujos de contratos inteligentes, y no tanto del propio lenguaje."

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""
"Adoptar una mentalidad de seguridad es el paso inicial para escribir "
"contratos inteligentes seguros. Intenta considerar siempre todos los "
"escenarios posibles al escribir código."

#: src/ch99-03-security-considerations.md:23
#, fuzzy
msgid "Viewing smart contract as Finite State Machines"
msgstr "### Ver los smart contracts como Finite State Machines"

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""
"Las transacciones en los smart contracts son atómicas, lo que significa que "
"tienen éxito o fracasan sin realizar ningún cambio."

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""
"Piense en los smart contracts como máquinas de estados: tienen un conjunto "
"de estados iniciales definidos por las restricciones del constructor, y la "
"función externa representa un conjunto de posibles transiciones de estado. "
"Una transacción no es más que una transición de estado."

#: src/ch99-03-security-considerations.md:29
#, fuzzy
msgid ""
"The `assert` or `panic` functions can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-panic."
"md) page."
msgstr ""
"Las funciones `assert` o `panic` pueden utilizarse para validar condiciones "
"antes de realizar acciones específicas. Puede obtener más información sobre "
"ellas en la página [Errores irrecuperables con pánico](./ch09-01-"
"unrecoverable-errors-with-panic.md)."

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr "Estas validaciones pueden incluir:"

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr ""

#: src/ch99-03-security-considerations.md:34
#, fuzzy
msgid "Execution requirements"
msgstr "### Requisitos"

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr ""

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr ""

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert` function to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""
"Por ejemplo, podría utilizar la función `assert` para validar que un usuario "
"tiene fondos suficientes para realizar una transacción de retirada. Si la "
"condición no se cumple, la transacción fallará y el estado del contrato no "
"cambiará."

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""
"El uso de estas funciones para comprobar condiciones añade restricciones que "
"ayudan a definir claramente los límites de las posibles transiciones de "
"estado para cada función de tu smart contract. Estas comprobaciones "
"garantizan que el comportamiento del contrato se mantenga dentro de los "
"límites esperados."

#: src/ch99-03-security-considerations.md:53
#, fuzzy
msgid "Recommendations"
msgstr "## Recomendaciones"

#: src/ch99-03-security-considerations.md:55
#, fuzzy
msgid "Checks Effects Interactions Pattern"
msgstr "### Comprueba Efectos Interacciones Patrón"

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"El patrón Checks Effects Interactions es un patrón de diseño común utilizado "
"para prevenir ataques de reentrada en Ethereum. Aunque la reentrada es más "
"difícil de conseguir en Starknet, se recomienda utilizar este patrón en los "
"smart contracts."

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""
"El patrón consiste en seguir un orden específico de operaciones en sus "
"funciones:"

#: src/ch99-03-security-considerations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr ""

#: src/ch99-03-security-considerations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch99-03-security-considerations.md:67
#, fuzzy
msgid "Access control"
msgstr "### Control de Acceso"

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"El Control de Acceso es el proceso de restringir el acceso a determinadas "
"funciones o recursos. Es un mecanismo de seguridad común utilizado para "
"evitar el acceso no autorizado a información o acciones sensibles. En los "
"contratos inteligentes, algunas funciones pueden a menudo estar restringidas "
"a usuarios o roles específicos."

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""
"Puede implementar el patrón de control de acceso para gestionar fácilmente "
"los permisos. Este patrón consiste en definir un conjunto de funciones y "
"asignarlas a usuarios específicos. Cada función puede entonces restringirse "
"a roles específicos."

#: src/ch99-03-security-considerations.md:92
msgid "// Role 'owner': only one address\n"
msgstr ""

#: src/ch99-03-security-considerations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr ""

#: src/ch99-03-security-considerations.md:103
msgid "// Guard functions to check roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""

#: src/ch99-03-security-considerations.md:131
msgid "// Functions to manage roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""

#: src/ch99-03-security-considerations.md:155
#, fuzzy
msgid "Static analysis tool"
msgstr "### Herramienta de análisis estático"

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""
"El análisis estático se refiere al proceso de examinar el código sin su "
"ejecución, centrándose en su estructura, sintaxis y propiedades. Consiste en "
"analizar el código fuente para identificar posibles problemas, "
"vulnerabilidades o infracciones de normas específicas."

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""
"Mediante la definición de normas, como convenciones de codificación o "
"directrices de seguridad, los desarrolladores pueden utilizar herramientas "
"de análisis estático para comprobar automáticamente el código con respecto a "
"estas normas."

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr "Referencias:"

#: src/ch99-03-security-considerations.md:163
#, fuzzy
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""
"- [Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"

#: src/ch99-03-security-considerations.md:164
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""

#: src/appendix-00.md:3
#, fuzzy
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""
"Las siguientes secciones contienen material de referencia que puede "
"resultarle útil en su \n"
"viaje a Cairo."

#: src/appendix-01-keywords.md:1
#, fuzzy
msgid "Appendix A: Keywords"
msgstr "## Apéndice A: Palabras Clave"

#: src/appendix-01-keywords.md:3
#, fuzzy
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""
"La siguiente lista contiene palabras clave que están reservadas para uso "
"actual o futuro por el lenguaje Cairo\n"
"por el lenguaje Cairo."

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr "Hay dos categorías de (Keyword) palabras clave:"

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
#, fuzzy
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""
"Hay una tercera categoría, que son funciones de la biblioteca central. "
"Aunque sus nombres no están reservados\n"
"no se recomienda utilizarlos como nombres de ningún elemento para seguir las "
"buenas prácticas."

#: src/appendix-01-keywords.md:16
#, fuzzy
msgid "Strict keywords"
msgstr "### Palabras Clave Estrictas"

#: src/appendix-01-keywords.md:18
#, fuzzy
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""
"Estas palabras clave sólo pueden utilizarse en sus contextos correctos.\n"
"No pueden utilizarse como nombres de ningún elemento."

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
#, fuzzy
msgid "`of` - Implementation a trait"
msgstr "## Implementando un Trait"

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:43
#, fuzzy
msgid "`trait` - Define a trait"
msgstr "## Definiendo un Trait"

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
#, fuzzy
msgid "Reserved keywords"
msgstr "### Palabras Clave Reservadas"

#: src/appendix-01-keywords.md:52
#, fuzzy
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""
"Estas palabras clave aún no se utilizan, pero están reservadas para un uso "
"futuro.\n"
"Tienen las mismas restricciones que las palabras clave estrictas.\n"
"El razonamiento detrás de esto es hacer que los programas actuales sean "
"compatibles con futuras versiones de\n"
"Cairo prohibiéndoles usar estas palabras clave."

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
#, fuzzy
msgid "Built-in functions"
msgstr "### Funciones incorporadas (Built-in)"

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""
"El lenguaje de programación Cairo proporciona varias funciones específicas "
"que sirven a un propósito especial. No las cubriremos todas en este libro, "
"pero no se recomienda usar los nombres de estas funciones como nombres de "
"otros elementos."

#: src/appendix-01-keywords.md:85
#, fuzzy
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates "
"to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""
"-`assert` - Esta función comprueba una expresión booleana, y si se evalúa "
"como falsa, desencadena la función de pánico. -`panic` - Esta función "
"termina el programa."

#: src/appendix-02-operators-and-symbols.md:1
#, fuzzy
msgid "Appendix B: Operators and Symbols"
msgstr "# Apéndice B: Operadores y Símbolos"

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr "Este apéndice incluye un glosario de la sintaxis de Cairo."

#: src/appendix-02-operators-and-symbols.md:5
#, fuzzy
msgid "Operators"
msgstr "## Operadores"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""
"La Tabla B-1 contiene los operadores en Cairo, un ejemplo de cómo aparecería "
"el operador en contexto, una breve explicación y si el operador es "
"sobrecargable. Si un operador es sobrecargable, se lista el trait relevante "
"a usar para sobrecargar ese operador."

#: src/appendix-02-operators-and-symbols.md:9
#, fuzzy
msgid "Table B-1: Operators"
msgstr "## Operadores"

#: src/appendix-02-operators-and-symbols.md:11
#, fuzzy
msgid "Operator"
msgstr "## Operadores"

#: src/appendix-02-operators-and-symbols.md:11
#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:65
#: src/appendix-02-operators-and-symbols.md:75
#: src/appendix-02-operators-and-symbols.md:88
#: src/appendix-02-operators-and-symbols.md:96
#: src/appendix-02-operators-and-symbols.md:105
#: src/appendix-02-operators-and-symbols.md:119
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Bitwise or logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
#, fuzzy
msgid "Non-equality comparison"
msgstr "## PartialEq para comparación de igualdad"

#: src/appendix-02-operators-and-symbols.md:14
#: src/appendix-02-operators-and-symbols.md:39
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
#: src/appendix-02-operators-and-symbols.md:22
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`MulEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`@var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
#, fuzzy
msgid "Snapshot"
msgstr "### Snapshots"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`*var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`Add`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`var += expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`AddEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`expr, expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
#: src/appendix-02-operators-and-symbols.md:27
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`-expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`Neg`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Sub`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`var -= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`SubEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`fn(...) -> type`, "
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "\\|...\\| -> type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`expr.ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "Member access"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "Arithmetic division"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`Div`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`var /= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`DivEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
#: src/appendix-02-operators-and-symbols.md:34
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`pat: type`, `ident: type`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
#, fuzzy
msgid "Constraints"
msgstr "##### Constantes"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
#: src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:41
#: src/appendix-02-operators-and-symbols.md:42
msgid "`PartialOrd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
#, fuzzy
msgid "Less than or equal to comparison"
msgstr "## PartialEq para comparación de igualdad"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`var = expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
#, fuzzy
msgid "Equality comparison"
msgstr "## PartialEq para comparación de igualdad"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
#, fuzzy
msgid "Greater than or equal to comparison"
msgstr "## PartialEq para comparación de igualdad"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "expr \\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\|\\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
#, fuzzy
msgid "Non Operator Symbols"
msgstr "## Símbolos No Operadores"

#: src/appendix-02-operators-and-symbols.md:49
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""
"La siguiente lista contiene todos los símbolos que no se utilizan como "
"operadores; es decir, no tienen el mismo comportamiento que una llamada a "
"una función o método."

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""
"La Tabla B-2 muestra símbolos que aparecen solos y son válidos en diversas "
"ubicaciones."

#: src/appendix-02-operators-and-symbols.md:53
#, fuzzy
msgid "Table B-2: Stand-Alone Syntax"
msgstr "<span class=\"caption\">Tabla B-2: Sintaxis Autónoma</span>"

#: src/appendix-02-operators-and-symbols.md:55
#: src/appendix-02-operators-and-symbols.md:65
#: src/appendix-02-operators-and-symbols.md:75
#: src/appendix-02-operators-and-symbols.md:88
#: src/appendix-02-operators-and-symbols.md:96
#: src/appendix-02-operators-and-symbols.md:105
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "`..._u8`, `..._usize`, etc."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:58
msgid "Short string"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""
"La Tabla B-3 muestra los símbolos que se utilizan en el contexto de una ruta "
"de jerarquía de módulos para acceder a un elemento."

#: src/appendix-02-operators-and-symbols.md:63
#, fuzzy
msgid "Table B-3: Path-Related Syntax"
msgstr ""
"<span class=\"caption\">Tabla B-3: Sintaxis Relacionada con la Ruta</span>"

#: src/appendix-02-operators-and-symbols.md:67
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:67
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:68
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""
"La Tabla B-4 muestra los símbolos que aparecen en el contexto del uso de "
"parámetros de tipo genérico."

#: src/appendix-02-operators-and-symbols.md:73
msgid "Table B-4: Generics"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:77
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:77
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:78
msgid ""
"Specifies parameters to generic type, function, or method in an expression; "
"often referred to as turbofish"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
#, fuzzy
msgid "Define generic function"
msgstr "Funciones Genéricas"

#: src/appendix-02-operators-and-symbols.md:80
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""
"La Tabla B-5 muestra los símbolos que aparecen en el contexto de la llamada "
"o definición de macros y la especificación de atributos en un elemento."

#: src/appendix-02-operators-and-symbols.md:86
#, fuzzy
msgid "Table B-5: Macros and Attributes"
msgstr "<span class=\"caption\">Tabla B-5: Macros y Atributos</span>"

#: src/appendix-02-operators-and-symbols.md:90
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:90
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Table B-6 shows symbols that create comments."
msgstr "La Tabla B-6 muestra los símbolos que crean comentarios."

#: src/appendix-02-operators-and-symbols.md:94
#, fuzzy
msgid "Table B-6: Comments"
msgstr "# Comentarios"

#: src/appendix-02-operators-and-symbols.md:98
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:98
#, fuzzy
msgid "Line comment"
msgstr "# Comentarios"

#: src/appendix-02-operators-and-symbols.md:100
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr ""
"La Tabla B-7 muestra los símbolos que aparecen en el contexto del uso de "
"tuplas."

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7: Tuples"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:107
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
#, fuzzy
msgid "Parenthesized expression"
msgstr "Esta expresión:"

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
#, fuzzy
msgid "Tuple expression"
msgstr "Esta expresión:"

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
#, fuzzy
msgid "Tuple type"
msgstr "### El Tipo Tupla"

#: src/appendix-02-operators-and-symbols.md:113
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:115
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr ""
"La Tabla B-8 muestra los contextos en los que se utilizan los corchetes."

#: src/appendix-02-operators-and-symbols.md:117
#, fuzzy
msgid "Table B-8: Curly Brackets"
msgstr "<span class=\"caption\">Tabla B-8: Corchetes</span>"

#: src/appendix-02-operators-and-symbols.md:119
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:121
#, fuzzy
msgid "Block expression"
msgstr "Esta expresión:"

#: src/appendix-02-operators-and-symbols.md:122
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`struct` literal"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
#, fuzzy
msgid "Appendix C: Derivable Traits"
msgstr "# Apéndice C: Traits Derivables"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""
"En varias partes del libro, hemos discutido el atributo `derive`, que puedes "
"aplicar a una definición struct o enum. El atributo `derive` genera código "
"para implementar un trait por defecto en el tipo que has anotado con la "
"sintaxis `derive`."

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""
"En este apéndice, proporcionamos una referencia completa que detalla todos "
"los traits de la biblioteca estándar compatibles con el atributo `derive`."

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""
"Estos traits listados aquí son los únicos definidos por la librería "
"principal que pueden ser implementados en tus tipos usando `derive`. Otros "
"traits definidos en la biblioteca estándar no tienen un comportamiento "
"sensible por defecto, por lo que depende de ti implementarlos de la manera "
"que tenga sentido para lo que estás tratando de lograr."

#: src/appendix-03-derivable-traits.md:9
msgid ""
"The list of derivable traits provided in this appendix does not encompass "
"all possibilities: external libraries can implement `derive` for their own "
"traits, expanding the list of traits compatible with `derive`."
msgstr ""
"La lista de traits derivables proporcionada en este apéndice no abarca todas "
"las posibilidades: las bibliotecas externas pueden implementar `derive` para "
"sus propios rasgos, ampliando la lista de rasgos compatibles con `derive`."

#: src/appendix-03-derivable-traits.md:11
#, fuzzy
msgid "PartialEq for equality comparison"
msgstr "## PartialEq para comparación de igualdad"

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""
"El trait `PartialEq` permite la comparación entre instancias de un tipo por "
"igualdad, habilitando así los operadores == y !=."

#: src/appendix-03-derivable-traits.md:15
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""
"Cuando `PartialEq` se deriva en structs, dos instancias son iguales sólo si "
"todos los campos son iguales, y las instancias no son iguales si algún campo "
"no lo es. Cuando se deriva en enums, cada variante es igual a sí misma y no "
"a las demás variantes."

#: src/appendix-03-derivable-traits.md:36
#, fuzzy
msgid "Clone and Copy for Duplicating Values"
msgstr "## Clonar y Copiar para Duplicar Valores"

#: src/appendix-03-derivable-traits.md:38
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""
"El trait `Clone` proporciona la funcionalidad de crear explícitamente una "
"copia profunda de un valor."

#: src/appendix-03-derivable-traits.md:40
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""
"Derivar `Clone` implementa el método `clone`, que, a su vez, llama a clone "
"en cada uno de los componentes del tipo. Esto significa que todos los campos "
"o valores del tipo también deben implementar `Clone` para derivar `Clone`."

#: src/appendix-03-derivable-traits.md:61
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""
"El trait `Copy` permite la duplicación de valores. Puedes derivar `Copy` de "
"cualquier tipo cuyas partes implementen `Copy`."

#: src/appendix-03-derivable-traits.md:77
msgid "// Copy Trait prevents firs_struct from moving into second_struct\n"
msgstr ""

#: src/appendix-03-derivable-traits.md:81
#, fuzzy
msgid "Serializing with Serde"
msgstr "## Serializar con Serde"

#: src/appendix-03-derivable-traits.md:83
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""
"`Serde` proporciona implementaciones trait para las funciones `serialize` y "
"`deserialize` para estructuras de datos definidas en tu crate. Te permite "
"transformar tu estructura en un array (o lo contrario)."

#: src/appendix-03-derivable-traits.md:108
msgid "Output:"
msgstr "Output:"

#: src/appendix-03-derivable-traits.md:111
msgid "''"
msgstr ""

#: src/appendix-03-derivable-traits.md:111
msgid "'c'"
msgstr ""

#: src/appendix-03-derivable-traits.md:114
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr ""
"Podemos ver aquí que nuestra estructura A ha sido serializada en el array de "
"salida."

#: src/appendix-03-derivable-traits.md:116
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back "
"into our A struct."
msgstr ""
"Además, podemos utilizar la función `deserialize` para convertir el array "
"serializado de nuevo en nuestra estructura A."

#: src/appendix-03-derivable-traits.md:143
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""
"Aquí estamos convirtiendo un array span serializado de nuevo a la estructura "
"A. `deserialize` devuelve una `Option` por lo que necesitamos desenvolverla. "
"Cuando usamos deserialize también necesitamos especificar el tipo al que "
"queremos deserializar."

#: src/appendix-03-derivable-traits.md:145
#, fuzzy
msgid "Drop and Destruct"
msgstr "## Drop y Destruct"

#: src/appendix-03-derivable-traits.md:147
#, fuzzy
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage [here]"
"(ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""
"Cuando se mueve fuera del ámbito, las variables necesitan ser movidas "
"primero. Aquí es donde interviene el rasgo `Drop`. Puedes encontrar más "
"detalles sobre su uso [aquí](ch03-01-what-is-ownership.md#the-drop-trait)."

#: src/appendix-03-derivable-traits.md:149
#, fuzzy
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` [here]"
"(ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""
"Además, los Diccionarios deben ser aplastados antes de salir del ámbito. "
"Llamar manualmente al método `squash` en cada uno de ellos puede ser "
"rápidamente redundante. El trait `Destruct` permite que los Diccionarios "
"sean aplastados automáticamente cuando salen del ámbito. Puedes encontrar "
"más información sobre `Destruct` [aquí](ch03-01-what-is-ownership.md#the-"
"destruct-trait)."

#: src/appendix-03-derivable-traits.md:151
msgid "Store"
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet "
"contract requires the `Store` trait to be implemented for this type. You can "
"automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""

#: src/appendix-03-derivable-traits.md:174
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the "
"Store trait. This `struct A` is subsequently used as a storage variable in "
"the contract."
msgstr ""

#: src/appendix-03-derivable-traits.md:177
#, fuzzy
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr "## PartialOrd y Ord para Ordenar Comparaciones"

#: src/appendix-03-derivable-traits.md:179
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the "
"`PartialOrd` and `Ord` traits to compare values for ordering."
msgstr ""

#: src/appendix-03-derivable-traits.md:181
#, fuzzy
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for "
"ordering, thereby enabling the \\<, \\<=, >, and >= operators."
msgstr ""
"El trait `PartialEq` permite la comparación entre instancias de un tipo por "
"igualdad, habilitando así los operadores == y !=."

#: src/appendix-03-derivable-traits.md:183
msgid ""
"When `PartialOrd` is derived on structs, two instances are ordered by "
"comparing each field in turn."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
#, fuzzy
msgid "Appendix D - Useful Development Tools"
msgstr "## Apéndice D - Herramientas de Desarrollo Útiles"

#: src/appendix-04-useful-development-tools.md:3
#, fuzzy
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"En este apéndice, hablamos de algunas herramientas de desarrollo útiles que "
"el proyecto Cairo\n"
"proporciona. Veremos el formateo automático, formas rápidas de aplicar\n"
"correcciones de advertencias, un linter, y la integración con IDEs."

#: src/appendix-04-useful-development-tools.md:7
#, fuzzy
msgid "Automatic Formatting with `scarb fmt`"
msgstr "### Formateo automático con `cairo-format`"

#: src/appendix-04-useful-development-tools.md:9
#, fuzzy
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"La herramienta `cairo-format` reformatea tu código de acuerdo con el estilo "
"de código de la comunidad. \n"
"Muchos proyectos colaborativos usan `cairo-format` para evitar discusiones "
"sobre \n"
"qué estilo usar al escribir Cairo: todo el mundo formatea su código usando "
"la herramienta."

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr "Para formatear cualquier proyecto de Cairo, introduce lo siguiente:"

#: src/appendix-04-useful-development-tools.md:16
#, fuzzy
msgid "IDE Integration Using `cairo-language-server`"
msgstr "### Integración del IDE Usando `cairo-language-server`"

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-"
"language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/"
"cairo-lang-language-server)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language "
"Server Protocol](http://langserver.org/)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate "
"with each other. Different clients can use `cairo-language-server`, such as "
"[the Cairo extension for Visual Studio Code](https://marketplace."
"visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` [page](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
#, fuzzy
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, "
"jump to definition, and inline errors."
msgstr ""
"Visite la página `vscode-cairo` [page][vscode-cairo]<!-- ignore -->\n"
"para obtener instrucciones de instalación, Usted ganará habilidades tales "
"como autocompletado, saltar a\n"
"y errores en línea."

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
#, fuzzy
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr ""
"## Apéndice E - Tipos y Traits Más Comunes Necesarios para Escribir Contratos"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the [lib.cairo](https://github.com/"
"starkware-libs/cairo/blob/v2.2.0/corelib/src/lib.cairo) file of the corelib "
"crate and contains Cairo's primitive data types, traits, operators, and "
"utility functions. This includes: Data types - felts, bools, arrays, dicts, "
"etc. Traits - behaviors for arithmetic, comparison, serialization Operators "
"- arithmetic, logical, bitwise Utility functions - helpers for arrays, maps, "
"boxing, etc. The core library prelude delivers the fundamental programming "
"constructs and operations needed for basic Cairo programs, without requiring "
"the explicit import of elements. Since the core library prelude is "
"automatically imported, its contents are available for use in any Cairo "
"crate without explicit imports. This prevents repetition and provides a "
"better devX. This is what allows you to use `ArrayTrait::append()` or the "
"`Default` trait without bringing them explicitly into scope."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
#, fuzzy
msgid "List of common types and traits"
msgstr "E - Tipos y Traits más comunes en Cairo"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"The following section provides a brief overview of commonly used types and "
"traits when developing Cairo programs. Most of these are included in the "
"prelude and not required to be imported explicitly - but not all of them."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Import"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Path"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:31
msgid "Usage"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid "`core::option::OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:33
msgid ""
"`OptionTrait<T>` defines a set of methods required to manipulate optional "
"value."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
#, fuzzy
msgid "`ResultTrait`"
msgstr "## El `ResultTrait`"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid "`core::result::ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:34
msgid ""
"`ResultTrait<T, E>` Type for Starknet contract address, a value in the range "
"\\[0, 2 \\*\\* 251)."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
#, fuzzy
msgid "`starknet::ContractAddress`"
msgstr "## Atributos del Contrato Starknet"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:35
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of `t:"
"ContractAddress` is zero or not."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid "`starknet::contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:37
msgid ""
"The `contract_address_const!` it's a function that allows instantiating "
"constant contract address values."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`Into`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an "
"implementation of Into\\<T,S> for the types T and S, you can convert T into "
"S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an "
"implementation of TryInto\\<T,S> for the types T and S, you can convert T "
"into S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid ""
"`get_caller_address()` is a function that returns the address of the caller "
"of the contract. It can be used to identify the caller of a contract "
"function."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
#, fuzzy
msgid ""
"`get_contract_address()` is a function that returns the address of the "
"current contract. It can be used to obtain the address of the contract being "
"executed."
msgstr ""
"Los constructores son un tipo especial de función que sólo se ejecuta una "
"vez al desplegar un contrato, y pueden utilizarse para inicializar el estado "
"del contrato."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""
"Esta no es una lista exhaustiva, pero cubre algunos de los tipos y rasgos "
"más utilizados en el desarrollo de contratos. Para más detalles, consulta la "
"documentación oficial y explora las bibliotecas y frameworks disponibles."

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr ""

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""
"El primer paso es instalar Cairo. Descargaremos Cairo manualmente, "
"utilizando el repositorio de Cairo o un script de instalación. Necesitará "
"una conexión a Internet para la descarga."

#: src/appendix-06-cairo-binaries.md:7
#, fuzzy
msgid "Prerequisites"
msgstr "### Requisitos previos"

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr "Primero deberá tener Rust y Git instalados."

#: src/appendix-06-cairo-binaries.md:12
#, fuzzy
msgid "# Install stable Rust\n"
msgstr "# Instalación"

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr "Install [Git](https://git-scm.com/)."

#: src/appendix-06-cairo-binaries.md:18
#, fuzzy
msgid ""
"Installing Cairo with a Script ([Installer](https://github.com/franalgaba/"
"cairo-installer) by [Fran](https://github.com/franalgaba))"
msgstr ""
"## Instalando Cairo con un Script ([Instalador](https://github.com/"
"franalgaba/cairo-installer) por [Fran](https://github.com/franalgaba))"

#: src/appendix-06-cairo-binaries.md:20
#, fuzzy
msgid "Install"
msgstr "### Instalación"

#: src/appendix-06-cairo-binaries.md:22
#, fuzzy
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.2.0`)."
msgstr ""
"Si deseas instalar una versión específica de Cairo en lugar de la última "
"versión disponible, puedes establecer la variable de entorno `CAIRO_GIT_TAG` "
"(por ejemplo, `export CAIRO_GIT_TAG=v1.1.0`)."

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-environment-"
"for-cairo) to set up your shell environment."
msgstr ""
"Tras la instalación, sigue [estas instrucciones](#set-up-your-shell-"
"environment-for-cairo) para configurar tu entorno shell."

#: src/appendix-06-cairo-binaries.md:30
#, fuzzy
msgid "Update"
msgstr "### Actualización"

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
"installer | bash\n"
"```"
msgstr ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
"installer | bash\n"
"```"

#: src/appendix-06-cairo-binaries.md:37
#, fuzzy
msgid "Uninstall"
msgstr "### Desinstalación"

#: src/appendix-06-cairo-binaries.md:39
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""
"Cairo se instala dentro de `$CAIRO_ROOT` (por defecto: ~/.cairo). Para "
"desinstalarlo, basta con eliminarlo:"

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr "luego elimina estas tres líneas de .bashrc:"

#: src/appendix-06-cairo-binaries.md:48
#, fuzzy
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr "y, por último, reinicia tu shell:"

#: src/appendix-06-cairo-binaries.md:57
#, fuzzy
msgid "Set up your shell environment for Cairo"
msgstr "### Configure su entorno shell para Cairo"

#: src/appendix-06-cairo-binaries.md:59
#, fuzzy
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"- Define la variable de entorno `CAIRO_ROOT` para apuntar a la ruta donde\n"
"  Cairo almacenará sus datos. Por defecto es `$HOME/.cairo`.\n"
"  Si instaló Cairo a través de Git checkout, recomendamos\n"
"  la misma ubicación donde lo clonaste.\n"
"- Añade los ejecutables de `cairo-*` a tu `PATH` si no están ya allí"

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/appendix-06-cairo-binaries.md:65
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""
"La siguiente configuración debería funcionar para la gran mayoría de "
"usuarios en casos de uso comunes."

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:75
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:78 src/appendix-06-cairo-binaries.md:88
#: src/appendix-06-cairo-binaries.md:94 src/appendix-06-cairo-binaries.md:101
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:79 src/appendix-06-cairo-binaries.md:89
#: src/appendix-06-cairo-binaries.md:95 src/appendix-06-cairo-binaries.md:102
#, fuzzy
msgid ""
"'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"'"
msgstr ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to `~/."
"profile`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:123
#, fuzzy
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent from Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""
"En MacOS, es posible que también desee instalar [Fig](https://fig.io/) \n"
"que proporciona complementos de shell alternativos para muchas "
"herramientas \n"
"de línea de comandos con una interfaz emergente similar a IDE en la ventana "
"de \n"
"terminal.\n"
"(Tenga en cuenta que sus complementos son independientes del código base "
"de \n"
"Cairo por lo que pueden estar ligeramente desincronizadas para cambios de\n"
" interfaz de última generación)."

#: src/appendix-06-cairo-binaries.md:129
#, fuzzy
msgid "Restart your shell"
msgstr "### Reinicie su shell"

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr "para que los cambios en el `PATH` surtan efecto."

#: src/appendix-06-cairo-binaries.md:134
msgid "\"$SHELL\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:137
#, fuzzy
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"## Instalando Cairo Manualmente ([Guía](https://github.com/auditless/cairo-"
"template) por [Abdel](https://github.com/abdelhamidbakhta))"

#: src/appendix-06-cairo-binaries.md:139
#, fuzzy
msgid "Step 1: Install Cairo 1.0"
msgstr "### Paso 1: Instalar Cairo 1.0"

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"Si utiliza un sistema Linux x86 y puede utilizar el binario de lanzamiento, "
"descargue Cairo aquí:<https://github.com/starkware-libs/cairo/releases>."

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""
"Para todos los demás, recomendamos compilar Cairo desde el código fuente de "
"la siguiente manera:"

#: src/appendix-06-cairo-binaries.md:146
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:147
msgid "\"${HOME}/.cairo\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:148
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:151
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:154
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:157
msgid "# View tags (you can also do this in the cairo compiler repository)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:159
msgid "# Checkout the version you want\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:162
msgid "# Generate release binaries\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**NOTA: Mantener Cairo actualizado**"

#: src/appendix-06-cairo-binaries.md:171
#, fuzzy
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""
"Ahora que tu compilador Cairo está en un repositorio clonado, todo lo que "
"necesitas hacer\n"
"es extraer los últimos cambios y reconstruir como sigue:"

#: src/appendix-06-cairo-binaries.md:178
#, fuzzy
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr "### Paso 2: Añade los ejecutables de Cairo 1.0 a tu ruta"

#: src/appendix-06-cairo-binaries.md:181
#, fuzzy
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"

#: src/appendix-06-cairo-binaries.md:184
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""
"**NOTA: Si instala desde un binario Linux, adapte la ruta de destino en "
"consecuencia"

#: src/appendix-06-cairo-binaries.md:186
#, fuzzy
msgid "Step 3: Setup Language Server"
msgstr "### Paso 3: Configurar el servidor de idiomas"

#: src/appendix-06-cairo-binaries.md:188
#, fuzzy
msgid "VS Code Extension"
msgstr "#### Extensión VS Code"

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"If you have the previous Cairo 0 extension installed, you can disable/"
"uninstall it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:191
#, fuzzy
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension [here](https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), or "
"just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"- Si tienes instalada la extensión anterior de Cairo 0, puedes desactivarla/"
"desinstalarla.\n"
"- Instala la extensión de Cairo 1 para tener resaltado de sintaxis y "
"navegación de código adecuados. Puedes encontrar el enlace a la extensión "
"[aquí](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1&ssr=false), o simplemente busca \"Cairo 1.0\" en el marketplace de VS "
"Code.\n"
"- La extensión funcionará automáticamente una vez que tengas instalado "
"[Scarb](./ch01-03-hello-scarb.md)."

#: src/appendix-06-cairo-binaries.md:192
msgid ""
"The extension will work out of the box once you will have [Scarb](./ch01-03-"
"hello-scarb.md) installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:194
#, fuzzy
msgid "Cairo Language Server without Scarb"
msgstr "#### Servidor de Lenguaje con Scarb"

#: src/appendix-06-cairo-binaries.md:196
#, fuzzy
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""
"Si no deseas depender de Scarb, aún puedes usar el Cairo Language Server con "
"el binario del compilador.\n"
"A partir del [Paso 1](#installing-cairo-with-a-script-installer-by-fran), el "
"binario `cairo-language-server` debería haber sido construido y ejecutar "
"este comando copiará su ruta en tu portapapeles."

#: src/appendix-06-cairo-binaries.md:203
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""
"Actualiza la `cairo1.languageServerPath` de la extensión Cairo 1.0 pegando "
"la ruta."

#~ msgid "Hello, Scarb!"
#~ msgstr "¡Hola, Scarb!"

#~ msgid "# The Cairo Programming Language"
#~ msgstr "El Lenguaje de Programación Cairo"

#~ msgid "# Foreword"
#~ msgstr "# Prólogo"

#~ msgid "# Introduction"
#~ msgstr "# Introducción"

#~ msgid "## References"
#~ msgstr "## Referencias"

#~ msgid ""
#~ "```bash\n"
#~ "# Install stable Rust\n"
#~ "rustup override set stable && rustup update\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "# Install stable Rust\n"
#~ "rustup override set stable && rustup update\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
#~ "installer | bash\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
#~ "installer | bash\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "rm -fr ~/.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "rm -fr ~/.cairo\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "exec $SHELL\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "exec $SHELL\n"
#~ "```"

#~ msgid ""
#~ "- For **bash**:\n"
#~ "\n"
#~ "  Stock Bash startup files vary widely between distributions in which of "
#~ "them source\n"
#~ "  which, under what circumstances, in what order and what additional "
#~ "configuration they perform.\n"
#~ "  As such, the most reliable way to get Cairo in all environments is to "
#~ "append Cairo\n"
#~ "  configuration commands to both `.bashrc` (for interactive shells)\n"
#~ "  and the profile file that Bash would use (for login shells).\n"
#~ "\n"
#~ "  First, add the commands to `~/.bashrc` by running the following in your "
#~ "terminal:\n"
#~ "\n"
#~ "  ```bash\n"
#~ "  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
#~ "  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/"
#~ "target/release:$PATH\"' >> ~/.bashrc\n"
#~ "  ```\n"
#~ "\n"
#~ "  Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, "
#~ "add the commands there as well.\n"
#~ "  If you have none of these, add them to `~/.profile`.\n"
#~ "\n"
#~ "  - to add to `~/.profile`:\n"
#~ "\n"
#~ "    ```bash\n"
#~ "    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
#~ "    echo 'command -v cairo-compile >/dev/null || export "
#~ "PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile\n"
#~ "    ```\n"
#~ "\n"
#~ "  - to add to `~/.bash_profile`:\n"
#~ "    ```bash\n"
#~ "    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
#~ "    echo 'command -v cairo-compile >/dev/null || export "
#~ "PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
#~ "    ```\n"
#~ "\n"
#~ "- For **Zsh**:\n"
#~ "\n"
#~ "  ```zsh\n"
#~ "  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
#~ "  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/"
#~ "target/release:$PATH\"' >> ~/.zshrc\n"
#~ "  ```\n"
#~ "\n"
#~ "  If you wish to get Cairo in non-interactive login shells as well, also "
#~ "add the commands to `~/.zprofile` or `~/.zlogin`.\n"
#~ "\n"
#~ "- For **Fish shell**:\n"
#~ "\n"
#~ "  If you have Fish 3.2.0 or newer, execute this interactively:\n"
#~ "\n"
#~ "  ```fish\n"
#~ "  set -Ux CAIRO_ROOT $HOME/.cairo\n"
#~ "  fish_add_path $CAIRO_ROOT/target/release\n"
#~ "  ```\n"
#~ "\n"
#~ "  Otherwise, execute the snippet below:\n"
#~ "\n"
#~ "  ```fish\n"
#~ "  set -Ux CAIRO_ROOT $HOME/.cairo\n"
#~ "  set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
#~ "  ```"
#~ msgstr ""
#~ "- Para **bash**:\n"
#~ "  \n"
#~ "  Los archivos de inicio de Bash predeterminados varían ampliamente entre "
#~ "las distribuciones \n"
#~ "  , en cuanto a la fuente de ellos, las circunstancias, el orden y la "
#~ "configuración adicional que realizan. \n"
#~ "  Como tal, la forma más confiable de obtener Cairo en todos los entornos "
#~ "es agregar los comandos\n"
#~ "  de configuración de Cairo tanto en `.bashrc` (para shells interactivos) "
#~ "como en el archivo de perfil \n"
#~ "  que Bash utilizaría (para shells de inicio de sesión).\n"
#~ "\n"
#~ "En primer lugar, agrega los comandos a `~/.bashrc` ejecutando lo "
#~ "siguiente en tu terminal:\n"
#~ "\n"
#~ "  ~~~ bash\n"
#~ "  echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
#~ "  echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/"
#~ "target/release:$PATH\"' >> ~/.bashrc\n"
#~ "  ~~~\n"
#~ "\n"
#~ "Entonces, si tiene `~/.profile`, `~/.bash_profile` o `~/.bash_login`, "
#~ "añada también allí los comandos.\n"
#~ "Si no tienes ninguno de estos, añádelos a `~/.profile`.\n"
#~ "\n"
#~ "  * Para añadir a `~/.profile`:\n"
#~ "      ~~~ bash\n"
#~ "      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
#~ "      echo 'command -v cairo-compile >/dev/null || export "
#~ "PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile\n"
#~ "      ~~~\n"
#~ "\n"
#~ "  * Para añadir a `~/.bash_profile`:\n"
#~ "      ~~~ bash\n"
#~ "      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
#~ "      echo 'command -v cairo-compile >/dev/null || export "
#~ "PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile\n"
#~ "      ~~~\n"
#~ "\n"
#~ "  - Para **Zsh**:\n"
#~ "    ~~~ zsh\n"
#~ "    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
#~ "    echo 'command -v cairo-compile >/dev/null || export "
#~ "PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc\n"
#~ "    ~~~\n"
#~ "\n"
#~ "    Si también desea obtener Cairo en shells de inicio de sesión no "
#~ "interactivos, añada también los comandos a `~/.zprofile` or `~/.zlogin`.\n"
#~ "\n"
#~ "  - Para **Fish shell**:\n"
#~ "\n"
#~ "    Si tiene Fish 3.2.0 o posterior, ejecútelo interactivamente:\n"
#~ "\n"
#~ "    ~~~ fish\n"
#~ "    set -Ux CAIRO_ROOT $HOME/.cairo\n"
#~ "    fish_add_path $CAIRO_ROOT/target/release\n"
#~ "    ~~~\n"
#~ "\n"
#~ "    De lo contrario, ejecute el siguiente fragmento:\n"
#~ "\n"
#~ "    ~~~ fish\n"
#~ "    set -Ux CAIRO_ROOT $HOME/.cairo\n"
#~ "    set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
#~ "    ~~~"

#~ msgid ""
#~ "```sh\n"
#~ "exec \"$SHELL\"\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "exec \"$SHELL\"\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "# Start by defining environment variable CAIRO_ROOT\n"
#~ "export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
#~ "\n"
#~ "# Create .cairo folder if it doesn't exist yet\n"
#~ "mkdir $CAIRO_ROOT\n"
#~ "\n"
#~ "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
#~ "cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
#~ "\n"
#~ "# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
#~ "compiler\n"
#~ "# Fetch all tags (versions)\n"
#~ "git fetch --all --tags\n"
#~ "# View tags (you can also do this in the cairo compiler repository)\n"
#~ "git describe --tags `git rev-list --tags`\n"
#~ "# Checkout the version you want\n"
#~ "git checkout tags/v1.1.0\n"
#~ "\n"
#~ "# Generate release binaries\n"
#~ "cargo build --all --release\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "# Start by defining environment variable CAIRO_ROOT\n"
#~ "export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
#~ "\n"
#~ "# Create .cairo folder if it doesn't exist yet\n"
#~ "mkdir $CAIRO_ROOT\n"
#~ "\n"
#~ "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
#~ "cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
#~ "\n"
#~ "# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
#~ "compiler\n"
#~ "# Fetch all tags (versions)\n"
#~ "git fetch --all --tags\n"
#~ "# View tags (you can also do this in the cairo compiler repository)\n"
#~ "git describe --tags `git rev-list --tags`\n"
#~ "# Checkout the version you want\n"
#~ "git checkout tags/v1.1.0\n"
#~ "\n"
#~ "# Generate release binaries\n"
#~ "cargo build --all --release\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "which cairo-language-server | pbcopy\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "which cairo-language-server | pbcopy\n"
#~ "```"

#~ msgid "## Hello, World"
#~ msgstr "## Hola, Mundo"

#~ msgid ""
#~ "```console\n"
#~ "mkdir ~/cairo_projects\n"
#~ "cd ~/cairo_projects\n"
#~ "mkdir hello_world\n"
#~ "cd hello_world\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "mkdir ~/cairo_projects\n"
#~ "cd ~/cairo_projects\n"
#~ "mkdir hello_world\n"
#~ "cd hello_world\n"
#~ "```"

#~ msgid ""
#~ "```cmd\n"
#~ "> mkdir \"%USERPROFILE%\\projects\"\n"
#~ "> cd /d \"%USERPROFILE%\\projects\"\n"
#~ "> mkdir hello_world\n"
#~ "> cd hello_world\n"
#~ "```"
#~ msgstr ""
#~ "```cmd\n"
#~ "> mkdir \"%USERPROFILE%\\projects\"\n"
#~ "> cd /d \"%USERPROFILE%\\projects\"\n"
#~ "> mkdir hello_world\n"
#~ "> cd hello_world\n"
#~ "```"

#~ msgid "### Writing and Running a Cairo Program"
#~ msgstr "### Escribiendo y Ejecutando un Programa Cairo"

#~ msgid ""
#~ "Next, make a new source file and call it _main.cairo_. Cairo files always "
#~ "end with\n"
#~ "the _.cairo_ extension. If you’re using more than one word in your "
#~ "filename, the\n"
#~ "convention is to use an underscore to separate them. For example, use\n"
#~ "_hello_world.cairo_ rather than _helloworld.cairo_."
#~ msgstr ""
#~ "A continuación, crea un nuevo archivo fuente y llámalo _main.cairo_. Los "
#~ "archivos \n"
#~ "Cairo siempre terminan con la extensión _.cairo_. Si usas más de una "
#~ "palabra en tu \n"
#~ "nombre de archivo, la convención es usar un guión bajo para separarlas. "
#~ "Por ejemplo_, \n"
#~ "hello_mundo.cairo_ en lugar de _helloworld.cairo_."

#~ msgid ""
#~ "Now open the _main.cairo_ file you just created and enter the code in "
#~ "Listing 1-1."
#~ msgstr ""
#~ "Ahora abre el archivo _main.cairo_ que acabas de crear e introduce el "
#~ "código del Listado 1-1."

#~ msgid "<span class=\"filename\">Filename: main.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: main.cairo</span>"

#~ msgid ""
#~ "```rust,file=hello_world.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,file=hello_world.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 1-1: A program that prints `Hello, world!"
#~ "`</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listing 1-1: Un programa que imprime `Hello, "
#~ "world!`</span>"

#~ msgid ""
#~ "Save the file and go back to your terminal window in the\n"
#~ "_~/cairo_projects/hello_world_ directory. Enter the following\n"
#~ "commands to compile and run the file:"
#~ msgstr ""
#~ "Guarde el archivo y vuelva a su ventana de terminal en el directorio\n"
#~ "_~/cairo_projects/hello_world_. Introduzca los siguientes comandos\n"
#~ "para compilar y ejecutar el archivo:"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "Hello, world!\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "Hello, world!\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "fn main() {\n"
#~ "\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "fn main() {\n"
#~ "\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    'Hello, world!'.print();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    'Hello, world!'.print();\n"
#~ "```"

#~ msgid ""
#~ "Just running with `cairo-run` is fine for simple programs, but as your "
#~ "project\n"
#~ "grows, you’ll want to manage all the options and make it easy to share "
#~ "your\n"
#~ "code. Next, we’ll introduce you to the Scarb tool, which will help you "
#~ "write\n"
#~ "real-world Cairo programs."
#~ msgstr ""
#~ "Sólo ejecutar con `cairo-run` está bien para programas simples, pero a "
#~ "medida que tu proyecto\n"
#~ "proyecto crezca, querrá manejar todas las opciones y hacer fácil "
#~ "compartir su código.\n"
#~ "código. A continuación, te presentaremos la herramienta Scarb, que te "
#~ "ayudará a escribir\n"
#~ "programas Cairo del mundo real."

#~ msgid "# Hello, Scarb"
#~ msgstr "# Hola, Scarb"

#~ msgid ""
#~ "If we were to build the 'Hello, world!' project using Scarb, only the "
#~ "part of Scarb that handles building the code would be utilized, since the "
#~ "program doesn't require any external dependencies. As you write more "
#~ "complex Cairo programs, you’ll add dependencies, and if you start a "
#~ "project using Scarb, adding dependencies will be much easier to do."
#~ msgstr ""
#~ "Si fuéramos a construir el proyecto `Hello, world!` usando Scarb, sólo la "
#~ "parte de Scarb que maneja la construcción del código sería utilizada, ya "
#~ "que el programa no requiere ninguna dependencia externa. A medida que "
#~ "escriba programas Cairo más complejos, agregará dependencias, y si inicia "
#~ "un proyecto utilizando Scarb, agregar dependencias será mucho más fácil "
#~ "de hacer."

#~ msgid "### Installation"
#~ msgstr "### Instalación"

#~ msgid ""
#~ "To install Scarb, please refer to the [installation instructions](https://"
#~ "docs.swmansion.com/scarb/download.html).\n"
#~ "You can simply run the following command in your terminal, then follow "
#~ "the onscreen instructions. This will install the latest stable release."
#~ msgstr ""
#~ "Para instalar Scarb, por favor consulta las [instrucciones de instalación]"
#~ "(https://docs.swmansion.com/scarb/docs/install.html).\n"
#~ "Simplemente ejecuta el siguiente comando en tu terminal y sigue las "
#~ "instrucciones en pantalla. Esto instalará la última versión estable."

#~ msgid ""
#~ "```bash\n"
#~ "curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
#~ "install.sh | sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
#~ "install.sh | sh\n"
#~ "```"

#~ msgid ""
#~ "Let’s create a new project using Scarb and look at how it differs from "
#~ "our original “Hello, world!” project."
#~ msgstr ""
#~ "Vamos a crear un nuevo proyecto utilizando Scarb y ver en qué se "
#~ "diferencia de nuestro proyecto original “Hello, world!”."

#~ msgid ""
#~ "```bash\n"
#~ "$ scarb new hello_scarb\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ scarb new hello_scarb\n"
#~ "```"

#~ msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
#~ msgstr "<span class=\"filename\">Filename: Scarb.toml</span>"

#~ msgid ""
#~ "```rust\n"
#~ "mod hello_scarb;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod hello_scarb;\n"
#~ "```"

#~ msgid "<span class=\"filename\">Filename: src/hello_scarb.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: src/hello_scarb.cairo</span>"

#~ msgid ""
#~ "```rust,file=hello_scarb.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, Scarb!'.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,file=hello_scarb.cairo\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    'Hello, Scarb!'.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ scarb build\n"
#~ "   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)\n"
#~ "    Finished release target(s) in 0 seconds\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ scarb build\n"
#~ "   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)\n"
#~ "    Finished release target(s) in 0 seconds\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: "
#~ "5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: "
#~ "5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "> Note: You will notice here that we didn't use a Scarb command, but "
#~ "rather a command from the Cairo binaries directly.\n"
#~ "> As Scarb doesn't have a command to execute Cairo code yet, we have to "
#~ "use the `cairo-run` command directly.\n"
#~ "> We will use this command in the rest of the tutorial, but we will also "
#~ "use Scarb commands to initialize projects."
#~ msgstr ""
#~ "> Nota: Notarás aquí que no usamos un comando de Scarb, sino un comando "
#~ "de los binarios de Cairo directamente.\n"
#~ "> Como Scarb no tiene un comando para ejecutar código de Cairo, tenemos "
#~ "que usar el comando `cairo-run` directamente.\n"
#~ "> Usaremos este comando en el resto del tutorial, pero también usaremos "
#~ "comandos de Scarb para inicializar proyectos."

#~ msgid "### Defining Custom Scripts"
#~ msgstr "### Definición de scripts personalizados"

#~ msgid ""
#~ "We can define Scarb scripts in `Scarb.toml` file, which can be used to "
#~ "execute custom shell scripts.\n"
#~ "Add the following line to your `Scarb.toml` file:"
#~ msgstr ""
#~ "Podemos definir scripts scarb en el archivo `Scarb.toml`, que puede ser "
#~ "usado para ejecutar scripts shell personalizados.\n"
#~ "Añada la siguiente línea a su fichero `Scarb.toml`:"

#~ msgid ""
#~ "```toml\n"
#~ "[scripts]\n"
#~ "run-lib = \"cairo-run src/lib.cairo\"\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[scripts]\n"
#~ "run-lib = \"cairo-run src/lib.cairo\"\n"
#~ "```"

#~ msgid "Now you can run the following command to run the project:"
#~ msgstr ""
#~ "Ahora puede ejecutar el siguiente comando para ejecutar el proyecto:"

#~ msgid ""
#~ "```bash\n"
#~ "$ scarb run run-lib\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: "
#~ "5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ scarb run run-lib\n"
#~ "[DEBUG] Hello, Scarb!                   (raw: "
#~ "5735816763073854913753904210465)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "Using `scarb run` is a convenient way to run custom shell scripts that "
#~ "can be useful to run files and test your project."
#~ msgstr ""
#~ "Usar `scarb run` es una forma conveniente de ejecutar scripts de shell "
#~ "personalizados que pueden ser útiles para ejecutar archivos y probar su "
#~ "proyecto."

#~ msgid ""
#~ "- We can create a project using `scarb new`.\n"
#~ "- We can build a project using `scarb build` to generate the compiled "
#~ "Sierra code.\n"
#~ "- We can define custom scripts in `Scarb.toml` and call them with the "
#~ "`scarb run` command."
#~ msgstr ""
#~ "- Podemos crear un proyecto usando `scarb new`.\n"
#~ "- Podemos construir un proyecto usando `scarb build` para generar el "
#~ "código Sierra compilado.\n"
#~ "- Podemos definir scripts personalizados en `Scarb.toml` y llamarlos con "
#~ "el comando `scarb run`."

#~ msgid ""
#~ "- Install the latest stable version of Cairo\n"
#~ "- Write and run a “Hello, world!” program using `cairo-run` directly\n"
#~ "- Create and run a new project using the conventions of Scarb"
#~ msgstr ""
#~ "- Instalar la última versión estable de Cairo\n"
#~ "- Escribir y ejecutar un programa \" Hello, world!\" usando `cairo-run` "
#~ "directamente\n"
#~ "- Crear y ejecutar un nuevo proyecto usando las convenciones de Scarb"

#~ msgid "# Common Programming Concepts"
#~ msgstr "# Conceptos comunes de programación"

#~ msgid "## Variables and Mutability"
#~ msgstr "## Variables y mutabilidad"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = 6;\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = 6;\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "error: Cannot assign to an immutable variable.\n"
#~ " --> lib.cairo:5:5\n"
#~ "    x = 6;\n"
#~ "    ^***^\n"
#~ "\n"
#~ "Error: failed to compile: src/lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "error: Cannot assign to an immutable variable.\n"
#~ " --> lib.cairo:5:5\n"
#~ "    x = 6;\n"
#~ "    ^***^\n"
#~ "\n"
#~ "Error: failed to compile: src/lib.cairo\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut x = 5;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = 6;\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut x = 5;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = 6;\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\t                              \t(raw: 5)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\t                              \t(raw: 5)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "const ONE_HOUR_IN_SECONDS: u32 = 3600;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    let x = x + 1;\n"
#~ "    {\n"
#~ "        let x = x * 2;\n"
#~ "        'Inner scope x value is:'.print();\n"
#~ "        x.print()\n"
#~ "    }\n"
#~ "    'Outer scope x value is:'.print();\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let x = 5;\n"
#~ "    let x = x + 1;\n"
#~ "    {\n"
#~ "        let x = x * 2;\n"
#~ "        'Inner scope x value is:'.print();\n"
#~ "        x.print()\n"
#~ "    }\n"
#~ "    'Outer scope x value is:'.print();\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "cairo-run src/lib.cairo\n"
#~ "[DEBUG]\tInner scope x value is:        \t(raw: "
#~ "7033328135641142205392067879065573688897582790068499258)\n"
#~ "\n"
#~ "[DEBUG]\n"
#~ "                                      \t(raw: 12)\n"
#~ "\n"
#~ "[DEBUG]\tOuter scope x value is:        \t(raw: "
#~ "7610641743409771490723378239576163509623951327599620922)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "cairo-run src/lib.cairo\n"
#~ "[DEBUG]\tInner scope x value is:        \t(raw: "
#~ "7033328135641142205392067879065573688897582790068499258)\n"
#~ "\n"
#~ "[DEBUG]\n"
#~ "                                      \t(raw: 12)\n"
#~ "\n"
#~ "[DEBUG]\tOuter scope x value is:        \t(raw: "
#~ "7610641743409771490723378239576163509623951327599620922)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 6)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    let x: felt252 = x.into(); // converts x to a felt, type annotation "
#~ "is required.\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    let x: felt252 = x.into(); // converts x to a felt, type annotation "
#~ "is required.\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let mut x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = x.into();\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "use traits::Into;\n"
#~ "fn main() {\n"
#~ "    let mut x = 2;\n"
#~ "    println!("x = {}", x);\n"
#~ "    x = x.into();\n"
#~ "    x.print()\n"
#~ "}\n"
#~ "```"

#~ msgid "## Data Types"
#~ msgstr "## Tipos de datos"

#~ msgid ""
#~ "```rust\n"
#~ "use traits::TryInto;\n"
#~ "use option::OptionTrait;\n"
#~ "fn main() {\n"
#~ "    let x: felt252 = 3;\n"
#~ "    let y: u32 = x.try_into().unwrap();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use traits::TryInto;\n"
#~ "use option::OptionTrait;\n"
#~ "fn main() {\n"
#~ "    let x: felt252 = 3;\n"
#~ "    let y: u32 = x.try_into().unwrap();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "| Length  | Unsigned |\n"
#~ "| ------- | -------- |\n"
#~ "| 8-bit   | `u8`     |\n"
#~ "| 16-bit  | `u16`    |\n"
#~ "| 32-bit  | `u32`    |\n"
#~ "| 64-bit  | `u64`    |\n"
#~ "| 128-bit | `u128`   |\n"
#~ "| 256-bit | `u256`   |\n"
#~ "| 32-bit  | `usize`  |"
#~ msgstr ""
#~ "| Length  | Unsigned |\n"
#~ "| ------- | -------- |\n"
#~ "| 8-bit   | `u8`     |\n"
#~ "| 16-bit  | `u16`    |\n"
#~ "| 32-bit  | `u32`    |\n"
#~ "| 64-bit  | `u64`    |\n"
#~ "| 128-bit | `u128`   |\n"
#~ "| 256-bit | `u256`   |\n"
#~ "| 32-bit  | `usize`  |"

#~ msgid ""
#~ "```rust\n"
#~ "fn sub_u8s(x: u8, y: u8) -> u8 {\n"
#~ "    x - y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    sub_u8s(1, 3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn sub_u8s(x: u8, y: u8) -> u8 {\n"
#~ "    x - y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    sub_u8s(1, 3);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "| Numeric literals | Example   |\n"
#~ "| ---------------- | --------- |\n"
#~ "| Decimal          | `98222`   |\n"
#~ "| Hex              | `0xff`    |\n"
#~ "| Octal            | `0o04321` |\n"
#~ "| Binary           | `0b01`    |"
#~ msgstr ""
#~ "| Numeric literals | Example   |\n"
#~ "| ---------------- | --------- |\n"
#~ "| Decimal          | `98222`   |\n"
#~ "| Hex              | `0xff`    |\n"
#~ "| Octal            | `0o04321` |\n"
#~ "| Binary           | `0b01`    |"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    // addition\n"
#~ "    let sum = 5_u128 + 10_u128;\n"
#~ "\n"
#~ "    // subtraction\n"
#~ "    let difference = 95_u128 - 4_u128;\n"
#~ "\n"
#~ "    // multiplication\n"
#~ "    let product = 4_u128 * 30_u128;\n"
#~ "\n"
#~ "    // division\n"
#~ "    let quotient = 56_u128 / 32_u128; //result is 1\n"
#~ "    let quotient = 64_u128 / 32_u128; //result is 2\n"
#~ "\n"
#~ "    // remainder\n"
#~ "    let remainder = 43_u128 % 5_u128; // result is 3\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    // addition\n"
#~ "    let sum = 5_u128 + 10_u128;\n"
#~ "\n"
#~ "    // subtraction\n"
#~ "    let difference = 95_u128 - 4_u128;\n"
#~ "\n"
#~ "    // multiplication\n"
#~ "    let product = 4_u128 * 30_u128;\n"
#~ "\n"
#~ "    // division\n"
#~ "    let quotient = 56_u128 / 32_u128; //result is 1\n"
#~ "    let quotient = 64_u128 / 32_u128; //result is 2\n"
#~ "\n"
#~ "    // remainder\n"
#~ "    let remainder = 43_u128 % 5_u128; // result is 3\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let t = true;\n"
#~ "\n"
#~ "    let f: bool = false; // with explicit type annotation\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let t = true;\n"
#~ "\n"
#~ "    let f: bool = false; // with explicit type annotation\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    let my_first_char = 'C';\n"
#~ "    let my_first_string = 'Hello world';\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    let my_first_char = 'C';\n"
#~ "    let my_first_string = 'Hello world';\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use traits::TryInto;\n"
#~ "use traits::Into;\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let my_felt252 = 10;\n"
#~ "    // Since a felt252 might not fit in a u8, we need to unwrap the "
#~ "Option<T> type\n"
#~ "    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
#~ "    let my_u16: u16 = my_u8.into();\n"
#~ "    let my_u32: u32 = my_u16.into();\n"
#~ "    let my_u64: u64 = my_u32.into();\n"
#~ "    let my_u128: u128 = my_u64.into();\n"
#~ "    // As a felt252 is smaller than a u256, we can use the into() method\n"
#~ "    let my_u256: u256 = my_felt252.into();\n"
#~ "    let my_usize: usize = my_felt252.try_into().unwrap();\n"
#~ "    let my_other_felt252: felt252 = my_u8.into();\n"
#~ "    let my_third_felt252: felt252 = my_u16.into();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use traits::TryInto;\n"
#~ "use traits::Into;\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let my_felt252 = 10;\n"
#~ "    // Since a felt252 might not fit in a u8, we need to unwrap the "
#~ "Option<T> type\n"
#~ "    let my_u8: u8 = my_felt252.try_into().unwrap();\n"
#~ "    let my_u16: u16 = my_u8.into();\n"
#~ "    let my_u32: u32 = my_u16.into();\n"
#~ "    let my_u64: u64 = my_u32.into();\n"
#~ "    let my_u128: u128 = my_u64.into();\n"
#~ "    // As a felt252 is smaller than a u256, we can use the into() method\n"
#~ "    let my_u256: u256 = my_felt252.into();\n"
#~ "    let my_usize: usize = my_felt252.try_into().unwrap();\n"
#~ "    let my_other_felt252: felt252 = my_u8.into();\n"
#~ "    let my_third_felt252: felt252 = my_u16.into();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let tup: (u32, u64, bool) = (10, 20, true);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let tup: (u32, u64, bool) = (10, 20, true);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let tup = (500, 6, true);\n"
#~ "\n"
#~ "    let (x, y, z) = tup;\n"
#~ "\n"
#~ "    if y == 6 {\n"
#~ "        'y is six!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let tup = (500, 6, true);\n"
#~ "\n"
#~ "    let (x, y, z) = tup;\n"
#~ "\n"
#~ "    if y == 6 {\n"
#~ "        'y is six!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let (x, y): (felt252, felt252) = (2, 3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let (x, y): (felt252, felt252) = (2, 3);\n"
#~ "}\n"
#~ "```"

#~ msgid "## Functions"
#~ msgstr "## Funciones"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn another_function() {\n"
#~ "    'Another function.'.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "    another_function();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn another_function() {\n"
#~ "    'Another function.'.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    'Hello, world!'.print();\n"
#~ "    another_function();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, world!                (raw: "
#~ "5735816763073854953388147237921)\n"
#~ "[DEBUG] Another function.            (raw: "
#~ "22265147635379277118623944509513687592494)\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] Hello, world!                (raw: "
#~ "5735816763073854953388147237921)\n"
#~ "[DEBUG] Another function.            (raw: "
#~ "22265147635379277118623944509513687592494)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252) {\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252) {\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5, 6);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252, y: felt252) {\n"
#~ "    println!("x = {}", x);\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    another_function(5, 6);\n"
#~ "}\n"
#~ "\n"
#~ "fn another_function(x: felt252, y: felt252) {\n"
#~ "    println!("x = {}", x);\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "[DEBUG]                                 (raw: 6)\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG]                                 (raw: 5)\n"
#~ "[DEBUG]                                 (raw: 6)\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn foo(x: u8, y: u8) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_arg = 3;\n"
#~ "    let second_arg = 4;\n"
#~ "    foo(x: first_arg, y: second_arg);\n"
#~ "    let x = 1;\n"
#~ "    let y = 2;\n"
#~ "    foo(:x, :y)\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn foo(x: u8, y: u8) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_arg = 3;\n"
#~ "    let second_arg = 4;\n"
#~ "    foo(x: first_arg, y: second_arg);\n"
#~ "    let x = 1;\n"
#~ "    let y = 2;\n"
#~ "    foo(:x, :y)\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let y = 6;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let y = 6;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile,ignore_format\n"
#~ "fn main() {\n"
#~ "    let x = (let y = 6);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile,ignore_format\n"
#~ "fn main() {\n"
#~ "    let x = (let y = 6);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "error: Missing token TerminalRParen.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "                      ^\n"
#~ "\n"
#~ "error: Skipped tokens. Expected: statement.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "error: Missing token TerminalRParen.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "             ^\n"
#~ "\n"
#~ "error: Missing token TerminalSemicolon.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "                      ^\n"
#~ "\n"
#~ "error: Skipped tokens. Expected: statement.\n"
#~ " --> src/lib.cairo:2:14\n"
#~ "    let x = (let y = 6);\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let y = {\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "    };\n"
#~ "\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let y = {\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "    };\n"
#~ "\n"
#~ "    y.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, does_not_compile, ignore_format\n"
#~ "{\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust, does_not_compile, ignore_format\n"
#~ "{\n"
#~ "        let x = 3;\n"
#~ "        x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn five() -> u32 {\n"
#~ "    5\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = five();\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn five() -> u32 {\n"
#~ "    5\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = five();\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, does_not_compile\n"
#~ "let x = 5;\n"
#~ "```"
#~ msgstr ""
#~ "```rust, does_not_compile\n"
#~ "let x = 5;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = plus_one(5);\n"
#~ "\n"
#~ "    println!("x = {}", x);\n"
#~ "}\n"
#~ "\n"
#~ "fn plus_one(x: u32) -> u32 {\n"
#~ "    x + 1;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() -> felt252 {\n"
#~ "    // start of the function\n"
#~ "    1 + 4 // return the sum of 1 and 4\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() -> felt252 {\n"
#~ "    // start of the function\n"
#~ "    1 + 4 // return the sum of 1 and 4\n"
#~ "}\n"
#~ "```"

#~ msgid "## Control Flow"
#~ msgstr "## Control de Flujo"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let number = 3;\n"
#~ "\n"
#~ "    if number == 5 {\n"
#~ "        'condition was true'.print();\n"
#~ "    } else {\n"
#~ "        'condition was false'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let number = 3;\n"
#~ "\n"
#~ "    if number == 5 {\n"
#~ "        'condition was true'.print();\n"
#~ "    } else {\n"
#~ "        'condition was false'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "[DEBUG]\tcondition was false\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "[DEBUG]\tcondition was false\n"
#~ "```"

#~ msgid ""
#~ "```rust, does_not_compile\n"
#~ "    let number = 5;\n"
#~ "```"
#~ msgstr ""
#~ "```rust, does_not_compile\n"
#~ "    let number = 5;\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "condition was true\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "condition was true\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. "
#~ "Error: Could not specialize libfunc `enum_match` with generic_args: "
#~ "[Type(ConcreteTypeId { id: 1, debug_name: None })]. Error: Provided "
#~ "generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/"
#~ "utils.rs:256:9\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. "
#~ "Error: Could not specialize libfunc `enum_match` with generic_args: "
#~ "[Type(ConcreteTypeId { id: 1, debug_name: None })]. Error: Provided "
#~ "generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/"
#~ "utils.rs:256:9\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let number = 3;\n"
#~ "\n"
#~ "    if number == 12 {\n"
#~ "        'number is 12'.print();\n"
#~ "    } else if number == 3 {\n"
#~ "        'number is 3'.print();\n"
#~ "    } else if number - 2 == 1 {\n"
#~ "        'number minus 2 is 1'.print();\n"
#~ "    } else {\n"
#~ "        'number not found'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let number = 3;\n"
#~ "\n"
#~ "    if number == 12 {\n"
#~ "        'number is 12'.print();\n"
#~ "    } else if number == 3 {\n"
#~ "        'number is 3'.print();\n"
#~ "    } else if number - 2 == 1 {\n"
#~ "        'number minus 2 is 1'.print();\n"
#~ "    } else {\n"
#~ "        'number not found'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "[DEBUG]\tnumber is 3\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "[DEBUG]\tnumber is 3\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let condition = true;\n"
#~ "    let number = if condition {\n"
#~ "        5\n"
#~ "    } else {\n"
#~ "        6\n"
#~ "    };\n"
#~ "\n"
#~ "    if number == 5 {\n"
#~ "        'condition was true'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let condition = true;\n"
#~ "    let number = if condition {\n"
#~ "        5\n"
#~ "    } else {\n"
#~ "        6\n"
#~ "    };\n"
#~ "\n"
#~ "    if number == 5 {\n"
#~ "        'condition was true'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "[DEBUG]\tcondition was true\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run main.cairo\n"
#~ "[DEBUG]\tcondition was true\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo --available-gas=20000000\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "Run panicked with err values: [375233589013918064796019]\n"
#~ "Remaining gas: 1050\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "❯ cairo-run src/lib.cairo --available-gas=20000000\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "[DEBUG]\tagain                          \t(raw: 418346264942)\n"
#~ "\n"
#~ "Run panicked with err values: [375233589013918064796019]\n"
#~ "Remaining gas: 1050\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        'again'.print();\n"
#~ "        i += 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        'again'.print();\n"
#~ "        i += 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        if i == 5 {\n"
#~ "            i += 1;\n"
#~ "            continue;\n"
#~ "        }\n"
#~ "        i.print();\n"
#~ "        i += 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i: usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10 {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        if i == 5 {\n"
#~ "            i += 1;\n"
#~ "            continue;\n"
#~ "        }\n"
#~ "        i.print();\n"
#~ "        i += 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut counter = 0;\n"
#~ "\n"
#~ "    let result = loop {\n"
#~ "        if counter == 10 {\n"
#~ "            break counter * 2;\n"
#~ "        }\n"
#~ "        counter += 1;\n"
#~ "    };\n"
#~ "\n"
#~ "    'The result is '.print();\n"
#~ "    result.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut counter = 0;\n"
#~ "\n"
#~ "    let result = loop {\n"
#~ "        if counter == 10 {\n"
#~ "            break counter * 2;\n"
#~ "        }\n"
#~ "        counter += 1;\n"
#~ "    };\n"
#~ "\n"
#~ "    'The result is '.print();\n"
#~ "    result.print();\n"
#~ "}\n"
#~ "```"

#~ msgid "## Common Collections"
#~ msgstr "## Colecciones Comunes"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, does_not_compile\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "```"
#~ msgstr ""
#~ "```rust, does_not_compile\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "#     a.append(1);\n"
#~ "#     a.append(2);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "#     a.append(1);\n"
#~ "#     a.append(2);\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(10);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "\n"
#~ "    let first_value = a.pop_front().unwrap();\n"
#~ "    first_value.print(); // print '10'\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(10);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "\n"
#~ "    let first_value = a.pop_front().unwrap();\n"
#~ "    first_value.print(); // print '10'\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "    a.append(1);\n"
#~ "\n"
#~ "    let first = *a.at(0);\n"
#~ "    let second = *a.at(1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn main() {\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(0);\n"
#~ "    a.append(1);\n"
#~ "\n"
#~ "    let first = *a.at(0);\n"
#~ "    let second = *a.at(1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "use array::ArrayTrait;\n"
#~ "use box::BoxTrait;\n"
#~ "fn main() -> u128 {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    arr.append(100);\n"
#~ "    let index_to_access =\n"
#~ "        1; // Change this value to see different results, what would "
#~ "happen if the index doesn't exist?\n"
#~ "    match arr.get(index_to_access) {\n"
#~ "        Option::Some(x) => {\n"
#~ "            *x.unbox()\n"
#~ "        // Don't worry about * for now, if you are curious see Chapter "
#~ "3.2 #desnap operator\n"
#~ "        // It basically means \"transform what get(idx) returned into a "
#~ "real value\"\n"
#~ "        },\n"
#~ "        Option::None(_) => {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('out of bounds');\n"
#~ "            panic(data)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "use array::ArrayTrait;\n"
#~ "use box::BoxTrait;\n"
#~ "fn main() -> u128 {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    arr.append(100);\n"
#~ "    let index_to_access =\n"
#~ "        1; // Change this value to see different results, what would "
#~ "happen if the index doesn't exist?\n"
#~ "    match arr.get(index_to_access) {\n"
#~ "        Option::Some(x) => {\n"
#~ "            *x.unbox()\n"
#~ "        // Don't worry about * for now, if you are curious see Chapter "
#~ "3.2 #desnap operator\n"
#~ "        // It basically means \"transform what get(idx) returned into a "
#~ "real value\"\n"
#~ "        },\n"
#~ "        Option::None(_) => {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('out of bounds');\n"
#~ "            panic(data)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use traits::Into;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "enum Data {\n"
#~ "    Integer: u128,\n"
#~ "    Felt: felt252,\n"
#~ "    Tuple: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut messages: Array<Data> = ArrayTrait::new();\n"
#~ "    messages.append(Data::Integer(100));\n"
#~ "    messages.append(Data::Felt('hello world'));\n"
#~ "    messages.append(Data::Tuple((10, 30)));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use traits::Into;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "enum Data {\n"
#~ "    Integer: u128,\n"
#~ "    Felt: felt252,\n"
#~ "    Tuple: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut messages: Array<Data> = ArrayTrait::new();\n"
#~ "    messages.append(Data::Integer(100));\n"
#~ "    messages.append(Data::Felt('hello world'));\n"
#~ "    messages.append(Data::Tuple((10, 30)));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut array = ArrayTrait::new();\n"
#~ "    array.span()\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut array = ArrayTrait::new();\n"
#~ "    array.span()\n"
#~ "# }\n"
#~ "```"

#~ msgid "## Summary"
#~ msgstr "## Resumen"

#~ msgid "## What Is Ownership?"
#~ msgstr "## ¿Qué es Ownership?"

#~ msgid ""
#~ "```rust\n"
#~ "let s = 'hello';\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let s = 'hello';\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    {                      // s is not valid here, it’s not yet declared\n"
#~ "        let s = 'hello';   // s is valid from this point forward\n"
#~ "\n"
#~ "        // do stuff with s\n"
#~ "    }                      // this scope is now over, and s is no longer "
#~ "valid\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# fn main() {\n"
#~ "    {                      // s is not valid here, it’s not yet declared\n"
#~ "        let s = 'hello';   // s is valid from this point forward\n"
#~ "\n"
#~ "        // do stuff with s\n"
#~ "    }                      // this scope is now over, and s is no longer "
#~ "valid\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# fn main() {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    arr.append(1);\n"
#~ "    arr.append(2);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# fn main() {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    arr.append(1);\n"
#~ "    arr.append(2);\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use array::ArrayTrait;\n"
#~ "fn foo(arr: Array<u128>) {}\n"
#~ "\n"
#~ "fn bar(arr: Array<u128>) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    foo(arr);\n"
#~ "    bar(arr);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use array::ArrayTrait;\n"
#~ "fn foo(arr: Array<u128>) {}\n"
#~ "\n"
#~ "fn bar(arr: Array<u128>) {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "    foo(arr);\n"
#~ "    bar(arr);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "error: Variable was previously moved. Trait has no implementation in "
#~ "context: core::traits::Copy::<core::array::Array::<core::integer::u128>>\n"
#~ " --> array.cairo:6:9\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "        ^*****^\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "error: Variable was previously moved. Trait has no implementation in "
#~ "context: core::traits::Copy::<core::array::Array::<core::integer::u128>>\n"
#~ " --> array.cairo:6:9\n"
#~ "    let mut arr = ArrayTrait::<u128>::new();\n"
#~ "        ^*****^\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Point {\n"
#~ "    x: u128,\n"
#~ "    y: u128,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 5, y: 10 };\n"
#~ "    foo(p1);\n"
#~ "    foo(p1);\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(p: Point) {\n"
#~ "    // do something with p\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Point {\n"
#~ "    x: u128,\n"
#~ "    y: u128,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 5, y: 10 };\n"
#~ "    foo(p1);\n"
#~ "    foo(p1);\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(p: Point) {\n"
#~ "    // do something with p\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A {}; // error: Value not dropped.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A {}; // error: Value not dropped.\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A {}; // Now there is no error.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A {}; // Now there is no error.\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use dict::Felt252DictTrait;\n"
#~ "\n"
#~ "struct A {\n"
#~ "    dict: Felt252Dict<u128>\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A { dict: Felt252DictTrait::new() };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use dict::Felt252DictTrait;\n"
#~ "\n"
#~ "struct A {\n"
#~ "    dict: Felt252Dict<u128>\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A { dict: Felt252DictTrait::new() };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "error: Variable not dropped. Trait has no implementation in context: "
#~ "core::traits::Drop::<temp7::temp7::A>. Trait has no implementation in "
#~ "context: core::traits::Destruct::<temp7::temp7::A>.\n"
#~ " --> temp7.cairo:7:5\n"
#~ "    A {\n"
#~ "    ^*^\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "error: Variable not dropped. Trait has no implementation in context: "
#~ "core::traits::Drop::<temp7::temp7::A>. Trait has no implementation in "
#~ "context: core::traits::Destruct::<temp7::temp7::A>.\n"
#~ " --> temp7.cairo:7:5\n"
#~ "    A {\n"
#~ "    ^*^\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use dict::Felt252DictTrait;\n"
#~ "\n"
#~ "#[derive(Destruct)]\n"
#~ "struct A {\n"
#~ "    dict: Felt252Dict<u128>\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A { dict: Felt252DictTrait::new() }; // No error here\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use dict::Felt252DictTrait;\n"
#~ "\n"
#~ "#[derive(Destruct)]\n"
#~ "struct A {\n"
#~ "    dict: Felt252Dict<u128>\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    A { dict: Felt252DictTrait::new() }; // No error here\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use clone::Clone;\n"
#~ "use array::ArrayTCloneImpl;\n"
#~ "fn main() {\n"
#~ "    let arr1 = ArrayTrait::<u128>::new();\n"
#~ "    let arr2 = arr1.clone();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use clone::Clone;\n"
#~ "use array::ArrayTCloneImpl;\n"
#~ "fn main() {\n"
#~ "    let arr1 = ArrayTrait::<u128>::new();\n"
#~ "    let arr2 = arr1.clone();\n"
#~ "}\n"
#~ "```"

#~ msgid "<span class=\"filename\">Filename: src/main.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: src/main.cairo</span>"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Drop)]\n"
#~ "struct MyStruct{}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let my_struct = MyStruct{};  // my_struct comes into scope\n"
#~ "\n"
#~ "    takes_ownership(my_struct);     // my_struct's value moves into the "
#~ "function...\n"
#~ "                                    // ... and so is no longer valid "
#~ "here\n"
#~ "\n"
#~ "    let x = 5;                 // x comes into scope\n"
#~ "\n"
#~ "    makes_copy(x);                  // x would move into the function,\n"
#~ "                                    // but u128 implements Copy, so it is "
#~ "okay to still\n"
#~ "                                    // use x afterward\n"
#~ "\n"
#~ "}                                   // Here, x goes out of scope and is "
#~ "dropped.\n"
#~ "\n"
#~ "\n"
#~ "fn takes_ownership(some_struct: MyStruct) { // some_struct comes into "
#~ "scope\n"
#~ "} // Here, some_struct goes out of scope and `drop` is called.\n"
#~ "\n"
#~ "fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
#~ "} // Here, some_integer goes out of scope and is dropped.\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Drop)]\n"
#~ "struct MyStruct{}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let my_struct = MyStruct{};  // my_struct comes into scope\n"
#~ "\n"
#~ "    takes_ownership(my_struct);     // my_struct's value moves into the "
#~ "function...\n"
#~ "                                    // ... and so is no longer valid "
#~ "here\n"
#~ "\n"
#~ "    let x = 5;                 // x comes into scope\n"
#~ "\n"
#~ "    makes_copy(x);                  // x would move into the function,\n"
#~ "                                    // but u128 implements Copy, so it is "
#~ "okay to still\n"
#~ "                                    // use x afterward\n"
#~ "\n"
#~ "}                                   // Here, x goes out of scope and is "
#~ "dropped.\n"
#~ "\n"
#~ "\n"
#~ "fn takes_ownership(some_struct: MyStruct) { // some_struct comes into "
#~ "scope\n"
#~ "} // Here, some_struct goes out of scope and `drop` is called.\n"
#~ "\n"
#~ "fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
#~ "} // Here, some_integer goes out of scope and is dropped.\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Drop)]\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a1 = gives_ownership();           // gives_ownership moves its "
#~ "return\n"
#~ "                                          // value into a1\n"
#~ "\n"
#~ "    let a2 = A {};                        // a2 comes into scope\n"
#~ "\n"
#~ "    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
#~ "                                          // takes_and_gives_back, which "
#~ "also\n"
#~ "                                          // moves its return value into "
#~ "a3\n"
#~ "\n"
#~ "} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
#~ "  // happens. a1 goes out of scope and is dropped.\n"
#~ "\n"
#~ "fn gives_ownership() -> A {               // gives_ownership will move "
#~ "its\n"
#~ "                                          // return value into the "
#~ "function\n"
#~ "                                          // that calls it\n"
#~ "\n"
#~ "    let some_a = A {};                    // some_a comes into scope\n"
#~ "\n"
#~ "    some_a                                // some_a is returned and\n"
#~ "                                          // moves ownership to the "
#~ "calling\n"
#~ "                                          // function\n"
#~ "}\n"
#~ "\n"
#~ "// This function takes an instance some_a of A and returns it\n"
#~ "fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
#~ "                                          // scope\n"
#~ "\n"
#~ "    some_a                               // some_a is returned and moves\n"
#~ "                                         // ownership to the calling\n"
#~ "                                         // function\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "#[derive(Drop)]\n"
#~ "struct A {}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a1 = gives_ownership();           // gives_ownership moves its "
#~ "return\n"
#~ "                                          // value into a1\n"
#~ "\n"
#~ "    let a2 = A {};                        // a2 comes into scope\n"
#~ "\n"
#~ "    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
#~ "                                          // takes_and_gives_back, which "
#~ "also\n"
#~ "                                          // moves its return value into "
#~ "a3\n"
#~ "\n"
#~ "} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
#~ "  // happens. a1 goes out of scope and is dropped.\n"
#~ "\n"
#~ "fn gives_ownership() -> A {               // gives_ownership will move "
#~ "its\n"
#~ "                                          // return value into the "
#~ "function\n"
#~ "                                          // that calls it\n"
#~ "\n"
#~ "    let some_a = A {};                    // some_a comes into scope\n"
#~ "\n"
#~ "    some_a                                // some_a is returned and\n"
#~ "                                          // moves ownership to the "
#~ "calling\n"
#~ "                                          // function\n"
#~ "}\n"
#~ "\n"
#~ "// This function takes an instance some_a of A and returns it\n"
#~ "fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
#~ "                                          // scope\n"
#~ "\n"
#~ "    some_a                               // some_a is returned and moves\n"
#~ "                                         // ownership to the calling\n"
#~ "                                         // function\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn main() {\n"
#~ "    let arr1 = ArrayTrait::<u128>::new();\n"
#~ "\n"
#~ "    let (arr2, len) = calculate_length(arr1);\n"
#~ "}\n"
#~ "\n"
#~ "fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
#~ "    let length = arr.len(); // len() returns the length of an array\n"
#~ "\n"
#~ "    (arr, length)\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn main() {\n"
#~ "    let arr1 = ArrayTrait::<u128>::new();\n"
#~ "\n"
#~ "    let (arr2, len) = calculate_length(arr1);\n"
#~ "}\n"
#~ "\n"
#~ "fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
#~ "    let length = arr.len(); // len() returns the length of an array\n"
#~ "\n"
#~ "    (arr, length)\n"
#~ "}\n"
#~ "```"

#~ msgid "## References and Snapshots"
#~ msgstr "## Referencias y Snapshots"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this "
#~ "point in time\n"
#~ "    arr1.append(1); // Mutate `arr1` by appending a value\n"
#~ "    let first_length = calculate_length(\n"
#~ "        first_snapshot\n"
#~ "    ); // Calculate the length of the array when the snapshot was taken\n"
#~ "    let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "    first_length.print();\n"
#~ "    second_length.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn calculate_length(arr: @Array<u128>) -> usize {\n"
#~ "    arr.len()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this "
#~ "point in time\n"
#~ "    arr1.append(1); // Mutate `arr1` by appending a value\n"
#~ "    let first_length = calculate_length(\n"
#~ "        first_snapshot\n"
#~ "    ); // Calculate the length of the array when the snapshot was taken\n"
#~ "    let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "    first_length.print();\n"
#~ "    second_length.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn calculate_length(arr: @Array<u128>) -> usize {\n"
#~ "    arr.len()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "[DEBUG]\t                               \t(raw: 0)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 1)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "[DEBUG]\t                               \t(raw: 0)\n"
#~ "\n"
#~ "[DEBUG]\t                              \t(raw: 1)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# use debug::PrintTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this "
#~ "point in time\n"
#~ "#     arr1.append(1); // Mutate `arr1` by appending a value\n"
#~ "#     let first_length = calculate_length(\n"
#~ "#         first_snapshot\n"
#~ "#     ); // Calculate the length of the array when the snapshot was "
#~ "taken\n"
#~ "    let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "#     first_length.print();\n"
#~ "#     second_length.print();\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn calculate_length(arr: @Array<u128>) -> usize {\n"
#~ "#     arr.len()\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# use debug::PrintTrait;\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "#     let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "#     let first_snapshot = @arr1; // Take a snapshot of `arr1` at this "
#~ "point in time\n"
#~ "#     arr1.append(1); // Mutate `arr1` by appending a value\n"
#~ "#     let first_length = calculate_length(\n"
#~ "#         first_snapshot\n"
#~ "#     ); // Calculate the length of the array when the snapshot was "
#~ "taken\n"
#~ "    let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "#     first_length.print();\n"
#~ "#     second_length.print();\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn calculate_length(arr: @Array<u128>) -> usize {\n"
#~ "#     arr.len()\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "The snapshot type is always copyable and droppable, so that you can use "
#~ "it multiple times without worrying about ownership transfers."
#~ msgstr ""
#~ "El tipo de snapshot siempre es copiable y eliminable, para que pueda "
#~ "usarlo varias veces sin preocuparse por las transferencias de propiedad."

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "// does_not_compile\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rec = Rectangle { height: 3, width: 10 };\n"
#~ "    flip(@rec);\n"
#~ "}\n"
#~ "\n"
#~ "fn flip(rec: @Rectangle) {\n"
#~ "    let temp = rec.height;\n"
#~ "    rec.height = rec.width;\n"
#~ "    rec.width = temp;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "// does_not_compile\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rec = Rectangle { height: 3, width: 10 };\n"
#~ "    flip(@rec);\n"
#~ "}\n"
#~ "\n"
#~ "fn flip(rec: @Rectangle) {\n"
#~ "    let temp = rec.height;\n"
#~ "    rec.height = rec.width;\n"
#~ "    rec.width = temp;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "error: Invalid left-hand side of assignment.\n"
#~ " --> ownership.cairo:15:5\n"
#~ "    rec.height = rec.width;\n"
#~ "    ^********^\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "error: Invalid left-hand side of assignment.\n"
#~ " --> ownership.cairo:15:5\n"
#~ "    rec.height = rec.width;\n"
#~ "    ^********^\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rec = Rectangle { height: 3, width: 10 };\n"
#~ "    flip(ref rec);\n"
#~ "    rec.height.print();\n"
#~ "    rec.width.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn flip(ref rec: Rectangle) {\n"
#~ "    let temp = rec.height;\n"
#~ "    rec.height = rec.width;\n"
#~ "    rec.width = temp;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rec = Rectangle { height: 3, width: 10 };\n"
#~ "    flip(ref rec);\n"
#~ "    rec.height.print();\n"
#~ "    rec.width.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn flip(ref rec: Rectangle) {\n"
#~ "    let temp = rec.height;\n"
#~ "    rec.height = rec.width;\n"
#~ "    rec.width = temp;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "[DEBUG]\n"
#~ "                                (raw: 10)\n"
#~ "\n"
#~ "[DEBUG]\t                        (raw: 3)\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "[DEBUG]\n"
#~ "                                (raw: 10)\n"
#~ "\n"
#~ "[DEBUG]\t                        (raw: 3)\n"
#~ "```"

#~ msgid ""
#~ "- At any given time, a variable can only have one owner.\n"
#~ "- You can pass a variable by-value, by-snapshot, or by-reference to a "
#~ "function.\n"
#~ "- If you pass-by-value, ownership of the variable is transferred to the "
#~ "function.\n"
#~ "- If you want to keep ownership of the variable and know that your "
#~ "function won’t mutate it, you can pass it as a snapshot with `@`.\n"
#~ "- If you want to keep ownership of the variable and know that your "
#~ "function will mutate it, you can pass it as a mutable reference with "
#~ "`ref`."
#~ msgstr ""
#~ "- En un momento dado, una variable solo puede tener un propietario.\n"
#~ "- Puedes pasar una variable por valor, por instantánea o por referencia a "
#~ "una función.\n"
#~ "- Si pasas una variable por valor, la propiedad de la variable se "
#~ "transfiere a la función.\n"
#~ "- Si quieres mantener la propiedad de la variable y sabes que tu función "
#~ "no la va a modificar, puedes pasarla como instantánea con `@`.\n"
#~ "- Si quieres mantener la propiedad de la variable y sabes que tu función "
#~ "la modificará, puedes pasarla como referencia mutable con `ref`."

#~ msgid "# Using Structs to Structure Related Data"
#~ msgstr "# Usando structs para estructurar datos relacionados"

#~ msgid "# Defining and Instantiating Structs"
#~ msgstr "# Definiendo e Instanciando una Estructura"

#~ msgid "<span class=\"filename\">Filename: structs.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: structs.cairo</span>"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct User {\n"
#~ "    active: bool,\n"
#~ "    username: felt252,\n"
#~ "    email: felt252,\n"
#~ "    sign_in_count: u64,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct User {\n"
#~ "    active: bool,\n"
#~ "    username: felt252,\n"
#~ "    email: felt252,\n"
#~ "    sign_in_count: u64,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct User {\n"
#~ "    active: bool,\n"
#~ "    username: felt252,\n"
#~ "    email: felt252,\n"
#~ "    sign_in_count: u64,\n"
#~ "}\n"
#~ "fn main() {\n"
#~ "    let user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct User {\n"
#~ "    active: bool,\n"
#~ "    username: felt252,\n"
#~ "    email: felt252,\n"
#~ "    sign_in_count: u64,\n"
#~ "}\n"
#~ "fn main() {\n"
#~ "    let user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "# \n"
#~ "# fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username: username, email: email, "
#~ "sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "# \n"
#~ "# fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username: username, email: email, "
#~ "sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "#     let mut user1 = User {\n"
#~ "#         active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "#     };\n"
#~ "#     user1.email = 'anotheremail@example.com';\n"
#~ "# }\n"
#~ "# \n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User { active: true, username: username, email: email, sign_in_count: "
#~ "1,  }\n"
#~ "}\n"
#~ "# \n"
#~ "# fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "#     let mut user1 = User {\n"
#~ "#         active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "#     };\n"
#~ "#     user1.email = 'anotheremail@example.com';\n"
#~ "# }\n"
#~ "# \n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User { active: true, username: username, email: email, sign_in_count: "
#~ "1,  }\n"
#~ "}\n"
#~ "# \n"
#~ "# fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "#     let mut user1 = User {\n"
#~ "#         active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "#     };\n"
#~ "#     user1.email = 'anotheremail@example.com';\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username: username, email: email, "
#~ "sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "    User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "}\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct User {\n"
#~ "#     active: bool,\n"
#~ "#     username: felt252,\n"
#~ "#     email: felt252,\n"
#~ "#     sign_in_count: u64,\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "#     let mut user1 = User {\n"
#~ "#         active: true, username: 'someusername123', email: "
#~ "'someone@example.com', sign_in_count: 1\n"
#~ "#     };\n"
#~ "#     user1.email = 'anotheremail@example.com';\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "#     User { active: true, username: username, email: email, "
#~ "sign_in_count: 1,  }\n"
#~ "# }\n"
#~ "# \n"
#~ "fn build_user_short(email: felt252, username: felt252) -> User {\n"
#~ "    User { active: true, username, email, sign_in_count: 1,  }\n"
#~ "}\n"
#~ "# \n"
#~ "```"

#~ msgid "# An Example Program Using Structs"
#~ msgstr "# Un Programa de Ejemplo Usando Estructuras"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let width1 = 30;\n"
#~ "    let height1 = 10;\n"
#~ "    let area = area(width1, height1);\n"
#~ "    area.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn area(width: u64, height: u64) -> u64 {\n"
#~ "    width * height\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let width1 = 30;\n"
#~ "    let height1 = 10;\n"
#~ "    let area = area(width1, height1);\n"
#~ "    area.print();\n"
#~ "}\n"
#~ "\n"
#~ "fn area(width: u64, height: u64) -> u64 {\n"
#~ "    width * height\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] ,                               (raw: 300)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ cairo-run src/lib.cairo\n"
#~ "[DEBUG] ,                               (raw: 300)\n"
#~ "\n"
#~ "Run completed successfully, returning []\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn area(width: u64, height: u64) -> u64 {\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn area(width: u64, height: u64) -> u64 {\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let rectangle = (30, 10);\n"
#~ "    let area = area(rectangle);\n"
#~ "    area.print(); // print out the area\n"
#~ "}\n"
#~ "\n"
#~ "fn area(dimension: (u64, u64)) -> u64 {\n"
#~ "    let (x, y) = dimension;\n"
#~ "    x * y\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let rectangle = (30, 10);\n"
#~ "    let area = area(rectangle);\n"
#~ "    area.print(); // print out the area\n"
#~ "}\n"
#~ "\n"
#~ "fn area(dimension: (u64, u64)) -> u64 {\n"
#~ "    let (x, y) = dimension;\n"
#~ "    x * y\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    let area = area(rectangle);\n"
#~ "    area.print(); // print out the area\n"
#~ "}\n"
#~ "\n"
#~ "fn area(rectangle: Rectangle) -> u64 {\n"
#~ "    rectangle.width * rectangle.height\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    let area = area(rectangle);\n"
#~ "    area.print(); // print out the area\n"
#~ "}\n"
#~ "\n"
#~ "fn area(rectangle: Rectangle) -> u64 {\n"
#~ "    rectangle.width * rectangle.height\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    rectangle.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    rectangle.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    rectangle.print();\n"
#~ "}\n"
#~ "\n"
#~ "impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
#~ "    fn print(self: Rectangle) {\n"
#~ "        self.width.print();\n"
#~ "        self.height.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rectangle = Rectangle { width: 30, height: 10,  };\n"
#~ "    rectangle.print();\n"
#~ "}\n"
#~ "\n"
#~ "impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
#~ "    fn print(self: Rectangle) {\n"
#~ "        self.width.print();\n"
#~ "        self.height.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "## Method Syntax"
#~ msgstr "## Sintaxis De Métodos"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        (*self.width) * (*self.height)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "\n"
#~ "    rect1.area().print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        (*self.width) * (*self.height)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "\n"
#~ "    rect1.area().print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleTrait {\n"
#~ "    fn width(self: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn width(self: @Rectangle) -> bool {\n"
#~ "        (*self.width) > 0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "    rect1.width().print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleTrait {\n"
#~ "    fn width(self: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn width(self: @Rectangle) -> bool {\n"
#~ "        (*self.width) > 0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "    rect1.width().print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "    let rect2 = Rectangle { width: 10, height: 40,  };\n"
#~ "    let rect3 = Rectangle { width: 60, height: 45,  };\n"
#~ "\n"
#~ "    'Can rect1 hold rect2?'.print();\n"
#~ "    rect1.can_hold(@rect2).print();\n"
#~ "\n"
#~ "    'Can rect1 hold rect3?'.print();\n"
#~ "    rect1.can_hold(@rect3).print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    width: u64,\n"
#~ "    height: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect1 = Rectangle { width: 30, height: 50,  };\n"
#~ "    let rect2 = Rectangle { width: 10, height: 40,  };\n"
#~ "    let rect3 = Rectangle { width: 60, height: 45,  };\n"
#~ "\n"
#~ "    'Can rect1 hold rect2?'.print();\n"
#~ "    rect1.can_hold(@rect2).print();\n"
#~ "\n"
#~ "    'Can rect1 hold rect3?'.print();\n"
#~ "    rect1.can_hold(@rect3).print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\tCan rec1 hold rect2?           \t(raw: "
#~ "384675147322001379018464490539350216396261044799)\n"
#~ "\n"
#~ "[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
#~ "\n"
#~ "[DEBUG]\tCan rect1 hold rect3?          \t(raw: "
#~ "384675147322001384331925548502381811111693612095)\n"
#~ "\n"
#~ "[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "❯ cairo-run src/lib.cairo\n"
#~ "[DEBUG]\tCan rec1 hold rect2?           \t(raw: "
#~ "384675147322001379018464490539350216396261044799)\n"
#~ "\n"
#~ "[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
#~ "\n"
#~ "[DEBUG]\tCan rect1 hold rect3?          \t(raw: "
#~ "384675147322001384331925548502381811111693612095)\n"
#~ "\n"
#~ "[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn square(size: u64) -> Rectangle;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn square(size: u64) -> Rectangle {\n"
#~ "        Rectangle { width: size, height: size }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn square(size: u64) -> Rectangle;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn square(size: u64) -> Rectangle {\n"
#~ "        Rectangle { width: size, height: size }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleCalc {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "}\n"
#~ "impl RectangleCalcImpl of RectangleCalc {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        (*self.width) * (*self.height)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleCmp {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleCmpImpl of RectangleCmp {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleCalc {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "}\n"
#~ "impl RectangleCalcImpl of RectangleCalc {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        (*self.width) * (*self.height)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "trait RectangleCmp {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleCmpImpl of RectangleCmp {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Enums and Pattern Matching"
#~ msgstr "# Enums y Coincidencia de Patrones"

#~ msgid "# Enums"
#~ msgstr "# Enums"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum Direction {\n"
#~ "    North: (),\n"
#~ "    East: (),\n"
#~ "    South: (),\n"
#~ "    West: (),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum Direction {\n"
#~ "    North: (),\n"
#~ "    East: (),\n"
#~ "    South: (),\n"
#~ "    West: (),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# #[derive(Drop)]\n"
#~ "# enum Direction {\n"
#~ "#     North: (),\n"
#~ "#     East: (),\n"
#~ "#     South: (),\n"
#~ "#     West: (),\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "    let direction = Direction::North(());\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# #[derive(Drop)]\n"
#~ "# enum Direction {\n"
#~ "#     North: (),\n"
#~ "#     East: (),\n"
#~ "#     South: (),\n"
#~ "#     West: (),\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn main() {\n"
#~ "    let direction = Direction::North(());\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum Message {\n"
#~ "    Quit: (),\n"
#~ "    Echo: felt252,\n"
#~ "    Move: (u128, u128),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum Message {\n"
#~ "    Quit: (),\n"
#~ "    Echo: felt252,\n"
#~ "    Move: (u128, u128),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- `Quit` is the unit type - it has no data associated with it at all.\n"
#~ "- `Echo` is a single felt.\n"
#~ "- `Move` is a tuple of two u128 values."
#~ msgstr ""
#~ "- `Quit` no tiene datos asociados en absoluto.\n"
#~ "- `Echo` incluye un solo campo.\n"
#~ "- `Move` incluye dos valores u128."

#~ msgid ""
#~ "```rs\n"
#~ "trait Processing {\n"
#~ "    fn process(self: Message);\n"
#~ "}\n"
#~ "\n"
#~ "impl ProcessingImpl of Processing {\n"
#~ "    fn process(self: Message) {\n"
#~ "        match self {\n"
#~ "            Message::Quit(()) => {\n"
#~ "                'quitting'.print();\n"
#~ "            },\n"
#~ "            Message::Echo(value) => {\n"
#~ "                value.print();\n"
#~ "            },\n"
#~ "            Message::Move((x, y)) => {\n"
#~ "                'moving'.print();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rs\n"
#~ "trait Processing {\n"
#~ "    fn process(self: Message);\n"
#~ "}\n"
#~ "\n"
#~ "impl ProcessingImpl of Processing {\n"
#~ "    fn process(self: Message) {\n"
#~ "        match self {\n"
#~ "            Message::Quit(()) => {\n"
#~ "                'quitting'.print();\n"
#~ "            },\n"
#~ "            Message::Echo(value) => {\n"
#~ "                value.print();\n"
#~ "            },\n"
#~ "            Message::Move((x, y)) => {\n"
#~ "                'moving'.print();\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Drop)]\n"
#~ "# enum Message {\n"
#~ "#     Quit: (),\n"
#~ "#     Echo: felt252,\n"
#~ "#     Move: (u128, u128),\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait Processing {\n"
#~ "#     fn process(self: Message);\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl ProcessingImpl of Processing {\n"
#~ "#     fn process(self: Message) {\n"
#~ "#         match self {\n"
#~ "#             Message::Quit(()) => {\n"
#~ "#                 'quitting'.print();\n"
#~ "#             },\n"
#~ "#             Message::Echo(value) => {\n"
#~ "#                 value.print();\n"
#~ "#             },\n"
#~ "#             Message::Move((x, y)) => {\n"
#~ "#                 'moving'.print();\n"
#~ "#             },\n"
#~ "#         }\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "    let msg: Message = Message::Quit(());\n"
#~ "    msg.process();\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Drop)]\n"
#~ "# enum Message {\n"
#~ "#     Quit: (),\n"
#~ "#     Echo: felt252,\n"
#~ "#     Move: (u128, u128),\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait Processing {\n"
#~ "#     fn process(self: Message);\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl ProcessingImpl of Processing {\n"
#~ "#     fn process(self: Message) {\n"
#~ "#         match self {\n"
#~ "#             Message::Quit(()) => {\n"
#~ "#                 'quitting'.print();\n"
#~ "#             },\n"
#~ "#             Message::Echo(value) => {\n"
#~ "#                 value.print();\n"
#~ "#             },\n"
#~ "#             Message::Move((x, y)) => {\n"
#~ "#                 'moving'.print();\n"
#~ "#             },\n"
#~ "#         }\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# fn main() {\n"
#~ "    let msg: Message = Message::Quit(());\n"
#~ "    msg.process();\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some: T,\n"
#~ "    None: (),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some: T,\n"
#~ "    None: (),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "use option::OptionTrait;\n"
#~ "fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: "
#~ "usize) -> Option<usize> {\n"
#~ "    if index >= arr.len() {\n"
#~ "        return Option::None(());\n"
#~ "    }\n"
#~ "\n"
#~ "    if *arr.at(index) == value {\n"
#~ "        return Option::Some(index);\n"
#~ "    }\n"
#~ "\n"
#~ "    find_value_recursive(arr, value, index + 1)\n"
#~ "}\n"
#~ "\n"
#~ "fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> "
#~ "Option<usize> {\n"
#~ "    let length = arr.len();\n"
#~ "    let mut index = 0;\n"
#~ "    let mut found: Option<usize> = Option::None(());\n"
#~ "    loop {\n"
#~ "        if index < length {\n"
#~ "            if *arr.at(index) == value {\n"
#~ "                found = Option::Some(index);\n"
#~ "                break ();\n"
#~ "            }\n"
#~ "        } else {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        index += 1;\n"
#~ "    };\n"
#~ "    return found;\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "#[available_gas(999999)]\n"
#~ "fn test_increase_amount() {\n"
#~ "    let mut my_array = ArrayTrait::new();\n"
#~ "    my_array.append(3);\n"
#~ "    my_array.append(7);\n"
#~ "    my_array.append(2);\n"
#~ "    my_array.append(5);\n"
#~ "\n"
#~ "    let value_to_find = 7;\n"
#~ "    let result = find_value_recursive(@my_array, value_to_find, 0);\n"
#~ "    let result_i = find_value_iterative(@my_array, value_to_find);\n"
#~ "\n"
#~ "    match result {\n"
#~ "        Option::Some(index) => {\n"
#~ "            if index == 1 {\n"
#~ "                'it worked'.print();\n"
#~ "            }\n"
#~ "        },\n"
#~ "        Option::None(()) => {\n"
#~ "            'not found'.print();\n"
#~ "        },\n"
#~ "    }\n"
#~ "    match result_i {\n"
#~ "        Option::Some(index) => {\n"
#~ "            if index == 1 {\n"
#~ "                'it worked'.print();\n"
#~ "            }\n"
#~ "        },\n"
#~ "        Option::None(()) => {\n"
#~ "            'not found'.print();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "use option::OptionTrait;\n"
#~ "fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: "
#~ "usize) -> Option<usize> {\n"
#~ "    if index >= arr.len() {\n"
#~ "        return Option::None(());\n"
#~ "    }\n"
#~ "\n"
#~ "    if *arr.at(index) == value {\n"
#~ "        return Option::Some(index);\n"
#~ "    }\n"
#~ "\n"
#~ "    find_value_recursive(arr, value, index + 1)\n"
#~ "}\n"
#~ "\n"
#~ "fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> "
#~ "Option<usize> {\n"
#~ "    let length = arr.len();\n"
#~ "    let mut index = 0;\n"
#~ "    let mut found: Option<usize> = Option::None(());\n"
#~ "    loop {\n"
#~ "        if index < length {\n"
#~ "            if *arr.at(index) == value {\n"
#~ "                found = Option::Some(index);\n"
#~ "                break ();\n"
#~ "            }\n"
#~ "        } else {\n"
#~ "            break ();\n"
#~ "        }\n"
#~ "        index += 1;\n"
#~ "    };\n"
#~ "    return found;\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "#[available_gas(999999)]\n"
#~ "fn test_increase_amount() {\n"
#~ "    let mut my_array = ArrayTrait::new();\n"
#~ "    my_array.append(3);\n"
#~ "    my_array.append(7);\n"
#~ "    my_array.append(2);\n"
#~ "    my_array.append(5);\n"
#~ "\n"
#~ "    let value_to_find = 7;\n"
#~ "    let result = find_value_recursive(@my_array, value_to_find, 0);\n"
#~ "    let result_i = find_value_iterative(@my_array, value_to_find);\n"
#~ "\n"
#~ "    match result {\n"
#~ "        Option::Some(index) => {\n"
#~ "            if index == 1 {\n"
#~ "                'it worked'.print();\n"
#~ "            }\n"
#~ "        },\n"
#~ "        Option::None(()) => {\n"
#~ "            'not found'.print();\n"
#~ "        },\n"
#~ "    }\n"
#~ "    match result_i {\n"
#~ "        Option::Some(index) => {\n"
#~ "            if index == 1 {\n"
#~ "                'it worked'.print();\n"
#~ "            }\n"
#~ "        },\n"
#~ "        Option::None(()) => {\n"
#~ "            'not found'.print();\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "# The Match Control Flow Construct"
#~ msgstr "# La Construcción de Control de Flujo Match"

#~ msgid ""
#~ "<!-- TODO : update mention of chapter 18 (on patterns and matching "
#~ "chapter) in paragraph below -->"
#~ msgstr ""
#~ "<!-- TODO : actualizar la mención del capítulo 18 (sobre patrones y "
#~ "concordancia) en el párrafo siguiente -->"

#~ msgid ""
#~ "```rust\n"
#~ "enum Coin {\n"
#~ "    Penny: (),\n"
#~ "    Nickel: (),\n"
#~ "    Dime: (),\n"
#~ "    Quarter: (),\n"
#~ "}\n"
#~ "\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => 1,\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(_) => 25,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "enum Coin {\n"
#~ "    Penny: (),\n"
#~ "    Nickel: (),\n"
#~ "    Dime: (),\n"
#~ "    Quarter: (),\n"
#~ "}\n"
#~ "\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => 1,\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(_) => 25,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum UsState {\n"
#~ "    Alabama: (),\n"
#~ "    Alaska: (),\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Drop)]\n"
#~ "enum Coin {\n"
#~ "    Penny: (),\n"
#~ "    Nickel: (),\n"
#~ "    Dime: (),\n"
#~ "    Quarter: (UsState, ),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "enum UsState {\n"
#~ "    Alabama: (),\n"
#~ "    Alaska: (),\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Drop)]\n"
#~ "enum Coin {\n"
#~ "    Penny: (),\n"
#~ "    Nickel: (),\n"
#~ "    Dime: (),\n"
#~ "    Quarter: (UsState, ),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => 1,\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(state) => {\n"
#~ "            state.print();\n"
#~ "            25\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => 1,\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(state) => {\n"
#~ "            state.print();\n"
#~ "            25\n"
#~ "        },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "impl UsStatePrintImpl of PrintTrait<UsState> {\n"
#~ "    fn print(self: UsState) {\n"
#~ "        match self {\n"
#~ "            UsState::Alabama(_) => ('Alabama').print(),\n"
#~ "            UsState::Alaska(_) => ('Alaska').print(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "impl UsStatePrintImpl of PrintTrait<UsState> {\n"
#~ "    fn print(self: UsState) {\n"
#~ "        match self {\n"
#~ "            UsState::Alabama(_) => ('Alabama').print(),\n"
#~ "            UsState::Alaska(_) => ('Alaska').print(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn plus_one(x: Option<u8>) -> Option<u8> {\n"
#~ "    match x {\n"
#~ "        Option::Some(val) => Option::Some(val + 1),\n"
#~ "        Option::None(_) => Option::None(()),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let five: Option<u8> = Option::Some(5);\n"
#~ "    let six: Option<u8> = plus_one(five);\n"
#~ "    six.unwrap().print();\n"
#~ "    let none = plus_one(Option::None(()));\n"
#~ "    none.unwrap().print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn plus_one(x: Option<u8>) -> Option<u8> {\n"
#~ "    match x {\n"
#~ "        Option::Some(val) => Option::Some(val + 1),\n"
#~ "        Option::None(_) => Option::None(()),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let five: Option<u8> = Option::Some(5);\n"
#~ "    let six: Option<u8> = plus_one(five);\n"
#~ "    six.unwrap().print();\n"
#~ "    let none = plus_one(Option::None(()));\n"
#~ "    none.unwrap().print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "        Option::Some(val) => Option::Some(val + 1),\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        Option::Some(val) => Option::Some(val + 1),\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "        Option::None(_) => Option::None(()),\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        Option::None(_) => Option::None(()),\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn plus_one(x: Option<u8>) -> Option<u8> {\n"
#~ "    match x {\n"
#~ "        Option::Some(val) => Option::Some(val + 1), \n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn plus_one(x: Option<u8>) -> Option<u8> {\n"
#~ "    match x {\n"
#~ "        Option::Some(val) => Option::Some(val + 1), \n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ cairo-run src/test.cairo\n"
#~ "    error: Unsupported match. Currently, matches require one arm per "
#~ "variant,\n"
#~ "    in the order of variant definition.\n"
#~ "    --> test.cairo:34:5\n"
#~ "        match x {\n"
#~ "        ^*******^\n"
#~ "    Error: failed to compile: ./src/test.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ cairo-run src/test.cairo\n"
#~ "    error: Unsupported match. Currently, matches require one arm per "
#~ "variant,\n"
#~ "    in the order of variant definition.\n"
#~ "    --> test.cairo:34:5\n"
#~ "        match x {\n"
#~ "        ^*******^\n"
#~ "    Error: failed to compile: ./src/test.cairo\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn did_i_win(nb: felt252) {\n"
#~ "    match nb {\n"
#~ "        0 => ('You won!').print(),\n"
#~ "        _ => ('You lost...').print(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn did_i_win(nb: felt252) {\n"
#~ "    match nb {\n"
#~ "        0 => ('You won!').print(),\n"
#~ "        _ => ('You lost...').print(),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<!-- TODO : might need to link the end of this chapter to patterns and "
#~ "matching chapter -->"
#~ msgstr ""
#~ "<!-- TODO: puede que necesitemos enlazar el final de este capítulo con el "
#~ "capítulo de patrones y coincidencias -->"

#~ msgid "# Managing Cairo Projects with Packages, Crates and Modules"
#~ msgstr "# Gestión de proyectos Cairo con Paquetes, Crates y Módulos"

#~ msgid ""
#~ "- **Packages:** A Scarb feature that lets you build, test, and share "
#~ "crates\n"
#~ "- **Crates:** A tree of modules that corresponds to a single compilation "
#~ "unit.\n"
#~ "  It has a root directory, and a root module defined at the file `lib."
#~ "cairo` under this directory.\n"
#~ "- **Modules** and **use:** Let you control the organization and scope of "
#~ "items.\n"
#~ "- **Paths:** A way of naming an item, such as a struct, function, or "
#~ "module"
#~ msgstr ""
#~ "- **Paquetes:** Una característica de Scarb que le permite construir, "
#~ "probar y compartir Crates.\n"
#~ "- **Crates:** Un árbol de módulos que corresponde a una única unidad de "
#~ "compilación. Tiene un directorio\n"
#~ " raíz y un módulo raíz definido en el archivo `lib.cairo` bajo este "
#~ "directorio.\n"
#~ "- **Módulos** y **use:** le permiten controlar la organización y el "
#~ "ámbito de los elementos.\n"
#~ "- **Rutas:** una forma de nombrar un elemento, como una estructura, "
#~ "función o módulo"

#~ msgid "# Packages and Crates"
#~ msgstr "# Paquetes y Crates"

#~ msgid ""
#~ "```bash\n"
#~ "scarb new my_package\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "scarb new my_package\n"
#~ "```"

#~ msgid ""
#~ "```\n"
#~ "my_package/\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "my_package/\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"

#~ msgid "## Defining Modules to Control Scope"
#~ msgstr "## Definición de Módulos para Controlar el Ámbito"

#~ msgid ""
#~ "- **Start from the crate root**: When compiling a crate, the compiler "
#~ "first\n"
#~ "  looks in the crate root file (_src/lib.cairo_) for code to compile.\n"
#~ "- **Declaring modules**: In the crate root file, you can declare new "
#~ "modules;\n"
#~ "  say, you declare a “garden” module with `mod garden;`. The compiler "
#~ "will look\n"
#~ "  for the module’s code in these places:\n"
#~ "\n"
#~ "  - Inline, within curly brackets that replace the semicolon following "
#~ "`mod garden;`.\n"
#~ "\n"
#~ "    ```rust\n"
#~ "      // crate root file (lib.cairo)\n"
#~ "        mod garden {\n"
#~ "        // code defining the garden module goes here\n"
#~ "        }\n"
#~ "    ```\n"
#~ "\n"
#~ "- In the file _src/garden.cairo_\n"
#~ "- **Declaring submodules**: In any file other than the crate root, you "
#~ "can\n"
#~ "  declare submodules. For example, you might declare `mod vegetables;` "
#~ "in\n"
#~ "  _src/garden.cairo_. The compiler will look for the submodule’s code "
#~ "within the\n"
#~ "  directory named for the parent module in these places:\n"
#~ "\n"
#~ "  - Inline, directly following `mod vegetables`, within curly brackets "
#~ "instead\n"
#~ "    of the semicolon.\n"
#~ "\n"
#~ "    ```rust\n"
#~ "    // src/garden.cairo file\n"
#~ "    mod vegetables {\n"
#~ "        // code defining the vegetables submodule goes here\n"
#~ "    }\n"
#~ "    ```\n"
#~ "\n"
#~ "  - In the file _src/garden/vegetables.cairo_\n"
#~ "\n"
#~ "- **Paths to code in modules**: Once a module is part of your crate, you "
#~ "can\n"
#~ "  refer to code in that module from anywhere else in that same crate, "
#~ "using the path\n"
#~ "  to the code. For example, an `Asparagus` type in the garden vegetables "
#~ "module would be found at\n"
#~ "  `backyard::garden::vegetables::Asparagus`.\n"
#~ "- **The `use` keyword**: Within a scope, the `use` keyword creates "
#~ "shortcuts to\n"
#~ "  items to reduce repetition of long paths. In any scope that can refer "
#~ "to\n"
#~ "  `backyard::garden::vegetables::Asparagus`, you can create a shortcut "
#~ "with\n"
#~ "  `use backyard::garden::vegetables::Asparagus;` and from then on you "
#~ "only need to\n"
#~ "  write `Asparagus` to make use of that type in the scope."
#~ msgstr ""
#~ "- **Comience desde la raíz del crate**: Al compilar un crate, el "
#~ "compilador primero \n"
#~ "busca código para compilar en el archivo raíz del crate (_src/lib."
#~ "cairo_).\n"
#~ "- **Declaración de módulos**: En el archivo raíz del crate, puede "
#~ "declarar nuevos módulos;\n"
#~ "  digamos que declara un módulo \"garden\" con `mod garden;`. El "
#~ "compilador buscará \n"
#~ "el código del módulo en estos lugares:\n"
#~ "\n"
#~ "  - En línea, dentro de llaves que reemplazan al punto y coma que sigue a "
#~ "`mod garden;`.\n"
#~ "\n"
#~ "    ```rust\n"
#~ "      // crate root file (lib.cairo)\n"
#~ "        mod garden {\n"
#~ "        // code defining the garden module goes here\n"
#~ "        }\n"
#~ "    ```\n"
#~ "\n"
#~ "- En el archivo _src/garden.cairo_\n"
#~ "- **Declarando submódulos**: En cualquier archivo que no sea la raíz del "
#~ "paquete, puede \n"
#~ "  declarar submódulos. Por ejemplo, podría declarar `mod vegetables;` "
#~ "en \n"
#~ "  el archivo _src/garden.cairo_. El compilador buscará el código del "
#~ "submódulo dentro \n"
#~ "  del directorio nombrado por el módulo padre en estos lugares:\n"
#~ "\n"
#~ "  - En línea, directamente después de `mod vegetables`, dentro de llaves "
#~ "en lugar \n"
#~ "  del punto y coma.\n"
#~ "\n"
#~ "    ```rust\n"
#~ "    // src/garden.cairo file\n"
#~ "    mod vegetables {\n"
#~ "        // code defining the vegetables submodule goes here\n"
#~ "    }\n"
#~ "    ```\n"
#~ "\n"
#~ "  - En el archivo _src/garden/vegetables.cairo_\n"
#~ "\n"
#~ "- **Rutas a código en módulos**: Una vez que un módulo forma parte de su "
#~ "paquete, puede \n"
#~ "  hacer referencia al código de ese módulo desde cualquier otro lugar en "
#~ "ese mismo paquete, utilizando la ruta \n"
#~ "  al código. Por ejemplo, un tipo `Asparagus` en el módulo de vegetales "
#~ "del jardín se encontraría en \n"
#~ "  `backyard::garden::vegetables::Asparagus`.\n"
#~ "- **La palabra clave `use`**: Dentro de un alcance, la palabra clave "
#~ "`use` crea atajos a \n"
#~ "  elementos para reducir la repetición de rutas largas. En cualquier "
#~ "alcance que pueda hacer \n"
#~ "  referencia a `backyard::garden::vegetables::Asparagus`, puede crear un "
#~ "atajo con \n"
#~ "  `use backyard::garden::vegetables::Asparagus;` y a partir de entonces "
#~ "solo necesita \n"
#~ "  escribir `Asparagus` para usar ese tipo en el alcance."

#~ msgid ""
#~ "```text\n"
#~ "backyard/\n"
#~ "├── Scarb.toml\n"
#~ "├── cairo_project.toml\n"
#~ "└── src\n"
#~ "    ├── garden\n"
#~ "    │   └── vegetables.cairo\n"
#~ "    ├── garden.cairo\n"
#~ "    └── lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "backyard/\n"
#~ "├── Scarb.toml\n"
#~ "├── cairo_project.toml\n"
#~ "└── src\n"
#~ "    ├── garden\n"
#~ "    │   └── vegetables.cairo\n"
#~ "    ├── garden.cairo\n"
#~ "    └── lib.cairo\n"
#~ "```"

#~ msgid ""
#~ "> Note: You will notice here a `cairo_project.toml` file.\n"
#~ "> This is the configuration file for \"vanilla\" Cairo projects (i.e. not "
#~ "managed by Scarb),\n"
#~ "> which is required to run the `cairo-run .` command to run the code of "
#~ "the crate.\n"
#~ "> It is required until Scarb implements this feature. The content of the "
#~ "file is:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> backyard = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> and indicates that the crate named \"backyard\" is located in the `src` "
#~ "directory."
#~ msgstr ""
#~ "> Nota: Aquí se observa un archivo `cairo_project.toml`.\n"
#~ "> Este es el archivo de configuración para proyectos \"vanilla\" de Cairo "
#~ "(es decir, no \n"
#~ "> gestionados por Scarb), que se requiere para ejecutar el comando `cairo-"
#~ "run .` y \n"
#~ "> ejecutar el código del crate.\n"
#~ "> Es necesario hasta que Scarb implemente esta función. El contenido del "
#~ "archivo es:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> backyard = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> y indica que la caja llamada \"backyard\" se encuentra en el directorio "
#~ "`src`."

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "use garden::vegetables::Asparagus;\n"
#~ "\n"
#~ "mod garden;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let Asparagus = Asparagus {};\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "use garden::vegetables::Asparagus;\n"
#~ "\n"
#~ "mod garden;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let Asparagus = Asparagus {};\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "mod vegetables;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod vegetables;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Asparagus {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Asparagus {}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "\n"
#~ "        fn seat_at_table() {}\n"
#~ "    }\n"
#~ "\n"
#~ "    mod serving {\n"
#~ "        fn take_order() {}\n"
#~ "\n"
#~ "        fn serve_order() {}\n"
#~ "\n"
#~ "        fn take_payment() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "\n"
#~ "        fn seat_at_table() {}\n"
#~ "    }\n"
#~ "\n"
#~ "    mod serving {\n"
#~ "        fn take_order() {}\n"
#~ "\n"
#~ "        fn serve_order() {}\n"
#~ "\n"
#~ "        fn take_payment() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "restaurant\n"
#~ " └── front_of_house\n"
#~ "     ├── hosting\n"
#~ "     │   ├── add_to_waitlist\n"
#~ "     │   └── seat_at_table\n"
#~ "     └── serving\n"
#~ "         ├── take_order\n"
#~ "         ├── serve_order\n"
#~ "         └── take_payment\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "restaurant\n"
#~ " └── front_of_house\n"
#~ "     ├── hosting\n"
#~ "     │   ├── add_to_waitlist\n"
#~ "     │   └── seat_at_table\n"
#~ "     └── serving\n"
#~ "         ├── take_order\n"
#~ "         ├── serve_order\n"
#~ "         └── take_payment\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 6-2: The module tree for the code in "
#~ "Listing\n"
#~ "6-1</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listing 6-2: El árbol de módulos para el código "
#~ "en el Listado\n"
#~ "6-1</span>"

#~ msgid "## Paths for Referring to an Item in the Module Tree"
#~ msgstr ""
#~ "## Caminos para hacer referencia a un elemento en el árbol de módulos"

#~ msgid ""
#~ "- An _absolute path_ is the full path starting from a crate root. The "
#~ "absolute path begins with the crate name.\n"
#~ "- A _relative path_ starts from the current module.\n"
#~ "\n"
#~ "  Both absolute and relative paths are followed by one or more "
#~ "identifiers\n"
#~ "  separated by double colons (`::`)."
#~ msgstr ""
#~ "- Un _camino absoluto_ es la ruta completa que comienza desde la raíz del "
#~ "crate. El camino absoluto comienza con el nombre del crate.\n"
#~ "- Un _camino relativo_ comienza desde el módulo actual.\n"
#~ "\n"
#~ "  Tanto los caminos absolutos como los relativos son seguidos por uno o "
#~ "más identificadores \n"
#~ "  separados por dos puntos dobles (`::`)."

#~ msgid ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "\n"
#~ "        fn seat_at_table() {}\n"
#~ "    }\n"
#~ "\n"
#~ "    mod serving {\n"
#~ "        fn take_order() {}\n"
#~ "\n"
#~ "        fn serve_order() {}\n"
#~ "\n"
#~ "        fn take_payment() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    // Absolute path\n"
#~ "    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ "
#~ "Compiles\n"
#~ "\n"
#~ "    // Relative path\n"
#~ "    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "\n"
#~ "        fn seat_at_table() {}\n"
#~ "    }\n"
#~ "\n"
#~ "    mod serving {\n"
#~ "        fn take_order() {}\n"
#~ "\n"
#~ "        fn serve_order() {}\n"
#~ "\n"
#~ "        fn take_payment() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    // Absolute path\n"
#~ "    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ "
#~ "Compiles\n"
#~ "\n"
#~ "    // Relative path\n"
#~ "    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn deliver_order() {}\n"
#~ "\n"
#~ "mod back_of_house {\n"
#~ "    fn fix_incorrect_order() {\n"
#~ "        cook_order();\n"
#~ "        super::deliver_order();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn cook_order() {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn deliver_order() {}\n"
#~ "\n"
#~ "mod back_of_house {\n"
#~ "    fn fix_incorrect_order() {\n"
#~ "        cook_order();\n"
#~ "        super::deliver_order();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn cook_order() {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist(); // ✅ Shorter path\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist(); // ✅ Shorter path\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "mod customer {\n"
#~ "    fn eat_at_restaurant() {\n"
#~ "        hosting::add_to_waitlist();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "mod customer {\n"
#~ "    fn eat_at_restaurant() {\n"
#~ "        hosting::add_to_waitlist();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "❯ scarb build\n"
#~ "error: Identifier not found.\n"
#~ " --> lib.cairo:11:9\n"
#~ "        hosting::add_to_waitlist();\n"
#~ "        ^*****^\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "❯ scarb build\n"
#~ "error: Identifier not found.\n"
#~ " --> lib.cairo:11:9\n"
#~ "        hosting::add_to_waitlist();\n"
#~ "        ^*****^\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting::add_to_waitlist;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    add_to_waitlist();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting::add_to_waitlist;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    add_to_waitlist();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = ArrayTrait::new();\n"
#~ "    arr.append(1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = ArrayTrait::new();\n"
#~ "    arr.append(1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait as Arr;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
#~ "    arr.append(1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait as Arr;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
#~ "    arr.append(1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use module::{item1, item2, item3};\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use module::{item1, item2, item3};\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// Assuming we have a module called `shapes` with the structures "
#~ "`Square`, `Circle`, and `Triangle`.\n"
#~ "mod shapes {\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Square {\n"
#~ "        side: u32\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Circle {\n"
#~ "        radius: u32\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Triangle {\n"
#~ "        base: u32,\n"
#~ "        height: u32,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// We can import the structures `Square`, `Circle`, and `Triangle` from "
#~ "the `shapes` module like this:\n"
#~ "use shapes::{Square, Circle, Triangle};\n"
#~ "\n"
#~ "// Now we can directly use `Square`, `Circle`, and `Triangle` in our "
#~ "code.\n"
#~ "fn main() {\n"
#~ "    let sq = Square { side: 5 };\n"
#~ "    let cr = Circle { radius: 3 };\n"
#~ "    let tr = Triangle { base: 5, height: 2 };\n"
#~ "// ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// Assuming we have a module called `shapes` with the structures "
#~ "`Square`, `Circle`, and `Triangle`.\n"
#~ "mod shapes {\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Square {\n"
#~ "        side: u32\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Circle {\n"
#~ "        radius: u32\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop)]\n"
#~ "    struct Triangle {\n"
#~ "        base: u32,\n"
#~ "        height: u32,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// We can import the structures `Square`, `Circle`, and `Triangle` from "
#~ "the `shapes` module like this:\n"
#~ "use shapes::{Square, Circle, Triangle};\n"
#~ "\n"
#~ "// Now we can directly use `Square`, `Circle`, and `Triangle` in our "
#~ "code.\n"
#~ "fn main() {\n"
#~ "    let sq = Square { side: 5 };\n"
#~ "    let cr = Circle { radius: 3 };\n"
#~ "    let tr = Triangle { base: 5, height: 2 };\n"
#~ "// ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 6-10: Importing multiple items from the "
#~ "same module</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 6-10 Importación de varios elementos del "
#~ "mismo módulo</span>"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house {\n"
#~ "    mod hosting {\n"
#~ "        fn add_to_waitlist() {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist();\n"
#~ "}\n"
#~ "```"

#~ msgid "## Separating Modules into Different Files"
#~ msgstr "## Separar Módulos en Archivos Diferentes"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house;\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "mod front_of_house;\n"
#~ "\n"
#~ "use restaurant::front_of_house::hosting;\n"
#~ "\n"
#~ "fn eat_at_restaurant() {\n"
#~ "    hosting::add_to_waitlist();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,\n"
#~ "mod hosting {\n"
#~ "    fn add_to_waitlist() {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,\n"
#~ "mod hosting {\n"
#~ "    fn add_to_waitlist() {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "mod hosting;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod hosting;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn add_to_waitlist() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn add_to_waitlist() {}\n"
#~ "```"

#~ msgid "## Generic Functions"
#~ msgstr "## Funciones Genéricas"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "// Specify generic type T between the angulars\n"
#~ "fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
#~ "    if l1.len() > l2.len() {\n"
#~ "        l1\n"
#~ "    } else {\n"
#~ "        l2\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut l1 = ArrayTrait::new();\n"
#~ "    let mut l2 = ArrayTrait::new();\n"
#~ "\n"
#~ "    l1.append(1);\n"
#~ "    l1.append(2);\n"
#~ "\n"
#~ "    l2.append(3);\n"
#~ "    l2.append(4);\n"
#~ "    l2.append(5);\n"
#~ "\n"
#~ "    // There is no need to specify the concrete type of T because\n"
#~ "    // it is inferred by the compiler\n"
#~ "    let l3 = largest_list(l1, l2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "// Specify generic type T between the angulars\n"
#~ "fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
#~ "    if l1.len() > l2.len() {\n"
#~ "        l1\n"
#~ "    } else {\n"
#~ "        l2\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut l1 = ArrayTrait::new();\n"
#~ "    let mut l2 = ArrayTrait::new();\n"
#~ "\n"
#~ "    l1.append(1);\n"
#~ "    l1.append(2);\n"
#~ "\n"
#~ "    l2.append(3);\n"
#~ "    l2.append(4);\n"
#~ "    l2.append(5);\n"
#~ "\n"
#~ "    // There is no need to specify the concrete type of T because\n"
#~ "    // it is inferred by the compiler\n"
#~ "    let l3 = largest_list(l1, l2);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> "
#~ "Array<T> {\n"
#~ "    if l1.len() > l2.len() {\n"
#~ "        l1\n"
#~ "    } else {\n"
#~ "        l2\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> "
#~ "Array<T> {\n"
#~ "    if l1.len() > l2.len() {\n"
#~ "        l1\n"
#~ "    } else {\n"
#~ "        l2\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "// Given a list of T get the smallest one.\n"
#~ "// The PartialOrd trait implements comparison operations for T\n"
#~ "fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -"
#~ "> T {\n"
#~ "    // This represents the smallest element through the iteration\n"
#~ "    // Notice that we use the desnap (*) operator\n"
#~ "    let mut smallest = *list[0];\n"
#~ "\n"
#~ "    // The index we will use to move through the list\n"
#~ "    let mut index = 1;\n"
#~ "\n"
#~ "    // Iterate through the whole list storing the smallest\n"
#~ "    loop {\n"
#~ "        if index >= list.len() {\n"
#~ "            break smallest;\n"
#~ "        }\n"
#~ "        if *list[index] < smallest {\n"
#~ "            smallest = *list[index];\n"
#~ "        }\n"
#~ "        index = index + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut list: Array<u8> = ArrayTrait::new();\n"
#~ "    list.append(5);\n"
#~ "    list.append(3);\n"
#~ "    list.append(10);\n"
#~ "\n"
#~ "    // We need to specify that we are passing a snapshot of `list` as an "
#~ "argument\n"
#~ "    let s = smallest_element(@list);\n"
#~ "    assert(s == 3, 0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "// Given a list of T get the smallest one.\n"
#~ "// The PartialOrd trait implements comparison operations for T\n"
#~ "fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -"
#~ "> T {\n"
#~ "    // This represents the smallest element through the iteration\n"
#~ "    // Notice that we use the desnap (*) operator\n"
#~ "    let mut smallest = *list[0];\n"
#~ "\n"
#~ "    // The index we will use to move through the list\n"
#~ "    let mut index = 1;\n"
#~ "\n"
#~ "    // Iterate through the whole list storing the smallest\n"
#~ "    loop {\n"
#~ "        if index >= list.len() {\n"
#~ "            break smallest;\n"
#~ "        }\n"
#~ "        if *list[index] < smallest {\n"
#~ "            smallest = *list[index];\n"
#~ "        }\n"
#~ "        index = index + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut list: Array<u8> = ArrayTrait::new();\n"
#~ "    list.append(5);\n"
#~ "    list.append(3);\n"
#~ "    list.append(10);\n"
#~ "\n"
#~ "    // We need to specify that we are passing a snapshot of `list` as an "
#~ "argument\n"
#~ "    let s = smallest_element(@list);\n"
#~ "    assert(s == 3, 0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rs\n"
#~ "use array::ArrayTrait;\n"
#~ "fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: "
#~ "Copy<T>, impl TDrop: Drop<T>>(\n"
#~ "    list: @Array<T>\n"
#~ ") -> T {\n"
#~ "    let mut smallest = *list[0];\n"
#~ "    let mut index = 1;\n"
#~ "    loop {\n"
#~ "        if index >= list.len() {\n"
#~ "            break smallest;\n"
#~ "        }\n"
#~ "        if *list[index] < smallest {\n"
#~ "            smallest = *list[index];\n"
#~ "        }\n"
#~ "        index = index + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rs\n"
#~ "use array::ArrayTrait;\n"
#~ "fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: "
#~ "Copy<T>, impl TDrop: Drop<T>>(\n"
#~ "    list: @Array<T>\n"
#~ ") -> T {\n"
#~ "    let mut smallest = *list[0];\n"
#~ "    let mut index = 1;\n"
#~ "    loop {\n"
#~ "        if index >= list.len() {\n"
#~ "            break smallest;\n"
#~ "        }\n"
#~ "        if *list[index] < smallest {\n"
#~ "            smallest = *list[index];\n"
#~ "        }\n"
#~ "        index = index + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3 };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3 };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3, address: 14 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Drop)]\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3, address: 14 };\n"
#~ "}\n"
#~ "```"

#~ msgid "## Enums"
#~ msgstr "## Enums (Enumeraciones)"

#~ msgid ""
#~ "```rust\n"
#~ "enum Result<T, E> {\n"
#~ "    Ok: T,\n"
#~ "    Err: E,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "enum Result<T, E> {\n"
#~ "    Ok: T,\n"
#~ "    Err: E,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "trait WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T {\n"
#~ "        return *self.balance;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 50 };\n"
#~ "    assert(w.balance() == 50, 0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "trait WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T {\n"
#~ "        return *self.balance;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 50 };\n"
#~ "    assert(w.balance() == 50, 0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "/// Generic trait for wallets\n"
#~ "trait WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T {\n"
#~ "        return *self.balance;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "/// Trait for wallets of type u128\n"
#~ "trait WalletReceiveTrait {\n"
#~ "    fn receive(ref self: Wallet<u128>, value: u128);\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletReceiveImpl of WalletReceiveTrait {\n"
#~ "    fn receive(ref self: Wallet<u128>, value: u128) {\n"
#~ "        self.balance += value;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut w = Wallet { balance: 50 };\n"
#~ "    assert(w.balance() == 50, 0);\n"
#~ "\n"
#~ "    w.receive(100);\n"
#~ "    assert(w.balance() == 150, 0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Wallet<T> {\n"
#~ "    balance: T\n"
#~ "}\n"
#~ "\n"
#~ "/// Generic trait for wallets\n"
#~ "trait WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletImpl<T, impl TCopy: Copy<T>> of WalletTrait<T> {\n"
#~ "    fn balance(self: @Wallet<T>) -> T {\n"
#~ "        return *self.balance;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "/// Trait for wallets of type u128\n"
#~ "trait WalletReceiveTrait {\n"
#~ "    fn receive(ref self: Wallet<u128>, value: u128);\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletReceiveImpl of WalletReceiveTrait {\n"
#~ "    fn receive(ref self: Wallet<u128>, value: u128) {\n"
#~ "        self.balance += value;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut w = Wallet { balance: 50 };\n"
#~ "    assert(w.balance() == 50, 0);\n"
#~ "\n"
#~ "    w.receive(100);\n"
#~ "    assert(w.balance() == 150, 0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "\n"
#~ "// This does not compile!\n"
#~ "trait WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
#~ "Wallet<T1, U2>;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
#~ "Wallet<T1, U2> {\n"
#~ "        Wallet { balance: self.balance, address: other.address }\n"
#~ "    }\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "\n"
#~ "// This does not compile!\n"
#~ "trait WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
#~ "Wallet<T1, U2>;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> "
#~ "Wallet<T1, U2> {\n"
#~ "        Wallet { balance: self.balance, address: other.address }\n"
#~ "    }\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
#~ "        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
#~ "    ) -> Wallet<T1, U2>;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> "
#~ "of WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
#~ "        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
#~ "    ) -> Wallet<T1, U2> {\n"
#~ "        Wallet { balance: self.balance, address: other.address }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
#~ "        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
#~ "    ) -> Wallet<T1, U2>;\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> "
#~ "of WalletMixTrait<T1, U1> {\n"
#~ "    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
#~ "        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
#~ "    ) -> Wallet<T1, U2> {\n"
#~ "        Wallet { balance: self.balance, address: other.address }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let w1 = Wallet { balance: true, address: 10 };\n"
#~ "    let w2 = Wallet { balance: 32, address: 100 };\n"
#~ "\n"
#~ "    let w3 = w1.mixup(w2);\n"
#~ "\n"
#~ "    assert(w3.balance == true, 0);\n"
#~ "    assert(w3.address == 100, 0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let w1 = Wallet { balance: true, address: 10 };\n"
#~ "    let w2 = Wallet { balance: 32, address: 100 };\n"
#~ "\n"
#~ "    let w3 = w1.mixup(w2);\n"
#~ "\n"
#~ "    assert(w3.balance == true, 0);\n"
#~ "    assert(w3.address == 100, 0);\n"
#~ "}\n"
#~ "```"

#~ msgid "# Traits in Cairo"
#~ msgstr "# Traits en Cairo"

#~ msgid ""
#~ "```rust\n"
#~ "trait ShapeGeometry {\n"
#~ "    fn boundary(self: Rectangle) -> u64;\n"
#~ "    fn area(self: Rectangle) -> u64;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait ShapeGeometry {\n"
#~ "    fn boundary(self: Rectangle) -> u64;\n"
#~ "    fn area(self: Rectangle) -> u64;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "impl RectangleGeometry of ShapeGeometry {\n"
#~ "\tfn boundary(self: Rectangle) -> u64 {\n"
#~ "        2 * (self.height + self.width)\n"
#~ "    }\n"
#~ "\tfn area(self: Rectangle) -> u64 {\n"
#~ "\t\tself.height * self.width\n"
#~ "\t}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "impl RectangleGeometry of ShapeGeometry {\n"
#~ "\tfn boundary(self: Rectangle) -> u64 {\n"
#~ "        2 * (self.height + self.width)\n"
#~ "    }\n"
#~ "\tfn area(self: Rectangle) -> u64 {\n"
#~ "\t\tself.height * self.width\n"
#~ "\t}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let rect = Rectangle { ... }; // Rectangle instantiation\n"
#~ "\n"
#~ "// First way, as a method on the struct instance\n"
#~ "let area1 = rect.area();\n"
#~ "// Second way, from the implementation\n"
#~ "let area2 = RectangleGeometry::area(rect);\n"
#~ "// `area1` has same value as `area2`\n"
#~ "area1.print();\n"
#~ "area2.print();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let rect = Rectangle { ... }; // Rectangle instantiation\n"
#~ "\n"
#~ "// First way, as a method on the struct instance\n"
#~ "let area1 = rect.area();\n"
#~ "// Second way, from the implementation\n"
#~ "let area2 = RectangleGeometry::area(rect);\n"
#~ "// `area1` has same value as `area2`\n"
#~ "area1.print();\n"
#~ "area2.print();\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Circle {\n"
#~ "    radius: u64\n"
#~ "}\n"
#~ "\n"
#~ "// Here T is an alias type which will be provided during implementation\n"
#~ "trait ShapeGeometry<T> {\n"
#~ "    fn boundary(self: T) -> u64;\n"
#~ "    fn area(self: T) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "// Implementation RectangleGeometry passes in <Rectangle>\n"
#~ "// to implement the trait for that type\n"
#~ "impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
#~ "    fn boundary(self: Rectangle) -> u64 {\n"
#~ "        2 * (self.height + self.width)\n"
#~ "    }\n"
#~ "    fn area(self: Rectangle) -> u64 {\n"
#~ "        self.height * self.width\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// We might have another struct Circle\n"
#~ "// which can use the same trait spec\n"
#~ "impl CircleGeometry of ShapeGeometry<Circle> {\n"
#~ "    fn boundary(self: Circle) -> u64 {\n"
#~ "        (2 * 314 * self.radius) / 100\n"
#~ "    }\n"
#~ "    fn area(self: Circle) -> u64 {\n"
#~ "        (314 * self.radius * self.radius) / 100\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect = Rectangle { height: 5, width: 7 };\n"
#~ "    rect.area().print(); // 35\n"
#~ "    rect.boundary().print(); // 24\n"
#~ "\n"
#~ "    let circ = Circle { radius: 5 };\n"
#~ "    circ.area().print(); // 78\n"
#~ "    circ.boundary().print(); // 31\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Rectangle {\n"
#~ "    height: u64,\n"
#~ "    width: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Circle {\n"
#~ "    radius: u64\n"
#~ "}\n"
#~ "\n"
#~ "// Here T is an alias type which will be provided during implementation\n"
#~ "trait ShapeGeometry<T> {\n"
#~ "    fn boundary(self: T) -> u64;\n"
#~ "    fn area(self: T) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "// Implementation RectangleGeometry passes in <Rectangle>\n"
#~ "// to implement the trait for that type\n"
#~ "impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
#~ "    fn boundary(self: Rectangle) -> u64 {\n"
#~ "        2 * (self.height + self.width)\n"
#~ "    }\n"
#~ "    fn area(self: Rectangle) -> u64 {\n"
#~ "        self.height * self.width\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// We might have another struct Circle\n"
#~ "// which can use the same trait spec\n"
#~ "impl CircleGeometry of ShapeGeometry<Circle> {\n"
#~ "    fn boundary(self: Circle) -> u64 {\n"
#~ "        (2 * 314 * self.radius) / 100\n"
#~ "    }\n"
#~ "    fn area(self: Circle) -> u64 {\n"
#~ "        (314 * self.radius * self.radius) / 100\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect = Rectangle { height: 5, width: 7 };\n"
#~ "    rect.area().print(); // 35\n"
#~ "    rect.boundary().print(); // 24\n"
#~ "\n"
#~ "    let circ = Circle { radius: 5 };\n"
#~ "    circ.area().print(); // 78\n"
#~ "    circ.boundary().print(); // 31\n"
#~ "}\n"
#~ "```"

#~ msgid "If the code was organised into modules like this,"
#~ msgstr "Si el código estuviera organizado en módulos de esta manera,"

#~ msgid ""
#~ "```rust,does_not_compile,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "// struct Circle { ... } and struct Rectangle { ... }\n"
#~ "\n"
#~ "mod geometry {\n"
#~ "    use super::Rectangle;\n"
#~ "    trait ShapeGeometry<T> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "\n"
#~ "    impl RectangleGeometry of ShapeGeometry::<Rectangle> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Could be in a different file\n"
#~ "mod circle {\n"
#~ "    use super::geometry::ShapeGeometry;\n"
#~ "    use super::Circle;\n"
#~ "    impl CircleGeometry of ShapeGeometry<Circle> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect = Rectangle { height: 5, width: 7 };\n"
#~ "    let circ = Circle { radius: 5 };\n"
#~ "    // Fails with this error\n"
#~ "    // Method `area` not found on... Did you import the correct trait and "
#~ "impl?\n"
#~ "    rect.area().print();\n"
#~ "    circ.area().print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile,ignore_format\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "// struct Circle { ... } and struct Rectangle { ... }\n"
#~ "\n"
#~ "mod geometry {\n"
#~ "    use super::Rectangle;\n"
#~ "    trait ShapeGeometry<T> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "\n"
#~ "    impl RectangleGeometry of ShapeGeometry::<Rectangle> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Could be in a different file\n"
#~ "mod circle {\n"
#~ "    use super::geometry::ShapeGeometry;\n"
#~ "    use super::Circle;\n"
#~ "    impl CircleGeometry of ShapeGeometry<Circle> {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let rect = Rectangle { height: 5, width: 7 };\n"
#~ "    let circ = Circle { radius: 5 };\n"
#~ "    // Fails with this error\n"
#~ "    // Method `area` not found on... Did you import the correct trait and "
#~ "impl?\n"
#~ "    rect.area().print();\n"
#~ "    circ.area().print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use geometry::ShapeGeometry;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use geometry::ShapeGeometry;\n"
#~ "```"

#~ msgid "you might also need to use `CircleGeometry`,"
#~ msgstr "para hacerlo funcionar, también tendrías que usar `CircleGeometry`,"

#~ msgid ""
#~ "```rust\n"
#~ "use circle::CircleGeometry\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use circle::CircleGeometry\n"
#~ "```"

#~ msgid "# Testing Cairo Programs"
#~ msgstr "# Testing de Programas en Cairo"

#~ msgid "# How To Write Tests"
#~ msgstr "# Cómo Escribir Test"

#~ msgid ""
#~ "- Set up any needed data or state.\n"
#~ "- Run the code you want to test.\n"
#~ "- Assert the results are what you expect."
#~ msgstr ""
#~ "- Configuran cualquier dato o estado necesario.\n"
#~ "- Ejecutan el código que se desea probar.\n"
#~ "- Verifican que los resultados sean los esperados."

#~ msgid "### The Anatomy of a Test Function"
#~ msgstr "### La anatomía de una Función Test"

#~ msgid ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── Scarb.toml\n"
#~ "└── src\n"
#~ "    └── lib.cairo\n"
#~ "```"

#~ msgid "<!-- TODO: remove when Scarb test work -->"
#~ msgstr "<!-- TODO: remove when Scarb test work -->"

#~ msgid ""
#~ "> Note: You will notice here a `cairo_project.toml` file.\n"
#~ "> This is the configuration file for \"vanilla\" Cairo projects (i.e. not "
#~ "managed by Scarb),\n"
#~ "> which is required to run the `scarb cairo-test` command to run the code "
#~ "of the crate.\n"
#~ "> It is required until Scarb implements this feature. The content of the "
#~ "file is:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> and indicates that the crate named \"adder\" is located in the `src` "
#~ "directory."
#~ msgstr ""
#~ "> Nota: Aquí notarás un archivo `cairo_project.toml`.\n"
#~ "> Este es el archivo de configuración para proyectos Cairo "
#~ "\"vanilla\" (es decir, no administrados por Scarb),\n"
#~ "> que se requiere para ejecutar el comando `scarb cairo-test` para "
#~ "ejecutar el código del crate.\n"
#~ "> Es necesario hasta que Scarb implemente esta característica. El "
#~ "contenido del archivo es:\n"
#~ ">\n"
#~ "> ```toml\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> ```\n"
#~ ">\n"
#~ "> e indica que el crate llamado \"adder\" se encuentra en el directorio "
#~ "`src`."

#~ msgid "<span class=\"filename\">Filename: lib.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: lib.cairo</span>"

#~ msgid ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 8-1: A test module and function</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listing 8-1: Un módulo de test y función</span>"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::it_works ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::it_works ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 8-2: The output from running a test</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 8-2: El resultado de ejecutar una prueba</"
#~ "span>"

#~ msgid ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn exploration() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn exploration() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::exploration ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::exploration ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn another() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 6, 'Make this test fail');\n"
#~ "    }\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    fn another() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 6, 'Make this test fail');\n"
#~ "    }\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::exploration ... ok\n"
#~ "test adder::lib::tests::another ... fail\n"
#~ "failures:\n"
#~ "    adder::lib::tests::another - panicked with "
#~ "[1725643816656041371866211894343434536761780588 ('Make this test "
#~ "fail'), ].\n"
#~ "Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::exploration ... ok\n"
#~ "test adder::lib::tests::another ... fail\n"
#~ "failures:\n"
#~ "    adder::lib::tests::another - panicked with "
#~ "[1725643816656041371866211894343434536761780588 ('Make this test "
#~ "fail'), ].\n"
#~ "Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Rectangle {\n"
#~ "#     width: u64,\n"
#~ "#     height: u64,\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64;\n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl RectangleImpl of RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64 {\n"
#~ "#         *self.width * *self.height\n"
#~ "#     }\n"
#~ "# \n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "#         *self.width > *other.width & *self.height > *other.height\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Rectangle;\n"
#~ "#     use super::RectangleTrait;\n"
#~ "# \n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "        let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "# \n"
#~ "#     #[test]\n"
#~ "#     fn smaller_cannot_hold_larger() {\n"
#~ "#         let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "#         let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "# \n"
#~ "#         assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Rectangle {\n"
#~ "#     width: u64,\n"
#~ "#     height: u64,\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64;\n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl RectangleImpl of RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64 {\n"
#~ "#         *self.width * *self.height\n"
#~ "#     }\n"
#~ "# \n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "#         *self.width > *other.width & *self.height > *other.height\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Rectangle;\n"
#~ "#     use super::RectangleTrait;\n"
#~ "# \n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "        let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "# \n"
#~ "#     #[test]\n"
#~ "#     fn smaller_cannot_hold_larger() {\n"
#~ "#         let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "#         let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "# \n"
#~ "#         assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::larger_can_hold_smaller ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::larger_can_hold_smaller ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Rectangle {\n"
#~ "#     width: u64,\n"
#~ "#     height: u64,\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64;\n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl RectangleImpl of RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64 {\n"
#~ "#         *self.width * *self.height\n"
#~ "#     }\n"
#~ "# \n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "#         *self.width > *other.width & *self.height > *other.height\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Rectangle;\n"
#~ "#     use super::RectangleTrait;\n"
#~ "# \n"
#~ "# \n"
#~ "#     #[test]\n"
#~ "#     fn larger_can_hold_smaller() {\n"
#~ "#         let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "#         let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "# \n"
#~ "#         assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "#     }\n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "        let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use debug::PrintTrait;\n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Rectangle {\n"
#~ "#     width: u64,\n"
#~ "#     height: u64,\n"
#~ "# }\n"
#~ "# \n"
#~ "# trait RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64;\n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl RectangleImpl of RectangleTrait {\n"
#~ "#     fn area(self: @Rectangle) -> u64 {\n"
#~ "#         *self.width * *self.height\n"
#~ "#     }\n"
#~ "# \n"
#~ "#     fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "#         *self.width > *other.width & *self.height > *other.height\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Rectangle;\n"
#~ "#     use super::RectangleTrait;\n"
#~ "# \n"
#~ "# \n"
#~ "#     #[test]\n"
#~ "#     fn larger_can_hold_smaller() {\n"
#~ "#         let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "#         let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "# \n"
#~ "#         assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "#     }\n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle { height: 7, width: 8,  };\n"
#~ "        let smaller = Rectangle { height: 1, width: 5,  };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "    running 2 tests\n"
#~ "    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
#~ "    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
#~ "    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "    running 2 tests\n"
#~ "    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
#~ "    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
#~ "    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
#~ "test adder::lib::tests::larger_can_hold_smaller ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::larger_can_hold_smaller - panicked with "
#~ "[167190012635530104759003347567405866263038433127524 ('rectangle cannot "
#~ "hold'), ].\n"
#~ "\n"
#~ "Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
#~ "test adder::lib::tests::larger_can_hold_smaller ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::larger_can_hold_smaller - panicked with "
#~ "[167190012635530104759003347567405866263038433127524 ('rectangle cannot "
#~ "hold'), ].\n"
#~ "\n"
#~ "Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Guess {\n"
#~ "    value: u64, \n"
#~ "}\n"
#~ "\n"
#~ "trait GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess;\n"
#~ "}\n"
#~ "\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 | value > 100 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "        Guess { value }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Guess;\n"
#~ "    use super::GuessTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct Guess {\n"
#~ "    value: u64, \n"
#~ "}\n"
#~ "\n"
#~ "trait GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess;\n"
#~ "}\n"
#~ "\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 | value > 100 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "        Guess { value }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Guess;\n"
#~ "    use super::GuessTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Guess {\n"
#~ "#     value: u64, \n"
#~ "# }\n"
#~ "# \n"
#~ "# trait GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess;\n"
#~ "# }\n"
#~ "# \n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Guess {\n"
#~ "#     value: u64, \n"
#~ "# }\n"
#~ "# \n"
#~ "# trait GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess;\n"
#~ "# }\n"
#~ "# \n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::greater_than_100 - expected panic but finished "
#~ "successfully.\n"
#~ "Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::greater_than_100 - expected panic but finished "
#~ "successfully.\n"
#~ "Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Guess {\n"
#~ "#     value: u64, \n"
#~ "# }\n"
#~ "# \n"
#~ "# trait GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl GuessImpl of GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess {\n"
#~ "#         if value < 1 {\n"
#~ "#             let mut data = ArrayTrait::new();\n"
#~ "#             data.append('Guess must be <= 100');\n"
#~ "#             panic(data);\n"
#~ "#         } else if value > 100 {\n"
#~ "#             let mut data = ArrayTrait::new();\n"
#~ "#             data.append('Guess must be >= 1');\n"
#~ "#             panic(data);\n"
#~ "#         }\n"
#~ "# \n"
#~ "#         Guess { value,  }\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Guess;\n"
#~ "#     use super::GuessTrait;\n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use array::ArrayTrait;\n"
#~ "# \n"
#~ "# #[derive(Copy, Drop)]\n"
#~ "# struct Guess {\n"
#~ "#     value: u64, \n"
#~ "# }\n"
#~ "# \n"
#~ "# trait GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess;\n"
#~ "# }\n"
#~ "# \n"
#~ "# impl GuessImpl of GuessTrait {\n"
#~ "#     fn new(value: u64) -> Guess {\n"
#~ "#         if value < 1 {\n"
#~ "#             let mut data = ArrayTrait::new();\n"
#~ "#             data.append('Guess must be <= 100');\n"
#~ "#             panic(data);\n"
#~ "#         } else if value > 100 {\n"
#~ "#             let mut data = ArrayTrait::new();\n"
#~ "#             data.append('Guess must be >= 1');\n"
#~ "#             panic(data);\n"
#~ "#         }\n"
#~ "# \n"
#~ "#         Guess { value,  }\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::Guess;\n"
#~ "#     use super::GuessTrait;\n"
#~ "# \n"
#~ "    #[test]\n"
#~ "    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1');\n"
#~ "            panic(data);\n"
#~ "        } else if value > 100 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Guess;\n"
#~ "    use super::GuessTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1');\n"
#~ "            panic(data);\n"
#~ "        } else if value > 100 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Guess;\n"
#~ "    use super::GuessTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
#~ "    fn greater_than_100() {\n"
#~ "        GuessTrait::new(200);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::greater_than_100 - panicked with "
#~ "[6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
#~ "\n"
#~ "Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::greater_than_100 ... fail\n"
#~ "failures:\n"
#~ "   adder::lib::tests::greater_than_100 - panicked with "
#~ "[6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
#~ "\n"
#~ "Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn add_two_and_two() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn add_three_and_two() {\n"
#~ "        let result = 3 + 2;\n"
#~ "        assert(result == 5, 'result is not 5');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn add_two_and_two() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn add_three_and_two() {\n"
#~ "        let result = 3 + 2;\n"
#~ "        assert(result == 5, 'result is not 5');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test -f add_two_and_two\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::add_two_and_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test -f add_two_and_two\n"
#~ "running 1 tests\n"
#~ "test adder::lib::tests::add_two_and_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[ignore]\n"
#~ "    fn expensive_test() {// code that takes an hour to run\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[ignore]\n"
#~ "    fn expensive_test() {// code that takes an hour to run\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::expensive_test ... ignored\n"
#~ "test adder::lib::tests::it_works ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ scarb cairo-test\n"
#~ "running 2 tests\n"
#~ "test adder::lib::tests::expensive_test ... ignored\n"
#~ "test adder::lib::tests::it_works ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid "# Testing Organization"
#~ msgstr "# Organización de Test"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    #[test]\n"
#~ "    fn it_works() {\n"
#~ "        let result = 2 + 2;\n"
#~ "        assert(result == 4, 'result is not 4');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── src\n"
#~ "    ├── lib.cairo\n"
#~ "│   └── main.cairo\n"
#~ "└── tests\n"
#~ "    ├── lib.cairo\n"
#~ "    └── integration_test.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "adder\n"
#~ "├── cairo_project.toml\n"
#~ "├── src\n"
#~ "    ├── lib.cairo\n"
#~ "│   └── main.cairo\n"
#~ "└── tests\n"
#~ "    ├── lib.cairo\n"
#~ "    └── integration_test.cairo\n"
#~ "```"

#~ msgid ""
#~ "> To successfully run your tests with `cairo-test` you will need to "
#~ "update your `cairo_project.toml` file to add the declaration of your "
#~ "`tests` crate.\n"
#~ ">\n"
#~ "> ```rust\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> tests = \"tests\"\n"
#~ "> ```"
#~ msgstr ""
#~ "> Para ejecutar correctamente tus pruebas con `cairo-test`, deberás "
#~ "actualizar tu archivo `cairo_project.toml` para agregar la declaración de "
#~ "tu crate `tests`.\n"
#~ ">\n"
#~ "> ```rust\n"
#~ "> [crate_roots]\n"
#~ "> adder = \"src\"\n"
#~ "> tests = \"tests\"\n"
#~ "> ```"

#~ msgid ""
#~ "Each test file is compiled as its own separate crate, that's why whenever "
#~ "you add a new test file you must add it to your _tests/lib.cairo_."
#~ msgstr ""
#~ "Cada archivo de prueba se compila como una entidad separada, por eso cada "
#~ "vez que agregas un nuevo archivo de prueba debes agregarlo a tu archivo "
#~ "_tests/lib.cairo_."

#~ msgid "<span class=\"filename\">Filename: tests/lib.cairo</span>"
#~ msgstr "<span class=\"filename\">Filename: tests/lib.cairo</span>"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(tests)]\n"
#~ "mod integration_tests;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(tests)]\n"
#~ "mod integration_tests;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn internal() {\n"
#~ "    assert(main::internal_adder(2, 2) == 4, 'internal_adder failed');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn internal() {\n"
#~ "    assert(main::internal_adder(2, 2) == 4, 'internal_adder failed');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 8-11: Testing functions from other "
#~ "modules</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 8-11: Probando funciones de otros "
#~ "módulos</span>"

#~ msgid ""
#~ "```shell\n"
#~ "$ cairo-test tests/\n"
#~ "running 1 tests\n"
#~ "test tests::tests_integration::it_adds_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cairo-test tests/\n"
#~ "running 1 tests\n"
#~ "test tests::tests_integration::it_adds_two ... ok\n"
#~ "test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
#~ "```"

#~ msgid "# Unrecoverable Errors with panic"
#~ msgstr "# Errores Irrecuperables con pánico"

#~ msgid ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append(2);\n"
#~ "    if true == true {\n"
#~ "        panic(data);\n"
#~ "    }\n"
#~ "    'This line isn\\'t reached'.print();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use array::ArrayTrait;\n"
#~ "use debug::PrintTrait;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append(2);\n"
#~ "    if true == true {\n"
#~ "        panic(data);\n"
#~ "    }\n"
#~ "    'This line isn\\'t reached'.print();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "$ cairo-run test.cairo\n"
#~ "Run panicked with [2 (''), ].\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "$ cairo-run test.cairo\n"
#~ "Run panicked with [2 (''), ].\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    panic_with_felt252(2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    panic_with_felt252(2);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn function_never_panic() -> felt252 nopanic {\n"
#~ "    42\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn function_never_panic() -> felt252 nopanic {\n"
#~ "    42\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "fn function_never_panic() nopanic {\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// does_not_compile\n"
#~ "fn function_never_panic() nopanic {\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "error: Function is declared as nopanic but calls a function that may "
#~ "panic.\n"
#~ " --> test.cairo:2:12\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "           ^****^\n"
#~ "Function is declared as nopanic but calls a function that may panic.\n"
#~ " --> test.cairo:2:5\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "    ^********************^\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "error: Function is declared as nopanic but calls a function that may "
#~ "panic.\n"
#~ " --> test.cairo:2:12\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "           ^****^\n"
#~ "Function is declared as nopanic but calls a function that may panic.\n"
#~ " --> test.cairo:2:5\n"
#~ "    assert(1 == 1, 'what');\n"
#~ "    ^********************^\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "#[panic_with('value is 0', wrap_not_zero)]\n"
#~ "fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
#~ "    if value == 0 {\n"
#~ "        Option::None(())\n"
#~ "    } else {\n"
#~ "        Option::Some(value)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    wrap_if_not_zero(0); // this returns None\n"
#~ "    wrap_not_zero(0); // this panic with 'value is 0'\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "#[panic_with('value is 0', wrap_not_zero)]\n"
#~ "fn wrap_if_not_zero(value: u128) -> Option<u128> {\n"
#~ "    if value == 0 {\n"
#~ "        Option::None(())\n"
#~ "    } else {\n"
#~ "        Option::Some(value)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    wrap_if_not_zero(0); // this returns None\n"
#~ "    wrap_not_zero(0); // this panic with 'value is 0'\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let my_number: u8 = 0;\n"
#~ "\n"
#~ "    assert(my_number != 0, 'number is zero');\n"
#~ "\n"
#~ "    100 / my_number;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let my_number: u8 = 0;\n"
#~ "\n"
#~ "    assert(my_number != 0, 'number is zero');\n"
#~ "\n"
#~ "    100 / my_number;\n"
#~ "}\n"
#~ "```"

#~ msgid "<br />"
#~ msgstr "<br />"

#~ msgid ""
#~ "```rust\n"
#~ "trait ResultTrait<T, E> {\n"
#~ "    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> "
#~ "T;\n"
#~ "\n"
#~ "    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
#~ "\n"
#~ "    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -"
#~ "> E;\n"
#~ "\n"
#~ "    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
#~ "\n"
#~ "    fn is_ok(self: @Result<T, E>) -> bool;\n"
#~ "\n"
#~ "    fn is_err(self: @Result<T, E>) -> bool;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait ResultTrait<T, E> {\n"
#~ "    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> "
#~ "T;\n"
#~ "\n"
#~ "    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
#~ "\n"
#~ "    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -"
#~ "> E;\n"
#~ "\n"
#~ "    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
#~ "\n"
#~ "    fn is_ok(self: @Result<T, E>) -> bool;\n"
#~ "\n"
#~ "    fn is_err(self: @Result<T, E>) -> bool;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
#~ "    match u128_overflowing_add(a, b) {\n"
#~ "        Result::Ok(r) => Option::Some(r),\n"
#~ "        Result::Err(r) => Option::None(()),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
#~ "    match u128_overflowing_add(a, b) {\n"
#~ "        Result::Ok(r) => Option::Some(r),\n"
#~ "        Result::Err(r) => Option::None(()),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use core::traits::Into;\n"
#~ "use traits::TryInto;\n"
#~ "use option::OptionTrait;\n"
#~ "use result::ResultTrait;\n"
#~ "use result::ResultTraitImpl;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use core::traits::Into;\n"
#~ "use traits::TryInto;\n"
#~ "use option::OptionTrait;\n"
#~ "use result::ResultTrait;\n"
#~ "use result::ResultTraitImpl;\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "    match s.try_into() {\n"
#~ "        Option::Some(value) => Result::Ok(value),\n"
#~ "        Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "    match s.try_into() {\n"
#~ "        Option::Some(value) => Result::Ok(value),\n"
#~ "        Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use traits::TryInto;\n"
#~ "# \n"
#~ "# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "#     match s.try_into() {\n"
#~ "#         Option::Some(value) => Result::Ok(value),\n"
#~ "#         Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::parse_u8;\n"
#~ "    use result::ResultTrait;\n"
#~ "    #[test]\n"
#~ "    fn test_felt252_to_u8() {\n"
#~ "        let number: felt252 = 5_felt252;\n"
#~ "        // should not panic\n"
#~ "        let res = parse_u8(number).unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic]\n"
#~ "    fn test_felt252_to_u8_panic() {\n"
#~ "        let number: felt252 = 256_felt252;\n"
#~ "        // should panic\n"
#~ "        let res = parse_u8(number).unwrap();\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use traits::TryInto;\n"
#~ "# \n"
#~ "# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "#     match s.try_into() {\n"
#~ "#         Option::Some(value) => Result::Ok(value),\n"
#~ "#         Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::parse_u8;\n"
#~ "    use result::ResultTrait;\n"
#~ "    #[test]\n"
#~ "    fn test_felt252_to_u8() {\n"
#~ "        let number: felt252 = 5_felt252;\n"
#~ "        // should not panic\n"
#~ "        let res = parse_u8(number).unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[should_panic]\n"
#~ "    fn test_felt252_to_u8_panic() {\n"
#~ "        let number: felt252 = 256_felt252;\n"
#~ "        // should panic\n"
#~ "        let res = parse_u8(number).unwrap();\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
#~ "    let input_to_u8: u8 = parse_u8(input)?;\n"
#~ "    // DO SOMETHING\n"
#~ "    let res = input_to_u8 - 1;\n"
#~ "    Result::Ok(res)\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
#~ "    let input_to_u8: u8 = parse_u8(input)?;\n"
#~ "    // DO SOMETHING\n"
#~ "    let res = input_to_u8 - 1;\n"
#~ "    Result::Ok(res)\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use traits::TryInto;\n"
#~ "# \n"
#~ "# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "#     match s.try_into() {\n"
#~ "#         Option::Some(value) => Result::Ok(value),\n"
#~ "#         Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
#~ "#     let input_to_u8: u8 = parse_u8(input)?;\n"
#~ "#     // DO SOMETHING\n"
#~ "#     let res = input_to_u8 - 1;\n"
#~ "#     Result::Ok(res)\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::do_something_with_parse_u8;\n"
#~ "#     use debug::PrintTrait;\n"
#~ "    #[test]\n"
#~ "    fn test_function_2() {\n"
#~ "        let number: felt252 = 258_felt252;\n"
#~ "        match do_something_with_parse_u8(number) {\n"
#~ "            Result::Ok(value) => value.print(),\n"
#~ "            Result::Err(e) => e.print()\n"
#~ "        }\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use traits::TryInto;\n"
#~ "# \n"
#~ "# fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
#~ "#     match s.try_into() {\n"
#~ "#         Option::Some(value) => Result::Ok(value),\n"
#~ "#         Option::None(_) => Result::Err('Invalid integer'),\n"
#~ "#     }\n"
#~ "# }\n"
#~ "# \n"
#~ "# fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
#~ "#     let input_to_u8: u8 = parse_u8(input)?;\n"
#~ "#     // DO SOMETHING\n"
#~ "#     let res = input_to_u8 - 1;\n"
#~ "#     Result::Ok(res)\n"
#~ "# }\n"
#~ "# \n"
#~ "# #[cfg(test)]\n"
#~ "# mod tests {\n"
#~ "#     use super::do_something_with_parse_u8;\n"
#~ "#     use debug::PrintTrait;\n"
#~ "    #[test]\n"
#~ "    fn test_function_2() {\n"
#~ "        let number: felt252 = 258_felt252;\n"
#~ "        match do_something_with_parse_u8(number) {\n"
#~ "            Result::Ok(value) => value.print(),\n"
#~ "            Result::Err(e) => e.print()\n"
#~ "        }\n"
#~ "    }\n"
#~ "# }\n"
#~ "# \n"
#~ "```"

#~ msgid "<br/>"
#~ msgstr "<br/>"

#~ msgid "### Summary"
#~ msgstr "### Resumen"

#~ msgid "# Advanced Features"
#~ msgstr "# Funciones Avanzadas"

#~ msgid "# Operator Overloading"
#~ msgstr "# Sobrecarga de Operadores"

#~ msgid ""
#~ "```rust\n"
#~ "struct Potion {\n"
#~ "    health: felt252,\n"
#~ "    mana: felt252\n"
#~ "}\n"
#~ "\n"
#~ "impl PotionAdd of Add<Potion> {\n"
#~ "    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
#~ "        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs."
#~ "mana,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
#~ "    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
#~ "    let super_potion: Potion = health_potion + mana_potion;\n"
#~ "    // Both potions were combined with the `+` operator.\n"
#~ "    assert(super_potion.health == 100, '');\n"
#~ "    assert(super_potion.mana == 100, '');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Potion {\n"
#~ "    health: felt252,\n"
#~ "    mana: felt252\n"
#~ "}\n"
#~ "\n"
#~ "impl PotionAdd of Add<Potion> {\n"
#~ "    fn add(lhs: Potion, rhs: Potion) -> Potion {\n"
#~ "        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs."
#~ "mana,  }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let health_potion: Potion = Potion { health: 100, mana: 0 };\n"
#~ "    let mana_potion: Potion = Potion { health: 0, mana: 100 };\n"
#~ "    let super_potion: Potion = health_potion + mana_potion;\n"
#~ "    // Both potions were combined with the `+` operator.\n"
#~ "    assert(super_potion.health == 100, '');\n"
#~ "    assert(super_potion.mana == 100, '');\n"
#~ "}\n"
#~ "```"

#~ msgid "# Introduction to smart-contracts"
#~ msgstr "# Introducción a los smart-contracts"

#~ msgid ""
#~ "<br/>\n"
#~ "<br/>\n"
#~ "As Ethereum continues to mature, we can expect the use cases and "
#~ "applications of smart contracts to expand further, bringing about "
#~ "exciting new opportunities and reshaping traditional systems for the "
#~ "better."
#~ msgstr ""
#~ "<br/>\n"
#~ "<br/>\n"
#~ "A medida que Ethereum siga madurando, podemos esperar que los casos de "
#~ "uso y las aplicaciones de los contratos inteligentes se amplíen aún más, "
#~ "dando lugar a nuevas e interesantes oportunidades y remodelando los "
#~ "sistemas tradicionales para mejor."

#~ msgid ""
#~ "Ethereum, being the most widely used and resilient smart-contract "
#~ "platform, became a victim of its own success. With the rapid adoption of "
#~ "some previously mentioned use cases, mainly DeFi, the cost of performing "
#~ "transactions became extremely high, rendering the network almost "
#~ "unusable. Engineers and researchers in the ecosystem began working on "
#~ "solutions to address this scalability issue. A famous theorem in the "
#~ "blockchain space states that it is impossible to achieve a high level of "
#~ "scalability, decentralization, and security simultaneously; trade-offs "
#~ "must be made. Ethereum is at the intersection of decentralization and "
#~ "security. Eventually, it was decided that Ethereum's purpose would be to "
#~ "serve as a secure settlement layer, while complex computations would be "
#~ "offloaded to other networks built on top of Ethereum. These are called "
#~ "Layer 2s (L2s). The two primary types of L2s are optimistic rollups and "
#~ "validity rollups. Both approaches involve compressing and batching "
#~ "numerous transactions together, computing the new state, and settling the "
#~ "result on Ethereum (L1). The difference lies in the way the result is "
#~ "settled on L1. For optimistic rollups, the new state is considered valid "
#~ "by default, but there is a 7-day window for nodes to identify malicious "
#~ "transactions. In contrast, validity rollups, such as Starknet, use "
#~ "cryptography to prove that the new state has been correctly computed. "
#~ "This is the purpose of STARKs, this cryptographic technology could permit "
#~ "validity rollups to scale significantly more than optimistic rollups. You "
#~ "can learn more about STARKs from Starkware's Medium [article](https://"
#~ "medium.com/starkware/starks-starkex-and-starknet-9a426680745a), which "
#~ "serves as a good primer."
#~ msgstr ""
#~ "Ethereum, siendo la plataforma de smart contracts más utilizada y "
#~ "resistente, se convirtió en víctima de su propio éxito. Con la rápida "
#~ "adopción de algunos de los casos de uso mencionados anteriormente, "
#~ "principalmente DeFi, el coste de realizar transacciones se volvió "
#~ "extremadamente elevado, haciendo que la red quedara prácticamente "
#~ "inutilizable. Los ingenieros e investigadores del ecosistema empezaron a "
#~ "trabajar en soluciones para resolver este problema de escalabilidad. Un "
#~ "famoso teorema en el ámbito de las cadenas de bloques afirma que es "
#~ "imposible lograr un alto nivel de escalabilidad, descentralización y "
#~ "seguridad simultáneamente; hay que hacer concesiones. Ethereum se "
#~ "encuentra en la intersección entre descentralización y seguridad. "
#~ "Finalmente, se decidió que el propósito de Ethereum sería servir como una "
#~ "capa de liquidación segura, mientras que los cálculos complejos se "
#~ "descargarían a otras redes construidas sobre Ethereum. Estas redes se "
#~ "denominan Capa 2 (L2). Los dos tipos principales de L2 son los rollups "
#~ "optimistas y los rollups de validez. Ambos enfoques implican comprimir y "
#~ "agrupar numerosas transacciones, calcular el nuevo estado y liquidar el "
#~ "resultado en Ethereum (L1). La diferencia radica en la forma en que el "
#~ "resultado se liquida en L1. En los rollups optimistas, el nuevo estado se "
#~ "considera válido por defecto, pero existe un plazo de 7 días para que los "
#~ "nodos identifiquen transacciones maliciosas. En cambio, los rollups de "
#~ "validez, como Starknet, utilizan la criptografía para demostrar que el "
#~ "nuevo estado se ha calculado correctamente. Este es el propósito de "
#~ "STARKs, esta tecnología criptográfica podría permitir a los rollups de "
#~ "validez escalar significativamente más que los rollups optimistas. Puedes "
#~ "aprender más sobre STARKs en el [artículo de Starkware en Medium](https://"
#~ "medium.com/starkware/starks-starkex-and-starknet-9a426680745a), que sirve "
#~ "como un buen manual."

#~ msgid "# Writing Starknet Contracts"
#~ msgstr "# Escribiendo Contratos en Starknet"

#~ msgid ""
#~ "This chapter will guide you on how to create smart contracts in Cairo, "
#~ "and will clarify the distinction between Cairo programs and Starknet "
#~ "contracts."
#~ msgstr ""
#~ "Este capítulo te guiará sobre cómo crear contratos inteligentes en Cairo, "
#~ "y aclarará la distinción entre los programas de Cairo y los contratos de "
#~ "Starknet."

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod example {\n"
#~ "    use starknet::get_caller_address;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    struct Storage {\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>, \n"
#~ "    }\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn get_name(_address: ContractAddress) -> felt252 {\n"
#~ "        let name = names::read(_address);\n"
#~ "        return name;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod example {\n"
#~ "    use starknet::get_caller_address;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    struct Storage {\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>, \n"
#~ "    }\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn get_name(_address: ContractAddress) -> felt252 {\n"
#~ "        let name = names::read(_address);\n"
#~ "        return name;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 99-1: A simple naming service contract</"
#~ "span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 9-1: Un contrato simple de servicio de "
#~ "nombres</span>"

#~ msgid ""
#~ "Attributes are special annotations that modify the behavior of certain "
#~ "functions or methods. They are placed preceding a function and are "
#~ "denoted by the `#[]` symbol."
#~ msgstr ""
#~ "Los atributos son anotaciones especiales que modifican el comportamiento "
#~ "de determinadas funciones o métodos. Se colocan antes de una función y se "
#~ "indican con el símbolo `#[]`."

#~ msgid "<!-- TODO: Appendix on attributes -->"
#~ msgstr "<!-- TODO: Appendix on attributes -->"

#~ msgid "Here is a list of common attributes used in Starknet contracts:"
#~ msgstr ""
#~ "He aquí una lista de atributos comunes utilizados en los contratos "
#~ "Starknet:"

#~ msgid ""
#~ "1. `#[contract]`: This attribute is used to annotate a module to be "
#~ "compiled as a Starknet contract.\n"
#~ "   The compiler recognizes this attribute and prepares the module with "
#~ "necessary contract elements,\n"
#~ "   such as the logic to handle external contract calls or how to access "
#~ "storage variables.\n"
#~ "\n"
#~ "2. `#[constructor]`: This attribute marks a function as a constructor. "
#~ "The constructor function is called only once upon deploying a contract, "
#~ "setting the initial state of the contract.\n"
#~ "\n"
#~ "3. `#[external]`: This attribute marks a function as an external "
#~ "function. External functions can be called by other contracts or "
#~ "externally and can modify the contract's state.\n"
#~ "\n"
#~ "4. `#[view]`: This attribute marks a function as a view function. View "
#~ "functions are read-only functions that allow you to access data from the "
#~ "contract, but prevent you from modifying the state of the blockchain.\n"
#~ "\n"
#~ "5. `#[event]`: This is used to define events that can be emitted by the "
#~ "contract.\n"
#~ "\n"
#~ "6. `#[l1_handler]`: This attribute is used to mark functions which can "
#~ "receive messages from L1s."
#~ msgstr ""
#~ "1. `#[contract]`: Este atributo se utiliza para anotar un módulo para ser "
#~ "compilado como un contrato Starknet.\n"
#~ "   El compilador reconoce este atributo y prepara el módulo con los "
#~ "elementos de contrato necesarios,\n"
#~ "   como la lógica para manejar las llamadas externas del contrato o cómo "
#~ "acceder a las variables de almacenamiento.\n"
#~ "\n"
#~ "2. `#[constructor]`: Este atributo marca una función como constructor. La "
#~ "función constructora es llamada sólo una vez al desplegar un contrato, "
#~ "estableciendo el estado inicial del contrato.\n"
#~ "\n"
#~ "3. `#[external]`: Este atributo marca una función como función externa. "
#~ "Las funciones externas pueden ser llamadas por otros contratos o "
#~ "externamente y pueden modificar el estado del contrato.\n"
#~ "\n"
#~ "4. `#[view]`: Este atributo marca una función como función de vista. Las "
#~ "funciones de vista son funciones de sólo lectura que permiten acceder a "
#~ "los datos del contrato, pero impiden modificar el estado de la "
#~ "blockchain.\n"
#~ "\n"
#~ "5. `#[event]`: Se utiliza para definir eventos que pueden ser emitidos "
#~ "por el contrato.\n"
#~ "\n"
#~ "6. `#[l1_handler]`: Este atributo se utiliza para marcar funciones que "
#~ "pueden recibir mensajes de los L1."

#~ msgid ""
#~ "```rust\n"
#~ "# #[contract]\n"
#~ "# mod contract {\n"
#~ "    struct Storage {\n"
#~ "        id: u8,\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>,\n"
#~ "    }\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# #[contract]\n"
#~ "# mod contract {\n"
#~ "    struct Storage {\n"
#~ "        id: u8,\n"
#~ "        names: LegacyMap::<ContractAddress, felt252>,\n"
#~ "    }\n"
#~ "# }\n"
#~ "```"

#~ msgid "<span class=\"caption\">Listing 99-2: A Storage Struct</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 9-2: Una Estructura de Almacenamiento</"
#~ "span>"

#~ msgid ""
#~ "The storage struct is a [struct](./ch04-00-using-structs-to-structure-"
#~ "related-data.md) like any other,\n"
#~ "except that it allows you to define mappings using the `LegacyMap` type."
#~ msgstr ""
#~ "La estructura de almacenamiento es una [struct](./ch04-00-using-structs-"
#~ "to-structure-related-data.md) como cualquier otra,\n"
#~ "excepto que permite definir mapeos utilizando el tipo `LegacyMap`."

#~ msgid ""
#~ "Mappings are a key-value data structure that you can use to store data "
#~ "within a smart contract. They are essentially hash tables that allow you "
#~ "to associate a unique key with a corresponding value. Mappings are also "
#~ "useful to store sets of data, as it's impossible to store arrays in "
#~ "storage."
#~ msgstr ""
#~ "Los mapeos son una estructura de datos clave-valor que puedes utilizar "
#~ "para almacenar datos dentro de un contrato inteligente. Son esencialmente "
#~ "tablas hash que te permiten asociar una clave única con un valor "
#~ "correspondiente. Los mapeos también son útiles para almacenar conjuntos "
#~ "de datos, ya que es imposible almacenar matrices en el almacenamiento."

#~ msgid ""
#~ "A mapping is a variable of type LegacyMap, in which the key and value "
#~ "types are specified within angular brackets <>.\n"
#~ "It is important to note that the `LegacyMap` type can only be used inside "
#~ "the `Storage` struct, and can't be used to define mappings in user-"
#~ "defined structs.\n"
#~ "The syntax for declaring a mapping is as follows in Listing 99-2."
#~ msgstr ""
#~ "Un mapeo es una variable de tipo LegacyMap, en la que los tipos de clave "
#~ "y valor se especifican entre corchetes angulares <>.\n"
#~ "Es importante tener en cuenta que el tipo `LegacyMap` sólo se puede "
#~ "utilizar dentro de la estructura `Storage`, y no se puede utilizar para "
#~ "definir mapeos en estructuras definidas por el usuario.\n"
#~ "La sintaxis para declarar un mapeo es la siguiente en el Listado 9-2."

#~ msgid ""
#~ "```rust\n"
#~ "    struct Storage {\n"
#~ "        allowances: LegacyMap::<(ContractAddress, ContractAddress), "
#~ "u256>\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    struct Storage {\n"
#~ "        allowances: LegacyMap::<(ContractAddress, ContractAddress), "
#~ "u256>\n"
#~ "    }\n"
#~ "```"

#~ msgid "### Reading from Storage"
#~ msgstr "### Lectura desde Storage"

#~ msgid ""
#~ "```rust\n"
#~ "        let name = names::read(_address);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        let name = names::read(_address);\n"
#~ "```"

#~ msgid ""
#~ "> Note: When the storage variable does not store a mapping, its value is "
#~ "accessed without passing any parameters to the read method"
#~ msgstr ""
#~ "> Nota: Cuando la variable de almacenamiento no almacena una asignación, "
#~ "se accede a su valor sin pasar ningún parámetro al método de lectura"

#~ msgid "### Writing to Storage"
#~ msgstr "### Escritura en Storage"

#~ msgid ""
#~ "To write a value to the storage variable `names`, we call the `write` "
#~ "function on the `names` storage variable, passing in the key and values "
#~ "as arguments."
#~ msgstr ""
#~ "Para escribir un valor en la variable de almacenamiento `names`, llamamos "
#~ "a la función `write` en la variable de almacenamiento `names`, pasando la "
#~ "clave y los valores como argumentos."

#~ msgid ""
#~ "```rust\n"
#~ "        names::write(caller, _name);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        names::write(caller, _name);\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 99-4: Writing to the `names` variable</"
#~ "span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 9-4: Escribir en la variable `names`</"
#~ "span>"

#~ msgid ""
#~ "```rust\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(_name: felt252, _address: ContractAddress) {\n"
#~ "        names::write(_address, _name);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "1. Your contract can't have more than one constructor.\n"
#~ "2. Your constructor function must be named `constructor`.\n"
#~ "3. Lastly, it must be annotated with the `#[constructor]` attribute."
#~ msgstr ""
#~ "1. Tu contrato no puede tener más de un constructor.\n"
#~ "2. Tu función constructora debe llamarse `constructor`.\n"
#~ "3. Por último, debe estar anotada con el atributo `#[constructor]`."

#~ msgid ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[view]\n"
#~ "    fn get_name(_address: ContractAddress) -> felt252 {\n"
#~ "        let name = names::read(_address);\n"
#~ "        return name;\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn store_name(_name: felt252) {\n"
#~ "        let caller = get_caller_address();\n"
#~ "        names::write(caller, _name);\n"
#~ "        StoredName(caller, _name);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "An event is defined as an empty function annotated with the `#[event]` "
#~ "attribute. The parameters of this function\n"
#~ "are the data that will be emitted by the event."
#~ msgstr ""
#~ "Un evento se define como una función vacía anotada con el atributo "
#~ "`#[evento]`. Los parámetros de esta función\n"
#~ "son los datos que serán emitidos por el evento."

#~ msgid ""
#~ "In Listing 99-1, `StoredName` is an event that emits information when "
#~ "names are stored in the contract:"
#~ msgstr ""
#~ "En el Listado 9-1, `StoredName` es un evento que emite información cuando "
#~ "se almacenan nombres en el contrato:"

#~ msgid ""
#~ "```rust\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[event]\n"
#~ "    fn StoredName(caller: ContractAddress, name: felt252) {}\n"
#~ "```"

#~ msgid ""
#~ "We pass in the emitted data types as parameters within the parentheses. "
#~ "In this example, our event will emit the contract address of the caller "
#~ "and the name stored within the contract."
#~ msgstr ""
#~ "Pasamos los tipos de datos emitidos como parámetros dentro de los "
#~ "paréntesis. En este ejemplo, nuestro evento emitirá la dirección del "
#~ "contrato de la persona que llama y el nombre almacenado en el contrato."

#~ msgid ""
#~ "After defining events, we can emit them by simply calling the event name "
#~ "like we'll call functions,\n"
#~ "passing in the values to be emitted as parameters:"
#~ msgstr ""
#~ "Después de definir los eventos, podemos emitirlos simplemente llamando al "
#~ "nombre del evento como llamaremos a las funciones,\n"
#~ "pasando los valores a emitir como parámetros:"

#~ msgid ""
#~ "```rust\n"
#~ "        StoredName(caller, _name);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        StoredName(caller, _name);\n"
#~ "```"

#~ msgid ""
#~ "The ability of contracts to interact with other smart contracts on the "
#~ "blockchain is a common pattern found in smart contract development."
#~ msgstr ""
#~ "La capacidad de los contratos para interactuar con otros contratos "
#~ "inteligentes en la cadena de bloques es un patrón común en el desarrollo "
#~ "de contratos inteligentes."

#~ msgid ""
#~ "For your Cairo code to qualify as an interface, it must meet the "
#~ "following requirements:"
#~ msgstr ""
#~ "Para que tu código de Cairo califique como una interfaz, debe cumplir con "
#~ "los siguientes requisitos:"

#~ msgid ""
#~ "1. Must be appended with the `#[abi]` attribute.\n"
#~ "2. Your interface functions should have no implementations.\n"
#~ "3. You must explicitly declare the function's decorator.\n"
#~ "4. Your interface should not declare a constructor.\n"
#~ "5. Your interface should not declare state variables."
#~ msgstr ""
#~ "1. Debe estar marcado con el atributo `[abi]`.\n"
#~ "2. Las funciones de tu interfaz no deben tener implementaciones.\n"
#~ "3. Debes declarar explícitamente el decorador de la función.\n"
#~ "4. Tu interfaz no debe declarar un constructor.\n"
#~ "5. Tu interfaz no debe declarar variables de estado."

#~ msgid "Here's a sample interface for an ERC20 token contract:"
#~ msgstr ""
#~ "Aquí hay un ejemplo de una interfaz para un contrato de token ERC20:"

#~ msgid ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[abi]\n"
#~ "trait IERC20 {\n"
#~ "    #[view]\n"
#~ "    fn name() -> felt252;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn symbol() -> felt252;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn decimals() -> u8;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn total_supply() -> u256;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn balance_of(account: ContractAddress) -> u256;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn allowance(owner: ContractAddress, spender: ContractAddress) -> "
#~ "u256;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256) -> bool;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[abi]\n"
#~ "trait IERC20 {\n"
#~ "    #[view]\n"
#~ "    fn name() -> felt252;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn symbol() -> felt252;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn decimals() -> u8;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn total_supply() -> u256;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn balance_of(account: ContractAddress) -> u256;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn allowance(owner: ContractAddress, spender: ContractAddress) -> "
#~ "u256;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256) -> bool;\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
#~ "}\n"
#~ "```"

#~ msgid "## ABIs"
#~ msgstr "## ABIs"

#~ msgid ""
#~ "ABI stands for Application Binary Interface. ABIs gives a smart contract "
#~ "the ability to communicate and interact with external applications or "
#~ "other smart contracts. ABIs can be likened to APIs in traditional web "
#~ "development, which helps data flow between applications and servers."
#~ msgstr ""
#~ "ABI significa Interfaz Binaria de Aplicaciones. Los ABI dan a un contrato "
#~ "inteligente la capacidad de comunicarse e interactuar con aplicaciones "
#~ "externas u otros contratos inteligentes. Los ABI se pueden comparar con "
#~ "las API en el desarrollo web tradicional, que ayudan al flujo de datos "
#~ "entre aplicaciones y servidores."

#~ msgid ""
#~ "Every contract on Starknet has an Application Binary Interface (ABI) that "
#~ "defines how to encode and decode data when calling its methods."
#~ msgstr ""
#~ "Cada contrato en Starknet tiene una Interfaz Binaria de Aplicaciones "
#~ "(ABI) que define cómo codificar y decodificar datos al llamar a los "
#~ "métodos del contrato inteligente."

#~ msgid "# Contract Dispatcher, Library Dispatcher and System calls"
#~ msgstr ""
#~ "# Despachador de Contratos, Despachador de Bibliotecas y Llamadas del "
#~ "Sistema"

#~ msgid ""
#~ "Traits annotated with the `#[abi]` attribute are programmed to "
#~ "automatically generate and export the relevant dispatcher logic on "
#~ "compilation. The compiler also generates a new trait, two new structs "
#~ "(one for contract calls, and the other for library calls) and their "
#~ "implementation of this trait. Our interface is expanded into something "
#~ "like this:"
#~ msgstr ""
#~ "Los traits anotados con el atributo `#[abi]` están programados para "
#~ "generar y exportar automáticamente la lógica del dispatcher relevante en "
#~ "la compilación. El compilador también genera un nuevo trait, dos nuevos "
#~ "structs (uno para llamadas a contratos y otro para llamadas a librerías) "
#~ "y su implementación de este trait. Nuestra interfaz se expande en algo "
#~ "como esto:"

#~ msgid ""
#~ "```rust\n"
#~ "//does_not_compile\n"
#~ "use starknet::{ContractAddress};\n"
#~ "\n"
#~ "trait IERC20DispatcherTrait<T> {\n"
#~ "    fn name(self: T) -> felt252;\n"
#~ "    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
#~ "struct IERC20Dispatcher {\n"
#~ "    contract_address: starknet::ContractAddress, \n"
#~ "}\n"
#~ "\n"
#~ "impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
#~ "    fn name(\n"
#~ "        self: IERC20Dispatcher\n"
#~ "    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
#~ "    }\n"
#~ "    fn transfer(\n"
#~ "        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
#~ "    ) { // starknet::call_contract_syscall is called in here\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//does_not_compile\n"
#~ "use starknet::{ContractAddress};\n"
#~ "\n"
#~ "trait IERC20DispatcherTrait<T> {\n"
#~ "    fn name(self: T) -> felt252;\n"
#~ "    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
#~ "struct IERC20Dispatcher {\n"
#~ "    contract_address: starknet::ContractAddress, \n"
#~ "}\n"
#~ "\n"
#~ "impl IERC20DispatcherImpl of IERC20DispatcherTrait<IERC20Dispatcher> {\n"
#~ "    fn name(\n"
#~ "        self: IERC20Dispatcher\n"
#~ "    ) -> felt252 { // starknet::call_contract_syscall is called in here\n"
#~ "    }\n"
#~ "    fn transfer(\n"
#~ "        self: IERC20Dispatcher, recipient: ContractAddress, amount: u256\n"
#~ "    ) { // starknet::call_contract_syscall is called in here\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# use starknet::ContractAddress;\n"
#~ "# \n"
#~ "# #[abi]\n"
#~ "# trait IERC20 {\n"
#~ "#     #[view]\n"
#~ "#     fn name() -> felt252;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn symbol() -> felt252;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn decimals() -> u8;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn total_supply() -> u256;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn balance_of(account: ContractAddress) -> u256;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn allowance(owner: ContractAddress, spender: ContractAddress) -> "
#~ "u256;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn transfer_from(sender: ContractAddress, recipient: "
#~ "ContractAddress, amount: u256) -> bool;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "//**** Specify interface here ****//\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(_contract_address: ContractAddress) -> felt252 {\n"
#~ "        IERC20Dispatcher { contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher { contract_address: _contract_address }."
#~ "transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# use starknet::ContractAddress;\n"
#~ "# \n"
#~ "# #[abi]\n"
#~ "# trait IERC20 {\n"
#~ "#     #[view]\n"
#~ "#     fn name() -> felt252;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn symbol() -> felt252;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn decimals() -> u8;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn total_supply() -> u256;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn balance_of(account: ContractAddress) -> u256;\n"
#~ "# \n"
#~ "#     #[view]\n"
#~ "#     fn allowance(owner: ContractAddress, spender: ContractAddress) -> "
#~ "u256;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn transfer_from(sender: ContractAddress, recipient: "
#~ "ContractAddress, amount: u256) -> bool;\n"
#~ "# \n"
#~ "#     #[external]\n"
#~ "#     fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
#~ "# }\n"
#~ "# \n"
#~ "//**** Specify interface here ****//\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(_contract_address: ContractAddress) -> felt252 {\n"
#~ "        IERC20Dispatcher { contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher { contract_address: _contract_address }."
#~ "transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "# \n"
#~ "```"

#~ msgid ""
#~ "The key difference between the contract dispatcher and the library "
#~ "dispatcher is that while the contract dispatcher calls an external "
#~ "contract's logic in the external contract's context, the library "
#~ "dispatcher calls the target contract's classhash, whilst executing the "
#~ "call in the calling contract's context.\n"
#~ "So unlike the contract dispatcher, calls made using the library "
#~ "dispatcher have no possibility of tampering with the target contract's "
#~ "state."
#~ msgstr ""
#~ "La diferencia clave entre el despachador de contratos y el despachador de "
#~ "librerías es que mientras el despachador de contratos llama a la lógica "
#~ "de un contrato externo en el contexto del contrato externo, el "
#~ "despachador de librerías llama al classhash del contrato destino, "
#~ "mientras ejecuta la llamada en el contexto del contrato que llama.\n"
#~ "Por lo tanto, a diferencia del despachador de contratos, las llamadas "
#~ "realizadas mediante el despachador de bibliotecas no tienen la "
#~ "posibilidad de alterar el estado del contrato de destino."

#~ msgid ""
#~ "As stated in the previous chapter, contracts annotated with the `#[abi]` "
#~ "macro on compilation generates a new trait, two new structs (one for "
#~ "contract calls, and the other for library calls) and their implementation "
#~ "of this trait. The expanded form of the library traits looks like:"
#~ msgstr ""
#~ "Como se indicó en el capítulo anterior, los contratos anotados con la "
#~ "macro `#[abi]` en la compilación generan un nuevo trait, dos nuevas "
#~ "estructuras (una para llamadas a contratos y otra para llamadas a "
#~ "bibliotecas) y su implementación de este trait. La forma expandida de los "
#~ "traits de biblioteca se ve así:"

#~ msgid ""
#~ "```rust\n"
#~ "//does_not_compile\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "trait IERC20DispatcherTrait<T> {\n"
#~ "    fn name(self: T) -> felt252;\n"
#~ "    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
#~ "struct IERC20LibraryDispatcher {\n"
#~ "    class_hash: starknet::ClassHash, \n"
#~ "}\n"
#~ "\n"
#~ "impl IERC20LibraryDispatcherImpl of "
#~ "IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
#~ "    fn name(\n"
#~ "        self: IERC20LibraryDispatcher\n"
#~ "    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called "
#~ "in here\n"
#~ "    }\n"
#~ "    fn transfer(\n"
#~ "        self: IERC20LibraryDispatcher, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//does_not_compile\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "trait IERC20DispatcherTrait<T> {\n"
#~ "    fn name(self: T) -> felt252;\n"
#~ "    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Copy, Drop, storage_access::StorageAccess, Serde)]\n"
#~ "struct IERC20LibraryDispatcher {\n"
#~ "    class_hash: starknet::ClassHash, \n"
#~ "}\n"
#~ "\n"
#~ "impl IERC20LibraryDispatcherImpl of "
#~ "IERC20DispatcherTrait<IERC20LibraryDispatcher> {\n"
#~ "    fn name(\n"
#~ "        self: IERC20LibraryDispatcher\n"
#~ "    ) -> felt252 { // starknet::syscalls::library_call_syscall  is called "
#~ "in here\n"
#~ "    }\n"
#~ "    fn transfer(\n"
#~ "        self: IERC20LibraryDispatcher, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) { // starknet::syscalls::library_call_syscall  is called in here\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20LibraryDispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name() -> felt252 {\n"
#~ "        IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::"
#~ "<0x1234>() }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(recipient: ContractAddress, amount: u256) -> bool "
#~ "{\n"
#~ "        IERC20LibraryDispatcher {\n"
#~ "            class_hash: starknet::class_hash_const::<0x1234>()\n"
#~ "        }.transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20LibraryDispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name() -> felt252 {\n"
#~ "        IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::"
#~ "<0x1234>() }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(recipient: ContractAddress, amount: u256) -> bool "
#~ "{\n"
#~ "        IERC20LibraryDispatcher {\n"
#~ "            class_hash: starknet::class_hash_const::<0x1234>()\n"
#~ "        }.transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "As you can see, we had to first import the `IERC20DispatcherTrait` and "
#~ "`IERC20LibraryDispatcher` which was generated and exported on compiling "
#~ "our interface, then we make calls to the methods implemented for the "
#~ "`IERC20LibraryDispatcher` struct (`name`, `transfer`, etc), passing in "
#~ "the `class_hash` parameter which represents the class of the contract we "
#~ "want to call."
#~ msgstr ""
#~ "Como se puede ver, primero tuvimos que importar `IERC20DispatcherTrait` e "
#~ "`IERC20LibraryDispatcher`, los cuales fueron generados y exportados al "
#~ "compilar nuestra interfaz. Luego realizamos llamadas a los métodos "
#~ "implementados para la estructura `IERC20LibraryDispatcher` (`name`, "
#~ "`transfer`, etc.), pasando el parámetro `class_hash` que representa la "
#~ "clase del contrato que queremos llamar."

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        address: starknet::ContractAddress, selector: felt252, calldata: "
#~ "Array<felt252>\n"
#~ "    ) -> Span::<felt252> {\n"
#~ "        starknet::call_contract_syscall(address, selector, calldata."
#~ "span()).unwrap_syscall()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod contract {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        address: starknet::ContractAddress, selector: felt252, calldata: "
#~ "Array<felt252>\n"
#~ "    ) -> Span::<felt252> {\n"
#~ "        starknet::call_contract_syscall(address, selector, calldata."
#~ "span()).unwrap_syscall()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "As you can see, rather than pass our function arguments directly, we "
#~ "passed in the contract address, function selector (which is a keccak hash "
#~ "of the function name), and the calldata (function arguments). At the end, "
#~ "we get returned a serialized value which we'll need to deserialize "
#~ "ourselves!"
#~ msgstr ""
#~ "Como se puede ver, en lugar de pasar nuestros argumentos de función "
#~ "directamente, pasamos la dirección del contrato, el selector de la "
#~ "función (que es un hash keccak del nombre de la función) y los datos de "
#~ "llamada (argumentos de función). Al final, ¡Se nos devuelve un valor "
#~ "serializado que tendremos que deserializar nosotros mismos!"

#~ msgid "# Security Considerations"
#~ msgstr "# Consideraciones de Seguridad"

#~ msgid ""
#~ "- Inputs provided by the caller\n"
#~ "- Execution requirements\n"
#~ "- Invariants (conditions that must always be true)\n"
#~ "- Return values from other function calls"
#~ msgstr ""
#~ "- Entradas proporcionadas por el autor de la llamada\n"
#~ "- Requisitos de ejecución\n"
#~ "- Invariantes (condiciones que deben cumplirse siempre)\n"
#~ "- Valores de retorno de otras llamadas a funciones"

#~ msgid ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn withdraw(amount: u256) {\n"
#~ "        let current_balance = balance::read();\n"
#~ "\n"
#~ "        assert(balance >= amount, 'Insufficient funds');\n"
#~ "\n"
#~ "        balance::write(current_balance - amount);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn withdraw(amount: u256) {\n"
#~ "        let current_balance = balance::read();\n"
#~ "\n"
#~ "        assert(balance >= amount, 'Insufficient funds');\n"
#~ "\n"
#~ "        balance::write(current_balance - amount);\n"
#~ "    }\n"
#~ "```"

#~ msgid "<!-- TODO add reference to the reentrancy CairoByExample page -->"
#~ msgstr ""
#~ "<!-- TODO añadir referencia a la página de reentrada CairoByExample -->"

#~ msgid ""
#~ "1. **Checks**: Validate all conditions and inputs before performing any "
#~ "state changes.\n"
#~ "2. **Effects**: Perform all state changes.\n"
#~ "3. **Interactions**: All external calls to other contracts should be made "
#~ "at the end of the function."
#~ msgstr ""
#~ "1. **Comprobaciones**: Validar todas las condiciones y entradas antes de "
#~ "realizar cualquier cambio de estado.\n"
#~ "2. **Efectos**: Realizar todos los cambios de estado.\n"
#~ "3. **Interacciones**: Todas las llamadas externas a otros contratos deben "
#~ "realizarse al final de la función."

#~ msgid ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod access_control_contract {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use starknet::get_caller_address;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        // Role 'owner': only one address\n"
#~ "        owner: ContractAddress,\n"
#~ "        // Role 'role_a': a set of addresses\n"
#~ "        role_a: LegacyMap::<ContractAddress, bool>\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor() {\n"
#~ "        owner::write(get_caller_address());\n"
#~ "    }\n"
#~ "\n"
#~ "    // Guard functions to check roles\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn is_owner() -> bool {\n"
#~ "        owner::read() == get_caller_address()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn is_role_a() -> bool {\n"
#~ "        role_a::read(get_caller_address())\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn only_owner() {\n"
#~ "        assert(is_owner(), 'Not owner');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn only_role_a() {\n"
#~ "        assert(is_role_a(), 'Not role A');\n"
#~ "    }\n"
#~ "\n"
#~ "    // You can easily combine guards to perfom complex checks\n"
#~ "    fn only_allowed() {\n"
#~ "        assert(is_owner() || is_role_a(), 'Not allowed');\n"
#~ "    }\n"
#~ "\n"
#~ "    // Functions to manage roles\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn set_role_a(_target: ContractAddress, _active: bool) {\n"
#~ "        only_owner();\n"
#~ "        role_a::write(_target, _active);\n"
#~ "    }\n"
#~ "\n"
#~ "    // You can now focus on the business logic of your contract\n"
#~ "    // and reduce the complexity of your code by using guard functions\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn role_a_action() {\n"
#~ "        only_role_a();\n"
#~ "    // ...\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn allowed_action() {\n"
#~ "        only_allowed();\n"
#~ "    // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[contract]\n"
#~ "mod access_control_contract {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use starknet::get_caller_address;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        // Role 'owner': only one address\n"
#~ "        owner: ContractAddress,\n"
#~ "        // Role 'role_a': a set of addresses\n"
#~ "        role_a: LegacyMap::<ContractAddress, bool>\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor() {\n"
#~ "        owner::write(get_caller_address());\n"
#~ "    }\n"
#~ "\n"
#~ "    // Guard functions to check roles\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn is_owner() -> bool {\n"
#~ "        owner::read() == get_caller_address()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn is_role_a() -> bool {\n"
#~ "        role_a::read(get_caller_address())\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn only_owner() {\n"
#~ "        assert(is_owner(), 'Not owner');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[inline(always)]\n"
#~ "    fn only_role_a() {\n"
#~ "        assert(is_role_a(), 'Not role A');\n"
#~ "    }\n"
#~ "\n"
#~ "    // You can easily combine guards to perfom complex checks\n"
#~ "    fn only_allowed() {\n"
#~ "        assert(is_owner() || is_role_a(), 'Not allowed');\n"
#~ "    }\n"
#~ "\n"
#~ "    // Functions to manage roles\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn set_role_a(_target: ContractAddress, _active: bool) {\n"
#~ "        only_owner();\n"
#~ "        role_a::write(_target, _active);\n"
#~ "    }\n"
#~ "\n"
#~ "    // You can now focus on the business logic of your contract\n"
#~ "    // and reduce the complexity of your code by using guard functions\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn role_a_action() {\n"
#~ "        only_role_a();\n"
#~ "    // ...\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn allowed_action() {\n"
#~ "        only_allowed();\n"
#~ "    // ...\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "# Appendix"
#~ msgstr "# Apéndice"

#~ msgid ""
#~ "- strict\n"
#~ "- reserved"
#~ msgstr ""
#~ "- strict\n"
#~ "- reserved"

#~ msgid ""
#~ "- `as` - Rename import\n"
#~ "- `break` - Exit a loop immediately\n"
#~ "- `const` - Define constant items\n"
#~ "- `continue` - Continue to the next loop iteration\n"
#~ "- `else` - Fallback for `if` and `if let` control flow constructs\n"
#~ "- `enum` - Define an enumeration\n"
#~ "- `extern` - Function defined at the compiler level using hint available "
#~ "at cairo1 level with this declaration\n"
#~ "- `false` - Boolean false literal\n"
#~ "- `fn` - Define a function\n"
#~ "- `if` - Branch based on the result of a conditional expression\n"
#~ "- `impl` - Implement inherent or trait functionality\n"
#~ "- `implicits` - Special kind of function parameters that are required to "
#~ "perform certain actions\n"
#~ "- `let` - Bind a variable\n"
#~ "- `loop` - Loop unconditionally\n"
#~ "- `match` - Match a value to patterns\n"
#~ "- `mod` - Define a module\n"
#~ "- `mut` - Denote variable mutability\n"
#~ "- `nopanic` - Functions marked with this notation mean that the function "
#~ "will never panic.\n"
#~ "- `of` - Implement a trait\n"
#~ "- `ref` - Bind by reference\n"
#~ "- `return` - Return from function\n"
#~ "- `struct` - Define a structure\n"
#~ "- `trait` - Define a trait\n"
#~ "- `true` - Boolean true literal\n"
#~ "- `type` - Define a type alias\n"
#~ "- `use` - Bring symbols into scope"
#~ msgstr ""
#~ "- `as` - Renombrar importación\n"
#~ "- `break` - Salir inmediatamente de un bucle\n"
#~ "- `const` - Definir elementos constantes\n"
#~ "- `continue` - Continúa con la siguiente iteración del bucle\n"
#~ "- `else` - Fallback para construcciones de flujo de control `if` y `if "
#~ "let`\n"
#~ "- `enum` - Define una enumeración\n"
#~ "- `extern` - Función definida a nivel de compilador utilizando una "
#~ "sugerencia disponible a nivel de cairo1 con esta declaración\n"
#~ "- `false` - Literal booleano falso\n"
#~ "- `fn` - Define una función\n"
#~ "- `if` - Rama basada en el resultado de una expresión condicional\n"
#~ "- `impl` - Implementa funcionalidad inherente o trait\n"
#~ "- `implicits` - Parámetros de función de tipo especial necesarios para "
#~ "realizar ciertas acciones\n"
#~ "- `let` - Vincular una variable\n"
#~ "- `loop` - Hacer un bucle incondicional\n"
#~ "- `match` - Comparar un valor con patrones\n"
#~ "- `mod` - Definir un módulo\n"
#~ "- `mut` - Denota mutabilidad de variables\n"
#~ "- `nopanic` - Las funciones marcadas con esta notación significan que la "
#~ "función nunca entrará en pánico.\n"
#~ "- `of` - Implementar un trait\n"
#~ "- `ref` - Vincular por referencia\n"
#~ "- `return` - Retorno de una función\n"
#~ "- `struct` - Define una estructura\n"
#~ "- `trait` - Define un trait\n"
#~ "- `true` - Literal booleano verdadero\n"
#~ "- `type` - Definir un alias de tipo\n"
#~ "- `use` - Introducir símbolos"

#~ msgid ""
#~ "- `do`\n"
#~ "- `dyn`\n"
#~ "- `macro`\n"
#~ "- `move`\n"
#~ "- `Self`\n"
#~ "- `self`\n"
#~ "- `static_assert`\n"
#~ "- `static`\n"
#~ "- `super`\n"
#~ "- `try`\n"
#~ "- `typeof`\n"
#~ "- `unsafe`\n"
#~ "- `where`\n"
#~ "- `while`\n"
#~ "- `with`\n"
#~ "- `yield`"
#~ msgstr ""
#~ "- `do`\n"
#~ "- `dyn`\n"
#~ "- `macro`\n"
#~ "- `move`\n"
#~ "- `Self`\n"
#~ "- `self`\n"
#~ "- `static_assert`\n"
#~ "- `static`\n"
#~ "- `super`\n"
#~ "- `try`\n"
#~ "- `typeof`\n"
#~ "- `unsafe`\n"
#~ "- `where`\n"
#~ "- `while`\n"
#~ "- `with`\n"
#~ "- `yield`"

#~ msgid "<span class=\"caption\">Table B-1: Operators</span>"
#~ msgstr "<span class=\"caption\">Tabla B-1: Operadores</span>"

#~ msgid ""
#~ "| Operator | Example | Explanation | Overloadable? |\n"
#~ "|----------|---------|-------------|---------------|\n"
#~ "| `!` | `!expr` | Bitwise or logical complement | `Not` |\n"
#~ "| `!=` | `expr != expr` | Non-equality comparison | `PartialEq` |\n"
#~ "| `%` | `expr % expr` | Arithmetic remainder | `Rem` |\n"
#~ "| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemEq` |\n"
#~ "| `&` | `expr & expr` | Bitwise AND | `BitAnd` |\n"
#~ "| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |\n"
#~ "| `*=` | `var *= expr` | Arithmetic multiplication and assignment | "
#~ "`MulEq` |\n"
#~ "| `@` | `@var` | Snapshot | |\n"
#~ "| `*` | `*var` | Desnap | |\n"
#~ "| `+` | `expr + expr` | Arithmetic addition | `Add` |\n"
#~ "| `+=` | `var += expr` | Arithmetic addition and assignment | `AddEq` |\n"
#~ "| `,` | `expr, expr` | Argument and element separator | |\n"
#~ "| `-` | `-expr` | Arithmetic negation | `Neg` |\n"
#~ "| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |\n"
#~ "| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubEq` "
#~ "|\n"
#~ "| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | "
#~ "Function and closure return type | |\n"
#~ "| `.` | `expr.ident` | Member access | |\n"
#~ "| `/` | `expr / expr` | Arithmetic division | `Div` |\n"
#~ "| `/=` | `var /= expr` | Arithmetic division and assignment | `DivEq` |\n"
#~ "| `:` | `pat: type`, `ident: type` | Constraints | |\n"
#~ "| `:` | `ident: expr` | Struct field initializer | |\n"
#~ "| `;` | `expr;` | Statement and item terminator | |\n"
#~ "| `<` | `expr < expr` | Less than comparison | `PartialOrd` |\n"
#~ "| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` "
#~ "|\n"
#~ "| `=` | `var = expr` | Assignment | |\n"
#~ "| `==` | `expr == expr` | Equality comparison | `PartialEq` |\n"
#~ "| `=>` | `pat => expr` | Part of match arm syntax | |\n"
#~ "| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |\n"
#~ "| `>=` | `expr >= expr` | Greater than or equal to comparison | "
#~ "`PartialOrd` |\n"
#~ "| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |\n"
#~ "| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | "
#~ "`BitOr` |"
#~ msgstr ""
#~ "| Operador | Ejemplo | Explicación | ¿Sobrecargable? |\n"
#~ "|----------|---------|-------------|---------------|\n"
#~ "| `!` | `!expr` | Complemento lógico o de bits | `Not` |\n"
#~ "| `!=` | `expr != expr` | Comparación de no igualdad | `PartialEq` |\n"
#~ "| `%` | `expr % expr` | Resto aritmético | `Rem` |\n"
#~ "| `%=` | `var %= expr` | Resto aritmético y asignación | `RemEq` |\n"
#~ "| `&` | `expr & expr` | AND de bits | `BitAnd` |\n"
#~ "| `*` | `expr * expr` | Multiplicación aritmética | `Mul` |\n"
#~ "| `*=` | `var *= expr` | Multiplicación aritmética y asignación | `MulEq` "
#~ "|\n"
#~ "| `@` | `@var` | Snapshot | |\n"
#~ "| `*` | `*var` | Desnap | |\n"
#~ "| `+` | `expr + expr` | Suma aritmética | `Add` |\n"
#~ "| `+=` | `var += expr` | Suma aritmética y asignación | `AddEq` |\n"
#~ "| `,` | `expr, expr` | Separador de argumentos y elementos | |\n"
#~ "| `-` | `-expr` | Negación aritmética | `Neg` |\n"
#~ "| `-` | `expr - expr` | Resta aritmética | `Sub` |\n"
#~ "| `-=` | `var -= expr` | Resta aritmética y asignación | `SubEq` |\n"
#~ "| `->` | `fn(...) -> type`, <code>|...| -> type</code> | Tipo de retorno "
#~ "de función y clausura | |\n"
#~ "| `.` | `expr.ident` | Acceso a miembro | |\n"
#~ "| `/` | `expr / expr` | División aritmética | `Div` |\n"
#~ "| `/=` | `var /= expr` | División aritmética y asignación | `DivEq` |\n"
#~ "| `:` | `pat: type`, `ident: type` | Restricciones | |\n"
#~ "| `:` | `ident: expr` | Inicializador de campo de estructura | |\n"
#~ "| `;` | `expr;` | Terminador de declaración e ítem | |\n"
#~ "| `<` | `expr < expr` | Comparación menor que | `PartialOrd` |\n"
#~ "| `<=` | `expr <= expr` | Comparación menor o igual que | `PartialOrd` |\n"
#~ "| `=` | `var = expr` | Asignación | |\n"
#~ "| `==` | `expr == expr` | Comparación de igualdad | `PartialEq` |\n"
#~ "| `=>` | `pat => expr` | Parte de la sintaxis de brazo de coincidencia | "
#~ "|\n"
#~ "| `>` | `expr > expr` | Comparación mayor que | `PartialOrd` |\n"
#~ "| `>=` | `expr >= expr` | Comparación mayor o igual que | `PartialOrd` |\n"
#~ "| `^` | `expr ^ expr` | OR exclusivo de bits | `BitXor` |\n"
#~ "| <code>|</code> | <code>expr | expr</code> | OR de bits | `BitOr` |"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `..._u8`, `..._usize`, etc. | Numeric literal of specific type |\n"
#~ "| `'...'` | Short string |\n"
#~ "| `_` | “Ignored” pattern binding; also used to make integer literals "
#~ "readable |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `..._u8`, `..._usize`, etc. | Literal numérico de un tipo específico |\n"
#~ "| `'...'` | Cadena corta |\n"
#~ "| `_` | Enlace de patrón \"ignorado\"; también se usa para hacer que los "
#~ "literales enteros sean legibles |"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `ident::ident` | Namespace path |\n"
#~ "| `super::path` | Path relative to the parent of the current module |\n"
#~ "| `trait::method(...)` | Disambiguating a method call by naming the trait "
#~ "that defines it |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `ident::ident` | Ruta de espacio de nombres |\n"
#~ "| `super::path` | Ruta relativa al padre del módulo actual |\n"
#~ "| `trait::method(...)` | Desambiguación de una llamada de método "
#~ "nombrando la trait que lo define |"

#~ msgid "<span class=\"caption\">Table B-4: Generics</span>"
#~ msgstr "<span class=\"caption\">Tabla B-4: Genéricos</span>"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `path<...>` | Specifies parameters to generic type in a type (e.g., "
#~ "`Vec<u8>`) |\n"
#~ "| `path::<...>`, `method::<...>` | Specifies parameters to generic type, "
#~ "function, or method in an expression; often referred to as turbofish |\n"
#~ "| `fn ident<...> ...` | Define generic function |\n"
#~ "| `struct ident<...> ...` | Define generic structure |\n"
#~ "| `enum ident<...> ...` | Define generic enumeration |\n"
#~ "| `impl<...> ...` | Define generic implementation |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `path<...>` | Especifica parámetros para un tipo genérico en un tipo "
#~ "(por ejemplo, `Vec<u8>`) |\n"
#~ "| `path::<...>`, `method::<...>` | Especifica parámetros para un tipo "
#~ "genérico, función o método en una expresión; a menudo se le conoce como "
#~ "\"turbofish\" |\n"
#~ "| `fn ident<...> ...` | Define una función genérica |\n"
#~ "| `struct ident<...> ...` | Define una estructura genérica |\n"
#~ "| `enum ident<...> ...` | Define una enumeración genérica |\n"
#~ "| `impl<...> ...` | Define una implementación genérica |"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `#[meta]` | Outer attribute |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `#[meta]` | Atributo externo |"

#~ msgid "<span class=\"caption\">Table B-6: Comments</span>"
#~ msgstr "<span class=\"caption\">Tabla B-6: Comentarios</span>"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `//` | Line comment |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `//` | Comentario de línea |"

#~ msgid "<span class=\"caption\">Table B-7: Tuples</span>"
#~ msgstr "<span class=\"caption\">Tabla B-7: Tuplas<span>"

#~ msgid ""
#~ "| Symbol | Explanation |\n"
#~ "|--------|-------------|\n"
#~ "| `()` | Empty tuple (aka unit), both literal and type |\n"
#~ "| `(expr)` | Parenthesized expression |\n"
#~ "| `(expr,)` | Single-element tuple expression |\n"
#~ "| `(type,)` | Single-element tuple type |\n"
#~ "| `(expr, ...)` | Tuple expression |\n"
#~ "| `(type, ...)` | Tuple type |\n"
#~ "| `expr(expr, ...)` | Function call expression; also used to initialize "
#~ "tuple `struct`s and tuple `enum` variants |"
#~ msgstr ""
#~ "| Símbolo | Explicación |\n"
#~ "|---------|-------------|\n"
#~ "| `()` | Tupla vacía (también conocida como unidad), tanto como literal "
#~ "como tipo |\n"
#~ "| `(expr)` | Expresión entre paréntesis |\n"
#~ "| `(expr,)` | Expresión de tupla de un solo elemento |\n"
#~ "| `(type,)` | Tipo de tupla de un solo elemento |\n"
#~ "| `(expr, ...)` | Expresión de tupla |\n"
#~ "| `(type, ...)` | Tipo de tupla |\n"
#~ "| `expr(expr, ...)` | Expresión de llamada de función; también se usa "
#~ "para inicializar estructuras de tuplas y variantes de tuplas de "
#~ "enumeraciones |"

#~ msgid ""
#~ "| Context | Explanation |\n"
#~ "|---------|-------------|\n"
#~ "| `{...}` | Block expression |\n"
#~ "| `Type {...}` | `struct` literal |"
#~ msgstr ""
#~ "| Contexto | Explicación |\n"
#~ "|----------|-------------|\n"
#~ "| `{...}` | Expresión de bloque |\n"
#~ "| `Type {...}` | Literal de `struct` |"

#~ msgid ""
#~ "```Rust\n"
#~ "#[derive(PartialEq, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    assert(first_struct == second_struct, 'Structs are different');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```Rust\n"
#~ "#[derive(PartialEq, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    assert(first_struct == second_struct, 'Structs are different');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```Rust\n"
#~ "use clone::Clone;\n"
#~ "\n"
#~ "#[derive(Clone, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = first_struct.clone();\n"
#~ "    assert(second_struct.item == 2, 'Not equal');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```Rust\n"
#~ "use clone::Clone;\n"
#~ "\n"
#~ "#[derive(Clone, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = first_struct.clone();\n"
#~ "    assert(second_struct.item == 2, 'Not equal');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```Rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = first_struct;\n"
#~ "    assert(second_struct.item == 2, 'Not equal');\n"
#~ "    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents "
#~ "firs_struct from moving into second_struct\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```Rust\n"
#~ "#[derive(Copy, Drop)]\n"
#~ "struct A {\n"
#~ "    item: felt252\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item: 2\n"
#~ "    };\n"
#~ "    let second_struct = first_struct;\n"
#~ "    assert(second_struct.item == 2, 'Not equal');\n"
#~ "    assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents "
#~ "firs_struct from moving into second_struct\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```Rust\n"
#~ "use serde::Serde;\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "#[derive(Serde, Drop)]\n"
#~ "struct A {\n"
#~ "    item_one: felt252,\n"
#~ "    item_two: felt252,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item_one: 2,\n"
#~ "        item_two: 99,\n"
#~ "    };\n"
#~ "    let mut output_array = ArrayTrait::new();\n"
#~ "    let serialized = first_struct.serialize(ref output_array);\n"
#~ "    panic(output_array);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```Rust\n"
#~ "use serde::Serde;\n"
#~ "use array::ArrayTrait;\n"
#~ "\n"
#~ "#[derive(Serde, Drop)]\n"
#~ "struct A {\n"
#~ "    item_one: felt252,\n"
#~ "    item_two: felt252,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item_one: 2,\n"
#~ "        item_two: 99,\n"
#~ "    };\n"
#~ "    let mut output_array = ArrayTrait::new();\n"
#~ "    let serialized = first_struct.serialize(ref output_array);\n"
#~ "    panic(output_array);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```Bash\n"
#~ "Run panicked with [2 (''), 99 ('c'), ].\n"
#~ "```"
#~ msgstr ""
#~ "```Bash\n"
#~ "Run panicked with [2 (''), 99 ('c'), ].\n"
#~ "```"

#~ msgid ""
#~ "```Rust\n"
#~ "use serde::Serde;\n"
#~ "use array::ArrayTrait;\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "#[derive(Serde, Drop)]\n"
#~ "struct A {\n"
#~ "    item_one: felt252,\n"
#~ "    item_two: felt252,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item_one: 2,\n"
#~ "        item_two: 99,\n"
#~ "    };\n"
#~ "    let mut output_array = ArrayTrait::new();\n"
#~ "    let mut serialized = first_struct.serialize(ref output_array);\n"
#~ "    let mut span_array = output_array.span();\n"
#~ "    let deserialized_struct: A = Serde::<A>::deserialize(ref span_array)."
#~ "unwrap();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```Rust\n"
#~ "use serde::Serde;\n"
#~ "use array::ArrayTrait;\n"
#~ "use option::OptionTrait;\n"
#~ "\n"
#~ "#[derive(Serde, Drop)]\n"
#~ "struct A {\n"
#~ "    item_one: felt252,\n"
#~ "    item_two: felt252,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let first_struct = A {\n"
#~ "        item_one: 2,\n"
#~ "        item_two: 99,\n"
#~ "    };\n"
#~ "    let mut output_array = ArrayTrait::new();\n"
#~ "    let mut serialized = first_struct.serialize(ref output_array);\n"
#~ "    let mut span_array = output_array.span();\n"
#~ "    let deserialized_struct: A = Serde::<A>::deserialize(ref span_array)."
#~ "unwrap();\n"
#~ "}\n"
#~ "```"

#~ msgid "TODO (Not derivable yet ?)"
#~ msgstr "TODO (¿Todavía no derivable?)"

#~ msgid ""
#~ "```console\n"
#~ "cairo-format -r\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "cairo-format -r\n"
#~ "```"

#~ msgid ""
#~ "Running this command reformats all the Cairo code in the current "
#~ "directory, recursively. This\n"
#~ "should only change the code style, not the code semantics."
#~ msgstr ""
#~ "Ejecutando este comando reformateará todo el código de Cairo en el "
#~ "directorio actual de forma recursiva. Esto \n"
#~ "solo cambiará el estilo de código, no la semántica del código."

#~ msgid ""
#~ "To help IDE integration, the Cairo community recommends using the\n"
#~ "[`cairo-language-server`][cairo-language-server]<!-- ignore -->. This "
#~ "tool is a set of\n"
#~ "compiler-centric utilities that speaks the [Language Server Protocol]"
#~ "[lsp]<!--\n"
#~ "ignore -->, which is a specification for IDEs and programming languages "
#~ "to\n"
#~ "communicate with each other. Different clients can use `cairo-language-"
#~ "server`, such as\n"
#~ "[the Cairo extension for Visual Studio Code][vscode-cairo]."
#~ msgstr ""
#~ "Para ayudar con la integración del IDE, la comunidad de Cairo recomienda "
#~ "el uso \n"
#~ "de [`cairo-language-server`][cairo-language-server]<!-- ignore -->. Esta "
#~ "herramienta es un conjunto de \n"
#~ "utilidades centradas en el compilador que utiliza el [Protocolo del "
#~ "Servidor de Lenguaje][lsp]<!--\n"
#~ "ignore --> que es una especificación para que los IDE y los lenguajes de "
#~ "programación se \n"
#~ "comuniquen entre sí. Diferentes clientes pueden utilizar `cairo-language-"
#~ "server`, como la \n"
#~ "extensión [de Cairo extensión para Visual Studio Code][vscode-cairo]."

#~ msgid ""
#~ "This appendix provides a reference for common types and traits used in "
#~ "contract development, along with their corresponding imports, paths, and "
#~ "usage examples."
#~ msgstr ""
#~ "Este apéndice proporciona una referencia para los tipos y traits comunes "
#~ "utilizados en el desarrollo de contratos, junto con sus correspondientes "
#~ "importaciones, rutas y ejemplos de uso."

#~ msgid ""
#~ "| Import                    | "
#~ "Path                                                  | "
#~ "Usage                                                                                                                                                                                  "
#~ "|\n"
#~ "| ------------------------- | "
#~ "----------------------------------------------------- | "
#~ "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
#~ "|\n"
#~ "| `OptionTrait`             | `std::option::"
#~ "OptionTrait`                            | `OptionTrait<T>` defines a set "
#~ "of methods required to manipulate optional "
#~ "value.                                                                                                       "
#~ "|\n"
#~ "| `ResultTrait`             | `std::result::"
#~ "ResultTrait`                            | `ResultTrait<T, E>` Type for "
#~ "Starknet contract address, a value in the range [0, 2 \\*\\* "
#~ "251).                                                                                          "
#~ "|\n"
#~ "| `ContractAddress`         | `starknet::"
#~ "ContractAddress`                           | `ContractAddress` is a type "
#~ "to represent the smart contract "
#~ "address                                                                                                                    "
#~ "|\n"
#~ "| `ContractAddressZeroable` | `starknet::contract_address::"
#~ "ContractAddressZeroable` | `ContractAddressZeroable` is the "
#~ "implementation of the trait `Zeroable` for the `ContractAddress` type. It "
#~ "is required to check whether a value of `t:ContractAddress` is zero or "
#~ "not. |\n"
#~ "| `contract_address_const`  | `starknet::"
#~ "contract_address_const`                    | The `contract_address_const!"
#~ "` it's a function that allows instantiating constant contract address "
#~ "values.                                                                              "
#~ "|\n"
#~ "| `Into`                    | `traits::Into;"
#~ "`                                       | `Into<T>` is a trait used for "
#~ "conversion between types. If there is an implementation of Into<T,S> for "
#~ "the types T and S, you can convert T into "
#~ "S.                                    |\n"
#~ "| `TryInto`                 | `traits::TryInto;"
#~ "`                                    | `TryInto<T>` is a trait used for "
#~ "conversion between types.If there is an implementation of TryInto<T,S> "
#~ "for the types T and S, you can convert T into "
#~ "S.                               |\n"
#~ "| `get_caller_address`      | `starknet::"
#~ "get_caller_address`                        | `get_caller_address()` is a "
#~ "function that returns the address of the caller of the contract. It can "
#~ "be used to identify the caller of a contract "
#~ "function.                             |\n"
#~ "| `get_contract_address`    | `starknet::info::"
#~ "get_contract_address`                | `get_contract_address()` is a "
#~ "function that returns the address of the current contract. It can be used "
#~ "to obtain the address of the contract being "
#~ "executed.                          |"
#~ msgstr ""
#~ "| Import                    | "
#~ "Path                                                  | "
#~ "Uso                                                                                                                                                                                   "
#~ "|\n"
#~ "| ------------------------- | "
#~ "----------------------------------------------------- | "
#~ "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
#~ "|\n"
#~ "| `OptionTrait`             | `std::option::"
#~ "OptionTrait`                            | `OptionTrait<T>` define un "
#~ "conjunto de métodos necesarios para manipular un valor "
#~ "opcional.                                                                                           "
#~ "|\n"
#~ "| `ResultTrait`             | `std::result::"
#~ "ResultTrait`                            | `ResultTrait<T, E>` es un tipo "
#~ "para la dirección de contrato Starknet, un valor en el rango [0, 2 \\*\\* "
#~ "251).                                                                           "
#~ "|\n"
#~ "| `ContractAddress`         | `starknet::"
#~ "ContractAddress`                           | `ContractAddress` es un tipo "
#~ "que representa la dirección del contrato "
#~ "inteligente.                                                                                                   "
#~ "|\n"
#~ "| `ContractAddressZeroable` | `starknet::contract_address::"
#~ "ContractAddressZeroable` | `ContractAddressZeroable` es la implementación "
#~ "del trait `Zeroable` para el tipo `ContractAddress`. Se utiliza para "
#~ "verificar si un valor de `t:ContractAddress` es cero o no.     |\n"
#~ "| `contract_address_const`  | `starknet::"
#~ "contract_address_const`                    | `contract_address_const!` es "
#~ "una función que permite instanciar valores de dirección de contrato "
#~ "constantes.                                                                          "
#~ "|\n"
#~ "| `Into`                    | `traits::Into;"
#~ "`                                       | `Into<T>` es un trait utilizado "
#~ "para la conversión entre tipos. Si hay una implementación de Into<T,S> "
#~ "para los tipos T y S, puedes convertir T en "
#~ "S.                                 |\n"
#~ "| `TryInto`                 | `traits::TryInto;"
#~ "`                                    | `TryInto<T>` es un rasgo utilizado "
#~ "para la conversión entre tipos. Si hay una implementación de TryInto<T,S> "
#~ "para los tipos T y S, puedes convertir T en S.                            "
#~ "|\n"
#~ "| `get_caller_address`      | `starknet::"
#~ "get_caller_address`                        | `get_caller_address()` es "
#~ "una función que devuelve la dirección del llamante del contrato. Se puede "
#~ "usar para identificar al llamante de una función del "
#~ "contrato.                  |\n"
#~ "| `get_contract_address`    | `starknet::info::"
#~ "get_contract_address`                | `get_contract_address()` es una "
#~ "función que devuelve la dirección del contrato actual. Se puede usar para "
#~ "obtener la dirección del contrato que se está ejecutando.                 "
#~ "|"

#~ msgid ""
#~ "- Disable previous Cairo 0.x extension\n"
#~ "- Install the Cairo 1 extension for proper syntax highlighting and code "
#~ "navigation.\n"
#~ "  Just follow the steps indicated [here](https://github.com/starkware-"
#~ "libs/cairo/blob/main/vscode-cairo/README.md)."
#~ msgstr ""
#~ "- Deshabilite la extensión anterior Cairo 0.x\n"
#~ "- Instale la extensión Cairo 1 para un correcto resaltado de sintaxis y "
#~ "navegación por el código.\n"
#~ "  Simplemente siga los pasos indicados [aquí](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."

#~ msgid ""
#~ "As for now, Scarb needs manual installation with the following steps:"
#~ msgstr ""
#~ "Por ahora, Scarb necesita instalación manual con los siguientes pasos:"

#~ msgid ""
#~ "- Download the release archive matching your operating system and CPU "
#~ "architecture, from [Scarb releases on GitHub](https://github.com/software-"
#~ "mansion/scarb/releases)\n"
#~ "- Extract it to a location where you would like to have Scarb installed, "
#~ "e.g. `~/scarb`\n"
#~ "- Add path to the `scarb/bin` directory to your `PATH` environment "
#~ "variable.\n"
#~ "\n"
#~ "  This depend on what shell you are using. Let’s take the example of [zsh]"
#~ "(https://ohmyz.sh/) and you have extracted Scarb to `~/scarb`:\n"
#~ "\n"
#~ "  - Open `~/.zshrc` file in your favorite editor\n"
#~ "  - Add the following line to the end of the file: `export PATH=\"$PATH:~/"
#~ "scarb/bin\"`\n"
#~ "\n"
#~ "- Verify installation by running the following command in new terminal "
#~ "session, it should print both Scarb and Cairo language versions, e.g:\n"
#~ "\n"
#~ "  ```bash\n"
#~ "  $ scarb --version\n"
#~ "  scarb 0.1.0 (289137c24 2023-03-28)\n"
#~ "  cairo: 1.0.0-alpha.6\n"
#~ "  ```"
#~ msgstr ""
#~ "- Descargue el archivo de versiones correspondiente a su sistema "
#~ "operativo y arquitectura de CPU desde [Scarb releases on GitHub](https://"
#~ "github.com/software-mansion/scarb/releases)\n"
#~ "- Extráigalo a una ubicación en la que desee tener Scarb instalado, por "
#~ "ejemplo. `~/scarb`\n"
#~ "- Añada la ruta al directorio `scarb/bin` a su variable de entorno "
#~ "`PATH`.\n"
#~ "\n"
#~ "  Esto depende del shell que esté utilizando. Tomemos el ejemplo de [zsh]"
#~ "(https://ohmyz.sh/) y has extraido Scarb a `~/scarb`:\n"
#~ "\n"
#~ "  - Abra el archivo `~/.zshrc` en su editor favorito\n"
#~ "  - Añada la siguiente línea al final del archivo: `export PATH=\"$PATH:~/"
#~ "scarb/bin\"`\n"
#~ "\n"
#~ "- Verifique la instalación ejecutando el siguiente comando en una nueva "
#~ "sesión de terminal, debería imprimir las versiones en Scarb y Cairo, por "
#~ "ejemplo:\n"
#~ "\n"
#~ "  ```bash\n"
#~ "  $ scarb --version\n"
#~ "  scarb 0.1.0 (289137c24 2023-03-28)\n"
#~ "  cairo: 1.0.0-alpha.6\n"
#~ "  ```"

#~ msgid ""
#~ "```rust\n"
#~ "{\n"
#~ "    let x = 3;\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "{\n"
#~ "    let x = 3;\n"
#~ "    x + 1\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i:usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10{\n"
#~ "            break();\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore,does_not_compile\n"
#~ "use debug::PrintTrait;\n"
#~ "fn main() {\n"
#~ "    let mut i:usize = 0;\n"
#~ "    loop {\n"
#~ "        if i > 10{\n"
#~ "            break();\n"
#~ "        }\n"
#~ "        'again!'.print();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(10);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    let mut a = ArrayTrait::new();\n"
#~ "    a.append(10);\n"
#~ "    a.append(1);\n"
#~ "    a.append(2);\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let span = array.span();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let span = array.span();\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "arr.append(1);\n"
#~ "arr.append(2);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let mut arr = ArrayTrait::<u128>::new();\n"
#~ "arr.append(1);\n"
#~ "arr.append(2);\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let mut arr1 = ArrayTrait::<u128>::new();\n"
#~ "let second_length = calculate_length(@arr1); // Calculate the current "
#~ "length of the array\n"
#~ "```"

#~ msgid ""
#~ "```rust,does_not_compile\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true,\n"
#~ "        username: 'someusername123',\n"
#~ "        email: 'someone@example.com',\n"
#~ "        sign_in_count: 1_u64,\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,does_not_compile\n"
#~ "fn main() {\n"
#~ "    let mut user1 = User {\n"
#~ "        active: true,\n"
#~ "        username: 'someusername123',\n"
#~ "        email: 'someone@example.com',\n"
#~ "        sign_in_count: 1_u64,\n"
#~ "    };\n"
#~ "    user1.email = 'anotheremail@example.com';\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username: username,\n"
#~ "        email: email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username: username,\n"
#~ "        email: email,\n"
#~ "        sign_in_count: 1,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username,\n"
#~ "        email,\n"
#~ "        sign_in_count: 1_u64,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn build_user(email: felt252, username: felt252) -> User {\n"
#~ "    User {\n"
#~ "        active: true,\n"
#~ "        username,\n"
#~ "        email,\n"
#~ "        sign_in_count: 1_u64,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rs\n"
#~ "let direction = Direction::North(());\n"
#~ "```"
#~ msgstr ""
#~ "```rs\n"
#~ "let direction = Direction::North(());\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let msg: Message = Message::Quit(());\n"
#~ "msg.process();\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let msg: Message = Message::Quit(());\n"
#~ "msg.process();\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => {\n"
#~ "            ('Lucky penny!').print();\n"
#~ "            1\n"
#~ "        },\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(_)=> 25,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn value_in_cents(coin: Coin) -> felt252 {\n"
#~ "    match coin {\n"
#~ "        Coin::Penny(_) => {\n"
#~ "            ('Lucky penny!').print();\n"
#~ "            1\n"
#~ "        },\n"
#~ "        Coin::Nickel(_) => 5,\n"
#~ "        Coin::Dime(_) => 10,\n"
#~ "        Coin::Quarter(_)=> 25,\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    enum Option<T> {\n"
#~ "        Some: T,\n"
#~ "        None: (),\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    enum Option<T> {\n"
#~ "        Some: T,\n"
#~ "        None: (),\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "In the next chapter, we’ll look at some collection data structures in "
#~ "the\n"
#~ "standard library that you can use in your neatly organized code."
#~ msgstr ""
#~ "En el próximo capítulo, veremos algunas estructuras de datos de colección "
#~ "en la\n"
#~ "biblioteca estándar que puedes utilizar en tu código bien organizado."

#~ msgid ""
#~ "Compiling the above code would error due to the `derive` macro not "
#~ "working well with generics. When using generic types is best to directly "
#~ "write the traits you want to use:"
#~ msgstr ""
#~ "La compilación del código anterior daría un error debido a que la macro "
#~ "`derive` no funciona bien con tipos genéricos. Cuando se usan tipos "
#~ "genéricos, es mejor escribir directamente los traits que se quieren "
#~ "utilizar:"

#~ msgid ""
#~ "<!-- TODO This is no longer true after in version 1.1.x and should be "
#~ "removed in the next versions -->"
#~ msgstr ""
#~ "<!-- TODO Esto ya no es cierto después de en la versión 1.1.x y debe ser "
#~ "eliminado en las próximas versiones -->"

#~ msgid ""
#~ "```rust\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of "
#~ "Drop<Wallet<T, U>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3_u128, address: 14 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Wallet<T, U> {\n"
#~ "    balance: T,\n"
#~ "    address: U,\n"
#~ "}\n"
#~ "\n"
#~ "impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of "
#~ "Drop<Wallet<T, U>>;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let w = Wallet { balance: 3_u128, address: 14 };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We add to `Wallet` struct definiton a new generic type `U` and then "
#~ "assign this type to the new field member `address`.\n"
#~ "Then we adapt the `WalletDrop` trait to work with the new generic type "
#~ "`U`. Notice that when initializing the struct inside `main` it "
#~ "automatically infers that `T` is a `u128` and `U` is a `felt252` and "
#~ "since they are both droppable, `Wallet` is droppable as well!"
#~ msgstr ""
#~ "Agregamos a la definición de la estructura `Wallet` un nuevo tipo "
#~ "genérico `U` y luego asignamos este tipo al nuevo miembro del campo "
#~ "`address`. Luego adaptamos el trait `WalletDrop` para que funcione con el "
#~ "nuevo tipo genérico `U`. ¡Observa que al inicializar la estructura dentro "
#~ "de `main`, automáticamente infiere que `T` es un `u128` y `U` es un "
#~ "`felt252` y como ambos son droppable, `Wallet` también lo es!"

#~ msgid ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some(T),\n"
#~ "    None,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "enum Option<T> {\n"
#~ "    Some(T),\n"
#~ "    None,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64;\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn area(self: @Rectangle) -> u64 {\n"
#~ "        *self.width * *self.height\n"
#~ "    }\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width > *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7_u64,\n"
#~ "            width: 8_u64,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1_u64,\n"
#~ "            width: 5_u64,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7_u64,\n"
#~ "            width: 8_u64,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1_u64,\n"
#~ "            width: 5_u64,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        // --snip--\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7_u64,\n"
#~ "            width: 8_u64,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1_u64,\n"
#~ "            width: 5_u64,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::Rectangle;\n"
#~ "    use super::RectangleTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn larger_can_hold_smaller() {\n"
#~ "        // --snip--\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn smaller_cannot_hold_larger() {\n"
#~ "        let larger = Rectangle {\n"
#~ "            height: 7_u64,\n"
#~ "            width: 8_u64,\n"
#~ "        };\n"
#~ "        let smaller = Rectangle {\n"
#~ "            height: 1_u64,\n"
#~ "            width: 5_u64,\n"
#~ "        };\n"
#~ "\n"
#~ "        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl RectangleImpl of RectangleTrait {\n"
#~ "    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
#~ "        *self.width < *other.width & *self.height > *other.height\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1_u64 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value, }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// --snip--\n"
#~ "impl GuessImpl of GuessTrait {\n"
#~ "    fn new(value: u64) -> Guess {\n"
#~ "        if value < 1_u64 {\n"
#~ "            let mut data = ArrayTrait::new();\n"
#~ "            data.append('Guess must be >= 1 and <= 100');\n"
#~ "            panic(data);\n"
#~ "        }\n"
#~ "\n"
#~ "        Guess { value, }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "if value < 1_u64 {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be <= 100');\n"
#~ "    panic(data);\n"
#~ "} else if value > 100_u64 {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be >= 1');\n"
#~ "    panic(data);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "if value < 1_u64 {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be <= 100');\n"
#~ "    panic(data);\n"
#~ "} else if value > 100_u64 {\n"
#~ "    let mut data = ArrayTrait::new();\n"
#~ "    data.append('Guess must be >= 1');\n"
#~ "    panic(data);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn test_function_2() {\n"
#~ "    let number: felt252 = 258_felt252;\n"
#~ "    match do_something_with_parse_u8(number) {\n"
#~ "        Result::Ok(value) => value.print(),\n"
#~ "        Result::Err(e) => e.print()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[test]\n"
#~ "fn test_function_2() {\n"
#~ "    let number: felt252 = 258_felt252;\n"
#~ "    match do_something_with_parse_u8(number) {\n"
#~ "        Result::Ok(value) => value.print(),\n"
#~ "        Result::Err(e) => e.print()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
#~ "deeper into this in the next sections."
#~ msgstr ""
#~ "Los contratos inteligentes en Starknet se denotan por el atributo "
#~ "`#[contract]`. Profundizaremos más en esto en las próximas secciones."

#~ msgid ""
#~ "```rust\n"
#~ "//**** Specify interface here ****//\n"
#~ "\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(\n"
#~ "        _contract_address: ContractAddress\n"
#~ "    ) -> felt252 {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }."
#~ "transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//**** Specify interface here ****//\n"
#~ "\n"
#~ "#[contract]\n"
#~ "mod dispatcher {\n"
#~ "    use super::IERC20DispatcherTrait;\n"
#~ "    use super::IERC20Dispatcher;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "\n"
#~ "    #[view]\n"
#~ "    fn token_name(\n"
#~ "        _contract_address: ContractAddress\n"
#~ "    ) -> felt252 {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external]\n"
#~ "    fn transfer_token(\n"
#~ "        _contract_address: ContractAddress, recipient: ContractAddress, "
#~ "amount: u256\n"
#~ "    ) -> bool {\n"
#~ "        IERC20Dispatcher {contract_address: _contract_address }."
#~ "transfer(recipient, amount)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<span class=\"caption\">Listing 9-4: An expanded form of the IERC20 "
#~ "trait</span>"
#~ msgstr ""
#~ "<span class=\"caption\">Listado 9-4: Una forma expandida del trait "
#~ "IERC20</span>"

#~ msgid "## Appendix A - Useful Development Tools"
#~ msgstr "## Apéndice A - Herramientas de Desarrollo Útiles"
