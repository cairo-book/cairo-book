msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-05-11 10:43+0100\n"
"Last-Translator: dami <pinonesdamian@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3\n"

#: src/SUMMARY.md:1
msgid "The Cairo Programming Language"
msgstr "El lenguaje de programación Cairo"

#: src/SUMMARY.md:4
msgid "Foreword"
msgstr "Prólogo"

#: src/SUMMARY.md:5
msgid "Introduction"
msgstr "Introducción"

#: src/SUMMARY.md:7
msgid "Getting Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:11
msgid "Installation"
msgstr "Instalación"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr "¡Hola, mundo!"

#: src/SUMMARY.md:13
msgid "Hello, Scarb!"
msgstr "¡Hola, Scarb!"

#: src/SUMMARY.md:15
msgid "Common Programming Concepts"
msgstr "Conceptos comunes de programación"

#: src/SUMMARY.md:18
msgid "Variables and Mutability"
msgstr "Variables y mutabilidad"

#: src/SUMMARY.md:19
msgid "Data Types"
msgstr "Tipos de datos"

#: src/SUMMARY.md:20
msgid "Functions"
msgstr "Funciones"

#: src/SUMMARY.md:21
msgid "Comments"
msgstr "Comentarios"

#: src/SUMMARY.md:22
msgid "Control Flow"
msgstr "Flujo de control"

#: src/SUMMARY.md:23
msgid "Common Collections"
msgstr "Colecciones Comunes"

#: src/SUMMARY.md:25
msgid "Understanding Ownership"
msgstr "Comprender Ownership"

#: src/SUMMARY.md:28
msgid "What is Ownership?"
msgstr "¿Qué es Ownership?"

#: src/SUMMARY.md:29
msgid "References and Snapshots"
msgstr "Referencias y Snapshots"

#: src/SUMMARY.md:31
msgid "Using Structs to Structure Related Data"
msgstr "Uso de estructuras para estructurar datos relacionados"

#: src/SUMMARY.md:34
msgid "Defining and Instantiating Structs"
msgstr "Definición e instanciación de estructuras"

#: src/SUMMARY.md:35
msgid "An Example Program Using Structs"
msgstr "Un programa de ejemplo usando estructuras"

#: src/SUMMARY.md:36
msgid "Method Syntax"
msgstr "Sintaxis de métodos"

#: src/SUMMARY.md:38
msgid "Enums and Pattern Matching"
msgstr "Enums y Concordancia de Patrones"

#: src/SUMMARY.md:38
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md:42
msgid "The Match Control Flow Construct"
msgstr "La construcción del flujo de control de coincidencias"

#: src/SUMMARY.md:44
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Gestionando Proyectos Cairo con Paquetes, Crates y Módulos"

#: src/SUMMARY.md:48
msgid "Packages and Crates"
msgstr "Paquetes y Crates"

#: src/SUMMARY.md:50
msgid "Defining Modules to Control Scope"
msgstr "Definición de módulos para controlar el alcance"

#: src/SUMMARY.md:51
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Rutas para referirse a un elemento en el Arbol de Módulos"

#: src/SUMMARY.md:52
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "Introducción de Rutas con la Palabra Clave 'use'"

#: src/SUMMARY.md:53
msgid "Separating Modules into Different Files"
msgstr "Separación de Módulos en Distintos Ficheros"

#: src/SUMMARY.md:56
msgid "Generic Types"
msgstr "Tipos Genéricos"

#: src/SUMMARY.md:58
msgid "Generic Functions"
msgstr "Funciones Genéricas"

#: src/SUMMARY.md:59
msgid "Traits in Cairo"
msgstr "Traits en Cairo"

#: src/SUMMARY.md:61
msgid "Error Handling"
msgstr "Gestión de Errores"

#: src/SUMMARY.md:65
msgid "Recoverable Errors with Result"
msgstr "Errores Recuperables con Resultados"

#: src/SUMMARY.md:67
msgid "Testing Cairo Programs"
msgstr "Test de Programas en Cairo"

#: src/SUMMARY.md:71
msgid "How To Write Tests"
msgstr "Cómo Escribir Tests"

#: src/SUMMARY.md:72
msgid "Testing Organization"
msgstr "Organización de Testing"

#: src/SUMMARY.md:76
msgid "Starknet Smart Contracts"
msgstr "Starknet Smart Contracts"

#: src/SUMMARY.md:77
msgid "ABIs and Cross-contract Interactions"
msgstr "ABIs e Interacciones entre Contratos Multicapa"

#: src/SUMMARY.md:78
msgid "ABIs and Interfaces"
msgstr "ABIs e interfaces"

#: src/SUMMARY.md:79
msgid "Contract Dispatchers, Library Dispachers and system calls"
msgstr "Despachadores de contratos, despachadores de librerías y llamadas del sistema"

#: src/SUMMARY.md:81
msgid "Appendix"
msgstr "Apéndice"

#: src/SUMMARY.md:82
msgid "A - Useful Development Tools"
msgstr "A - Herramientas Útiles de Desarrollo"

#: src/title-page.md:1
msgid "# The Cairo Programming Language"
msgstr "El Lenguaje de Programación Cairo"

#: src/title-page.md:3
msgid ""
"by the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-"
"book.github.io). Special thanks to [Starkware](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager.online/) for "
"supporting the creation of this book."
msgstr ""
"creado por la Comunidad Cairo y sus [colaboradores](https://github.com/cairo-book/"
"cairo-book.github.io). Un agradecimiento especial a [Starkware](https://starkware."
"co/) a través de [OnlyDust](https://www.onlydust.xyz/), y [Voyager](https://voyager."
"online/) por apoyar la creación de este libro."

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using Cairo v1.0.0-alpha.7 (released "
"2023-04-13). See the “Installation” section of Chapter 1 to install or update Cairo."
msgstr ""
"Esta versión del texto asume que estás usando Cairo v1.0.0-alpha.7 (publicado el "
"2023-04-13). Consulte la sección \"Instalación\" del Capítulo 1 para instalar o "
"actualizar Cairo."

#: src/ch00-01-foreword.md:1
msgid "# Foreword"
msgstr "# Prólogo"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as Cairo "
"0.x was a low-level language that did not entirely abstract the underlying "
"cryptographic primitives required to build a proof for the execution of a program."
msgstr ""
"En 2020, StarkWare lanzó Cairo 0, un lenguaje de programación Turing completo que "
"admite cálculo verificable. Cairo comenzó como un lenguaje ensamblador y "
"gradualmente se volvió más expresivo. La curva de aprendizaje fue inicialmente "
"pronunciada, ya que Cairo 0.x era un lenguaje de bajo nivel que no abstraía por "
"completo las primitivas criptográficas subyacentes requeridas para construir una "
"prueba para la ejecución de un programa."

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably improved, "
"abstracting away the underlying immutable memory model of the Cairo architecture "
"where possible. Strongly inspired by Rust, Cairo 1 has been built to help you "
"create provable programs without specific knowledge of its underlying architecture "
"so that you can focus on the program itself, increasing the overall security of "
"Cairo programs. Powered by a Rust VM, the execution of Cairo programs is now "
"_blazingly_ fast, allowing you to build an extensive test suite without "
"compromising on performance."
msgstr ""
"Con el lanzamiento de Cairo 1, la experiencia del desarrollador ha mejorado "
"considerablemente, abstrayendo el modelo de memoria inmutable subyacente de la "
"arquitectura de Cairo siempre que sea posible. Inspirado en Rust, Cairo 1 ha sido "
"construido para ayudarte a crear programas comprobables sin conocimientos "
"específicos de su arquitectura subyacente, para que puedas concentrarte en el "
"programa en sí, aumentando la seguridad general de los programas de Cairo. "
"Alimentado por una máquina virtual Rust, la ejecución de los programas de Cairo es "
"ahora _extremadamente_ rápida, lo que te permite construir una amplia suite de "
"pruebas sin comprometer el rendimiento."

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the Cairo "
"programming language to code their smart contracts. This allows the Starknet OS to "
"generate execution traces for transactions to be proved by a prover, which is then "
"verified on Ethereum L1 prior to updating the state root of Starknet."
msgstr ""
"Los desarrolladores de blockchain que desean implementar contratos en Starknet "
"utilizarán el lenguaje de programación Cairo para codificar sus contratos "
"inteligentes. Esto permite al sistema operativo Starknet generar trazas de "
"ejecución para transacciones que deben ser demostradas por un probador, que luego "
"se verifica en Ethereum L1 antes de actualizar la raíz del estado de Starknet."

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit from "
"being proved on one computer and verified on other machines with lower hardware "
"requirements."
msgstr ""
"Sin embargo, Cairo no es solo para desarrolladores de blockchain. Como lenguaje de "
"programación de propósito general, se puede utilizar para cualquier cálculo que se "
"beneficie de ser demostrado en una computadora y verificado en otras máquinas con "
"requisitos de hardware más bajos."

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of programming "
"concepts. It is a friendly and approachable text intended to help you level up your "
"knowledge of Cairo, but also help you develop your programming skills in general. "
"So, dive in and get ready to learn all there is to know about Cairo!"
msgstr ""
"Este libro está diseñado para desarrolladores con una comprensión básica de los "
"conceptos de programación. Es un texto amigable y accesible destinado a ayudarte a "
"mejorar tus conocimientos de Cairo, pero también a ayudarte a desarrollar tus "
"habilidades de programación en general. ¡Así que sumérgete y prepárate para "
"aprender todo lo que hay que saber sobre Cairo!"

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr "—  La comunidad de Cairo"

#: src/ch00-00-introduction.md:1
msgid "# Introduction"
msgstr "# Introducción"

#: src/ch00-00-introduction.md:3
msgid "## What is Cairo?"
msgstr "## ¿Qué es Cairo?"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. The "
"unique aspect of this processor is that it was not created for the physical "
"constraints of our world but for cryptographic ones, making it capable of "
"efficiently proving the execution of any program running on it. This means that you "
"can perform time consuming operations on a machine you don't trust, and check the "
"result very quickly on a cheaper machine.\n"
"While Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo 1 "
"is a more high level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of CASM. The "
"point of Sierra is to ensure your CASM will always be provable, even when the "
"computation fails."
msgstr ""
"Cairo es un lenguaje de programación diseñado para una CPU virtual del mismo "
"nombre. El aspecto único de este procesador es que no fue creado para las "
"restricciones físicas de nuestro mundo, sino para las criptográficas, lo que lo "
"hace capaz de probar eficientemente la ejecución de cualquier programa que se "
"ejecute en él. Esto significa que puedes realizar operaciones que consumen mucho "
"tiempo en una máquina en la que no confías, y comprobar el resultado muy "
"rápidamente en una máquina más barata.\n"
"Mientras que Cairo 0 solía compilarse directamente a CASM, el ensamblador de CPU de "
"Cairo, Cairo 1 es un lenguaje de más alto nivel. Primero compila a Sierra, una "
"representación intermedia de Cairo que compilará más tarde a un subconjunto seguro "
"de CASM. El objetivo de Sierra es garantizar que tu CASM sea siempre demostrable, "
"incluso cuando falle el cálculo."

#: src/ch00-00-introduction.md:8
msgid "## What can you do with it?"
msgstr "## ¿Qué puedes hacer con Cairo?"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One major "
"usecase is Starknet, a solution to Ethereum scaling. Ethereum is a decentralized "
"blockchain platform that enables the creation of decentralized applications where "
"every single interaction between a user and a d-app is verified by all the "
"participants. Starknet is a Layer 2 built on top of Ethereum. Instead of having all "
"the participants of the network to verify all user interactions, only one node, "
"called the prover, execute the programs and generate proofs that the computations "
"were done correctly.These proofs are then verified by an Ethereum smart contract, "
"requiring significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and reduced "
"transaction costs but preserving Ethereum security."
msgstr ""
"Cairo te permite calcular valores confiables en máquinas no confiables. Un caso de "
"uso importante es Starknet, una solución para la escalabilidad de Ethereum. "
"Ethereum es una plataforma blockchain descentralizada que permite la creación de "
"aplicaciones descentralizadas donde cada interacción entre un usuario y una d-app "
"es verificada por todos los participantes. Starknet es una capa 2 construida sobre "
"Ethereum. En lugar de que todos los participantes de la red verifiquen todas las "
"interacciones del usuario, solo un nodo, llamado el probador, ejecuta los programas "
"y genera pruebas de que los cálculos se realizaron correctamente. Estas pruebas "
"luego son verificadas por un contrato inteligente de Ethereum, lo que requiere "
"significativamente menos potencia de cálculo en comparación con la ejecución de las "
"interacciones mismas. Este enfoque permite un mayor rendimiento y una reducción en "
"los costos de transacción, pero preservando la seguridad de Ethereum."

#: src/ch00-00-introduction.md:12
msgid "## What are the differences with other programming languages?"
msgstr "## ¿Cuáles son las diferencias con otros lenguajes de programación?"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially when it "
"comes to overhead costs and its primary advantages. Your program can be executed in "
"two different ways:"
msgstr ""
"Cairo es bastante diferente de los lenguajes de programación tradicionales, "
"especialmente en cuanto a los costos generales y sus ventajas principales. Tu "
"programa se puede ejecutar de dos formas diferentes:"

#: src/ch00-00-introduction.md:16
msgid ""
"- When executed by the prover, it is similar to any other language. Because Cairo "
"is virtualized, and because the operations were not specifically designed for "
"maximum efficiency, this can lead to some performance overhead but it is not the "
"most relevant part to optimize.\n"
"\n"
"- When the generated proof is verified by a verifier, it is a bit different. This "
"has to be as cheap as possible since it could potentially be verified on many very "
"small machines. Fortunately verifying is faster than computing and Cairo has some "
"unique advantages to improve it even more. A notable one is non-determinism. This "
"is a topic you will cover in more detail later in this book, but the idea is that "
"you can theoretically use a different algorithm for verifying than for computing. "
"Currently, writing custom non-deterministic code is not supported for the "
"developers, but the standard library leverages non-determinism for improved "
"performance. For example sorting an array in Cairo costs the same price than "
"copying it. Because the verifier doesn't sort the array, it just checks that it is "
"sorted, which is cheaper."
msgstr ""
"- Cuando se ejecuta por el probador, es similar a cualquier otro lenguaje. Debido a "
"que Cairo está virtualizado y porque las operaciones no se diseñaron "
"específicamente para la máxima eficiencia, esto puede llevar a una sobrecarga de "
"rendimiento, pero no es la parte más relevante para optimizar.\n"
"\n"
"- Cuando el probador genera la prueba, es un poco diferente. Esto tiene que ser lo "
"más barato posible, ya que potencialmente se podría verificar en muchas máquinas "
"muy pequeñas. Afortunadamente, verificar es más rápido que computar y Cairo tiene "
"algunas ventajas únicas para mejorar aún más. Uno notable es la no determinación. "
"Este es un tema que cubrirás con más detalle más adelante en este libro, pero la "
"idea es que teóricamente puedes usar un algoritmo diferente para verificar que para "
"calcular. Actualmente, escribir código personalizado no determinista no está "
"soportado para los desarrolladores, pero la biblioteca estándar aprovecha la no "
"determinación para mejorar el rendimiento. Por ejemplo, ordenar una matriz en Cairo "
"cuesta lo mismo que copiarla. Debido a que el verificador no ordena la matriz, "
"simplemente verifica que está ordenada, lo que es más barato."

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, memory "
"access is immutable, meaning that once a value is written to memory, it cannot be "
"changed. Cairo 1 provides abstractions that help developers work with these "
"constraints, but it does not fully simulate mutability. Therefore, developers must "
"think carefully about how they manage memory and data structures in their programs "
"to optimize performance."
msgstr ""
"Otro aspecto que diferencia al lenguaje es su modelo de memoria. En Cairo, el "
"acceso a la memoria es inmutable, lo que significa que una vez que se escribe un "
"valor en la memoria, no se puede cambiar. Cairo 1 proporciona abstracciones que "
"ayudan a los desarrolladores a trabajar con estas limitaciones, pero no simula "
"completamente la mutabilidad. Por lo tanto, los desarrolladores deben pensar "
"cuidadosamente en cómo administran la memoria y las estructuras de datos en sus "
"programas para optimizar el rendimiento."

#: src/ch00-00-introduction.md:22
msgid "## References"
msgstr "## Referencias"

#: src/ch00-00-introduction.md:24
msgid ""
"- Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>\n"
"- Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>\n"
"- State of non determinism: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"
msgstr ""
"- Arquitectura del CPU de Cairo: <https://eprint.iacr.org/2021/1063>\n"
"- Cairo, Sierra y Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>\n"
"- Estado no determinista: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"

#: src/ch01-01-installation.md:1
msgid "# Installation"
msgstr "# Instalación"

#: src/ch01-01-installation.md:3
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using cairo "
"repository or with an installation script. You’ll need an internet connection for "
"the download."
msgstr ""
"El primer paso es instalar Cairo. Descargaremos Cairo manualmente, utilizando el "
"repositorio de Cairo o un script de instalación. Necesitará una conexión a Internet "
"para la descarga."

#: src/ch01-01-installation.md:5
msgid "### Prerequisites"
msgstr "### Requisitos previos"

#: src/ch01-01-installation.md:7
msgid "First you will need to have Rust and Git installed."
msgstr "Primero deberá tener Rust y Git instalados."

#: src/ch01-01-installation.md:9
msgid ""
"```bash\n"
"# Install stable Rust\n"
"rustup override set stable && rustup update\n"
"```"
msgstr ""
"```bash\n"
"# Install stable Rust\n"
"rustup override set stable && rustup update\n"
"```"

#: src/ch01-01-installation.md:14
msgid "Install [Git](https://git-scm.com/)."
msgstr "Install [Git](https://git-scm.com/)."

#: src/ch01-01-installation.md:16
msgid ""
"## Installing Cairo with a Script ([Installer](https://github.com/franalgaba/cairo-"
"installer) by [Fran](https://github.com/franalgaba))"
msgstr ""
"## Instalando Cairo con un Script ([Instalador](https://github.com/franalgaba/cairo-"
"installer) por [Fran](https://github.com/franalgaba))"

#: src/ch01-01-installation.md:18
msgid "### Install"
msgstr "### Instalación"

#: src/ch01-01-installation.md:20
msgid ""
"If you wish to install a specific release of Cairo rather than the latest head, set "
"the `CAIRO_GIT_TAG` environment variable (e.g. `export CAIRO_GIT_TAG=v1.0.0-"
"alpha.6`)."
msgstr ""
"Si deseas instalar una versión específica de Cairo en lugar de la última versión, "
"debes establecer la variable de entorno `CAIRO_GIT_TAG` (por ejemplo,`export "
"CAIRO_GIT_TAG=v1.0.0-alpha.6`)."

#: src/ch01-01-installation.md:22
msgid ""
"```bash \n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer "
"| bash\n"
"```"
msgstr ""
"```bash \n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer "
"| bash\n"
"```"

#: src/ch01-01-installation.md:26
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-environment-for-"
"cairo) to set up your shell environment."
msgstr ""
"Tras la instalación, sigue [estas instrucciones](#set-up-your-shell-environment-for-"
"cairo) para configurar tu entorno shell."

#: src/ch01-01-installation.md:28
msgid "### Update"
msgstr "### Actualización"

#: src/ch01-01-installation.md:30
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer "
"| bash\n"
"```"
msgstr ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer "
"| bash\n"
"```"

#: src/ch01-01-installation.md:35
msgid "### Uninstall"
msgstr "### Desinstalación"

#: src/ch01-01-installation.md:37
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, just "
"remove it:"
msgstr ""
"Cairo se instala dentro de `$CAIRO_ROOT` (por defecto: ~/.cairo). Para "
"desinstalarlo, basta con eliminarlo:"

#: src/ch01-01-installation.md:39
msgid ""
"```bash\n"
"rm -fr ~/.cairo\n"
"```"
msgstr ""
"```bash\n"
"rm -fr ~/.cairo\n"
"```"

#: src/ch01-01-installation.md:43
msgid "then remove these three lines from .bashrc:"
msgstr "luego elimina estas tres líneas de .bashrc:"

#: src/ch01-01-installation.md:45
msgid ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"
msgstr ""
"```bash\n"
"export PATH=\"$HOME/.cairo/target/release:$PATH\"\n"
"```"

#: src/ch01-01-installation.md:49
msgid "and finally, restart your shell:"
msgstr "y, por último, reinicia tu shell:"

#: src/ch01-01-installation.md:51
msgid ""
"```bash\n"
"exec $SHELL\n"
"```"
msgstr ""
"```bash\n"
"exec $SHELL\n"
"```"

#: src/ch01-01-installation.md:55
msgid "### Set up your shell environment for Cairo"
msgstr "### Configure su entorno shell para Cairo"

#: src/ch01-01-installation.md:57
msgid ""
"* Define environment variable `CAIRO_ROOT` to point to the path where\n"
"  Cairo will store its data. `$HOME/.cairo` is the default.\n"
"  If you installed Cairo via Git checkout, we recommend\n"
"  to set it to the same location as where you cloned it.\n"
"* Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""
"* Define la variable de entorno `CAIRO_ROOT` para apuntar a la ruta donde\n"
"  Cairo almacenará sus datos. Por defecto es `$HOME/.cairo`.\n"
"  Si instaló Cairo a través de Git checkout, recomendamos\n"
"  la misma ubicación donde lo clonaste.\n"
"* Añade los ejecutables de `cairo-*` a tu `PATH` si no están ya allí"

#: src/ch01-01-installation.md:63
msgid ""
"The below setup should work for the vast majority of users for common use cases."
msgstr ""
"La siguiente configuración debería funcionar para la gran mayoría de usuarios en "
"casos de uso comunes."

#: src/ch01-01-installation.md:65
msgid ""
"  - For **bash**:\n"
"\n"
"    Stock Bash startup files vary widely between distributions in which of them "
"source\n"
"    which, under what circumstances, in what order and what additional "
"configuration they perform.\n"
"    As such, the most reliable way to get Cairo in all environments is to append "
"Cairo\n"
"    configuration commands to both `.bashrc` (for interactive shells)\n"
"    and the profile file that Bash would use (for login shells).\n"
"\n"
"    First, add the commands to `~/.bashrc` by running the following in your "
"terminal:\n"
"\n"
"    ~~~ bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.bashrc\n"
"    ~~~\n"
"\n"
"    Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add the "
"commands there as well.\n"
"    If you have none of these, add them to `~/.profile`.\n"
"\n"
"    * to add to `~/.profile`:\n"
"      ~~~ bash\n"
"      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
"      echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.profile\n"
"      ~~~\n"
"\n"
"    * to add to `~/.bash_profile`:\n"
"      ~~~ bash\n"
"      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"      echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.bash_profile\n"
"      ~~~\n"
"\n"
"  - For **Zsh**:\n"
"    ~~~ zsh\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.zshrc\n"
"    ~~~\n"
"\n"
"    If you wish to get Cairo in non-interactive login shells as well, also add the "
"commands to `~/.zprofile` or `~/.zlogin`.\n"
"\n"
"  - For **Fish shell**:\n"
"\n"
"    If you have Fish 3.2.0 or newer, execute this interactively:\n"
"\n"
"    ~~~ fish\n"
"    set -Ux CAIRO_ROOT $HOME/.cairo\n"
"    fish_add_path $CAIRO_ROOT/target/release\n"
"    ~~~\n"
"\n"
"    Otherwise, execute the snippet below:\n"
"\n"
"    ~~~ fish\n"
"    set -Ux CAIRO_ROOT $HOME/.cairo\n"
"    set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
"    ~~~"
msgstr ""
"  - Para **bash**:\n"
"  \n"
"  Los archivos de inicio de Bash predeterminados varían ampliamente entre las "
"distribuciones \n"
"  , en cuanto a la fuente de ellos, las circunstancias, el orden y la configuración "
"adicional que realizan. \n"
"  Como tal, la forma más confiable de obtener Cairo en todos los entornos es "
"agregar los comandos\n"
"  de configuración de Cairo tanto en `.bashrc` (para shells interactivos) como en "
"el archivo de perfil \n"
"  que Bash utilizaría (para shells de inicio de sesión).\n"
"\n"
"En primer lugar, agrega los comandos a `~/.bashrc` ejecutando lo siguiente en tu "
"terminal:\n"
"\n"
"    ~~~ bash\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.bashrc\n"
"    ~~~\n"
"\n"
"    Entonces, si tiene `~/.profile`, `~/.bash_profile` o `~/.bash_login`, añada "
"también allí los comandos.\n"
"    Si no tienes ninguno de estos, añádelos a `~/.profile`.\n"
"\n"
"    * Para añadir a `~/.profile`:\n"
"      ~~~ bash\n"
"      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile\n"
"      echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.profile\n"
"      ~~~\n"
"\n"
"    * Para añadir a `~/.bash_profile`:\n"
"      ~~~ bash\n"
"      echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile\n"
"      echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.bash_profile\n"
"      ~~~\n"
"\n"
"  - Para **Zsh**:\n"
"    ~~~ zsh\n"
"    echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc\n"
"    echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"' >> ~/.zshrc\n"
"    ~~~\n"
"\n"
"    Si también desea obtener Cairo en shells de inicio de sesión no interactivos, "
"añada también los comandos a `~/.zprofile` or `~/.zlogin`.\n"
"\n"
"  - Para **Fish shell**:\n"
"\n"
"    Si tiene Fish 3.2.0 o posterior, ejecútelo interactivamente:\n"
"\n"
"    ~~~ fish\n"
"    set -Ux CAIRO_ROOT $HOME/.cairo\n"
"    fish_add_path $CAIRO_ROOT/target/release\n"
"    ~~~\n"
"\n"
"    De lo contrario, ejecute el siguiente fragmento:\n"
"\n"
"    ~~~ fish\n"
"    set -Ux CAIRO_ROOT $HOME/.cairo\n"
"    set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths\n"
"    ~~~"

#: src/ch01-01-installation.md:119
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which\n"
"provides alternative shell completions for many command line tools with an\n"
"IDE-like popup interface in the terminal window.\n"
"(Note that their completions are independent from Cairo's codebase\n"
"so they might be slightly out of sync for bleeding-edge interface changes.)"
msgstr ""
"En MacOS, es posible que también desee instalar [Fig](https://fig.io/) \n"
"que proporciona complementos de shell alternativos para muchas herramientas \n"
"de línea de comandos con una interfaz emergente similar a IDE en la ventana de \n"
"terminal.\n"
"(Tenga en cuenta que sus complementos son independientes del código base de \n"
"Cairo por lo que pueden estar ligeramente desincronizadas para cambios de\n"
" interfaz de última generación)."

#: src/ch01-01-installation.md:125
msgid "### Restart your shell"
msgstr "### Reinicie su shell"

#: src/ch01-01-installation.md:127
msgid "for the `PATH` changes to take effect."
msgstr "para que los cambios en el `PATH` surtan efecto."

#: src/ch01-01-installation.md:129
msgid ""
"```sh\n"
"  exec \"$SHELL\"\n"
"  ```"
msgstr ""
"```sh\n"
"  exec \"$SHELL\"\n"
"  ```"

#: src/ch01-01-installation.md:133
msgid ""
"## Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-template) "
"by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"## Instalando Cairo Manualmente ([Guía](https://github.com/auditless/cairo-"
"template) por [Abdel](https://github.com/abdelhamidbakhta))"

#: src/ch01-01-installation.md:135
msgid "### Step 1: Install Cairo 1.0"
msgstr "### Paso 1: Instalar Cairo 1.0"

#: src/ch01-01-installation.md:137
msgid ""
"If you are using an x86 Linux system and can use the release binary, download Cairo "
"here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"Si utiliza un sistema Linux x86 y puede utilizar el binario de lanzamiento, "
"descargue Cairo aquí:<https://github.com/starkware-libs/cairo/releases>."

#: src/ch01-01-installation.md:139
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""
"Para todos los demás, recomendamos compilar Cairo desde el código fuente de la "
"siguiente manera:"

#: src/ch01-01-installation.md:141
msgid ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v1.0.0-alpha.6\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"
msgstr ""
"```bash\n"
"# Start by defining environment variable CAIRO_ROOT\n"
"export CAIRO_ROOT=\"${HOME}/.cairo\"\n"
"\n"
"# Create .cairo folder if it doesn't exist yet\n"
"mkdir $CAIRO_ROOT\n"
"\n"
"# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
"cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git .\n"
"\n"
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
"git fetch --all --tags\n"
"# View tags (you can also do this in the cairo compiler repository)\n"
"git describe --tags `git rev-list --tags`\n"
"# Checkout the version you want\n"
"git checkout tags/v1.0.0-alpha.6\n"
"\n"
"# Generate release binaries\n"
"cargo build --all --release\n"
"```"

#: src/ch01-01-installation.md:163
msgid ". "
msgstr ". "

#: src/ch01-01-installation.md:165
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**NOTA: Mantener Cairo actualizado**"

#: src/ch01-01-installation.md:167
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to do\n"
"is pull the latest changes and rebuild as follows:"
msgstr ""
"Ahora que tu compilador Cairo está en un repositorio clonado, todo lo que necesitas "
"hacer\n"
"es extraer los últimos cambios y reconstruir como sigue:"

#: src/ch01-01-installation.md:170
msgid ""
"```bash\n"
"cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
"```"
msgstr ""
"```bash\n"
"cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release\n"
"```"

#: src/ch01-01-installation.md:174
msgid "### Step 2: Add Cairo 1.0 executables to your path"
msgstr "### Paso 2: Añade los ejecutables de Cairo 1.0 a tu ruta"

#: src/ch01-01-installation.md:176
msgid ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"
msgstr ""
"```bash\n"
"export PATH=\"$CAIRO_ROOT/target/release:$PATH\"\n"
"```"

#: src/ch01-01-installation.md:180
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path accordingly.**"
msgstr ""
"**NOTA: Si instala desde un binario Linux, adapte la ruta de destino en consecuencia"

#: src/ch01-01-installation.md:182
msgid "### Step 3: Setup Language Server"
msgstr "### Paso 3: Configurar el servidor de idiomas"

#: src/ch01-01-installation.md:184
msgid "#### VS Code Extension"
msgstr "#### Extensión VS Code"

#: src/ch01-01-installation.md:186
msgid ""
"- Disable previous Cairo 0.x extension\n"
"- Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation.\n"
"Just follow the steps indicated [here](https://github.com/starkware-libs/cairo/blob/"
"main/vscode-cairo/README.md)."
msgstr ""
"- Deshabilite la extensión anterior Cairo 0.x\n"
"- Instale la extensión Cairo 1 para un correcto resaltado de sintaxis y navegación "
"por el código.\n"
"Simplemente siga los pasos indicados [aquí](https://github.com/starkware-libs/cairo/"
"blob/main/vscode-cairo/README.md)."

#: src/ch01-01-installation.md:190
msgid "#### Cairo Language Server"
msgstr "#### Servidor de Lenguaje de Cairo"

#: src/ch01-01-installation.md:192
msgid ""
"From [Step 1](#step-1-install-cairo-10-guide-by-abdel), the `cairo-language-server` "
"binary should be built and executing this command will copy its path into your "
"clipboard."
msgstr ""
"Desde [Paso 1](#step-1-install-cairo-10-guide-by-abdel), el binario `cairo-language-"
"server` debe ser construido y ejecutando este comando se copiará su ruta en el "
"portapapeles."

#: src/ch01-01-installation.md:194
msgid ""
"```bash\n"
"which cairo-language-server | pbcopy\n"
"```"
msgstr ""
"```bash\n"
"which cairo-language-server | pbcopy\n"
"```"

#: src/ch01-01-installation.md:198
msgid ""
"Update the `languageServerPath` of the Cairo 1.0 extension by pasting the path."
msgstr "Actualiza el `languageServerPath` de la extensión Cairo 1.0 pegando la ruta."

#: src/ch01-02-hello-world.md:1
msgid "## Hello, World"
msgstr "## Hola, Mundo"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo, it’s time to write your first Cairo program.\n"
"It’s traditional when learning a new language to write a little program that\n"
"prints the text `Hello, world!` to the screen, so we’ll do the same here!"
msgstr ""
"Ahora que has instalado Cairo, es hora de escribir tu primer programa Cairo.\n"
"Es tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa "
"que\n"
"imprima el texto `¡Hola, mundo!` en la pantalla, ¡así que haremos lo mismo aquí!"

#: src/ch01-02-hello-world.md:7
msgid ""
"> Note: This book assumes basic familiarity with the command line. Cairo makes\n"
"> no specific demands about your editing or tooling or where your code lives, so\n"
"> if you prefer to use an integrated development environment (IDE) instead of\n"
"> the command line, feel free to use your favorite IDE. The Cairo team has "
"developed\n"
"> a VSCode extension for the Cairo language that you can use to get the features "
"from\n"
"> the language server and code highlighting. See [Appendix A][devtools]\n"
"> for more details."
msgstr ""
"> Nota: Este libro asume una familiaridad básica con la línea de comandos. Cairo no "
"hace\n"
"> ninguna demanda específica sobre su edición o herramientas o donde vive su "
"código, así que\n"
"> si prefiere usar un entorno de desarrollo integrado (IDE) en lugar de la línea de "
"comandos, > siéntase libre de hacerlo.\n"
"> la línea de comandos, siéntase libre de usar su IDE favorito. El equipo de Cairo "
"ha desarrollado\n"
"> una extensión VSCode para el lenguaje Cairo que puedes usar para obtener las "
"características de\n"
"> el servidor de lenguajes y el resaltado de código. Ver [Apéndice A][devtools]<!-- "
"ignore -->\n"
"> para más detalles."

#: src/ch01-02-hello-world.md:15
msgid "### Creating a Project Directory"
msgstr "### Creando un Directorio de Proyecto"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t matter\n"
"to Cairo where your code lives, but for the exercises and projects in this book,\n"
"we suggest making a _cairo_projects_ directory in your home directory and keeping "
"all\n"
"your projects there."
msgstr ""
"Empezarás creando un directorio para almacenar tu código de Cairo. A Cairo no le "
"importa\n"
"a Cairo dónde vive tu código, pero para los ejercicios y proyectos de este libro,\n"
"sugerimos hacer un directorio _cairo_projects_ en su directorio home y mantener "
"todos\n"
"tus proyectos allí."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory\n"
"and a directory for the “Hello, world!” project within the _cairo_projects_ "
"directory."
msgstr ""
"Abre un terminal e introduce los siguientes comandos para crear un directorio "
"_cairo_projects_.\n"
"y un directorio para el proyecto \"¡Hola, mundo!\" dentro del directorio "
"_cairo_projects_."

#: src/ch01-02-hello-world.md:25
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Para Linux, macOS y PowerShell en Windows, introduce esto:"

#: src/ch01-02-hello-world.md:27
msgid ""
"```console\n"
"mkdir ~/cairo_projects\n"
"cd ~/cairo_projects\n"
"mkdir hello_world\n"
"cd hello_world\n"
"```"
msgstr ""
"```console\n"
"mkdir ~/cairo_projects\n"
"cd ~/cairo_projects\n"
"mkdir hello_world\n"
"cd hello_world\n"
"```"

#: src/ch01-02-hello-world.md:34
msgid "For Windows CMD, enter this:"
msgstr "Para Windows CMD, introduzca esto:"

#: src/ch01-02-hello-world.md:36
msgid ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\projects\"\n"
"> cd /d \"%USERPROFILE%\\projects\"\n"
"> mkdir hello_world\n"
"> cd hello_world\n"
"```"
msgstr ""
"```cmd\n"
"> mkdir \"%USERPROFILE%\\projects\"\n"
"> cd /d \"%USERPROFILE%\\projects\"\n"
"> mkdir hello_world\n"
"> cd hello_world\n"
"```"

#: src/ch01-02-hello-world.md:43
msgid "### Writing and Running a Cairo Program"
msgstr "### Escribiendo y Ejecutando un Programa Cairo"

#: src/ch01-02-hello-world.md:45
msgid ""
"Next, make a new source file and call it _main.cairo_. Cairo files always end with\n"
"the _.cairo_ extension. If you’re using more than one word in your filename, the\n"
"convention is to use an underscore to separate them. For example, use\n"
"_hello_world.cairo_ rather than _helloworld.cairo_."
msgstr ""
"A continuación, crea un nuevo archivo fuente y llámalo _main.cairo_. Los archivos \n"
"Cairo siempre terminan con la extensión _.cairo_. Si usas más de una palabra en "
"tu \n"
"nombre de archivo, la convención es usar un guión bajo para separarlas. Por "
"ejemplo_, \n"
"hello_mundo.cairo_ en lugar de _helloworld.cairo_."

#: src/ch01-02-hello-world.md:50
msgid ""
"Now open the _main.cairo_ file you just created and enter the code in Listing 1-1."
msgstr ""
"Ahora abre el archivo _main.cairo_ que acabas de crear e introduce el código del "
"Listado 1-1."

#: src/ch01-02-hello-world.md:52 src/ch02-05-control-flow.md:9
#: src/ch02-05-control-flow.md:58 src/ch02-05-control-flow.md:90
msgid "<span class=\"filename\">Filename: main.cairo</span>"
msgstr "<span class=\"filename\">Filename: main.cairo</span>"

#: src/ch01-02-hello-world.md:54
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"}\n"
"```"

#: src/ch01-02-hello-world.md:61
msgid ""
"<span class=\"caption\">Listing 1-1: A program that prints `Hello, world!`</span>"
msgstr ""
"<span class=\"caption\">Listing 1-1: Un programa que imprime `Hello, world!`</span>"

#: src/ch01-02-hello-world.md:63
msgid ""
"Save the file and go back to your terminal window in the\n"
"_~/cairo_projects/hello_world_ directory. Enter the following\n"
"commands to compile and run the file:"
msgstr ""
"Guarde el archivo y vuelva a su ventana de terminal en el directorio\n"
"_~/cairo_projects/hello_world_. Introduzca los siguientes comandos\n"
"para compilar y ejecutar el archivo:"

#: src/ch01-02-hello-world.md:67
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"Hello, world!\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run main.cairo\n"
"Hello, world!\n"
"```"

#: src/ch01-02-hello-world.md:72
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print to\n"
"the terminal."
msgstr ""
"Independientemente de su sistema operativo, la cadena `Hello, world!` debería \n"
"imprimirse en el terminal."

#: src/ch01-02-hello-world.md:75
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a Cairo\n"
"program. That makes you a Cairo programmer—welcome!"
msgstr ""
"Si `Hello, world!` se imprime, ¡enhorabuena! Has escrito oficialmente un programa\n"
" en Cairo. Eso te convierte en un programador de Cairo ¡Bienvenido!"

#: src/ch01-02-hello-world.md:78
msgid "### Anatomy of a Cairo Program"
msgstr "### Anatomía de un Programa Cairo"

#: src/ch01-02-hello-world.md:80
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece of\n"
"the puzzle:"
msgstr ""
"Revisemos este programa \"¡Hola, mundo!\" en detalle. Aquí está la primera \n"
"pieza del puzzle:"

#: src/ch01-02-hello-world.md:83
msgid ""
"```rust\n"
"fn main() {\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"\n"
"}\n"
"```"

#: src/ch01-02-hello-world.md:89
msgid ""
"These lines define a function named `main`. The `main` function is special: it\n"
"is always the first code that runs in every executable Cairo program. Here, the\n"
"first line declares a function named `main` that has no parameters and returns\n"
"nothing. If there were parameters, they would go inside the parentheses `()`."
msgstr ""
"Estas líneas definen una función llamada `main`. La función `main` es especial: es\n"
"es siempre el primer código que se ejecuta en cada programa ejecutable de El Cairo. "
"Aquí, la\n"
"primera línea declara una función llamada `main` que no tiene parámetros y "
"devuelve\n"
"nada. Si hubiera parámetros, irían dentro de los paréntesis `()`."

#: src/ch01-02-hello-world.md:94
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around all\n"
"function bodies. It’s good style to place the opening curly bracket on the same\n"
"line as the function declaration, adding one space in between."
msgstr ""
"El cuerpo de la función está envuelto en `{}`. Cairo requiere llaves alrededor de "
"todos los\n"
"cuerpos de función. Es de buen estilo colocar la llave de apertura en la misma "
"línea que la\n"
" declaración de la función, añadiendo un espacio en medio."

#: src/ch01-02-hello-world.md:98
msgid ""
"> Note: If you want to stick to a standard style across Cairo projects, you can\n"
"> use the automatic formatter tool called `cairo-format` to format your code in a\n"
"> particular style (more on `cairo-format` in\n"
"> [Appendix A][devtools]). The Cairo team has included this tool\n"
"> with the standard Cairo distribution, as `cairo-run` is, so it should already be\n"
"> installed on your computer!"
msgstr ""
"> Nota: Si quieres mantener un estilo estándar en todos los proyectos de Cairo, "
"puedes\n"
"> usar la herramienta de formateo automático llamada `cairo-format` para formatear "
"tu código \n"
"> en un estilo particular (más sobre `cairo-format` en\n"
"> [Apéndice A][devtools]<!-- ignore -->). El equipo de Cairo ha incluido esta "
"herramienta\n"
"> con la distribución estándar de Cairo, como lo es `cairo-run`, así que ya debería "
"estar\n"
"> ¡instalada en tu ordenador!"

#: src/ch01-02-hello-world.md:105
msgid ""
"Prior to the main function declaration, The line `use debug::PrintTrait;` is "
"responsible for importing an item defined in another module. In this case, we are "
"importing the `PrintTrait` item from the Cairo core library. By doing so, we gain "
"the ability to use the `print()` method on data types that are compatible with "
"printing."
msgstr ""
"Antes de la declaración de la función principal, la línea `use debug::PrintTrait;` "
"es responsable de importar un elemento definido en otro módulo. En este caso, "
"estamos importando el elemento `PrintTrait` de la biblioteca central de Cairo. "
"Haciendo esto, ganamos la habilidad de usar el método `print()` en tipos de datos "
"que son compatibles con la impresión."

#: src/ch01-02-hello-world.md:107
msgid "The body of the `main` function holds the following code:"
msgstr "El cuerpo de la función `main` contiene el siguiente código:"

#: src/ch01-02-hello-world.md:109
msgid ""
"```rust\n"
"    'Hello, world!'.print();\n"
"```"
msgstr ""
"```rust\n"
"    'Hello, world!'.print();\n"
"```"

#: src/ch01-02-hello-world.md:113
msgid ""
"This line does all the work in this little program: it prints text to the\n"
"screen. There are four important details to notice here."
msgstr ""
"Esta línea hace todo el trabajo en este pequeño programa: imprime texto en la "
"pantalla.\n"
"pantalla. Hay cuatro detalles importantes a tener en cuenta aquí."

#: src/ch01-02-hello-world.md:116
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr ""
"En primer lugar, el estilo de Cairo es hacer sangrías con cuatro espacios, no con "
"una tabulación."

#: src/ch01-02-hello-world.md:118
msgid ""
"Second, the `print()` function called is a method from the trait `PrintTrait`. This "
"trait is imported from the Cairo core library, and it defines how to print values "
"to the screen for different data types. In our case, our text is defined as a "
"\"short string\", which is an ASCII string that can fit in Cairo's basic data type, "
"which is the `felt252` type. By calling `Hello, world!'.print()`, we're calling the "
"`print()` method of the `felt252` implementation of the `PrintTrait` trait."
msgstr ""
"Segundo, la función `print()` es un método del trait `PrintTrait`. Este trait se "
"importa de la librería del núcleo de Cairo, y define cómo imprimir valores en la "
"pantalla para diferentes tipos de datos. En nuestro caso, nuestro texto está "
"definido como una \"cadena corta\", que es una cadena ASCII que puede caber en el "
"tipo de datos básico de Cairo, que es el tipo `felt252`. Al llamar a `Hello, "
"world!'.print()`, estamos llamando al método `print()` de la implementación "
"`felt252` del trait `PrintTrait`."

#: src/ch01-02-hello-world.md:120
msgid ""
"Third, you see the `'Hello, world!'` short string. We pass this short string as an "
"argument\n"
"to `print()`, and the short string is printed to the screen."
msgstr ""
"En tercer lugar, ves la cadena corta `'Hello, world!'` Pasamos esta cadena corta "
"como argumento\n"
"a `print()`, y la cadena corta se imprime en la pantalla."

#: src/ch01-02-hello-world.md:123
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this\n"
"expression is over and the next one is ready to begin. Most lines of Cairo code\n"
"end with a semicolon."
msgstr ""
"Cuarto, terminamos la línea con un punto y coma (`;`), que indica que esta\n"
"expresión ha terminado y la siguiente está lista para comenzar. La mayoría de las \n"
"líneas de código de Cairo terminan con punto y coma."

#: src/ch01-02-hello-world.md:127
msgid ""
"Just running with `cairo-run` is fine for simple programs, but as your project\n"
"grows, you’ll want to manage all the options and make it easy to share your\n"
"code. Next, we’ll introduce you to the Scarb tool, which will help you write\n"
"real-world Cairo programs."
msgstr ""
"Sólo ejecutar con `cairo-run` está bien para programas simples, pero a medida que "
"tu proyecto\n"
"proyecto crezca, querrá manejar todas las opciones y hacer fácil compartir su "
"código.\n"
"código. A continuación, te presentaremos la herramienta Scarb, que te ayudará a "
"escribir\n"
"programas Cairo del mundo real."

#: src/ch01-03-hello-scarb.md:1
msgid "# Hello, Scarb"
msgstr "# Hola, Scarb"

#: src/ch01-03-hello-scarb.md:3
msgid ""
"Scarb is the Cairo package manager and heavily inspired by [Cargo](https://doc.rust-"
"lang.org/cargo/), Rust’s build system and package manager."
msgstr ""
"Scarb es el gestor de paquetes de Cairo y está fuertemente inspirado en [Cargo]"
"(https://doc.rust-lang.org/cargo/), el sistema de construcción y gestor de paquetes "
"de Rust."

#: src/ch01-03-hello-scarb.md:5
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either pure Cairo "
"or Starknet contracts), downloading the libraries your code depends on, and "
"building those libraries."
msgstr ""
"Scarb maneja muchas tareas por ti, como construir tu código (ya sea Cairo puro o "
"contratos Starknet), descargar las librerías de las que depende tu código, y "
"construir esas librerías."

#: src/ch01-03-hello-scarb.md:7
msgid ""
"If we were to build the 'Hello, world!' project using Scarb, only the part of Scarb "
"that handles building the code would be utilized, since the program doesn't require "
"any external dependencies. As you write more complex Cairo programs, you’ll add "
"dependencies, and if you start a project using Scarb, adding dependencies will be "
"much easier to do."
msgstr ""
"Si fuéramos a construir el proyecto `Hello, world!` usando Scarb, sólo la parte de "
"Scarb que maneja la construcción del código sería utilizada, ya que el programa no "
"requiere ninguna dependencia externa. A medida que escriba programas Cairo más "
"complejos, agregará dependencias, y si inicia un proyecto utilizando Scarb, agregar "
"dependencias será mucho más fácil de hacer."

#: src/ch01-03-hello-scarb.md:9
msgid "Let's start by installing Scarb."
msgstr "Empecemos instalando Scarb."

#: src/ch01-03-hello-scarb.md:11
msgid "## Installing Scarb"
msgstr "## Instalando Scarb"

#: src/ch01-03-hello-scarb.md:13
msgid "### Requirements"
msgstr "### Requisitos"

#: src/ch01-03-hello-scarb.md:15
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment variable."
msgstr "Scarb requiere un ejecutable Git disponible en la variable de entorno `PATH`."

#: src/ch01-03-hello-scarb.md:17
msgid "### Installation"
msgstr "### Instalación"

#: src/ch01-03-hello-scarb.md:19
msgid "As for now, Scarb needs manual installation with the following steps:"
msgstr "Por ahora, Scarb necesita instalación manual con los siguientes pasos:"

#: src/ch01-03-hello-scarb.md:21
msgid ""
"- Download the release archive matching your operating system and CPU architecture, "
"from [Scarb releases on GitHub](https://github.com/software-mansion/scarb/"
"releases)\n"
"- Extract it to a location where you would like to have Scarb installed, e.g. `~/"
"scarb`\n"
"- Add path to the `scarb/bin` directory to your `PATH` environment variable.\n"
"\n"
"  This depend on what shell you are using. Let’s take the example of [zsh](https://"
"ohmyz.sh/) and you have extracted Scarb to `~/scarb`:\n"
"\n"
"  - Open `~/.zshrc` file in your favorite editor\n"
"  - Add the following line to the end of the file: `export PATH=\"$PATH:~/scarb/bin"
"\"`\n"
"\n"
"- Verify installation by running the following command in new terminal session, it "
"should print both Scarb and Cairo language versions, e.g:\n"
"\n"
"  ```bash\n"
"  $ scarb --version\n"
"  scarb 0.1.0 (289137c24 2023-03-28)\n"
"  cairo: 1.0.0-alpha.6\n"
"  ```"
msgstr ""
"- Descargue el archivo de versiones correspondiente a su sistema operativo y "
"arquitectura de CPU desde [Scarb releases on GitHub](https://github.com/software-"
"mansion/scarb/releases)\n"
"- Extráigalo a una ubicación en la que desee tener Scarb instalado, por ejemplo. `~/"
"scarb`\n"
"- Añada la ruta al directorio `scarb/bin` a su variable de entorno `PATH`.\n"
"\n"
"  Esto depende del shell que esté utilizando. Tomemos el ejemplo de [zsh](https://"
"ohmyz.sh/) y has extraido Scarb a `~/scarb`:\n"
"\n"
"  - Abra el archivo `~/.zshrc` en su editor favorito\n"
"  -Añada la siguiente línea al final del archivo: `export PATH=\"$PATH:~/scarb/bin"
"\"`\n"
"\n"
"- Verifique la instalación ejecutando el siguiente comando en una nueva sesión de "
"terminal, debería imprimir las versiones en Scarb y Cairo, por ejemplo:\n"
"\n"
"  ```bash\n"
"  $ scarb --version\n"
"  scarb 0.1.0 (289137c24 2023-03-28)\n"
"  cairo: 1"

#: src/ch01-03-hello-scarb.md:38
msgid "### Creating a Project with Scarb"
msgstr "### Creando un Proyecto con Scarb"

#: src/ch01-03-hello-scarb.md:40
msgid ""
"Let’s create a new project using Scarb and look at how it differs from our original "
"“Hello, world!” project."
msgstr ""
"Vamos a crear un nuevo proyecto utilizando Scarb y ver en qué se diferencia de "
"nuestro proyecto original “Hello, world!”."

#: src/ch01-03-hello-scarb.md:42
msgid ""
"Navigate back to your projects directory (or wherever you decided to store your "
"code). Then run the following:"
msgstr ""
"Navegue de nuevo a su directorio de proyectos (o donde haya decidido almacenar su "
"código). Luego ejecute lo siguiente:"

#: src/ch01-03-hello-scarb.md:44
msgid ""
"```bash\n"
"$ scarb new hello_scarb\n"
"```"
msgstr ""
"```bash\n"
"$ scarb new hello_scarb\n"
"```"

#: src/ch01-03-hello-scarb.md:48
msgid ""
"It creates a new directory and project called hello_scarb. We’ve named our project "
"hello_scarb, and Scarb creates its files in a directory of the same name."
msgstr ""
"Crea un nuevo directorio y proyecto llamado hello_scarb. Hemos llamado a nuestro "
"proyecto hello_scarb, y Scarb crea sus archivos en un directorio con el mismo "
"nombre."

#: src/ch01-03-hello-scarb.md:50
msgid ""
"Go into the hello_scarb directory with the command `cd hello_scarb`. You’ll see "
"that Scarb has generated two files and one directory for us: a `Scarb.toml` file "
"and a src directory with a `lib.cairo` file inside."
msgstr ""
"Entre en el directorio hello_scarb con el comando `cd hello_scarb`.Verás que Scarb "
"ha generado dos archivos y un directorio para nosotros: un archivo `Scarb.toml` y "
"un directorio src con un archivo `lib.cairo` dentro."

#: src/ch01-03-hello-scarb.md:52
msgid "It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""
"También ha inicializado un nuevo repositorio Git junto con un archivo `.gitignore`"

#: src/ch01-03-hello-scarb.md:54
msgid ""
"> Note: Git is a common version control system. You can stop using version control "
"system by using the `--vcs` flag.\n"
"> Run `scarb new -help` to see the available options."
msgstr ""
"> Nota: Git es un sistema de control de versiones común. Puede dejar de usar el "
"sistema de control de versiones \n"
"> usando la bandera `--vcs`.\n"
"> Ejecute `scarb new -help` para ver las opciones disponibles."

#: src/ch01-03-hello-scarb.md:57
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to the code "
"in Listing 1-2."
msgstr ""
"Abra _Scarb.toml_ en su editor de texto preferido. Debería parecerse al código del "
"Listado 1-2."

#: src/ch01-03-hello-scarb.md:59
msgid "<span class=\"filename\">Filename: Scarb.toml</span>"
msgstr "<span class=\"filename\">Filename: Scarb.toml</span>"

#: src/ch01-03-hello-scarb.md:61
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/"
"reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# Vea más claves y sus definiciones en https://docs.swmansion.com/scarb/docs/"
"reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-03-hello-scarb.md:72
msgid ""
"<span class=\"caption\">Listing 1-2: Contents of Scarb.toml generated by `scarb "
"new`</span>"
msgstr ""
"<span class=\"caption\">Listing 1-2: Contents of Scarb.toml generated by `scarb "
"new`</span>"

#: src/ch01-03-hello-scarb.md:74
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal Language) "
"format, which is Scarb’s configuration format."
msgstr ""
"Este archivo se encuentra en formato [TOML](https://toml.io/) (Tom’s Obvious, "
"Minimal Language), que es el formato de configuración de Scarb."

#: src/ch01-03-hello-scarb.md:76
msgid ""
"The first line, `[package]`, is a section heading that indicates that the following "
"statements are configuring a package. As we add more information to this file, "
"we’ll add other sections."
msgstr ""
"La primera línea, `[package]`, es un encabezado de sección que indica que las "
"siguientes sentencias están configurando un paquete. A medida que agreguemos más "
"información a este archivo, agregaremos otras secciones."

#: src/ch01-03-hello-scarb.md:78
msgid ""
"The next two lines set the configuration information Scarb needs to compile your "
"program: the name and the version of Scarb to use."
msgstr ""
"Las siguientes dos líneas establecen la información de configuración que Scarb "
"necesita para compilar su programa: el nombre y la versión de Scarb a utilizar."

#: src/ch01-03-hello-scarb.md:80
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list any of "
"your project’s dependencies. In Cairo, packages of code are referred to as crates. "
"We won’t need any other crates for this project."
msgstr ""
"La última línea, `[dependencies]`, es el comienzo de una sección para que puedas "
"listar cualquiera de las dependencias de tu proyecto. En Cairo, los paquetes de "
"código se conocen como crates. No necesitaremos ninguna otra crate para este "
"proyecto."

#: src/ch01-03-hello-scarb.md:82
msgid ""
"The other file created by Scarb is `src/lib.cairo`, let's delete all the content "
"and put in the following content, we will explain the reason later."
msgstr ""
"El otro archivo creado por Scarb es `src/lib.cairo`, borremos todo el contenido y "
"pongamos el siguiente contenido, explicaremos la razón más adelante."

#: src/ch01-03-hello-scarb.md:84
msgid ""
"```rust\n"
"mod hello_scarb;\n"
"```"
msgstr ""
"```rust\n"
"mod hello_scarb;\n"
"```"

#: src/ch01-03-hello-scarb.md:88
msgid ""
"Then create a new file called `src/hello_scarb.cairo` and put the following code in "
"it:"
msgstr ""
"A continuación, cree un nuevo archivo llamado `src/hello_scarb.cairo` y ponle el "
"siguiente código:"

#: src/ch01-03-hello-scarb.md:90
msgid "<span class=\"filename\">Filename: src/hello_scarb.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/hello_scarb.cairo</span>"

#: src/ch01-03-hello-scarb.md:92
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"

#: src/ch01-03-hello-scarb.md:99
msgid ""
"We have just created a file called `lib.cairo`, which contains a module declaration "
"referencing another module named \"hello_scarb\", as well as the file `hello_scarb."
"cairo`,containing the implementation details of the \"hello_scarb\" module."
msgstr ""
"Acabamos de crear un archivo llamado `lib.cairo`, que contiene una declaración de "
"módulo que hace referencia a otro módulo llamado \"hello_scarb\", así como el "
"archivo `hello_scarb.cairo`, que contiene los detalles de implementación del módulo "
"\"hello_scarb\"."

#: src/ch01-03-hello-scarb.md:101
msgid "Scarb requires your source files to be located within the src directory."
msgstr ""
"Scarb requiere que sus archivos fuente se encuentren dentro del directorio src."

#: src/ch01-03-hello-scarb.md:103
msgid ""
"The top-level project directory is reserved for README files, license information, "
"configuration files, and any other non-code-related content.\n"
"Scarb ensures a designated location for all project components, maintaining a "
"structured organization."
msgstr ""
"El directorio de proyecto de nivel superior está reservado para los archivos "
"README, información de licencia, archivos de configuración, y cualquier\n"
"otro contenido no relacionado con el código.\n"
"Scarb asegura una ubicación designada para todos los componentes del proyecto, "
"manteniendo una organización estructurada."

#: src/ch01-03-hello-scarb.md:106
msgid ""
"If you started a project that doesn’t use Scarb, as we did with the “Hello, world!” "
"project, you can convert it to a project that does use Scarb. Move the project code "
"into the src directory and create an appropriate `Scarb.toml` file."
msgstr ""
"Si ha iniciado un proyecto que no utiliza Scarb, como hicimos con el proyecto "
"“Hello, world!”, puede convertirlo en un proyecto que utilice Scarb. Mueva el "
"código del proyecto al directorio src y cree un archivo `Scarb.toml` apropiado."

#: src/ch01-03-hello-scarb.md:108
msgid "### Building a Scarb Project"
msgstr "### Creación de un proyecto Scarb"

#: src/ch01-03-hello-scarb.md:110
msgid ""
"From your hello_scarb directory, build your project by entering the following "
"command:"
msgstr ""
"Desde su directorio hello_scarb, construya su proyecto introduciendo el siguiente "
"comando:"

#: src/ch01-03-hello-scarb.md:112
msgid ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"
msgstr ""
"```bash\n"
"$ scarb build\n"
"   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)\n"
"    Finished release target(s) in 0 seconds\n"
"```"

#: src/ch01-03-hello-scarb.md:118
msgid ""
"This command creates a `sierra` file in `target/release`, let's ignore the `sierra` "
"file for now."
msgstr ""
"Este comando crea un archivo `sierra` en `target/release`, ignoremos el archivo "
"`sierra` por ahora."

#: src/ch01-03-hello-scarb.md:120
msgid ""
"If you have installed Cairo correctly, you should be able to run and see the "
"following output:"
msgstr ""
"Si has instalado Cairo correctamente, deberías ser capaz de ejecutarlo y ver la "
"siguiente salida:"

#: src/ch01-03-hello-scarb.md:122
msgid ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch01-03-hello-scarb.md:129
msgid ""
"> Note: You will notice here that we didn't use a Scarb command, but rather a "
"command from the Cairo binaries directly.\n"
"> As Scarb doesn't have a command to execute Cairo code yet, we have to use the "
"`cairo-run` command directly.\n"
"> We will use this command in the rest of the tutorial, but we will also use Scarb "
"commands to initialize projects."
msgstr ""
"> Nota: Notarás aquí que no usamos un comando de Scarb, sino un comando de los "
"binarios de Cairo directamente.\n"
"> Como Scarb no tiene un comando para ejecutar código de Cairo, tenemos que usar el "
"comando `cairo-run` directamente.\n"
"> Usaremos este comando en el resto del tutorial, pero también usaremos comandos de "
"Scarb para inicializar proyectos."

#: src/ch01-03-hello-scarb.md:133
msgid "### Defining Custom Scripts"
msgstr "### Definición de scripts personalizados"

#: src/ch01-03-hello-scarb.md:135
msgid ""
"We can define Scarb scripts in `Scarb.toml` file, which can be used to execute "
"custom shell scripts.\n"
"Add the following line to your `Scarb.toml` file:"
msgstr ""
"Podemos definir scripts scarb en el archivo `Scarb.toml`, que puede ser usado para "
"ejecutar scripts shell personalizados.\n"
"Añada la siguiente línea a su fichero `Scarb.toml`:"

#: src/ch01-03-hello-scarb.md:138
msgid ""
"```toml\n"
"[scripts]\n"
"run-lib = \"cairo-run src/lib.cairo\"\n"
"```"
msgstr ""
"```toml\n"
"[scripts]\n"
"run-lib = \"cairo-run src/lib.cairo\"\n"
"```"

#: src/ch01-03-hello-scarb.md:143
msgid "Now you can run the following command to run the project:"
msgstr "Ahora puede ejecutar el siguiente comando para ejecutar el proyecto:"

#: src/ch01-03-hello-scarb.md:145
msgid ""
"```bash\n"
"$ scarb run run-lib\n"
"[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```bash\n"
"$ scarb run run-lib\n"
"[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch01-03-hello-scarb.md:152
msgid ""
"Using `scarb run` is a convenient way to run custom shell scripts that can be "
"useful to run files and test your project."
msgstr ""
"Usar `scarb run` es una forma conveniente de ejecutar scripts de shell "
"personalizados que pueden ser útiles para ejecutar archivos y probar su proyecto."

#: src/ch01-03-hello-scarb.md:154
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "Recapitulemos lo que hemos aprendido hasta ahora sobre Scarb:"

#: src/ch01-03-hello-scarb.md:156
msgid ""
"- We can create a project using `scarb new`.\n"
"- We can build a project using `scarb build` to generate the compiled Sierra code.\n"
"- We can define custom scripts in `Scarb.toml` and call them with the `scarb run` "
"command."
msgstr ""
"- Podemos crear un proyecto usando `scarb new`.\n"
"- Podemos construir un proyecto usando `scarb build` para generar el código Sierra "
"compilado.\n"
"- Podemos definir scripts personalizados en `Scarb.toml` y llamarlos con el comando "
"`scarb run`."

#: src/ch01-03-hello-scarb.md:160
msgid ""
"An additional advantage of using Scarb is that the commands are the same no matter "
"which operating system you’re working on. So, at this point, we’ll no longer "
"provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Una ventaja adicional de usar Scarb es que los comandos son los mismos sin importar "
"el sistema operativo en el que estemos trabajando. Así que, en este punto, ya no "
"proporcionaremos instrucciones específicas para Linux y macOS frente a Windows."

#: src/ch01-03-hello-scarb.md:162
msgid "# Summary"
msgstr "# Resumen"

#: src/ch01-03-hello-scarb.md:164
msgid ""
"You’re already off to a great start on your Cairo journey! In this chapter, you’ve "
"learned how to:"
msgstr ""
"Ya has empezado con buen pie tu viaje en Cairo. En este capítulo, has aprendido "
"cómo:"

#: src/ch01-03-hello-scarb.md:166
msgid ""
"- Install the latest stable version of Cairo\n"
"- Write and run a “Hello, world!” program using `cairo-run` directly\n"
"- Create and run a new project using the conventions of Scarb"
msgstr ""
"- Instalar la última versión estable de Cairo\n"
"- Escribir y ejecutar un programa \" Hello, world!\" usando `cairo-run` "
"directamente\n"
"- Crear y ejecutar un nuevo proyecto usando las convenciones de Scarb"

#: src/ch01-03-hello-scarb.md:170
msgid ""
"This is a great time to build a more substantial program to get used to reading and "
"writing Cairo code."
msgstr ""
"Este es un buen momento para construir un programa más sustancial para "
"acostumbrarte a leer y escribir código de Cairo."

#: src/ch02-00-common-programming-concepts.md:1
msgid "# Common Programming Concepts"
msgstr "# Conceptos comunes de programación"

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming language and "
"how they work in Cairo. Many programming languages have much in common at their "
"core. None of the concepts presented in this chapter are unique to Cairo, but we’ll "
"discuss them in the context of Cairo and explain the conventions around using these "
"concepts."
msgstr ""
"Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de "
"programación y cómo funcionan en Cairo. Muchos lenguajes de programación tienen "
"mucho en común en su núcleo. Ninguno de los conceptos presentados en este capítulo "
"son exclusivos de Cairo, pero los discutiremos en el contexto de Cairo y "
"explicaremos las convenciones sobre el uso de estos conceptos."

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, comments, and "
"control flow. These foundations will be in every Cairo program, and learning them "
"early will give you a strong core to start from."
msgstr ""
"Específicamente, aprenderás sobre variables, tipos básicos, funciones, comentarios "
"y flujo de control. Estos fundamentos estarán en cada programa de Cairo, y "
"aprenderlos desde el principio te dará un núcleo fuerte desde el que empezar."

#: src/ch02-01-variables-and-mutability.md:1
msgid "## Variables and Mutability"
msgstr "## Variables y mutabilidad"

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is written "
"to,\n"
"it can't be overwritten but only read from. To reflect this immutable memory "
"model,\n"
"variables in Cairo are immutable by default.\n"
"However, the language abstracts this model and gives you the option to make your\n"
"variables mutable. Let’s explore how and why Cairo enforces immutability, and how\n"
"you can make your variables mutable."
msgstr ""
"Cairo usa un modelo de memoria inmutable, lo que significa que una vez que se "
"escribe en\n"
" una celda de memoria, no puede ser sobrescrita sino sólo leída. Para reflejar este "
"modelo \n"
"de memoria inmutable, las variables en Cairo son inmutables por defecto.\n"
"Sin embargo, el lenguaje abstrae este modelo y te da la opción de hacer tus\n"
"variables mutables. Exploremos cómo y por qué Cairo impone la inmutabilidad, y "
"cómo\n"
"puedes hacer tus variables mutables."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t change\n"
"that value. To illustrate this, generate a new project called _variables_ in\n"
"your _cairo_projects_ directory by using `scarb new variables`."
msgstr ""
"Cuando una variable es inmutable, una vez que un valor está ligado a un nombre, no\n"
" puedes cambiar ese valor. Para ilustrar esto, genera un nuevo proyecto llamado _\n"
"variables_ en tu directorio _cairo_projects_ usando `scarb new variables`."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its\n"
"code with the following code, which won’t compile just yet:"
msgstr ""
"A continuación, en su nuevo directorio _variables_, abra _src/lib.cairo_ y "
"sustituya \n"
"su código por el siguiente, que todavía no compilará:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:76
#: src/ch02-01-variables-and-mutability.md:154 src/ch02-05-control-flow.md:130
#: src/ch03-02-references-and-snapshots.md:23
#: src/ch03-02-references-and-snapshots.md:111
#: src/ch04-02-an-example-program-using-structs.md:7
#: src/ch04-02-an-example-program-using-structs.md:48
#: src/ch04-02-an-example-program-using-structs.md:74
#: src/ch04-02-an-example-program-using-structs.md:106
#: src/ch04-02-an-example-program-using-structs.md:142 src/ch04-03-method-syntax.md:18
#: src/ch04-03-method-syntax.md:93 src/ch04-03-method-syntax.md:135
#: src/ch04-03-method-syntax.md:192 src/ch04-03-method-syntax.md:231
#: src/ch06-02-defining-modules-to-control-scope.md:90
#: src/ch06-02-defining-modules-to-control-scope.md:144
#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:35
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:74
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:156
#: src/ch06-05-separating-modules-into-different-files.md:18
#: src/ch08-01-how-to-write-tests.md:426 src/ch08-01-how-to-write-tests.md:464
msgid "<span class=\"filename\">Filename: src/lib.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/lib.cairo</span>"

#: src/ch02-01-variables-and-mutability.md:19
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `cairo-run src/lib.cairo`. You should receive an "
"error message\n"
"regarding an immutability error, as shown in this output:"
msgstr ""
"Guarde y ejecute el programa utilizando `cairo-run src/lib.cairo`. Debería recibir "
"un mensaje \n"
"de error relativo a un error de inmutabilidad, como se muestra en esta salida:"

#: src/ch02-01-variables-and-mutability.md:32
msgid ""
"```console\n"
"error: Cannot assign to an immutable variable.\n"
" --> lib.cairo:5:5\n"
"    x = 6;\n"
"    ^***^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""
"```console\n"
"error: Cannot assign to an immutable variable.\n"
" --> lib.cairo:5:5\n"
"    x = 6;\n"
"    ^***^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"

#: src/ch02-01-variables-and-mutability.md:41
msgid ""
"This example shows how the compiler helps you find errors in your programs.\n"
"Compiler errors can be frustrating, but really they only mean your program\n"
"isn’t safely doing what you want it to do yet; they do _not_ mean that you’re\n"
"not a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"Este ejemplo muestra cómo el compilador te ayuda a encontrar errores en tus \n"
"programas. Los errores del compilador pueden ser frustrantes, pero en realidad \n"
"sólo significan que su programa todavía no está haciendo con seguridad lo que "
"usted \n"
"quiere que haga; ¡no significan que usted no sea un buen programador! Los "
"Caironautas \n"
"experimentados siguen teniendo errores de compilador."

#: src/ch02-01-variables-and-mutability.md:46
msgid ""
"You received the error message `Cannot assign to an immutable variable.`\n"
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"Recibiste el mensaje de error `Cannot assign to an immutable variable.` porque \n"
"intentaste asignar un segundo valor a la variable inmutable `x`."

#: src/ch02-01-variables-and-mutability.md:49
msgid ""
"It’s important that we get compile-time errors when we attempt to change a\n"
"value that’s designated as immutable because this specific situation can lead to\n"
"bugs. If one part of our code operates on the assumption that a value will\n"
"never change and another part of our code changes that value, it’s possible\n"
"that the first part of the code won’t do what it was designed to do. The cause\n"
"of this kind of bug can be difficult to track down after the fact, especially\n"
"when the second piece of code changes the value only _sometimes_. The Cairo\n"
"compiler guarantees that when you state that a value won’t change, it really\n"
"won’t change, so you don’t have to keep track of it yourself. Your code is thus\n"
"easier to reason through."
msgstr ""
"Es importante que obtengamos errores en tiempo de compilación cuando intentamos \n"
"cambiar un valor designado como inmutable porque esta situación específica puede\n"
" conducir a errores. Si una parte de nuestro código opera bajo la suposición de que "
"un\n"
" valor nunca cambiará y otra parte de nuestro código cambia ese valor, es posible\n"
"que la primera parte del código no haga lo que fue diseñada para hacer. La causa de "
"este \n"
"tipo de error puede ser difícil de rastrear después de los hechos, especialmente "
"cuando la \n"
"segunda parte del código cambia el valor sólo _a veces_. El compilador Cairo "
"garantiza que \n"
"cuando dices que un valor no cambiará, realmente no cambiará, por lo que no tiene "
"que hacer \n"
"un seguimiento. Su código es así más fácil de razonar."

#: src/ch02-01-variables-and-mutability.md:60
msgid ""
"But mutability can be very useful, and can make code more convenient to write.\n"
"Although variables are immutable by default, you can make them mutable by\n"
"adding `mut` in front of the variable name. Adding `mut` also conveys\n"
"intent to future readers of the code by indicating that other parts of the code\n"
"will be changing this variable’s value."
msgstr ""
"Pero la mutabilidad puede ser muy útil, y puede hacer que el código sea más "
"cómodo \n"
"de escribir. Aunque las variables son inmutables por defecto, puedes hacerlas "
"mutables \n"
"añadiendo `mut` delante del nombre de la variable. Añadir `mut` también transmite \n"
"intención a los futuros lectores del código indicando que otras partes del código \n"
"cambiarán el valor de esta variable."

#: src/ch02-01-variables-and-mutability.md:66
msgid ""
"However, you might be wondering at this point what exactly happens when a variable\n"
"is declared as `mut`, as we previously mentioned that Cairo's memory is immutable.\n"
"The answer is that Cairo's memory is immutable, but the memory address the variable "
"points\n"
"to can be changed. Upon examining the low-level Cairo Assembly code, it becomes "
"clear that\n"
"variable mutation is implemented as syntactic sugar, which translates mutation "
"operations\n"
"into a series of steps equivalent to variable shadowing. The only difference is "
"that at the Cairo\n"
"level, the variable is not redeclared so its type cannot change."
msgstr ""
"Sin embargo, puede que en este punto te estés preguntando qué ocurre exactamente \n"
"cuando una variable es declarada como `mut`, ya que previamente mencionamos que "
"la \n"
"memoria de Cairo es inmutable.\n"
"La respuesta es que la memoria de Cairo es inmutable, pero la dirección de memoria "
"a la \n"
"que apunta la variable puede ser cambiada. Al examinar el código ensamblador de "
"bajo nivel \n"
"de Cairo, queda claro que la mutación de variables se implementa como azúcar "
"sintáctico, \n"
"que traduce las operaciones de mutación en una serie de pasos equivalentes al "
"shadowing \n"
"de variables. La única diferencia es que en el nivel la variable no se vuelve a "
"declarar, por lo \n"
"que su tipo no puede cambiar."

#: src/ch02-01-variables-and-mutability.md:74
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Por ejemplo, cambiemos _src/lib.cairo_ por lo siguiente:"

#: src/ch02-01-variables-and-mutability.md:78
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut x = 5;\n"
"    x.print();\n"
"    x = 6;\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:88
msgid "When we run the program now, we get this:"
msgstr "Cuando ejecutamos el programa ahora, obtenemos esto:"

#: src/ch02-01-variables-and-mutability.md:90
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\t                              \t(raw: 5)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\t                              \t(raw: 5)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch02-01-variables-and-mutability.md:99
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is\n"
"used. Ultimately, deciding whether to use mutability or not is up to you and\n"
"depends on what you think is clearest in that particular situation."
msgstr ""
"Se nos permite cambiar el valor ligado a `x` de `5` a `6` cuando se usa `mut`. \n"
"En última instancia, la decisión de utilizar la mutabilidad o no es suya y "
"depende \n"
"de lo que usted piensa que es más claro en esa situación particular."

#: src/ch02-01-variables-and-mutability.md:103
msgid "### Constants"
msgstr "##### Constantes"

#: src/ch02-01-variables-and-mutability.md:105
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name and\n"
"are not allowed to change, but there are a few differences between constants\n"
"and variables."
msgstr ""
"Al igual que las variables inmutables, las _constantes_ son valores que están\n"
" vinculados a un nombre y no se les permite cambiar, pero hay algunas diferencias \n"
"entre las constantes y las variables."

#: src/ch02-01-variables-and-mutability.md:109
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just\n"
"immutable by default—they’re always immutable. You declare constants using the\n"
"`const` keyword instead of the `let` keyword, and the type of the value _must_\n"
"be annotated. We’ll cover types and type annotations in the next section,\n"
"[“Data Types”][data-types], so don’t worry about the details\n"
"right now. Just know that you must always annotate the type."
msgstr ""
"En primer lugar, no se permite el uso de `mut` con las constantes. Las constantes \n"
"no son solo inmutables por defecto, sino que siempre son inmutables. Se declaran \n"
"constantes usando la palabra clave `const` en lugar de la palabra clave `let`, y el "
"tipo de\n"
" valor _debe_ ser anotado. Cubriremos los tipos y las anotaciones de tipo en la "
"próxima\n"
" sección, [“Tipos de datos”][tipos-de-datos], así que no se preocupe por los \n"
"detalles por ahora. Solo sepa que siempre debe anotar el tipo."

#: src/ch02-01-variables-and-mutability.md:116
msgid ""
"Constants can only be declared in the global scope, which makes\n"
"them useful for values that many parts of code need to know about."
msgstr ""
"Las constantes solo se pueden declarar en el ámbito global, lo que las hace \n"
"útiles para valores que muchas partes del código deben conocer."

#: src/ch02-01-variables-and-mutability.md:119
msgid ""
"The last difference is that constants may be set only to a constant expression,\n"
"not the result of a value that could only be computed at runtime. Only literal "
"constants\n"
"are currently supported."
msgstr ""
"La última diferencia es que las constantes solo pueden ser asignadas a una "
"expresión \n"
"constante, no al resultado de un valor que solo se podría calcular en tiempo de "
"ejecución. \n"
"Actualmente, solo se admiten constantes literales."

#: src/ch02-01-variables-and-mutability.md:123
msgid "Here’s an example of a constant declaration:"
msgstr "Aquí hay un ejemplo de declaración de constante:"

#: src/ch02-01-variables-and-mutability.md:125
msgid ""
"```rust\n"
"const ONE_HOUR_IN_SECONDS: u32 = 3600_u32;\n"
"```"
msgstr ""
"```rust\n"
"const ONE_HOUR_IN_SECONDS: u32 = 3600_u32;\n"
"```"

#: src/ch02-01-variables-and-mutability.md:129
msgid ""
"Cairo's naming convention for constants is to use all uppercase with\n"
"underscores between words."
msgstr ""
"La convención de nomenclatura de Cairo para las constantes es usar todas\n"
" las mayúsculas con guiones bajos entre palabras."

#: src/ch02-01-variables-and-mutability.md:132
msgid ""
"Constants are valid for the entire time a program runs, within the scope in\n"
"which they were declared. This property makes constants useful for values in\n"
"your application domain that multiple parts of the program might need to know\n"
"about, such as the maximum number of points any player of a game is allowed to\n"
"earn, or the speed of light."
msgstr ""
"Las constantes son válidas durante todo el tiempo que se ejecuta un programa, \n"
"dentro del ámbito en el que fueron declaradas. Esta propiedad hace que las "
"constantes \n"
"sean útiles para los valores en el dominio de su aplicación que varias partes del "
"programa \n"
"podrían necesitar conocer, como el número máximo de puntos que cualquier jugador "
"de \n"
"un juego puede ganar o la velocidad de la luz."

#: src/ch02-01-variables-and-mutability.md:138
msgid ""
"Naming hardcoded values used throughout your program as constants is useful in\n"
"conveying the meaning of that value to future maintainers of the code. It also\n"
"helps to have only one place in your code you would need to change if the\n"
"hardcoded value needed to be updated in the future."
msgstr ""
"Nombrar los valores codificados en duro utilizados en todo el programa como \n"
"constantes es útil para transmitir el significado de ese valor a los futuros "
"mantenedores\n"
" del código. También ayuda a tener solo un lugar en su código donde tendría que "
"cambiar\n"
" si el valor codificado en duro necesitara ser actualizado en el futuro."

#: src/ch02-01-variables-and-mutability.md:143
msgid "### Shadowing"
msgstr "### Shadowing"

#: src/ch02-01-variables-and-mutability.md:145
msgid ""
"Variable shadowing refers to the declaration of a\n"
"new variable with the same name as a previous variable. Caironautes say that the\n"
"first variable is _shadowed_ by the second, which means that the second\n"
"variable is what the compiler will see when you use the name of the variable.\n"
"In effect, the second variable overshadows the first, taking any uses of the\n"
"variable name to itself until either it itself is shadowed or the scope ends.\n"
"We can shadow a variable by using the same variable’s name and repeating the\n"
"use of the `let` keyword as follows:"
msgstr ""
"La sombra de una variable se refiere a la declaración de una nueva variable con \n"
"el mismo nombre que una variable anterior. Los caironautas dicen que la primera \n"
"variable está _sombreada_ por la segunda, lo que significa que el compilador verá \n"
"la segunda variable cuando use el nombre de la variable. En efecto, la segunda \n"
"variable oculta la primera, tomando cualquier uso del nombre de la variable para "
"sí \n"
"misma hasta que ella misma sea sombreada o que el ámbito termine. Podemos \n"
"sombrear una variable usando el mismo nombre de la variable y repitiendo el uso "
"de \n"
"la palabra clave `let` de la siguiente manera:"

#: src/ch02-01-variables-and-mutability.md:156
msgid ""
"```swift\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    let x = x + 1;\n"
"    {\n"
"        let x = x * 2;\n"
"        'Inner scope x value is:'.print();\n"
"        x.print()\n"
"    }\n"
"    'Outer scope x value is:'.print();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```swift\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let x = 5;\n"
"    let x = x + 1;\n"
"    {\n"
"        let x = x * 2;\n"
"        'Inner scope x value is:'.print();\n"
"        x.print()\n"
"    }\n"
"    'Outer scope x value is:'.print();\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:171
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new variable\n"
"`x` by repeating `let x =`, taking the original value and adding `1` so the\n"
"value of `x` is then `6`. Then, within an inner scope created with the curly\n"
"brackets, the third `let` statement also shadows `x` and creates a new\n"
"variable, multiplying the previous value by `2` to give `x` a value of `12`.\n"
"When that scope is over, the inner shadowing ends and `x` returns to being `6`.\n"
"When we run this program, it will output the following:"
msgstr ""
"Este programa primero asigna un valor de `5` a `x`. Luego crea una nueva \n"
"variable `x` repitiendo `let x =`, tomando el valor original y sumando `1`, \n"
"por lo que el valor de `x` es ahora `6`. Luego, dentro de un ámbito interno \n"
"creado con llaves, la tercera instrucción `let` también sombrea `x` y crea \n"
"una nueva variable, multiplicando el valor anterior por `2` para darle a `x` \n"
"un valor de `12`. Cuando ese ámbito termina, la sombra interna termina y `x`\n"
" vuelve a ser `6`. Al ejecutar este programa, se mostrará lo siguiente:"

#: src/ch02-01-variables-and-mutability.md:179
msgid ""
"```console\n"
"cairo-run src/lib.cairo\n"
"[DEBUG]\tInner scope x value is:        \t(raw: "
"7033328135641142205392067879065573688897582790068499258)\n"
"\n"
"[DEBUG]\n"
"                                      \t(raw: 12)\n"
"\n"
"[DEBUG]\tOuter scope x value is:        \t(raw: "
"7610641743409771490723378239576163509623951327599620922)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```console\n"
"cairo-run src/lib.cairo\n"
"[DEBUG]\tInner scope x value is:        \t(raw: "
"7033328135641142205392067879065573688897582790068499258)\n"
"\n"
"[DEBUG]\n"
"                                      \t(raw: 12)\n"
"\n"
"[DEBUG]\tOuter scope x value is:        \t(raw: "
"7610641743409771490723378239576163509623951327599620922)\n"
"\n"
"[DEBUG]\t                              \t(raw: 6)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch02-01-variables-and-mutability.md:193
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a\n"
"compile-time error if we accidentally try to reassign to this variable without\n"
"using the `let` keyword. By using `let`, we can perform a few transformations\n"
"on a value but have the variable be immutable after those transformations have\n"
"been completed."
msgstr ""
"El sombreado es diferente de marcar una variable como `mut`, porque obtendremos \n"
"un error en tiempo de compilación si intentamos reasignar a esta variable sin usar "
"la \n"
"palabra clave `let`. Al usar `let`, podemos realizar algunas transformaciones en "
"un \n"
"valor pero hacer que la variable sea inmutable después de que se hayan completado \n"
"esas transformaciones."

#: src/ch02-01-variables-and-mutability.md:199
msgid ""
"Another distinction between `mut` and shadowing is that when we use the `let` "
"keyword again,\n"
"we are effectively creating a new variable, which allows us to change the type of "
"the\n"
"value while reusing the same name. As mentioned before, variable shadowing and "
"mutable variables\n"
"are equivalent at the lower level.\n"
"The only difference is that by shadowing a variable, the compiler will not "
"complaing\n"
"if you change its type. For example, say our program performs a type conversion "
"between the\n"
"`u64` and `felt252` types."
msgstr ""
"Otra diferencia entre `mut` y el sombreado es que al usar la palabra clave `let` "
"nuevamente, \n"
"estamos creando efectivamente una nueva variable, lo que nos permite cambiar el "
"tipo del valor \n"
"mientras reutilizamos el mismo nombre. Como se mencionó antes, el sombreado de "
"variables y las \n"
"variables mutables son equivalentes a un nivel más bajo. \n"
"La única diferencia es que al sombrear una \n"
"variable, el compilador no se quejará si cambia su tipo. Por ejemplo, digamos que "
"nuestro programa \n"
"realiza una conversión de tipo entre los tipos `u64` y `felt252`."

#: src/ch02-01-variables-and-mutability.md:207
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let x = 2_u64;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is "
"required.\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let x = 2_u64;\n"
"    x.print();\n"
"    let x: felt252 = x.into(); // converts x to a felt, type annotation is "
"required.\n"
"    x.print()\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:218
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type.\n"
"Shadowing thus spares us from having to come up with different names, such as "
"`x_u64`\n"
"and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we try to "
"use\n"
"`mut` for this, as shown here, we’ll get a compile-time error:"
msgstr ""
"El primer variable `x` tiene un tipo `u64`, mientras que la segunda variable `x` "
"tiene un tipo `felt252`.\n"
"Por lo tanto, el shadowing nos ahorra tener que inventar diferentes nombres, como "
"`x_u64` y `x_felt252`; \n"
"en su lugar, podemos reutilizar el nombre más simple `x`. Sin embargo, si "
"intentamos usar `mut` para esto, \n"
"como se muestra aquí, obtendremos un error en tiempo de compilación:"

#: src/ch02-01-variables-and-mutability.md:223
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let mut x = 2_u64;\n"
"    x.print();\n"
"    x = x.into();\n"
"    x.print()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"use traits::Into;\n"
"fn main() {\n"
"    let mut x = 2_u64;\n"
"    x.print();\n"
"    x = x.into();\n"
"    x.print()\n"
"}\n"
"```"

#: src/ch02-01-variables-and-mutability.md:234
msgid ""
"The error says we’re were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""
"El error dice que se esperaba un `u64` (el tipo original) pero se obtuvo un tipo "
"diferente:"

#: src/ch02-01-variables-and-mutability.md:236
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::"
"felt252\".\n"
" --> lib.cairo:6:9\n"
"    x = x.into();\n"
"        ^******^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"
msgstr ""
"```console\n"
"❯ cairo-run src/lib.cairo\n"
"error: Unexpected argument type. Expected: \"core::integer::u64\", found: \"core::"
"felt252\".\n"
" --> lib.cairo:6:9\n"
"    x = x.into();\n"
"        ^******^\n"
"\n"
"Error: failed to compile: src/lib.cairo\n"
"```"

#: src/ch02-01-variables-and-mutability.md:246
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types they\n"
"can have."
msgstr ""
"Ahora que hemos explorado cómo funcionan las variables, veamos otros tipos de datos "
"que pueden tener."

#: src/ch02-02-data-types.md:1
msgid "## Data Types"
msgstr "## Tipos de datos"

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what kind of\n"
"data is being specified so it knows how to work with that data. This section covers "
"two subsets of data types: scalars and compounds."
msgstr ""
"Cada valor en Cairo tiene un cierto _tipo de dato_, lo que le dice a Cairo qué tipo "
"de\n"
" datos se están especificando para que sepa cómo trabajar con esos datos. Esta "
"sección cubre dos subconjuntos de tipos de \n"
"datos: escalares y compuestos."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that it\n"
"must know the types of all variables at compile time. The compiler can usually "
"infer the desired type based on the value and its usage. In cases\n"
"when many types are possible, we can use a cast method where we specify the desired "
"output type."
msgstr ""
"Tenga en cuenta que Cairo es un lenguaje _de tipado estático_, lo que significa que "
"debe\n"
" conocer los tipos de todas las variables en tiempo de compilación. El compilador "
"suele inferir el tipo deseado en función del valor y su uso. En casos \n"
"en que pueden ser posibles varios tipos, podemos utilizar un método de conversión "
"donde especificamos el tipo de salida deseado."

#: src/ch02-02-data-types.md:10
msgid ""
"```Rust\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"fn main(){\n"
"    let x = 3;\n"
"    let y:u32 = x.try_into().unwrap();\n"
"}\n"
"```"
msgstr ""
"```Rust\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"fn main(){\n"
"    let x = 3;\n"
"    let y:u32 = x.try_into().unwrap();\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:19
msgid "You’ll see different type annotations for other data types."
msgstr "Verá diferentes anotaciones de tipo para otros tipos de datos."

#: src/ch02-02-data-types.md:21
msgid "### Scalar Types"
msgstr "### Tipos escalares"

#: src/ch02-02-data-types.md:23
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar types:\n"
"felts, integers, and booleans. You may recognize\n"
"these from other programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Un tipo _scalar_ representa un único valor. Cairo tiene tres tipos escalares "
"primarios:\n"
"fieltros, enteros y booleanos. Puede que reconozca de otros lenguajes de "
"programación. Veamos cómo funcionan en Cairo."

#: src/ch02-02-data-types.md:27
msgid "#### Felt Type"
msgstr "#### Tipo Felt"

#: src/ch02-02-data-types.md:29
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the context "
"of Cairo, when we say “a field element” we mean an integer in the range `0 <= x < "
"P`,\n"
"where `P` is a very large prime number currently equal to `P = 2^{251} + 17 * "
"2^{192}+1`. When adding, subtracting, or multiplying, if the result falls outside "
"the specified range of the prime number, an overflow occurs, and an appropriate "
"multiple of P is added or subtracted to bring the result back within the range (i."
"e., the result is computed modulo P)."
msgstr ""
"En Cairo, si no especificas el tipo de una variable o argumento, su tipo por "
"defecto es un elemento de campo, representado por la palabra clave `felt252`. En el "
"contexto de Cairo, cuando decimos \"un elemento de campo\" nos referimos a un "
"entero en el rango `0 <= x < P`,\n"
" donde `P` es un número primo muy grande actualmente igual a `P = 2^{251} + 17 * "
"2^{192}+1`. Al sumar, restar o multiplicar, si el resultado queda fuera del rango "
"especificado del número primo, se produce un desbordamiento y se suma o resta un "
"múltiplo apropiado de P para que el resultado vuelva a estar dentro del rango (es "
"decir, el resultado se calcula módulo P)."

#: src/ch02-02-data-types.md:32
msgid ""
"The most important difference between integers and field elements is division: "
"Division of field elements (and therefore division in Cairo) is unlike regular CPUs "
"division, where\n"
"integer division `x / y` is defined as `[x/y]` where the integer part of the "
"quotient is returned (so you get `7 / 3 = 2`) and it may or may not satisfy the "
"equation `(x / y) * y == x`,\n"
"depending on the divisibility of `x` by `y`."
msgstr ""
"La diferencia más importante entre los números enteros y los elementos de campo es "
"la división: La división de elementos de campo (y, por tanto, la división en Cairo) "
"es distinta de la división normal de las CPU, en la que\n"
"la división entera `x / y` se define como `[x/y]` donde se devuelve la parte entera "
"del cociente (por lo que se obtiene `7 / 3 = 2`) y puede o no satisfacer la "
"ecuación `(x / y) * y == x`, dependiendo de la divisibilidad de `x` por `y`."

#: src/ch02-02-data-types.md:36
msgid ""
"In Cairo, the result of `x/y` is defined to always satisfy the equation `(x / y) * "
"y == x`. If y divides x as integers, you will get the expected result in Cairo (for "
"example `6 / 2`\n"
"will indeed result in `3`).\n"
"But when y does not divide x, you may get a surprising result: For example, since "
"`2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, the value of `1 / 2` in Cairo is `(P+1)/2` (and "
"not 0 or 0.5), as it satisfies the above equation."
msgstr ""
"En Cairo, el resultado de `x/y` está definido para satisfacer siempre la ecuación "
"`(x / y) * y == x`. Si `y` divide a `x` entre enteros, obtendrás el resultado "
"esperado en Cairo (por ejemplo `6 / 2`\n"
" dará como resultado `3`).\n"
"Pero cuando `y` no divide a `x`, puedes obtener un resultado sorprendente: Por "
"ejemplo, como `2 * ((P+1)/2) = P+1 ≡ 1 mod[P]`, el valor de `1 / 2` en Cairo es `(P"
"+1)/2` (y no 0 ó 0,5), ya que satisface la ecuación anterior."

#: src/ch02-02-data-types.md:40
msgid "#### Integer Types"
msgstr "#### Tipos enteros"

#: src/ch02-02-data-types.md:42
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating all "
"types in the core library.\n"
"However, it is highly recommended for programmers to use the integer types instead "
"of the `felt252` type whenever possible, as the `integer` types come with added "
"security features that provide extra protection against potential vulnerabilities "
"in the code, such as overflow checks. By using these integer types, programmers can "
"ensure that their programs are more secure and less susceptible to attacks or other "
"security threats.\n"
"An _integer_ is a number without a fractional component. This type declaration "
"indicates the number of bits the programmer can use to store the integer.\n"
"Table 3-1 shows\n"
"the built-in integer types in Cairo. We can use any of these variants to declare\n"
"the type of an integer value."
msgstr ""
"El tipo felt252 es un tipo fundamental que sirve como base para la creación de "
"todos los tipos en la librería central.\n"
"Sin embargo, se recomienda encarecidamente a los programadores que utilicen los "
"tipos enteros en lugar del tipo `felt252` siempre que sea posible, ya que los tipos "
"`integer` vienen con características de seguridad añadidas que proporcionan "
"protección extra contra posibles vulnerabilidades en el código, como comprobaciones "
"de desbordamiento. Utilizando estos tipos de enteros, los programadores pueden "
"asegurarse de que sus programas son más seguros y menos susceptibles a ataques u "
"otras amenazas de seguridad.\n"
"Un _integer_ es un número sin componente fraccionario. Esta declaración de tipo "
"indica el número de bits que el programador puede utilizar para almacenar el "
"entero.\n"
"La Tabla 3-1 muestra \n"
"los tipos enteros incorporados en Cairo. Podemos usar cualquiera de estas variantes "
"para declarar\n"
"el tipo de un valor entero."

#: src/ch02-02-data-types.md:49
msgid "<span class=\"caption\">Table 3-1: Integer Types in Cairo</span>"
msgstr "<span class=\"caption\">Table 3-1: Integer Types in Cairo</span>"

#: src/ch02-02-data-types.md:51
msgid ""
"| Length  | Unsigned |\n"
"| ------- | -------- |\n"
"| 8-bit   | `u8`     |\n"
"| 16-bit  | `u16`    |\n"
"| 32-bit  | `u32`    |\n"
"| 64-bit  | `u64`    |\n"
"| 128-bit | `u128`   |\n"
"| 256-bit | `u256`   |\n"
"| 32-bit  | `usize`  |"
msgstr ""
"| Length  | Unsigned |\n"
"| ------- | -------- |\n"
"| 8-bit   | `u8`     |\n"
"| 16-bit  | `u16`    |\n"
"| 32-bit  | `u32`    |\n"
"| 64-bit  | `u64`    |\n"
"| 128-bit | `u128`   |\n"
"| 256-bit | `u256`   |\n"
"| 32-bit  | `usize`  |"

#: src/ch02-02-data-types.md:61
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is just an "
"alias for `u32`; however, it might be useful when in the future Cairo can be "
"compiled to MLIR.\n"
"As variables are unsigned, they can't contain a negative number. This code will "
"cause the program to panic:"
msgstr ""
"Cada variante tiene un tamaño explícito. Tenga en cuenta que por ahora, el tipo "
"`usize` es sólo un alias para `u32`; sin embargo, podría ser útil cuando en el "
"futuro Cairo pueda ser compilado a MLIR.\n"
"Como las variables son sin signo, no pueden contener un número negativo. Este "
"código hará que el programa entre en pánico:"

#: src/ch02-02-data-types.md:64
msgid ""
"```rust\n"
"fn sub_u8s(x: u8, y: u8) -> u8 {\n"
"    x - y\n"
"}\n"
"\n"
"fn main() {\n"
"    sub_u8s(1, 3);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn sub_u8s(x: u8, y: u8) -> u8 {\n"
"    x - y\n"
"}\n"
"\n"
"fn main() {\n"
"    sub_u8s(1, 3);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:74
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note\n"
"that number literals that can be multiple numeric types allow a type suffix,\n"
"such as `57_u8`, to designate the type."
msgstr ""
"Puede escribir literales enteros en cualquiera de las formas mostradas en la Tabla "
"3-2. Observe\n"
"que los literales numéricos que pueden ser múltiples tipos numéricos permiten un "
"sufijo de tipo\n"
"como `57_u8`, para designar el tipo."

#: src/ch02-02-data-types.md:78
msgid "<span class=\"caption\">Table 3-2: Integer Literals in Cairo</span>"
msgstr "<span class=\"caption\">Table 3-2: Integer Literals in Cairo</span>"

#: src/ch02-02-data-types.md:80
msgid ""
"| Numeric literals | Example   |\n"
"| ---------------- | --------- |\n"
"| Decimal          | `98222`   |\n"
"| Hex              | `0xff`    |\n"
"| Octal            | `0o04321` |\n"
"| Binary           | `0b01`    |"
msgstr ""
"| Numeric literals | Example   |\n"
"| ---------------- | --------- |\n"
"| Decimal          | `98222`   |\n"
"| Hex              | `0xff`    |\n"
"| Octal            | `0o04321` |\n"
"| Binary           | `0b01`    |"

#: src/ch02-02-data-types.md:87
msgid ""
"So how do you know which type of integer to use? Try to estimate the max value your "
"int can have and choose the good size.\n"
"The primary situation in which you’d use `usize` is when indexing some sort of "
"collection."
msgstr ""
"Entonces, ¿cómo saber qué tipo de entero utilizar? Intenta estimar el valor máximo "
"que puede tener tu int y elige un buen tamaño.\n"
"La principal situación en la que usarías `usize` es al indexar algún tipo de "
"colección."

#: src/ch02-02-data-types.md:90
msgid "#### Numeric Operations"
msgstr "#### Operaciones numéricas"

#: src/ch02-02-data-types.md:92
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the integer\n"
"types: addition, subtraction, multiplication, division, and remainder. Integer\n"
"division truncates toward zero to the nearest integer. The following code shows\n"
"how you’d use each numeric operation in a `let` statement:"
msgstr ""
"Cairo soporta las operaciones matemáticas básicas que esperarías para todos los \n"
"tipos de enteros: suma, resta, multiplicación y resto (u256 no soporta división y "
"resto \n"
"todavía). Entero trunca hacia cero al entero más cercano. El siguiente código "
"muestra \n"
"cómo utilizar cada operación numérica en una sentencia `let`:"

#: src/ch02-02-data-types.md:97
msgid ""
"```rust\n"
"fn main() {\n"
"     // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"     // addition\n"
"    let sum = 5_u128 + 10_u128;\n"
"\n"
"    // subtraction\n"
"    let difference = 95_u128 - 4_u128;\n"
"\n"
"    // multiplication\n"
"    let product = 4_u128 * 30_u128;\n"
"\n"
"    // division\n"
"    let quotient = 56_u128 / 32_u128; //result is 1\n"
"    let quotient = 64_u128 / 32_u128; //result is 2\n"
"\n"
"    // remainder\n"
"    let remainder = 43_u128 % 5_u128; // result is 3\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:117
msgid ""
"Each expression in these statements uses a mathematical operator and evaluates\n"
"to a single value, which is then bound to a variable."
msgstr ""
"Cada expresión de estas sentencias utiliza un operador matemático y se evalúa a \n"
"un único valor, que se asigna a una variable."

#: src/ch02-02-data-types.md:120
msgid ""
"<!-- TODO: Appendix operator -->\n"
"<!-- [Appendix B][appendix_b] ignore contains a list of all operators that Cairo "
"provides. -->"
msgstr ""
"<!-- TODO: Appendix operator -->\n"
"<!-- [Appendix B][appendix_b] ignore contains a list of all operators that Cairo "
"provides. -->"

#: src/ch02-02-data-types.md:123
msgid "#### The Boolean Type"
msgstr "#### El tipo Booleano"

#: src/ch02-02-data-types.md:125
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two possible\n"
"values: `true` and `false`. Booleans are one felt252 in size. The Boolean type in\n"
"Cairo is specified using `bool`. For example:"
msgstr ""
"Como en la mayoría de los lenguajes de programación, un tipo booleano en Cairo "
"tiene \n"
"dos posibles valores: `true` y `false`. Los booleanos tienen un byte de tamaño. El "
"tipo booleano \n"
"en Cairo se especifica usando `bool`. Por ejemplo:"

#: src/ch02-02-data-types.md:129
msgid ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let t = true;\n"
"\n"
"    let f: bool = false; // with explicit type annotation\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:139
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if`\n"
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control\n"
"Flow”][control-flow] section."
msgstr ""
"La principal forma de utilizar valores booleanos es a través de condicionales, \n"
"como una expresión `if` expresión. Cubriremos cómo funcionan las expresiones `if` \n"
"en Cairo en la sección. [“Control de flujo”][control-de-flujo]"

#: src/ch02-02-data-types.md:143
msgid "#### The Short String Type"
msgstr "#### El tipo de Short String"

#: src/ch02-02-data-types.md:145
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters forming "
"what we call a \"short string\" inside `felt252`s. A short string has a max length "
"of 31 chars. This is to ensure that it can fit in a single felt (a felt is 252 "
"bits, one ASCII char is 8 bits).\n"
"Here are some examples of declaring values by putting them between single quotes:"
msgstr ""
"Cairo no tiene un tipo nativo para strings, pero puedes almacenar caracteres "
"formando lo que llamamos un \"short string\" dentro de `felt252`. Una cadena corta "
"tiene una longitud máxima de 31 caracteres. Esto es para asegurar que puede caber "
"en un solo felt (un felt son 252 bits, un char ASCII son 8 bits).\n"
"He aquí algunos ejemplos de declaración de valores entre comillas simples:"

#: src/ch02-02-data-types.md:148
msgid ""
"```rust\n"
"let my_first_char = 'C';\n"
"let my_first_string = 'Hello world';\n"
"```"
msgstr ""
"```rust\n"
"let my_first_char = 'C';\n"
"let my_first_string = 'Hello world';\n"
"```"

#: src/ch02-02-data-types.md:153
msgid "### Type casting"
msgstr "### Conversión de Tipos"

#: src/ch02-02-data-types.md:155
msgid ""
"In Cairo, you can convert values between common scalar types and `felt252` using "
"the `try_into` and `into` methods provided by the `TryInto` and `Into` traits, "
"respectively."
msgstr ""
"En Cairo, puedes convertir valores entre tipos escalares comunes y `felt252` usando "
"los métodos `try_into` e `into` proporcionados por los traits `TryInto` e `Into`, "
"respectivamente."

#: src/ch02-02-data-types.md:157
msgid ""
"The `try_into` method allows for safe type casting when the target type might not "
"fit the source value. Keep in mind that `try_into` returns an `Option<T>` type, "
"which you'll need to unwrap to access the new value."
msgstr ""
"El método `try_into` permite una conversión de tipos segura cuando el tipo de "
"destino puede no encajar con el valor de origen. Ten en cuenta que `try_into` "
"devuelve un tipo `Option<T>`, que tendrás que desenvolver para acceder al nuevo "
"valor."

#: src/ch02-02-data-types.md:159
msgid ""
"On the other hand, the `into` method can be used for type casting when success is "
"guaranteed, such as when the source type is smaller than the destination type."
msgstr ""
"Por otro lado, el método `into` se puede utilizar para la conversión de tipos "
"cuando el éxito está garantizado, como cuando el tipo de destino es más pequeño que "
"el tipo de origen."

#: src/ch02-02-data-types.md:161
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the source "
"value to cast it to another type. The new variable's type must be explicitly "
"defined, as demonstrated in the example below."
msgstr ""
"Para realizar la conversión, llame a `var.into()` o `var.try_into()` sobre el valor "
"fuente para convertirlo a otro tipo. El tipo de la nueva variable debe definirse "
"explícitamente, como se muestra en el siguiente ejemplo."

#: src/ch02-02-data-types.md:163
msgid ""
"```rust\n"
"use traits::TryInto;\n"
"use traits::Into;\n"
"use option::OptionTrait;\n"
"\n"
"fn main(){\n"
"    let my_felt = 10;\n"
"    let my_u8: u8 = my_felt.try_into().unwrap(); // Since a felt252 might not fit "
"in a u8, we need to unwrap the Option<T> type\n"
"    let my_u16: u16 = my_felt.try_into().unwrap();\n"
"    let my_u32: u32 = my_felt.try_into().unwrap();\n"
"    let my_u64: u64 = my_felt.try_into().unwrap();\n"
"    let my_u128: u128 = my_felt.try_into().unwrap();\n"
"    let my_u256: u256 = my_felt.into(); // As a felt252 is smaller than a u256, we "
"can use the into() method\n"
"    let my_usize: usize = my_felt.try_into().unwrap();\n"
"    let my_felt2: felt252 = my_u8.into();\n"
"    let my_felt3: felt252 = my_u16.into();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use traits::TryInto;\n"
"use traits::Into;\n"
"use option::OptionTrait;\n"
"\n"
"fn main(){\n"
"    let my_felt = 10;\n"
"    let my_u8: u8 = my_felt.try_into().unwrap(); // Since a felt252 might not fit "
"in a u8, we need to unwrap the Option<T> type\n"
"    let my_u16: u16 = my_felt.try_into().unwrap();\n"
"    let my_u32: u32 = my_felt.try_into().unwrap();\n"
"    let my_u64: u64 = my_felt.try_into().unwrap();\n"
"    let my_u128: u128 = my_felt.try_into().unwrap();\n"
"    let my_u256: u256 = my_felt.into(); // As a felt252 is smaller than a u256, we "
"can use the into() method\n"
"    let my_usize: usize = my_felt.try_into().unwrap();\n"
"    let my_felt2: felt252 = my_u8.into();\n"
"    let my_felt3: felt252 = my_u16.into();\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:182
msgid "### The Tuple Type"
msgstr "### El Tipo Tupla"

#: src/ch02-02-data-types.md:184
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a\n"
"variety of types into one compound type. Tuples have a fixed length: once\n"
"declared, they cannot grow or shrink in size."
msgstr ""
"Una _tupla_ es una forma general de agrupar un número de valores con una variedad \n"
"de tipos en un tipo compuesto. Las tuplas tienen una longitud fija: una vez "
"declaradas, \n"
"no pueden aumentar ni disminuir de tamaño."

#: src/ch02-02-data-types.md:188
msgid ""
"We create a tuple by writing a comma-separated list of values inside\n"
"parentheses. Each position in the tuple has a type, and the types of the\n"
"different values in the tuple don’t have to be the same. We’ve added optional\n"
"type annotations in this example:"
msgstr ""
"Se crea una tupla escribiendo una lista de valores separados por comas entre \n"
"paréntesis. Cada posición de la tupla tiene un tipo, y los tipos de los distintos "
"valores\n"
" de la tupla no tienen por qué ser iguales. Hemos añadido anotaciones opcionales "
"de \n"
"tipo en este ejemplo:"

#: src/ch02-02-data-types.md:193
msgid ""
"```rust\n"
"fn main() {\n"
"    let tup: (u32,u64,bool) = (10,20,true);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let tup: (u32,u64,bool) = (10,20,true);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:199
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a\n"
"single compound element. To get the individual values out of a tuple, we can\n"
"use pattern matching to destructure a tuple value, like this:"
msgstr ""
"La variable `tup` se vincula a toda la tupla porque una tupla se considera un "
"único\n"
" elemento compuesto. Para obtener los valores individuales de una tupla, podemos \n"
"utilizar la concordancia de patrones para desestructurar un valor de tupla, así:"

#: src/ch02-02-data-types.md:203
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let tup = (500, 6, true);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    if y == 6 {\n"
"        'y is six!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let tup = (500, 6, true);\n"
"\n"
"    let (x, y, z) = tup;\n"
"\n"
"    if y == 6 {\n"
"        'y is six!'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:216
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It then\n"
"uses a pattern with `let` to take `tup` and turn it into three separate\n"
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks\n"
"the single tuple into three parts. Finally, the program prints `y is six` as the "
"value of\n"
"`y` is `6`."
msgstr ""
"Este programa crea primero una tupla y la asocia a la variable `tup`. A "
"continuación, \n"
"utiliza un patrón con `let` para tomar `tup` y convertirla en tres variables "
"separadas,\n"
" `x`, `y`, y `z`. Esto se llama _desestructuración_ porque divide la tupla en tres "
"partes. \n"
"Finalmente, el programa imprime `y es seis` ya que el valor de `y` es `6`."

#: src/ch02-02-data-types.md:222
msgid ""
"We can also declare the tuple with value and name at the same time.\n"
"For example:"
msgstr ""
"También podemos declarar la tupla con valor y nombre al mismo tiempo.\n"
"Por ejemplo:"

#: src/ch02-02-data-types.md:225
msgid ""
"```rust\n"
"fn main() {\n"
"    let (x, y): (felt252, felt252) = (2, 3);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let (x, y): (felt252, felt252) = (2, 3);\n"
"}\n"
"```"

#: src/ch02-02-data-types.md:231
msgid "### The unit type ()"
msgstr "### The unit type ()"

#: src/ch02-02-data-types.md:233
msgid ""
"A _unit type_ is a type which has only one value `()`.\n"
"It is represented by a tuple with no elements.\n"
"Its size is always zero, and it is guaranteed to not exist in the compiled code."
msgstr ""
"Un _tipo unitario_ es un tipo que sólo tiene un valor `()`.\n"
"Se representa mediante una tupla sin elementos.\n"
"Su tamaño es siempre cero y se garantiza que no existe en el código compilado."

#: src/ch02-03-functions.md:1
msgid "## Functions"
msgstr "## Funciones"

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most\n"
"important functions in the language: the `main` function, which is the entry\n"
"point of many programs. You’ve also seen the `fn` keyword, which allows you to\n"
"declare new functions."
msgstr ""
"Las funciones son frecuentes en el código de Cairo. Ya has visto una de las \n"
"funciones más importantes del lenguaje: la función `main`, que es el punto de \n"
"entrada de muchos programas. También has visto la palabra clave `fn`, que te \n"
"permite declarar nuevas funciones."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses *snake case* as the conventional style for function and variable\n"
"names, in which all letters are lowercase and underscores separate words.\n"
"Here’s a program that contains an example function definition:"
msgstr ""
"El código de Cairo usa *snake case* como estilo convencional para los nombres de \n"
"funciones y variables, en el que todas las letras están en minúsculas y los "
"guiones\n"
" bajos separan las palabras.\n"
"Aquí hay un programa que contiene un ejemplo de definición de función:"

#: src/ch02-03-functions.md:13
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn another_function() {\n"
"    'Another function.'.print();\n"
"}\n"
"\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"    another_function();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn another_function() {\n"
"    'Another function.'.print();\n"
"}\n"
"\n"
"fn main() {\n"
"    'Hello, world!'.print();\n"
"    another_function();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:26
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name and a\n"
"set of parentheses. The curly brackets tell the compiler where the function\n"
"body begins and ends."
msgstr ""
"Definimos una función en Cairo introduciendo `fn` seguido de un nombre de función y "
"un\n"
"conjunto de paréntesis. Las llaves indican al compilador dónde empieza y termina "
"el\n"
" cuerpo de la función."

#: src/ch02-03-functions.md:30
msgid ""
"We can call any function we’ve defined by entering its name followed by a set\n"
"of parentheses. Because `another_function` is defined in the program, it can be\n"
"called from inside the `main` function. Note that we defined `another_function`\n"
"*before* the `main` function in the source code; we could have defined it after\n"
"as well. Cairo doesn’t care where you define your functions, only that they’re\n"
"defined somewhere in a scope that can be seen by the caller."
msgstr ""
"Podemos llamar a cualquier función que hayamos definido introduciendo su nombre \n"
"seguido de un conjunto de paréntesis. Como `another_function` está definida en el \n"
"programa, puede ser llamada desde dentro de la función `main`. Ten en cuenta que \n"
"hemos definido \"another_function\" *antes* de la función `main` en el código "
"fuente; \n"
"también podríamos haberla definido después. A Cairo no le importa dónde definas "
"tus \n"
"funciones, sólo que estén definidas en algún lugar en un ámbito que pueda ser visto "
"por quien las llama."

#: src/ch02-03-functions.md:37
msgid ""
"Let’s start a new project with Scarb named *functions* to explore functions\n"
"further. Place the `another_function` example in *src/lib.cairo* and run it. You\n"
"should see the following output:"
msgstr ""
"Empecemos un nuevo proyecto con Scarb llamado *functions* para explorar las \n"
"funciones. Coloque el ejemplo `another_function` en *src/lib.cairo* y ejecútelo. "
"Usted\n"
"Debería ver la siguiente salida:"

#: src/ch02-03-functions.md:41
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)\n"
"[DEBUG] Another function.            (raw: "
"22265147635379277118623944509513687592494)\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)\n"
"[DEBUG] Another function.            (raw: "
"22265147635379277118623944509513687592494)\n"
"```"

#: src/ch02-03-functions.md:47
msgid ""
"The lines execute in the order in which they appear in the `main` function.\n"
"First the “Hello, world!” message prints, and then `another_function` is called\n"
"and its message is printed."
msgstr ""
"Las líneas se ejecutan en el orden en que aparecen en la función `main`.\n"
"Primero se imprime el mensaje \" Hello, world!\", y luego se llama a "
"`another_function`\n"
" y se imprime su mensaje."

#: src/ch02-03-functions.md:51
msgid "### Parameters"
msgstr "### Parámetros"

#: src/ch02-03-functions.md:53
msgid ""
"We can define functions to have *parameters*, which are special variables that\n"
"are part of a function’s signature. When a function has parameters, you can\n"
"provide it with concrete values for those parameters. Technically, the concrete\n"
"values are called *arguments*, but in casual conversation, people tend to use\n"
"the words *parameter* and *argument* interchangeably for either the variables\n"
"in a function’s definition or the concrete values passed in when you call a\n"
"function."
msgstr ""
"Podemos definir funciones para que tengan *parámetros*, que son variables "
"especiales \n"
"que forman parte de la firma de una función. Cuando una función tiene parámetros, \n"
"puede proporcionarle valores concretos para esos parámetros. Técnicamente, los "
"valores\n"
"se llaman *argumentos*, pero en una conversación informal, la gente tiende a usar\n"
"las palabras *parámetro* y *argumento* indistintamente para las variables\n"
"en la definición de una función o los valores concretos pasados cuando se llama a "
"una\n"
"función."

#: src/ch02-03-functions.md:61
msgid "In this version of `another_function` we add a parameter:"
msgstr "En esta versión de `another_function` añadimos un parámetro:"

#: src/ch02-03-functions.md:63
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: felt252) {\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5);\n"
"}\n"
"\n"
"fn another_function(x: felt252) {\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:75
msgid "Try running this program; you should get the following output:"
msgstr "Intente ejecutar este programa; debería obtener la siguiente salida:"

#: src/ch02-03-functions.md:77 src/ch02-03-functions.md:250
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"```"

#: src/ch02-03-functions.md:82
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type of\n"
"`x` is specified as `felt252`. When we pass `5` in to `another_function`, the\n"
"`.print()` function outputs `5` in the console."
msgstr ""
"La declaración de `another_function` tiene un parámetro llamado `x`. El tipo de\n"
"`x` se especifica como `felt252`. Cuando pasamos `5` a `another_function`, la "
"función\n"
"`print()` muestra `5` en la consola."

#: src/ch02-03-functions.md:86
msgid ""
"In function signatures, you *must* declare the type of each parameter. This is\n"
"a deliberate decision in Cairo’s design: requiring type annotations in function\n"
"definitions means the compiler almost never needs you to use them elsewhere in\n"
"the code to figure out what type you mean. The compiler is also able to give\n"
"more helpful error messages if it knows what types the function expects."
msgstr ""
"En las firmas de función, *debes* declarar el tipo de cada parámetro. Esta es\n"
"una decisión deliberada en el diseño de Cairo: requerir anotaciones de tipo en las\n"
"significa que el compilador casi nunca necesita usarlas en otra parte del código\n"
"el código para averiguar a qué tipo se refiere. El compilador también es capaz de "
"dar\n"
"mensajes de error más útiles si sabe qué tipos espera la función."

#: src/ch02-03-functions.md:92
msgid ""
"When defining multiple parameters, separate the parameter declarations with\n"
"commas, like this:"
msgstr ""
"Cuando defina múltiples parámetros, separe las declaraciones de parámetros con\n"
"comas, así:"

#: src/ch02-03-functions.md:95
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5,6);\n"
"}\n"
"\n"
"fn another_function(x: felt252, y:felt252) {\n"
"    x.print();\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    another_function(5,6);\n"
"}\n"
"\n"
"fn another_function(x: felt252, y:felt252) {\n"
"    x.print();\n"
"    y.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:108
msgid ""
"This example creates a function named `another_function` with two\n"
"parameters. The first parameter is named `x` and is an `felt252`. The second is\n"
"named `y` and is type `felt252` too. The function then prints the content of the "
"felt `x` and then the content of the felt `y`."
msgstr ""
"Este ejemplo crea una función llamada `another_function` con dos parámetros. El "
"primer \n"
"parámetro se llama `x` y es un `felt252`. El segundo se llama `y` y también es del "
"tipo `felt252`. \n"
"La función luego imprime el contenido del `x` y luego el contenido del `y`."

#: src/ch02-03-functions.md:112
msgid ""
"Let’s try running this code. Replace the program currently in your *functions*\n"
"project’s *src/lib.cairo* file with the preceding example and run it using `cairo-"
"run src/lib.cairo`:"
msgstr ""
"Intentemos ejecutar este código. Reemplaza el programa actualmente en el archivo \n"
"*src/lib.cairo* de tu proyecto *functions* con el ejemplo anterior y ejecútalo "
"usando `cairo-run src/lib.cairo`"

#: src/ch02-03-functions.md:115
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"[DEBUG]                                 (raw: 6)\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG]                                 (raw: 5)\n"
"[DEBUG]                                 (raw: 6)\n"
"```"

#: src/ch02-03-functions.md:121
msgid ""
"Because we called the function with `5` as the value for `x` and `6` as\n"
"the value for `y`, the program output contains those values."
msgstr ""
"Debido a que llamamos a la función con `5` como valor para `x` y `6` como valor\n"
" para `y`, la salida del programa contiene esos valores."

#: src/ch02-03-functions.md:124
msgid "### Statements and Expressions"
msgstr "### Declaraciones y Expresiones"

#: src/ch02-03-functions.md:126
msgid ""
"Function bodies are made up of a series of statements optionally ending in an\n"
"expression. So far, the functions we’ve covered haven’t included an ending\n"
"expression, but you have seen an expression as part of a statement. Because\n"
"Cairo is an expression-based language, this is an important distinction to\n"
"understand. Other languages don’t have the same distinctions, so let’s look at\n"
"what statements and expressions are and how their differences affect the bodies\n"
"of functions."
msgstr ""
"Los cuerpos de las funciones están compuestos por una serie de sentencias que \n"
"terminan opcionalmente en una expresión. Hasta ahora, las funciones que hemos \n"
"cubierto no han incluido una expresión final, pero ya has visto una expresión como "
"parte \n"
"de una sentencia. Como Cairo es un lenguaje basado en expresiones, esta es una \n"
"distinción importante que debemos entender. Otros lenguajes no tienen las mismas \n"
"distinciones, así que veamos qué son las sentencias y expresiones y cómo sus "
"diferencias \n"
"afectan los cuerpos de las funciones."

#: src/ch02-03-functions.md:134
msgid ""
"* **Statements** are instructions that perform some action and do not return\n"
"  a value.\n"
"* **Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr ""
"* **Declaraciones** son instrucciones que realizan alguna acción y no devuelven un "
"valor.\n"
"* **Expresiones** se evalúan para producir un valor resultante. Veamos algunos "
"ejemplos."

#: src/ch02-03-functions.md:138
msgid ""
"We’ve actually already used statements and expressions. Creating a variable and\n"
"assigning a value to it with the `let` keyword is a statement. In Listing 3-1,\n"
"`let y = 6;` is a statement."
msgstr ""
"De hecho, ya hemos utilizado declaraciones y expresiones. Crear una variable y \n"
"asignarle  un valor con la palabra clave `let` es una declaración. En el Listado "
"3-1,\n"
" `let y = 6;` es una declaración."

#: src/ch02-03-functions.md:142
msgid ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let y = 6;\n"
"}\n"
"```"

#: src/ch02-03-functions.md:148
msgid ""
"<span class=\"caption\">Listing 3-1: A `main` function declaration containing one "
"statement</span>"
msgstr ""
"<span class=\"caption\">Listing 3-1: A `main` function declaration containing one "
"statement</span>"

#: src/ch02-03-functions.md:150
msgid ""
"Function definitions are also statements; the entire preceding example is a\n"
"statement in itself."
msgstr ""
"Las definiciones de funciones también son sentencias; todo el ejemplo anterior \n"
"es una sentencia en sí misma."

#: src/ch02-03-functions.md:153
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` statement\n"
"to another variable, as the following code tries to do; you’ll get an error:"
msgstr ""
"Las Declaraciones no devuelven valores. Por lo tanto, no se puede asignar una "
"sentencia \n"
"`let` a otra variable, como intenta hacer el siguiente código; se producirá un "
"error:"

#: src/ch02-03-functions.md:156
msgid ""
"```rust\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let x = (let y = 6);\n"
"}\n"
"```"

#: src/ch02-03-functions.md:161
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "Cuando ejecutes este programa, el error que obtendrás se verá así:"

#: src/ch02-03-functions.md:162
msgid ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"error: Missing token TerminalRParen.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"                      ^\n"
"\n"
"error: Skipped tokens. Expected: statement.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run src/lib.cairo\n"
"error: Missing token TerminalRParen.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"             ^\n"
"\n"
"error: Missing token TerminalSemicolon.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"                      ^\n"
"\n"
"error: Skipped tokens. Expected: statement.\n"
" --> src/lib.cairo:2:14\n"
"    let x = (let y = 6);\n"
"```"

#: src/ch02-03-functions.md:184
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything for\n"
"`x` to bind to. This is different from what happens in other languages, such as\n"
"C and Ruby, where the assignment returns the value of the assignment. In those\n"
"languages, you can write `x = y = 6` and have both `x` and `y` have the value\n"
"`6`; that is not the case in Cairo."
msgstr ""
"La declaración `let y = 6` no devuelve un valor, por lo que no hay nada a lo que "
"`x`\n"
" pueda enlazar. Esto es diferente de lo que sucede en otros lenguajes, como C y "
"Ruby, \n"
"donde la asignación devuelve el valor de la asignación. En esos lenguajes, puedes "
"escribir\n"
" `x = y = 6` y tanto `x` como `y` tendrán el valor `6`; esto no es así en Cairo."

#: src/ch02-03-functions.md:190
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code that\n"
"you’ll write in Cairo. Consider a math operation, such as `5 + 6`, which is an\n"
"expression that evaluates to the value `11`. Expressions can be part of\n"
"statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an\n"
"expression that evaluates to the value `6`. Calling a function is an\n"
"expression. A new scope block created with\n"
"curly brackets is an expression, for example:"
msgstr ""
"Las expresiones evalúan a un valor y componen la mayor parte del código que \n"
"escribirás en Cairo. Considera una operación matemática, como `5 + 6`, que es \n"
"una expresión que evalúa al valor `11`. Las expresiones pueden formar parte de \n"
"las declaraciones: en el Listado 3-1, el `6` en la declaración `let y = 6;` es una "
"expresión \n"
"que evalúa al valor `6`. Llamar a una función es una expresión. Un bloque de "
"ámbito\n"
" nuevo creado con llaves es una expresión, por ejemplo:"

#: src/ch02-03-functions.md:199
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    y.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let y = {\n"
"        let x = 3;\n"
"        x + 1\n"
"    };\n"
"\n"
"    y.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:211
msgid "This expression:"
msgstr "Esta expresión:"

#: src/ch02-03-functions.md:212
msgid ""
"```rust\n"
"{\n"
"    let x = 3;\n"
"    x + 1\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"{\n"
"    let x = 3;\n"
"    x + 1\n"
"}\n"
"```"

#: src/ch02-03-functions.md:218
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to `y`\n"
"as part of the `let` statement. Note that the `x + 1` line doesn’t have a\n"
"semicolon at the end, which is unlike most of the lines you’ve seen so far.\n"
"Expressions do not include ending semicolons. If you add a semicolon to the end\n"
"of an expression, you turn it into a statement, and it will then not return a\n"
"value. Keep this in mind as you explore function return values and expressions\n"
"next."
msgstr ""
"este bloque de código, en este caso, se evalúa como 4. Ese valor se asigna\n"
" a y como parte de la declaración let. Ten en cuenta que la línea x + 1 no tiene\n"
" un punto y coma al final, lo que es diferente a la mayoría de las líneas que has \n"
"visto hasta ahora. Las expresiones no incluyen un punto y coma al final. Si "
"agregas\n"
" un punto y coma al final de una expresión, la conviertes en una declaración, y "
"en \n"
"ese caso no se devolverá ningún valor. Tenlo en cuenta mientras exploras los \n"
"valores de retorno de las funciones y las expresiones a continuación."

#: src/ch02-03-functions.md:225
msgid "### Functions with Return Values"
msgstr "### Funciones con Valores de Retorno"

#: src/ch02-03-functions.md:226
msgid ""
"Functions can return values to the code that calls them. We don’t name return\n"
"values, but we must declare their type after an arrow (`->`). In Cairo, the\n"
"return value of the function is synonymous with the value of the final\n"
"expression in the block of the body of a function. You can return early from a\n"
"function by using the `return` keyword and specifying a value, but most\n"
"functions return the last expression implicitly. Here’s an example of a\n"
"function that returns a value:"
msgstr ""
"Las funciones pueden devolver valores al código que las llama. No nombramos \n"
"los valores de retorno, pero debemos declarar su tipo después de una flecha (`-"
">`).\n"
" En Cairo, el valor de retorno de la función es sinónimo del valor de la última "
"expresión \n"
"en el bloque del cuerpo de una función. Puede salir temprano de una función usando "
"la \n"
"palabra clave `return` y especificando un valor, pero la mayoría de las funciones "
"devuelven\n"
" la última expresión implícitamente. Aquí hay un ejemplo de una función que "
"devuelve un valor:"

#: src/ch02-03-functions.md:234
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn five() -> u32 {\n"
"    5_u32\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"    x.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn five() -> u32 {\n"
"    5_u32\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = five();\n"
"    x.print();\n"
"}\n"
"```"

#: src/ch02-03-functions.md:246
msgid ""
"There are no function calls, or even `let` statements in the `five`\n"
"function—just the number `5` by itself. That’s a perfectly valid function in\n"
"Cairo. Note that the function’s return type is specified too, as `-> u32`. Try\n"
"running this code; the output should look like this:"
msgstr ""
"No hay llamadas a funciones ni declaraciones `let` en la función `five`, solo \n"
"el número `5` por sí mismo. Esa es una función perfectamente válida en Cairo.\n"
" Observa que se especifica el tipo de retorno de la función como `-> u32`. Intenta\n"
" ejecutar este código; la salida debería verse así:"

#: src/ch02-03-functions.md:254
msgid ""
"The `5` in `five` is the function’s return value, which is why the return type\n"
"is `u32`. Let’s examine this in more detail. There are two important bits:\n"
"first, the line `let x = five();` shows that we’re using the return value of a\n"
"function to initialize a variable. Because the function `five` returns a `5`,\n"
"that line is the same as the following:"
msgstr ""
"El `5` en `five` es el valor de retorno de la función, por eso el tipo de retorno\n"
" es `u32`. Vamos a examinar esto con más detalle. Hay dos partes importantes: \n"
"en primer lugar, la línea `let x = five();` muestra que estamos usando el valor "
"de \n"
"retorno de una función para inicializar una variable. Debido a que la función "
"`five` \n"
"devuelve un `5`, esa línea es lo mismo que:"

#: src/ch02-03-functions.md:259
msgid ""
"```rust\n"
"let x = 5;\n"
"```"
msgstr ""
"```rust\n"
"let x = 5;\n"
"```"

#: src/ch02-03-functions.md:262
msgid ""
"Second, the `five` function has no parameters and defines the type of the\n"
"return value, but the body of the function is a lonely `5` with no semicolon\n"
"because it’s an expression whose value we want to return.\n"
"Let’s look at another example:"
msgstr ""
"Segundo, la función `five` no tiene parámetros y define el tipo del valor de "
"retorno, \n"
"pero el cuerpo de la función es simplemente `5` sin un punto y coma porque es una \n"
"expresión cuyo valor queremos retornar"

#: src/ch02-03-functions.md:267
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5_u32);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1_u32\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5_u32);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1_u32\n"
"}\n"
"```"

#: src/ch02-03-functions.md:280
msgid ""
"Running this code will print `[DEBUG]                    (raw: 6)`. But if we place "
"a\n"
"semicolon at the end of the line containing `x + 1`, changing it from an\n"
"expression to a statement, we’ll get an error:"
msgstr ""
"Al ejecutar este código se imprimirá `[DEBUG]                    (raw: 6)`. Pero "
"si \n"
"agregamos un punto y coma al final de la línea que contiene `x + 1`, cambiándola \n"
"de una expresión a una declaración, obtendremos un error:"

#: src/ch02-03-functions.md:284
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5_u32);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1_u32;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let x = plus_one(5_u32);\n"
"\n"
"    x.print();\n"
"}\n"
"\n"
"fn plus_one(x: u32) -> u32 {\n"
"    x + 1_u32;\n"
"}\n"
"```"

#: src/ch02-03-functions.md:298
msgid "Compiling this code produces an error, as follows:"
msgstr ""
"La compilación de este código produce un error, como se muestra a continuación:"

#: src/ch02-03-functions.md:299
msgid ""
"```console\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"
msgstr ""
"```console\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"

#: src/ch02-03-functions.md:302
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue with this\n"
"code. The definition of the function `plus_one` says that it will return an\n"
"`u32`, but statements don’t evaluate to a value, which is expressed by `()`,\n"
"the unit type. Therefore, nothing is returned, which contradicts the function\n"
"definition and results in an error."
msgstr ""
"El mensaje principal de error, `Unexpected return type`, revela el problema \n"
"principal con este código. La definición de la función `plus_one` dice que "
"devolverá \n"
"un `u32`, pero las sentencias no se evalúan a un valor, lo cual se expresa por "
"`()`, el tipo \n"
"unit. Por lo tanto, no se devuelve nada, lo que contradice la definición de la "
"función y \n"
"resulta en un error."

#: src/ch02-04-comments.md:1
msgid "# Comments"
msgstr "# Comentarios"

#: src/ch02-04-comments.md:3
msgid ""
"In Cairo programs, you can include explanatory text within the code using comments. "
"To create a comment, use the // syntax, after which any text on the same line will "
"be ignored by the compiler."
msgstr ""
"En programas de Cairo, puedes incluir texto explicativo dentro del código mediante "
"comentarios. Para crear un comentario, usa la sintaxis //, después de lo cual "
"cualquier texto en la misma línea será ignorado por el compilador."

#: src/ch02-04-comments.md:5
msgid ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() -> felt252 {\n"
"    // start of the function\n"
"    1 + 4 // return the sum of 1 and 4\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:1
msgid "## Control Flow"
msgstr "## Control de Flujo"

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to run "
"some code repeatedly while a condition is true are basic building blocks in most "
"programming languages. The most common constructs that let you control the flow of "
"execution of Cairo code are if expressions and loops."
msgstr ""
"La capacidad de ejecutar cierto código dependiendo de si una condición es verdadera "
"y de ejecutar código repetidamente mientras una condición es verdadera son bloques "
"de construcción básicos en la mayoría de los lenguajes de programación. Las "
"construcciones más comunes que le permiten controlar el flujo de ejecución del "
"código en Cairo son las expresiones if y los bucles."

#: src/ch02-05-control-flow.md:5
msgid "### `if` Expressions"
msgstr "### Expresiones `if`"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this block of "
"code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Una expresión if le permite ramificar su código según condiciones. Proporciona una "
"condición y luego establece: \"Si se cumple esta condición, ejecute este bloque de "
"código. Si no se cumple la condición, no ejecute este bloque de código\"."

#: src/ch02-05-control-flow.md:11
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    } else {\n"
"        'condition was false'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    } else {\n"
"        'condition was false'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. In this "
"case, the condition checks whether or not the variable `number` has a value equal "
"to 5. We place the block of code to execute if the condition is `true` immediately "
"after the condition inside curly brackets."
msgstr ""
"Todos las expresiones `if` comienzan con la palabra clave `if`, seguido de una "
"condición. En este caso, la condición verifica si la variable `number` tiene un "
"valor igual a 5. Colocamos el bloque de código a ejecutar si la condición es `true` "
"inmediatamente después de la condición dentro de llaves."

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do here, to "
"give the program an alternative block of code to execute should the condition "
"evaluate to `false`. If you don’t provide an `else` expression and the condition is "
"`false`, the program will just skip the `if` block and move on to the next bit of "
"code."
msgstr ""
"Opcionalmente, también podemos incluir una expresión `else`, que elegimos hacer "
"aquí, para dar al programa un bloque de código alternativo para ejecutar si la "
"condición se evalúa como `false`. Si no proporciona una expresión `else` y la "
"condición es `false`, el programa simplemente omitirá el bloque `if` y pasará al "
"siguiente fragmento de código."

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "Intente ejecutar este código; debería ver la siguiente salida:"

#: src/ch02-05-control-flow.md:31
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was false\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was false\n"
"```"

#: src/ch02-05-control-flow.md:36
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition `true` "
"to see what happens:"
msgstr ""
"Intentaré cambiar el valor de number por uno que haga que la condición sea "
"verdadera para ver qué sucede:"

#: src/ch02-05-control-flow.md:38
msgid ""
"```rust\n"
"    let number = 5;\n"
"```"
msgstr ""
"```rust\n"
"    let number = 5;\n"
"```"

#: src/ch02-05-control-flow.md:42
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"condition was true\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run main.cairo\n"
"condition was true\n"
"```"

#: src/ch02-05-control-flow.md:47
msgid ""
"It’s also worth noting that the condition in this code must be a bool. If the "
"condition isn’t a bool, we’ll get an error."
msgstr ""
"También vale la pena señalar que la condición en este código debe ser un bool. Si "
"la condición no es un bool, obtendremos un error."

#: src/ch02-05-control-flow.md:49
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. Error: "
"Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId "
"{ id: 1, debug_name: None })]. Error: Provided generic argument is unsupported.', "
"crates/cairo-lang-sierra-generator/src/utils.rs:256:9\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run main.cairo\n"
"thread 'main' panicked at 'Failed to specialize: `enum_match<felt252>`. Error: "
"Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId "
"{ id: 1, debug_name: None })]. Error: Provided generic argument is unsupported.', "
"crates/cairo-lang-sierra-generator/src/utils.rs:256:9\n"
"```"

#: src/ch02-05-control-flow.md:54
msgid "### Handling Multiple Conditions with `else if`"
msgstr "### Manejando múltiples condiciones con `else if`"

#: src/ch02-05-control-flow.md:56
msgid ""
"You can use multiple conditions by combining if and else in an else if expression. "
"For example:"
msgstr ""
"Puede usar múltiples condiciones combinando `if` y `else` en una expresión `else "
"if`. Por ejemplo:"

#: src/ch02-05-control-flow.md:60
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 12 {\n"
"        'number is 12'.print();\n"
"    } else if number == 3 {\n"
"        'number is 3'.print();\n"
"    } else if number - 2 == 1 {\n"
"        'number minus 2 is 1'.print();\n"
"    } else {\n"
"        'number not found'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let number = 3;\n"
"\n"
"    if number == 12 {\n"
"        'number is 12'.print();\n"
"    } else if number == 3 {\n"
"        'number is 3'.print();\n"
"    } else if number - 2 == 1 {\n"
"        'number minus 2 is 1'.print();\n"
"    } else {\n"
"        'number not found'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:78
msgid ""
"This program has four possible paths it can take. After running it, you should see "
"the following output:"
msgstr ""
"Este programa tiene cuatro posibles caminos que puede seguir. Después de "
"ejecutarlo, debería ver la siguiente salida:"

#: src/ch02-05-control-flow.md:80
msgid ""
"```console\n"
"[DEBUG]\tnumber is 3\n"
"```"
msgstr ""
"```console\n"
"[DEBUG]\tnumber is 3\n"
"```"

#: src/ch02-05-control-flow.md:84
msgid ""
"When this program executes, it checks each `if` expression in turn and executes the "
"first body for which the condition evaluates to `true`. Note that even though "
"`number - 2 == 1` is `true`, we don’t see the output `number minus 2 is 1'."
"print()`, nor do we see the `number not found` text from the `else` block. That’s "
"because Cairo only executes the block for the first true condition, and once it "
"finds one, it doesn’t even check the rest. Using too many `else if` expressions can "
"clutter your code, so if you have more than one, you might want to refactor your "
"code. Chapter 5 describes a powerful Cairo branching construct called `match` for "
"these cases."
msgstr ""
"Cuando este programa se ejecuta, verifica cada expresión `if` en orden y ejecuta el "
"primer cuerpo para el cual la condición se evalúa como verdadera. Es importante "
"destacar que aunque `number - 2 == 1` es verdadero, no vemos la salida `number "
"minus 2 is 1'.print()`, ni tampoco vemos el texto `number is not divisible by 4, 3, "
"or 2` del bloque `else`. Esto se debe a que Cairo solo ejecuta el bloque "
"correspondiente a la primera condición verdadera que encuentra, y una vez que la "
"encuentra, no verifica las demás. Usar demasiadas expresiones `else if` puede "
"desordenar el código, por lo que si tienes más de una, es posible que desees "
"refactorizar el código. El capítulo 5 describe una poderosa estructura de control "
"de flujo de Cairo llamada `match` para estos casos."

#: src/ch02-05-control-flow.md:86
msgid "### Using `if` in a `let` statement"
msgstr "### Usando `if` en una declaración `let`"

#: src/ch02-05-control-flow.md:88
msgid ""
"Because if is an expression, we can use it on the right side of a let statement to "
"assign the outcome to a variable."
msgstr ""
"Dado que `if` es una expresión, podemos usarla en el lado derecho de una "
"declaración `let` para asignar el resultado a una variable."

#: src/ch02-05-control-flow.md:92
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition {\n"
"        5\n"
"    } else {\n"
"        6\n"
"    };\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let condition = true;\n"
"    let number = if condition {\n"
"        5\n"
"    } else {\n"
"        6\n"
"    };\n"
"\n"
"    if number == 5 {\n"
"        'condition was true'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:109
msgid ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was true\n"
"```"
msgstr ""
"```console\n"
"$ cairo-run main.cairo\n"
"[DEBUG]\tcondition was true\n"
"```"

#: src/ch02-05-control-flow.md:114
msgid ""
"The `number` variable will be bound to a value based on the outcome of the `if` "
"expression. Which will be 5 here."
msgstr ""
"La variable `number` quedará ligada a un valor basado en el resultado de la "
"expresión `if`. En este caso, será 5."

#: src/ch02-05-control-flow.md:116
msgid "### Repetition with Loops"
msgstr "### Repetición con bucles"

#: src/ch02-05-control-flow.md:118
msgid ""
"It’s often useful to execute a block of code more than once. For this task, Cairo "
"provides a simple loop syntax, which will run through the code inside the loop body "
"to the end and then start immediately back at the beginning. To experiment with "
"loops, let’s create a new project called loops."
msgstr ""
"A menudo es útil ejecutar un bloque de código más de una vez. Para esta tarea, "
"Cairo proporciona una simple sintaxis de bucle, que recorrerá el código dentro del "
"cuerpo del bucle hasta el final y luego comenzará inmediatamente de vuelta al "
"principio. Para experimentar con bucles, creemos un nuevo proyecto llamado bucles."

#: src/ch02-05-control-flow.md:120
msgid "Cairo only has one kind of loop for now: `loop`."
msgstr "Cairo sólo tiene un tipo de bucle por ahora: `loop`."

#: src/ch02-05-control-flow.md:122
msgid "#### Repeating Code with `loop`"
msgstr "#### Repetición de Código con `loop`"

#: src/ch02-05-control-flow.md:124
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over again\n"
"forever or until you explicitly tell it to stop."
msgstr ""
"La palabra clave `loop` le dice a Cairo que ejecute un bloque de código una y otra "
"vez\n"
"para siempre o hasta que le digas explícitamente que pare."

#: src/ch02-05-control-flow.md:127
msgid ""
"As an example, change the _src/lib.rs_ file in your _loops_ directory to look\n"
"like this:"
msgstr ""
"Por ejemplo, cambie el archivo _src/lib.rs_ de su directorio _loops_ para que tenga "
"el siguiente aspecto\n"
"así:"

#: src/ch02-05-control-flow.md:132
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i:usize = 0;\n"
"    loop {\n"
"        if i > 10{\n"
"            break();\n"
"        }\n"
"        'again!'.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i:usize = 0;\n"
"    loop {\n"
"        if i > 10{\n"
"            break();\n"
"        }\n"
"        'again!'.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:145
msgid ""
"When we run this program, we’ll see `again!` printed over and over continuously\n"
"until we stop the program manually, because the stop condition is never reached.\n"
"While the compiler prevents us from writing programs without a stop condition "
"(`break()` statement),\n"
"the stop condition might never be reached, resulting in an infinite loop.\n"
"Most terminals support the keyboard shortcut <span class=\"keystroke\">ctrl-c</"
"span> to interrupt a program that is\n"
"stuck in a continual loop. Give it a try:"
msgstr ""
"Cuando ejecutemos este programa, veremos impreso `¡otra vez!` una y otra vez "
"continuamente\n"
"hasta que detengamos el programa manualmente, porque la condición de parada nunca "
"se alcanza.\n"
"Aunque el compilador nos impide escribir programas sin una condición de parada "
"(sentencia `break()`),\n"
"la condición de parada podría no alcanzarse nunca, dando lugar a un bucle "
"infinito.\n"
"La mayoría de los terminales soportan el atajo de teclado <span class=\"keystroke"
"\">ctrl-c</span> para interrumpir un programa que está\n"
"en un bucle continuo. Pruébalo:"

#: src/ch02-05-control-flow.md:152
msgid ""
"```console\n"
"❯ cairo-run src/lib.cairo --available-gas=20000000\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"Run panicked with err values: [375233589013918064796019]\n"
"Remaining gas: 1050\n"
"```"
msgstr ""
"```console\n"
"❯ cairo-run src/lib.cairo --available-gas=20000000\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"[DEBUG]\tagain                          \t(raw: 418346264942)\n"
"\n"
"Run panicked with err values: [375233589013918064796019]\n"
"Remaining gas: 1050\n"
"```"

#: src/ch02-05-control-flow.md:166
msgid ""
"> Note: Cairo prevents us from running program with infinite loops by including a "
"gas meter. The gas meter is a mechanism that limits the amount of computation that "
"can be done in a program. By setting a value to the `--available-gas` flag, we can "
"set the maximum amount of gas available to the program. Gas is a unit of "
"measurements that expresses the computation cost of an instruction. When the gas "
"meter runs out, the program will stop. In this case, the program panicked because "
"it ran out of gas, as the stop condition was never reached.\n"
"> It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network.\n"
"> If you're writing a program that needs to run a loop, you will need to execute it "
"with the `--available-gas` flag set to a value that is large enough to run the "
"program."
msgstr ""
"> Nota: Cairo nos previene de ejecutar programas con bucles infinitos incluyendo un "
"contador de gas. El contador de gas es un mecanismo que limita la cantidad de "
"computación que se puede hacer en un programa. Estableciendo un valor a la bandera "
"`--available-gas`, podemos establecer la cantidad máxima de gas disponible para el "
"programa. El gas es una unidad de medida que expresa el coste de cálculo de una "
"instrucción. Cuando el contador de gas se agote, el programa se detendrá. En este "
"caso, el programa entró en pánico porque se quedó sin gas, ya que nunca se alcanzó "
"la condición de parada.\n"
"> Es particularmente importante en el contexto de los contratos inteligentes "
"desplegados en Starknet, ya que evita que se ejecuten bucles infinitos en la red.\n"
"> Si estás escribiendo un programa que necesita ejecutar un bucle, tendrás que "
"ejecutarlo con la bandera `--available-gas` establecida en un valor que sea lo "
"suficientemente grande como para ejecutar el programa."

#: src/ch02-05-control-flow.md:170
msgid ""
"To break out of a loop, you can place the `break()` statement within the loop to "
"tell the program when to stop\n"
"executing the loop. Let's fix the infinite loop by adding a making the stop "
"condition `i > 10` reachable."
msgstr ""
"Para salir de un bucle, puede colocar la sentencia `break()` dentro del bucle para "
"indicar al programa cuándo debe detener la ejecución del bucle\n"
"la ejecución del bucle. Arreglemos el bucle infinito añadiendo una condición de "
"parada `i > 10` alcanzable."

#: src/ch02-05-control-flow.md:173
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ();\n"
"        }\n"
"        'again'.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut i: usize = 0;\n"
"    loop {\n"
"        if i > 10 {\n"
"            break ();\n"
"        }\n"
"        'again'.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:187
msgid "#### Returning Values from Loops"
msgstr "#### Devolución de Valores de Loops"

#: src/ch02-05-control-flow.md:189
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, such\n"
"as checking whether an operation has succeeded. You might also need to pass\n"
"the result of that operation out of the loop to the rest of your code. To do\n"
"this, you can add the value you want returned after the `break` expression you\n"
"use to stop the loop; that value will be returned out of the loop so you can\n"
"use it, as shown here:"
msgstr ""
"Uno de los usos de un `loop` es reintentar una operación que sabes que puede "
"fallar, como por ejemplo\n"
"comprobar si una operación ha tenido éxito. También puede ser necesario pasar\n"
"el resultado de esa operación fuera del bucle al resto del código. Para ello\n"
"Para ello, puede añadir el valor que desea devolver después de la expresión "
"`break`\n"
"para detener el bucle; ese valor será devuelto fuera del bucle para que pueda "
"utilizarlo, \n"
"como se muestra aquí:"

#: src/ch02-05-control-flow.md:196
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"        counter += 1;\n"
"    };\n"
"\n"
"    'The result is '.print();\n"
"    result.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let mut counter = 0;\n"
"\n"
"    let result = loop {\n"
"        if counter == 10 {\n"
"            break counter * 2;\n"
"        }\n"
"        counter += 1;\n"
"    };\n"
"\n"
"    'The result is '.print();\n"
"    result.print();\n"
"}\n"
"```"

#: src/ch02-05-control-flow.md:213
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to\n"
"`0`. Then we declare a variable named `result` to hold the value returned from\n"
"the loop. On every iteration of the loop, we check whether the `counter` is equal "
"to `10`, and then add `1` to the `counter` variable.\n"
"When the condition is met, we use the `break` keyword with the value `counter * 2`. "
"After the loop, we use a\n"
"semicolon to end the statement that assigns the value to `result`. Finally, we\n"
"print the value in `result`, which in this case is `20`."
msgstr ""
"Antes del bucle, declaramos una variable llamada `counter` y la inicializamos a\n"
"`0`. Luego declaramos una variable llamada `resultado` para mantener el valor "
"devuelto por el bucle.\n"
"del bucle. En cada iteración del bucle, comprobamos si `counter` es igual a `10`, y "
"añadimos `1` a la variable `counter`.\n"
"Cuando se cumple la condición, utilizamos la palabra clave `break` con el valor "
"`counter * 2`. Después del bucle, usamos un\n"
"punto y coma para terminar la sentencia que asigna el valor a `resultado`. "
"Finalmente\n"
"el valor en `resultado`, que en este caso es `20`."

#: src/ch02-06-common-collections.md:1
msgid "## Common Collections"
msgstr "## Colecciones Comunes"

#: src/ch02-06-common-collections.md:3
msgid ""
"Cairo1 provides a set of common collection types that can be used to store and "
"manipulate data. These collections are designed to be efficient, flexible, and easy "
"to use. This section introduces the primary collection types available in Cairo1: "
"`Array` and `Felt252Dict` (coming soon)."
msgstr ""
"Cairo1 proporciona un conjunto de tipos de colecciones comunes que pueden "
"utilizarse para almacenar y manipular datos. Estas colecciones están diseñadas para "
"ser eficientes, flexibles y fáciles de usar. Esta sección presenta los principales "
"tipos de colecciones disponibles en Cairo1: `Array` y `Felt252Dict` (próximamente)."

#: src/ch02-06-common-collections.md:5
msgid "### Array"
msgstr "### Array"

#: src/ch02-06-common-collections.md:7
msgid ""
"An array is a collection of elements of the same type. You can create and use array "
"methods by importing the `array::ArrayTrait` trait."
msgstr ""
"Un array es una colección de elementos del mismo tipo. Puedes crear y utilizar "
"métodos de array importando el trait `array::ArrayTrait`."

#: src/ch02-06-common-collections.md:9
msgid ""
"An important thing to note is that arrays have limited modifications options. "
"Arrays are, in fact, queues whose values can't be modified.\n"
"This has to do with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of an "
"array and remove items from the front using `pop_front`."
msgstr ""
"Algo importante a tener en cuenta es que las arrays tienen opciones de modificación "
"limitadas. Las arrays son, de hecho, colas cuyos valores no pueden modificarse.\n"
"Esto tiene que ver con el hecho de que una vez que se escribe en un espacio de "
"memoria, no se puede sobrescribir, sino sólo leer de él. Sólo se pueden añadir "
"elementos al final de un array y eliminar elementos de la parte delantera "
"utilizando `pop_front`."

#: src/ch02-06-common-collections.md:12
msgid "#### Creating an Array"
msgstr "#### Crear un Array"

#: src/ch02-06-common-collections.md:14
msgid ""
"Creating an Array is done with the `ArrayTrait::new()` call. Here is an example of "
"creation of an array with 3 elements:"
msgstr ""
"La creación de un Array se realiza con la llamada `ArrayTrait::new()`. He aquí un "
"ejemplo de creación de un array con 3 elementos:"

#: src/ch02-06-common-collections.md:16
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"}\n"
"```"

#: src/ch02-06-common-collections.md:27
msgid ""
"You can pass the expected type of items inside the array when instantiating the "
"array like this"
msgstr ""
"Puede pasar el tipo esperado de elementos dentro de la array al instanciar la array "
"de la siguiente manera"

#: src/ch02-06-common-collections.md:29
msgid ""
"```rust,\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"```"
msgstr ""
"```rust,\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"```"

#: src/ch02-06-common-collections.md:33
msgid "#### Updating an Array"
msgstr "#### Actualizar un Array"

#: src/ch02-06-common-collections.md:35
msgid "##### Adding Elements"
msgstr "##### Añadir Elementos"

#: src/ch02-06-common-collections.md:37
msgid "To add an element to the end of an array, you can use the `append()` method:"
msgstr "To add an element to the end of an array, you can use the `append()` method:"

#: src/ch02-06-common-collections.md:39
msgid ""
"```rust\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"```"
msgstr ""
"```rust\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"```"

#: src/ch02-06-common-collections.md:46
msgid "##### Removing Elements"
msgstr "##### Eliminar Elementos"

#: src/ch02-06-common-collections.md:48
msgid ""
"To remove an element from the front of an array, you can use the `pop_front()` "
"method.\n"
"This method returns an `Option` containing the removed element, or `Option::None` "
"if the array is empty."
msgstr ""
"Para eliminar un elemento de la parte frontal de un array, puedes utilizar el "
"método `pop_front()`.\n"
"Este método devuelve un `Option` que contiene el elemento eliminado, o `Option::"
"None` si el array está vacío."

#: src/ch02-06-common-collections.md:51
msgid ""
"```rust\n"
"use option::OptionTrait;\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use option::OptionTrait;\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(10);\n"
"    a.append(1);\n"
"    a.append(2);\n"
"\n"
"    let first_value = a.pop_front().unwrap();\n"
"    first_value.print(); // print '10'\n"
"}\n"
"```"

#: src/ch02-06-common-collections.md:67
msgid "The above code will print `10` as we remove the first element that was added."
msgstr ""
"El código anterior imprimirá `10` cuando eliminemos el primer elemento añadido."

#: src/ch02-06-common-collections.md:69
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify the "
"elements of an array once they've been added. You can only add elements to the end "
"of an array and remove elements from the front of an array. These operations do not "
"require memory mutation, as they involve updating pointers rather than directly "
"modifying the memory cells."
msgstr ""
"En Cairo, la memoria es inmutable, lo que significa que no es posible modificar los "
"elementos de un array una vez que han sido añadidos. Sólo se pueden añadir "
"elementos al final de un array y eliminar elementos de la parte frontal de un "
"array. Estas operaciones no requieren mutación de memoria, ya que implican "
"actualizar punteros en lugar de modificar directamente las celdas de memoria."

#: src/ch02-06-common-collections.md:71
msgid "#### Reading Elements from an Array"
msgstr "#### Lectura de Elementos de un Array"

#: src/ch02-06-common-collections.md:73
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that return "
"different types. Using `arr.at(index)` is equivalent to using the subscripting "
"operator `arr[index]`."
msgstr ""
"Para acceder a los elementos de un array, puedes utilizar los métodos `get()` o "
"`at()` que devuelven diferentes tipos. Utilizar `arr.at(index)` es equivalente a "
"utilizar el operador de subíndice `arr[index]`."

#: src/ch02-06-common-collections.md:75
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an option "
"to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at "
"the specified index if that element exists in the array. If the element doesn't "
"exist, `get` returns `None`. This method is useful when you expect to access "
"indices that may not be within the array's bounds and want to handle such cases "
"gracefully without panics. Snapshots will be explained in more detail in the "
"[References and Snapshots](ch03-02-references-and-snapshots.md) chapter."
msgstr ""
"La función `get` devuelve una `Option<Box<@T>>`, lo que significa que devuelve una "
"opción a un tipo Box (el tipo smart-pointer de Cairo) que contiene una instantánea "
"al elemento en el índice especificado si ese elemento existe en el array. Si el "
"elemento no existe, `get` devuelve `None`. Este método es útil cuando esperas "
"acceder a índices que pueden no estar dentro de los límites del array y quieres "
"manejar tales casos con gracia sin pánicos. Las instantáneas se explicarán con más "
"detalle en el capítulo [Referencias y Snapshots](ch03-02-references-and-snapshots."
"md)."

#: src/ch02-06-common-collections.md:77
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the element at "
"the specified index using the `unbox()` operator to extract the value stored in a "
"box. If the index is out of bounds, a panic error occurs. You should only use at "
"when you want the program to panic if the provided index is out of the array's "
"bounds, which can prevent unexpected behavior."
msgstr ""
"La función `at`, por otro lado, devuelve directamente una instantánea al elemento "
"en el índice especificado utilizando el operador `unbox()` para extraer el valor "
"almacenado en una caja. Si el índice está fuera de los límites, se produce un error "
"de pánico. Sólo debe utilizar at cuando desee que el programa entre en pánico si el "
"índice proporcionado está fuera de los límites del array, lo que puede evitar "
"comportamientos inesperados."

#: src/ch02-06-common-collections.md:79
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access attempts, and "
"use `get` when you prefer to handle such cases gracefully without panicking."
msgstr ""
"En resumen, usa `at` cuando quieras que el programa entre en pánico ante intentos "
"de acceso fuera de los límites, y usa `get` cuando prefieras manejar estos casos "
"con gracia sin entrar en pánico."

#: src/ch02-06-common-collections.md:81
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"\n"
"    let first = *a.at(0_usize);\n"
"    let second = *a.at(1_usize);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let mut a = ArrayTrait::new();\n"
"    a.append(0);\n"
"    a.append(1);\n"
"\n"
"    let first = *a.at(0_usize);\n"
"    let second = *a.at(1_usize);\n"
"}\n"
"```"

#: src/ch02-06-common-collections.md:93
msgid ""
"In this example, the variable named `first` will get the value `0` because that\n"
"is the value at index `0` in the array. The variable named `second` will get\n"
"the value `1` from index `1` in the array."
msgstr ""
"En este ejemplo, la variable llamada `first` obtendrá el valor `0` porque es el \n"
"valor del índice `0` del array. La variable llamada `second` obtendrá el valor "
"`1` \n"
"del índice `1` del array."

#: src/ch02-06-common-collections.md:97
msgid "Here is an example with the `get()` method:"
msgstr "He aquí un ejemplo con el método `get()`:"

#: src/ch02-06-common-collections.md:99
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use box::BoxTrait;\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100_u128);\n"
"    let index_to_access =\n"
"        1_usize;        // Change this value to see different results, what would "
"happen if the index doesn't exist ?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x.unbox()  // Don't worry about * for now, if you are curious see "
"Chapter 3.2 #desnap operator\n"
"                        // It basically means \"transform what get(idx) returned "
"into a real value\"\n"
"        },\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"use box::BoxTrait;\n"
"fn main() -> u128 {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    arr.append(100_u128);\n"
"    let index_to_access =\n"
"        1_usize;        // Change this value to see different results, what would "
"happen if the index doesn't exist ?\n"
"    match arr.get(index_to_access) {\n"
"        Option::Some(x) => {\n"
"            *x.unbox()  // Don't worry about * for now, if you are curious see "
"Chapter 3.2 #desnap operator\n"
"                        // It basically means \"transform what get(idx) returned "
"into a real value\"\n"
"        },\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('out of bounds');\n"
"            panic(data)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-06-common-collections.md:121
msgid "#### Size related methods"
msgstr "#### Métodos relacionados con el tamaño"

#: src/ch02-06-common-collections.md:123
msgid ""
"To determine the number of elements in an array, use the `len()` method. The return "
"is of type `usize`."
msgstr ""
"Para determinar el número de elementos de un array, utilice el método `len()`. El "
"valor devuelto es de tipo `usize`."

#: src/ch02-06-common-collections.md:125
msgid ""
"If you want to check if an array is empty or not, you can use the `is_empty()` "
"method, which returns `true` if the array is empty and `false` otherwise."
msgstr ""
"Si quieres comprobar si un array está vacío o no, puedes utilizar el método "
"`is_empty()`, que devuelve `true` si el array está vacío y `false` en caso "
"contrario."

#: src/ch02-06-common-collections.md:127
msgid "#### Storing multiple types with Enums"
msgstr "#### Almacenar multiples tipos con Enums"

#: src/ch02-06-common-collections.md:129
msgid ""
"If you want to store elements of different types in an array, you can use an `Enum` "
"to define a custom data type that can hold multiple types."
msgstr ""
"Si desea almacenar elementos de diferentes tipos en una array, puede utilizar un "
"`Enum` para definir un tipo de datos personalizado que pueda contener múltiples "
"tipos."

#: src/ch02-06-common-collections.md:131
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use traits::Into;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"enum Data {\n"
"    Integer: u128,\n"
"    Felt: felt252,\n"
"    Tuple: (u32, u32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut messages: Array<Data> = ArrayTrait::new();\n"
"    messages.append(Data::Integer(100_u128));\n"
"    messages.append(Data::Felt('hello world'));\n"
"    messages.append(Data::Tuple((10_u32, 30_u32)));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"use traits::Into;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"enum Data {\n"
"    Integer: u128,\n"
"    Felt: felt252,\n"
"    Tuple: (u32, u32),\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut messages: Array<Data> = ArrayTrait::new();\n"
"    messages.append(Data::Integer(100_u128));\n"
"    messages.append(Data::Felt('hello world'));\n"
"    messages.append(Data::Tuple((10_u32, 30_u32)));\n"
"}\n"
"```"

#: src/ch02-06-common-collections.md:150
msgid "#### Span"
msgstr "#### Span"

#: src/ch02-06-common-collections.md:152
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed to "
"provide safe and controlled access to the elements of an array without modifying "
"the original array. Span is particularly useful for ensuring data integrity and "
"avoiding borrowing issues when passing arrays between functions or when performing "
"read-only operations (cf. [References and Snapshots](ch03-02-references-and-"
"snapshots.md))"
msgstr ""
"`Span` es una estructura que representa una instantánea de un `Array`. Está "
"diseñada para proporcionar un acceso seguro y controlado a los elementos de un "
"array sin modificar el array original. Span es particularmente útil para asegurar "
"la integridad de los datos y evitar problemas de préstamo cuando se pasan arrays "
"entre funciones o cuando se realizan operaciones de sólo lectura (cf. [References "
"and Snapshots](ch03-02-references-and-snapshots.md))"

#: src/ch02-06-common-collections.md:154
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the exception of "
"the `append()` method."
msgstr ""
"Todos los métodos proporcionados por `Array` también se pueden utilizar con `Span`, "
"a excepción del método `append()`."

#: src/ch02-06-common-collections.md:156
msgid "##### Turning an Array into span"
msgstr "##### Convertir un Array en span"

#: src/ch02-06-common-collections.md:158
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "To create a `Span` of an `Array`, call the `span()` method:"

#: src/ch02-06-common-collections.md:160
msgid ""
"```rust\n"
"let span = array.span();\n"
"```"
msgstr ""
"```rust\n"
"let span = array.span();\n"
"```"

#: src/ch02-06-common-collections.md:164 src/ch04-03-method-syntax.md:286
#: src/ch06-05-separating-modules-into-different-files.md:98
msgid "## Summary"
msgstr "## Resumen"

#: src/ch02-06-common-collections.md:166
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data types, "
"functions, comments,\n"
"`if` expressions, loops, and common collections! To practice with the concepts "
"discussed in this chapter,\n"
"try building programs to do the following:"
msgstr ""
"¡Lo has conseguido! Este ha sido un capítulo considerable: has aprendido sobre "
"variables, tipos de datos, funciones, comentarios,\n"
"expresiones `if`, bucles y colecciones comunes. Para practicar con los conceptos "
"discutidos en este capítulo,\n"
"intenta construir programas para hacer lo siguiente:"

#: src/ch02-06-common-collections.md:170
msgid ""
"- Generate the _n_-th Fibonacci number.\n"
"- Compute the factorial of a number _n_."
msgstr ""
"- Generar el _n_-th número de Fibonacci.\n"
"- Calcular el factorial de un número _n_."

#: src/ch02-06-common-collections.md:173
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares with "
"Rust and that _doesn’t_\n"
"commonly exist in other programming languages: ownership."
msgstr ""
"Cuando estés listo para continuar, hablaremos de un concepto que Cairo comparte con "
"Rust y que _no_\n"
"existe comúnmente en otros lenguajes de programación: ownership."

#: src/ch03-00-understanding-ownership.md:1
msgid "# Understanding Cairo's Ownership system"
msgstr "# Entendiendo el Ownership de Cairo"

#: src/ch03-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to\n"
"statically ensure that in every Cairo program, a value is used exactly once.\n"
"This linear type system helps preventing runtime errors by ensuring that operations "
"that could cause such errors, such as writing twice to a memory cell, are detected "
"at compile time.\n"
"This is achieved by implementing an ownership system\n"
"and forbidding copying and dropping values by default. In this chapter, we’ll\n"
"talk about Cairo's ownership system as well as references and snapshots."
msgstr ""
"Cairo es un lenguaje construido alrededor de un sistema de tipos lineales que \n"
"nos permite asegurarnos estáticamente de que en cada programa de Cairo, un valor se "
"utiliza exactamente una vez. \n"
"Este sistema de tipos lineales ayuda a prevenir errores en tiempo de ejecución "
"asegurando que las operaciones que podrían causar dichos errores, como escribir dos "
"veces en una celda de memoria, se detecten en tiempo de compilación. \n"
"Esto se logra implementando un Ownership y prohibiendo la copia y eliminación \n"
"de valores por defecto. En este capítulo, hablaremos sobre el Ownership de Cairo, "
"así como \n"
"sobre las referencias y snapshots."

#: src/ch03-01-what-is-ownership.md:1
msgid "## What Is Ownership?"
msgstr "## ¿Qué es Ownership?"

#: src/ch03-01-what-is-ownership.md:3
msgid ""
"Cairo implements an ownership system to ensure the safety and correctness of its "
"compiled code.\n"
"The ownership mechanism complements the linear type system, which enforces that "
"objects are used exactly once.\n"
"This helps prevent common operations that can produce runtime errors, such as "
"illegal memory address\n"
"references or multiple writes to the same memory address, and ensures the soundness "
"of Cairo programs\n"
"by checking at compile time that all the dictionaries are squashed."
msgstr ""
"Cairo implementa un sistema de propiedad para garantizar la seguridad y corrección "
"de su código compilado. \n"
"El mecanismo de propiedad complementa el sistema de tipos lineales, que obliga a "
"que los objetos se usen exactamente una vez. \n"
"Esto ayuda a prevenir operaciones comunes que pueden producir errores en tiempo de "
"ejecución, como referencias ilegales de direcciones\n"
" de memoria o múltiples escrituras en la misma dirección de memoria, y garantiza la "
"corrección de los programas de Cairo comprobando \n"
"en tiempo de compilación que todos los diccionarios están aplastados."

#: src/ch03-01-what-is-ownership.md:9
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() {`\n"
"code in examples, so if you’re following along, make sure to put the following\n"
"examples inside a `main` function manually. As a result, our examples will be a\n"
"bit more concise, letting us focus on the actual details rather than\n"
"boilerplate code."
msgstr ""
"Ahora que hemos pasado la sintaxis básica de Cairo, no incluiremos todo el código\n"
" `fn main() {` en los ejemplos, así que si estás siguiendo, asegúrate de colocar "
"los siguientes \n"
"ejemplos dentro de una función `main` manualmente. Como resultado, nuestros "
"ejemplos\n"
" serán un poco más concisos, lo que nos permitirá enfocarnos en los detalles reales "
"en lugar \n"
"del código de plantilla."

#: src/ch03-01-what-is-ownership.md:15
msgid "### Ownership Rules"
msgstr "### Reglas de Ownership"

#: src/ch03-01-what-is-ownership.md:17
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as we\n"
"work through the examples that illustrate them:"
msgstr ""
"En primer lugar, echemos un vistazo a las reglas de propiedad. Mantenga estas \n"
"reglas en mente mientras trabajamos a través de los ejemplos que las ilustran:"

#: src/ch03-01-what-is-ownership.md:20
msgid ""
"- Each value in Cairo has an _owner_.\n"
"- There can only be one owner at a time.\n"
"- When the owner goes out of scope, the value will be _dropped_."
msgstr ""
"- Cada valor en Cairo tiene un _propietario_.\n"
"- Solo puede haber un propietario a la vez.\n"
"- Cuando el propietario sale del ámbito, el valor será _descartado_."

#: src/ch03-01-what-is-ownership.md:24
msgid "### Variable Scope"
msgstr "### Ámbito de Variables"

#: src/ch03-01-what-is-ownership.md:26
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some variables. A\n"
"scope is the range within a program for which an item is valid. Take the\n"
"following variable:"
msgstr ""
"Como primer ejemplo de propiedad, veremos el _ámbito_ de algunas variables. \n"
"Un ámbito es el alcance dentro de un programa para el cual un elemento es válido. \n"
"Tomemos la siguiente variable:"

#: src/ch03-01-what-is-ownership.md:30
msgid ""
"```rust\n"
"let s = 'hello';\n"
"```"
msgstr ""
"```rust\n"
"let s = 'hello';\n"
"```"

#: src/ch03-01-what-is-ownership.md:34
msgid ""
"The variable `s` refers to a short string, where the value of the string is\n"
"hardcoded into the text of our program. The variable is valid from the point at\n"
"which it’s declared until the end of the current _scope_. Listing 3-1 shows a\n"
"program with comments annotating where the variable `s` would be valid."
msgstr ""
"La variable `s` hace referencia a una cadena corta, donde el valor de la cadena \n"
"está codificado en el texto de nuestro programa. La variable es válida desde el\n"
" momento en que se declara hasta el final del _ámbito_ actual. La Lista 3-1 "
"muestra \n"
"un programa con comentarios que anotan dónde sería válida la variable `s`."

#: src/ch03-01-what-is-ownership.md:39
msgid ""
"```rust\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer valid\n"
"```"
msgstr ""
"```rust\n"
"    {                      // s is not valid here, it’s not yet declared\n"
"        let s = 'hello';   // s is valid from this point forward\n"
"\n"
"        // do stuff with s\n"
"    }                      // this scope is now over, and s is no longer valid\n"
"```"

#: src/ch03-01-what-is-ownership.md:47
msgid ""
"<span class=\"caption\">Listing 3-1: A variable and the scope in which it is\n"
"valid</span>"
msgstr ""
"<span class=\"caption\">Lista 3-1: Una variable y el ámbito en el que es válida</"
"span>"

#: src/ch03-01-what-is-ownership.md:50
msgid "In other words, there are two important points in time here:"
msgstr "En otras palabras, hay dos puntos importantes en el tiempo aquí:"

#: src/ch03-01-what-is-ownership.md:52
msgid ""
"- When `s` comes _into_ scope, it is valid.\n"
"- It remains valid until it goes _out of_ scope."
msgstr ""
"- Cuando `s` entra en el _ámbito_, es válida.\n"
"- Permanece válida hasta que sale del _ámbito_."

#: src/ch03-01-what-is-ownership.md:55
msgid ""
"At this point, the relationship between scopes and when variables are valid is\n"
"similar to that in other programming languages. Now we’ll build on top of this\n"
"understanding by using the `Array` type we introduced in the [previous chapter]"
"(ch02-06-common-collections.md)."
msgstr ""
"En este punto, la relación entre los ámbitos y cuándo las variables son válidas "
"es \n"
"similar a la de otros lenguajes de programación. Ahora nos basaremos en este\n"
"utilizando el tipo `Array` que introdujimos en el [capítulo anterior](ch02-06-"
"common-collections.md)."

#: src/ch03-01-what-is-ownership.md:59
msgid "### Ownership with the `Array` Type"
msgstr "### Ownership con el tipo `Array"

#: src/ch03-01-what-is-ownership.md:61
msgid ""
"To illustrate the rules of ownership, we need a data type that is more complex.\n"
"The types covered in the [“Data Types”][data-types]<!-- ignore --> section\n"
"of Chapter 2 are of a known size, can be\n"
"quickly and trivially copied to make a new, independent instance if another\n"
"part of code needs to use the same value in a different scope, and can easily\n"
"be dropped when they're no longer used. But what is the behavior with the `Array` "
"type whose size\n"
"is unknown at compile time and which can't be trivially copied ?"
msgstr ""
"Para ilustrar las reglas de propiedad, necesitamos un tipo de datos que sea más "
"complejo.\n"
"Los tipos cubiertos en la sección [\"Tipos de datos\"][data-types]<!-- ignore -->\n"
"del capítulo 2 tienen un tamaño conocido, pueden ser\n"
"pueden copiarse rápida y trivialmente para crear una instancia nueva e\n"
"si otra parte del código necesita utilizar el mismo valor en un ámbito diferente, y "
"pueden\n"
"cuando ya no se utilizan. Pero ¿cuál es el comportamiento con el tipo `Array` cuyo "
"tamaño\n"
"es desconocido en tiempo de compilación y que no puede copiarse trivialmente?"

#: src/ch03-01-what-is-ownership.md:69
msgid "Here is a short reminder of what an array looks like:"
msgstr "Aquí tienes un breve recordatorio de cómo es un array:"

#: src/ch03-01-what-is-ownership.md:71
msgid ""
"```rust\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"arr.append(1);\n"
"arr.append(2);\n"
"```"
msgstr ""
"```rust\n"
"let mut arr = ArrayTrait::<u128>::new();\n"
"arr.append(1);\n"
"arr.append(2);\n"
"```"

#: src/ch03-01-what-is-ownership.md:77
msgid ""
"So, how does the ownership system ensure that each cell is never written to more "
"than once?\n"
"Consider the following code, where we try to pass the same instance of an array in "
"two consecutive\n"
"function calls:"
msgstr ""
"Entonces, ¿cómo garantiza el sistema de propiedad que nunca se escriba en cada "
"celda más de una vez?\n"
"Consideremos el siguiente código, en el que intentamos pasar la misma instancia de "
"un array en dos llamadas consecutivas a la función\n"
"consecutivas:"

#: src/ch03-01-what-is-ownership.md:81
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn foo(arr: Array<u128>) {\n"
"}\n"
"\n"
"fn bar(arr:Array<u128>){\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    foo(arr);\n"
"    bar(arr);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn foo(arr: Array<u128>) {\n"
"}\n"
"\n"
"fn bar(arr:Array<u128>){\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"    foo(arr);\n"
"    bar(arr);\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:96
msgid ""
"In this case, we try to pass the same array instance `arr` by value to the "
"functions `foo` and `bar`, which means\n"
"that the parameter used in both function calls is the same instance of the array. "
"If you append a value to the array\n"
"in `foo`, and then try to append another value to the same array in `bar`, what "
"would happen is that\n"
"you would attempt to try to write to the same memory cell twice, which is not "
"allowed in Cairo.\n"
"To prevent this, the ownership of the `arr` variable moves from the `main` function "
"to the `foo` function. When trying\n"
"to call `bar` with `arr` as a parameter, the ownership of `arr` was already moved "
"to the first call. The ownership\n"
"system thus prevents us from using the same instance of `arr` in `foo`."
msgstr ""
"En este caso, intentamos pasar la misma instancia de matriz `arr` por valor a las "
"funciones `foo` y `bar`, lo que significa \n"
"que el parámetro utilizado en ambas llamadas de función es la misma instancia de la "
"matriz. Si agrega un valor a la matriz e\n"
"n `foo` y luego intenta agregar otro valor a la misma matriz en `bar`, lo que "
"sucederá es que intentará escribir en la misma celda de memoria dos veces, lo que "
"no está permitido en Cairo.\n"
"Para evitar esto, la propiedad de la variable `arr` se mueve de la función `main` a "
"la función `foo`. Cuando se intenta llamar a \n"
"`bar` con `arr` como parámetro, la propiedad de `arr` ya se movió a la primera "
"llamada. El sistema de propiedad nos impide usar \n"
"la misma instancia de `arr` en `foo`."

#: src/ch03-01-what-is-ownership.md:104
msgid "Running the code above will result in a compile-time error:"
msgstr "Ejecutar el código anterior resultará en un error en tiempo de compilación:"

#: src/ch03-01-what-is-ownership.md:106
msgid ""
"```console\n"
"error: Variable was previously moved. Trait has no implementation in context: core::"
"traits::Copy::<core::array::Array::<core::integer::u128>>\n"
" --> array.cairo:6:9\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"        ^*****^\n"
"```"
msgstr ""
"```console\n"
"error: Variable was previously moved. Trait has no implementation in context: core::"
"traits::Copy::<core::array::Array::<core::integer::u128>>\n"
" --> array.cairo:6:9\n"
"    let mut arr = ArrayTrait::<u128>::new();\n"
"        ^*****^\n"
"```"

#: src/ch03-01-what-is-ownership.md:113
msgid "### The `Copy` Trait"
msgstr "### El Trait `Copy`"

#: src/ch03-01-what-is-ownership.md:115
msgid ""
"If a type implements the `Copy` trait, passing it to a function will not move the "
"ownership of the value to the function called, but will instead pass a copy of the "
"value.\n"
"You can implement the `Copy` trait on your type by adding the `#[derive(Copy)]` "
"annotation to your type definition. However, Cairo won't allow a type to be "
"annotated with Copy if the type itself or any of its components don't implement the "
"Copy trait.\n"
"While Arrays and Dictionaries can't be copied, custom types that don't contain "
"either of them can be."
msgstr ""
"Si un tipo implementa el trait `Copy`, pasar su valor a una función no moverá la "
"propiedad del valor a la función llamada, sino que pasará una copia del valor.\n"
"Puedes implementar el trait `Copy` en tu tipo agregando la anotación "
"`#[derive(Copy)]` a la definición de tu tipo. Sin embargo, Cairo no permitirá que "
"un tipo sea anotado con `Copy` si el tipo en sí mismo o cualquiera de sus "
"componentes no implementan el trait `Copy`.\n"
"Mientras que los Arrays y Diccionarios no pueden ser copiados, los tipos "
"personalizados que no los contienen sí pueden serlo."

#: src/ch03-01-what-is-ownership.md:119
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) {\n"
"    // do something with p\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct Point {\n"
"    x: u128,\n"
"    y: u128,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 5, y: 10 };\n"
"    foo(p1);\n"
"    foo(p1);\n"
"}\n"
"\n"
"fn foo(p: Point) {\n"
"    // do something with p\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:137
msgid ""
"In this example, we can pass `p1` twice to the foo function because the `Point` "
"type implements the `Copy` trait. This means that when we pass `p1` to `foo`, we "
"are actually passing a copy of `p1`, and the ownership of `p1` remains with the "
"main function.\n"
"If you remove the `Copy` trait derivation from the `Point` type, you will get a "
"compile-time error when trying to compile the code."
msgstr ""
"En este ejemplo, podemos pasar `p1` dos veces a la función `foo` porque el tipo "
"`Point` implementa el trait `Copy`. Esto significa que cuando pasamos `p1` a `foo`, "
"en realidad estamos pasando una copia de `p1`, y la propiedad de `p1` permanece en "
"la función principal.\n"
"Si eliminamos la derivación del trait `Copy` del tipo `Point`, obtendremos un error "
"en tiempo de compilación al intentar compilar el código."

#: src/ch03-01-what-is-ownership.md:140
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter 4]"
"(ch04-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"_No te preocupes por la palabra clave `Struct`. La introduciremos en el [Capítulo 4]"
"(ch04-00-using-structs-to-structure-related-data.md)._"

#: src/ch03-01-what-is-ownership.md:142
msgid "### The `Drop` Trait"
msgstr "### El Trait `Drop`"

#: src/ch03-01-what-is-ownership.md:144
msgid ""
"You may have noticed that the `Point` type in the previous example also implements "
"the `Drop` trait. In Cairo, a value cannot go out of scope unless it has been "
"previously moved.\n"
"For example, the following code will not compile, because the struct `A` is not "
"moved before it goes out of scope:"
msgstr ""
"Es posible que hayas notado que el tipo `Point` en el ejemplo anterior también "
"implementa el trait `Drop`. En Cairo, un valor no puede salir del ámbito a menos "
"que se haya movido previamente.\n"
"Por ejemplo, el siguiente código no se compilará porque la estructura `A` no se "
"mueve antes de que salga del ámbito:"

#: src/ch03-01-what-is-ownership.md:147
msgid ""
"```rust\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // error: Value not dropped.\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:155
msgid ""
"This is to ensure the soundness of Cairo programs. Soundness refers to the fact "
"that if a\n"
"statement during the execution of the program is false, no cheating prover can "
"convince an\n"
"honest verifier that it is true. In our case, we want to ensure the consistency of\n"
"consecutive dictionary key updates during program execution, which is only checked "
"when\n"
"the dictionaries are`squashed` - which moves the ownership of the dictionary to "
"the\n"
"`squash` method, thus allowing the dictionary to go out of scope. Unsquashed "
"dictionaries\n"
"are dangerous, as a malicious prover could prove the correctness of inconsistent "
"updates."
msgstr ""
"En Cairo, esto se hace para garantizar la solidez de los programas. La solidez se "
"refiere al hecho de\n"
" que si una declaración durante la ejecución del programa es falsa, ningún probador "
"deshonesto puede\n"
" convencer a un verificador honesto de que es verdadera. En nuestro caso, queremos "
"asegurar la consistencia \n"
"de las actualizaciones consecutivas de claves de un diccionario durante la "
"ejecución del programa, lo cua\n"
"l solo se verifica cuando los diccionarios se \"aplastan\" - lo que mueve la "
"propiedad del diccionario al método `squash`, \n"
"permitiendo que el diccionario salga de ámbito. Los diccionarios no \"aplastados\" "
"son peligrosos, ya que un probador \n"
"malintencionado podría probar la corrección de actualizaciones inconsistentes."

#: src/ch03-01-what-is-ownership.md:163
msgid ""
"However, types that implement the `Drop` trait are allowed to go out of scope "
"without being explicitly moved. When a value of a type that implements the `Drop` "
"trait goes out of scope, the `Drop` implementation is called on the type, which "
"moves the value to the `drop` function, allowing it to go out of scope - This is "
"what we call \"dropping\" a value.\n"
"It is important to note that the implementation of drop is a \"no-op\", meaning "
"that it doesn't perform any actions other than allowing the value to go out of "
"scope."
msgstr ""
"Sin embargo, los tipos que implementan el trait `Drop` se permiten que salgan de "
"ámbito sin ser movidos explícitamente. Cuando un valor de un tipo que implementa el "
"trait `Drop` sale de ámbito, se llama a la implementación `Drop` en el tipo, lo que "
"mueve el valor a la función `drop`, permitiendo que salga de ámbito: esto es lo que "
"llamamos \"eliminar\" un valor. \n"
"Es importante tener en cuenta que la implementación de `Drop` es una \"operación "
"nula\", lo que significa que no realiza ninguna acción aparte de permitir que el "
"valor salga de ámbito."

#: src/ch03-01-what-is-ownership.md:166
msgid ""
"The `Drop` implementation can be derived for all types, allowing them to be dropped "
"when goint out of scope, except for dictionaries (`Felt252Dict`) and types "
"containing dictionaries.\n"
"For example, the following code compiles:"
msgstr ""
"La implementación de `Drop` se puede derivar para todos los tipos, lo que les "
"permite eliminarse al salir de ámbito, excepto para los diccionarios "
"(`Felt252Dict`) y los tipos que contienen diccionarios.\n"
"Por ejemplo, el siguiente código compila:"

#: src/ch03-01-what-is-ownership.md:169
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A {}\n"
"\n"
"fn main() {\n"
"    A {}; // Now there is no error.\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:178
msgid "### The `Destruct` Trait"
msgstr "### El Trait `Destruct`"

#: src/ch03-01-what-is-ownership.md:180
msgid ""
"Manually calling the `squash` method on a dictionary is not very convenient, and it "
"is easy to forget to do so. To make it easier to use dictionaries, Cairo provides "
"the `Destruct` trait, which allows you to specify the behavior of a type when it "
"goes out of scope. While Dictionaries don't implement the `Drop` trait, they do "
"implement the `Destruct` trait, which allows them to automatically be `squashed` "
"when they go out of scope. This means that you can use dictionaries without having "
"to manually call the `squash` method."
msgstr ""
"Llamar manualmente al método `squash` en un diccionario no es muy conveniente y es "
"fácil de olvidar hacerlo. Para facilitar el uso de los diccionarios, Cairo "
"proporciona el trait `Destruct`, que te permite especificar el comportamiento de un "
"tipo cuando sale del ámbito. Si bien los diccionarios no implementan el trait "
"`Drop`, sí implementan el trait `Destruct`, lo que les permite ser `aplastados` "
"automáticamente cuando salen del ámbito. Esto significa que puedes usar "
"diccionarios sin tener que llamar manualmente al método `squash`."

#: src/ch03-01-what-is-ownership.md:182
msgid ""
"Consider the following example, in which we define a custom type that contains a "
"dictionary:"
msgstr ""
"Considera el siguiente ejemplo, en el que definimos un tipo personalizado que "
"contiene un diccionario:"

#: src/ch03-01-what-is-ownership.md:184
msgid ""
"```rust\n"
"use dict::Felt252DictTrait;\n"
"\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A {\n"
"        dict: Felt252DictTrait::new()\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use dict::Felt252DictTrait;\n"
"\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A {\n"
"        dict: Felt252DictTrait::new()\n"
"    };\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:198
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "Si intenta ejecutar este código, obtendrá un error de tiempo de compilación:"

#: src/ch03-01-what-is-ownership.md:200
msgid ""
"```console\n"
"error: Variable not dropped. Trait has no implementation in context: core::traits::"
"Drop::<temp7::temp7::A>. Trait has no implementation in context: core::traits::"
"Destruct::<temp7::temp7::A>.\n"
" --> temp7.cairo:7:5\n"
"    A {\n"
"    ^*^\n"
"```"
msgstr ""
"```console\n"
"error: Variable not dropped. Trait has no implementation in context: core::traits::"
"Drop::<temp7::temp7::A>. Trait has no implementation in context: core::traits::"
"Destruct::<temp7::temp7::A>.\n"
" --> temp7.cairo:7:5\n"
"    A {\n"
"    ^*^\n"
"```"

#: src/ch03-01-what-is-ownership.md:207
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the `Drop` "
"(as it contains a dictionary and can't `derive(Drop)`) nor the `Destruct` trait. To "
"fix this, we can derive the `Destruct` trait implementation for the `A` type:"
msgstr ""
"Cuando `A` sale del alcance, no puede ser liberado ya que no implementa ni el "
"`Drop` (ya que contiene un diccionario y no puede `derive(Drop)`) ni el trait "
"`Destruct`. Para solucionar esto, podemos derivar la implementación del trait "
"`Destruct` para el tipo `A`:"

#: src/ch03-01-what-is-ownership.md:209
msgid ""
"```rust\n"
"use dict::Felt252DictTrait;\n"
"\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A {\n"
"        dict: Felt252DictTrait::new()\n"
"    }; // No error here\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use dict::Felt252DictTrait;\n"
"\n"
"#[derive(Destruct)]\n"
"struct A {\n"
"    dict: Felt252Dict<u128>\n"
"}\n"
"\n"
"fn main() {\n"
"    A {\n"
"        dict: Felt252DictTrait::new()\n"
"    }; // No error here\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:224
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically `squashed`, "
"and the program will compile."
msgstr ""
"Ahora, cuando `A` salga del ámbito, su diccionario será automáticamente `squashed`, "
"y el programa compilará."

#: src/ch03-01-what-is-ownership.md:226
msgid "### Copy Array data with Clone"
msgstr "### Copiar datos de un Array con Clone"

#: src/ch03-01-what-is-ownership.md:228
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common method "
"called `clone`. We’ll discuss method syntax in Chapter 5, but because methods are a "
"common feature in many\n"
"programming languages, you’ve probably seen them before."
msgstr ""
"Si queremos copiar profundamente los datos de un `Array`, podemos utilizar un "
"método común llamado `clone`. Discutiremos la sintaxis de los métodos en el "
"Capítulo 5, pero como los métodos son una característica común en muchos lenguajes "
"de programación, es probable que ya los hayas visto antes."

#: src/ch03-01-what-is-ownership.md:231
msgid "Here’s an example of the `clone` method in action."
msgstr "Aquí hay un ejemplo del método `clone` en acción."

#: src/ch03-01-what-is-ownership.md:233
msgid ""
"> Note: in the following example, we need to import the `Clone` trait from the "
"corelib `clone` module, and its implementation for the array type from the `array` "
"module."
msgstr ""
"> Nota: en el siguiente ejemplo, necesitamos importar el rasgo `Clone` del módulo "
"`clone` de la biblioteca estándar, y su implementación para el tipo `array` del "
"módulo `array`."

#: src/ch03-01-what-is-ownership.md:235
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use clone::Clone;\n"
"use array::ArrayTCloneImpl;\n"
"...\n"
"let arr1 = ArrayTrait::<u128>::new();\n"
"let arr2 = arr1.clone();\n"
"\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"use clone::Clone;\n"
"use array::ArrayTCloneImpl;\n"
"...\n"
"let arr1 = ArrayTrait::<u128>::new();\n"
"let arr2 = arr1.clone();\n"
"\n"
"```"

#: src/ch03-01-what-is-ownership.md:245
msgid ""
"> Note: you will need to run `cairo-run` with the `--available-gas=2000000` option "
"to run this example, because it uses a loop and must be ran with a gas limit."
msgstr ""
"> Nota: necesitarás ejecutar `cairo-run` con la opción `--available-gas=2000000` "
"para ejecutar este ejemplo, ya que utiliza un bucle y debe ser ejecutado con un "
"límite de gas."

#: src/ch03-01-what-is-ownership.md:247
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being\n"
"executed and that code may be expensive. It’s a visual indicator that something\n"
"different is going on."
msgstr ""
"Cuando ves una llamada a `clone`, sabes que se está ejecutando algún código "
"arbitrario\n"
" y ese código puede ser costoso. Es un indicador visual de que algo diferente está "
"sucediendo."

#: src/ch03-01-what-is-ownership.md:251
msgid "### Ownership and Functions"
msgstr "### Ownership y Funciones"

#: src/ch03-01-what-is-ownership.md:253
msgid ""
"Passing a variable to a function will either move it or copy it. As seen in the "
"Array section, passing an `Array` as a function parameter transfers its ownership; "
"let's see what happens with other types."
msgstr ""
"Pasar una variable a una función puede moverla o copiarla. Como se vio en la "
"sección de Array, pasar un `Array` como parámetro de función transfiere su "
"propiedad; veamos qué sucede con otros tipos."

#: src/ch03-01-what-is-ownership.md:255
msgid ""
"Listing 3-3 has an example with some annotations\n"
"showing where variables go into and out of scope."
msgstr ""
"El Listado 3-3 tiene un ejemplo con algunas anotaciones \n"
"que muestran dónde las variables entran y salen de ámbito."

#: src/ch03-01-what-is-ownership.md:258 src/ch03-01-what-is-ownership.md:300
#: src/ch03-01-what-is-ownership.md:353
msgid "<span class=\"filename\">Filename: src/main.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/main.cairo</span>"

#: src/ch03-01-what-is-ownership.md:260
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the "
"function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5_u128;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is okay to "
"still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct MyStruct{}\n"
"\n"
"fn main() {\n"
"    let my_struct = MyStruct{};  // my_struct comes into scope\n"
"\n"
"    takes_ownership(my_struct);     // my_struct's value moves into the "
"function...\n"
"                                    // ... and so is no longer valid here\n"
"\n"
"    let x = 5_u128;                 // x comes into scope\n"
"\n"
"    makes_copy(x);                  // x would move into the function,\n"
"                                    // but u128 implements Copy, so it is okay to "
"still\n"
"                                    // use x afterward\n"
"\n"
"}                                   // Here, x goes out of scope and is dropped.\n"
"\n"
"\n"
"fn takes_ownership(some_struct: MyStruct) { // some_struct comes into scope\n"
"} // Here, some_struct goes out of scope and `drop` is called.\n"
"\n"
"fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope\n"
"} // Here, some_integer goes out of scope and is dropped.\n"
"```"

#: src/ch03-01-what-is-ownership.md:286
msgid ""
"<span class=\"caption\">Listing 3-3: Functions with ownership and scope\n"
"annotated</span>"
msgstr ""
"<span class=\"caption\">Listing 3-3: Functions with ownership and scope\n"
"annotated</span>"

#: src/ch03-01-what-is-ownership.md:289
msgid ""
"If we tried to use `my_struct` after the call to `takes_ownership`, Cairo would "
"throw a\n"
"compile-time error. These static checks protect us from mistakes. Try adding\n"
"code to `main` that uses `my_struct` and `x` to see where you can use them and "
"where\n"
"the ownership rules prevent you from doing so."
msgstr ""
"Si intentamos usar `my_struct` después de la llamada a `takes_ownership`, Cairo "
"lanzará un \n"
"error en tiempo de compilación. Estas verificaciones estáticas nos protegen de "
"errores. Intenta \n"
"agregar código a `main` que use `my_struct` y `x` para ver dónde puedes usarlos y "
"dónde las \n"
"reglas de propiedad te impiden hacerlo."

#: src/ch03-01-what-is-ownership.md:294
msgid "### Return Values and Scope"
msgstr "### Valores de retorno y alcance"

#: src/ch03-01-what-is-ownership.md:296
msgid ""
"Returning values can also transfer ownership. Listing 3-4 shows an example of a\n"
"function that returns some value, with similar annotations as those in Listing\n"
"4-3."
msgstr ""
"La devolución de valores también puede transferir la propiedad. El Listado 3-4 "
"muestra \n"
"un ejemplo de una función que devuelve algún valor, con anotaciones similares a las "
"del Listado 4-3."

#: src/ch03-01-what-is-ownership.md:302
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A{}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A{};                         // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A{};                     // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"struct A{}\n"
"\n"
"fn main() {\n"
"    let a1 = gives_ownership();           // gives_ownership moves its return\n"
"                                          // value into a1\n"
"\n"
"    let a2 = A{};                         // a2 comes into scope\n"
"\n"
"    let a3 = takes_and_gives_back(a2);    // a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
"\n"
"} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
"\n"
"fn gives_ownership() -> A {               // gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
"\n"
"    let some_a = A{};                     // some_a comes into scope\n"
"\n"
"    some_a                                // some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
"}\n"
"\n"
"// This function takes an instance some_a of A and returns it\n"
"fn takes_and_gives_back(some_a: A) -> A { // some_a comes into\n"
"                                          // scope\n"
"\n"
"    some_a                               // some_a is returned and moves\n"
"                                         // ownership to the calling\n"
"                                         // function\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:340
msgid ""
"<span class=\"caption\">Listing 3-4: Transferring ownership of return\n"
"values</span>"
msgstr ""
"<span class=\"caption\">Listado 3-4: Transferencia de propiedad de \n"
"valores devueltos</span>"

#: src/ch03-01-what-is-ownership.md:343
msgid ""
"When a variable goes out of scope, its value is dropped, unless ownership of the "
"value has been moved to another variable."
msgstr ""
"Cuando una variable sale del ámbito, su valor se elimina, a menos que la propiedad "
"del valor se haya transferido a otra variable."

#: src/ch03-01-what-is-ownership.md:345
msgid ""
"While this works, taking ownership and then returning ownership with every\n"
"function is a bit tedious. What if we want to let a function use a value but\n"
"not take ownership? It’s quite annoying that anything we pass in also needs to\n"
"be passed back if we want to use it again, in addition to any data resulting\n"
"from the body of the function that we might want to return as well."
msgstr ""
"Si bien esto funciona, tomar propiedad y luego devolver la propiedad con cada\n"
" función es un poco tedioso. ¿Qué sucede si queremos permitir que una función use \n"
"un valor pero no tome posesión de él? Es bastante molesto que todo lo que pasemos \n"
"también deba ser devuelto si queremos usarlo nuevamente, además de cualquier\n"
" dato que resulte del cuerpo de la función que también podríamos querer devolver."

#: src/ch03-01-what-is-ownership.md:351
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing 3-5."
msgstr ""
"Cairo nos permite devolver varios valores usando una tupla, como se muestra en el "
"Listado 3-5"

#: src/ch03-01-what-is-ownership.md:355
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"fn main() {\n"
"    let arr1 = ArrayTrait::<u128>::new();\n"
"\n"
"    let (arr2, len) = calculate_length(arr1);\n"
"}\n"
"\n"
"fn calculate_length(arr: Array<u128>) -> (Array<u128>, usize) {\n"
"    let length = arr.len(); // len() returns the length of an array\n"
"\n"
"    (arr, length)\n"
"}\n"
"```"

#: src/ch03-01-what-is-ownership.md:370
msgid "<span class=\"caption\">Listing 3-5: Returning ownership of parameters</span>"
msgstr ""
"<span class=\"caption\">Listado 3-5: Devolviendo propiedad de los parámetros</span>"

#: src/ch03-01-what-is-ownership.md:372
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be\n"
"common. Luckily for us, Cairo has two features for using a value without\n"
"transferring ownership, called _references_ and _snapshots_."
msgstr ""
"Pero esto es demasiado ceremonioso y mucho trabajo para un concepto que \n"
"debería ser común. Afortunadamente, Cairo tiene dos características para usar\n"
" un valor sin transferir la propiedad, llamadas _referencias_ y _snapshots_."

#: src/ch03-02-references-and-snapshots.md:1
msgid "## References and Snapshots"
msgstr "## Referencias y Snapshots"

#: src/ch03-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in Listing 3-5 is that we have to return the\n"
"`Array` to the calling function so we can still use the `Array` after the\n"
"call to `calculate_length`, because the `Array` was moved into\n"
"`calculate_length`."
msgstr ""
"El problema con el código de tupla en el Listado 3-5 es que tenemos que \n"
"devolver el `Array` a la función de llamada para que podamos seguir usando \n"
"el `Array` después de la llamada a `calculate_length`, ya que el `Array` se \n"
"movió a `calculate_length`."

#: src/ch03-02-references-and-snapshots.md:8
msgid "### Snapshots"
msgstr "### Snapshots"

#: src/ch03-02-references-and-snapshots.md:10
msgid ""
"Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a snapshot\n"
"is an immutable view of a value at a certain point in time. In the previous "
"chapter,\n"
"we talked about how Cairo's ownership system prevents us from using a value after\n"
"we've moved it, protecting us from potentially writing twice to the same memory "
"cell when\n"
"appending values to arrays. However, it's not very convenient. Let's see how we can "
"retain ownership\n"
"of the value in the calling function using snapshots."
msgstr ""
"En su lugar, podemos proporcionar una _instantánea_ del valor `Array`. En Cairo, "
"una instantánea\n"
" es una vista inmutable de un valor en un cierto momento en el tiempo. En el "
"capítulo anterior, \n"
"hablamos de cómo el sistema de propiedad de Cairo nos impide usar un valor después "
"de \n"
"haberlo movido, protegiéndonos de escribir potencialmente dos veces en la misma "
"celda de \n"
"memoria al agregar valores a los arreglos. Sin embargo, no es muy conveniente. "
"Veamos cómo \n"
"podemos mantener la propiedad del valor en la función de llamada usando "
"instantáneas."

#: src/ch03-02-references-and-snapshots.md:17
msgid ""
"Here is how you would define and use a `calculate_length` function that takes a\n"
"snapshot to an array as a parameter instead of taking ownership of the underlying "
"value. In this example,\n"
"the `calculate_length` function returns the length of the array passed as "
"parameter.\n"
"As we're passing it as a snapshot, which is an immutable view of the array, we can "
"be sure that\n"
"the `calculate_length` function will not mutate the array, and ownership of the "
"array is kept in the main function."
msgstr ""
"Aquí es cómo definiría y usaría una función `calculate_length` que toma una "
"instantánea \n"
"de un arreglo como parámetro en lugar de tomar propiedad del valor subyacente. En "
"este ejemplo, \n"
"la función `calculate_length` devuelve la longitud del arreglo pasado como "
"parámetro.\n"
"Como lo estamos pasando como una instantánea, que es una vista inmutable del "
"arreglo, podemos estar seguros\n"
" de que la función `calculate_length` no mutará el arreglo, y la propiedad del "
"arreglo se mantiene en la función principal."

#: src/ch03-02-references-and-snapshots.md:25
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"    arr1.append(1_u128); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(first_snapshot); // Calculate the length of "
"the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of "
"the array\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr1 = ArrayTrait::<u128>::new();\n"
"    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time\n"
"    arr1.append(1_u128); // Mutate `arr1` by appending a value\n"
"    let first_length = calculate_length(first_snapshot); // Calculate the length of "
"the array when the snapshot was taken\n"
"    let second_length = calculate_length(@arr1); // Calculate the current length of "
"the array\n"
"    first_length.print();\n"
"    second_length.print();\n"
"}\n"
"\n"
"fn calculate_length(arr: @Array<u128>) -> usize {\n"
"    arr.len()\n"
"}\n"
"```"

#: src/ch03-02-references-and-snapshots.md:44
msgid ""
"> Note: It is only possible to call the `len()` method on an array snapshot because "
"it is defined as such in the `ArrayTrait` trait. If you try to call a method that "
"is not defined for snapshots on a snapshot, you will get a compilation error. "
"However, you can call methods expecting a snapshot on non-snapshot types."
msgstr ""
"> Nota: Solo es posible llamar al método `len()` en un snapshot de un array porque "
"está definido así en el trait `ArrayTrait`. Si intentas llamar a un método que no "
"está definido para snapshots en un snapshot, obtendrás un error de compilación. Sin "
"embargo, puedes llamar a métodos que esperan un snapshot en tipos que no son "
"snapshots"

#: src/ch03-02-references-and-snapshots.md:46
msgid "The output of this program is:"
msgstr "La salida de este programa es:"

#: src/ch03-02-references-and-snapshots.md:48
msgid ""
"```console\n"
"[DEBUG]\t                               \t(raw: 0)\n"
"\n"
"[DEBUG]\t                              \t(raw: 1)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```console\n"
"[DEBUG]\t                               \t(raw: 0)\n"
"\n"
"[DEBUG]\t                              \t(raw: 1)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch03-02-references-and-snapshots.md:56
msgid ""
"First, notice that all the tuple code in the variable declaration and the function "
"return value is gone. Second, note\n"
"that we pass `@arr1` into `calculate_length` and, in its definition, we take "
"`@Array<u128>` rather than `Array<u128>`."
msgstr ""
"La primera observación es que todo el código de tuplas en la declaración de "
"variables y en el valor de retorno de la función \n"
"ha desaparecido. La segunda observación es que pasamos `@arr1` a `calculate_length` "
"y, en su definición, tomamos\n"
" `@Array<u128>` en lugar de `Array<u128>`."

#: src/ch03-02-references-and-snapshots.md:59
msgid "Let’s take a closer look at the function call here:"
msgstr "Veamos más de cerca la llamada a la función aquí:"

#: src/ch03-02-references-and-snapshots.md:61
msgid ""
"```rust\n"
"let mut arr1 = ArrayTrait::<u128>::new();\n"
"let second_length = calculate_length(@arr1); // Calculate the current length of the "
"array\n"
"```"
msgstr ""
"```rust\n"
"let mut arr1 = ArrayTrait::<u128>::new();\n"
"let second_length = calculate_length(@arr1); // Calculate the current length of the "
"array\n"
"```"

#: src/ch03-02-references-and-snapshots.md:66
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because a "
"snapshot is an immutable view of a value, the value it points to cannot be modified "
"through the snapshot, and the value it refers to will not be dropped once the "
"snapshot stops being used."
msgstr ""
"La sintaxis `@arr1` nos permite crear una instantánea (snapshot) del valor en "
"`arr1`. Como una instantánea es una vista inmutable de un valor, el valor al que "
"apunta no puede ser modificado a través de la instantánea y el valor al que se "
"refiere no será eliminado una vez que la instantánea deje de ser usada."

#: src/ch03-02-references-and-snapshots.md:68
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type of the "
"parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""
"De manera similar, la firma de la función utiliza `@` para indicar que el tipo del "
"parámetro `arr` es una instantánea. Añadamos algunas anotaciones explicativas:"

#: src/ch03-02-references-and-snapshots.md:70
msgid ""
"```rust\n"
"fn calculate_length(array_snapshot: @Array<u128>) -> usize { // array_snapshot is a "
"snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, "
"the original `arr` can still be used.\n"
"```"
msgstr ""
"```rust\n"
"fn calculate_length(array_snapshot: @Array<u128>) -> usize { // array_snapshot is a "
"snapshot of an Array\n"
"    array_snapshot.len()\n"
"} // Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, "
"the original `arr` can still be used.\n"
"```"

#: src/ch03-02-references-and-snapshots.md:77
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not dropped "
"when `array_snapshot` stops being used. When functions have snapshots as parameters "
"instead of the actual values, we won’t need to return the values in order to give "
"back ownership of the original value, because we never had it."
msgstr ""
"El alcance en el que la variable `array_snapshot` es válida es el mismo que el "
"alcance de cualquier parámetro de función, pero el valor subyacente del snapshot no "
"se eliminará cuando `array_snapshot` deje de usarse. Cuando las funciones tienen "
"snapshots como parámetros en lugar de los valores reales, no necesitamos devolver "
"los valores para devolver la propiedad del valor original, porque nunca la tuvimos."

#: src/ch03-02-references-and-snapshots.md:79
msgid ""
"Snapshots can be converted back into regular values using the `desnap` operator "
"`*`, as long as the value type is copyable (which is not the case for Arrays, as "
"they don't implement `Copy`). In the following example, we want to calculate the "
"area of a rectangle, but we don't want to take ownership of the rectangle in the "
"`calculate_area` function, because we might want to use the rectangle again after "
"the function call. Since our function doesn't mutate the rectangle instance, we can "
"pass the snapshot of the rectangle to the function, and then transform the "
"snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Los snapshots se pueden convertir de nuevo en valores regulares usando el operador "
"`desnap` `*`, siempre y cuando el tipo de valor sea copiable (lo cual no es el caso "
"para los Arrays, ya que no implementan `Copy`). En el siguiente ejemplo, queremos "
"calcular el área de un rectángulo, pero no queremos tomar la propiedad del "
"rectángulo en la función `calculate_area`, porque podríamos querer usar el "
"rectángulo de nuevo después de la llamada a la función. Dado que nuestra función no "
"muta la instancia del rectángulo, podemos pasar el snapshot del rectángulo a la "
"función, y luego transformar los snapshots de nuevo en valores usando el operador "
"`desnap` `*`."

#: src/ch03-02-references-and-snapshots.md:81
msgid ""
"The snapshot type is always copyable and droppable, so that you can use it multiple "
"times without worrying about ownership transfers."
msgstr ""
"El tipo de snapshot siempre es copiable y eliminable, para que pueda usarlo varias "
"veces sin preocuparse por las transferencias de propiedad."

#: src/ch03-02-references-and-snapshots.md:83
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy,Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main(){\n"
"    let rec = Rectangle{height:3_u64, width:10_u64};\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"#[derive(Copy,Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main(){\n"
"    let rec = Rectangle{height:3_u64, width:10_u64};\n"
"    let area = calculate_area(@rec);\n"
"    area.print();\n"
"\n"
"}\n"
"\n"
"fn calculate_area(rec: @Rectangle) -> u64 {\n"
"    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
"    *rec.height * *rec.width\n"
"}\n"
"```"

#: src/ch03-02-references-and-snapshots.md:108
msgid ""
"But, what happens if we try to modify something we’re passing as snapshot? Try the "
"code in\n"
"Listing 3-6. Spoiler alert: it doesn’t work!"
msgstr ""
"Pero, ¿qué sucede si intentamos modificar algo que estamos pasando como "
"instantánea? Prueba el código \n"
"en la Lista 3-6. ¡Alerta de spoiler: no funciona!"

#: src/ch03-02-references-and-snapshots.md:113
msgid ""
"```rust\n"
"#[derive(Copy,Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main(){\n"
"    let rec = Rectangle{height:3_u64, width:10_u64};\n"
"    flip(@rec);\n"
"}\n"
"\n"
"fn flip(rec: @Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy,Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main(){\n"
"    let rec = Rectangle{height:3_u64, width:10_u64};\n"
"    flip(@rec);\n"
"}\n"
"\n"
"fn flip(rec: @Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"

#: src/ch03-02-references-and-snapshots.md:132
msgid ""
"<span class=\"caption\">Listing 3-6: Attempting to modify a snapshot value</span>"
msgstr ""
"<span class=\"caption\">Listado 3-6: Intentando modificar un valor de snapshot</"
"span>"

#: src/ch03-02-references-and-snapshots.md:134
msgid "Here’s the error:"
msgstr "Aquí está el error:"

#: src/ch03-02-references-and-snapshots.md:136
msgid ""
"```console\n"
"error: Invalid left-hand side of assignment.\n"
" --> ownership.cairo:15:5\n"
"    rec.height = rec.width;\n"
"    ^********^\n"
"```"
msgstr ""
"```console\n"
"error: Invalid left-hand side of assignment.\n"
" --> ownership.cairo:15:5\n"
"    rec.height = rec.width;\n"
"    ^********^\n"
"```"

#: src/ch03-02-references-and-snapshots.md:143
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr "El compilador nos impide modificar los valores asociados a las instantáneas."

#: src/ch03-02-references-and-snapshots.md:145
msgid "### Mutable References"
msgstr "### Referencias Mutables"

#: src/ch03-02-references-and-snapshots.md:147
msgid ""
"We can achieve the behavior we want in Listing 3-6 by using a _mutable reference_ "
"instead of a snapshot. Mutable references are actually mutable values passed to a "
"function that are implicitly returned at the end of the function, returning "
"ownership to the calling context. By doing so, they allow you to mutate the value "
"passed while keeping ownership of it by returning it automatically at the end of "
"the execution.\n"
"In Cairo, a parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Podemos lograr el comportamiento que queremos en el Listado 3-6 utilizando una "
"_referencia mutable_ en lugar de un snapshot. Las referencias mutables son valores "
"mutables pasados a una función que se devuelven implícitamente al final de la "
"función, devolviendo la propiedad al contexto de llamada. Al hacerlo, le permiten "
"mutar el valor pasado y mantener su propiedad devolviéndolo automáticamente al "
"final de la ejecución.\n"
"En Cairo, se puede pasar un parámetro como _referencia mutable_ utilizando el "
"modificador `ref`."

#: src/ch03-02-references-and-snapshots.md:150
msgid ""
"> **Note**: In Cairo, a parameter can only be passed as _mutable reference_ using "
"the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"> **Nota**: En Cairo, un parámetro solo se puede pasar como _referencia mutable_ "
"utilizando el modificador `ref` si la variable se declara como mutable con `mut`."

#: src/ch03-02-references-and-snapshots.md:152
msgid ""
"In Listing 3-7, we use a mutable reference to modify the value of the `height` and "
"`width` fields of the `Rectangle` instance in the `flip` function."
msgstr ""
"En el Listado 3-7, usamos una referencia mutable para modificar el valor del campo "
"`height` de la instancia de `Rectangle` en la función `flip`."

#: src/ch03-02-references-and-snapshots.md:154
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rec = Rectangle { height: 3_u64, width: 10_u64 };\n"
"    flip(ref rec);\n"
"    rec.height.print();\n"
"    rec.width.print();\n"
"}\n"
"\n"
"fn flip(ref rec: Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    height: u64,\n"
"    width: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rec = Rectangle { height: 3_u64, width: 10_u64 };\n"
"    flip(ref rec);\n"
"    rec.height.print();\n"
"    rec.width.print();\n"
"}\n"
"\n"
"fn flip(ref rec: Rectangle) {\n"
"    let temp = rec.height;\n"
"    rec.height = rec.width;\n"
"    rec.width = temp;\n"
"}\n"
"```"

#: src/ch03-02-references-and-snapshots.md:176
msgid ""
"<span class=\"caption\">Listing 3-7: Use of a mutable reference to modify a value</"
"span>"
msgstr ""
"<span class=\"caption\">Listing 3-7: Uso de una referencia mutable para modificar "
"un valor</span>"

#: src/ch03-02-references-and-snapshots.md:178
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of `rec` into "
"`flip` with `ref rec`, and update the function signature to accept a mutable "
"reference with `ref rec: Rectangle`. This makes it very clear that the `flip` "
"function will mutate the value of the `Rectangle` instance passed as parameter."
msgstr ""
"Primero, cambiamos `rec` a `mut`. Luego, pasamos una referencia mutable de `rec` a "
"`flip` con `ref rec` y actualizamos la firma de la función para aceptar una "
"referencia mutable con `ref rec: Rectangle`. Esto deja muy claro que la función "
"`flip` modificará el valor de la instancia de `Rectangle` pasada como parámetro."

#: src/ch03-02-references-and-snapshots.md:180
msgid "The output of the program is:"
msgstr "La salida del programa es:"

#: src/ch03-02-references-and-snapshots.md:182
msgid ""
"```console\n"
"[DEBUG]\n"
"                                (raw: 10)\n"
"\n"
"[DEBUG]\t                        (raw: 3)\n"
"```"
msgstr ""
"```console\n"
"[DEBUG]\n"
"                                (raw: 10)\n"
"\n"
"[DEBUG]\t                        (raw: 3)\n"
"```"

#: src/ch03-02-references-and-snapshots.md:189
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""
"Como era de esperar, los campos `height` y `width` de la variable `rec` se han "
"intercambiado."

#: src/ch03-02-references-and-snapshots.md:191
msgid "### Small recap"
msgstr "### Pequeño resumen"

#: src/ch03-02-references-and-snapshots.md:193
msgid "Let’s recap what we’ve discussed about ownership, snapshots, and references:"
msgstr ""
"Como resumen, lo que hemos discutido acerca de ownership, snapshots y las "
"referencias es:"

#: src/ch03-02-references-and-snapshots.md:195
msgid ""
"- At any given time, a variable can only have one owner.\n"
"- You can pass a variable by-value, by-snapshot, or by-reference to a function.\n"
"- If you pass-by-value, ownership of the variable is transferred to the function.\n"
"- If you want to keep ownership of the variable and know that your function won’t "
"mutate it, you can pass it as a snapshot with `@`.\n"
"- If you want to keep ownership of the variable and know that your function will "
"mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"- En un momento dado, una variable solo puede tener un propietario.\n"
"- Puedes pasar una variable por valor, por instantánea o por referencia a una "
"función.\n"
"- Si pasas una variable por valor, la propiedad de la variable se transfiere a la "
"función.\n"
"- Si quieres mantener la propiedad de la variable y sabes que tu función no la va a "
"modificar, puedes pasarla como instantánea con `@`.\n"
"- Si quieres mantener la propiedad de la variable y sabes que tu función la "
"modificará, puedes pasarla como referencia mutable con `ref`."

#: src/ch04-00-using-structs-to-structure-related-data.md:1
msgid "# Using Structs to Structure Related Data"
msgstr "# Usando structs para estructurar datos relacionados"

#: src/ch04-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together and "
"name multiple related values that make up a meaningful group. If you’re familiar "
"with an object-oriented language, a struct is like an object’s data attributes. In "
"this chapter, we’ll compare and contrast tuples with structs to build on what you "
"already know and demonstrate when structs are a better way to group data."
msgstr ""
"Un struct, o estructura, es un tipo de datos personalizado que te permite "
"empaquetar y nombrar múltiples valores relacionados que conforman un grupo "
"significativo. Si estás familiarizado con un lenguaje orientado a objetos, un "
"struct es como los atributos de datos de un objeto. En este capítulo, compararemos "
"y contrastaremos las tuplas con los structs para construir sobre lo que ya sabes y "
"demostrar cuándo los structs son una mejor manera de agrupar datos."

#: src/ch04-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how to "
"define associated functions, especially the kind of associated functions called "
"methods, to specify behavior associated with a struct type. Structs and enums "
"(discussed in the next chapter) are the building blocks for creating new types in "
"your program’s domain to take full advantage of Cairo's compile-time type checking."
msgstr ""
"Demostraremos cómo definir e instanciar structs. Discutiremos cómo definir "
"funciones asociadas, especialmente el tipo de funciones asociadas llamadas métodos, "
"para especificar el comportamiento asociado con un tipo de struct. Los structs y "
"los enums (discutidos en el Capítulo 6) son los bloques de construcción para crear "
"nuevos tipos en el dominio de tu programa para aprovechar al máximo la verificación "
"de tipos en tiempo de compilación de Cairo."

#: src/ch04-01-defining-and-instantiating-structs.md:1
msgid "# Defining and Instantiating Structs"
msgstr "# Definiendo e Instanciando una Estructura"

#: src/ch04-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in [The Data Types](ch02-02-data-types.md) "
"section, in that both hold multiple related values. Like tuples, the pieces of a "
"struct can be different types. Unlike with tuples, in a struct you’ll name each "
"piece of data so it’s clear what the values mean. Adding these names means that "
"structs are more flexible than tuples: you don’t have to rely on the order of the "
"data to specify or access the values of an instance."
msgstr ""
"Las estructuras son similares a las tuplas, discutidas en la sección [Tipos de "
"datos](ch02-02-data-types.md), en el sentido de que ambas contienen múltiples "
"valores relacionados. Al igual que las tuplas, las piezas de una estructura pueden "
"ser de diferentes tipos. A diferencia de las tuplas, en una estructura se nombra "
"cada dato para que quede claro lo que significan los valores. Agregar estos nombres "
"significa que las estructuras son más flexibles que las tuplas: no se tiene que "
"depender del orden de los datos para especificar o acceder a los valores de una "
"instancia."

#: src/ch04-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire struct. A "
"struct’s name should describe the significance of the pieces of data being grouped "
"together. Then, inside curly brackets, we define the names and types of the pieces "
"of data, which we call fields. For example, Listing 4-1 shows a struct that stores "
"information about a user account."
msgstr ""
"Para definir una estructura, introducimos la palabra clave `struct` y nombramos la "
"estructura completa. El nombre de una estructura debe describir el significado de "
"los datos que se agrupan. Después, entre llaves, definimos los nombres y tipos de "
"los datos, que llamamos campos. Por ejemplo, el Listado 4-1 muestra una estructura "
"que almacena información sobre una cuenta de usuario."

#: src/ch04-01-defining-and-instantiating-structs.md:7
#: src/ch04-01-defining-and-instantiating-structs.md:26
#: src/ch04-01-defining-and-instantiating-structs.md:50
#: src/ch04-01-defining-and-instantiating-structs.md:72
#: src/ch04-01-defining-and-instantiating-structs.md:93
msgid "<span class=\"filename\">Filename: structs.cairo</span>"
msgstr "<span class=\"filename\">Filename: structs.cairo</span>"

#: src/ch04-01-defining-and-instantiating-structs.md:9
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"```"

#: src/ch04-01-defining-and-instantiating-structs.md:19
msgid "<span class=\"caption\">Listing 4-1: A `User` struct definition</span>"
msgstr "<span class=\"caption\">Listing 4-1: A `User` struct definition</span>"

#: src/ch04-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that struct by "
"specifying concrete values for each of the fields.\n"
"We create an instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields and the "
"values are the data we want to store in those fields. We don’t have to specify the "
"fields in the same order in which we declared them in the struct. In other words, "
"the struct definition is like a general template for the type, and instances fill "
"in that template with particular data to create values of the type."
msgstr ""
"Para usar una estructura después de haberla definido, creamos una instancia de esa "
"estructura especificando valores concretos para cada uno de los campos. \n"
"Creamos una instancia indicando el nombre de la estructura y luego agregamos "
"corchetes que contienen pares de *clave: valor*, donde las claves son los nombres "
"de los campos y los valores son los datos que queremos almacenar en esos campos. No "
"tenemos que especificar los campos en el mismo orden en que los declaramos en la "
"estructura. En otras palabras, la definición de una estructura es como una "
"plantilla general para el tipo y las instancias completan esa plantilla con datos "
"particulares para crear valores del tipo."

#: src/ch04-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 4-2."
msgstr ""
"Por ejemplo, podemos declarar un usuario particular como se muestra en el Listado "
"4-2."

#: src/ch04-01-defining-and-instantiating-structs.md:28
msgid ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true,\n"
"        username: 'someusername123',\n"
"        email: 'someone@example.com',\n"
"        sign_in_count: 1_u64,\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop)]\n"
"struct User {\n"
"    active: bool,\n"
"    username: felt252,\n"
"    email: felt252,\n"
"    sign_in_count: u64,\n"
"}\n"
"fn main() {\n"
"    let user1 = User {\n"
"        active: true,\n"
"        username: 'someusername123',\n"
"        email: 'someone@example.com',\n"
"        sign_in_count: 1_u64,\n"
"    };\n"
"}\n"
"```"

#: src/ch04-01-defining-and-instantiating-structs.md:46
msgid ""
"<span class=\"caption\">Listing 4-2: Creating an instance of the `User` struct</"
"span>"
msgstr ""
"<span class=\"caption\">Listado 4-2: Creando una instancia de la estructura `User`</"
"span>"

#: src/ch04-01-defining-and-instantiating-structs.md:48
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to access "
"this user’s email address, we use `user1.email`. If the instance is mutable, we can "
"change a value by using the dot notation and assigning into a particular field. "
"Listing 4-3 shows how to change the value in the `email` field of a mutable `User` "
"instance."
msgstr ""
"Para obtener un valor específico de una estructura, usamos la notación punto. Por "
"ejemplo, para acceder a la dirección de correo electrónico de este usuario, usamos "
"`user1.email`. Si la instancia es mutable, podemos cambiar un valor usando la "
"notación punto y asignándolo a un campo en particular. El listado 4-3 muestra cómo "
"cambiar el valor en el campo `email`de una instancia mutable de `User`."

#: src/ch04-01-defining-and-instantiating-structs.md:52
msgid ""
"```rust\n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true,\n"
"        username: 'someusername123',\n"
"        email: 'someone@example.com',\n"
"        sign_in_count: 1_u64,\n"
"    };\n"
"    user1.email = 'anotheremail@example.com';\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let mut user1 = User {\n"
"        active: true,\n"
"        username: 'someusername123',\n"
"        email: 'someone@example.com',\n"
"        sign_in_count: 1_u64,\n"
"    };\n"
"    user1.email = 'anotheremail@example.com';\n"
"}\n"
"```"

#: src/ch04-01-defining-and-instantiating-structs.md:64
msgid ""
"<span class=\"caption\">Listing 4-3: Changing the value in the email field of a "
"`User` instance</span>"
msgstr ""
"<span class=\"caption\">Listado 4-3: Cambiando el valor del campo email de la "
"instancia `User`</span>"

#: src/ch04-01-defining-and-instantiating-structs.md:66
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to mark only "
"certain fields as mutable."
msgstr ""
"Tenga en cuenta que toda la instancia debe ser mutable; Cairo no nos permite marcar "
"solo ciertos campos como mutables."

#: src/ch04-01-defining-and-instantiating-structs.md:68
msgid ""
"As with any expression, we can construct a new instance of the struct as the last "
"expression in the function body to implicitly return that new instance."
msgstr ""
"Como con cualquier expresión, podemos construir una nueva instancia de la "
"estructura como la última expresión en el cuerpo de la función para devolver "
"implícitamente esa nueva instancia."

#: src/ch04-01-defining-and-instantiating-structs.md:70
msgid ""
"Listing 4-4 shows a `build_user` function that returns a `User` instance with the "
"given email and username. The `active` field gets the value of `true`, and the "
"`sign_in_count` gets a value of `1`."
msgstr ""
"Listado 4-4 muestra la función `build_user` que retorna una instancia de la "
"estructura `User` con el email y el username. Al campo `active` se le asigna el "
"valor `true`,y el campo `sign_in_count` obtiene el valor de `1`."

#: src/ch04-01-defining-and-instantiating-structs.md:74
msgid ""
"```rust\n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username: username,\n"
"        email: email,\n"
"        sign_in_count: 1,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username: username,\n"
"        email: email,\n"
"        sign_in_count: 1,\n"
"    }\n"
"}\n"
"```"

#: src/ch04-01-defining-and-instantiating-structs.md:85
msgid ""
"<span class=\"caption\">Listing 4-4: A `build_user` function that takes an email "
"and username and returns a `User` instance</span>"
msgstr ""
"<span class=\"caption\">Listado 4-4: Función `build_user` que toma los argumentos "
"email y username, y retorna una instancia de la estructura `User`</span>"

#: src/ch04-01-defining-and-instantiating-structs.md:87
msgid ""
"It makes sense to name the function parameters with the same name as the struct "
"fields, but having to repeat the `email` and `username` field names and variables "
"is a bit tedious. If the struct had more fields, repeating each name would get even "
"more annoying. Luckily, there’s a convenient shorthand!"
msgstr ""
"Tiene sentido nombrar los parámetros de la función con el mismo nombre que los "
"campos de la estructura, porque tener que repetir los nombres y variables de los "
"campos `email`y `username` es un poco tedioso. Si la estructura tuviera más campos, "
"repetir cada nombre sería aún más molesto. ¡Afortunadamente, hay una forma "
"abreviada!"

#: src/ch04-01-defining-and-instantiating-structs.md:89
msgid "## Using the Field Init Shorthand"
msgstr "## Usando la Abreviatura Field Init"

#: src/ch04-01-defining-and-instantiating-structs.md:91
msgid ""
"Because the parameter names and the struct field names are exactly the same in "
"Listing 4-4, we can use the field init shorthand syntax to rewrite `build_user` so "
"it behaves exactly the same but doesn’t have the repetition of `username` and "
"`email`, as shown in Listing 4-5."
msgstr ""
"Como los nombres de los parámetros y los nombres de los campos struct son "
"exactamente los mismos en el Listado 4-4, podemos usar la sintaxis abreviada de "
"field init para reescribir `build_user` de forma que se comporte exactamente igual "
"pero sin la repetición de `username` y `email`, como se muestra en el Listado 4-5."

#: src/ch04-01-defining-and-instantiating-structs.md:95
msgid ""
"```rust\n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username,\n"
"        email,\n"
"        sign_in_count: 1_u64,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn build_user(email: felt252, username: felt252) -> User {\n"
"    User {\n"
"        active: true,\n"
"        username,\n"
"        email,\n"
"        sign_in_count: 1_u64,\n"
"    }\n"
"}\n"
"```"

#: src/ch04-01-defining-and-instantiating-structs.md:106
msgid ""
"<span class=\"caption\">Listing 4-5: A `build_user` function that uses field init "
"shorthand because the `username` and `email` parameters have the same name as "
"struct fields</span>"
msgstr ""
"<span class=\"caption\">Lista 4-5: Una función `build_user` que utiliza la "
"abreviatura field init porque los parámetros `username` y `email` tienen el mismo "
"nombre que los campos struct</span>"

#: src/ch04-01-defining-and-instantiating-structs.md:108
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field named "
"`email`. We want to set the `email` field’s value to the value in the `email` "
"parameter of the `build_user` function. Because the `email` field and the `email` "
"parameter have the same name, we only need to write `email` rather than `email: "
"email`."
msgstr ""
"Aquí, estamos creando una nueva instancia de la estructura `User`, que tiene un "
"campo llamado `email`. Queremos establecer el valor del campo `email` con el valor "
"del parámetro `email` de la función `build_user`. Debido a que el campo `email` y "
"el parámetro `email` tienen el mismo nombre, solo necesitamos escribir `email` en "
"lugar de `email: email`."

#: src/ch04-02-an-example-program-using-structs.md:1
msgid "# An Example Program Using Structs"
msgstr "# Un Programa de Ejemplo Usando Estructuras"

#: src/ch04-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, and then "
"refactor the program until we’re using structs instead."
msgstr ""
"Para entender cuándo podríamos usar estructuras, escribamos un programa que calcule "
"el área de un rectángulo. Comenzaremos usando variables individuales y luego "
"reescribiremos el programa hasta que estemos usando estructuras en su lugar."

#: src/ch04-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the width "
"and height of a rectangle specified in pixels and calculate the area of the "
"rectangle. Listing 4-6 shows a short program with one way of doing exactly that in "
"our project’s _src/lib.cairo_."
msgstr ""
"Hagamos un nuevo proyecto con Scarb llamado _rectangles_ que tomará el ancho y la "
"altura de un rectángulo en píxeles y calculará el área del rectángulo. El Listado "
"4-6 muestra un pequeño programa con una forma de hacer exactamente eso en el _src/"
"lib.cairo_ de nuestro proyecto."

#: src/ch04-02-an-example-program-using-structs.md:9
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let width1 = 30_u64;\n"
"    let height1 = 10_u64;\n"
"    let area = area(width1, height1);\n"
"    area.print();\n"
"}\n"
"\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"    width * height\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let width1 = 30_u64;\n"
"    let height1 = 10_u64;\n"
"    let area = area(width1, height1);\n"
"    area.print();\n"
"}\n"
"\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"    width * height\n"
"}\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:23
msgid ""
"<span class=\"caption\">Listing 4-6: Calculating the area of a rectangle specified "
"by separate width and height variables</span>"
msgstr ""
"<span class=\"caption\">Listado 4-6: Cálculo del área de un rectángulo especificado "
"por variables separadas de ancho y alto</span>"

#: src/ch04-02-an-example-program-using-structs.md:25
msgid "Now run the program with `cairo-run src/lib.cairo`:"
msgstr "Para compilar el programa usamos `cairo-run src/lib.cairo`:"

#: src/ch04-02-an-example-program-using-structs.md:27
msgid ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] ,                               (raw: 300)\n"
"\n"
"Run completed successfully, returning []\n"
"```"
msgstr ""
"```bash\n"
"$ cairo-run src/lib.cairo\n"
"[DEBUG] ,                               (raw: 300)\n"
"\n"
"Run completed successfully, returning []\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the `area` "
"function with each dimension, but we can do more to make this code clear and "
"readable."
msgstr ""
"Este código logra calcular el área del rectángulo llamando a la función `area` con "
"cada dimensión, pero podemos hacer más para que este código sea claro y legible."

#: src/ch04-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""
"El problema con este código es evidente en la declaración de la función `area`:"

#: src/ch04-02-an-example-program-using-structs.md:38
msgid ""
"```rust\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"```"
msgstr ""
"```rust\n"
"fn area(width: u64, height: u64) -> u64 {\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but the "
"function we wrote has two parameters, and it’s not clear anywhere in our program "
"that the parameters are related. It would be more readable and more manageable to "
"group width and height together. We’ve already discussed one way we might do that "
"in [Chapter 3](ch02-02-data-types.html#the-tuple-type): using tuples."
msgstr ""
"Se supone que la función `area` calcula el área de un rectángulo, pero la función "
"que escribimos tiene dos parámetros, y no está claro en ninguna parte de nuestro "
"programa que los parámetros estén relacionados. Sería más legible y manejable "
"agrupar el ancho y el alto juntos. Ya discutimos una forma en que podríamos hacer "
"eso en el [Capítulo 3](ch02-02-data-types.html#the-tuple-type): usando tuplas."

#: src/ch04-02-an-example-program-using-structs.md:44
msgid "## Refactoring with Tuples"
msgstr "## Reescribiendo con Tuplas"

#: src/ch04-02-an-example-program-using-structs.md:46
msgid "Listing 4-7 shows another version of our program that uses tuples."
msgstr "El listado 4-7 muestra otra versión de nuestro programa usando tuplas."

#: src/ch04-02-an-example-program-using-structs.md:50
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30_u64, 10_u64);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x,y) = dimension;\n"
"    x * y\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    let rectangle = (30_u64, 10_u64);\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(dimension: (u64, u64)) -> u64 {\n"
"    let (x,y) = dimension;\n"
"    x * y\n"
"}\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:64
msgid ""
"<span class=\"caption\">Listing 4-7: Specifying the width and height of the "
"rectangle with a tuple</span>"
msgstr ""
"<span class=\"caption\">Listing 4-7: Especificando el ancho y alto de un rectángulo "
"con una tupla</span>"

#: src/ch04-02-an-example-program-using-structs.md:66
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, and we’re "
"now passing just one argument. But in another way, this version is less clear: "
"tuples don’t name their elements, so we have to index into the parts of the tuple, "
"making our calculation less obvious."
msgstr ""
"En cierto modo, este programa es mejor. Las tuplas nos permiten agregar un poco de "
"estructura y ahora estamos pasando solo un argumento. Pero en otro sentido, esta "
"versión es menos clara: las tuplas no nombran sus elementos, por lo que tenemos que "
"indexar las partes de la tupla, lo que hace que nuestro cálculo sea menos obvio."

#: src/ch04-02-an-example-program-using-structs.md:68
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but if we "
"want to calculate the difference, it would matter! We would have to keep in mind "
"that `width` is the tuple index `0` and `height` is the tuple index `1`. This would "
"be even harder for someone else to figure out and keep in mind if they were to use "
"our code. Because we haven’t conveyed the meaning of our data in our code, it’s now "
"easier to introduce errors."
msgstr ""
"Mezclar el ancho y la altura no importaría para el cálculo del área, pero si "
"queremos calcular la diferencia, ¡sería importante! Tendríamos que tener en cuenta "
"que `width` es el índice de tupla `0` y `height` es el índice de tupla `1`. Esto "
"sería aún más difícil de entender y tener en cuenta para otra persona si usara "
"nuestro código. Debido a que no hemos transmitido el significado de nuestros datos "
"en nuestro código, ahora es más fácil introducir errores."

#: src/ch04-02-an-example-program-using-structs.md:70
msgid "## Refactoring with Structs: Adding More Meaning"
msgstr "## Reescribiendo con `struct`: Agrega Más Significado"

#: src/ch04-02-an-example-program-using-structs.md:72
msgid ""
"We use structs to add meaning by labeling the data. We can transform the tuple "
"we’re using into a struct with a name for the whole as well as names for the parts."
msgstr ""
"Usamos estructuras para agregar significado al etiquetar los datos. Podemos "
"transformar la tupla que estamos usando en una estructura con un nombre para el "
"todo y nombres para las partes."

#: src/ch04-02-an-example-program-using-structs.md:76
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    let area = area(rectangle);\n"
"    area.print(); // print out the area\n"
"}\n"
"\n"
"fn area(rectangle: Rectangle) -> u64 {\n"
"    rectangle.width * rectangle.height\n"
"}\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:98
msgid "<span class=\"caption\">Listing 4-8: Defining a `Rectangle` struct</span>"
msgstr ""
"<span class=\"caption\">Listado 4-8: Definición de una estructura llamada "
"`Rectangle`</span>"

#: src/ch04-02-an-example-program-using-structs.md:100
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly brackets, we "
"defined the fields as `width` and `height`, both of which have type `u64`. Then, in "
"`main`, we created a particular instance of `Rectangle` that has a width of `30` "
"and a height of `10`. Our `area` function is now defined with one parameter, which "
"we’ve named `rectangle` which is of type `Rectangle` struct. We can then access the "
"fields of the instance with dot notation, and it gives descriptive names to the "
"values rather than using the tuple index values of `0` and `1`."
msgstr ""
"Aquí hemos definido una estructura y la hemos llamado `Rectangle`. Dentro de las "
"llaves, definimos los campos como `width` y `height`, los cuales tienen el tipo "
"`u64`. Luego, en `main`, creamos una instancia particular de `Rectangle` que tiene "
"un ancho de `30` y una altura de `10`. Nuestra función `area` ahora está definida "
"con un parámetro, al que hemos llamado `rectangle` que es de tipo de la estructura "
"`Rectangle`. Luego podemos acceder a los campos de la instancia con notación de "
"punto, y dar nombres descriptivos a los valores en lugar de usar los valores de "
"índice de tupla de `0` y `1`."

#: src/ch04-02-an-example-program-using-structs.md:102
msgid "## Adding Useful Functionality with Trait"
msgstr "## Agregando Funcionalidades Útiles con Trait"

#: src/ch04-02-an-example-program-using-structs.md:104
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re debugging "
"our program and see the values for all its fields. Listing 4-9 tries using the "
"`print` as we have used in previous chapters. This won’t work."
msgstr ""
"Sería útil poder imprimir una instancia de `Rectangle` mientras estamos depurando "
"nuestro programa y ver los valores de todos sus campos. El Listado 4-9 intenta usar "
"`print` como lo hemos usado en capítulos anteriores. Esto no funcionará."

#: src/ch04-02-an-example-program-using-structs.md:108
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    rectangle.print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    rectangle.print();\n"
"}\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:125
msgid ""
"<span class=\"caption\">Listing 4-9: Attempting to print a `Rectangle` instance</"
"span>"
msgstr ""
"<span class=\"caption\">Listado 4-9: Intentando imprimir una instancia de "
"`Rectangle`</span>"

#: src/ch04-02-an-example-program-using-structs.md:127
msgid "When we compile this code, we get an error with this message:"
msgstr "Cuando compilamos este código, obtenemos un error con el siguiente mensaje:"

#: src/ch04-02-an-example-program-using-structs.md:129
msgid ""
"```bash\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you import the "
"correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""
"```bash\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you import the "
"correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:139
msgid ""
"The `print` trait is implemented for many data types, but not for the `Rectangle` "
"struct. We can fix this by implementing the `PrintTrait` trait on `Rectangle` as "
"shown in Listing 4-10.\n"
"To learn more about traits, see [Traits in Cairo](ch07-02-traits-in-cairo.md)."
msgstr ""
"El trait `print` está implementado para muchos tipos de datos, pero no para la "
"estructura `Rectangle`. Podemos arreglar esto implementando el trait `PrintTrait` "
"en la estructura `Rectangle` como se muestra en el Listado 4-10.\n"
"Para aprender más sobre traits,[Traits en Cairo](ch07-02-traits-in-cairo.md)."

#: src/ch04-02-an-example-program-using-structs.md:144
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    rectangle.print();\n"
"}\n"
"\n"
"impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
"    fn print(self: Rectangle) {\n"
"        self.width.print();\n"
"        self.height.print();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rectangle = Rectangle {\n"
"        width: 30_u64,\n"
"        height: 10_u64,\n"
"    };\n"
"    rectangle.print();\n"
"}\n"
"\n"
"impl RectanglePrintImpl of PrintTrait<Rectangle> {\n"
"    fn print(self: Rectangle) {\n"
"        self.width.print();\n"
"        self.height.print();\n"
"    }\n"
"}\n"
"```"

#: src/ch04-02-an-example-program-using-structs.md:168
msgid ""
"<span class=\"caption\">Listing 4-10: Implementing the `PrintTrait` trait on "
"`Rectangle`</span>"
msgstr ""
"<span class=\"caption\">Listado 4-10:  Implementación del trait `PrintTrait` en "
"`Rectangle`</span>"

#: src/ch04-02-an-example-program-using-structs.md:170
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the fields for "
"this instance, which would definitely help during debugging."
msgstr ""
"¡Bien! No es el resultado más bonito, pero muestra los valores de todos los campos "
"para esta instancia, lo que definitivamente ayudaría durante la depuración."

#: src/ch04-03-method-syntax.md:1
msgid "## Method Syntax"
msgstr "## Sintaxis De Métodos"

#: src/ch04-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword and a\n"
"name, they can have parameters and a return value, and they contain some code\n"
"that’s run when the method is called from somewhere else. Unlike functions,\n"
"methods are defined within the context of a type and their first parameter is\n"
"always `self`, which represents the instance of the type the method is being\n"
"called on. For those familiar with Rust, Cairo's approach might be confusing,\n"
"as methods cannot be defined directly on types. Instead, you must define a trait\n"
"and an implementation associated with the type for which the method is intended."
msgstr ""
"Los métodos son similares a las funciones: los declaramos con la palabra clave "
"`fn` \n"
"y un nombre, pueden tener parámetros, retornar un valor, y contener código que se \n"
"ejecuta cuando el método es llamado desde otro lugar. A diferencia de las "
"funciones, \n"
"los métodos se definen dentro del contexto de un tipo y su primer parámetro siempre "
"es \n"
"`self`, que representa la instancia del tipo al que se llama el método. Para "
"aquellos familiarizados \n"
"con Rust, el enfoque de Cairo puede resultar confuso, ya que los métodos no se "
"pueden definir \n"
"directamente en los tipos. En su lugar, debe definir un `trait` y una "
"implementación asociados con el\n"
" tipo para el que está destinado el método."

#: src/ch04-03-method-syntax.md:12
msgid "### Defining Methods"
msgstr "### Definición de Détodos"

#: src/ch04-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a parameter\n"
"and instead make an `area` method defined on the `RectangleTrait` trait, as shown\n"
"in Listing 5-13."
msgstr ""
"Cambiemos la función `area` que tiene una instancia `Rectangle` como parámetro\n"
"y en su lugar hagamos un método `area` definido en el trait `RectangleTrait`, como "
"se muestra\n"
" en el Listado 5-13."

#: src/ch04-03-method-syntax.md:20
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"\n"
"    rect1.area().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"\n"
"    rect1.area().print();\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:45
msgid ""
"<span class=\"caption\">Listing 4-13: Defining an `area` method to use on the\n"
"`Rectangle` </span>"
msgstr ""
"<span class=\"caption\">Listado 4-13: Definiendo el método `area` para usar en la \n"
"estructura `Rectangle` </span>"

#: src/ch04-03-method-syntax.md:48
msgid ""
"To define the function within the context of `Rectangle`, we start by definining a "
"`trait`\n"
"block with the signature of the method that we want to implement. Traits are not "
"linked to\n"
"a specific type; only the `self` parameter of the method defines which type it can "
"be used\n"
"with. Then, we define an `impl` (implementation) block for `RectangleTrait`, that "
"defines\n"
"the behavior of the methods implemented. Everything within this `impl` block will "
"be\n"
"associated with the type of the `self` parameter of the method called. While it is "
"technically\n"
"possible to define methods for multiple types within the same `impl` block, it is "
"not\n"
"a recommended practice, as it can lead to confusion. We recommend that the type of "
"the `self` parameter\n"
"stays consistent within the same `impl` block.\n"
"Then we move the `area` function within the `impl` curly brackets and change the "
"first (and in this case, only)\n"
"parameter to be `self` in the signature and everywhere within the body. In\n"
"`main`, where we called the `area` function and passed `rect1` as an argument,\n"
"we can instead use the _method syntax_ to call the `area` method on our "
"`Rectangle`\n"
"instance. The method syntax goes after an instance: we add a dot followed by\n"
"the method name, parentheses, and any arguments."
msgstr ""
"Para definir la función dentro del contexto de `Rectangle`, comenzamos definiendo "
"un `trait` \n"
"con la declaración del método que queremos implementar. Los *Traits* no están "
"vinculados a un\n"
" tipo específico; solo el parámetro `self` del método define qué tipo se puede usar "
"con dicho *trait*. \n"
"Luego, definimos un bloque con la palabra clave `impl` para `RectangleTrait`, que "
"define el \n"
"comportamiento de los métodos implementados. Todo dentro de este bloque `impl` será "
"asociado con \n"
"el tipo del parámetro `self` del método llamado. Si bien es técnicamente posible "
"definir métodos para \n"
"múltiples tipos dentro del mismo bloque `impl`, no es una práctica recomendada, ya "
"que puede producir\n"
" una confusión. Recomendamos que el tipo del parámetro `self` permanece consistente "
"dentro del mismo\n"
" bloque `impl`. \n"
"Luego movemos la función `area` dentro de los corchetes `impl` y cambiamos el "
"primer (y en\n"
" este caso, único) parámetro para ser `self` en la declaración y en todas partes "
"dentro del cuerpo. En `main`,\n"
" donde llamamos a la función `area` y pasamos `rect1` como argumento, en su lugar, "
"podemos usar la _sintaxis \n"
"del método_ para llamar al método `area` en nuestra instancia del `Rectangle`. La "
"sintaxis del método va \n"
"después de una instancia: agregamos un punto seguido del nombre del método, los "
"paréntesis y los argumentos."

#: src/ch04-03-method-syntax.md:64
msgid ""
"Methods must have a parameter named `self` of the type they will be applied to for "
"their first parameter.\n"
"Note that we used the `@` snapshot operator in front of the `Rectangle` type in the "
"function signature.\n"
"By doing so, we indicate that this method takes an immutable snapshot of the "
"`Rectangle` instance, which is\n"
"automatically created by the compiler when passing the instance to the method.\n"
"Methods can take ownership of `self`, use `self` with snapshots as we’ve done here, "
"or use a mutable reference to `self`\n"
"using the `ref self: T` syntax."
msgstr ""
"Los métodos deben tener un parámetro llamado `self` del tipo al que se aplicarán "
"como primer parámetro.\n"
"Observa que hemos utilizado el operador de instantánea `@` delante del tipo "
"`Rectangle` en la firma de la función.\n"
"Al hacerlo, indicamos que este método toma una instantánea inmutable de la "
"instancia `Rectangle`, que es\n"
"automáticamente por el compilador al pasar la instancia al método.\n"
"Los métodos pueden tomar posesión de `self`, usar `self` con instantáneas como "
"hemos hecho aquí, o usar una referencia mutable a `self\n"
"usando la sintaxis `ref self: T`."

#: src/ch04-03-method-syntax.md:71
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in the "
"function\n"
"version: we don’t want to take ownership, and we just want to read the data in\n"
"the struct, not write to it. If we wanted to change the instance that we’ve\n"
"called the method on as part of what the method does, we’d use `ref self: "
"Rectangle` as\n"
"the first parameter. Having a method that takes ownership of the instance by\n"
"using just `self` as the first parameter is rare; this technique is usually\n"
"used when the method transforms `self` into something else and you want to\n"
"prevent the caller from using the original instance after the transformation."
msgstr ""
"Elegimos `self: @Rectangle` por la misma razón que usamos `@Rectangle` en la "
"función versión:\n"
" no queremos tomar posesión, y solo queremos leer los datos en la estructura, no "
"escribir en ella.\n"
" Si quisiéramos cambiar la instancia que hemos llamado al método como parte de lo "
"que hace el método,\n"
" usaríamos `ref self: Rectangle` como el primer parámetro. Tener un método que tome "
"posesión de la \n"
"instancia por usar solo `self` como primer parámetro es raro; esta técnica suele "
"ser usada cuando el\n"
" método transforma `self` en otra cosa y desea evitar que la persona que llama use "
"la instancia original\n"
" después de la transformación."

#: src/ch04-03-method-syntax.md:80
msgid ""
"Observe the use of the desnap operator `*` within the area method when accessing "
"the struct's members.\n"
"This is necessary because the struct is passed as a snapshot, and all of its field "
"values are of type `@T`,\n"
"requiring them to be desnapped in order to manipulate them."
msgstr ""
"Observe el uso del operador *desnap* `*` dentro del método *area* cuando accede a "
"los miembros de la \n"
"estructura. Esto es necesario porque la estructura se pasa como una *snapshot* y "
"todos sus valores de campo \n"
"son del tipo `@T`, requiriendo que sean *desnapped* para poder manipularlos."

#: src/ch04-03-method-syntax.md:84
msgid ""
"The main reason for using methods instead of functions is for organization and code "
"clarity. We’ve put all the things we can do with an instance of a type in one "
"combination of `trait` & `impl` blocks, rather than making future users\n"
"of our code search for capabilities of `Rectangle` in various places in the\n"
"library we provide. However, we can define multiple combinations of `trait` & "
"`impl` blocks for the same type at different places, which can be useful for a more "
"granular code organization. For example, you could implement\n"
"the `Add` trait for your type in one `impl` block, and the `Sub` trait in another "
"block."
msgstr ""
"La principal razón para utilizar métodos en lugar de funciones es la organización y "
"la claridad del código. Hemos puesto todas las cosas que podemos hacer con una "
"instancia de un tipo en una combinación de bloques `trait` & `impl`, en lugar de "
"hacer que los futuros usuarios de nuestro código busquen las capacidades de "
"`Rectangle` en varios lugares del código.\n"
"de nuestro código busquen las capacidades de `Rectangle` en varios lugares de la\n"
"biblioteca que proporcionamos. Sin embargo, podemos definir múltiples combinaciones "
"de bloques `trait` & `impl` para el mismo tipo en diferentes lugares, lo que puede "
"ser útil para una organización más granular del código. Por ejemplo, puedes "
"implementar\n"
"el rasgo `Add` para tu tipo en un bloque `impl`, y el rasgo `Sub` en otro bloque."

#: src/ch04-03-method-syntax.md:89
msgid ""
"Note that we can choose to give a method the same name as one of the struct’s\n"
"fields. For example, we can define a method on `Rectangle` that is also named\n"
"`width`:"
msgstr ""
"Tenga en cuenta que podemos optar por dar a un método el mismo nombre que uno de "
"los campos de la estructura\n"
"de la estructura. Por ejemplo, podemos definir un método en `Rectangle` que también "
"se llame\n"
"ancho`:"

#: src/ch04-03-method-syntax.md:95
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool {\n"
"        (*self.width) > 0_u64\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"    rect1.width().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"trait RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn width(self: @Rectangle) -> bool {\n"
"        (*self.width) > 0_u64\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"    rect1.width().print();\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:119
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value in\n"
"the instance’s `width` field is greater than `0` and `false` if the value is\n"
"`0`: we can use a field within a method of the same name for any purpose. In\n"
"`main`, when we follow `rect1.width` with parentheses, Cairo knows we mean the\n"
"method `width`. When we don’t use parentheses, Cairo knows we mean the field\n"
"`width`."
msgstr ""
"Aquí, elegimos hacer que el método `width` devuelva `true` si el valor en el campo "
"`width` \n"
"de la instancia es mayor que `0` y `false` si el valor es `0`: podemos usar un "
"campo dentro \n"
"de un método del mismo nombre para cualquier propósito. En `main`, cuando "
"colocamos \n"
"`rect1.width` entre paréntesis, Cairo sabe que nos referimos al método `width`. "
"Cuando no \n"
"usamos paréntesis, Cairo sabe que nos referimos al campo `widht`."

#: src/ch04-03-method-syntax.md:126
msgid "### Methods with More Parameters"
msgstr "### Métodos con Más Parámetros"

#: src/ch04-03-method-syntax.md:128
msgid ""
"Let’s practice using methods by implementing a second method on the `Rectangle`\n"
"struct. This time we want an instance of `Rectangle` to take another instance\n"
"of `Rectangle` and return `true` if the second `Rectangle` can fit completely\n"
"within `self` (the first `Rectangle`); otherwise, it should return `false`.\n"
"That is, once we’ve defined the `can_hold` method, we want to be able to write\n"
"the program shown in Listing 5-14."
msgstr ""
"Practiquemos el uso de métodos implementando un segundo método en la estructura "
"`Rectangle`. \n"
"Esta vez queremos que una instancia de `Rectangle` tome otra instancia de "
"`Rectangle` y devolver \n"
"`true` si el segundo `Rectangle` puede caber completamente dentro de `self` (el "
"primer `Rectangle`); \n"
"de lo contrario, debería devolver `false`. Es decir, una vez que hemos definido el "
"método `can_hold`, queremos poder escribir el programa que se muestra en el Listado "
"5-14."

#: src/ch04-03-method-syntax.md:137
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"    let rect2 = Rectangle { width: 10_u64, height: 40_u64,  };\n"
"    let rect3 = Rectangle { width: 60_u64, height: 45_u64,  };\n"
"\n"
"    'Can rect1 hold rect2?'.print();\n"
"    rect1.can_hold(@rect2).print();\n"
"\n"
"    'Can rect1 hold rect3?'.print();\n"
"    rect1.can_hold(@rect3).print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"#[derive(Copy, Drop)]\n"
"struct Rectangle {\n"
"    width: u64,\n"
"    height: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };\n"
"    let rect2 = Rectangle { width: 10_u64, height: 40_u64,  };\n"
"    let rect3 = Rectangle { width: 60_u64, height: 45_u64,  };\n"
"\n"
"    'Can rect1 hold rect2?'.print();\n"
"    rect1.can_hold(@rect2).print();\n"
"\n"
"    'Can rect1 hold rect3?'.print();\n"
"    rect1.can_hold(@rect3).print();\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:158
msgid ""
"<span class=\"caption\">Listing 5-14: Using the as-yet-unwritten `can_hold`\n"
"method</span>"
msgstr ""
"<span class=\"caption\">Listing 5-14:  Usando el método todavia no escrito "
"`can_hold`</span>"

#: src/ch04-03-method-syntax.md:161
msgid ""
"The expected output would look like the following because both dimensions of\n"
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider than\n"
"`rect1`:"
msgstr ""
"La salida esperada sería similar a la siguiente porque ambas dimensiones de `rect2` "
"son más\n"
" pequeñas que las dimensiones de `rect1`, pero `rect3` es más ancha que` rect1`:"

#: src/ch04-03-method-syntax.md:165
msgid ""
"```text\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\tCan rec1 hold rect2?           \t(raw: "
"384675147322001379018464490539350216396261044799)\n"
"\n"
"[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
"\n"
"[DEBUG]\tCan rect1 hold rect3?          \t(raw: "
"384675147322001384331925548502381811111693612095)\n"
"\n"
"[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
"\n"
"```"
msgstr ""
"```text\n"
"❯ cairo-run src/lib.cairo\n"
"[DEBUG]\tCan rec1 hold rect2?           \t(raw: "
"384675147322001379018464490539350216396261044799)\n"
"\n"
"[DEBUG]\ttrue                           \t(raw: 1953658213)\n"
"\n"
"[DEBUG]\tCan rect1 hold rect3?          \t(raw: "
"384675147322001384331925548502381811111693612095)\n"
"\n"
"[DEBUG]\tfalse                          \t(raw: 439721161573)\n"
"\n"
"```"

#: src/ch04-03-method-syntax.md:177
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait`\n"
"and `impl RectangleImpl of RectangleTrait` blocks.\n"
"The method name will be `can_hold`, and it will take a snapshot\n"
"of another `Rectangle` as a parameter. We can tell what the type of the\n"
"parameter will be by looking at the code that calls the method:\n"
"`rect1.can_hold(@rect2)` passes in `@rect2`, which is a snapshot to\n"
"`rect2`, an instance of `Rectangle`. This makes sense because we only need to\n"
"read `rect2` (rather than write, which would mean we’d need a mutable borrow),\n"
"and we want `main` to retain ownership of `rect2` so we can use it again after\n"
"calling the `can_hold` method. The return value of `can_hold` will be a\n"
"Boolean, and the implementation will check whether the width and height of\n"
"`self` are greater than the width and height of the other `Rectangle`,\n"
"respectively. Let’s add the new `can_hold` method to the `trait` and `impl` blocks "
"from\n"
"Listing 5-13, shown in Listing 5-15."
msgstr ""
"Sabemos que queremos definir un método, así que estará dentro de los bloques `trait "
"RectangleTrait` y `impl RectangleImpl of RectangleTrait`.\n"
"y `impl RectangleImpl of RectangleTrait`.\n"
"El nombre del método será `can_hold`, y tomará una instantánea\n"
"de otro `Rectangle` como parámetro. Podemos saber cuál será el tipo del parámetro\n"
"parámetro mirando el código que llama al método:\n"
"rect1.can_hold(@rect2)` pasa `@rect2`, que es una instantánea de\n"
"`rect2`, una instancia de `Rectangle`. Esto tiene sentido porque sólo necesitamos\n"
"leer `rect2` (en lugar de escribir, lo que significaría que necesitaríamos un "
"préstamo mutable),\n"
"y queremos que `main` conserve la propiedad de `rect2` para poder volver a usarla "
"después de\n"
"después de llamar al método `can_hold`. El valor de retorno de `can_hold` será un "
"booleano\n"
"y la implementación comprobará si la anchura y la altura de\n"
"`self` son mayores que la anchura y la altura del otro `Rectangle`,\n"
"respectivamente. Añadamos el nuevo método `can_hold` a los bloques `trait` e `impl` "
"de\n"
"Listado 5-13, mostrados en el Listado 5-15."

#: src/ch04-03-method-syntax.md:194
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:211
msgid ""
"<span class=\"caption\">Listing 5-15: Implementing the `can_hold` method on\n"
"`Rectangle` that takes another `Rectangle` instance as a parameter</span>"
msgstr ""
"<span class=\"caption\">Listing 4-15: Implementación del método `can_hold` en "
"`Rectangle` que recibe una instancia de `Rectangle` como parámetro</span>"

#: src/ch04-03-method-syntax.md:214
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get our\n"
"desired output. Methods can take multiple parameters that we add to the\n"
"signature after the `self` parameter, and those parameters work just like\n"
"parameters in functions."
msgstr ""
"Cuando ejecutemos este código con la función `main` del Listado 5-14, obtendremos "
"la salida deseada.\n"
"salida deseada. Los métodos pueden tomar múltiples parámetros que añadimos a la "
"firma\n"
"después del parámetro `self`, y esos parámetros funcionan igual que los parámetros "
"de las funciones.\n"
"en las funciones."

#: src/ch04-03-method-syntax.md:219
msgid "### Accessing implementation functions"
msgstr "### Acceso a las funciones de implementación"

#: src/ch04-03-method-syntax.md:221
msgid ""
"All functions defined within a `trait` and `impl` block can be directly addressed\n"
"using the `::` operator on the implementation name.\n"
"Functions in traits that aren’t methods are often used for constructors that\n"
"will return a new instance of the struct. These are often called `new`, but\n"
"`new` isn’t a special name and isn’t built into the language. For example, we\n"
"could choose to provide an associated function named `square` that would have\n"
"one dimension parameter and use that as both width and height, thus making it\n"
"easier to create a square `Rectangle` rather than having to specify the same\n"
"value twice:"
msgstr ""
"Todas las funciones definidas dentro de un bloque `trait` e `impl` se pueden "
"direccionar directamente\n"
"utilizando el operador `::` en el nombre de la implementación.\n"
"Las funciones en traits que no son métodos se utilizan a menudo para constructores "
"que\n"
"devolverán una nueva instancia de la estructura. A menudo se llaman `new`, pero\n"
"`new` no es un nombre especial y no está incorporado en el lenguaje. Por ejemplo\n"
"una función asociada llamada `square` que tendría un parámetro de\n"
"un parámetro de dimensión y utilizarlo como anchura y altura, facilitando así la "
"creación de un cuadrado.\n"
"un `Rectángulo` cuadrado en lugar de tener que especificar el mismo valor dos "
"veces\n"
"valor dos veces:"

#: src/ch04-03-method-syntax.md:233
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle {\n"
"        Rectangle { width: size, height: size }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn square(size: u64) -> Rectangle {\n"
"        Rectangle { width: size, height: size }\n"
"    }\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:245
msgid ""
"To call this function, we use the `::` syntax with the implementation name;\n"
"`let square = RectangleImpl::square(10_u64);` is an example. This function is "
"namespaced by\n"
"the implementation; the `::` syntax is used for both trait functions and\n"
"namespaces created by modules. We’ll discuss modules in [Chapter 7][modules]<!-- "
"ignore -->."
msgstr ""
"Para llamar a esta función, usamos la sintaxis `::` con el nombre de "
"implementación; por ejemplo, \n"
"`let square = RectangleImpl::square(10_u64);`. Esta función está espaciada por la "
"implementación: l\n"
"a sintaxis `::` se usa tanto para funciones del *trait* y espacios de nombres "
"creados por módulos. \n"
"Lo discutiremos en el [Capítulo 7][modules]<!-- ignore -->."

#: src/ch04-03-method-syntax.md:250
msgid ""
"> Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10_u64)`."
msgstr ""
"> Nota: También es posible llamar a esta función usando el nombre del *trait*, con "
"`RectangleTrait::square(10_u64)`."

#: src/ch04-03-method-syntax.md:252
msgid "### Multiple `impl` Blocks"
msgstr "### Multiples Bloques con `impl`"

#: src/ch04-03-method-syntax.md:254
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For example, "
"Listing\n"
"5-15 is equivalent to the code shown in Listing 5-16, which has each method in\n"
"its own `trait` and `impl` blocks."
msgstr ""
"Cada estructura tiene permitido tener múltiples bloques con `trait` e `impl`. Por "
"ejemplo,\n"
" en el Listado 5-15 es equivalente al código mostrado en el Listado 5-16, que tiene "
"cada método \n"
"en su propio bloque de `trait` e `impl`."

#: src/ch04-03-method-syntax.md:258
msgid ""
"```rust\n"
"trait RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"impl RectangleCalcImpl of RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"trait RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleCmpImpl of RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"}\n"
"impl RectangleCalcImpl of RectangleCalc {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        (*self.width) * (*self.height)\n"
"    }\n"
"}\n"
"\n"
"trait RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleCmpImpl of RectangleCmp {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch04-03-method-syntax.md:279
msgid ""
"<span class=\"caption\">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`\n"
"blocks</span>"
msgstr ""
"<span class=\"caption\">Listado 5-16: Reescribiendo el Listado 5-15 usando "
"múltiples bloques de `impl`</span>"

#: src/ch04-03-method-syntax.md:282
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` blocks "
"here,\n"
"but this is valid syntax. We’ll see a case in which multiple blocks are\n"
"useful in [Chapter 7](ch07-00-generic-types-and-traits.md), where we discuss "
"generic types and traits."
msgstr ""
"No hay razón para separar estos métodos en múltiples bloques `trait` e `impl` "
"aquí,\n"
"pero es una sintaxis válida. Veremos un caso en el que los bloques múltiples son\n"
"útiles en el [Capítulo 7](ch07-00-generic-types-and-traits.md), donde hablamos de "
"tipos genéricos y traits."

#: src/ch04-03-method-syntax.md:288
msgid ""
"Structs let you create custom types that are meaningful for your domain. By\n"
"using structs, you can keep associated pieces of data connected to each other\n"
"and name each piece to make your code clear. In `trait` and `impl` blocks, you can "
"define\n"
"methods, which are functions associated to a type and let you specify the behavior "
"that instances of your\n"
"type have."
msgstr ""
"Las estructuras permiten crear tipos personalizados que son significativos para su "
"dominio. \n"
"Usando estructuras, puede mantener partes de datos asociadas conectadas entre sí y "
"nombra \n"
"cada pieza para que tu código quede claro. En los bloques `trait` e `impl`, puedes "
"definir métodos, \n"
"que son funciones asociadas a un tipo y le permiten especificar el comportamiento "
"que las instancias \n"
"de su tipo pueden tener."

#: src/ch04-03-method-syntax.md:294
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to\n"
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""
"Pero las estructuras (`struct`) no son la única manera de crear tipos "
"personalizados: \n"
"pasemos a la función de enumeración (`enum`) de Cairo para agregar otra herramienta."

#: src/ch05-00-enums-and-pattern-matching.md:1
msgid "# Enums and Pattern Matching"
msgstr "# Enums y Coincidencia de Patrones"

#: src/ch05-01-enums.md:1
msgid "# Enums"
msgstr "# Enums"

#: src/ch05-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type that "
"consists of a fixed set of named values, called _variants_. Enums are useful for "
"representing a collection of related values where each value is distinct and has a "
"specific meaning."
msgstr ""
"Los Enums, abreviatura de \"enumeraciones\", son una forma de definir un tipo de "
"datos personalizado que consiste en un conjunto fijo de valores nombrados, llamados "
"_variantes_. Los enums son útiles para representar una colección de valores "
"relacionados donde cada valor es distinto y tiene un significado específico."

#: src/ch05-01-enums.md:5
msgid "## Enum Variants and Values"
msgstr "## Variantes y Valores de Enum"

#: src/ch05-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "Aquí hay un ejemplo sencillo de un enum:"

#: src/ch05-01-enums.md:9
msgid ""
"```rs\n"
"#[derive(Drop)]\n"
"enum Direction {\n"
"    North: (),\n"
"    East: (),\n"
"    South: (),\n"
"    West: (),\n"
"}\n"
"\n"
"```"
msgstr ""
"```rs\n"
"#[derive(Drop)]\n"
"enum Direction {\n"
"    North: (),\n"
"    East: (),\n"
"    South: (),\n"
"    West: (),\n"
"}\n"
"\n"
"```"

#: src/ch05-01-enums.md:20
msgid ""
"Unlike other languages like Rust, every variant has a type. In this example, we've "
"defined an enum called `Direction` with four variants: `North`, `East`, `South`, "
"and `West`. The naming convention is to use PascalCase for enum variants. Each "
"variant represents a distinct value of the Direction type and is associated with a "
"unit type `()`. One variant can be instantiated using this syntax:"
msgstr ""
"A diferencia de otros lenguajes como Rust, cada variante tiene un tipo. En este "
"ejemplo, hemos definido un enum llamado `Direction` con cuatro variantes: `North`, "
"`East`, `South` y `West`. La convención de nomenclatura es utilizar PascalCase para "
"las variantes del enum. Cada variante representa un valor distinto del tipo "
"`Direction` y está asociada con un tipo unitario `()`. Una variante puede ser "
"instanciada utilizando esta sintaxis:"

#: src/ch05-01-enums.md:22
msgid ""
"```rs\n"
"let direction = Direction::North(());\n"
"```"
msgstr ""
"```rs\n"
"let direction = Direction::North(());\n"
"```"

#: src/ch05-01-enums.md:26
msgid ""
"It's easy to write code that acts differently depending on the variant of an enum "
"instance, in this example to run specific code according to a Direction. You can "
"learn more about it on the [The Match Control Flow Construct page](ch05-02-the-"
"match-control-flow-construct.md)."
msgstr ""
"Es fácil escribir código que se comporte de manera diferente según la variante de "
"una instancia de un enum, como en este ejemplo, donde se ejecuta un código "
"específico según una dirección. Puedes obtener más información sobre esto en la "
"página [The Match Control Flow Construct](ch05-02-the-match-control-flow-construct."
"md)."

#: src/ch05-01-enums.md:28
msgid "## Enums Combined with Custom Types"
msgstr "## Enums combinados con Tipos Personalizados"

#: src/ch05-01-enums.md:30
msgid ""
"Enums can also be used to store more interesting data associated with each variant. "
"For example:"
msgstr ""
"Los enums también pueden ser utilizados para almacenar datos más interesantes "
"asociados con cada variante. Por ejemplo:"

#: src/ch05-01-enums.md:32
msgid ""
"```rs\n"
"#[derive(Drop)]\n"
"enum Message {\n"
"    Quit : (),\n"
"    Echo : felt252,\n"
"    Move : (u128, u128),\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"#[derive(Drop)]\n"
"enum Message {\n"
"    Quit : (),\n"
"    Echo : felt252,\n"
"    Move : (u128, u128),\n"
"}\n"
"```"

#: src/ch05-01-enums.md:41
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and `Move`, "
"all with different types:"
msgstr ""
"En este ejemplo, el enum `Message` tiene tres variantes: `Quit`, `Echo` y `Move`, "
"todas con tipos diferentes:"

#: src/ch05-01-enums.md:43
msgid ""
"- `Quit` is the unit type - it has no data associated with it at all.\n"
"- `Echo` is a single felt.\n"
"- `Move` is a tuple of two u128 values."
msgstr ""
"- `Quit` no tiene datos asociados en absoluto.\n"
"- `Echo` incluye un solo campo.\n"
"- `Move` incluye dos valores u128."

#: src/ch05-01-enums.md:47
msgid ""
"You could even use a Struct or another Enum you defined inside one of your Enum "
"variants."
msgstr ""
"Incluso puedes usar una estructura o otro enum que hayas definido dentro de una de "
"las variantes de tu enum."

#: src/ch05-01-enums.md:49
msgid "## Trait Implementations for Enums"
msgstr "## Implementaciones de Traits para Enums"

#: src/ch05-01-enums.md:51
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. This "
"allows you to define methods and behaviors associated with the enum. Here's an "
"example of defining a trait and implementing it for the previous `Message` enum:"
msgstr ""
"En Cairo, puedes definir traits e implementarlos para tus enums personalizados. "
"Esto te permite definir métodos y comportamientos asociados con el enum. Aquí hay "
"un ejemplo de cómo definir un trait e implementarlo para el enum `Message` anterior:"

#: src/ch05-01-enums.md:53
msgid ""
"```rs\n"
"trait Processing {\n"
"    fn process(self: Message);\n"
"}\n"
"\n"
"impl ProcessingImpl of Processing {\n"
"    fn process(self: Message) {\n"
"        match self {\n"
"            Message::Quit(()) => {\n"
"                'quitting'.print();\n"
"            },\n"
"            Message::Echo(value) => {\n"
"                value.print();\n"
"            },\n"
"            Message::Move((x, y)) => {\n"
"                'moving'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"trait Processing {\n"
"    fn process(self: Message);\n"
"}\n"
"\n"
"impl ProcessingImpl of Processing {\n"
"    fn process(self: Message) {\n"
"        match self {\n"
"            Message::Quit(()) => {\n"
"                'quitting'.print();\n"
"            },\n"
"            Message::Echo(value) => {\n"
"                value.print();\n"
"            },\n"
"            Message::Move((x, y)) => {\n"
"                'moving'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch05-01-enums.md:75
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here is how "
"it could be used to process a Quit message:"
msgstr ""
"En este ejemplo, implementamos el trait `Processing` para `Message`. Así es cómo "
"podría ser utilizado para procesar un mensaje Quit:"

#: src/ch05-01-enums.md:77
msgid ""
"```rust\n"
"let msg: Message = Message::Quit(());\n"
"msg.process();\n"
"```"
msgstr ""
"```rust\n"
"let msg: Message = Message::Quit(());\n"
"msg.process();\n"
"```"

#: src/ch05-01-enums.md:82
msgid "Running this code would print `quitting`."
msgstr "Al ejecutar este código se imprimiría `quitting`."

#: src/ch05-01-enums.md:84
msgid "## The Option Enum and Its Advantages"
msgstr "## El Enum Option y sus Ventajas"

#: src/ch05-01-enums.md:86
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an optional "
"value. It has two variants: `Some: T` and `None: ()`. `Some: T ` indicates that "
"there's a value of type `T`, while `None` represents the absence of a value."
msgstr ""
"El enum Option es un enum estándar en Cairo que representa el concepto de un valor "
"opcional. Tiene dos variantes: `Some: T` y `None: ()`. `Some: T` indica que hay un "
"valor de tipo `T`, mientras que `None` representa la ausencia de un valor."

#: src/ch05-01-enums.md:88
msgid ""
"```rs\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None: (),\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"enum Option<T> {\n"
"    Some: T,\n"
"    None: (),\n"
"}\n"
"```"

#: src/ch05-01-enums.md:95
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent the "
"possibility of a value being absent, making your code more expressive and easier to "
"reason about. Using `Option` can also help prevent bugs caused by using "
"uninitialized or unexpected `null` values."
msgstr ""
"El enum `Option` es útil porque te permite representar explícitamente la "
"posibilidad de que un valor esté ausente, lo que hace que tu código sea más "
"expresivo y fácil de entender. Usar `Option` también puede ayudar a prevenir "
"errores causados por el uso de valores `null` no inicializados o inesperados."

#: src/ch05-01-enums.md:97
msgid ""
"To give you an example, here is a function which returns the index of the first "
"element of an array with a given value, or None if the element is not present."
msgstr ""
"Para darte un ejemplo, aquí hay una función que devuelve el índice del primer "
"elemento de un arreglo con un valor dado, o `None` si el elemento no está presente."

#: src/ch05-01-enums.md:99
msgid "We are demonstrating two approaches for the above function:"
msgstr "Estamos demostrando dos enfoques para la función anterior:"

#: src/ch05-01-enums.md:101
msgid ""
"- Recursive Approach `find_value_recursive`\n"
"- Iterative Approach `find_value_iterative`"
msgstr ""
"- Método recursivo `find_value_recursive`\n"
"- Método iterativo find_value_iterative"

#: src/ch05-01-enums.md:104
msgid ""
"> Note: in the future it would be nice to replace this example by something simpler "
"using a loop and without gas related code."
msgstr ""
"> Nota: en el futuro sería bueno reemplazar este ejemplo con algo más simple que "
"use un ciclo y sin código relacionado con el gas."

#: src/ch05-01-enums.md:106
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: usize) -> "
"Option<usize> {\n"
"    match gas::withdraw_gas() {\n"
"        Option::Some(_) => {},\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('OOG');\n"
"            panic(data);\n"
"        },\n"
"    }\n"
"\n"
"    if index >= arr.len() {\n"
"        return Option::None(());\n"
"    }\n"
"\n"
"    if *arr.at(index) == value {\n"
"        return Option::Some(index);\n"
"    }\n"
"\n"
"    find_value_recursive(arr, value, index + 1_usize)\n"
"}\n"
"\n"
"fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> Option<usize> {\n"
"    let length = arr.len();\n"
"    let mut index = 0_usize;\n"
"    let mut found: Option<usize> = Option::None(());\n"
"    loop {\n"
"        if index < length {\n"
"            if *arr.at(index) == value {\n"
"                found = Option::Some(index);\n"
"                break ();\n"
"            }\n"
"        } else {\n"
"            break ();\n"
"        }\n"
"        index += 1_usize;\n"
"    };\n"
"    return found;\n"
"}\n"
"\n"
"#[test]\n"
"#[available_gas(999999)]\n"
"fn test_increase_amount() {\n"
"    let mut my_array = ArrayTrait::new();\n"
"    my_array.append(3);\n"
"    my_array.append(7);\n"
"    my_array.append(2);\n"
"    my_array.append(5);\n"
"\n"
"    let value_to_find = 7;\n"
"    let result = find_value_recursive(@my_array, value_to_find, 0_usize);\n"
"    let result_i = find_value_iterative(@my_array, value_to_find);\n"
"\n"
"\n"
"    match result {\n"
"        Option::Some(index) => {\n"
"            if index == 1_usize {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"    match result_i {\n"
"        Option::Some(index) => {\n"
"            if index == 1_usize {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"fn find_value_recursive(arr: @Array<felt252>, value: felt252, index: usize) -> "
"Option<usize> {\n"
"    match gas::withdraw_gas() {\n"
"        Option::Some(_) => {},\n"
"        Option::None(_) => {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('OOG');\n"
"            panic(data);\n"
"        },\n"
"    }\n"
"\n"
"    if index >= arr.len() {\n"
"        return Option::None(());\n"
"    }\n"
"\n"
"    if *arr.at(index) == value {\n"
"        return Option::Some(index);\n"
"    }\n"
"\n"
"    find_value_recursive(arr, value, index + 1_usize)\n"
"}\n"
"\n"
"fn find_value_iterative(arr: @Array<felt252>, value: felt252) -> Option<usize> {\n"
"    let length = arr.len();\n"
"    let mut index = 0_usize;\n"
"    let mut found: Option<usize> = Option::None(());\n"
"    loop {\n"
"        if index < length {\n"
"            if *arr.at(index) == value {\n"
"                found = Option::Some(index);\n"
"                break ();\n"
"            }\n"
"        } else {\n"
"            break ();\n"
"        }\n"
"        index += 1_usize;\n"
"    };\n"
"    return found;\n"
"}\n"
"\n"
"#[test]\n"
"#[available_gas(999999)]\n"
"fn test_increase_amount() {\n"
"    let mut my_array = ArrayTrait::new();\n"
"    my_array.append(3);\n"
"    my_array.append(7);\n"
"    my_array.append(2);\n"
"    my_array.append(5);\n"
"\n"
"    let value_to_find = 7;\n"
"    let result = find_value_recursive(@my_array, value_to_find, 0_usize);\n"
"    let result_i = find_value_iterative(@my_array, value_to_find);\n"
"\n"
"\n"
"    match result {\n"
"        Option::Some(index) => {\n"
"            if index == 1_usize {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"    match result_i {\n"
"        Option::Some(index) => {\n"
"            if index == 1_usize {\n"
"                'it worked'.print();\n"
"            }\n"
"        },\n"
"        Option::None(()) => {\n"
"            'not found'.print();\n"
"        },\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch05-01-enums.md:186
msgid "Running this code would print `it worked`."
msgstr "Al ejecutar este código se imprimiría `it worked`."

#: src/ch05-02-the-match-control-flow-construct.md:1
msgid "# The Match Control Flow Construct"
msgstr "# La Construcción de Control de Flujo Match"

#: src/ch05-02-the-match-control-flow-construct.md:3
msgid ""
"<!-- TODO : update mention of chapter 18 (on patterns and matching chapter) in "
"paragraph below -->"
msgstr ""
"<!-- TODO : actualizar la mención del capítulo 18 (sobre patrones y concordancia) "
"en el párrafo siguiente -->"

#: src/ch05-02-the-match-control-flow-construct.md:5
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that allows "
"you to compare a value against a series of patterns and then execute code based on "
"which pattern matches. Patterns can be made up of literal values, variable names, "
"wildcards, and many other things. The power of match comes from the expressiveness "
"of the patterns and the fact that the compiler confirms that all possible cases are "
"handled."
msgstr ""
"Cairo tiene una construcción de control de flujo extremadamente poderosa llamada "
"`match` que te permite comparar un valor con una serie de patrones y luego ejecutar "
"código basado en el patrón que coincide. Los patrones pueden estar compuestos por "
"valores literales, nombres de variables, comodines y muchas otras cosas. El poder "
"de `match` proviene de la expresividad de los patrones y del hecho de que el "
"compilador confirma que se manejan todos los casos posibles."

#: src/ch05-02-the-match-control-flow-construct.md:7
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins slide down "
"a track with variously sized holes along it, and each coin falls through the first "
"hole it encounters that it fits into. In the same way, values go through each "
"pattern in a match, and at the first pattern the value “fits”, the value falls into "
"the associated code block to be used during execution."
msgstr ""
"Piensa en una expresión `match` como una máquina clasificadora de monedas: las "
"monedas se deslizan por una pista con agujeros de diferentes tamaños a lo largo de "
"ella, y cada moneda cae por el primer agujero que encuentra en el que encaja. De la "
"misma manera, los valores pasan por cada patrón en un `match`, y en el primer "
"patrón en el que el valor \"encaja\", el valor cae en el bloque de código asociado "
"para ser utilizado durante la ejecución."

#: src/ch05-02-the-match-control-flow-construct.md:9
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a "
"function that takes an unknown US coin and, in a similar way as the counting "
"machine, determines which coin it is and returns its value in cents, as shown in "
"Listing 5-3."
msgstr ""
"Hablando de monedas, ¡usemoslas como ejemplo con `match`! Podemos escribir una "
"función que toma una moneda de EE. UU. desconocida y, de manera similar a la "
"máquina de contar, determina qué moneda es y devuelve su valor en centavos, como se "
"muestra en el Listado 5-3."

#: src/ch05-02-the-match-control-flow-construct.md:11
msgid ""
"```rust\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (),\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(_) => 25,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (),\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(_) => 25,\n"
"    }\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:29
msgid ""
"Listing 5-3: An enum and a match expression that has the variants of the enum as "
"its patterns"
msgstr ""
"Listado 5-3: Un enum y una expresión `match` que tiene las variantes del enum como "
"sus patrones"

#: src/ch05-02-the-match-control-flow-construct.md:31
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list the "
"`match` keyword followed by an expression, which in this case is the value `coin`. "
"This seems very similar to a conditional expression used with if, but there’s a big "
"difference: with if, the condition needs to evaluate to a Boolean value, but here "
"it can be any type. The type of coin in this example is the `Coin` enum that we "
"defined on the first line."
msgstr ""
"Desglosemos el `match` en la función `value_in_cents`. Primero enumeramos la "
"palabra clave `match` seguida de una expresión, que en este caso es el valor "
"`coin`. Esto parece muy similar a una expresión condicional utilizada con `if`, "
"pero hay una gran diferencia: con `if`, la condición debe evaluarse a un valor "
"booleano, pero aquí puede ser de cualquier tipo. El tipo de moneda en este ejemplo "
"es el enum `Coin` que definimos en la primera línea."

#: src/ch05-02-the-match-control-flow-construct.md:33
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. The first "
"arm here has a pattern that is the value `Coin::Penny(_)` and then the `=>` "
"operator that separates the pattern and the code to run. The code in this case is "
"just the value `1`. Each arm is separated from the next with a comma."
msgstr ""
"A continuación, están los brazos del `match`. Un brazo tiene dos partes: un patrón "
"y algún código. El primer brazo aquí tiene un patrón que es el valor `Coin::"
"Penny(_)` y luego el operador `=>` que separa el patrón y el código a ejecutar. El "
"código en este caso es simplemente el valor `1`. Cada brazo está separado del "
"siguiente con una coma."

#: src/ch05-02-the-match-control-flow-construct.md:35
msgid ""
"When the `match` expression executes, it compares the resultant value against the "
"pattern of each arm, in order. If a pattern matches the value, the code associated "
"with that pattern is executed. If that pattern doesn’t match the value, execution "
"continues to the next arm, much as in a coin-sorting machine. We can have as many "
"arms as we need: in the above example, our match has four arms."
msgstr ""
"Cuando se ejecuta la expresión `match`, compara el valor resultante con el patrón "
"de cada brazo, en orden. Si un patrón coincide con el valor, se ejecuta el código "
"asociado con ese patrón. Si ese patrón no coincide con el valor, la ejecución "
"continúa con el siguiente brazo, como en una máquina clasificadora de monedas. "
"Podemos tener tantos brazos como necesitemos: en el ejemplo anterior, nuestro "
"`match` tiene cuatro brazos."

#: src/ch05-02-the-match-control-flow-construct.md:37
msgid "In Cairo, the order of the arms must follow the same order as the enum."
msgstr "En Cairo, el orden de los brazos debe seguir el mismo orden que el enum."

#: src/ch05-02-the-match-control-flow-construct.md:39
msgid ""
"The code associated with each arm is an expression, and the resultant value of the "
"expression in the matching arm is the value that gets returned for the entire match "
"expression."
msgstr ""
"El código asociado con cada brazo es una expresión, y el valor resultante de la "
"expresión en el brazo coincidente es el valor que se devuelve para toda la "
"expresión match."

#: src/ch05-02-the-match-control-flow-construct.md:41
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it is in "
"our example where each arm just returns a value. If you want to run multiple lines "
"of code in a match arm, you must use curly brackets, with a comma following the "
"arm. For example, the following code prints “Lucky penny!” every time the method is "
"called with a `Coin::Penny(())`, but still returns the last value of the block, `1`:"
msgstr ""
"Normalmente no usamos llaves si el código del brazo del `match` es corto, como en "
"nuestro ejemplo donde cada brazo simplemente devuelve un valor. Si desea ejecutar "
"varias líneas de código en un brazo del `match`, debe usar llaves, con una coma "
"después del brazo. Por ejemplo, el siguiente código imprime \"¡Moneda de la suerte!"
"\" cada vez que se llama al método con una `Coin::Penny(())`, pero aún devuelve el "
"último valor del bloque, `1`:"

#: src/ch05-02-the-match-control-flow-construct.md:43
msgid ""
"```rust\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => {\n"
"            ('Lucky penny!').print();\n"
"            1\n"
"        },\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(_)=> 25,\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => {\n"
"            ('Lucky penny!').print();\n"
"            1\n"
"        },\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(_)=> 25,\n"
"    }\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:57
msgid "## Patterns That Bind to Values"
msgstr "## Patrones que se Vinculan con Valores"

#: src/ch05-02-the-match-control-flow-construct.md:59
msgid ""
"Another useful feature of match arms is that they can bind to the parts of the "
"values that match the pattern. This is how we can extract values out of enum "
"variants."
msgstr ""
"Otra característica útil de los brazos de coincidencia es que pueden vincularse con "
"las partes de los valores que coinciden con el patrón. Así es como podemos extraer "
"valores de las variantes de una enum."

#: src/ch05-02-the-match-control-flow-construct.md:61
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. From "
"1999 through 2008, the United States minted quarters with different designs for "
"each of the 50 states on one side. No other coins got state designs, so only "
"quarters have this extra value. We can add this information to our `enum` by "
"changing the `Quarter` variant to include a `UsState` value stored inside it, which "
"we’ve done in Listing 5-4."
msgstr ""
"Como ejemplo, cambiemos una de nuestras variantes de enum para que contenga datos "
"en su interior. Desde 1999 hasta 2008, la Casa de la Moneda de los Estados Unidos "
"acuñó monedas de 25 centavos con diseños diferentes para cada uno de los 50 estados "
"en un lado. Ninguna otra moneda tenía diseños estatales, por lo que solo los "
"cuartos tienen este valor adicional. Podemos agregar esta información a nuestra "
"`enum` cambiando la variante `Quarter` para incluir un valor `UsState` almacenado "
"en su interior, lo cual hemos hecho en la Lista 5-4."

#: src/ch05-02-the-match-control-flow-construct.md:63
msgid ""
"```rust\n"
"#[derive(Drop)]\n"
"enum UsState {\n"
"    Alabama: (),\n"
"    Alaska: (),\n"
"}\n"
"\n"
"#[derive(Drop)]\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (UsState),\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop)]\n"
"enum UsState {\n"
"    Alabama: (),\n"
"    Alaska: (),\n"
"}\n"
"\n"
"#[derive(Drop)]\n"
"enum Coin {\n"
"    Penny: (),\n"
"    Nickel: (),\n"
"    Dime: (),\n"
"    Quarter: (UsState),\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:79
msgid ""
"Listing 5-4: A `Coin` enum in which the `Quarter` variant also holds a `UsState` "
"value"
msgstr ""
"Listado 5-4: Un enum `Coin` en el que la variante `Quarter` también tiene un valor "
"`UsState`"

#: src/ch05-02-the-match-control-flow-construct.md:81
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. While we "
"sort our loose change by coin type, we’ll also call out the name of the state "
"associated with each quarter so that if it’s one our friend doesn’t have, they can "
"add it to their collection."
msgstr ""
"Imaginemos que un amigo está tratando de recolectar todas las 50 monedas de cuarto "
"de estado. Mientras clasificamos nuestro cambio suelto por tipo de moneda, también "
"llamaremos el nombre del estado asociado con cada cuarto para que si es uno que "
"nuestro amigo no tiene, puedan agregarlo a su colección."

#: src/ch05-02-the-match-control-flow-construct.md:83
msgid ""
"In the match expression for this code, we add a variable called `state` to the "
"pattern that matches values of the variant `Coin::Quarter`. When a `Coin::Quarter` "
"matches, the `state` variable will bind to the value of that quarter’s state. Then "
"we can use `state` in the code for that arm, like so:"
msgstr ""
"En la expresión `match` de este código, agregamos una variable llamada `state` al "
"patrón que coincide con los valores de la variante `Coin::Quarter`. Cuando se hace "
"una coincidencia de `Coin::Quarter`, la variable `state` se vinculará al valor del "
"estado de ese cuarto. Luego podemos usar `state` en el código para ese brazo, así:"

#: src/ch05-02-the-match-control-flow-construct.md:85
msgid ""
"```rust\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(state)=> {\n"
"            state.print();\n"
"            25\n"
"        },\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny(_) => 1,\n"
"        Coin::Nickel(_) => 5,\n"
"        Coin::Dime(_) => 10,\n"
"        Coin::Quarter(state)=> {\n"
"            state.print();\n"
"            25\n"
"        },\n"
"    }\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:99
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an "
"implementation for the `print` function for the `debug::PrintTrait`:"
msgstr ""
"Para imprimir el valor de una variante de un enum en Cairo, necesitamos agregar una "
"implementación para la función `print` de `debug::PrintTrait`:"

#: src/ch05-02-the-match-control-flow-construct.md:101
msgid ""
"```rust\n"
"impl UsStatePrintImpl of PrintTrait::<UsState> {\n"
"    fn print(self: UsState) {\n"
"        match self {\n"
"            UsState::Alabama(_) => ('Alabama').print(),\n"
"            UsState::Alaska(_) => ('Alaska').print(),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl UsStatePrintImpl of PrintTrait::<UsState> {\n"
"    fn print(self: UsState) {\n"
"        match self {\n"
"            UsState::Alabama(_) => ('Alabama').print(),\n"
"            UsState::Alaska(_) => ('Alaska').print(),\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:112
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska())`. When we compare that value with each "
"of the match arms, none of them match until we reach `Coin::Quarter(state)`. At "
"that point, the binding for state will be the value `UsState::Alaska()`. We can "
"then use that binding in the `PrintTrait`, thus getting the inner state value out "
"of the `Coin` enum variant for `Quarter`."
msgstr ""
"Si llamáramos a `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, `coin` sería "
"`Coin::Quarter(UsState::Alaska())`. Cuando comparamos ese valor con cada uno de los "
"brazos del `match`, ninguno coincide hasta que llegamos a `Coin::Quarter (state)`. "
"En ese momento, la asignación para `state` será el valor `UsState::Alaska()`. Luego "
"podemos usar esa asignación en el `PrintTrait`, obteniendo así el valor interno de "
"estado fuera de la variante `Coin` para `Quarter`."

#: src/ch05-02-the-match-control-flow-construct.md:114
msgid "## Matching with Options"
msgstr "## Coincidencia Con Opciones"

#: src/ch05-02-the-match-control-flow-construct.md:116
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the `Some` "
"case when using `Option<T>`; we can also handle `Option<T>` using `match`, as we "
"did with the `Coin` enum! Instead of comparing coins, we’ll compare the variants of "
"`Option<T>`, but the way the `match` expression works remains the same. You can use "
"Options by importing the `option::OptionTrait` trait."
msgstr ""
"En la sección anterior, queríamos obtener el valor interno `T` fuera del caso "
"`Some` al usar `Option<T>`; ¡también podemos manejar `Option<T>` usando `match`, "
"como lo hicimos con el `enum` `Coin`! En lugar de comparar monedas, compararemos "
"las variantes de `Option<T>`, pero la forma en que funciona la expresión `match` "
"sigue siendo la misma. Puedes usar opciones importando el trait `option::"
"OptionTrait`."

#: src/ch05-02-the-match-control-flow-construct.md:118
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if there’s a "
"value inside, adds `1_u8` to that value. If there isn’t a value inside, the "
"function should return the `None` value and not attempt to perform any operations."
msgstr ""
"Digamos que queremos escribir una función que tome una `Option<u8>` y, si hay un "
"valor dentro, agregue `1_u8` a ese valor. Si no hay un valor dentro, la función "
"debería devolver el valor `None` y no intentar realizar ninguna operación."

#: src/ch05-02-the-match-control-flow-construct.md:120
msgid ""
"This function is very easy to write, thanks to match, and will look like Listing "
"5-5."
msgstr ""
"Esta función es muy fácil de escribir, gracias a `match`, y se verá como en el "
"listado 5-5."

#: src/ch05-02-the-match-control-flow-construct.md:122
msgid ""
"```rust\n"
"use option::OptionTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1_u8),\n"
"        Option::None(_) => Option::None(()),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let five: Option<u8> = Option::Some(5_u8);\n"
"    let six: Option<u8> = plus_one(five);\n"
"    six.unwrap().print();\n"
"    let none = plus_one(Option::None(()));\n"
"    none.unwrap().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use option::OptionTrait;\n"
"use debug::PrintTrait;\n"
"\n"
"fn plus_one(x: Option<u8>) -> Option<u8> {\n"
"    match x {\n"
"        Option::Some(val) => Option::Some(val + 1_u8),\n"
"        Option::None(_) => Option::None(()),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let five: Option<u8> = Option::Some(5_u8);\n"
"    let six: Option<u8> = plus_one(five);\n"
"    six.unwrap().print();\n"
"    let none = plus_one(Option::None(()));\n"
"    none.unwrap().print();\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:142
msgid "Listing 5-5: A function that uses a match expression on an `Option<u8>`"
msgstr "Listado 5-5: Una función que usa una expresión `match` en un `Option<u8>`"

#: src/ch05-02-the-match-control-flow-construct.md:144
msgid ""
"Note that your arms must respect the same order as the enum defined in the "
"`OptionTrait` of the core Cairo lib."
msgstr ""
"Tenga en cuenta que los brazos (`arms`) deben respetar el mismo orden que el enum "
"definido en `OptionTrait` de la librería central de Cairo."

#: src/ch05-02-the-match-control-flow-construct.md:146
msgid ""
"```rust\n"
"    enum Option<T> {\n"
"        Some: T,\n"
"        None: (),\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    enum Option<T> {\n"
"        Some: T,\n"
"        None: (),\n"
"    }\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:153
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the value "
"`Some(5_u8)`. We then compare that against each match arm:"
msgstr ""
"Estudiemos con más detalle la primera ejecución de `plus_one`. Cuando llamamos a "
"`plus_one(five)`, la variable `x` en el cuerpo de `plus_one` tendrá el valor "
"`Some(5_u8)`. Luego, lo comparamos con cada rama del `match`:"

#: src/ch05-02-the-match-control-flow-construct.md:155
#: src/ch05-02-the-match-control-flow-construct.md:163
msgid ""
"```rust\n"
"    Option::Some(val) => Option::Some(val + 1_u8),\n"
"```"
msgstr ""
"```rust\n"
"    Option::Some(val) => Option::Some(val + 1_u8),\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:159
msgid ""
"Does `Option::Some(5_u8)` value match the pattern `Option::Some(val)`? It does! We "
"have the same variant. The `val` binds to the value contained in `Option::Some`, so "
"`val` takes the value `5_u8`. The code in the match arm is then executed, so we add "
"`1_u8` to the value of `val` and create a new `Option::Some` value with our total "
"`6_u8` inside. Because the first arm matched, no other arms are compared."
msgstr ""
"¿El valor `Option::Some(5_u8)` coincide con el patrón `Option::Some(val)`? ¡Sí! "
"Tenemos la misma variante. `val` se vincula al valor contenido en `Option::Some`, "
"por lo que `val` toma el valor `5_u8`. Luego se ejecuta el código en el brazo del "
"`match`, por lo que agregamos `1_u8` al valor de `val` y creamos un nuevo valor "
"`Option::Some` con nuestro total `6_u8` en su interior. Debido a que se ha "
"realizado la primera coincidencia, no se comparan otros brazos."

#: src/ch05-02-the-match-control-flow-construct.md:161
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where `x` is "
"`Option::None(())`. We enter the match and compare to the first arm:"
msgstr ""
"Ahora consideremos la segunda llamada de `plus_one` en nuestra función principal, "
"donde `x` es `Option::None(())`. Entramos en el `match` y comparamos con el primer "
"brazo:"

#: src/ch05-02-the-match-control-flow-construct.md:167
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so we "
"continue to the next arm:"
msgstr ""
"El valor `Option::Some(5_u8)` no coincide con el patrón `Option::None`, así que "
"continuamos con el siguiente brazo:"

#: src/ch05-02-the-match-control-flow-construct.md:169
msgid ""
"```rust\n"
"    Option::None(_) => Option::None(()),\n"
"```"
msgstr ""
"```rust\n"
"    Option::None(_) => Option::None(()),\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:173
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`Option::None(())` value on the right side of `=>`."
msgstr ""
"¡Coincide! No hay valor al que agregar, por lo que el programa se detiene y "
"devuelve el valor `Option::None(())` en el lado derecho de `=>`."

#: src/ch05-02-the-match-control-flow-construct.md:175
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this pattern a "
"lot in Cairo code: `match` against an enum, bind a variable to the data inside, and "
"then execute code based on it. It’s a bit tricky at first, but once you get used to "
"it, you’ll wish you had it in all languages. It’s consistently a user favorite."
msgstr ""
"Combinar `match` y enumeraciones es útil en muchas situaciones. Verás este patrón "
"mucho en el código de Cairo: `match` contra una enumeración, enlaza una variable "
"con los datos internos y luego ejecuta código basado en ella. Es un poco complicado "
"al principio, pero una vez que te acostumbras, desearás tenerlo en todos los "
"lenguajes. Es consistentemente favorito de los usuarios."

#: src/ch05-02-the-match-control-flow-construct.md:177
msgid "## Matches Are Exhaustive"
msgstr "## Los Matches Son Exhaustivos"

#: src/ch05-02-the-match-control-flow-construct.md:179
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns must cover "
"all possibilities. Consider this version of our `plus_one` function, which has a "
"bug and won’t compile:"
msgstr ""
"Hay otro aspecto de los matches que necesitamos discutir: los patrones de los "
"brazos deben cubrir todas las posibilidades. Considera esta versión de nuestra "
"función `plus_one`, que tiene un error y no se compilará:"

#: src/ch05-02-the-match-control-flow-construct.md:181
msgid ""
"```bash\n"
"$ cairo-run src/test.cairo\n"
"    error: Unsupported match. Currently, matches require one arm per variant,\n"
"    in the order of variant definition.\n"
"    --> test.cairo:34:5\n"
"        match x {\n"
"        ^*******^\n"
"    Error: failed to compile: ./src/test.cairo\n"
"```"
msgstr ""
"```bash\n"
"$ cairo-run src/test.cairo\n"
"    error: Unsupported match. Currently, matches require one arm per variant,\n"
"    in the order of variant definition.\n"
"    --> test.cairo:34:5\n"
"        match x {\n"
"        ^*******^\n"
"    Error: failed to compile: ./src/test.cairo\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:191
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which pattern "
"we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility "
"in order for the code to be valid. Especially in the case of `Option<T>`, when "
"Cairo prevents us from forgetting to explicitly handle the `None` case, it protects "
"us from assuming that we have a value when we might have null, thus making the "
"billion-dollar mistake discussed earlier impossible."
msgstr ""
"Cairo sabe que no cubrimos todos los casos posibles, ¡e incluso sabe qué patrón "
"olvidamos! Los matches en Cairo son exhaustivos: debemos cubrir todas las "
"posibilidades para que el código sea válido. Especialmente en el caso de "
"`Option<T>`, cuando Cairo nos impide olvidar manejar explícitamente el caso `None`, "
"nos protege de asumir que tenemos un valor cuando podríamos tener nulo, lo que hace "
"imposible el error de mil millones de dólares discutido anteriormente."

#: src/ch05-02-the-match-control-flow-construct.md:193
msgid "## Match 0 and the \\_ Placeholder"
msgstr "## Match 0 y el Comodín \\_"

#: src/ch05-02-the-match-control-flow-construct.md:195
msgid ""
"Using enums, we can also take special actions for a few particular values, but for "
"all other values take one default action. Currently only `0` and the `_`operator "
"are supported."
msgstr ""
"Usando enums, también podemos tomar acciones especiales para algunos valores "
"particulares, pero para todos los demás valores tomar una acción predeterminada. "
"Actualmente solo se admiten `0` y el operador `_`."

#: src/ch05-02-the-match-control-flow-construct.md:197
msgid ""
"Imagine we’re implementing a game where, you get a random number between 0 and 7. "
"If you have 0, you win. For all other values you loose. Here's a match that "
"implements that logic, with the number hardcoded rather than a random value."
msgstr ""
"Imaginemos que estamos implementando un juego en el que obtienes un número "
"aleatorio entre 0 y 7. Si tienes 0, ganas. Para todos los demás valores pierdes. "
"Aquí hay un match que implementa esa lógica, con el número codificado en lugar de "
"un valor aleatorio."

#: src/ch05-02-the-match-control-flow-construct.md:199
msgid ""
"```rust\n"
"fn did_i_win(nb: felt252) {\n"
"    match nb {\n"
"        0 => ('You won!').print(),\n"
"        _ => ('You lost...').print(),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn did_i_win(nb: felt252) {\n"
"    match nb {\n"
"        0 => ('You won!').print(),\n"
"        _ => ('You lost...').print(),\n"
"    }\n"
"}\n"
"```"

#: src/ch05-02-the-match-control-flow-construct.md:208
msgid ""
"The first arm, the pattern is the literal values 0. For the last arm that covers "
"every other possible value, the pattern is the character `_`. This code compiles, "
"even though we haven’t listed all the possible values a `felt252` can have, because "
"the last pattern will match all values not specifically listed. This catch-all "
"pattern meets the requirement that `match` must be exhaustive. Note that we have to "
"put the catch-all arm last because the patterns are evaluated in order. If we put "
"the catch-all arm earlier, the other arms would never run, so Cairo will warn us if "
"we add arms after a catch-all!"
msgstr ""
"Para el primer brazo, el patrón es el valor literal 0. Para el último brazo, que "
"cubre todos los demás valores posibles, el patrón es el carácter `_`. Este código "
"compila, aunque no hayamos enumerado todos los valores posibles que puede tener "
"`felt252`, porque el último patrón coincidirá con todos los valores no enumerados "
"específicamente. Este patrón catch-all cumple el requisito de que `match` debe ser "
"exhaustivo. Tenga en cuenta que tenemos que poner la rama catch-all en último lugar "
"porque los patrones se evalúan en orden. Si pusiéramos el brazo catch-all antes, "
"los otros brazos nunca se ejecutarían, ¡así que Cairo nos avisará si añadimos "
"brazos después de un catch-all!"

#: src/ch05-02-the-match-control-flow-construct.md:210
msgid ""
"<!-- TODO : might need to link the end of this chapter to patterns and matching "
"chapter -->"
msgstr ""
"<!-- TODO: puede que necesitemos enlazar el final de este capítulo con el capítulo "
"de patrones y coincidencias -->"

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "# Managing Cairo Projects with Packages, Crates and Modules"
msgstr "# Gestión de proyectos Cairo con Paquetes, Crates y Módulos"

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly\n"
"important. By grouping related functionality and separating code with distinct\n"
"features, you’ll clarify where to find code that implements a particular\n"
"feature and where to go to change how a feature works."
msgstr ""
"A medida que escriba programas grandes, la organización de su código se volverá "
"cada \n"
"vez más importante. Al agrupar funcionalidades relacionadas y separar el código "
"con \n"
"características distintas, aclarará dónde encontrar el código que implementa una "
"característica\n"
" en particular y dónde ir para cambiar cómo funciona una característica."

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a\n"
"project grows, you should organize code by splitting it into multiple modules\n"
"and then multiple files. As a package grows, you can extract parts into\n"
"separate crates that become external dependencies. This chapter covers all\n"
"these techniques."
msgstr ""
"Los programas que hemos escrito hasta ahora han estado en un módulo en un archivo. "
"A medida que\n"
"proyecto crece, debe organizar el código dividiéndolo en varios módulos\n"
"y luego en varios archivos. A medida que un paquete crece, puede extraer partes en\n"
"cajas separadas que se convierten en dependencias externas. Este capítulo cubre "
"todas\n"
"estas técnicas."

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you reuse\n"
"code at a higher level: once you’ve implemented an operation, other code can\n"
"call your code without having to know how the\n"
"implementation works."
msgstr ""
"También discutiremos la encapsulación de detalles de implementación, lo que le \n"
"permite reutilizar el código a un nivel superior: una vez que ha implementado una\n"
" operación, otro código puede llamar a su código sin tener que saber cómo "
"funciona \n"
"la implementación."

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has a\n"
"set of names that are defined as “in scope.” When reading, writing, and\n"
"compiling code, programmers and compilers need to know whether a particular\n"
"name at a particular spot refers to a variable, function, struct, enum, module,\n"
"constant, or other item and what that item means. You can create scopes and\n"
"change which names are in or out of scope. You can’t have two items with the\n"
"same name in the same scope."
msgstr ""
"Un concepto relacionado es el ámbito: el contexto anidado en el que se escribe el \n"
"código tiene un conjunto de nombres que se definen como \"en ámbito\". Al leer, "
"escribir \n"
"y compilar código, los programadores y compiladores deben saber si un nombre "
"particular \n"
"en un lugar particular se refiere a una variable, función, estructura, enumeración, "
"módulo, \n"
"constante u otro elemento y qué significa ese elemento. Puede crear ámbitos y "
"cambiar \n"
"qué nombres están dentro o fuera de ámbito. No puede tener dos elementos con el "
"mismo nombre en el mismo ámbito."

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s\n"
"organization. These features, sometimes\n"
"collectively referred to as the _module system_, include:"
msgstr ""
"Cairo tiene varias características que le permiten gestionar la organización de \n"
"su código. Estas características, a veces denominadas colectivamente el _sistema de "
"módulos_,\n"
" incluyen:"

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"- **Packages:** A Scarb feature that lets you build, test, and share crates\n"
"- **Crates:** A tree of modules that corresponds to a single compilation unit.\n"
"  It has a root directory, and a root module defined at the file `lib.cairo` under "
"this directory.\n"
"- **Modules** and **use:** Let you control the organization and scope of items.\n"
"- **Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""
"- **Paquetes:** Una característica de Scarb que le permite construir, probar y "
"compartir Crates.\n"
"- **Crates:** Un árbol de módulos que corresponde a una única unidad de "
"compilación. Tiene un directorio\n"
" raíz y un módulo raíz definido en el archivo `lib.cairo` bajo este directorio.\n"
"- **Módulos** y **use:** le permiten controlar la organización y el ámbito de los "
"elementos.\n"
"- **Rutas:** una forma de nombrar un elemento, como una estructura, función o módulo"

#: src/ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, and\n"
"explain how to use them to manage scope. By the end, you should have a solid\n"
"understanding of the module system and be able to work with scopes like a pro!"
msgstr ""
"En este capítulo, cubriremos todas estas características, discutiremos cómo "
"interactúan, y\n"
"cómo utilizarlas para gestionar el alcance. Al final, deberías tener una sólida\n"
"del sistema de módulos y serás capaz de trabajar con ámbitos como un profesional"

#: src/ch06-01-packages-and-crates.md:1
msgid "# Packages and Crates"
msgstr "# Paquetes y Crates"

#: src/ch06-01-packages-and-crates.md:3
msgid "## What is a crate?"
msgstr "## ¿Qué es un Crate?"

#: src/ch06-01-packages-and-crates.md:4
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at a time. "
"Even if you run `cairo-compile` rather than `scarb build` and pass a single source "
"code file, the compiler considers that file to be a crate. Crates can contain "
"modules, and the modules may be defined in other files that get compiled with the "
"crate, as will be discussed in the subsequent sections."
msgstr ""
"Un crate es la cantidad más pequeña de código que el compilador de Cairo considera "
"a la vez. Incluso si ejecuta `cairo-compile` en lugar de `scarb build` y pasa un "
"solo archivo de código fuente, el compilador considera que ese archivo es un crate. "
"Los crates pueden contener módulos, y los módulos pueden estar definidos en otros "
"archivos que se compilan junto con el crate, como se discutirá en las secciones "
"siguientes."

#: src/ch06-01-packages-and-crates.md:6
msgid "## What is the crate root?"
msgstr "## ¿Qué es la Raíz del Crate?"

#: src/ch06-01-packages-and-crates.md:7
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts from "
"and makes up the root module of your crate (we’ll explain modules in depth in the "
"[“Defining Modules to Control Scope”](./ch06-02-defining-modules-to-control-scope."
"md) section)."
msgstr ""
"La raíz del crate es el fichero fuente `lib.cairo` desde el que arranca el "
"compilador de Cairo y constituye el módulo raíz de tu crate (explicaremos los "
"módulos en profundidad en la sección [\"Definición de módulos para controlar el "
"alcance\"](./ch06-02-defining-modules-to-control-scope.md) section)."

#: src/ch06-01-packages-and-crates.md:9
msgid "## What is a package?"
msgstr "## ¿Qué es un Paquete?"

#: src/ch06-01-packages-and-crates.md:10
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file that "
"describes how to build those crates. This enables the splitting of code into "
"smaller, reusable parts and facilitates more structured dependency management."
msgstr ""
"Un paquete de Cairo es un conjunto de uno o más crates con un archivo Scarb.toml "
"que describe cómo construir esos crates. Esto permite la división del código en "
"partes más pequeñas y reutilizables, y facilita la gestión de dependencias más "
"estructurada."

#: src/ch06-01-packages-and-crates.md:12
msgid "## Creating a Package with Scarb"
msgstr "## Creación de un Paquete con Scarb"

#: src/ch06-01-packages-and-crates.md:14
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To create a "
"new package, run the following command:"
msgstr ""
"Puede crear un nuevo paquete de Cairo utilizando la herramienta de línea de "
"comandos scarb. Para crear un nuevo paquete, ejecute el siguiente comando:"

#: src/ch06-01-packages-and-crates.md:16
msgid ""
"```bash\n"
"scarb new my_package\n"
"```"
msgstr ""
"```bash\n"
"scarb new my_package\n"
"```"

#: src/ch06-01-packages-and-crates.md:20
msgid ""
"This command will generate a new package directory named `my_package` with the "
"following structure:"
msgstr ""
"Este comando generará un nuevo directorio de paquete llamado my_crate con la "
"siguiente estructura:"

#: src/ch06-01-packages-and-crates.md:22
msgid ""
"```\n"
"my_package/\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```\n"
"my_package/\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"

#: src/ch06-01-packages-and-crates.md:29
msgid ""
"- `src/` is the main directory where all the Cairo source files for the package "
"will be stored.\n"
"- `lib.cairo` is the default root module of the crate, which is also the main entry "
"point of the package. By default, it is empty.\n"
"- `Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, version, "
"and authors. You can find documentation about it on the [scarb reference](https://"
"docs.swmansion.com/scarb/docs/reference/manifest)."
msgstr ""
"- `src/` es el directorio principal donde se almacenarán todos los archivos de "
"origen de Cairo para el paquete.\n"
"- `lib.cairo` es el módulo raíz predeterminado del crate, que también es el punto "
"de entrada principal del paquete. Por defecto, está vacío.\n"
"- `Scarb.toml` es el archivo de manifiesto del paquete, que contiene metadatos y "
"opciones de configuración para el paquete, como dependencias, nombre del paquete, "
"versión y autores. Puede encontrar documentación al respecto en la [referencia de "
"Scarb](https://docs.swmansion.com/scarb/docs/reference/manifest)."

#: src/ch06-01-packages-and-crates.md:33
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch06-01-packages-and-crates.md:42
msgid ""
"As you develop your package, you may want to organize your code into multiple Cairo "
"source files. You can do this by creating additional `.cairo` files within the "
"`src` directory or its subdirectories."
msgstr ""
"A medida que desarrolla su paquete, es posible que desee organizar su código en "
"varios archivos de origen de Cairo. Puede hacer esto creando archivos `.cairo` "
"adicionales dentro del directorio `src` o sus subdirectorios."

#: src/ch06-02-defining-modules-to-control-scope.md:1
msgid "## Defining Modules to Control Scope"
msgstr "## Definición de Módulos para Controlar el Ámbito"

#: src/ch06-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module system,\n"
"namely _paths_ that allow you to name items and the `use` keyword that brings a\n"
"path into scope."
msgstr ""
"En esta sección, hablaremos sobre los módulos y otras partes del sistema de "
"módulos, \n"
"como las _rutas_ que le permiten nombrar elementos y la palabra clave `use` \n"
"que introduce una ruta en el ámbito."

#: src/ch06-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when you’re\n"
"organizing your code in the future. Then we’ll explain each of the rules in\n"
"detail."
msgstr ""
"Primero, vamos a comenzar con una lista de reglas para su fácil referencia \n"
"cuando esté organizando su código en el futuro. Luego explicaremos cada una \n"
"de las reglas en detalle."

#: src/ch06-02-defining-modules-to-control-scope.md:11
msgid "### Modules Cheat Sheet"
msgstr "### Hoja de Trucos de Módulos"

#: src/ch06-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` keyword\n"
"work in the compiler, and how most developers organize their\n"
"code. We’ll be going through examples of each of these rules throughout this\n"
"chapter, but this is a great place to refer to as a reminder of how modules\n"
"work. You can create a new Scarb project with `scarb new backyard` to follow along."
msgstr ""
"Aquí ofrecemos una referencia rápida sobre cómo funcionan los módulos, las rutas y "
"la palabra clave `use\n"
"y cómo la mayoría de los desarrolladores organizan su código.\n"
"código. Veremos ejemplos de cada una de estas reglas a lo largo de este\n"
"capítulo, pero este es un buen lugar para recordar cómo funcionan los módulos.\n"
"funcionan. Puede crear un nuevo proyecto Scarb con `scarb new backyard` para "
"seguirlo."

#: src/ch06-02-defining-modules-to-control-scope.md:19
msgid ""
"- **Start from the crate root**: When compiling a crate, the compiler first\n"
"  looks in the crate root file (_src/lib.cairo_) for code to compile.\n"
"- **Declaring modules**: In the crate root file, you can declare new modules;\n"
"  say, you declare a “garden” module with `mod garden;`. The compiler will look\n"
"  for the module’s code in these places:\n"
"\n"
"  - Inline, within curly brackets that replace the semicolon following `mod garden;"
"`.\n"
"\n"
"    ```rust\n"
"      // crate root file (lib.cairo)\n"
"        mod garden {\n"
"        // code defining the garden module goes here\n"
"        }\n"
"    ```\n"
"\n"
"- In the file _src/garden.cairo_\n"
"- **Declaring submodules**: In any file other than the crate root, you can\n"
"  declare submodules. For example, you might declare `mod vegetables;` in\n"
"  _src/garden.cairo_. The compiler will look for the submodule’s code within the\n"
"  directory named for the parent module in these places:\n"
"\n"
"  - Inline, directly following `mod vegetables`, within curly brackets instead\n"
"    of the semicolon.\n"
"\n"
"    ```rust\n"
"    // src/garden.cairo file\n"
"    mod vegetables {\n"
"        // code defining the vegetables submodule goes here\n"
"    }\n"
"    ```\n"
"\n"
"  - In the file _src/garden/vegetables.cairo_\n"
"\n"
"- **Paths to code in modules**: Once a module is part of your crate, you can\n"
"  refer to code in that module from anywhere else in that same crate, using the "
"path\n"
"  to the code. For example, an `Asparagus` type in the garden vegetables module "
"would be found at\n"
"  `backyard::garden::vegetables::Asparagus`.\n"
"- **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts to\n"
"  items to reduce repetition of long paths. In any scope that can refer to\n"
"  `backyard::garden::vegetables::Asparagus`, you can create a shortcut with\n"
"  `use backyard::garden::vegetables::Asparagus;` and from then on you only need to\n"
"  write `Asparagus` to make use of that type in the scope."
msgstr ""
"- **Comience desde la raíz del crate**: Al compilar un crate, el compilador "
"primero \n"
"busca código para compilar en el archivo raíz del crate (_src/lib.cairo_).\n"
"- **Declaración de módulos**: En el archivo raíz del crate, puede declarar nuevos "
"módulos;\n"
"  digamos que declara un módulo \"garden\" con `mod garden;`. El compilador "
"buscará \n"
"el código del módulo en estos lugares:\n"
"\n"
"  - En línea, dentro de llaves que reemplazan al punto y coma que sigue a `mod "
"garden;`.\n"
"\n"
"    ```rust\n"
"      // crate root file (lib.cairo)\n"
"        mod garden {\n"
"        // code defining the garden module goes here\n"
"        }\n"
"    ```\n"
"\n"
"- En el archivo _src/garden.cairo_\n"
"- **Declarando submódulos**: En cualquier archivo que no sea la raíz del paquete, "
"puede \n"
"  declarar submódulos. Por ejemplo, podría declarar `mod vegetables;` en \n"
"  el archivo _src/garden.cairo_. El compilador buscará el código del submódulo "
"dentro \n"
"  del directorio nombrado por el módulo padre en estos lugares:\n"
"\n"
"  - En línea, directamente después de `mod vegetables`, dentro de llaves en lugar \n"
"  del punto y coma.\n"
"\n"
"    ```rust\n"
"    // src/garden.cairo file\n"
"    mod vegetables {\n"
"        // code defining the vegetables submodule goes here\n"
"    }\n"
"    ```\n"
"\n"
"  - En el archivo _src/garden/vegetables.cairo_\n"
"\n"
"- **Rutas a código en módulos**: Una vez que un módulo forma parte de su paquete, "
"puede \n"
"  hacer referencia al código de ese módulo desde cualquier otro lugar en ese mismo "
"paquete, utilizando la ruta \n"
"  al código. Por ejemplo, un tipo `Asparagus` en el módulo de vegetales del jardín "
"se encontraría en \n"
"  `backyard::garden::vegetables::Asparagus`.\n"
"- **La palabra clave `use`**: Dentro de un alcance, la palabra clave `use` crea "
"atajos a \n"
"  elementos para reducir la repetición de rutas largas. En cualquier alcance que "
"pueda hacer \n"
"  referencia a `backyard::garden::vegetables::Asparagus`, puede crear un atajo "
"con \n"
"  `use backyard::garden::vegetables::Asparagus;` y a partir de entonces solo "
"necesita \n"
"  escribir `Asparagus` para usar ese tipo en el alcance."

#: src/ch06-02-defining-modules-to-control-scope.md:62
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The\n"
"crate’s directory, also named `backyard`, contains these files and directories:"
msgstr ""
"Aquí creamos un paquete llamado `backyard` que ilustra estas reglas. El \n"
"directorio del paquete, también llamado `backyard`, contiene estos archivos y "
"directorios:"

#: src/ch06-02-defining-modules-to-control-scope.md:65
msgid ""
"```text\n"
"backyard/\n"
"├── Scarb.toml\n"
"├── cairo_project.toml\n"
"└── src\n"
"    ├── garden\n"
"    │   └── vegetables.cairo\n"
"    ├── garden.cairo\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```text\n"
"backyard/\n"
"├── Scarb.toml\n"
"├── cairo_project.toml\n"
"└── src\n"
"    ├── garden\n"
"    │   └── vegetables.cairo\n"
"    ├── garden.cairo\n"
"    └── lib.cairo\n"
"```"

#: src/ch06-02-defining-modules-to-control-scope.md:76
msgid ""
"> Note: You will notice here a `cairo_project.toml` file.\n"
"> This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed "
"by Scarb),\n"
"> which is required to run the `cairo-run .` command to run the code of the crate.\n"
"> It is required until Scarb implements this feature. The content of the file is:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> backyard = \"src\"\n"
"> ```\n"
">\n"
"> and indicates that the crate named \"backyard\" is located in the `src` directory."
msgstr ""
"> Nota: Aquí se observa un archivo `cairo_project.toml`.\n"
"> Este es el archivo de configuración para proyectos \"vanilla\" de Cairo (es "
"decir, no \n"
"> gestionados por Scarb), que se requiere para ejecutar el comando `cairo-run .` "
"y \n"
"> ejecutar el código del crate.\n"
"> Es necesario hasta que Scarb implemente esta función. El contenido del archivo "
"es:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> backyard = \"src\"\n"
"> ```\n"
">\n"
"> y indica que la caja llamada \"backyard\" se encuentra en el directorio `src`."

#: src/ch06-02-defining-modules-to-control-scope.md:88
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "El archivo raíz de la caja en este caso es _src/lib.cairo_, y contiene:"

#: src/ch06-02-defining-modules-to-control-scope.md:92
msgid ""
"```rust\n"
"use garden::vegetables::Asparagus;\n"
"\n"
"mod garden;\n"
"\n"
"fn main(){\n"
"    let Asparagus = Asparagus{};\n"
"}\n"
"\n"
"\n"
"```"
msgstr "El archivo raíz de la caja en este caso es _src/lib.cairo_, y contiene"

#: src/ch06-02-defining-modules-to-control-scope.md:104
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in _src/"
"garden.cairo_, which is:"
msgstr ""
"La línea `mod garden;` le indica al compilador que incluya el código que encuentra "
"en _src/garden.cairo_, que es:"

#: src/ch06-02-defining-modules-to-control-scope.md:106
msgid "<span class=\"filename\">Filename: src/garden.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/garden.cairo</span>"

#: src/ch06-02-defining-modules-to-control-scope.md:108
msgid ""
"```rust\n"
"mod vegetables;\n"
"```"
msgstr ""
"```rust\n"
"mod vegetables;\n"
"```"

#: src/ch06-02-defining-modules-to-control-scope.md:112
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is\n"
"included too. That code is:"
msgstr ""
"Aquí, `mod vegetables;` significa que el código en _src/garden/vegetables.cairo_ "
"también está incluido. Ese código es:"

#: src/ch06-02-defining-modules-to-control-scope.md:115
msgid ""
"```rust\n"
"#[derive(Copy,Drop)]\n"
"struct Asparagus{}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy,Drop)]\n"
"struct Asparagus{}\n"
"```"

#: src/ch06-02-defining-modules-to-control-scope.md:120
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us use bring the `Asparagus` "
"type into scope,\n"
"so we can use it in the `main` function."
msgstr ""
"La línea `use garden::vegetables::Asparagus;` nos permite traer el tipo `Asparagus` "
"al ámbito de alcance, \n"
"para que podamos usarlo en la función `main`."

#: src/ch06-02-defining-modules-to-control-scope.md:123
msgid "Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""
"¡Ahora vamos a entrar en los detalles de estas reglas y demostrarlas en acción!"

#: src/ch06-02-defining-modules-to-control-scope.md:125
msgid "### Grouping Related Code in Modules"
msgstr "### Agrupando el Código Relacionado en Módulos"

#: src/ch06-02-defining-modules-to-control-scope.md:127
msgid ""
"_Modules_ let us organize code within a crate for readability and easy reuse.\n"
"As an example, let’s write a library crate that provides the functionality of a\n"
"restaurant. We’ll define the signatures of functions but leave their bodies\n"
"empty to concentrate on the organization of the code, rather than the\n"
"implementation of a restaurant."
msgstr ""
"_Los módulos_ nos permiten organizar el código dentro de un paquete para hacerlo "
"más legible y fácil de reutilizar. \n"
"Como ejemplo, escribiremos un paquete de biblioteca que proporcione la "
"funcionalidad de un \n"
"restaurante. Definiremos las firmas de las funciones pero dejaremos sus cuerpos \n"
"vacíos para concentrarnos en la organización del código, en lugar de \n"
"en la implementación de un restaurante."

#: src/ch06-02-defining-modules-to-control-scope.md:133
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as\n"
"_front of house_ and others as _back of house_. Front of house is where\n"
"customers are; this encompasses where the hosts seat customers, servers take\n"
"orders and payment, and bartenders make drinks. Back of house is where the\n"
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do\n"
"administrative work."
msgstr ""
"En la industria de la restauración, algunas partes de un restaurante se denominan \n"
"_front of house_ (delante de la casa) y otras como _back of house_. Front of house "
"es donde \n"
"están los clientes; esto abarca desde donde los anfitriones sientan a los clientes, "
"los servidores toman \n"
"órdenes y pagos, y los barman hacen bebidas. Back of house es donde los \n"
"chefs y cocineros trabajan en la cocina, los lavaplatos limpian y los gerentes "
"hacen\n"
" trabajo administrativo."

#: src/ch06-02-defining-modules-to-control-scope.md:140
msgid ""
"To structure our crate in this way, we can organize its functions into nested\n"
"modules. Create a new package named `restaurant` by running `scarb new restaurant`; "
"then enter the code in Listing 6-1 into _src/lib.cairo_ to\n"
"define some modules and function signatures. Here’s the front of house section:"
msgstr ""
"Para estructurar nuestro paquete de esta manera, podemos organizar sus funciones en "
"módulos \n"
"anidados. Cree un nuevo paquete llamado `restaurant` ejecutando el comando `scarb "
"new restaurant`; luego ingrese el código en el Listado 6-1 en _src/lib.cairo_ para "
"definir algunos módulos y firmas de funciones. Aquí está la sección de front of "
"house:"

#: src/ch06-02-defining-modules-to-control-scope.md:146
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"```"

#: src/ch06-02-defining-modules-to-control-scope.md:164
msgid ""
"<span class=\"caption\">Listing 6-1: A `front_of_house` module containing other\n"
"modules that then contain functions</span>"
msgstr ""
"<span class=\"caption\">Listado 6-1: Un módulo `front_of_house` que contiene "
"otros \n"
"módulos que a su vez contienen funciones</span>"

#: src/ch06-02-defining-modules-to-control-scope.md:167
msgid ""
"We define a module with the `mod` keyword followed by the name of the module\n"
"(in this case, `front_of_house`). The body of the module then goes inside curly\n"
"brackets. Inside modules, we can place other modules, as in this case with the\n"
"modules `hosting` and `serving`. Modules can also hold definitions for other\n"
"items, such as structs, enums, constants, traits, and—as in Listing\n"
"6-1—functions."
msgstr ""
"Definimos un módulo con la palabra clave `mod` seguida del nombre del módulo \n"
"(en este caso, `front_of_house`). El cuerpo del módulo va entre \n"
"llaves. Dentro de los módulos, podemos colocar otros módulos, como en este caso con "
"los \n"
"módulos `hosting` y `serving`. Los módulos también pueden contener definiciones de "
"otros\n"
" elementos, como structs, enums, constantes, traits y, como en el Listado \n"
"6-1, funciones."

#: src/ch06-02-defining-modules-to-control-scope.md:174
msgid ""
"By using modules, we can group related definitions together and name why\n"
"they’re related. Programmers using this code can navigate the code based on the\n"
"groups rather than having to read through all the definitions, making it easier\n"
"to find the definitions relevant to them. Programmers adding new functionality\n"
"to this code would know where to place the code to keep the program organized."
msgstr ""
"Al utilizar módulos, podemos agrupar las definiciones relacionadas y darles un "
"nombre que \n"
"indique por qué están relacionadas. Los programadores que usan este código pueden "
"navegar por el código en función de los \n"
"grupos en lugar de tener que leer todas las definiciones, lo que hace que sea más "
"fácil \n"
"encontrar las definiciones relevantes para ellos. Los programadores que agregan "
"nueva funcionalidad \n"
"a este código sabrían dónde colocar el código para mantener el programa organizado."

#: src/ch06-02-defining-modules-to-control-scope.md:180
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate\n"
"root. The reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure,\n"
"known as the _module tree_."
msgstr ""
"Anteriormente, mencionamos que _src/lib.cairo_ se llama raíz de la \n"
"caja. La razón de este nombre es que el contenido de este archivo forma un módulo "
"con el nombre de la caja en la raíz de la estructura de módulos de la caja, "
"conocido como el _árbol de módulos_."

#: src/ch06-02-defining-modules-to-control-scope.md:184
msgid "Listing 6-2 shows the module tree for the structure in Listing 6-1."
msgstr ""
"El Listado 6-2 muestra el árbol de módulos para la estructura en el Listado 6-1."

#: src/ch06-02-defining-modules-to-control-scope.md:186
msgid ""
"```text\n"
"restaurant\n"
" └── front_of_house\n"
"     ├── hosting\n"
"     │   ├── add_to_waitlist\n"
"     │   └── seat_at_table\n"
"     └── serving\n"
"         ├── take_order\n"
"         ├── serve_order\n"
"         └── take_payment\n"
"```"
msgstr ""
"```text\n"
"restaurant\n"
" └── front_of_house\n"
"     ├── hosting\n"
"     │   ├── add_to_waitlist\n"
"     │   └── seat_at_table\n"
"     └── serving\n"
"         ├── take_order\n"
"         ├── serve_order\n"
"         └── take_payment\n"
"```"

#: src/ch06-02-defining-modules-to-control-scope.md:198
msgid ""
"<span class=\"caption\">Listing 6-2: The module tree for the code in Listing\n"
"6-1</span>"
msgstr ""
"<span class=\"caption\">Listing 6-2: El árbol de módulos para el código en el "
"Listado\n"
"6-1</span>"

#: src/ch06-02-defining-modules-to-control-scope.md:201
msgid ""
"This tree shows how some of the modules nest inside one another; for example,\n"
"`hosting` nests inside `front_of_house`. The tree also shows that some modules\n"
"are _siblings_ to each other, meaning they’re defined in the same module;\n"
"`hosting` and `serving` are siblings defined within `front_of_house`. If module\n"
"A is contained inside module B, we say that module A is the _child_ of module B\n"
"and that module B is the _parent_ of module A. Notice that the entire module\n"
"tree is rooted under the explicit name of the crate `restaurant`."
msgstr ""
"Este árbol muestra cómo algunos módulos se anidan dentro de otros; por ejemplo,\n"
"`hosting` se anida dentro de `front_of_house`. El árbol también muestra que algunos "
"módulos\n"
"son _hermanos_ entre sí, lo que significa que están definidos en el mismo módulo;\n"
"`hosting` y `serving` son hermanos definidos dentro de `front_of_house`. Si el "
"módulo\n"
"A está contenido dentro del módulo B, decimos que el módulo A es el _hijo_ del "
"módulo B\n"
"y que el módulo B es el _padre_ del módulo A. Observa que todo el árbol de "
"módulos \n"
"está enraizado en el nombre explícito del paquete `restaurant`."

#: src/ch06-02-defining-modules-to-control-scope.md:209
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your\n"
"computer; this is a very apt comparison! Just like directories in a filesystem,\n"
"you use modules to organize your code. And just like files in a directory, we\n"
"need a way to find our modules."
msgstr ""
"El árbol de módulos podría recordarte al árbol de directorios del sistema de \n"
"archivos en tu computadora; ¡esta es una comparación muy adecuada! Al igual que los "
"directorios \n"
"en un sistema de archivos, utilizamos los módulos para organizar nuestro código. Y "
"al igual que los archivos en un directorio, necesitamos\n"
" una manera de encontrar nuestros módulos."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "## Paths for Referring to an Item in the Module Tree"
msgstr "## Caminos para hacer referencia a un elemento en el árbol de módulos"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the same way "
"we use a path when navigating a filesystem. To call a function, we need to know its "
"path."
msgstr ""
"Para indicarle a Cairo dónde encontrar un elemento en el árbol de módulos, usamos "
"un camino de la misma forma que usamos una ruta al navegar por un sistema de "
"archivos. Para llamar a una función, necesitamos conocer su camino."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Un camino puede tomar dos formas:"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"- An _absolute path_ is the full path starting from a crate root. The absolute path "
"begins with the crate name.\n"
"- A _relative path_ starts from the current module.\n"
"\n"
"  Both absolute and relative paths are followed by one or more identifiers\n"
"  separated by double colons (`::`)."
msgstr ""
"- Un _camino absoluto_ es la ruta completa que comienza desde la raíz del crate. El "
"camino absoluto comienza con el nombre del crate.\n"
"- Un _camino relativo_ comienza desde el módulo actual.\n"
"\n"
"  Tanto los caminos absolutos como los relativos son seguidos por uno o más "
"identificadores \n"
"  separados por dos puntos dobles (`::`)."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 6-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` in which "
"we have a module named `front_of_house` that contains a module named `hosting`. The "
"`hosting` module contains a function named `add_to_waitlist`. We want to call the "
"`add_to_waitlist` function from the `eat_at_restaurant` function. We need to tell "
"Cairo the path to the `add_to_waitlist` function so it can find it."
msgstr ""
"Para ilustrar esta noción, tomemos de nuevo nuestro ejemplo del restaurante que "
"usamos en el último capítulo. Tenemos un crate llamado `restaurant` en el cual "
"tenemos un módulo llamado `front_of_house` que contiene un módulo llamado "
"`hosting`. El módulo `hosting` contiene una función llamada `add_to_waitlist`. "
"Queremos llamar a la función `add_to_waitlist` desde la función "
"`eat_at_restaurant`. Necesitamos decirle a Cairo el camino hacia la función "
"`add_to_waitlist` para que pueda encontrarla."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:17
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"\n"
"        fn seat_at_table() {}\n"
"    }\n"
"\n"
"    mod serving {\n"
"        fn take_order() {}\n"
"\n"
"        fn serve_order() {}\n"
"\n"
"        fn take_payment() {}\n"
"    }\n"
"}\n"
"\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    // Absolute path\n"
"    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"\n"
"    // Relative path\n"
"    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles\n"
"}\n"
"```"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"<span class=\"caption\">Listing 6-3: Calling the `add_to_waitlist` function using "
"absolute and relative paths</span>"
msgstr ""
"<span class=\"caption\">Lista 6-3: Llamada a la función `add_to_waitlist` "
"utilizando rutas absolutas y relativas</span>"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,\n"
"we use an absolute path. The `add_to_waitlist` function is defined in the same\n"
"crate as `eat_at_restaurant`. In Cairo, absolute paths start from the crate root, "
"which you need to refer to by using the crate name."
msgstr ""
"La primera vez que llamamos a la función `add_to_waitlist` en "
"`eat_at_restaurant`, \n"
"usamos una ruta absoluta. La función `add_to_waitlist` está definida en la misma \n"
"caja que `eat_at_restaurant`. En Cairo, las rutas absolutas comienzan desde la raíz "
"de la caja, a la cual se refiere usando el nombre de la caja."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path starts "
"with `front_of_house`, the name of the module\n"
"defined at the same level of the module tree as `eat_at_restaurant`. Here the\n"
"filesystem equivalent would be using the path\n"
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name means\n"
"that the path is relative to the current module."
msgstr ""
"La segunda vez que llamamos a `add_to_waitlist`, usamos una ruta relativa. La ruta "
"comienza con `front_of_house`, el nombre del módulo \n"
"definido en el mismo nivel del árbol de módulos que `eat_at_restaurant`. Aquí, el \n"
"equivalente en el sistema de archivos sería usar la ruta \n"
"`./front_of_house/hosting/add_to_waitlist`. Comenzar con un nombre de módulo "
"significa \n"
"que la ruta es relativa al módulo actual."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "### Starting Relative Paths with `super`"
msgstr "### Comenzando Rutas Relativas con `super`"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make\n"
"based on your project, and depends on whether you’re more likely to move item\n"
"definition code separately from or together with the code that uses the item."
msgstr ""
"Elegir si usar o no `super` es una decisión que tomarás \n"
"basada en tu proyecto y dependerá de si es más probable que muevas el código de \n"
"definición de elementos por separado o junto con el código que usa el elemento."

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:64
msgid ""
"```rust\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn deliver_order() {}\n"
"\n"
"mod back_of_house {\n"
"    fn fix_incorrect_order() {\n"
"        cook_order();\n"
"        super::deliver_order();\n"
"    }\n"
"\n"
"    fn cook_order() {}\n"
"}\n"
"```"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid ""
"<span class=\"caption\">Listing 6-4: Calling a function using a relative path "
"starting with super</span>"
msgstr ""
"<span class=\"caption\">Lista 6-4: Llamada a una función utilizando una ruta "
"relativa que empieza por super</span>"

#: src/ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using `super`, "
"which wasn't the case previously."
msgstr ""
"Aquí se puede ver directamente que se accede fácilmente a un módulo padre usando "
"`super`, lo que no era el caso anteriormente."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "# Bringing Paths into Scope with the `use` Keyword"
msgstr "# Introducir Rutas con la Palabra Clave `use"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can create a "
"shortcut to a path with the `use` keyword once, and then use the shorter name "
"everywhere else in the scope."
msgstr ""
"Tener que escribir las rutas para llamar a las funciones puede resultar incómodo y "
"repetitivo. Afortunadamente, hay una manera de simplificar este proceso: podemos "
"crear un acceso directo a una ruta con la palabra clave `use` una vez, y luego "
"utilizar el nombre más corto en todas partes en el ámbito."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 6-5, we bring the `restaurant::front_of_house::hosting` module into the\n"
"scope of the `eat_at_restaurant` function so we only have to specify\n"
"`hosting::add_to_waitlist` to call the `add_to_waitlist` function in\n"
"`eat_at_restaurant`."
msgstr ""
"En el Listado 6-5, incluimos el módulo `restaurant::front_of_house::hosting` en el "
"ámbito de la función\n"
"de la función `eat_at_restaurant` para que sólo tengamos que especificar\n"
"`hosting::add_to_waitlist` para llamar a la función `add_to_waitlist` de\n"
"en `eat_at_restaurant`."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:12
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist(); // ✅ Shorter path\n"
"}\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:26
msgid ""
"<span class=\"caption\">Listing 6-5: Bringing a module into scope with\n"
"`use`</span>"
msgstr ""
"<span class=\"caption\">Listado 6-5: Introducir un módulo en el ámbito con\n"
"`use`</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in the "
"filesystem. By adding `use restaurant::front_of_house::hosting` in the crate root, "
"hosting is now a valid name in that scope, just as though the `hosting` module had "
"been defined in the crate root."
msgstr ""
"Añadir use y una ruta en un ámbito es similar a crear un enlace simbólico en el "
"sistema de ficheros. Al añadir `use restaurant::front_of_house::hosting` en la raíz "
"de crate, hosting es ahora un nombre válido en ese ámbito, como si el módulo "
"`hosting` se hubiera definido en la raíz de un crate."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:31
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which the "
"`use` occurs. Listing 6-6 moves the `eat_at_restaurant` function into a new\n"
"child module named `customer`, which is then a different scope than the `use`\n"
"statement, so the function body won’t compile:"
msgstr ""
"Ten en cuenta que `use` sólo crea el acceso directo para el ámbito concreto en el "
"que se produce el `use`. El listado 6-6 mueve la función `eat_at_restaurant` a un "
"nuevo módulo hijo llamado\n"
"módulo hijo llamado `customer`, que es un ámbito diferente al de la sentencia `use\n"
"por lo que el cuerpo de la función no compilará:"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:37
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"mod customer {\n"
"    fn eat_at_restaurant() {\n"
"        hosting::add_to_waitlist();\n"
"    }\n"
"}\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:53
msgid ""
"<span class=\"caption\">Listing 6-6: A `use` statement only applies in the scope\n"
"it’s in</span>"
msgstr ""
"<span class=\"caption\">Listado 6-6: Una sentencia `use` sólo se aplica en el "
"ámbito\n"
"en el que se encuentra</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid ""
"The compiler error shows that the shortcut no longer applies within the\n"
"`customer` module:"
msgstr ""
"El error del compilador muestra que el acceso directo ya no se aplica dentro del "
"módulo\n"
"módulo `customer`:"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"```console\n"
"❯ scarb build\n"
"error: Identifier not found.\n"
" --> lib.cairo:11:9\n"
"        hosting::add_to_waitlist();\n"
"        ^*****^\n"
"```"
msgstr ""
"```console\n"
"❯ scarb build\n"
"error: Identifier not found.\n"
" --> lib.cairo:11:9\n"
"        hosting::add_to_waitlist();\n"
"        ^*****^\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:67
msgid "## Creating Idiomatic `use` Paths"
msgstr "## Crear Rutas idiomáticas `use`"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:69
msgid ""
"In Listing 6-5, you might have wondered why we specified `use\n"
"restaurant::front_of_house::hosting` and then called `hosting::add_to_waitlist` in\n"
"`eat_at_restaurant` rather than specifying the `use` path all the way out to\n"
"the `add_to_waitlist` function to achieve the same result, as in Listing 6-7."
msgstr ""
"En el Listado 6-5, puede que te hayas preguntado por qué especificamos `use\n"
"restaurant::front_of_house::hosting` y luego llamamos a `hosting::add_to_waitlist` "
"en\n"
"en `eat_at_restaurant` en lugar de especificar la ruta `use\n"
"la función `add_to_waitlist` para conseguir el mismo resultado, como en el Listado "
"6-7."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:76
msgid ""
"```rust\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house {\n"
"    pub mod hosting {\n"
"        pub fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting::add_to_waitlist;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    add_to_waitlist();\n"
"}\n"
"\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:91
msgid ""
"<span class=\"caption\">Listing 6-7: Bringing the `add_to_waitlist` function\n"
"into scope with `use`, which is unidiomatic</span>"
msgstr ""
"<span class=\"caption\">Listado 6-7: Introduciendo la función `add_to_waitlist\n"
"con `use`, que es poco idiomático</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:94
msgid ""
"Although both Listing 6-5 and 6-7 accomplish the same task, Listing 6-5 is\n"
"the idiomatic way to bring a function into scope with `use`. Bringing the\n"
"function’s parent module into scope with `use` means we have to specify the\n"
"parent module when calling the function. Specifying the parent module when\n"
"calling the function makes it clear that the function isn’t locally defined\n"
"while still minimizing repetition of the full path. The code in Listing 6-7 is\n"
"unclear as to where `add_to_waitlist` is defined."
msgstr ""
"Aunque tanto el Listado 6-5 como el 6-7 realizan la misma tarea, el Listado 6-5 es\n"
"la forma idiomática de traer una función al ámbito con `use`. Traer el\n"
"módulo padre de la función al ámbito con `use` significa que tenemos que "
"especificar el\n"
"módulo padre al llamar a la función. Especificar el módulo padre al\n"
"al llamar a la función deja claro que la función no está definida localmente\n"
"a la vez que minimiza la repetición de la ruta completa. El código del Listado 6-7 "
"es\n"
"no está claro dónde está definido `add_to_waitlist`."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:102
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items with "
"`use`,\n"
"it’s idiomatic to specify the full path. Listing 6-8 shows the idiomatic way\n"
"to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""
"Por otro lado, cuando se introducen structs, enums, traits y otros elementos con "
"`use`,\n"
"es idiomático especificar la ruta completa. El listado 6-8 muestra la forma "
"idiomática\n"
"de traer el trait `ArrayTrait` de la librería core al ámbito."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:106
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"fn main() {\n"
"    let mut arr = ArrayTrait::new();\n"
"    arr.append(1);\n"
"}\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid ""
"<span class=\"caption\">Listing 6-8: Bringing `ArrayTrait` into scope in an\n"
"idiomatic way</span>"
msgstr ""
"<span class=\"caption\">Listado 6-8: Introducir `ArrayTrait` en el ámbito de forma\n"
"forma idiomática</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that has\n"
"emerged in the Rust community, and folks have gotten used to reading and writing "
"Rust code this way.\n"
"As Cairo shares many idioms with Rust, we follow this convention as well."
msgstr ""
"No hay ninguna razón de peso detrás de este modismo: es sólo la convención que ha \n"
"surgido en la comunidad Rust y la gente se ha acostumbrado a leer y escribir código "
"Rust de esta manera.\n"
"Como Cairo comparte muchos modismos con Rust, nosotros también seguimos esta "
"convención."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same name\n"
"into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"La excepción a este modismo es si estamos trayendo dos elementos con el mismo "
"nombre\n"
"con sentencias `use`, porque Cairo no lo permite."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "### Providing New Names with the `as` Keyword"
msgstr "### Proporcionar nuevos nombres con la Palabra Clave `as`"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same name\n"
"into the same scope with `use`: after the path, we can specify `as` and a new\n"
"local name, or _alias_, for the type. Listing 6-9 shows how you can rename an "
"import with `as`:"
msgstr ""
"Hay otra solución al problema de meter dos tipos del mismo nombre\n"
"en el mismo ámbito con `use`: después de la ruta, podemos especificar `as` y un "
"nuevo\n"
"nombre local, o _alias_, para el tipo. El listado 6-9 muestra cómo puedes renombrar "
"una importación con `as`:"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:133
msgid ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main(){\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait as Arr;\n"
"\n"
"fn main(){\n"
"    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr\n"
"    arr.append(1);\n"
"}\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"<span class=\"caption\">Listing 6-9: Renaming a trait when it’s brought into\n"
"scope with the `as` keyword</span>"
msgstr ""
"<span class=\"caption\">Listado 6-9: Renombrar un trait cuando es traído a\n"
"scope con la palabra clave `as`</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now access "
"the trait's methods with the `Arr` identifier."
msgstr ""
"En este caso, hemos introducido `ArrayTrait` en el ámbito con el alias `Arr`. Ahora "
"podemos acceder a los métodos del rasgo con el identificador `Arr`."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "## Re-exporting Names in Module Files"
msgstr "## Re-exportación de Nombres en Archivos de Módulo"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When we bring a name into scope with the `use` keyword, the name available in\n"
"the new scope can be imported as if it had been defined in that code’s scope.\n"
"This technique is called _re-exporting_ because we’re bringing an item into scope,\n"
"but also making that item available for others to bring into their scope."
msgstr ""
"Cuando traemos un nombre al ámbito con la palabra clave `use`, el nombre disponible "
"en\n"
"el nuevo ámbito puede ser importado como si hubiera sido definido en el ámbito de "
"ese código.\n"
"Esta técnica se llama _re-exporting_ porque estamos trayendo un elemento al "
"ámbito,\n"
"pero también haciendo que ese elemento esté disponible para que otros lo "
"introduzcan en su ámbito."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the restaurant "
"example:"
msgstr ""
"Por ejemplo, reexportemos la función `add_to_waitlist` del ejemplo del restaurante:"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:158
msgid ""
"```rs\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"mod front_of_house {\n"
"    mod hosting {\n"
"        fn add_to_waitlist() {}\n"
"    }\n"
"}\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:172
msgid ""
"<span class=\"caption\">Listing 6-10: Making a name available for any code to use\n"
"from a new scope with `pub use`</span>"
msgstr ""
"<span class=\"caption\">Listado 6-10: Poner un nombre a disposición de cualquier "
"código\n"
"desde un nuevo ámbito con `pub use`.</span>"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:175
msgid ""
"Before this change, external code would have to call the `add_to_waitlist`\n"
"function by using the path\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this `use`\n"
"has re-exported the `hosting` module from the root module, external code\n"
"can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"Antes de este cambio, el código externo tenía que llamar a la función "
"`add_to_waitlist`\n"
"utilizando la ruta\n"
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Ahora que este `use`\n"
"ha reexportado el módulo `hosting` desde el módulo raíz, el código externo\n"
"puede usar la ruta `restaurant::hosting::add_to_waitlist()` en su lugar."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid ""
"Re-exporting is useful when the internal structure of your code is different\n"
"from how programmers calling your code would think about the domain. For\n"
"example, in this restaurant metaphor, the people running the restaurant think\n"
"about “front of house” and “back of house.” But customers visiting a restaurant\n"
"probably won’t think about the parts of the restaurant in those terms. With\n"
"`use`, we can write our code with one structure but expose a different\n"
"structure. Doing so makes our library well organized for programmers working on\n"
"the library and programmers calling the library."
msgstr ""
"La Re-exportación es útil cuando la estructura interna de su código es diferente\n"
"de cómo los programadores que llaman a su código pensarían sobre el dominio. En\n"
"ejemplo, en esta metáfora del restaurante, las personas que lo dirigen piensan\n"
"piensan en \"la parte delantera\" y \"la parte trasera\". Pero los clientes que "
"visitan un restaurante\n"
"probablemente no piensen en las partes del restaurante en esos términos. Con\n"
"`use`, podemos escribir nuestro código con una estructura pero exponer una "
"estructura diferente.\n"
"Esto hace que nuestra biblioteca esté bien organizada para los programadores que "
"trabajan \n"
"en ella y para los programadores que la llaman."

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:190
msgid "## Using External Packages in Cairo with Scarb"
msgstr "## Usando Paquetes Externos en Cairo con Scarb"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:192
msgid ""
"You might need to use external packages to leverage the functionality provided by "
"the community. To use an external package in your project with Scarb, follow these "
"steps:"
msgstr ""
"Puede que necesite utilizar paquetes externos para aprovechar la funcionalidad "
"proporcionada por la comunidad. Para utilizar un paquete externo en su proyecto con "
"Scarb, siga estos pasos:"

#: src/ch06-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid ""
"> The dependencies system is still a work in progress. You can check the official "
"[documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies)."
msgstr ""
"> El sistema de dependencias es todavía un trabajo en curso. Puede consultar la "
"[documentación oficial](https://docs.swmansion.com/scarb/docs/guides/dependencies)."

#: src/ch06-05-separating-modules-into-different-files.md:1
msgid "## Separating Modules into Different Files"
msgstr "## Separar Módulos en Archivos Diferentes"

#: src/ch06-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one file.\n"
"When modules get large, you might want to move their definitions to a separate\n"
"file to make the code easier to navigate."
msgstr ""
"Hasta ahora, todos los ejemplos de este capítulo definían varios módulos en un solo "
"archivo.\n"
"Cuando los módulos se hacen grandes, es posible que desee mover sus definiciones a "
"una separada\n"
"para facilitar la navegación por el código."

#: src/ch06-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 6-10 that had multiple\n"
"restaurant modules. We’ll extract modules into files instead of having all the\n"
"modules defined in the crate root file. In this case, the crate root file is\n"
"_src/lib.cairo_."
msgstr ""
"Por ejemplo, partamos del código del Listado 6-10 que tenía múltiples\n"
"módulos de restaurante. Extraeremos los módulos en archivos en lugar de tener todos "
"los\n"
"módulos definidos en el archivo raíz del crate. En este caso, el archivo raíz es\n"
"_src/lib.cairo_."

#: src/ch06-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the\n"
"code inside the curly brackets for the `front_of_house` module, leaving only\n"
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the code\n"
"shown in Listing 6-11. Note that this won’t compile until we create the\n"
"_src/front_of_house.cairo_ file in Listing 6-12."
msgstr ""
"Primero, extraeremos el módulo `front_of_house` a su propio archivo. Elimina el "
"código\n"
"dentro de las llaves del módulo `front_of_house`, dejando sólo\n"
"la declaración `mod front_of_house;`, de forma que _src/lib.cairo_ contenga el "
"código\n"
"mostrado en el Listado 6-11. Ten en cuenta que esto no compilará hasta que creemos "
"el módulo\n"
"_src/front_of_house.cairo_ del Listado 6-12."

#: src/ch06-05-separating-modules-into-different-files.md:20
msgid ""
"```rust\n"
"mod front_of_house;\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod front_of_house;\n"
"\n"
"use restaurant::front_of_house::hosting;\n"
"\n"
"pub fn eat_at_restaurant() {\n"
"    hosting::add_to_waitlist();\n"
"}\n"
"```"

#: src/ch06-05-separating-modules-into-different-files.md:30
msgid ""
"<span class=\"caption\">Listing 6-11: Declaring the `front_of_house` module whose\n"
"body will be in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"caption\">Listado 6-11: Declarando el módulo `front_of_house` cuyo\n"
"cuerpo estará en _src/front_of_house.cairo_</span>"

#: src/ch06-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named\n"
"_src/front_of_house.cairo_, as shown in Listing 6-12. The compiler knows to look\n"
"in this file because it came across the module declaration in the crate root\n"
"with the name `front_of_house`."
msgstr ""
"A continuación, coloque el código que estaba entre llaves en un nuevo archivo "
"llamado\n"
"_src/front_of_house.cairo_, como se muestra en el Listado 6-12. El compilador sabe "
"que debe buscar\n"
"en este archivo porque se encontró con la declaración del módulo en la raíz del "
"crate\n"
"con el nombre `front_of_house`."

#: src/ch06-05-separating-modules-into-different-files.md:38
#: src/ch06-05-separating-modules-into-different-files.md:66
msgid "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/front_of_house.cairo</span>"

#: src/ch06-05-separating-modules-into-different-files.md:40
msgid ""
"```rust,\n"
"mod hosting {\n"
"    fn add_to_waitlist() {}\n"
"}\n"
"```"
msgstr ""
"```rust,\n"
"mod hosting {\n"
"    fn add_to_waitlist() {}\n"
"}\n"
"```"

#: src/ch06-05-separating-modules-into-different-files.md:46
msgid ""
"<span class=\"caption\">Listing 6-12: Definitions inside the `front_of_house`\n"
"module in _src/front_of_house.cairo_</span>"
msgstr ""
"<span class=\"caption\">Listado 6-12: Definiciones dentro del módulo "
"`front_of_house`\n"
"en _src/front_of_house.cairo_</span>"

#: src/ch06-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in your\n"
"module tree. Once the compiler knows the file is part of the project (and knows\n"
"where in the module tree the code resides because of where you’ve put the `mod`\n"
"statement), other files in your project should refer to the loaded file’s code\n"
"using a path to where it was declared, as covered in the [“Paths for Referring\n"
"to an Item in the Module Tree”][paths]<!-- ignore --> section. In other words,\n"
"`mod` is _not_ an “include” operation that you may have seen in other\n"
"programming languages."
msgstr ""
"Tenga en cuenta que sólo es necesario cargar un archivo mediante una declaración "
"`mod` _una vez_ en su\n"
"árbol de módulos. Una vez que el compilador sabe que el archivo es parte del "
"proyecto (y sabe\n"
"donde en el árbol de módulos reside el código debido a donde has puesto la "
"declaración `mod`\n"
"), otros archivos en su proyecto debe hacer referencia al código del archivo "
"cargado\n"
"cargado utilizando una ruta hacia el lugar donde se declaró, como se explica en la "
"sección [\"Rutas para Referirse \n"
"a un elemento en el árbol de módulos\"][rutas]<!-- ignorar --> sección. En otras "
"palabras,\n"
"`mod` no es una operación \"include\" que pueda haber visto en otros \n"
"lenguajes de programación."

#: src/ch06-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a bit\n"
"different because `hosting` is a child module of `front_of_house`, not of the\n"
"root module. We’ll place the file for `hosting` in a new directory that will be\n"
"named for its ancestors in the module tree, in this case _src/front_of_house/_."
msgstr ""
"A continuación, extraeremos el módulo `hosting` a su propio archivo. El proceso es "
"un poco diferente\n"
"porque `hosting` es un módulo hijo de `front_of_house`, no del \n"
"módulo raíz. Colocaremos el archivo para `hosting` en un nuevo directorio que será\n"
"nombre de sus antepasados en el árbol de módulos, en este caso _src/front_of_house/"
"_."

#: src/ch06-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain only "
"the\n"
"declaration of the `hosting` module:"
msgstr ""
"Para empezar a mover `hosting`, cambiamos _src/front_of_house.cairo_ para que "
"contenga sólo la\n"
"declaración del módulo `hosting`:"

#: src/ch06-05-separating-modules-into-different-files.md:68
msgid ""
"```rust\n"
"mod hosting;\n"
"```"
msgstr ""
"```rust\n"
"mod hosting;\n"
"```"

#: src/ch06-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ to\n"
"contain the definitions made in the `hosting` module:"
msgstr ""
"Luego creamos un directorio _src/front_of_house_ y un archivo _hosting.cairo_ para\n"
"contener las definiciones hechas en el módulo `hosting`:"

#: src/ch06-05-separating-modules-into-different-files.md:75
msgid "<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"
msgstr "<span class=\"filename\">Filename: src/front_of_house/hosting.cairo</span>"

#: src/ch06-05-separating-modules-into-different-files.md:77
msgid ""
"```rust\n"
"pub fn add_to_waitlist() {}\n"
"```"
msgstr ""
"```rust\n"
"pub fn add_to_waitlist() {}\n"
"```"

#: src/ch06-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would\n"
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the crate\n"
"root, and not declared as a child of the `front_of_house` module. The\n"
"compiler’s rules for which files to check for which modules’ code means the\n"
"directories and files more closely match the module tree."
msgstr ""
"Si en su lugar ponemos _hosting.cairo_ en el directorio _src_, el compilador\n"
"esperaría que el código _hosting.cairo_ estuviera en un módulo `hosting` declarado "
"en el crate\n"
"y no declarado como hijo del módulo `front_of_house`. Las reglas del compilador de\n"
"reglas del compilador sobre qué archivos comprobar para qué código de los módulos "
"significa que los\n"
"directorios y archivos se ajustan más al árbol de módulos."

#: src/ch06-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree remains\n"
"the same. The function calls in `eat_at_restaurant` will work without any\n"
"modification, even though the definitions live in different files. This\n"
"technique lets you move modules to new files as they grow in size."
msgstr ""
"Hemos movido el código de cada módulo a un archivo separado, y el árbol de módulos "
"sigue siendo\n"
"el mismo. Las llamadas a funciones en `eat_at_restaurant` funcionarán sin ninguna\n"
"aunque las definiciones estén en archivos diferentes. Esta\n"
"técnica le permite mover módulos a nuevos archivos a medida que crecen en tamaño."

#: src/ch06-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in\n"
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what files\n"
"are compiled as part of the crate. The `mod` keyword declares modules, and Cairo\n"
"looks in a file with the same name as the module for the code that goes into\n"
"that module."
msgstr ""
"Tenga en cuenta que la declaración `use restaurant::front_of_house::hosting` en\n"
"_src/lib.cairo_ tampoco ha cambiado, ni `use` tiene ningún impacto sobre qué "
"archivos\n"
"se compilan como parte de la caja. La palabra clave `mod` declara módulos, y Cairo\n"
"busca en un fichero con el mismo nombre que el módulo el código que va en \n"
"ese módulo."

#: src/ch06-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules\n"
"so you can refer to items defined in one module from another module. You can do\n"
"this by specifying absolute or relative paths. These paths can be brought into\n"
"scope with a `use` statement so you can use a shorter path for multiple uses of\n"
"the item in that scope. Module code is public by default."
msgstr ""
"Cairo le permite dividir un paquete en múltiples crates y un crate en módulos\n"
"para que pueda referirse a elementos definidos en un módulo desde otro módulo. "
"Puede hacer esto\n"
"esto especificando rutas absolutas o relativas. Estas rutas pueden ser\n"
"con una sentencia `use` para que pueda utilizar una ruta más corta para múltiples "
"usos\n"
"del elemento en ese ámbito. El código del módulo es público por defecto."

#: src/ch06-05-separating-modules-into-different-files.md:106
msgid ""
"In the next chapter, we’ll look at some collection data structures in the\n"
"standard library that you can use in your neatly organized code."
msgstr ""
"En el próximo capítulo, veremos algunas estructuras de datos de colección en la\n"
"biblioteca estándar que puedes utilizar en tu código bien organizado."

#: src/ch07-00-generic-types-and-traits.md:1
msgid "# Generic Types and Traits"
msgstr "# Tipos Genéricos y Traits"

#: src/ch07-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the duplication of "
"concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete "
"types or other properties. We can express the behaviour of generics or how they "
"relate to other generics without knowing what will be in their place when compiling "
"and running the code."
msgstr ""
"Cada lenguaje de programación tiene herramientas para manejar eficazmente la "
"duplicación de conceptos. En Cairo, una de esas herramientas son los genéricos: "
"sustitutos abstractos de tipos concretos u otras propiedades. Podemos expresar el "
"comportamiento de los genéricos o cómo se relacionan con otros genéricos sin saber "
"qué habrá en su lugar al compilar y ejecutar el código."

#: src/ch07-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part of their "
"definition instead of a concrete types like `u32` or `ContractAddress`."
msgstr ""
"Las funciones, estructuras, enumeraciones y traits pueden incorporar tipos "
"genéricos como parte de su definición en lugar de tipos concretos como `u32` o "
"`ContractAddress`."

#: src/ch07-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that represents "
"multiple types to remove code duplication."
msgstr ""
"Los genéricos nos permiten reemplazar tipos específicos con un marcador de posición "
"que representa múltiples tipos para eliminar la duplicación de código."

#: src/ch07-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a new "
"definition, reducing development time for the programmer, but code duplication at "
"compile level still exists. This may be of importance if you are writing Starknet "
"contracts and using a generic for multiple types which will cause contract size to "
"increment."
msgstr ""
"Para cada tipo concreto que reemplaza a un tipo genérico, el compilador crea una "
"nueva definición, reduciendo el tiempo de desarrollo para el programador, pero la "
"duplicación de código a nivel de compilación todavía existe. Esto puede ser "
"importante si estás escribiendo contratos Starknet y usando un genérico para "
"múltiples tipos que hará que el tamaño del contrato aumente."

#: src/ch07-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You can "
"combine traits with generic types to constrain a generic type to accept only those "
"types that have a particular behavior, as opposed to just any type."
msgstr ""
"Luego aprenderás cómo usar traits para definir comportamientos de manera genérica. "
"Puedes combinar traits con tipos genéricos para restringir un tipo genérico para "
"que acepte solo aquellos tipos que tienen un comportamiento particular, en lugar de "
"cualquier tipo."

#: src/ch07-01-generic-data-types.md:1
msgid "# Generic Data Types"
msgstr "# Tipos de Datos Genéricos"

#: src/ch07-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs and "
"functions, which we can then use with many different concrete data types. In Cairo "
"we can use generics when defining functions, structs, enums, traits, "
"implementations and methods! In this chapter we are going to take a look on how to "
"effectively use generic types with all of them."
msgstr ""
"Usamos genéricos para crear definiciones de declaraciones de elementos, como "
"structs y funciones, que luego podemos usar con muchos tipos de datos concretos "
"diferentes. ¡En Cairo podemos usar genéricos al definir funciones, structs, enums, "
"traits, implementaciones y métodos! En este capítulo vamos a ver cómo usar "
"efectivamente tipos genéricos con todos ellos."

#: src/ch07-01-generic-data-types.md:5
msgid "## Generic Functions"
msgstr "## Funciones Genéricas"

#: src/ch07-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the function "
"signature, where we would usually specify the data types of the parameter and "
"return value. For example, imagine we want to create a function which given two "
"`Array` of items, will return the largest one. If we need to perform this "
"operations for lists of different types, then we would have to redefine the "
"function each time. Luckily we can implement the function once using generics and "
"move on to other tasks."
msgstr ""
"Al definir una función que utiliza genéricos, colocamos los genéricos en la firma "
"de la función, donde normalmente especificaríamos los tipos de datos del parámetro "
"y el valor de retorno. Por ejemplo, imaginemos que queremos crear una función que, "
"dadas dos matrices (`Array`) de elementos, devolverá la más grande. Si necesitamos "
"realizar esta operación para listas de diferentes tipos, tendríamos que redefinir "
"la función cada vez. Afortunadamente, podemos implementar la función una vez usando "
"genéricos y seguir adelante con otras tareas."

#: src/ch07-01-generic-data-types.md:9
msgid ""
"```rust\n"
"// This code does not compile!\n"
"\n"
"use array::ArrayTrait;\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// This code does not compile!\n"
"\n"
"use array::ArrayTrait;\n"
"\n"
"// Specify generic type T between the angulars\n"
"fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut l1 = ArrayTrait::new();\n"
"    let mut l2 = ArrayTrait::new();\n"
"\n"
"    l1.append(1);\n"
"    l1.append(2);\n"
"\n"
"    l2.append(3);\n"
"    l2.append(4);\n"
"    l2.append(5);\n"
"\n"
"    // There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
"    let l3 = largest_list(l1, l2);\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:40
msgid ""
"The `largest_list` function compares two lists of the same type and returns the one "
"with more elements and drops the other. If you compile the previous code, you will "
"notice that it will fail with an error saying that there are no traits defined for "
"droping an array of a generic type. This happens because the compiler has no way to "
"guarantee that an `Array<T>` is droppable when executing the `main` function. In "
"order to drop an array of `T`, the compiler must first know how to drop `T`. This "
"can be fixed by specifiying in the function signature of `largest_list` that `T` "
"must implement the drop trait. The correct function definition of `largest_list` is "
"as follows:"
msgstr ""
"La función `largest_list` compara dos listas del mismo tipo y devuelve aquella con "
"más elementos y elimina la otra. Si se compila el código anterior, se notará que "
"fallará con un error diciendo que no se han definido traits para eliminar un array "
"de un tipo genérico. Esto sucede porque el compilador no tiene forma de garantizar "
"que un `Array<T>` sea eliminable al ejecutar la función `main`. Para eliminar un "
"array de `T`, el compilador primero debe saber cómo eliminar `T`. Esto se puede "
"solucionar especificando en la firma de la función `largest_list` que `T` debe "
"implementar el trait de eliminación. La definición correcta de la función "
"`largest_list` es la siguiente:"

#: src/ch07-01-generic-data-types.md:42
msgid ""
"```rust\n"
"fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n"
"    if l1.len() > l2.len() {\n"
"        l1\n"
"    } else {\n"
"        l2\n"
"    }\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:52
msgid ""
"The new `largest_list` function includes in its definition the requirement that "
"whatever generic type is placed there, it must be droppable. The `main` function "
"remains unchanged, the compiler is smart enough to deduct which concrete type is "
"being used and if it implements the `Drop` trait."
msgstr ""
"La nueva función `largest_list` incluye en su definición el requisito de que "
"cualquier tipo genérico que se coloque allí debe poder eliminarse. La función "
"`main` sigue sin cambios, el compilador es lo suficientemente inteligente como para "
"deducir qué tipo concreto se está utilizando y si implementa el trait `Drop`."

#: src/ch07-01-generic-data-types.md:54
msgid "### Constraints for Generic Types"
msgstr "### Restricciones para Tipos Genéricos"

#: src/ch07-01-generic-data-types.md:56
msgid ""
"When defining generic types, it is useful to have information about them. Knowing "
"which traits a generic type implements allow us to use them more effectively in a "
"functions logic at the cost of constraining the generic types that can be used with "
"the function. We saw an example of this previously by adding the `TDrop` "
"implementation as part of the generic arguments of `largest_list`. While `TDrop` "
"was added to satisfy the compilers requirements, we can also add constraints to "
"benefit our function logic."
msgstr ""
"Al definir tipos genéricos, es útil tener información sobre ellos. Saber qué traits "
"implementa un tipo genérico nos permite usarlos de manera más efectiva en la lógica "
"de una función a costa de limitar los tipos genéricos que se pueden usar con la "
"función. Vimos un ejemplo de esto anteriormente al agregar la implementación de "
"`TDrop` como parte de los argumentos genéricos de `largest_list`. Si bien `TDrop` "
"se agregó para cumplir con los requisitos del compilador, también podemos agregar "
"restricciones para beneficiar nuestra lógica de función."

#: src/ch07-01-generic-data-types.md:58
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, find the "
"smallest element among them. Initially, we know that for an element of type `T` to "
"be comparable, it must implement the `PartialOrd` trait. The resulting function "
"would be:"
msgstr ""
"Imaginemos que queremos, dado una lista de elementos de algún tipo genérico `T`, "
"encontrar el elemento más pequeño entre ellos. Inicialmente, sabemos que para que "
"un elemento de tipo `T` sea comparable, debe implementar el trait `PartialOrd`. La "
"función resultante sería:"

#: src/ch07-01-generic-data-types.md:60
msgid ""
"```rust\n"
"// This code does not compile!\n"
"use array:ArrayTrait;\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0_usize];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1_usize;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len(){\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main()  {\n"
"    let mut list = ArrayTrait::new();\n"
"    list.append(5_u8);\n"
"    list.append(3_u8);\n"
"    list.append(10_u8);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3_u8, 0);\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// This code does not compile!\n"
"use array:ArrayTrait;\n"
"\n"
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {\n"
"    // This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
"    let mut smallest = *list[0_usize];\n"
"\n"
"    // The index we will use to move through the list\n"
"    let mut index = 1_usize;\n"
"\n"
"    // Iterate through the whole list storing the smallest\n"
"    loop {\n"
"        if index >= list.len(){\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"\n"
"fn main()  {\n"
"    let mut list = ArrayTrait::new();\n"
"    list.append(5_u8);\n"
"    list.append(3_u8);\n"
"    list.append(10_u8);\n"
"\n"
"    // We need to specify that we are passing a snapshot of `list` as an argument\n"
"    let s = smallest_element(@list);\n"
"    assert(s == 3_u8, 0);\n"
"\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:99
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes an snapshot of an `Array<T>` as a parameter and returns a "
"copy of the smallest element. Because the parameter is of type `@Array<T>`, we no "
"longer need to drop it at the end of the execution and so we don't require to "
"implement the `Drop` trait for `T` as well. Why it does not compile then?"
msgstr ""
"La función `smallest_element` utiliza un tipo genérico `T` que implementa el trait "
"`PartialOrd`, toma una instantánea de un `Array<T>` como parámetro y devuelve una "
"copia del elemento más pequeño. Debido a que el parámetro es de tipo `@Array<T>`, "
"ya no necesitamos soltarlo al final de la ejecución y por lo tanto no necesitamos "
"implementar el trait `Drop` para `T` también. ¿Por qué entonces no compila?"

#: src/ch07-01-generic-data-types.md:101
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, unless "
"`PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The "
"`*` operation requires a copy from `@T` to`T`, which means that `T` needs to "
"implement the `Copy` trait. After copying an element of type `@T` to `T`, there are "
"now variables with type `T` that need to be dropped, requiring for `T` to implement "
"the `Drop` trait as well. We must then add both `Drop` and `Copy` traits "
"implementation for the function to be correct. After updating the`smallest_element` "
"function the resulting code would be:"
msgstr ""
"Cuando hacemos indexación en `list`, el valor resultante es una instantánea del "
"elemento indexado, a menos que `PartialOrd` esté implementado para `@T` necesitamos "
"deshacer la instantánea del elemento usando `*`. La operación `*` requiere una "
"copia de `@T` a `T`, lo que significa que `T` necesita implementar el trait `Copy`. "
"Después de copiar un elemento de tipo `@T` a `T`, ahora hay variables con tipo `T` "
"que necesitan ser soltadas, lo que requiere que `T` implemente también el trait "
"`Drop`. Debemos entonces agregar la implementación de los traits `Drop` y `Copy` "
"para que la función sea correcta. Después de actualizar la función "
"`smallest_element`, el código resultante sería:"

#: src/ch07-01-generic-data-types.md:103
msgid ""
"```rs\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl "
"TDrop: Drop<T>>(list: @Array<T>) -> T {\n"
"    let mut smallest = *list[0_usize];\n"
"    let mut index = 1_usize;\n"
"    loop {\n"
"        if index >= list.len(){\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl "
"TDrop: Drop<T>>(list: @Array<T>) -> T {\n"
"    let mut smallest = *list[0_usize];\n"
"    let mut index = 1_usize;\n"
"    loop {\n"
"        if index >= list.len(){\n"
"            break smallest;\n"
"        }\n"
"        if *list[index] < smallest {\n"
"            smallest = *list[index];\n"
"        }\n"
"        index = index + 1;\n"
"    }\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:119
msgid "## Structs"
msgstr "## Structs (Estructuras)"

#: src/ch07-01-generic-data-types.md:121
msgid ""
"We can also define structs to use a generic type parameter for one or more fields "
"using the `<>` syntax, similar to function definitions. First we declare the name "
"of the type parameter inside the angle brackets just after the name of the struct. "
"Then we use the generic type in the struct definition where we would otherwise "
"specify concrete data types. The next code example shows the definition `Wallet<T>` "
"which has a `balance` field of type `T`."
msgstr ""
"También podemos definir estructuras que usen un parámetro de tipo genérico para uno "
"o más campos usando la sintaxis `<>`, similar a las definiciones de funciones. "
"Primero declaramos el nombre del parámetro de tipo dentro de los corchetes "
"angulares justo después del nombre de la estructura. Luego usamos el tipo genérico "
"en la definición de la estructura donde de otra manera especificaríamos tipos de "
"datos concretos. El siguiente ejemplo de código muestra la definición de "
"`Wallet<T>` que tiene un campo `balance` de tipo `T`."

#: src/ch07-01-generic-data-types.md:123
msgid ""
"```rust\n"
"// This code does not compile!\n"
"\n"
"#[derive(Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"\n"
"fn main() {\n"
"   let w = Wallet{ balance: 3_u128};\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// This code does not compile!\n"
"\n"
"#[derive(Drop)]\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"\n"
"fn main() {\n"
"   let w = Wallet{ balance: 3_u128};\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:137
msgid ""
"Compiling the above code would error due to the `derive` macro not working well "
"with generics. When using generic types is best to directly write the traits you "
"want to use:"
msgstr ""
"La compilación del código anterior daría un error debido a que la macro `derive` no "
"funciona bien con tipos genéricos. Cuando se usan tipos genéricos, es mejor "
"escribir directamente los traits que se quieren utilizar:"

#: src/ch07-01-generic-data-types.md:139
msgid ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3_u128 };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3_u128 };\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:151
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead "
"define our own `WalletDrop` implementation. Notice that we must define, just like "
"functions, an additional generic type for `WalletDrop` saying that `T` implements "
"the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is "
"droppable as long as `T` is also droppable."
msgstr ""
"Evitamos el uso de la macro `derive` para la implementación de `Drop` de `Wallet` y "
"en su lugar definimos nuestra propia implementación de `WalletDrop`. Nótese que "
"debemos definir, al igual que en las funciones, un tipo genérico adicional para "
"`WalletDrop` diciendo que `T` también implementa el trait `Drop`. Básicamente "
"estamos diciendo que la estructura `Wallet<T>` es dropeable siempre y cuando `T` "
"también lo sea."

#: src/ch07-01-generic-data-types.md:153
msgid ""
"Finally, if we want to add a field to `Wallet` representing its Cairo address and "
"we want that field to be different than `T` but generic as well, we can simply add "
"another generic type between the `<>`:"
msgstr ""
"Finalmente, si queremos agregar un campo a `Wallet` que represente su dirección de "
"Cairo y queremos que ese campo sea diferente a `T` pero también genérico, "
"simplemente podemos agregar otro tipo genérico entre los `<>`:"

#: src/ch07-01-generic-data-types.md:155
msgid ""
"```rust\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of Drop<Wallet<T, "
"U>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3_u128, address: 14 };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>, U, impl UDrop: Drop<U>> of Drop<Wallet<T, "
"U>>;\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 3_u128, address: 14 };\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:168
msgid ""
"We add to `Wallet` struct definiton a new generic type `U` and then assign this "
"type to the new field member `address`.\n"
"Then we adapt the `WalletDrop` trait to work with the new generic type `U`. Notice "
"that when initializing the struct inside `main` it automatically infers that `T` is "
"a `u128` and `U` is a `felt252` and since they are both droppable, `Wallet` is "
"droppable as well!"
msgstr ""
"Agregamos a la definición de la estructura `Wallet` un nuevo tipo genérico `U` y "
"luego asignamos este tipo al nuevo miembro del campo `address`. Luego adaptamos el "
"trait `WalletDrop` para que funcione con el nuevo tipo genérico `U`. ¡Observa que "
"al inicializar la estructura dentro de `main`, automáticamente infiere que `T` es "
"un `u128` y `U` es un `felt252` y como ambos son droppable, `Wallet` también lo es!"

#: src/ch07-01-generic-data-types.md:171
msgid "## Enums"
msgstr "## Enums (Enumeraciones)"

#: src/ch07-01-generic-data-types.md:173
msgid ""
"As we did with structs, we can define enums to hold generic data types in their "
"variants. For example the `Option<T>` enum provided by the Cairo core library:"
msgstr ""
"Como hicimos con las estructuras, podemos definir enumeraciones para contener tipos "
"de datos genéricos en sus variantes. Por ejemplo, la enumeración `Option<T>` "
"proporcionada por la biblioteca central de Cairo:"

#: src/ch07-01-generic-data-types.md:175
msgid ""
"```rust\n"
"enum Option<T> {\n"
"    Some(T),\n"
"    None,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"enum Option<T> {\n"
"    Some(T),\n"
"    None,\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:182
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which "
"holds one value of type `T` and `None` that doesn't hold any value. By using the "
"`Option<T>` enum, it is possible for us to express the abstract concept of an "
"optional value and because the value has a generic type `T` we can use this "
"abstraction with any type."
msgstr ""
"El enum `Option<T>` es genérico sobre un tipo `T` y tiene dos variantes: `Some`, "
"que contiene un valor de tipo `T`, y `None`, que no contiene ningún valor. Al "
"utilizar el enum `Option<T>`, es posible expresar el concepto abstracto de un valor "
"opcional y debido a que el valor tiene un tipo genérico `T`, podemos utilizar esta "
"abstracción con cualquier tipo."

#: src/ch07-01-generic-data-types.md:184
msgid ""
"Enums can use multiple generic types as well, like definition of the `Result<T, E>` "
"enum that the core library provides:"
msgstr ""
"Los enums también pueden utilizar múltiples tipos genéricos, como la definición del "
"enum `Result<T, E>` que proporciona la biblioteca estándar"

#: src/ch07-01-generic-data-types.md:186 src/ch09-01-error-handling.md:11
msgid ""
"```rust\n"
"enum Result<T, E> {\n"
"    Ok(T),\n"
"    Err(E),\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"enum Result<T, E> {\n"
"    Ok(T),\n"
"    Err(E),\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:193 src/ch09-01-error-handling.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` "
"which holds the value of type `T` and `Err` which holds the value of type `E`. This "
"definition makes it convenient to use the `Result` enum anywhere we have an "
"operation that might succeed (by returning a value of type `T`) or fail (by "
"returning a value of type `E`)."
msgstr ""
"El enum `Result<T, E>` tiene dos tipos genéricos, `T` y `E`, y dos variantes: `Ok` "
"que tiene el valor de tipo `T` y `Err` que tiene el valor de tipo `E`. Esta "
"definición hace que sea conveniente usar el enum `Result` en cualquier lugar donde "
"tengamos una operación que pueda tener éxito (devolviendo un valor de tipo `T`) o "
"fallar (devolviendo un valor de tipo `E`)."

#: src/ch07-01-generic-data-types.md:195
msgid "## Generic Methods"
msgstr "## Métodos Genéricos"

#: src/ch07-01-generic-data-types.md:197
msgid ""
"We can implement methods on structs and enums, and use the generic types in their "
"definition, too. Using our previous definition of `Wallet<T>` struct, we define a "
"`balance` method for it:"
msgstr ""
"También podemos implementar métodos en structs y enums, y usar los tipos genéricos "
"en su definición. Utilizando nuestra definición anterior de la struct `Wallet<T>`, "
"definimos un método `balance` para ella:"

#: src/ch07-01-generic-data-types.md:199
msgid ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> @T;\n"
"}\n"
"\n"
"impl WalletImpl<T> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> @T {\n"
"        return self.balance;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Wallet<T> {\n"
"    balance: T,\n"
"}\n"
"\n"
"impl WalletDrop<T, impl TDrop: Drop<T>> of Drop<Wallet<T>>;\n"
"\n"
"trait WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> @T;\n"
"}\n"
"\n"
"impl WalletImpl<T> of WalletTrait<T> {\n"
"    fn balance(self: @Wallet<T>) -> @T {\n"
"        return self.balance;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let w = Wallet { balance: 50 };\n"
"    assert(w.balance() == 50, 0);\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:222
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which defines a "
"method that returns a snapshot of the field `address` from `Wallet`. Then we give "
"an implementation for the trait in `WalletImpl<T>`. Note that you need to include a "
"generic type in both definitions of the trait and the implementation."
msgstr ""
"Primero definimos la clase `WalletTrait<T>` usando un tipo genérico `T` que define "
"un método que devuelve una instantánea del campo `address` de `Wallet`. Luego, "
"damos una implementación de la clase en `WalletImpl<T>`. Ten en cuenta que debes "
"incluir un tipo genérico en ambas definiciones de la clase y la implementación."

#: src/ch07-01-generic-data-types.md:224
msgid ""
"We can also specify constraints on generic types when defining methods on the type. "
"We could, for example, implement methods only for `Wallet<u128>` instances rather "
"than `Wallet<T>`. In the code example we define an implementation for wallets which "
"have a concrete type of `u128` for the `balance` field."
msgstr ""
"También podemos especificar restricciones en los tipos genéricos al definir métodos "
"en la clase. Por ejemplo, podríamos implementar métodos solo para instancias de "
"`Wallet<u128>` en lugar de `Wallet<T>`. En el ejemplo de código, definimos una "
"implementación para carteras que tienen un tipo concreto de `u128` para el campo "
"`balance`."

#: src/ch07-01-generic-data-types.md:226
msgid ""
"```rust\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50_u128 };\n"
"    assert(w.balance() == 50_u128, 0);\n"
"\n"
"    w.receive(100_u128)\n"
"    assert(w.balance() == 150_u128, 0);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128);\n"
"}\n"
"\n"
"impl WalletReceiveImpl of WalletReceiveTrait {\n"
"    fn receive(ref self: Wallet<u128>, value: u128) {\n"
"        self.balance += value;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut w = Wallet { balance: 50_u128 };\n"
"    assert(w.balance() == 50_u128, 0);\n"
"\n"
"    w.receive(100_u128)\n"
"    assert(w.balance() == 150_u128, 0);\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:246
msgid ""
"The new method `receive` increments the size of the balance of any instance of a "
"`Wallet<u128>`. Notice that we changed the `main` function making `w` a mutable "
"variable in order for it to be able to update its balance. If we were to change the "
"initialization of `w` by changing the type of `balance` the previous code wouldn't "
"compile."
msgstr ""
"El nuevo método `receive` incrementa el tamaño del saldo de cualquier instancia de "
"una `Wallet<u128>`. Observe que se cambió la función `main` haciendo que `w` sea "
"una variable mutable para que pueda actualizar su saldo. Si cambiáramos la "
"inicialización de `w` cambiando el tipo de `balance`, el código anterior no se "
"compilaría."

#: src/ch07-01-generic-data-types.md:248
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. Using the "
"past implementation from `Wallet<U, V>` we are going to define a trait that picks "
"two wallets of different generic types and create a new one with a generic type of "
"each. First, lets rewrite the struct definiton:"
msgstr ""
"Cairo nos permite definir métodos genéricos dentro de traits genéricos también. "
"Usando la implementación previa de `Wallet<U, V>`, vamos a definir un trait que "
"tome dos wallets de diferentes tipos genéricos y cree uno nuevo con un tipo "
"genérico de cada uno. Primero, reescribamos la definición de la estructura:"

#: src/ch07-01-generic-data-types.md:250
msgid ""
"```rust\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Wallet<T, U> {\n"
"    balance: T,\n"
"    address: U,\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:257
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr ""
"A continuación vamos a definir ingenuamente el rasgo mixup y su implementación:"

#: src/ch07-01-generic-data-types.md:259
msgid ""
"```rust\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, "
"U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> "
"{\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// This does not compile!\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, "
"U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> "
"{\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:272
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` methods "
"which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new "
"`Wallet<T1, U2>`. As `mixup` signature specify, both `self` and `other` are getting "
"dropped at the end of the function, which is the reason for this code not to "
"compile. If you have been following from the start until now you would know that we "
"must add a requirement for all the generic types specifiying that they will "
"implement the `Drop` trait in order for the compiler to know how to drop instances "
"of `Wallet<T, U>`. The updated implementation is as follow:"
msgstr ""
"Estamos creando un trait `WalletMixTrait<T1, U1>` con el método `mixup<T2, U2>` "
"que, dada una instancia de `Wallet<T1, U1>` y `Wallet<T2, U2>`, crea un nuevo "
"`Wallet<T1, U2>`. Como especifica la firma de `mixup`, tanto `self` como `other` se "
"están eliminando al final de la función, lo que hace que este código no se compile. "
"Si has estado siguiendo desde el principio hasta ahora, sabrás que debemos agregar "
"un requisito para todos los tipos genéricos especificando que implementarán el "
"trait `Drop` para que el compilador sepa cómo eliminar las instancias de `Wallet<T, "
"U>`. La implementación actualizada es la siguiente:"

#: src/ch07-01-generic-data-types.md:274
msgid ""
"```rust\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> of "
"WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2>;\n"
"}\n"
"\n"
"impl WalletMixImpl<T1, impl T1Drop: Drop<T1>, U1, impl U1Drop: Drop<U1>> of "
"WalletMixTrait<T1, U1> {\n"
"    fn mixup<T2, impl T2Drop: Drop<T2>, U2, impl U2Drop: Drop<U2>>(\n"
"        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n"
"    ) -> Wallet<T1, U2> {\n"
"        Wallet { balance: self.balance, address: other.address }\n"
"    }\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:290
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` "
"signature. We can now try the `mixup` function:"
msgstr ""
"Sí, agregamos los requisitos para que `T1` y `U1` sean droppables en la declaración "
"de `WalletMixImpl`. Luego hacemos lo mismo para `T2` y `U2`, esta vez como parte de "
"la firma de `mixup`. Ahora podemos probar la función `mixup`:"

#: src/ch07-01-generic-data-types.md:292
msgid ""
"```rs\n"
"fn main() {\n"
"    let w1 = Wallet { balance: true, address: 10_u128 };\n"
"    let w2 = Wallet { balance: 32, address: 100_u8 };\n"
"\n"
"    let w3 = w1.mixup(w2);\n"
"\n"
"    assert(w3.balance == true, 0);\n"
"    assert(w3.address == 100_u8, 0);\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"fn main() {\n"
"    let w1 = Wallet { balance: true, address: 10_u128 };\n"
"    let w2 = Wallet { balance: 32, address: 100_u8 };\n"
"\n"
"    let w3 = w1.mixup(w2);\n"
"\n"
"    assert(w3.balance == true, 0);\n"
"    assert(w3.address == 100_u8, 0);\n"
"}\n"
"```"

#: src/ch07-01-generic-data-types.md:304
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, u8>` "
"instance."
msgstr ""
"Primero creamos dos instancias: una de `Wallet<bool, u128>` y la otra de "
"`Wallet<felt252, u8>`. Luego, llamamos a `mixup` y creamos una nueva instancia de "
"`Wallet<bool, u8>`."

#: src/ch07-02-traits-in-cairo.md:1
msgid "# Traits in Cairo"
msgstr "# Traits en Cairo"

#: src/ch07-02-traits-in-cairo.md:3
msgid ""
"Traits specify functionality blueprints that can be implemented. The blueprint "
"specification includes a set of function signatures containing type annotations for "
"the parameters and return value. This sets a standard to implement the specific "
"functionality."
msgstr ""
"Los traits especifican plantillas de funcionalidad que pueden ser implementadas. La "
"especificación de la plantilla incluye un conjunto de firmas de funciones que "
"contienen anotaciones de tipos para los parámetros y el valor de retorno. Esto "
"establece un estándar para implementar la funcionalidad específica."

#: src/ch07-02-traits-in-cairo.md:5
msgid "## Defining a Trait"
msgstr "## Definiendo un Trait"

#: src/ch07-02-traits-in-cairo.md:7
msgid ""
"To define a trait, you use the keyword `trait` followed by the name of the trait in "
"`PascalCase` then the function signatures in a pair of curly braces."
msgstr ""
"Para definir un trait, se utiliza la palabra clave `trait` seguida del nombre del "
"trait en `PascalCase` y luego las firmas de funciones dentro de un par de llaves."

#: src/ch07-02-traits-in-cairo.md:9
msgid ""
"For example, let's say that we have multiple structs representing shapes. We want "
"our application to be able to perform geometry operations on these shapes, So we "
"define a trait `ShapeGeometry` that contains a blueprint to implement geometry "
"operations on a shape like this:"
msgstr ""
"Por ejemplo, supongamos que tenemos múltiples estructuras que representan formas. "
"Queremos que nuestra aplicación pueda realizar operaciones de geometría en estas "
"formas, por lo que definimos un trait `ShapeGeometry` que contiene una plantilla "
"para implementar operaciones de geometría en una forma de esta manera:"

#: src/ch07-02-traits-in-cairo.md:11
msgid ""
"```rust\n"
"trait ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64;\n"
"    fn area(self: Rectangle) -> u64;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ShapeGeometry {\n"
"    fn boundary(self: Rectangle) -> u64;\n"
"    fn area(self: Rectangle) -> u64;\n"
"}\n"
"```"

#: src/ch07-02-traits-in-cairo.md:18
msgid ""
"Here our trait `ShapeGeometry` declares signatures for two methods `boundary` and "
"`area`. When implemented, both these functions should return a `u64` and accept "
"parameters as specified by the trait."
msgstr ""
"Aquí nuestro trait `ShapeGeometry` declara las firmas de dos métodos `boundary` y "
"`area`. Cuando se implementen, ambas funciones deben devolver un `u64` y aceptar "
"parámetros tal como se especifica en el trait."

#: src/ch07-02-traits-in-cairo.md:20
msgid "## Implementing a Trait"
msgstr "## Implementando un Trait"

#: src/ch07-02-traits-in-cairo.md:22
msgid ""
"A trait can be implemented using `impl` keyword with the name of your "
"implementation followed by `of` then the name of trait being implemented. Here's an "
"example implementing `ShapeGeometry` trait."
msgstr ""
"Un trait puede ser implementado usando la palabra clave `impl` seguida del nombre "
"de la implementación y la palabra `of`, seguida del nombre del trait que está "
"siendo implementado. Aquí hay un ejemplo de cómo implementar el trait "
"`ShapeGeometry`."

#: src/ch07-02-traits-in-cairo.md:24
msgid ""
"```rust\n"
"impl RectangleGeometry of ShapeGeometry {\n"
"\tfn boundary(self: Rectangle) -> u64 {\n"
"        2_u64 * (self.height + self.width)\n"
"    }\n"
"\tfn area(self: Rectangle) -> u64 {\n"
"\t\tself.height * self.width\n"
"\t}\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl RectangleGeometry of ShapeGeometry {\n"
"\tfn boundary(self: Rectangle) -> u64 {\n"
"        2_u64 * (self.height + self.width)\n"
"    }\n"
"\tfn area(self: Rectangle) -> u64 {\n"
"\t\tself.height * self.width\n"
"\t}\n"
"}\n"
"```"

#: src/ch07-02-traits-in-cairo.md:35
msgid ""
"In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` "
"defining what the methods `boundary` and `area` should do. Note that the function "
"parameters and return value types are identical to the trait specification."
msgstr ""
"En el código anterior, `RectangleGeometry` implementa el trait `ShapeGeometry` "
"definiendo lo que deben hacer los métodos `boundary` y `area`. Note que los tipos "
"de los parámetros de las funciones y los valores de retorno son idénticos a los "
"especificados en el trait."

#: src/ch07-02-traits-in-cairo.md:37
msgid "## Parameter `self`"
msgstr "## Parámetro `self`"

#: src/ch07-02-traits-in-cairo.md:39
msgid ""
"In the example above, `self` is a special parameter. When a parameter with name "
"`self` is used, the implemented functions are also [attached to the instances of "
"the type as methods](ch04-03-method-syntax.md#defining-methods). Here's an "
"illustration,"
msgstr ""
"En el ejemplo anterior, `self` es un parámetro especial. Cuando se usa un parámetro "
"con el nombre `self`, las funciones implementadas también [se adjuntan a las "
"instancias del tipo como métodos](ch04-03-method-syntax.md#defining-methods). Aquí "
"hay una ilustración,"

#: src/ch07-02-traits-in-cairo.md:41
msgid ""
"When the `ShapeGeometry` trait is implemented, the function `area` from the "
"`ShapeGeometry` trait can be called in two ways:"
msgstr ""
"Cuando se implementa el trait `ShapeGeometry`, la función `area` del trait "
"`ShapeGeometry` se puede llamar de dos maneras:"

#: src/ch07-02-traits-in-cairo.md:43
msgid ""
"```rust\n"
"let rect = Rectangle { ... }; // Rectangle instantiation\n"
"\n"
"// First way, as a method on the struct instance\n"
"let area1 = rect.area();\n"
"// Second way, from the implementation\n"
"let area2 = RectangleGeometry::area(rect);\n"
"// `area1` has same value as `area2`\n"
"area1.print();\n"
"area2.print();\n"
"```"
msgstr ""
"```rust\n"
"let rect = Rectangle { ... }; // Rectangle instantiation\n"
"\n"
"// First way, as a method on the struct instance\n"
"let area1 = rect.area();\n"
"// Second way, from the implementation\n"
"let area2 = RectangleGeometry::area(rect);\n"
"// `area1` has same value as `area2`\n"
"area1.print();\n"
"area2.print();\n"
"```"

#: src/ch07-02-traits-in-cairo.md:55
msgid ""
"And the implementation of the `area` method will be accessed via the `self` "
"parameter."
msgstr ""
"Y se accederá a la implementación del método `area` a través del parámetro `self`."

#: src/ch07-02-traits-in-cairo.md:57
msgid "## Generic Traits"
msgstr "## Traits Genéricos"

#: src/ch07-02-traits-in-cairo.md:59
msgid ""
"Usually we want to write a trait when we want multiple types to implement a "
"functionality in a standard way. However, in the example above the signatures are "
"static and cannot be used for multiple types. To do this, we use generic types when "
"defining traits."
msgstr ""
"Por lo general, queremos escribir un trait cuando queremos que múltiples tipos "
"implementen una funcionalidad de una manera estándar. Sin embargo, en el ejemplo "
"anterior, las firmas son estáticas y no se pueden usar para múltiples tipos. Para "
"hacer esto, usamos tipos genéricos al definir traits."

#: src/ch07-02-traits-in-cairo.md:61
msgid ""
"In the example below, we use generic type `T` and our method signatures can use "
"this alias which can be provided during implementation."
msgstr ""
"En el siguiente ejemplo, usamos el tipo genérico `T` y nuestras firmas de métodos "
"pueden usar este alias que se puede proporcionar durante la implementación."

#: src/ch07-02-traits-in-cairo.md:63
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"// Here T is an alias type which will be provided buring implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2_u64 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2_u64 * 314_u64 * self.radius) / 100_u64\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314_u64 * self.radius * self.radius) / 100_u64\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5_u128, width: 7_u128 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5_u128 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"// Here T is an alias type which will be provided buring implementation\n"
"trait ShapeGeometry<T> {\n"
"    fn boundary(self: T) -> u64;\n"
"    fn area(self: T) -> u64;\n"
"}\n"
"\n"
"// Implementation RectangleGeometry passes in <Rectangle>\n"
"// to implement the trait for that type\n"
"impl RectangleGeometry of ShapeGeometry<Rectangle> {\n"
"    fn boundary(self: Rectangle) -> u64 {\n"
"        2_u64 * (self.height + self.width)\n"
"    }\n"
"    fn area(self: Rectangle) -> u64 {\n"
"        self.height * self.width\n"
"    }\n"
"}\n"
"\n"
"// We might have another struct Circle\n"
"// which can use the same trait spec\n"
"impl CircleGeometry of ShapeGeometry<Circle> {\n"
"    fn boundary(self: Circle) -> u64 {\n"
"        (2_u64 * 314_u64 * self.radius) / 100_u64\n"
"    }\n"
"    fn area(self: Circle) -> u64 {\n"
"        (314_u64 * self.radius * self.radius) / 100_u64\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5_u128, width: 7_u128 };\n"
"    rect.area().print(); // 35\n"
"    rect.boundary().print(); // 24\n"
"\n"
"    let circ = Circle { radius: 5_u128 };\n"
"    circ.area().print(); // 78\n"
"    circ.boundary().print(); // 31\n"
"}\n"
"```"

#: src/ch07-02-traits-in-cairo.md:105
msgid "## Managing and using external trait implementations"
msgstr "## Administrando y usando implementaciones de traits externos"

#: src/ch07-02-traits-in-cairo.md:107
msgid ""
"To use traits methods, you need to make sure the correct traits/implementation(s) "
"are imported. In the code above we imported `PrintTrait` from `debug` with `use "
"debug::PrintTrait;` to use `print()` methods."
msgstr ""
"Para usar los métodos de traits, es necesario asegurarse de que los traits/"
"implementaciones correctos estén importados. En el código anterior, importamos "
"`PrintTrait` desde `debug` con `use debug::PrintTrait;` para usar el método "
"`print()`."

#: src/ch07-02-traits-in-cairo.md:109
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules.\n"
"If `CircleGeometry` was in a separate module/file `circle` then to use `boundary` "
"on `circ: Circle`, we'd need to import `CircleGeometry` in addition to "
"`ShapeGeometry`."
msgstr ""
"En algunos casos, puede ser necesario importar no solo el trait, sino también la "
"implementación si están declarados en módulos separados. \n"
"Si `CircleGeometry` estuviera en un módulo/archivo separado `circle`, entonces para "
"usar `boundary` en `circ: Circle`, necesitaríamos importar `CircleGeometry` además "
"de `ShapeGeometry`."

#: src/ch07-02-traits-in-cairo.md:112
msgid "If the code was organised into modules like this,"
msgstr "Si el código estuviera organizado en módulos de esta manera,"

#: src/ch07-02-traits-in-cairo.md:114
msgid ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry::<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry::<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5_u64, width: 7_u64 };\n"
"    let circ = Circle { radius: 5_u64 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use debug::PrintTrait;\n"
"\n"
"// struct Circle { ... } and struct Rectangle { ... }\n"
"\n"
"mod geometry {\n"
"    use super::Rectangle;\n"
"    trait ShapeGeometry<T> {\n"
"        // ...\n"
"    }\n"
"\n"
"    impl RectangleGeometry of ShapeGeometry::<Rectangle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"// Could be in a different file\n"
"mod circle {\n"
"    use super::geometry::ShapeGeometry;\n"
"    use super::Circle;\n"
"    impl CircleGeometry of ShapeGeometry::<Circle> {\n"
"        // ...\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let rect = Rectangle { height: 5_u64, width: 7_u64 };\n"
"    let circ = Circle { radius: 5_u64 };\n"
"    // Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
"    rect.area().print();\n"
"    circ.area().print();\n"
"}\n"
"```"

#: src/ch07-02-traits-in-cairo.md:149
msgid "To make it work, in addition to,"
msgstr "Para hacer que funcione, además de,"

#: src/ch07-02-traits-in-cairo.md:151
msgid ""
"```rust\n"
"use geometry::ShapeGeometry;\n"
"```"
msgstr ""
"```rust\n"
"use geometry::ShapeGeometry;\n"
"```"

#: src/ch07-02-traits-in-cairo.md:155
msgid "you might also need to use `CircleGeometry`,"
msgstr "para hacerlo funcionar, también tendrías que usar `CircleGeometry`,"

#: src/ch07-02-traits-in-cairo.md:157
msgid ""
"```rust\n"
"use circle::CircleGeometry\n"
"```"
msgstr ""
"```rust\n"
"use circle::CircleGeometry\n"
"```"

#: src/ch09-00-error-handling.md:1
msgid "# Error handling"
msgstr "# Gestión de errores"

#: src/ch09-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided by "
"Cairo, which not only allow you to address potential issues in your code, but also "
"make it easier to create programs that are adaptable and maintainable. By examining "
"different approaches to managing errors, such as pattern matching with the Result "
"enum, using the ? operator for more ergonomic error propagation, and employing the "
"unwrap or expect methods for handling recoverable errors, you'll gain a deeper "
"understanding of Cairo's error handling features. These concepts are crucial for "
"building robust applications that can effectively handle unexpected situations, "
"ensuring your code is ready for production."
msgstr ""
"En este capítulo, exploraremos varias técnicas de manejo de errores proporcionadas "
"por Cairo, que no sólo te permiten tratar problemas potenciales en tu código, sino "
"que también hacen más fácil crear programas que son adaptables y mantenibles. "
"Examinando diferentes aproximaciones a la gestión de errores, como la concordancia "
"de patrones con el enum Result, usando el operador ? para una propagación de "
"errores más ergonómica, y empleando los métodos unwrap o expect para gestionar "
"errores recuperables, obtendrá una comprensión más profunda de las características "
"de gestión de errores de Cairo. Estos conceptos son cruciales para construir "
"aplicaciones robustas que puedan manejar efectivamente situaciones inesperadas, "
"asegurando que su código esté listo para producción."

#: src/ch09-01-error-handling.md:1
msgid "# Recoverable Errors with `Result`"
msgstr "# Errores Recuperables con `Result`"

#: src/ch09-01-error-handling.md:3 src/ch09-01-error-handling.md:56
msgid "<br />"
msgstr "<br />"

#: src/ch09-01-error-handling.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily interpret "
"and respond to. For example, if you try to add two large integers and the operation "
"overflows because the sum exceeds the maximum representable value, you might want "
"to return an error or a wrapped result instead of causing undefined behavior or "
"terminating the process."
msgstr ""
"La mayoría de los errores no son lo suficientemente graves como para que el "
"programa se detenga por completo. A veces, cuando una función falla, es por una "
"razón que usted puede interpretar fácilmente y a la que puede responder. Por "
"ejemplo, si intenta sumar dos enteros grandes y la operación se desborda porque la "
"suma excede el valor máximo representable, es posible que desee devolver un error o "
"un resultado envuelto en lugar de causar un comportamiento indefinido o terminar el "
"proceso."

#: src/ch09-01-error-handling.md:7
msgid "## The `Result` enum"
msgstr "## El enum `Result`"

#: src/ch09-01-error-handling.md:9
msgid ""
"Recall from [“Generic data types”](ch07-01-generic-data-types.md#enums) in Chapter "
"7 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as "
"follows:"
msgstr ""
"Recordemos de [\"Tipos de datos genéricos\"](ch07-01-generic-data-types.md#enums) "
"en el Capítulo 7 que el enum `Result` se define como teniendo dos variantes, `Ok` y "
"`Err`, como sigue:"

#: src/ch09-01-error-handling.md:20
msgid "## The `ResultTrait`"
msgstr "## El `ResultTrait`"

#: src/ch09-01-error-handling.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` enum, "
"such as unwrapping values, checking whether the `Result` is `Ok` or `Err`, and "
"panicking with a custom message. The `ResultTraitImpl` implementation defines the "
"logic of these methods."
msgstr ""
"El rasgo `ResultTrait` proporciona métodos para trabajar con el enum `Result<T, "
"E>`, como desenvolver valores, comprobar si el `Result` es `Ok` o `Err`, y entrar "
"en pánico con un mensaje personalizado. La implementación de `ResultTraitImpl` "
"define la lógica de estos métodos."

#: src/ch09-01-error-handling.md:24
msgid ""
"```rust\n"
"trait ResultTrait<T, E> {\n"
"    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> T;\n"
"\n"
"    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
"\n"
"    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -> E;\n"
"\n"
"    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
"\n"
"    fn is_ok(self: @Result<T, E>) -> bool;\n"
"\n"
"    fn is_err(self: @Result<T, E>) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ResultTrait<T, E> {\n"
"    fn expect<impl EDrop: Drop<E>>(self: Result<T, E>, err: felt252) -> T;\n"
"\n"
"    fn unwrap<impl EDrop: Drop<E>>(self: Result<T, E>) -> T;\n"
"\n"
"    fn expect_err<impl TDrop: Drop<T>>(self: Result<T, E>, err: felt252) -> E;\n"
"\n"
"    fn unwrap_err<impl TDrop: Drop<T>>(self: Result<T, E>) -> E;\n"
"\n"
"    fn is_ok(self: @Result<T, E>) -> bool;\n"
"\n"
"    fn is_err(self: @Result<T, E>) -> bool;\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to extract "
"the value of type `T` from a `Result<T, E>` when it is in the `Ok` variant. If the "
"`Result` is `Ok(x)`, both methods return the value `x`. However, the key difference "
"between the two methods lies in their behavior when the `Result` is in the `Err` "
"variant. The `expect` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control and "
"context over the panic. On the other hand, the `unwrap` method panics with a "
"default error message, providing less information about the cause of the panic."
msgstr ""
"Los métodos `expect` y `unwrap` se parecen en que ambos intentan extraer el valor "
"de tipo `T` de un `Resultado<T, E>` cuando está en la variante `Ok`. Si el "
"`Resultado` es `Ok(x)`, ambos métodos devuelven el valor `x`. Sin embargo, la "
"diferencia clave entre los dos métodos radica en su comportamiento cuando el "
"`Result` está en la variante `Err`. El método `expect` te permite proporcionar un "
"mensaje de error personalizado (como un valor `felt252`) que se utilizará cuando se "
"produzca el pánico, dándote más control y contexto sobre el pánico. Por otro lado, "
"el método `unwrap` entra en pánico con un mensaje de error por defecto, "
"proporcionando menos información sobre la causa del pánico."

#: src/ch09-01-error-handling.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the `Result` "
"is `Err(x)`, both methods return the value `x`. However, the key difference between "
"the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other hand, "
"the `unwrap_err` method panics with a default error message, providing less "
"information about the cause of the panic."
msgstr ""
"Los métodos `expect_err` y `unwrap_err` tienen el comportamiento exactamente "
"opuesto. Si el `Result` es `Err(x)`, ambos métodos devuelven el valor `x`. Sin "
"embargo, la diferencia clave entre los dos métodos está en el caso de `Result::"
"Ok()`. El método `expect_err` te permite proporcionar un mensaje de error "
"personalizado (como un valor `felt252`) que se utilizará cuando se produzca el "
"pánico, dándote más control y contexto sobre el pánico. Por otro lado, el método "
"`unwrap_err` entra en pánico con un mensaje de error por defecto, proporcionando "
"menos información sobre la causa del pánico."

#: src/ch09-01-error-handling.md:44
msgid ""
"A careful reader may have noticed the `<impl TDrop: Drop<T>>` and `<impl EDrop: "
"Drop<E>>` in the first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language. These constraints indicate that the associated "
"functions require an implementation of the `Drop` trait for the generic types `T` "
"and `E`, respectively."
msgstr ""
"Un lector atento puede haber notado el `<impl TDrop: Drop<T>>` y `<impl EDrop: "
"Drop<E>>` en las firmas de los cuatro primeros métodos. Esta sintaxis representa "
"restricciones de tipo genérico en el lenguaje Cairo. Estas restricciones indican "
"que las funciones asociadas requieren una implementación del rasgo `Drop` para los "
"tipos genéricos `T` y `E`, respectivamente."

#: src/ch09-01-error-handling.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by the "
"`ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""
"Por último, los métodos `is_ok` y `is_err` son funciones de utilidad proporcionadas "
"por el rasgo `ResultTrait` para comprobar la variante de un valor del enum `Result`."

#: src/ch09-01-error-handling.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the `Result` "
"is the `Err` variant, it returns `false`."
msgstr ""
"`is_ok` toma una instantánea de un valor `Result<T, E>` y devuelve `true` si el "
"`Result` es la variante `Ok`, lo que significa que la operación se ha realizado "
"correctamente. Si el `Resultado` es la variante `Err`, devuelve `false`."

#: src/ch09-01-error-handling.md:50
msgid ""
"`is_err` takes a reference to a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Err` variant, meaning the operation encountered an error. If the "
"`Result` is the `Ok` variant, it returns `false`."
msgstr ""
"`is_err` toma una referencia a un valor `Result<T, E>` y devuelve `true` si el "
"`Result` es la variante `Err`, lo que significa que la operación ha encontrado un "
"error. Si el `Resultado` es la variante `Ok`, devuelve `false`."

#: src/ch09-01-error-handling.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of an "
"operation without consuming the Result value, allowing you to perform additional "
"operations or make decisions based on the variant without unwrapping it."
msgstr ""
"Estos métodos son útiles cuando se desea comprobar el éxito o el fracaso de una "
"operación sin consumir el valor del Resultado, lo que permite realizar operaciones "
"adicionales o tomar decisiones basadas en la variante sin desenvolverla."

#: src/ch09-01-error-handling.md:54
msgid ""
"You can find the implementation ot the `ResultTrait` [here](https://github.com/"
"starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"Puede encontrar la implementación del `ResultTrait` [aquí](https://github.com/"
"starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."

#: src/ch09-01-error-handling.md:58
msgid "It is always easier to understand with examples."
msgstr "Siempre es más fácil entender con ejemplos."

#: src/ch09-01-error-handling.md:60
msgid "Have a look at this function signature:"
msgstr "Eche un vistazo a la firma de esta función:"

#: src/ch09-01-error-handling.md:62
msgid ""
"```rust\n"
"fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
"```"
msgstr ""
"```rust\n"
"fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;\n"
"```"

#: src/ch09-01-error-handling.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` where the "
"`Ok` variant holds the sum if the addition does not overflow, and the `Err` variant "
"holds the overflowed value if the addition does overflow."
msgstr ""
"Toma dos enteros u128, a y b, y devuelve un `Result<u128, u128>` donde la variante "
"`Ok` contiene la suma si la suma no se desborda, y la variante `Err` contiene el "
"valor desbordado si la suma se desborda."

#: src/ch09-01-error-handling.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Ahora, podemos utilizar esta función en otros lugares. Por ejemplo:"

#: src/ch09-01-error-handling.md:70
msgid ""
"```rust\n"
"fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
"    match u128_overflowing_add(a, b) {\n"
"        Result::Ok(r) => Option::Some(r),\n"
"        Result::Err(r) => Option::None(()),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn u128_checked_add(a: u128, b: u128) -> Option<u128> {\n"
"    match u128_overflowing_add(a, b) {\n"
"        Result::Ok(r) => Option::Some(r),\n"
"        Result::Err(r) => Option::None(()),\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. It uses "
"the `Result` returned by `u128_overflowing_add` to determine the success or failure "
"of the addition operation. The match expression checks the `Result` from "
"`u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` "
"containing the sum. If the result is `Err(r)`, it returns `Option::None(())` to "
"indicate that the operation has failed due to overflow. The function does not panic "
"in case of an overflow."
msgstr ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. It uses "
"the `Result` returned by `u128_overflowing_add` to determine the success or failure "
"of the addition operation. The match expression checks the `Result` from "
"`u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` "
"containing the sum. If the result is `Err(r)`, it returns `Option::None(())` to "
"indicate that the operation has failed due to overflow. The function does not panic "
"in case of an overflow."

#: src/ch09-01-error-handling.md:81
msgid ""
"Let's take another example demonstrating the use of `unwrap`.\n"
"First we import the necessary modules:"
msgstr ""
"Veamos otro ejemplo que demuestra el uso de `unwrap`.\n"
"Primero importamos los módulos necesarios:"

#: src/ch09-01-error-handling.md:84
msgid ""
"```rust\n"
"use core::traits::Into;\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"use result::ResultTrait;\n"
"use result::ResultTraitImpl;\n"
"```"
msgstr ""
"```rust\n"
"use core::traits::Into;\n"
"use traits::TryInto;\n"
"use option::OptionTrait;\n"
"use result::ResultTrait;\n"
"use result::ResultTraitImpl;\n"
"```"

#: src/ch09-01-error-handling.md:92
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries to "
"convert it into a `u8` integer using the `try_into` method. If successful, it "
"returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`."
msgstr ""
"En este ejemplo, la función `parse_u8` toma un entero `felt252` e intenta "
"convertirlo en un entero `u8` utilizando el método `try_into`. Si tiene éxito, "
"devuelve `Result::Ok(value)`, en caso contrario devuelve `Result::Err('Invalid "
"integer')`."

#: src/ch09-01-error-handling.md:94
msgid ""
"```rust\n"
"fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"    match s.try_into() {\n"
"        Option::Some(value) => Result::Ok(value),\n"
"        Option::None(_) => Result::Err('Invalid integer'),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn parse_u8(s: felt252) -> Result<u8, felt252> {\n"
"    match s.try_into() {\n"
"        Option::Some(value) => Result::Ok(value),\n"
"        Option::None(_) => Result::Err('Invalid integer'),\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:103
msgid "Our two test cases are:"
msgstr "Nuestros dos casos de prueba son:"

#: src/ch09-01-error-handling.md:105
msgid ""
"```rust\n"
"#[test]\n"
"fn test_felt252_to_u8() {\n"
"    let number: felt252 = 5_felt252;\n"
"    // should not panic\n"
"    let res = parse_u8(number).unwrap();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_felt252_to_u8_panic() {\n"
"    let number: felt252 = 256_felt252;\n"
"    // should panic\n"
"    let res = parse_u8(number).unwrap();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[test]\n"
"fn test_felt252_to_u8() {\n"
"    let number: felt252 = 5_felt252;\n"
"    // should not panic\n"
"    let res = parse_u8(number).unwrap();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_felt252_to_u8_panic() {\n"
"    let number: felt252 = 256_felt252;\n"
"    // should panic\n"
"    let res = parse_u8(number).unwrap();\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:121
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a value "
"that is out of the `u8` range, expecting the `unwrap` method to panic with the "
"error message 'Invalid integer'."
msgstr ""
"La primera prueba una conversión válida de `felt252` a `u8`, esperando que el "
"método `unwrap` no entre en pánico. La segunda función de prueba intenta convertir "
"un valor que está fuera del rango `u8`, esperando que el método `unwrap` entre en "
"pánico con el mensaje de error 'Invalid integer'."

#: src/ch09-01-error-handling.md:123
msgid "> We could have also used the #[should_panic] attribute here."
msgstr "> También podríamos haber utilizado aquí el atributo #[should_panic]."

#: src/ch09-01-error-handling.md:125
msgid "### The `?` operator ?"
msgstr "### El operador `?` ?"

#: src/ch09-01-error-handling.md:127
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator is used "
"for more idiomatic and concise error handling. When you use the `?` operator on a "
"`Result` or `Option` type, it will do the following:"
msgstr ""
"El último operador del que hablaremos es el operador `?`. El operador `?` se "
"utiliza para un manejo de errores más idiomático y conciso. Cuando usas el operador "
"`?` en un tipo `Result` u `Option`, hará lo siguiente:"

#: src/ch09-01-error-handling.md:129
msgid ""
"- If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner "
"value `x` directly.\n"
"- If the value is `Result::Err(e)` or `Option::None`, it will propagate the error "
"or `None` by immediately returning from the function."
msgstr ""
"- Si el valor es `Result::Ok(x)` u `Opción::Some(x)`, devolverá el valor interno "
"`x` directamente.\n"
"- Si el valor es `Result::Err(e)` u `Option::None`, propagará el error o `None` "
"retornando inmediatamente de la función."

#: src/ch09-01-error-handling.md:132
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let the "
"calling function deal with them."
msgstr ""
"El operador `?` es útil cuando se desea manejar los errores implícitamente y dejar "
"que la función de llamada se ocupe de ellos."

#: src/ch09-01-error-handling.md:134
msgid "Here is an example."
msgstr "Aquí un ejemplo."

#: src/ch09-01-error-handling.md:136
msgid ""
"```rust\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {\n"
"    let input_to_u8: u8 = parse_u8(input)?;\n"
"    // DO SOMETHING\n"
"    let res = input_to_u8 - 1;\n"
"    Result::Ok(res)\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:145
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and calls "
"`parse_u8`. The `?` operator is used to propagate the error, if any, or unwrap the "
"successful value."
msgstr ""
"La función `do_something_with_parse_u8` toma un valor `felt252` como entrada y "
"llama a `parse_u8`. El operador `?` se utiliza para propagar el error, si lo hay, o "
"desenvolver el valor correcto."

#: src/ch09-01-error-handling.md:147
msgid "And with a little test case:"
msgstr "Y con un pequeño caso de prueba:"

#: src/ch09-01-error-handling.md:149
msgid ""
"```rust\n"
"#[test]\n"
"fn test_function_2() {\n"
"    let number: felt252 = 258_felt252;\n"
"    match do_something_with_parse_u8(number) {\n"
"        Result::Ok(value) => value.print(),\n"
"        Result::Err(e) => e.print()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[test]\n"
"fn test_function_2() {\n"
"    let number: felt252 = 258_felt252;\n"
"    match do_something_with_parse_u8(number) {\n"
"        Result::Ok(value) => value.print(),\n"
"        Result::Err(e) => e.print()\n"
"    }\n"
"}\n"
"```"

#: src/ch09-01-error-handling.md:160
msgid "The console will print the error \"Invalid Integer\"."
msgstr "La consola mostrará el error \"Invalid Integer\"."

#: src/ch09-01-error-handling.md:162
msgid "<br/>"
msgstr "<br/>"

#: src/ch09-01-error-handling.md:164
msgid "### Summary"
msgstr "### Resumen"

#: src/ch09-01-error-handling.md:166
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result enum, which "
"has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types "
"`T` and `E` representing the successful and error values, respectively. The "
"`ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping "
"values, checking if the result is `Ok` or `Err`, and panicking with custom messages."
msgstr ""
"Vimos que los errores recuperables pueden ser manejados en Cairo usando el enum "
"Result, que tiene dos variantes: `Ok` y `Err`. El enum `Result<T, E>` es genérico, "
"con los tipos `T` y `E` representando los valores de éxito y error, "
"respectivamente. El `ResultTrait` proporciona métodos para trabajar con `Result<T, "
"E>`, como desenvolver valores, comprobar si el resultado es `Ok` o `Err`, y asustar "
"con mensajes personalizados."

#: src/ch09-01-error-handling.md:168
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use pattern "
"matching to handle the success or failure of an operation. The `?` operator can be "
"used to implicitly handle errors by propagating the error or unwrapping the "
"successful value. This allows for more concise and clear error handling, where the "
"caller is responsible for managing errors raised by the called function."
msgstr ""
"Para gestionar errores recuperables, una función puede devolver un tipo `Result` y "
"utilizar la concordancia de patrones para gestionar el éxito o el fracaso de una "
"operación. El operador `?` puede utilizarse para gestionar errores implícitamente, "
"propagando el error o desenvolviendo el valor correcto. Esto permite una gestión de "
"errores más concisa y clara, en la que el autor de la llamada es responsable de "
"gestionar los errores generados por la función llamada."

#: src/ch08-00-testing-cairo-programs.md:1
msgid "# Testing Cairo Programs"
msgstr "# Testing de Programas en Cairo"

#: src/ch08-01-how-to-write-tests.md:1
msgid "# How To Write Tests"
msgstr "# Cómo Escribir Test"

#: src/ch08-01-how-to-write-tests.md:3
msgid "## The Anatomy of a Test Function"
msgstr "## La Anatomía de una Función de Testing"

#: src/ch08-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning in the "
"expected manner. The bodies of test functions typically perform these three actions:"
msgstr ""
"Las pruebas son funciones en Cairo que verifican que el código no relacionado con "
"las pruebas está funcionando de la manera esperada. Los cuerpos de las funciones de "
"prueba típicamente realizan estas tres acciones:"

#: src/ch08-01-how-to-write-tests.md:7
msgid ""
"- Set up any needed data or state.\n"
"- Run the code you want to test.\n"
"- Assert the results are what you expect."
msgstr ""
"- Configuran cualquier dato o estado necesario.\n"
"- Ejecutan el código que se desea probar.\n"
"- Verifican que los resultados sean los esperados."

#: src/ch08-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests that take "
"these actions, which include the `test` attribute, the `assert` function, and and "
"the `should_panic` attribute."
msgstr ""
"Veamos las características específicas que Cairo proporciona para escribir pruebas "
"que realizan estas acciones, que incluyen el atributo `test`, la función `assert` y "
"el atributo `should_panic`."

#: src/ch08-01-how-to-write-tests.md:13
msgid "### The Anatomy of a Test Function"
msgstr "### La anatomía de una Función Test"

#: src/ch08-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the `test` "
"attribute. Attributes are metadata about pieces of Cairo code; one example is the "
"derive attribute we used with structs in Chapter 4. To change a function into a "
"test function, add `#[test]` on the line before `fn`. When you run your tests with "
"the `cairo-test` command, Cairo builds a test runner binary that runs the annotated "
"functions and reports on whether each test function passes or fails."
msgstr ""
"En su forma más simple, una prueba en Cairo es una función que está anotada con el "
"atributo `test`. Los atributos son metadatos sobre piezas de código en Cairo; un "
"ejemplo es el atributo `derive` que usamos con estructuras en el capítulo 4. Para "
"convertir una función en una función de prueba, agrega `#[test]` en la línea antes "
"de `fn`. Cuando se ejecutan las pruebas con el comando `cairo-test`, Cairo "
"construye un binario de ejecución de pruebas que ejecuta las funciones anotadas y "
"reporta si cada función de prueba pasa o falla."

#: src/ch08-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using Scarb "
"with the command `scarb new adder`:"
msgstr ""
"Creemos un nuevo proyecto llamado `adder` que sumará dos números usando Scarb con "
"el comando `scarb new adder`: "

#: src/ch08-01-how-to-write-tests.md:19
msgid ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"
msgstr ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── Scarb.toml\n"
"└── src\n"
"    └── lib.cairo\n"
"```"

#: src/ch08-01-how-to-write-tests.md:27 src/ch08-02-test-organization.md:51
msgid "<!-- TODO: remove when Scarb test work -->"
msgstr "<!-- TODO: remove when Scarb test work -->"

#: src/ch08-01-how-to-write-tests.md:29
msgid ""
"> Note: You will notice here a `cairo_project.toml` file.\n"
"> This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed "
"by Scarb),\n"
"> which is required to run the `cairo-test .` command to run the code of the "
"crate.\n"
"> It is required until Scarb implements this feature. The content of the file is:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> ```\n"
">\n"
"> and indicates that the crate named \"adder\" is located in the `src` directory."
msgstr ""
"> Nota: Aquí notarás un archivo `cairo_project.toml`.\n"
"> Este es el archivo de configuración para proyectos Cairo \"vanilla\" (es decir, "
"no administrados por Scarb),\n"
"> que se requiere para ejecutar el comando `cairo-test .` para ejecutar el código "
"del crate.\n"
"> Es necesario hasta que Scarb implemente esta característica. El contenido del "
"archivo es:\n"
">\n"
"> ```toml\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> ```\n"
">\n"
"> e indica que el crate llamado \"adder\" se encuentra en el directorio `src`."

#: src/ch08-01-how-to-write-tests.md:41
msgid "In _lib.cairo_, let's add a first test, as shown in Listing 8-1."
msgstr ""
"En _lib.cairo_, agreguemos una primera prueba, como se muestra en el Listado 8-1."

#: src/ch08-01-how-to-write-tests.md:43 src/ch08-01-how-to-write-tests.md:79
#: src/ch08-01-how-to-write-tests.md:140 src/ch08-01-how-to-write-tests.md:162
#: src/ch08-01-how-to-write-tests.md:201 src/ch08-01-how-to-write-tests.md:274
#: src/ch08-01-how-to-write-tests.md:355 src/ch08-02-test-organization.md:19
msgid "<span class=\"filename\">Filename: lib.cairo</span>"
msgstr "<span class=\"filename\">Filename: lib.cairo</span>"

#: src/ch08-01-how-to-write-tests.md:45 src/ch08-02-test-organization.md:21
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:56
msgid "Listing 8-1: A test module and function"
msgstr "Listado 8-1: Un módulo y función de prueba"

#: src/ch08-01-how-to-write-tests.md:58
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so the test "
"runner knows to treat this function as a test. We might also have non-test "
"functions in the tests module to help set up common scenarios or perform common "
"operations, so we always need to indicate which functions are tests."
msgstr ""
"Por ahora, ignoraremos las dos primeras líneas y nos centraremos en la función. "
"Observa la anotación `#[test]`: este atributo indica que esta es una función de "
"prueba, por lo que el runner de pruebas sabe que debe tratar esta función como una "
"prueba. También podríamos tener funciones que no son de prueba en el módulo de "
"pruebas para ayudar a configurar escenarios comunes o realizar operaciones comunes, "
"por lo que siempre debemos indicar qué funciones son pruebas."

#: src/ch08-01-how-to-write-tests.md:60
msgid ""
"The example function body uses the `assert` function, which contains the result of "
"adding 2 and 2, equals 4. This assertion serves as an example of the format for a "
"typical test. Let’s run it to see that this test passes."
msgstr ""
"El cuerpo de la función de ejemplo utiliza la función `assert`, que comprueba que "
"el resultado de sumar 2 y 2 es igual a 4. Esta afirmación sirve como ejemplo del "
"formato de una prueba típica. Ejecutémoslo para ver que esta prueba pasa."

#: src/ch08-01-how-to-write-tests.md:62
msgid ""
"The `cairo-test .` command runs all tests in our project, as shown in Listing 8-2."
msgstr ""
"El comando `cairo-test .` ejecuta todas las pruebas en nuestro proyecto, como se "
"muestra en el Listado 8-2."

#: src/ch08-01-how-to-write-tests.md:64
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:71
msgid "Listing 8-2: The output from running a test"
msgstr "Listado 8-2: Resultados de la ejecución de una prueba"

#: src/ch08-01-how-to-write-tests.md:73
msgid ""
"`cairo-test` compiled and ran the test. We see the line `running 1 tests`. The next "
"line shows the name of the generated test function, called `it_works`, and that the "
"result of running that test is `ok`. The overall summary `test result: ok.` means "
"that all the tests passed, and the portion that reads `1 passed; 0 failed` totals "
"the number of tests that passed or failed."
msgstr ""
"`cairo-test` compiló y ejecutó la prueba. Vemos la línea `running 1 tests`. La "
"siguiente línea muestra el nombre de la función de prueba generada, llamada "
"`it_works`, y que el resultado de ejecutar esa prueba es `ok`. El resumen general "
"`test result: ok.` significa que todas las pruebas pasaron, y la porción que lee `1 "
"passed; 0 failed` totaliza el número de pruebas que pasaron o fallaron."

#: src/ch08-01-how-to-write-tests.md:75
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular instance; "
"we’ll cover that in the [Ignoring Some Tests Unless Specifically Requested]"
"(#ignoring-some-tests-unless-specifically-requested) section later in this chapter. "
"Because we haven’t done that here, the summary shows `0 ignored`. We can also pass "
"an argument to the `cairo-test` command to run only a test whose name matches a "
"string; this is called filtering and we’ll cover that in the [Running Single Tests]"
"(#running-single-tests) section. We also haven’t filtered the tests being run, so "
"the end of the summary shows `0 filtered out`."
msgstr ""
"Es posible marcar una prueba como ignorada para que no se ejecute en una instancia "
"particular; cubriremos eso en la sección [Ignorando algunas pruebas a menos que se "
"soliciten específicamente](#ignoring-some-tests-unless-specifically-requested) más "
"adelante en este capítulo. Debido a que no hemos hecho eso aquí, el resumen muestra "
"`0 ignoradas`. También podemos pasar un argumento al comando `cairo-test` para "
"ejecutar solo una prueba cuyo nombre coincida con una cadena; esto se llama "
"filtrado y lo cubriremos en la sección [Ejecución de pruebas individuales](#running-"
"single-tests). Tampoco hemos filtrado las pruebas que se ejecutan, por lo que el "
"final del resumen muestra `0 filtradas`."

#: src/ch08-01-how-to-write-tests.md:77
msgid ""
"Let’s start to customize the test to our own needs. First change the name of the "
"`it_works` function to a different name, such as `exploration`, like so:"
msgstr ""
"Comencemos a personalizar la prueba según nuestras necesidades. Primero, cambie el "
"nombre de la función `it_works` a un nombre diferente, como `exploration`, así:"

#: src/ch08-01-how-to-write-tests.md:81
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn exploration() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn exploration() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:92
msgid ""
"Then run `cairo-test  -- --path src` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""
"A continuación, ejecute `cairo-test -- --path src` de nuevo. La salida muestra "
"ahora `exploration` en lugar de `it_works`:"

#: src/ch08-01-how-to-write-tests.md:94
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:101
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! Tests fail "
"when something in the test function panics. Each test is run in a new thread, and "
"when the main thread sees that a test thread has died, the test is marked as "
"failed. Enter the new test as a function named `another`, so your _src/lib.cairo_ "
"file looks like Listing 8-3."
msgstr ""
"Ahora agregaremos otra prueba, ¡pero esta vez haremos una prueba que falla! Las "
"pruebas fallan cuando algo en la función de prueba causa un pánico. Cada prueba se "
"ejecuta en un hilo nuevo y cuando el hilo principal ve que un hilo de prueba ha "
"muerto, la prueba se marca como fallida. Agregue la nueva prueba como una función "
"llamada `another`, de modo que su archivo _src/lib.cairo_ se vea como en el Listado "
"8-3."

#: src/ch08-01-how-to-write-tests.md:103
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests{\n"
"    #[test]\n"
"    fn another() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 6, 'Make this test fail');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests{\n"
"    #[test]\n"
"    fn another() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 6, 'Make this test fail');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:114
msgid "Listing 8-3: Adding a second test that will fail"
msgstr "Lista 8-3: Agregando una segunda prueba que fallará"

#: src/ch08-01-how-to-write-tests.md:116
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test adder::lib::tests::another ... fail\n"
"failures:\n"
"    adder::lib::tests::another - panicked with "
"[1725643816656041371866211894343434536761780588 ('Make this test fail'), ].\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::exploration ... ok\n"
"test adder::lib::tests::another ... fail\n"
"failures:\n"
"    adder::lib::tests::another - panicked with "
"[1725643816656041371866211894343434536761780588 ('Make this test fail'), ].\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch08-01-how-to-write-tests.md:126
msgid "Listing 8-4: Test results when one test passes and one test fails"
msgstr "Listing 8-4: Resultados de las pruebas cuando una pasa y otra falla"

#: src/ch08-01-how-to-write-tests.md:128
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new section "
"appears between the individual results and the summary. It displays the detailed "
"reason for each test failure. In this case, we get the details that `another` "
"failed because it panicked with `[1725643816656041371866211894343434536761780588 "
"('Make this test fail'), ]` in the _src/lib.cairo_ file."
msgstr ""
"En lugar de `ok`, la línea `adder::lib::tests::another` muestra `fail`. Aparece una "
"nueva sección entre los resultados individuales y el resumen. Muestra la razón "
"detallada de cada falla de prueba. En este caso, obtenemos los detalles de que "
"`another` falló porque falló con un pánico con "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` en el "
"archivo _src/lib.cairo_."

#: src/ch08-01-how-to-write-tests.md:130
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. We had "
"one test pass and one test fail."
msgstr ""
"La línea de resumen se muestra al final: en general, nuestro resultado de prueba es "
"`FAILED`. Tuvimos una prueba que pasó y otra que falló."

#: src/ch08-01-how-to-write-tests.md:132
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, let’s "
"look at some functions that are useful in tests."
msgstr ""
"Ahora que ha visto cómo son los resultados de las pruebas en diferentes escenarios, "
"veamos algunas funciones que son útiles en las pruebas."

#: src/ch08-01-how-to-write-tests.md:134
msgid "## Checking Results with the assert function"
msgstr "## Verificar Resultados con la función assert"

#: src/ch08-01-how-to-write-tests.md:136
msgid ""
"The `assert` function, provided by Cairo, is useful when you want to ensure that "
"some condition in a test evaluates to `true`. We give the `assert` function a first "
"argument that evaluates to a Boolean. If the value is `true`, nothing happens and "
"the test passes. If the value is `false`, the assert function calls `panic()` to "
"cause the test to fail with a message we defined as the second argument of the "
"`assert` function. Using the `assert` function helps us check that our code is "
"functioning in the way we intend."
msgstr ""
"La función `assert`, proporcionada por Cairo, es útil cuando desea asegurarse de "
"que alguna condición en una prueba se evalúe como verdadera. Le damos a la función "
"`assert` un primer argumento que se evalúa como un valor booleano. Si el valor es "
"`true`, no sucede nada y la prueba pasa. Si el valor es `false`, la función "
"`assert` llama a `panic()` para hacer que la prueba falle con un mensaje que "
"definimos como segundo argumento de la función `assert`. Usar la función `assert` "
"nos ayuda a verificar que nuestro código funciona de la manera que pretendemos."

#: src/ch08-01-how-to-write-tests.md:138
msgid ""
"In [Chapter 4, Listing 5-15](ch04-03-method-syntax.md#multiple-impl-blocks), we "
"used a `Rectangle` struct and a `can_hold` method, which are repeated here in "
"Listing 8-5. Let’s put this code in the _src/lib.cairo_ file, then write some tests "
"for it using the `assert` function."
msgstr ""
"En [Capítulo 4, Lista 5-15](ch04-03-method-syntax.md#multiple-impl-blocks), usamos "
"una estructura `Rectangle` y un método `can_hold`, que se repiten aquí en la Lista "
"8-5. Colocaremos este código en el archivo _src/lib.cairo_, luego escribiremos "
"algunas pruebas para él usando la función `assert`."

#: src/ch08-01-how-to-write-tests.md:142
msgid ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64;\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool;\n"
"}\n"
"\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn area(self: @Rectangle) -> u64 {\n"
"        *self.width * *self.height\n"
"    }\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width > *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:158
msgid ""
"Listing 8-5: Using the `Rectangle` struct and its `can_hold` method from Chapter 5"
msgstr ""
"Lista 8-5: Uso de la estructura `Rectangle` y su método `can_hold` del Capítulo 5"

#: src/ch08-01-how-to-write-tests.md:160
msgid ""
"The `can_hold` method returns a `Boolean`, which means it’s a perfect use case for "
"the assert function. In Listing 8-6, we write a test that exercises the `can_hold` "
"method by creating a `Rectangle` instance that has a width of `8_u64` and a height "
"of `7_u64` and asserting that it can hold another `Rectangle` instance that has a "
"width of `5_u64` and a height of `1_u64`."
msgstr ""
"El método `can_hold` devuelve un valor booleano, lo que significa que es un caso de "
"uso perfecto para la función `assert`. En el Listado 8-6, escribimos una prueba que "
"ejerce el método `can_hold` creando una instancia de `Rectangle` que tiene un ancho "
"de `8_u64` y una altura de `7_u64` y asegurando que puede contener otra instancia "
"de `Rectangle` que tiene un ancho de `5_u64` y una altura de `1_u64`."

#: src/ch08-01-how-to-write-tests.md:164
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Rectangle;\n"
"    use super::RectangleTrait;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle {\n"
"            height: 7_u64,\n"
"            width: 8_u64,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            height: 1_u64,\n"
"            width: 5_u64,\n"
"        };\n"
"\n"
"        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Rectangle;\n"
"    use super::RectangleTrait;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        let larger = Rectangle {\n"
"            height: 7_u64,\n"
"            width: 8_u64,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            height: 1_u64,\n"
"            width: 5_u64,\n"
"        };\n"
"\n"
"        assert(larger.can_hold(@smaller), 'rectangle cannot hold');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:186
msgid ""
"Listing 8-6: A test for `can_hold` that checks whether a larger rectangle can "
"indeed hold a smaller rectangle"
msgstr ""
"Lista 8-6: Un test para `can_hold` que verifica si un rectángulo más grande "
"realmente puede contener un rectángulo más pequeño"

#: src/ch08-01-how-to-write-tests.md:188
msgid ""
"Note that we’ve added two new lines inside the tests module: `use super::Rectangle;"
"` and `use super::RectangleTrait;`. The tests module is a regular module that "
"follows the usual visibility rules. Because the tests module is an inner module, we "
"need to bring the code under test in the outer module into the scope of the inner "
"module."
msgstr ""
"Note que hemos agregado dos nuevas líneas dentro del módulo de pruebas: `use super::"
"Rectangle;` y `use super::RectangleTrait;`. El módulo de pruebas es un módulo "
"regular que sigue las reglas normales de visibilidad. Debido a que el módulo de "
"pruebas es un módulo interno, necesitamos traer el código bajo prueba en el módulo "
"externo al ámbito del módulo interno."

#: src/ch08-01-how-to-write-tests.md:190
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the assert function and passed "
"it the result of calling `larger.can_hold(@smaller)`. This expression is supposed "
"to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"Hemos nombrado nuestro test `larger_can_hold_smaller`, y hemos creado los dos "
"instancias de `Rectangle` que necesitamos. Luego llamamos a la función assert y le "
"pasamos el resultado de llamar a `larger.can_hold(@smaller)`. Esta expresión se "
"supone que devuelve `true`, por lo que nuestra prueba debería pasar. ¡Descubramoslo!"

#: src/ch08-01-how-to-write-tests.md:192
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:199
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller rectangle "
"cannot hold a larger rectangle:"
msgstr ""
"¡Pasó la prueba! Ahora agreguemos otra prueba, esta vez afirmamos que un rectángulo "
"más pequeño no puede contener un rectángulo más grande:"

#: src/ch08-01-how-to-write-tests.md:203
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Rectangle;\n"
"    use super::RectangleTrait;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        // --snip--\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle {\n"
"            height: 7_u64,\n"
"            width: 8_u64,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            height: 1_u64,\n"
"            width: 5_u64,\n"
"        };\n"
"\n"
"        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Rectangle;\n"
"    use super::RectangleTrait;\n"
"\n"
"    #[test]\n"
"    fn larger_can_hold_smaller() {\n"
"        // --snip--\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn smaller_cannot_hold_larger() {\n"
"        let larger = Rectangle {\n"
"            height: 7_u64,\n"
"            width: 8_u64,\n"
"        };\n"
"        let smaller = Rectangle {\n"
"            height: 1_u64,\n"
"            width: 5_u64,\n"
"        };\n"
"\n"
"        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:230
msgid ""
"Because the correct result of the `can_hold` function in this case is `false`, we "
"need to negate that result before we pass it to the assert function. As a result, "
"our test will pass if `can_hold` returns false:"
msgstr ""
"Como el resultado correcto de la función `can_hold` en este caso es `false`, "
"debemos negar ese resultado antes de pasarlo a la función `assert`. Como resultado, "
"nuestro test pasará si `can_hold` devuelve false:"

#: src/ch08-01-how-to-write-tests.md:232
msgid ""
"```shell\n"
"$ cairo-test .\n"
"    running 2 tests\n"
"    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"    running 2 tests\n"
"    test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"    test adder::lib::tests::larger_can_hold_smaller ... ok\n"
"    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:240
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the `can_hold` "
"method by replacing the greater-than sign with a less-than sign when it compares "
"the widths:"
msgstr ""
"¡Dos pruebas que pasan! Ahora veamos qué sucede con los resultados de nuestras "
"pruebas cuando introducimos un error en nuestro código. Cambiaremos la "
"implementación del método `can_hold` reemplazando el signo mayor que (`>`) por un "
"signo menor que (`<`) cuando compara los anchos:"

#: src/ch08-01-how-to-write-tests.md:242
msgid ""
"```rust\n"
"// --snip--\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width < *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// --snip--\n"
"impl RectangleImpl of RectangleTrait {\n"
"    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n"
"        *self.width < *other.width & *self.height > *other.height\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:251
msgid "Running the tests now produces the following:"
msgstr "Ejecutando los test ahora produce lo siguiente:"

#: src/ch08-01-how-to-write-tests.md:253
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"test adder::lib::tests::larger_can_hold_smaller ... fail\n"
"failures:\n"
"   adder::lib::tests::larger_can_hold_smaller - panicked with "
"[167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ].\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::smaller_cannot_hold_larger ... ok\n"
"test adder::lib::tests::larger_can_hold_smaller ... fail\n"
"failures:\n"
"   adder::lib::tests::larger_can_hold_smaller - panicked with "
"[167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ].\n"
"\n"
"Error: test result: FAILED. 1 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch08-01-how-to-write-tests.md:264
msgid ""
"Our tests caught the bug! Because `larger.width` is `8_u64` and `smaller.width` is "
"`5_u64`, the comparison of the widths in `can_hold` now returns `false`: `8_u64` is "
"not less than `5_u64`."
msgstr ""
"Nuestros tests detectaron el error! Debido a que `larger.width` es `8_u64` y "
"`smaller.width` es `5_u64`, la comparación de anchuras en `can_hold` ahora devuelve "
"`false`: `8_u64` no es menor que `5_u64`."

#: src/ch08-01-how-to-write-tests.md:266
msgid "## Checking for Panics with `should_panic`"
msgstr "## Comprobando los pánicos con `should_panic`"

#: src/ch08-01-how-to-write-tests.md:268
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type in "
"Listing 8-8. Other code that uses `Guess` depends on the guarantee that `Guess` "
"instances will contain only values between `1_u64` and `100_u64`. We can write a "
"test that ensures that attempting to create a `Guess` instance with a value outside "
"that range panics."
msgstr ""
"Además de verificar los valores de retorno, es importante verificar que nuestro "
"código maneje las condiciones de error como esperamos. Por ejemplo, consideremos el "
"tipo Guess en el Listing 8-8. Otro código que usa `Guess` depende de la garantía de "
"que las instancias de `Guess` contengan solo valores entre `1_u64` y `100_u64`. "
"Podemos escribir un test que asegure que al intentar crear una instancia de `Guess` "
"con un valor fuera de ese rango, el programa entra en pánico."

#: src/ch08-01-how-to-write-tests.md:270
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The test "
"passes if the code inside the function panics; the test fails if the code inside "
"the function doesn’t panic."
msgstr ""
"Lo hacemos agregando el atributo `should_panic` a nuestra función de prueba. La "
"prueba pasa si el código dentro de la función entra en pánico; la prueba falla si "
"el código dentro de la función no entra en pánico."

#: src/ch08-01-how-to-write-tests.md:272
msgid ""
"Listing 8-8 shows a test that checks that the error conditions of `GuessTrait::new` "
"happen when we expect them to."
msgstr ""
"El Listing 8-8 muestra una prueba que verifica que las condiciones de error de "
"`GuessTrait::new` ocurren cuando esperamos que sucedan."

#: src/ch08-01-how-to-write-tests.md:276
msgid ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Guess {\n"
"    value: u64,\n"
"}\n"
"\n"
"trait GuessTrait {\n"
"    fn new(value: u64) -> Guess;\n"
"}\n"
"\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 | value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200_u64);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use array::ArrayTrait;\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct Guess {\n"
"    value: u64,\n"
"}\n"
"\n"
"trait GuessTrait {\n"
"    fn new(value: u64) -> Guess;\n"
"}\n"
"\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 | value > 100 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"        Guess { value }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200_u64);\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:312
msgid "Listing 8-8: Testing that a condition will cause a panic"
msgstr "Listing 8-8: Probando que una condición causará un pánico"

#: src/ch08-01-how-to-write-tests.md:314
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and before "
"the test function it applies to. Let’s look at the result when this test passes:"
msgstr ""
"Colocamos el atributo `#[should_panic]` después del atributo `#[test]` y antes de "
"la función de prueba a la que se aplica. Veamos el resultado cuando esta prueba "
"pasa:"

#: src/ch08-01-how-to-write-tests.md:316
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:323
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition that "
"the new function will panic if the value is greater than `100_u64`:"
msgstr ""
"Looks good! Now let’s introduce a bug in our code by removing the condition that "
"the new function will panic if the value is greater than `100_u64`:"

#: src/ch08-01-how-to-write-tests.md:325
msgid ""
"```rust\n"
"// --snip--\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// --snip--\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1 and <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:340
msgid "When we run the test in Listing 8-8, it will fail:"
msgstr "Cuando ejecutamos la prueba en el Listado 8-8, fallará:"

#: src/ch08-01-how-to-write-tests.md:342
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - expected panic but finished successfully.\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - expected panic but finished successfully.\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch08-01-how-to-write-tests.md:351
msgid ""
"We don’t get a very helpful message in this case, but when we look at the test "
"function, we see that it’s annotated with `#[should_panic]`. The failure we got "
"means that the code in the test function did not cause a panic."
msgstr ""
"En este caso, no obtenemos un mensaje muy útil, pero cuando miramos la función de "
"prueba, vemos que está anotada con `#[should_panic]`. La falla que obtuvimos "
"significa que el código en la función de prueba no causó un pánico."

#: src/ch08-01-how-to-write-tests.md:353
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would pass "
"even if the test panics for a different reason from the one we were expecting. To "
"make `should_panic` tests more precise, we can add an optional expected parameter "
"to the `should_panic` attribute. The test harness will make sure that the failure "
"message contains the provided text. For example, consider the modified code for "
"`Guess` in Listing 8-9 where the new function panics with different messages "
"depending on whether the value is too small or too large."
msgstr ""
"Las pruebas que usan `should_panic` pueden ser imprecisas. Una prueba con "
"`should_panic` pasaría incluso si la prueba produce un pánico por una razón "
"diferente a la que esperábamos. Para hacer que las pruebas con `should_panic` sean "
"más precisas, podemos agregar un parámetro opcional `expected` al atributo "
"`should_panic`. El sistema de pruebas se asegurará de que el mensaje de error "
"contenga el texto proporcionado. Por ejemplo, considere el código modificado para "
"`Guess` en el Listado 8-9, donde la nueva función genera un pánico con mensajes "
"diferentes dependiendo de si el valor es demasiado pequeño o demasiado grande."

#: src/ch08-01-how-to-write-tests.md:357
msgid ""
"```rust\n"
"// --snip--\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1');\n"
"            panic(data);\n"
"        } else if value > 100_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200_u64);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// --snip--\n"
"impl GuessImpl of GuessTrait {\n"
"    fn new(value: u64) -> Guess {\n"
"        if value < 1_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be >= 1');\n"
"            panic(data);\n"
"        } else if value > 100_u64 {\n"
"            let mut data = ArrayTrait::new();\n"
"            data.append('Guess must be <= 100');\n"
"            panic(data);\n"
"        }\n"
"\n"
"        Guess { value, }\n"
"    }\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::Guess;\n"
"    use super::GuessTrait;\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Guess must be <= 100', ))]\n"
"    fn greater_than_100() {\n"
"        GuessTrait::new(200_u64);\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:388
msgid ""
"Listing 8-9: Testing for a panic with a panic message containing the error message "
"string"
msgstr ""
"Listado 8-9: Prueba para una excepción con un mensaje de excepción que contiene la "
"cadena del mensaje de error"

#: src/ch08-01-how-to-write-tests.md:390
msgid ""
"This test will pass because the value we put in the `should_panic` attribute’s "
"expected parameter is the array of string of the message that the `Guess::new` "
"function panics with. We need to specify the entire panic message that we expect."
msgstr ""
"Esta prueba pasará porque el valor que ponemos en el parámetro esperado del "
"atributo `should_panic` es la matriz de cadenas del mensaje con el que la función "
"`Guess::new` genera la excepción. Necesitamos especificar el mensaje completo de la "
"excepción que esperamos."

#: src/ch08-01-how-to-write-tests.md:392
msgid ""
"To see what happens when a `should_panic` test with an expected message fails, "
"let’s again introduce a bug into our code by swapping the bodies of the if `value < "
"1_u64` and the else if `value > 100_u64` blocks:"
msgstr ""
"Para ver qué sucede cuando una prueba `should_panic` con un mensaje esperado falla, "
"introduzcamos de nuevo un error en nuestro código cambiando los cuerpos de los "
"bloques if `value < 1_u64` y else if `value > 100_u64`:"

#: src/ch08-01-how-to-write-tests.md:394
msgid ""
"```rust\n"
"if value < 1_u64 {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append('Guess must be <= 100');\n"
"    panic(data);\n"
"} else if value > 100_u64 {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append('Guess must be >= 1');\n"
"    panic(data);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"if value < 1_u64 {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append('Guess must be <= 100');\n"
"    panic(data);\n"
"} else if value > 100_u64 {\n"
"    let mut data = ArrayTrait::new();\n"
"    data.append('Guess must be >= 1');\n"
"    panic(data);\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:406
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "Esta vez, cuando ejecutamos la prueba `should_panic`, fallará:"

#: src/ch08-01-how-to-write-tests.md:408
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - panicked with "
"[6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 1 tests\n"
"test adder::lib::tests::greater_than_100 ... fail\n"
"failures:\n"
"   adder::lib::tests::greater_than_100 - panicked with "
"[6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ].\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"

#: src/ch08-01-how-to-write-tests.md:418
msgid ""
"The failure message indicates that this test did indeed panic as we expected, but "
"the panic message did not include the expected string. The panic message that we "
"did get in this case was `Guess must be >= 1`. Now we can start figuring out where "
"our bug is!"
msgstr ""
"El mensaje de fallo indica que este test realmente causó un pánico como "
"esperábamos, pero el mensaje de pánico no incluyó la cadena esperada. El mensaje de "
"pánico que obtuvimos en este caso fue `Guess must be >= 1`. ¡Ahora podemos comenzar "
"a descubrir dónde está nuestro error!"

#: src/ch08-01-how-to-write-tests.md:420
msgid "## Running Single Tests"
msgstr "## Ejecución de Pruebas Individuales"

#: src/ch08-01-how-to-write-tests.md:422
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working on "
"code in a particular area, you might want to run only the tests pertaining to that "
"code. You can choose which tests to run by passing `cairo-test` the name of the "
"test you want to run as an argument."
msgstr ""
"A veces, ejecutar un conjunto completo de pruebas puede llevar mucho tiempo. Si "
"está trabajando en código en un área particular, es posible que desee ejecutar solo "
"las pruebas relacionadas con ese código. Puede elegir qué pruebas ejecutar pasando "
"el nombre de la prueba que desea ejecutar como argumento a `cairo-test`."

#: src/ch08-01-how-to-write-tests.md:424
msgid ""
"To demonstrate how to run a single test, we’ll first create two tests functions, as "
"shown in Listing 8-10, and choose which ones to run."
msgstr ""
"Para demostrar cómo ejecutar una sola prueba, primero crearemos dos funciones de "
"prueba, como se muestra en el Listado 8-10, y elegiremos cuáles ejecutar."

#: src/ch08-01-how-to-write-tests.md:428
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        let result = 3 + 2;\n"
"        assert(result == 5, 'result is not 5');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn add_two_and_two() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn add_three_and_two() {\n"
"        let result = 3 + 2;\n"
"        assert(result == 5, 'result is not 5');\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:445
msgid "Listing 8-10: Two tests with two different names"
msgstr "Listado 8-10: Dos pruebas con dos nombres diferentes"

#: src/ch08-01-how-to-write-tests.md:447
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that test "
"using the `-f` flag:"
msgstr ""
"Podemos pasar el nombre de cualquier función de prueba a `cairo-test` para ejecutar "
"solo esa prueba usando la bandera `-f`:"

#: src/ch08-01-how-to-write-tests.md:449
msgid ""
"```shell\n"
"$ cairo-test . -f add_two_and_two\n"
"running 1 tests\n"
"test adder::lib::tests::add_two_and_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test . -f add_two_and_two\n"
"running 1 tests\n"
"test adder::lib::tests::add_two_and_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:456
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t match that "
"name. The test output lets us know we had one more test that didn’t run by "
"displaying 1 filtered out at the end."
msgstr ""
"Solo se ejecutó la prueba con el nombre `add_two_and_two`; la otra prueba no "
"coincidía con ese nombre. La salida de la prueba nos indica que tuvimos una prueba "
"más que no se ejecutó al mostrar \"1 filtrado\" al final."

#: src/ch08-01-how-to-write-tests.md:458
msgid ""
"We can also specify part of a test name, and any test whose name contains that "
"value will be run."
msgstr ""
"También podemos especificar parte del nombre de una prueba y se ejecutarán todas "
"las pruebas cuyo nombre contenga ese valor."

#: src/ch08-01-how-to-write-tests.md:460
msgid "## Ignoring Some Tests Unless Specifically Requested"
msgstr "## Ignorar Algunos Test a menos que se Soliciten Específicamente"

#: src/ch08-01-how-to-write-tests.md:462
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you might "
"want to exclude them during most runs of `cairo-test`. Rather than listing as "
"arguments all tests you do want to run, you can instead annotate the time-consuming "
"tests using the `ignore` attribute to exclude them, as shown here:"
msgstr ""
"A veces, algunas pruebas específicas pueden ser muy lentas de ejecutar, por lo que "
"es posible que desee excluirlos durante la mayoría de las ejecuciones de `cairo-"
"test`. En lugar de enumerar como argumentos todas las pruebas que desea ejecutar, "
"puede anotar las pruebas que consumen mucho tiempo utilizando el atributo `ignore` "
"para excluirlos, como se muestra aquí:"

#: src/ch08-01-how-to-write-tests.md:466
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() {\n"
"        // code that takes an hour to run\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    #[test]\n"
"    fn it_works() {\n"
"        let result = 2 + 2;\n"
"        assert(result == 4, 'result is not 4');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[ignore]\n"
"    fn expensive_test() {\n"
"        // code that takes an hour to run\n"
"    }\n"
"}\n"
"```"

#: src/ch08-01-how-to-write-tests.md:483
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now "
"when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"Después de `#[test]` agregamos la línea `#[ignore]` al test que queremos excluir. "
"Ahora, cuando ejecutamos nuestros tests, `it_works` se ejecuta pero "
"`expensive_test` no lo hace:"

#: src/ch08-01-how-to-write-tests.md:485
msgid ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::expensive_test ... ignored\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test .\n"
"running 2 tests\n"
"test adder::lib::tests::expensive_test ... ignored\n"
"test adder::lib::tests::it_works ... ok\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;\n"
"```"

#: src/ch08-01-how-to-write-tests.md:493
msgid "The `expensive_test` function is listed as ignored."
msgstr "La función `expensive_test` está listada como ignorada."

#: src/ch08-01-how-to-write-tests.md:495
msgid ""
"When you’re at a point where it makes sense to check the results of the ignored "
"tests and you have time to wait for the results, you can run `cairo-test --include-"
"ignored` to run all tests whether they’re ignored or not."
msgstr ""
"Cuando esté en un punto en el que tenga sentido verificar los resultados de las "
"pruebas ignoradas y tenga tiempo para esperar los resultados, puede ejecutar `cairo-"
"test --include-ignored` para ejecutar todas las pruebas, ya sea que estén ignoradas "
"o no."

#: src/ch08-02-test-organization.md:1
msgid "# Testing Organization"
msgstr "# Organización de Test"

#: src/ch08-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and integration "
"tests. Unit tests are small and more focused, testing one module in isolation at a "
"time, and can test private functions. Integration tests use your code in the same "
"way any other external code would, using only the public interface and potentially "
"exercising multiple modules per test."
msgstr ""
"Pensaremos en las pruebas en términos de dos categorías principales: pruebas "
"unitarias y pruebas de integración. Las pruebas unitarias son pequeñas y más "
"enfocadas, probando un módulo a la vez en aislamiento, y pueden probar funciones "
"privadas. Las pruebas de integración utilizan su código de la misma manera que "
"cualquier otro código externo, utilizando solo la interfaz pública y potencialmente "
"ejercitando varios módulos por prueba."

#: src/ch08-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your library "
"are doing what you expect them to, separately and together."
msgstr ""
"Escribir ambos tipos de pruebas es importante para asegurarse de que las piezas de "
"su biblioteca estén haciendo lo que se espera de ellas, tanto separadas como juntas."

#: src/ch08-02-test-organization.md:7
msgid "## Unit Tests"
msgstr "## Test Unitarios"

#: src/ch08-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the rest "
"of the code to quickly pinpoint where code is and isn’t working as expected. You’ll "
"put unit tests in the `src` directory in each file with the code that they’re "
"testing."
msgstr ""
"El propósito de las pruebas unitarias es probar cada unidad de código en "
"aislamiento del resto del código para identificar rápidamente dónde el código "
"funciona y dónde no lo hace como se esperaba. Colocará las pruebas unitarias en el "
"directorio `src` en cada archivo con el código que están probando."

#: src/ch08-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the test "
"functions and to annotate the module with `cfg(test)`."
msgstr ""
"La convención es crear un módulo llamado `tests` en cada archivo para contener las "
"funciones de prueba y anotar el módulo con `cfg(test)`."

#: src/ch08-02-test-organization.md:13
msgid "### The Tests Module and `#[cfg(test)]`"
msgstr "### El Módulo de Test y `#[cfg(test)]`"

#: src/ch08-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run "
"the test code only when you run `cairo-test`, not when you run `cairo-run`. This "
"saves compile time when you only want to build the library and saves space in the "
"resulting compiled artifact because the tests are not included. You’ll see that "
"because integration tests go in a different directory, they don’t need the "
"`#[cfg(test)]` annotation. However, because unit tests go in the same files as the "
"code, you’ll use `#[cfg(test)]` to specify that they shouldn’t be included in the "
"compiled result."
msgstr ""
"La anotación `#[cfg(test)]` en el módulo de pruebas indica a Cairo que compile y "
"ejecute el código de prueba solo cuando se ejecuta `cairo-test`, no cuando se "
"ejecuta `cairo-run`. Esto ahorra tiempo de compilación cuando solo desea compilar "
"la biblioteca y ahorra espacio en el artefacto compilado resultante porque las "
"pruebas no están incluidas. Verá que debido a que las pruebas de integración van en "
"un directorio diferente, no necesitan la anotación `#[cfg(test)]`. Sin embargo, "
"debido a que las pruebas unitarias van en los mismos archivos que el código, usará "
"`#[cfg(test)]` para especificar que no deben incluirse en el resultado compilado."

#: src/ch08-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of this "
"chapter, we wrote this first test:"
msgstr ""
"Recuerde que cuando creamos el nuevo proyecto `adder` en la primera sección de este "
"capítulo, escribimos esta primera prueba:"

#: src/ch08-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the following "
"item should only be included given a certain configuration option. In this case, "
"the configuration option is `test`, which is provided by Cairo for compiling and "
"running tests. By using the `cfg` attribute, Cairo compiles our test code only if "
"we actively run the tests with `cairo-test`. This includes any helper functions "
"that might be within this module, in addition to the functions annotated with "
"`#[test]`."
msgstr ""
"El atributo `cfg` significa \"configuración\" y le indica a Cairo que el siguiente "
"elemento solo debe incluirse dado una cierta opción de configuración. En este caso, "
"la opción de configuración es `test`, que es proporcionada por Cairo para compilar "
"y ejecutar pruebas. Al usar el atributo `cfg`, Cairo compila nuestro código de "
"prueba solo si ejecutamos activamente las pruebas con `cairo-test`. Esto incluye "
"cualquier función de ayuda que pueda estar dentro de este módulo, además de las "
"funciones anotadas con `#[test]`."

#: src/ch08-02-test-organization.md:34
msgid "## Integration Tests"
msgstr "## Test de Integración"

#: src/ch08-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. Their "
"purpose is to test whether many parts of your library work together correctly. "
"Units of code that work correctly on their own could have problems when integrated, "
"so test coverage of the integrated code is important as well. To create integration "
"tests, you first need a `tests` directory."
msgstr ""
"Las pruebas de integración usan su biblioteca de la misma manera que cualquier otro "
"código. Su propósito es probar si muchas partes de su biblioteca funcionan "
"correctamente juntas. Las unidades de código que funcionan correctamente por sí "
"mismas podrían tener problemas cuando se integran, por lo que también es importante "
"tener cobertura de prueba del código integrado. Para crear pruebas de integración, "
"primero necesita un directorio de `tests`."

#: src/ch08-02-test-organization.md:38
msgid "### The `tests` Directory"
msgstr "### Directorio `tests`"

#: src/ch08-02-test-organization.md:40
msgid ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── src\n"
"    ├── lib.cairo\n"
"│   └── main.cairo\n"
"└── tests\n"
"    ├── lib.cairo\n"
"    └── integration_test.cairo\n"
"```"
msgstr ""
"```shell\n"
"adder\n"
"├── cairo_project.toml\n"
"├── src\n"
"    ├── lib.cairo\n"
"│   └── main.cairo\n"
"└── tests\n"
"    ├── lib.cairo\n"
"    └── integration_test.cairo\n"
"```"

#: src/ch08-02-test-organization.md:53
msgid ""
"> To successfully run your tests with `cairo-test` you will need to update your "
"`cairo_project.toml` file to add the declaration of your `tests` crate.\n"
">\n"
"> ```rust\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> tests = \"tests\"\n"
"> ```"
msgstr ""
"> Para ejecutar correctamente tus pruebas con `cairo-test`, deberás actualizar tu "
"archivo `cairo_project.toml` para agregar la declaración de tu crate `tests`.\n"
">\n"
"> ```rust\n"
"> [crate_roots]\n"
"> adder = \"src\"\n"
"> tests = \"tests\"\n"
"> ```"

#: src/ch08-02-test-organization.md:61
msgid ""
"Each test file is compiled as its own separate crate, that's why whenever you add a "
"new test file you must add it to your _tests/lib.cairo_."
msgstr ""
"Cada archivo de prueba se compila como una entidad separada, por eso cada vez que "
"agregas un nuevo archivo de prueba debes agregarlo a tu archivo _tests/lib.cairo_."

#: src/ch08-02-test-organization.md:63
msgid "<span class=\"filename\">Filename: tests/lib.cairo</span>"
msgstr "<span class=\"filename\">Filename: tests/lib.cairo</span>"

#: src/ch08-02-test-organization.md:65
msgid ""
"```rust\n"
"#[cfg(tests)]\n"
"mod integration_tests;\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(tests)]\n"
"mod integration_tests;\n"
"```"

#: src/ch08-02-test-organization.md:70
msgid "Enter the code in Listing 11-13 into the _tests/integration_test.cairo_ file:"
msgstr ""
"Ingrese el código del Listado 11-13 en el archivo _tests/integration_test.cairo_:"

#: src/ch08-02-test-organization.md:72
msgid "<span class=\"filename\">Filename: tests/integration_test.cairo</span>"
msgstr "<span class=\"filename\">Filename: tests/integration_test.cairo</span>"

#: src/ch08-02-test-organization.md:74
msgid ""
"```rust\n"
"use adder::main;\n"
"\n"
"#[test]\n"
"fn internal() {\n"
"    assert(main::internal_adder(2_u32, 2_u32) == 4_u32, 'internal_adder failed');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use adder::main;\n"
"\n"
"#[test]\n"
"fn internal() {\n"
"    assert(main::internal_adder(2_u32, 2_u32) == 4_u32, 'internal_adder failed');\n"
"}\n"
"```"

#: src/ch08-02-test-organization.md:83
msgid ""
"Each file in the tests directory is a separate crate, so we need to bring our "
"library into each test crate’s scope. For that reason we add `use adder::main` at "
"the top of the code, which we didn’t need in the unit tests."
msgstr ""
"Cada archivo en el directorio de pruebas es una creación separada, por lo que "
"debemos incluir nuestra biblioteca en el alcance de cada creación de prueba. Por "
"esa razón, agregamos `use adder::main` en la parte superior del código, lo cual no "
"necesitábamos en las pruebas unitarias."

#: src/ch08-02-test-organization.md:85
msgid ""
"```shell\n"
"$ cairo-test tests/\n"
"running 1 tests\n"
"test tests::tests_integration::it_adds_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"
msgstr ""
"```shell\n"
"$ cairo-test tests/\n"
"running 1 tests\n"
"test tests::tests_integration::it_adds_two ... ok\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;\n"
"```"

#: src/ch08-02-test-organization.md:92
msgid ""
"The result of the tests is the same as what we've been seeing: one line for each "
"test."
msgstr ""
"El resultado de las pruebas es el mismo que hemos estado viendo: una línea por cada "
"prueba."

#: src/ch09-starknet-smart-contracts.md:1
msgid "# Starknet Smart Contracts"
msgstr "# Contratos Inteligentes en Starknet"

#: src/ch09-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a `main` "
"entrypoint. In the coming sections, you will learn to write and deploy Starknet "
"contracts."
msgstr ""
"En todas las secciones anteriores, principalmente ha escrito programas con un punto "
"de entrada `main`. En las próximas secciones, aprenderá a escribir e implementar "
"contratos inteligentes en Starknet."

#: src/ch09-starknet-smart-contracts.md:5
msgid ""
"Starknet contracts, in simple words, are programs that can run on the Starknet VM. "
"Since they run on the VM, they have access to Starknet’s persistent state, can "
"alter or modify variables in Starknet’s states, communicate with other contracts, "
"and interact seamlessly with the underlying L1."
msgstr ""
"Un contrato inteligente en Starknet en términos simples, es un programa que puede "
"ejecutarse en la VM de Starknet. Dado que se ejecutan en la VM, tienen acceso al "
"estado persistente de Starknet, pueden modificar variables en los estados de "
"Starknet, comunicarse con otros contratos e interactuar sin problemas con la L1 "
"subyacente."

#: src/ch09-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive deeper "
"into this in the next sections."
msgstr ""
"Los contratos inteligentes en Starknet se denotan por el atributo #[contract]. "
"Profundizaremos más en esto en las próximas secciones."

#: src/ch09-00-00-abis-and-cross-contract-interactions.md:1
msgid "# Starknet contracts: ABIs and cross-contract interactions"
msgstr "# Contratos de Starknet: ABIs e interacciones entre cross-contract"

#: src/ch09-00-00-abis-and-cross-contract-interactions.md:3
msgid ""
"The ability of contracts to interact with other smart contracts on the blockchain "
"is a common pattern found in smart contract development."
msgstr ""
"La capacidad de los contratos para interactuar con otros contratos inteligentes en "
"la cadena de bloques es un patrón común en el desarrollo de contratos inteligentes."

#: src/ch09-00-00-abis-and-cross-contract-interactions.md:5
msgid ""
"This chapter covers how cross-contract interactions between Starknet contracts can "
"be achieved. Specifically, you'll learn about ABIs, contract interfaces, the "
"contract and library dispatchers and their low-level system call equivalents!"
msgstr ""
"Este capítulo cubre cómo se pueden lograr interacciones entre contratos multicapa "
"en Starknet. Específicamente, aprenderá sobre ABIs, interfaces de contrato, los "
"despachadores de contratos y bibliotecas y sus equivalentes de llamadas al sistema "
"de nivel inferior"

#: src/ch09-00-01-abis-and-interfaces.md:1
msgid "# ABIs and Contract Interfaces"
msgstr "# ABIs e Interfaces de Contrato"

#: src/ch09-00-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a common "
"practice which enables us to build flexible contracts that can speak with each "
"other."
msgstr ""
"Las interacciones entre contratos inteligentes en una cadena de bloques, también "
"conocidas como \"cross-contract\", son una práctica común que nos permite construir "
"contratos flexibles que puedan comunicarse entre sí."

#: src/ch09-00-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "Para lograr esto en Starknet, se requiere algo que llamamos una interfaz."

#: src/ch09-00-01-abis-and-interfaces.md:7
msgid "## Interface"
msgstr "## Interfaz"

#: src/ch09-00-01-abis-and-interfaces.md:8
msgid ""
"An interface is a list of a contract's function definitions without "
"implementations. In other words, an interface specifies the function declarations "
"(name, parameters, visibility and return value) contained in a smart contract "
"without including the function body."
msgstr ""
"Una interfaz es una lista de definiciones de funciones de un contrato sin "
"implementaciones. En otras palabras, una interfaz especifica las declaraciones de "
"función (nombre, parámetros, visibilidad y valor de retorno) contenidas en un "
"contrato inteligente sin incluir el cuerpo de la función."

#: src/ch09-00-01-abis-and-interfaces.md:10
msgid ""
"Interfaces in Cairo are traits with the `#[abi]` attribute. If you are new to "
"traits, check out the dedicated chapter on [traits](./ch07-02-traits-in-cairo.md)."
msgstr ""
"Las interfaces en Cairo son traits con el atributo `[abi]`. Si eres nuevo en los "
"traits, consulta el capítulo dedicado a [traits](./ch07-02-traits-in-cairo.md)."

#: src/ch09-00-01-abis-and-interfaces.md:12
msgid ""
"For your Cairo code to qualify as an interface, it must meet the following "
"requirements:"
msgstr ""
"Para que tu código de Cairo califique como una interfaz, debe cumplir con los "
"siguientes requisitos:"

#: src/ch09-00-01-abis-and-interfaces.md:14
msgid ""
"1. Must be appended with the `#[abi]` attribute.\n"
"2. Your interface functions should have no implementations.\n"
"3. You must explicitly declare the function's decorator.\n"
"4. Your interface should not declare a constructor.\n"
"5. Your interface should not declare state variables."
msgstr ""
"1. Debe estar marcado con el atributo `[abi]`.\n"
"2. Las funciones de tu interfaz no deben tener implementaciones.\n"
"3. Debes declarar explícitamente el decorador de la función.\n"
"4. Tu interfaz no debe declarar un constructor.\n"
"5. Tu interfaz no debe declarar variables de estado."

#: src/ch09-00-01-abis-and-interfaces.md:20
msgid "Here's a sample interface for an ERC20 token contract:"
msgstr "Aquí hay un ejemplo de una interfaz para un contrato de token ERC20:"

#: src/ch09-00-01-abis-and-interfaces.md:22
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[abi]\n"
"trait IERC20 {\n"
"    #[view]\n"
"    fn name() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn symbol() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn decimals() -> u8;\n"
"\n"
"    #[view]\n"
"    fn total_supply() -> u256;\n"
"\n"
"    #[view]\n"
"    fn balance_of(account: ContractAddress) -> u256;\n"
"\n"
"    #[view]\n"
"    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"\n"
"    #[external]\n"
"    fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, amount: "
"u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[abi]\n"
"trait IERC20 {\n"
"    #[view]\n"
"    fn name() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn symbol() -> felt252;\n"
"\n"
"    #[view]\n"
"    fn decimals() -> u8;\n"
"\n"
"    #[view]\n"
"    fn total_supply() -> u256;\n"
"\n"
"    #[view]\n"
"    fn balance_of(account: ContractAddress) -> u256;\n"
"\n"
"    #[view]\n"
"    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"\n"
"    #[external]\n"
"    fn transfer(recipient: ContractAddress, amount: u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, amount: "
"u256) -> bool;\n"
"\n"
"    #[external]\n"
"    fn approve(spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"```"

#: src/ch09-00-01-abis-and-interfaces.md:56
msgid "<span class=\"caption\">Listing 9-1: A simple ERC20 Interface</span>"
msgstr "<span class=\"caption\">Listado 9-1: Una interfaz simple de ERC20</span>"

#: src/ch09-00-01-abis-and-interfaces.md:58
msgid "## ABIs"
msgstr "## ABIs"

#: src/ch09-00-01-abis-and-interfaces.md:59
msgid ""
"ABI stands for Application Binary Interface. ABIs gives a smart contract the "
"ability to communicate and interact with external applications or other smart "
"contracts. ABIs can be likened to APIs in traditional web development, which helps "
"data flow between applications and servers."
msgstr ""
"ABI significa Interfaz Binaria de Aplicaciones. Los ABI dan a un contrato "
"inteligente la capacidad de comunicarse e interactuar con aplicaciones externas u "
"otros contratos inteligentes. Los ABI se pueden comparar con las API en el "
"desarrollo web tradicional, que ayudan al flujo de datos entre aplicaciones y "
"servidores."

#: src/ch09-00-01-abis-and-interfaces.md:61
msgid ""
"While we write our smart contract logics in high-level Cairo, they are stored on "
"the VM as executable bytecodes which are in binary formats. Since this bytecode is "
"not human readable, it requires interpretation to be understood. This is where ABIs "
"come into play, defining specific methods which can be called to a smart contract "
"for execution."
msgstr ""
"Si bien escribimos nuestras lógicas de contrato inteligente en Cairo de alto nivel, "
"se almacenan en la VM como bytecodes ejecutables que están en formatos binarios. "
"Dado que este bytecode no es legible por humanos, requiere interpretación para ser "
"entendido. Aquí es donde entran en juego los ABI, definiendo métodos específicos "
"que se pueden llamar a un contrato inteligente para su ejecución."

#: src/ch09-00-01-abis-and-interfaces.md:63
msgid ""
"Every contract on Starknet has an Application Binary Interface (ABI) that defines "
"how to encode and decode data when calling its methods."
msgstr ""
"Cada contrato en Starknet tiene una Interfaz Binaria de Aplicaciones (ABI) que "
"define cómo codificar y decodificar datos al llamar a los métodos del contrato "
"inteligente."

#: src/ch09-00-01-abis-and-interfaces.md:65
msgid ""
"In the next chapter, we are going to be looking into how we can call other smart "
"contracts using a `Contract Dispatcher`, `Library Dispatcher`, and `System calls`."
msgstr ""
"En el próximo capítulo, veremos cómo podemos llamar a otros contratos inteligentes "
"utilizando un `Contract Dispatcher`, un `Library Dispatcher`, y `System calls`."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid "# Contract Dispatcher, Library Dispatcher and System calls"
msgstr "# Despachador de Contratos, Despachador de Bibliotecas y Llamadas del Sistema"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is created on Starknet, two dispatchers are "
"automatically created and exported:"
msgstr ""
"Cada vez que se crea una interfaz de contrato en Starknet, se crean automáticamente "
"y exportan dos despachadores:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:4
msgid ""
"1. The Contract Dispatcher\n"
"2. The Library Dispatcher"
msgstr ""
"1. El Despachador de Contratos\n"
"2. El Despachador de Bibliotecas"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:7
msgid ""
"In this chapter, we are going to extensively discuss how these dispatchers work and "
"their usage."
msgstr ""
"En este capítulo, discutiremos en detalle cómo funcionan estos despachadores y su "
"uso."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:9
msgid ""
"To effectively break down the concepts in this chapter, we are going to be using "
"the IERC20 interface from the previous chapter (refer to Listing 9-1):"
msgstr ""
"Para desglosar efectivamente los conceptos en este capítulo, utilizaremos la "
"interfaz IERC20 del capítulo anterior (consulte la Lista 9-1):"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:11
msgid "## Contract Dispatcher"
msgstr "## Despachador de Contratos"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"Contracts annotated with the `#[abi]` attribute are programmed to automatically "
"generate and export the relevant dispatcher logic on compilation. The compiler also "
"generates a new trait, two new structs (one for contract calls, and the other for "
"library calls) and their implementation of this trait. Our interface is expanded "
"into something like this:"
msgstr ""
"Los contratos anotados con el atributo `abi` están programados para generar "
"automáticamente y exportar la lógica de despachador relevante durante la "
"compilación. El compilador también genera un nuevo trait, dos nuevas estructuras "
"(una para llamadas de contrato y otra para llamadas de biblioteca) y su "
"implementación de este trait. Nuestra interfaz se expande en algo como esto:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid ""
"```rust\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn get_name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: starknet::ContractAddress,\n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait::<IERC20Dispatcher> {\n"
"    fn get_name(self: IERC20Dispatcher) -> felt252 {\n"
"        // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(self: IERC20Dispatcher, recipient: ContractAddress, amount: u256) "
"{\n"
"        // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn get_name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct IERC20Dispatcher {\n"
"    contract_address: starknet::ContractAddress,\n"
"}\n"
"\n"
"impl IERC20DispatcherImpl of IERC20DispatcherTrait::<IERC20Dispatcher> {\n"
"    fn get_name(self: IERC20Dispatcher) -> felt252 {\n"
"        // starknet::call_contract_syscall is called in here\n"
"    }\n"
"    fn transfer(self: IERC20Dispatcher, recipient: ContractAddress, amount: u256) "
"{\n"
"        // starknet::call_contract_syscall is called in here\n"
"    }\n"
"}\n"
"```"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:34
msgid ""
"<span class=\"caption\">Listing 9-2: An expanded form of the IERC20 trait</span>"
msgstr ""
"<span class=\"caption\">Listado 9-2: Una forma expandida de la interfaz IERC20</"
"span>"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:36
msgid ""
"**NB:** The expanded code for our IERC20 interface is a lot more robust, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `get_name`, and one external function `transfer`."
msgstr ""
"**Nota:** El código expandido para nuestra interfaz IERC20 es mucho más robusto, "
"pero para mantener este capítulo conciso y al grano, nos enfocamos en una función "
"de vista `get_name` y una función externa `transfer`."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:38
msgid ""
"It's also worthy of note that all these is abstracted behind the scenes thanks to "
"the power of Cairo plugins."
msgstr ""
"También es digno de mención que todo esto se abstrae detrás de escena, gracias al "
"poder de los complementos de Cairo."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:40
msgid "### Calling Contracts using the Contract Dispatcher"
msgstr "### Llamando contratos usando el Dispatcher de Contrato"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid ""
"This is an example of a contract named `Dispatcher` using the Contract interface "
"dispatcher to call an ERC-20 contract in the ERC-20 contract's context and, in the "
"case of `transfer_token`, altering the state of the ERC-20 contract:"
msgstr ""
"Este es un ejemplo de un contrato llamado `Dispatcher` que utiliza la interfaz "
"Contract dispatcher para llamar a un contrato ERC-20 en el contexto del contrato "
"ERC-20 y, en el caso de `transfer_token`, alterar el estado del contrato ERC-20:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:43
msgid ""
"```rust\n"
"//**** Specify interface here ****//\n"
"\n"
"#[contract]\n"
"mod Dispatcher {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[view]\n"
"    fn token_name(\n"
"        _contract_address: ContractAddress\n"
"    ) -> felt252 {\n"
"        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
"    } \n"
"\n"
"    #[external]\n"
"    fn transfer_token(\n"
"        _contract_address: ContractAddress, recipient: ContractAddress, amount: "
"u256\n"
"    ) -> bool {\n"
"        IERC20Dispatcher {contract_address: _contract_address }.transfer(recipient, "
"amount)\n"
"    } \n"
"}\n"
"```"
msgstr ""
"```rust\n"
"//**** Specify interface here ****//\n"
"\n"
"#[contract]\n"
"mod Dispatcher {\n"
"    use super::IERC20DispatcherTrait;\n"
"    use super::IERC20Dispatcher;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[view]\n"
"    fn token_name(\n"
"        _contract_address: ContractAddress\n"
"    ) -> felt252 {\n"
"        IERC20Dispatcher {contract_address: _contract_address }.name()\n"
"    } \n"
"\n"
"    #[external]\n"
"    fn transfer_token(\n"
"        _contract_address: ContractAddress, recipient: ContractAddress, amount: "
"u256\n"
"    ) -> bool {\n"
"        IERC20Dispatcher {contract_address: _contract_address }.transfer(recipient, "
"amount)\n"
"    } \n"
"}\n"
"```"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:67
msgid ""
"<span class=\"caption\">Listing 9-3: A sample contract which uses the Contract "
"Dispatcher</span>"
msgstr ""
"<span class=\"caption\">Listado 9-3: Un ejemplo de contrato que utiliza el Contract "
"Dispatcher</span>"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:69
msgid ""
"As you can see, we had to first import the `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` which was generated and exported on compiling our interface, "
"then we make calls to the methods implemented for the `IERC20Dispatcher` struct "
"(`name`, `transfer`, etc), passing in the `contract_address` parameter which "
"represents the address of the contract we want to call."
msgstr ""
"Como se puede observar, primero tuvimos que importar `IERC20DispatcherTrait` e "
"`IERC20Dispatcher`, los cuales fueron generados y exportados al compilar nuestra "
"interfaz. Luego realizamos llamadas a los métodos implementados para la estructura "
"`IERC20Dispatcher` (`name`, `transfer`, etc.), pasando el parámetro "
"`contract_address` que representa la dirección del contrato que queremos llamar."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:71
msgid "## Library Dispatcher"
msgstr "## Dispatcher de Biblioteca"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:72
msgid ""
"The key difference between the contract dispatcher and the library dispatcher is "
"that while the contract dispatcher calls an external contract's logic in the "
"external contract's context, the library dispatcher calls the target contract's "
"classhash, whilst executing the call in the calling contract's context. \n"
"So unlike the contract dispatcher, calls made using the library dispatcher have no "
"possibility of tampering with the target contract's state."
msgstr ""
"La principal diferencia entre el Dispatcher de Contratos y el Dispatcher de "
"Biblioteca es que, mientras que el Dispatcher de Contratos llama a la lógica de un "
"contrato externo en el contexto del contrato externo, el Dispatcher de Biblioteca "
"llama al hash de clase del contrato objetivo mientras ejecuta la llamada en el "
"contexto del contrato que llama. \n"
"Por lo tanto, a diferencia del Dispatcher de Contratos, las llamadas realizadas "
"utilizando el Dispatcher de Biblioteca no tienen la posibilidad de manipular el "
"estado del contrato objetivo."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:75
msgid ""
"As stated in the previous chapter, contracts annotated with the `#[abi]` macro on "
"compilation generates a new trait, two new structs (one for contract calls, and the "
"other for library calls) and their implementation of this trait. The expanded form "
"of the library traits looks like:"
msgstr ""
"Como se indicó en el capítulo anterior, los contratos anotados con la macro "
"`#[abi]` en la compilación generan un nuevo trait, dos nuevas estructuras (una para "
"llamadas a contratos y otra para llamadas a bibliotecas) y su implementación de "
"este trait. La forma expandida de los traits de biblioteca se ve así:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:77
msgid ""
"```rust\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn get_name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash,\n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait::"
"<IERC20LibraryDispatcher> {\n"
"    fn get_name(self: IERC20LibraryDispatcher) -> felt252 {\n"
"        // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"    fn transfer(self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: "
"u256) {\n"
"        // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait IERC20DispatcherTrait<T> {\n"
"    fn get_name(self: T) -> felt252;\n"
"    fn transfer(self: T, recipient: ContractAddress, amount: u256);\n"
"}\n"
"\n"
"#[derive(Copy, Drop)]\n"
"struct IERC20LibraryDispatcher {\n"
"    class_hash: starknet::ClassHash,\n"
"}\n"
"\n"
"impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait::"
"<IERC20LibraryDispatcher> {\n"
"    fn get_name(self: IERC20LibraryDispatcher) -> felt252 {\n"
"        // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"    fn transfer(self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: "
"u256) {\n"
"        // starknet::syscalls::library_call_syscall  is called in here\n"
"    }\n"
"}\n"
"```"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:97
msgid ""
"<span class=\"caption\">Listing 9-4: An expanded form of the IERC20 trait</span>"
msgstr ""
"<span class=\"caption\">Listado 9-4: Una forma expandida del trait IERC20</span>"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:99
msgid "### Calling Contracts using the Library Dispatcher"
msgstr "### Llamando a Contratos usando el Dispatcher de Biblioteca"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:100
msgid "Below's a sample code on calling contracts using the Library Dispatcher:"
msgstr ""
"A continuación se muestra un código de muestra sobre cómo llamar a contratos "
"utilizando el Dispatcher de Biblioteca:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:102
msgid ""
"```rust\n"
"//**** Specify interface here ****//\n"
"\n"
"use super::IERC20DispatcherTrait;\n"
"use super::IERC20LibraryDispatcher;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[view]\n"
"fn token_name() -> felt252 {\n"
"    IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }."
"name()\n"
"} \n"
"\n"
"#[external]\n"
"fn transfer_token(\n"
"    recipient: ContractAddress, amount: u256\n"
") -> bool {\n"
"    IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }."
"transfer(recipient, amount)\n"
"} \n"
"```"
msgstr ""
"```rust\n"
"//**** Specify interface here ****//\n"
"\n"
"use super::IERC20DispatcherTrait;\n"
"use super::IERC20LibraryDispatcher;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[view]\n"
"fn token_name() -> felt252 {\n"
"    IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }."
"name()\n"
"} \n"
"\n"
"#[external]\n"
"fn transfer_token(\n"
"    recipient: ContractAddress, amount: u256\n"
") -> bool {\n"
"    IERC20LibraryDispatcher { class_hash: starknet::class_hash_const::<0x1234>() }."
"transfer(recipient, amount)\n"
"} \n"
"```"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:121
msgid ""
"<span class=\"caption\">Listing 9-4: A sample contract using the Library "
"Dispatcher</span>"
msgstr ""
"<span class=\"caption\">Listado 9-4: Un contrato de muestra que utiliza el "
"Dispatcher de Biblioteca</span>"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:123
msgid ""
"As you can see, we had to first import the `IERC20DispatcherTrait` and "
"`IERC20LibraryDispatcher` which was generated and exported on compiling our "
"interface, then we make calls to the methods implemented for the "
"`IERC20LibraryDispatcher` struct (`name`, `transfer`, etc), passing in the "
"`class_hash` parameter which represents the class of the contract we want to call."
msgstr ""
"Como se puede ver, primero tuvimos que importar `IERC20DispatcherTrait` e "
"`IERC20LibraryDispatcher`, los cuales fueron generados y exportados al compilar "
"nuestra interfaz. Luego realizamos llamadas a los métodos implementados para la "
"estructura `IERC20LibraryDispatcher` (`name`, `transfer`, etc.), pasando el "
"parámetro `class_hash` que representa la clase del contrato que queremos llamar."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "## Calling Contracts using low-level System calls"
msgstr "## Llamando a Contratos usando llamadas de Sistema de bajo nivel"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:126
msgid ""
"Another way to call other contracts is to use the `starknet::call_contract_syscall` "
"system call. The Dispatchers we described in the previous sections are high-level "
"syntaxes for this low-level system call."
msgstr ""
"Otra forma de llamar a otros contratos es mediante la llamada de sistema `starknet::"
"call_contract_syscall`. Los Dispatchers que describimos en las secciones anteriores "
"son sintaxis de alto nivel para esta llamada de sistema de bajo nivel."

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:128
msgid ""
"Using the system call `starknet::call_contract_syscall` can be handy for customized "
"error handling or possessing more control over the serialization/deserialization of "
"the call data and the returned data. Here's an example demonstrating a low-level "
"`transfer` call:"
msgstr ""
"El uso de la llamada de sistema `starknet::call_contract_syscall` puede ser útil "
"para la personalización del manejo de errores o para tener más control sobre la "
"serialización/deserialización de los datos de llamada y los datos devueltos. Aquí "
"hay un ejemplo que demuestra una llamada de `transfer` de bajo nivel:"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:130
msgid ""
"```rust\n"
"#[external]\n"
"fn transfer_token(\n"
"    address: starknet::ContractAddress, selector: felt252, calldata: "
"Array<felt252>\n"
") -> Span::<felt252> {\n"
"    starknet::call_contract_syscall(address, selector, calldata.span())."
"unwrap_syscall()\n"
"} \n"
"```"
msgstr ""
"```rust\n"
"#[external]\n"
"fn transfer_token(\n"
"    address: starknet::ContractAddress, selector: felt252, calldata: "
"Array<felt252>\n"
") -> Span::<felt252> {\n"
"    starknet::call_contract_syscall(address, selector, calldata.span())."
"unwrap_syscall()\n"
"} \n"
"```"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"<span class=\"caption\">Listing 9-5: A sample contract implementing system calls</"
"span>"
msgstr ""
"<span class=\"caption\">Listado 9-5: Un contrato de muestra que implementa llamadas "
"de sistema</span>"

#: src/ch09-00-02-contract-dispatcher-library-dispatcher-and-system-calls.md:141
msgid ""
"As you can see, rather than pass our function arguments directly, we passed in the "
"contract address, function selector (which is a keccak hash of the function name), "
"and the calldata (function arguments). At the end, we get returned a serialized "
"value which we'll need to deserialize ourselves!"
msgstr ""
"Como se puede ver, en lugar de pasar nuestros argumentos de función directamente, "
"pasamos la dirección del contrato, el selector de la función (que es un hash keccak "
"del nombre de la función) y los datos de llamada (argumentos de función). Al final, "
"se nos devuelve un valor serializado que tendremos que deserializar nosotros mismos"

#: src/appendix-00.md:1
msgid "# Appendix"
msgstr "# Apéndice"

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in your\n"
"Cairo journey."
msgstr ""
"Las siguientes secciones contienen material de referencia que puede resultarle útil "
"en su \n"
"viaje a Cairo."

#: src/appendix-04-useful-development-tools.md:1
msgid "## Appendix A - Useful Development Tools"
msgstr "## Apéndice A - Herramientas de Desarrollo Útiles"

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo\n"
"project provides. We’ll look at automatic formatting, quick ways to apply\n"
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"En este apéndice, hablamos de algunas herramientas de desarrollo útiles que el "
"proyecto Cairo\n"
"proporciona. Veremos el formateo automático, formas rápidas de aplicar\n"
"correcciones de advertencias, un linter, y la integración con IDEs."

#: src/appendix-04-useful-development-tools.md:7
msgid "### Automatic Formatting with `cairo-format`"
msgstr "### Formateo automático con `cairo-format`"

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"The `cairo-format` tool reformats your code according to the community code style.\n"
"Many collaborative projects use `cairo-format` to prevent arguments about which\n"
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"La herramienta `cairo-format` reformatea tu código de acuerdo con el estilo de "
"código de la comunidad. \n"
"Muchos proyectos colaborativos usan `cairo-format` para evitar discusiones sobre \n"
"qué estilo usar al escribir Cairo: todo el mundo formatea su código usando la "
"herramienta."

#: src/appendix-04-useful-development-tools.md:13
msgid "To format any Cairo project, enter the following:"
msgstr "Para formatear cualquier proyecto de Cairo, introduce lo siguiente:"

#: src/appendix-04-useful-development-tools.md:15
msgid ""
"```console\n"
"cairo-format -r\n"
"```"
msgstr ""
"```console\n"
"cairo-format -r\n"
"```"

#: src/appendix-04-useful-development-tools.md:19
msgid ""
"Running this command reformats all the Cairo code in the current directory, "
"recursively. This\n"
"should only change the code style, not the code semantics."
msgstr ""
"Ejecutando este comando reformateará todo el código de Cairo en el directorio "
"actual de forma recursiva. Esto \n"
"solo cambiará el estilo de código, no la semántica del código."

#: src/appendix-04-useful-development-tools.md:22
msgid "### IDE Integration Using `cairo-language-server`"
msgstr "### Integración del IDE Usando `cairo-language-server`"

#: src/appendix-04-useful-development-tools.md:24
msgid ""
"To help IDE integration, the Cairo community recommends using the\n"
"[`cairo-language-server`][cairo-language-server]<!-- ignore -->. This tool is a set "
"of\n"
"compiler-centric utilities that speaks the [Language Server Protocol][lsp]<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to\n"
"communicate with each other. Different clients can use `cairo-language-server`, "
"such as\n"
"[the Cairo extension for Visual Studio Code][vscode-cairo]."
msgstr ""
"Para ayudar con la integración del IDE, la comunidad de Cairo recomienda el uso \n"
"de [`cairo-language-server`][cairo-language-server]<!-- ignore -->. Esta "
"herramienta es un conjunto de \n"
"utilidades centradas en el compilador que utiliza el [Protocolo del Servidor de "
"Lenguaje][lsp]<!--\n"
"ignore --> que es una especificación para que los IDE y los lenguajes de "
"programación se \n"
"comuniquen entre sí. Diferentes clientes pueden utilizar `cairo-language-server`, "
"como la \n"
"extensión [de Cairo extensión para Visual Studio Code][vscode-cairo]."

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Visit the `vscode-cairo` [page][vscode-cairo]<!-- ignore -->\n"
"for installation instructions, You will gain abilities such as autocompletion, jump "
"to\n"
"definition, and inline errors."
msgstr ""
"Visite la página `vscode-cairo` [page][vscode-cairo]<!-- ignore -->\n"
"para obtener instrucciones de instalación, Usted ganará habilidades tales como "
"autocompletado, saltar a\n"
"y errores en línea."
