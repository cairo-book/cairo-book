msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-02-05T19:07:56+03:00\n"
"PO-Revision-Date: 2024-02-05 16:55+0300\n"
"Last-Translator:  <omeraydin2112@gmail.com>\n"
"Language-Team: Turkish <gnome-turk@gnome.org>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr "Cairo Programlama Dili"

#: src/SUMMARY.md:3
msgid "The Cairo Programming Language Foreword Introduction"
msgstr "Cairo Programlama Dili Önsöz Giriş"

#: src/SUMMARY.md:7 src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr "Başlangıç"

#: src/SUMMARY.md:11 src/ch01-01-installation.md:1
#: src/ch01-01-installation.md:19
msgid "Installation"
msgstr "Kurulum"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr ""

#: src/SUMMARY.md:14 src/SUMMARY.md:16
#: src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr "Genel Programlama Kavramları"

#: src/SUMMARY.md:17 src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "Değişkenler ve Değişkenlik"

#: src/SUMMARY.md:18 src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "Veri Türleri"

#: src/SUMMARY.md:19 src/ch02-03-functions.md:1
msgid "Functions"
msgstr "Fonksiyonlar"

#: src/SUMMARY.md:20 src/ch02-04-comments.md:1
msgid "Comments"
msgstr "Yorumlar"

#: src/SUMMARY.md:21 src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "Kontrol Akışı"

#: src/SUMMARY.md:23 src/SUMMARY.md:25 src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr "Ortak Koleksiyonlar"

#: src/SUMMARY.md:26 src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "Diziler"

#: src/SUMMARY.md:27 src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "Sözlükler"

#: src/SUMMARY.md:28 src/ch03-03-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "Özel Veri Yapıları"

#: src/SUMMARY.md:30 src/SUMMARY.md:32
msgid "Understanding Ownership"
msgstr "Sahipliği Anlamak"

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr "Sahiplik Nedir?"

#: src/SUMMARY.md:34 src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "Referanslar ve Anlık Görüntüler"

#: src/SUMMARY.md:36 src/SUMMARY.md:38
#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr "İlgili Verileri Yapılandırmak için Structları Kullanma"

#: src/SUMMARY.md:39 src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "Structları Tanımlama ve Örnekleme"

#: src/SUMMARY.md:40 src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "Structları Kullanan Örnek Bir Program"

#: src/SUMMARY.md:41 src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "Metod Sözdizimi"

#: src/SUMMARY.md:43 src/SUMMARY.md:45
#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr "Enumlar ve Kalıp Eşleştirme"

#: src/SUMMARY.md:46 src/ch06-01-enums.md:1
#: src/ch08-01-generic-data-types.md:186
msgid "Enums"
msgstr "Enumlar"

#: src/SUMMARY.md:47 src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "Eşleştirme Kontrol Akış Yapısı"

#: src/SUMMARY.md:49 src/SUMMARY.md:51
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "Cairo Projelerini Paketler, Kasalar ve Modüllerle Yönetme"

#: src/SUMMARY.md:53 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "Paketler ve Kasalar"

#: src/SUMMARY.md:54 src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "Kapsamı Kontrol Etmek için Modülleri Tanımlama"

#: src/SUMMARY.md:55
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "Modül Ağacındaki Bir Öğeye Başvurma Yolları"

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "'use' Anahtar Sözcüğü ile Yolları Kapsam İçine Alma"

#: src/SUMMARY.md:57 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "Modülleri Farklı Dosyalara Ayırma"

#: src/SUMMARY.md:59 src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "Genel Veri Türleri"

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr "Genel Türler"

#: src/SUMMARY.md:63 src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr "Genel Fonksiyonlar"

#: src/SUMMARY.md:64 src/ch08-02-traits-in-cairo.md:1
msgid "Traits in Cairo"
msgstr "Cairo'daki Özellikler"

#: src/SUMMARY.md:66 src/SUMMARY.md:68 src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr "Cairo Programlarını Test Etme"

#: src/SUMMARY.md:70 src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "Testler Nasıl Yazılır"

#: src/SUMMARY.md:71 src/ch09-02-test-organization.md:1
msgid "Testing Organization"
msgstr "Test Organizasyonu"

#: src/SUMMARY.md:73 src/SUMMARY.md:75
msgid "Error Handling"
msgstr "Hata İşleme"

#: src/SUMMARY.md:77 src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr "Panic ile Kurtarılamayan Hatalar"

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr "Result ile Kurtarılabilir Hatalar"

#: src/SUMMARY.md:80 src/SUMMARY.md:82 src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr "Gelişmiş Özellikler"

#: src/SUMMARY.md:84 src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "Operatörün Aşırı Yüklenmesi"

#: src/SUMMARY.md:85 src/ch11-02-macros.md:1
msgid "Macros"
msgstr "Makrolar"

#: src/SUMMARY.md:86 src/ch11-03-hash.md:19
msgid "Working with Hashes"
msgstr "Hash'lerle Çalışma"

#: src/SUMMARY.md:88
msgid "Starknet smart contracts"
msgstr "Starknet akıllı sözleşmeleri"

#: src/SUMMARY.md:90 src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr "Starknet Akıllı Sözleşmeleri"

#: src/SUMMARY.md:92 src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr "Akıllı sözleşmelere giriş"

#: src/SUMMARY.md:93 src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr "Basit bir sözleşme"

#: src/SUMMARY.md:94 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr "Sözleşmelere daha derinlemesine bir bakış"

#: src/SUMMARY.md:96 src/ch99-01-03-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "Sözleşme Depolama"

#: src/SUMMARY.md:97 src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "Sözleşme Fonksiyonları"

#: src/SUMMARY.md:98
msgid "Contract Events"
msgstr "Sözleşme Olayları"

#: src/SUMMARY.md:99 src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr "Boilerplate'i azaltma"

#: src/SUMMARY.md:100
msgid "Optimizing storage costs"
msgstr "Depolama maliyetlerini optimize etme"

#: src/SUMMARY.md:102
msgid "Components"
msgstr "Bileşenler"

#: src/SUMMARY.md:104
msgid "Under the hood"
msgstr "Kaputun altı"

#: src/SUMMARY.md:105 src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr "Bileşen bağımlılıkları"

#: src/SUMMARY.md:106 src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr "Bileşenleri test etme"

#: src/SUMMARY.md:108
msgid "ABIs and Cross-contract Interactions"
msgstr "ABI'ler ve Sözleşmeler Arası Etkileşimler"

#: src/SUMMARY.md:110
msgid "ABIs and Interfaces"
msgstr "ABI'lar ve Arabirimler"

#: src/SUMMARY.md:111
msgid "Contract Dispatchers, Library Dispatchers and system calls"
msgstr "Sözleşme Dağıtıcıları, Kütüphane Dağıtıcıları ve sistem çağrıları"

#: src/SUMMARY.md:113 src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr "Başka örnekler"

#: src/SUMMARY.md:115 src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "Bir Oylama sözleşmesini dağıtma ve onunla etkileşim kurma"

#: src/SUMMARY.md:117
msgid "L1 \\<\\> L2 Messaging"
msgstr "L1 \\<\\> L2 Mesajlaşma"

#: src/SUMMARY.md:118 src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr "Güvenlikle İlgili Hususlar"

#: src/SUMMARY.md:120 src/appendix-00.md:1
msgid "Appendix"
msgstr "Ek Bilgiler"

#: src/SUMMARY.md:122
msgid "A - Keywords"
msgstr "A - Anahtar Sözcükler"

#: src/SUMMARY.md:123
msgid "B - Operators and Symbols"
msgstr "B - Operatörler ve Semboller"

#: src/SUMMARY.md:124
msgid "C - Derivable Traits"
msgstr "C - Türetilebilir Özellikler"

#: src/SUMMARY.md:125
msgid "D - Useful Development Tools"
msgstr "D - Faydalı Geliştirme Araçları"

#: src/SUMMARY.md:126
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr "E - Yaygın Tipler ve Özellikler ve Cairo Prelüdü"

#: src/SUMMARY.md:127
msgid "F - Installing Cairo binaries"
msgstr "F - Cairo ikili dosyalarının yüklenmesi"

#: src/SUMMARY.md:128
msgid "G - System Calls"
msgstr "G - Sistem Çağrıları"

#: src/title-page.md:3
msgid ""
"By the Cairo Community and its [contributors](https://github.com/cairo-book/"
"cairo-book.github.io). Special thanks to [Starkware](https://starkware.co/) "
"through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager."
"online/) for supporting the creation of this book."
msgstr ""
"Cairo Topluluğu ve [katkıda bulunanlar](https://github.com/cairo-book/"
"cairo-book.github.io) tarafından. Bu kitabın oluşturulmasını destekleyen [Starkwar'e](https://starkware.co/) "
" [OnlyDust](https://www.onlydust.xyz/) aracılığıyla ve [Voyager'a](https://voyager."
"online/) özel teşekkürler."

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo Compiler](https://"
"github.com/starkware-libs/cairo) [version 2.5.1](https://github.com/"
"starkware-libs/cairo/releases). See the “Installation” section of Chapter 1 "
"to install or update Cairo."
msgstr ""
"Bu metin versiyonu, [Cairo Derleyicisi'nin](https://"
"github.com/starkware-libs/cairo) [2.5.1 sürümünü ](https://github.com/"
"starkware-libs/cairo/releases) kullandığınızı varsaymaktadır. Cairo'yu yüklemek veya güncellemek için 1. Bölüm'ün "Kurulum" bölümüne bakın."

#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr "Önsöz"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and "
"gradually became more expressive. The learning curve was initially steep, as "
"Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"2020 yılında, StarkWare, doğrulanabilir hesaplamayı destekleyen Turing-complete bir programlama "
"dili olan Cairo 0'ı yayımladı. Cairo, bir montaj dili olarak başladı ve giderek daha ifade gücü "
"yüksek hale geldi. Öğrenme eğrisi başlangıçta dikti, çünkü Cairo 0.x düşük seviyeli bir dil olup, "
"bir programın yürütülmesi için bir kanıt oluşturmak üzere gerekli olan temel kriptografik primitifleri tamamen soyutlamıyordu."

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the "
"execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"Cairo 1'in yayımlanmasıyla birlikte, geliştirici deneyimi önemli ölçüde iyileşti, mümkün olan yerlerde Cairo "
"mimarisinin altında yatan değişmez bellek modelini soyutlayarak. Rust'tan güçlü bir şekilde esinlenilerek oluşturulan "
"Cairo 1, altında yatan mimarisinin özel bilgisine ihtiyaç duymadan kanıtlanabilir programlar oluşturmanıza yardımcı olmak "
"için tasarlanmıştır, böylece programın kendisine odaklanabilir ve Cairo programlarının genel güvenliğini artırabilirsiniz. "
"Bir Rust VM tarafından desteklenen Cairo programlarının yürütülmesi artık şaşırtıcı derecede hızlıdır, bu da performanstan "
"ödün vermeden kapsamlı bir test paketi oluşturmanıza olanak tanır."

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the "
"Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"Starknet üzerine sözleşmeler dağıtmak isteyen blockchain geliştiricileri, "
"akıllı sözleşmelerini kodlamak için Cairo programlama dilini kullanacaklar. "
"Bu, Starknet OS'nin, işlemler için yürütme izlerini üretmesine olanak tanır ve "
"ardından bir kanıtlayıcı tarafından kanıtlanır, bu da Ethereum L1 üzerinde doğrulanmadan "
"önce Starknet'in durum kökünün güncellenmesi için kullanılır."

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"Ancak, Cairo yalnızca blockchain geliştiricileri için değildir. Genel amaçlı "
"bir programlama dili olarak, bir bilgisayarda kanıtlanması ve daha düşük donanım "
"gereksinimlerine sahip diğer makinelerde doğrulanması faydalı olacak herhangi bir "
"hesaplama için kullanılabilir."

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"Bu kitap, programlama konseptlerine temel bir anlayışa sahip geliştiriciler "
"için tasarlanmıştır. Dostane ve yaklaşılabilir bir metin olarak, sizi Cairo "
"hakkında bilginizi artırmaya, ancak aynı zamanda genel olarak programlama "
"becerilerinizi geliştirmeye yardımcı olmayı amaçlamaktadır. Bu yüzden dalın "
"ve Cairo hakkında bilinmesi gereken her şeyi öğrenmeye hazır olun!"

#: src/ch00-01-foreword.md:13
msgid "— The Cairo community"
msgstr "— Cairo Topluluğu"

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr "Giriş"

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr "Cairo Nedir?"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name. "
"The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""
"Cairo, aynı adı taşıyan sanal bir CPU için tasarlanmış bir programlama "
"dilidir. Bu işlemcinin benzersiz yönü, fiziksel dünyamızın kısıtlamaları için "
"değil, kriptografik olanlar için yaratılmış olmasıdır, bu da herhangi bir programın "
"üzerinde çalıştığının etkin bir şekilde kanıtlanabilmesini sağlar. Bu, güvenmediğiniz "
"bir makinede zaman alıcı işlemler gerçekleştirebileceğiniz ve sonucu daha ucuz bir makinede "
"çok hızlı bir şekilde kontrol edebileceğiniz anlamına gelir. Cairo 0, doğrudan CASM'e, yani "
"Cairo CPU montajına derlenirken, Cairo 1 daha yüksek seviyeli bir dildir. İlk olarak "
"Sierra'ya derlenir, bu da Cairo'nun ara bir temsilidir ve daha sonra CASM'in güvenli bir "
"alt kümesine derlenecektir. Sierra'nın amacı, hesaplama başarısız olduğunda bile CASM'inizin "
"her zaman kanıtlanabilir olmasını sağlamaktır."

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr "Bununla ne yapabilirsin?"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized "
"applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"Cairo, güvenilmeyen makinelerde güvenilir değerler hesaplamanıza olanak "
"tanır. Önemli bir kullanım örneği Starknet'tir, bu da Ethereum ölçeklendirme "
"çözümüdür. Ethereum, her bir kullanıcı ile merkezi olmayan bir uygulama (d-app) "
"arasındaki her etkileşimin tüm katılımcılar tarafından doğrulanmasını sağlayan "
"merkezi olmayan bir blockchain platformudur. Starknet, Ethereum'un üzerine inşa "
"edilmiş bir Katman 2'dir. Ağın tüm katılımcılarının tüm kullanıcı etkileşimlerini "
"doğrulaması yerine, yalnızca kanıtlayıcı olarak adlandırılan tek bir düğüm, programları "
"çalıştırır ve hesaplamaların doğru bir şekilde yapıldığına dair kanıtlar üretir. Bu kanıtlar "
"daha sonra bir Ethereum akıllı sözleşmesi tarafından doğrulanır ve bu, etkileşimlerin kendilerini "
"gerçekleştirmeye kıyasla önemli ölçüde daha az hesaplama gücü gerektirir. Bu yaklaşım, Ethereum "
"güvenliğini korurken artırılmış verimlilik ve azaltılmış işlem maliyetleri sağlar."

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr "Diğer programlama dilleri ile arasındaki farklar nelerdir?"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can "
"be executed in two different ways:"
msgstr ""
"Cairo, özellikle genel maliyetler ve temel avantajlar açısından geleneksel programlama dillerinden "
"oldukça farklıdır. Programınız iki farklı şekilde çalıştırılabilir:"

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"Kanıtlayıcı tarafından çalıştırıldığında, diğer dillerle benzerdir. Cairo'nun "
"sanallaştırılmış olması ve işlemlerin özellikle maksimum verimlilik için "
"tasarlanmamış olması, bazı performans maliyetlerine yol açabilir, ancak bu, "
"optimize edilmesi gereken en önemli kısım değildir."

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"Kanıt bir doğrulayıcı tarafından doğrulandığında, durum biraz farklıdır. Bu, potansiyel "
"olarak birçok küçük makinede doğrulanabileceği için mümkün olduğunca ucuz olmalıdır. Neyse ki, "
"doğrulama hesaplamadan daha hızlıdır ve Cairo, bunu daha da iyileştirecek bazı benzersiz "
"avantajlara sahiptir. Önemli bir avantaj, belirsizliktir (non-determinizm). Bu, kitapta daha "
"sonra daha detaylı ele alacağınız bir konu, ancak fikir, teorik olarak hesaplama için "
"kullanılandan farklı bir algoritma kullanabilmenizdir. Şu anda, geliştiriciler için özel belirsiz "
"kod yazma desteklenmiyor, ancak standart kütüphane performansı artırmak için belirsizlikten "
"yararlanıyor. Örneğin, Cairo'da bir diziyi sıralamanın maliyeti, onu kopyalamakla aynıdır. Çünkü "
"doğrulayıcı dizi sıralamaz, sadece sıralı olduğunu kontrol eder, bu da daha ucuzdur."

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"Dili ayıran bir diğer yönü, bellek modelidir. Cairo'da, bellek erişimi değişmezdir, yani bir "
"değer bir kere belleğe yazıldığında, değiştirilemez. Cairo 1, geliştiricilerin bu kısıtlamalarla "
"çalışmasına yardımcı olan soyutlamalar sağlar, ancak değiştirilebilirliği tam olarak simüle "
"etmez. Bu nedenle, geliştiriciler performansı optimize etmek için programlarında belleği ve "
"veri yapılarını nasıl yönettiklerini dikkatlice düşünmelidir."

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr "Referanslar"

#: src/ch00-00-introduction.md:24
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "Cairo CPU Mimarisi"

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"Cairo, Sierra ve Casm: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md:26
msgid ""
"State of non determinism: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"
msgstr ""
"Determinizm dışı durum: <https://twitter.com/PapiniShahar/"
"status/1638203716535713798>"

#: src/ch01-00-getting-started.md:3
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr ""
"Cairo yolculuğunuza başlayalım! Öğrenilecek çok şey var, ama her yolculuk bir yerden başlar. Bu bölümde, şunları tartışacağız:"

#: src/ch01-00-getting-started.md:5
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr ""
"Linux, macOS ve Windows üzerinde Cairo'nun derleme araç zinciri ve paket yöneticisi olan Scarb'ı kurma."

#: src/ch01-00-getting-started.md:6
msgid "Writing a program that prints `Hello, world!`."
msgstr "`Hello, world!` yazdıran bir program yazma."

#: src/ch01-00-getting-started.md:7
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr "Bir proje oluşturmak ve bir programı çalıştırmak için temel Scarb komutlarını kullanma."

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading [Scarb](https://docs.swmansion."
"com/scarb/docs). Scarb bundles the Cairo compiler and the Cairo language "
"server together in an easy-to-install package so that you can start writing "
"Cairo code right away."
msgstr ""
"Cairo, basitçe Scarb'ı indirerek kurulabilir. Scarb, Cairo derleyicisini ve "
"Cairo dil sunucusunu kolayca kurulabilen bir pakette bir araya getirir, böylece "
"hemen Cairo kodu yazmaya başlayabilirsiniz."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by [Cargo]"
"(https://doc.rust-lang.org/cargo/), Rust’s build system and package manager."
msgstr ""
"Scarb ayrıca Cairo'nun paket yöneticisidir ve Rust'ın derleme sistemi ve paket yöneticisi olan Cargo'dan büyük ölçüde ilham alır."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb, kodunuzu derleme (ister saf Cairo ister Starknet sözleşmeleri), kodunuzun bağlı olduğu kütüphaneleri indirme, "
"bu kütüphaneleri derleme ve VSCode Cairo 1 uzantısı için LSP desteği sağlama gibi birçok görevi sizin için üstlenir."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if "
"you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""
"Daha karmaşık Cairo programları yazdıkça, bağımlılıklar ekleyebilir ve eğer bir projeye Scarb kullanarak başlarsanız, "
"dış kodu ve bağımlılıkları yönetmek çok daha kolay hale gelir."

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Scarb'ı yükleyerek başlayalım."

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr "Scarb'ın Kurulumu"

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr "Gereksinimler"

#: src/ch01-01-installation.md:17
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr ""
"Scarb, `PATH` çevre değişkeninde bir Git yürütülebilir dosyasının bulunmasını gerektirir."

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation instructions](https://"
"docs.swmansion.com/scarb/download). We strongly recommend that you install "
"Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-"
"asdf), a CLI tool that can manage multiple language runtime versions on a "
"per-project basis. This will ensure that the version of Scarb you use to "
"work on a project always matches the one defined in the project settings, "
"avoiding problems related to version mismatches."
msgstr ""
"Scarb'ı kurmak için lütfen [kurulum talimatlarını](https://"
"docs.swmansion.com/scarb/download) izleyin. Scarb'ı, bir "
"proje bazında birden fazla dil çalışma zamanı sürümünü yönetebilen bir "
"CLI aracı olan [asdf aracılığıyla](https://docs.swmansion.com/scarb/download.html#install-via-"
"asdf) kurmanızı şiddetle tavsiye ederiz. Bu, "
"bir projede çalışmak için kullandığınız Scarb sürümünün her zaman proje "
"ayarlarında tanımlanan sürümle eşleşmesini sağlayacak ve sürüm "
"uyumsuzluklarına bağlı problemleri önleyecektir."

#: src/ch01-01-installation.md:25
msgid ""
"Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-"
"started.html) to install all prerequisites."
msgstr ""
"Tüm önkoşulları yüklemek için lütfen [asdf belgelerine](https://asdf-vm.com/guide/getting-"
"started.html) bakın."

#: src/ch01-01-installation.md:27
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the "
"following command:"
msgstr ""
"Yerel olarak asdf'yi kurduktan sonra, aşağıdaki komutla Scarb eklentisini indirebilirsiniz:"

#: src/ch01-01-installation.md:31
msgid "This will allow you to download specific versions:"
msgstr "Bu, belirli sürümleri indirmenize olanak sağlayacaktır:"

#: src/ch01-01-installation.md:35
msgid "and set a global version: "
msgstr "ve genel bir sürüm ayarlayın:"

#: src/ch01-01-installation.md:40
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""
"Aksi takdirde, terminalinizde aşağıdaki komutu çalıştırabilir ve ekrandaki "
"talimatları takip edebilirsiniz. Bu, Scarb'ın en son kararlı sürümünü kuracaktır."

#: src/ch01-01-installation.md:43
msgid "'=https'"
msgstr ""

#: src/ch01-01-installation.md:46
msgid ""
"In both cases, you can verify installation by running the following command "
"in a new terminal session, it should print both Scarb and Cairo language "
"versions, e.g:"
msgstr ""
"Her iki durumda da, yeni bir terminal oturumunda aşağıdaki komutu çalıştırarak kurulumu "
"doğrulayabilirsiniz; bu, hem Scarb hem de Cairo dil sürümlerini yazdırmalıdır, örneğin:"

#: src/ch01-01-installation.md:55
msgid "Installing the VSCode extension"
msgstr "VSCode uzantısının yükleme"

#: src/ch01-01-installation.md:57
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware."
"cairo1). Once installed, go into the extension settings, and make sure to "
"tick the `Enable Language Server` and `Enable Scarb` options."
msgstr ""
"Cairo'nun, sözdizimi vurgulama, kod tamamlama ve diğer yararlı özellikleri "
"sağlayan bir VSCode uzantısı bulunmaktadır. Bunu VSCode Marketplace'ten "
"kurabilirsiniz. Kurduktan sonra, uzantı ayarlarına gidin ve `Dil Sunucusunu Etkinleştir` "
"ve `Scarb'ı Etkinleştir` seçeneklerini işaretlemeyi unutmayın."

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr ""

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first "
"Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"Scarb aracılığıyla Cairo'yu kurduğunuza göre, ilk Cairo programınızı yazma "
"zamanı geldi. Yeni bir dil öğrenirken geleneksel olarak ekrana `Hello, world!` metnini "
"yazdıran küçük bir program yazılır, biz de burada aynısını yapacağız!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Cairo makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. The Cairo team has "
"developed a VSCode extension for the Cairo language that you can use to get "
"the features from the language server and code highlighting. See [Appendix D]"
"(appendix-04-useful-development-tools.md) for more details."
msgstr ""
"Not: Bu kitap, komut satırıyla temel bir aşinalık varsayar. Cairo, düzenleme "
"veya araç kullanımı ya da kodunuzun nerede bulunduğu konusunda özel taleplerde "
"bulunmaz, bu yüzden komut satırı yerine bir tümleşik geliştirme ortamı (IDE) "
"kullanmayı tercih ediyorsanız, favori IDE'nizi kullanmaktan çekinmeyin. Cairo ekibi, "
"dil sunucusundan özellikler ve kod vurgulama alabilmeniz için Cairo diline özel bir "
"VSCode uzantısı geliştirmiştir. Daha fazla detay için [Ek D](appendix-04-useful-development-tools.md)'ye bakın."

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr "Proje Dizini Oluşturma"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in "
"this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"Cairo kodunuzu saklamak için bir dizin oluşturarak başlayacaksınız. Cairo "
"için kodunuzun nerede bulunduğu önemli değildir, ancak bu kitaptaki alıştırmalar "
"ve projeler için, ana dizininizde bir _cairo_projects_ dizini oluşturmanızı ve tüm "
"projelerinizi orada saklamanızı öneririz."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr ""
"Bir terminal açın ve bir _cairo_projects_ dizini oluşturmak için aşağıdaki komutları girin."

#: src/ch01-02-hello-world.md:24
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Linux, macOS ve Windows'ta PowerShell için şunu girin:"

#: src/ch01-02-hello-world.md:31
msgid "For Windows CMD, enter this:"
msgstr "Windows CMD için şunu girin:"

#: src/ch01-02-hello-world.md:34 src/ch01-02-hello-world.md:35
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:38
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"Not: Bundan sonra, kitapta gösterilen her örnek için, bir Scarb proje dizininden "
"çalışacağınızı varsayıyoruz. Scarb kullanmıyorsanız ve örnekleri farklı bir dizinden "
"çalıştırmayı denerseniz, komutları buna göre ayarlamanız veya bir Scarb projesi oluşturmanız gerekebilir."

#: src/ch01-02-hello-world.md:41
msgid "Creating a Project with Scarb"
msgstr "Scarb ile Proje Oluşturma"

#: src/ch01-02-hello-world.md:43
msgid "Let’s create a new project using Scarb."
msgstr "Scarb kullanarak yeni bir proje oluşturalım."

#: src/ch01-02-hello-world.md:45
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr ""
"_cairo_projects_ dizininize gidin (veya kodunuzu saklamaya karar verdiğiniz herhangi "
"bir yere). Sonra aşağıdaki komutu çalıştırın: "


#: src/ch01-02-hello-world.md:51
msgid ""
"It creates a new directory and project called _hello_world_. We’ve named our "
"project _hello_world_, and Scarb creates its files in a directory of the "
"same name."
msgstr ""
"Yeni bir dizin ve _hello_world_ adında bir proje oluşturur. Projemize _hello_world_ adını "
"verdik ve Scarb, dosyalarını aynı adı taşıyan bir dizinde oluşturur. "


#: src/ch01-02-hello-world.md:53
msgid ""
"Go into the _hello_world_ directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""
"`cd hello_world` komutu ile _hello_world_ dizinine gidin. Scarb'ın bizim için iki dosya ve bir "
"dizin oluşturduğunu göreceksiniz: Bir _Scarb.toml_ dosyası ve içinde bir _lib.cairo_ dosyası "
"bulunan bir _src_ dizini. "


#: src/ch01-02-hello-world.md:55
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr ""
"Ayrıca bir `.gitignore` dosyası ile birlikte yeni bir Git deposu başlattı"

#: src/ch01-02-hello-world.md:57
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new -help` to see "
"the available options."
msgstr ""
"Not: Git, yaygın bir versiyon kontrol sistemidir. Versiyon kontrol sistemini kullanmayı `--no-vcs` "
"bayrağını kullanarak durdurabilirsiniz. Kullanılabilir seçenekleri görmek için `scarb new -help` "
"komutunu çalıştırın. "


#: src/ch01-02-hello-world.md:60
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr ""
"_Scarb.toml_ dosyasını tercih ettiğiniz metin düzenleyicisinde açın. Liste 1-2'deki koda benzer görünmelidir."

#: src/ch01-02-hello-world.md:62
msgid "Filename: Scarb.toml"
msgstr "Dosya Adı: Scarb.toml"

#: src/ch01-02-hello-world.md:64
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/"
"docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2023_11\"\n"
"\n"
"# Daha fazla anahtar ve tanımlarına https://docs.swmansion.com/scarb/docs/reference/manifest adresinden bakın."
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of _Scarb.toml_ generated by `scarb new`"
msgstr "Liste 1-2: `scarb new` tarafından oluşturulan _Scarb.toml_ içeriği"

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""
"Bu dosya, [TOML](https://toml.io/) (Tom's Obvious, Minimal Language) formatındadır, bu da Scarb'ın yapılandırma "
"formatıdır. "


#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""
"İlk satır olan `[package]`, takip eden ifadelerin bir paketi yapılandırdığını belirten bir "
"bölüm başlığıdır. Bu dosyaya daha fazla bilgi ekledikçe, diğer bölümleri de ekleyeceğiz. "


#: src/ch01-02-hello-world.md:82
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of "
"the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix E](./"
"appendix-05-common-types-and-traits-and-cairo-prelude.md)"
msgstr ""
"Sonraki üç satır, programınızı derlemek için Scarb'ın ihtiyaç duyduğu yapılandırma bilgilerini "
"ayarlar: paketin adı, kullanılacak Scarb sürümü ve kullanılacak giriş baskısı. Giriş, her Cairo "
"programına otomatik olarak ithal edilen en yaygın kullanılan öğelerin koleksiyonudur. Giriş hakkında "
"daha fazla bilgiyi [Ek E](./appendix-05-common-types-and-traits-and-cairo-prelude.md) bölümünde "
"öğrenebilirsiniz. "

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""
"Son satır olan `[dependencies]`, projenizin bağımlılıklarını listelemek için bir bölümün başlangıcıdır. "
"Cairo'da, kod paketlerine kutu denir. Bu proje için başka hiçbir kutuya ihtiyacımız olmayacak. "


#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb documentation](https://docs."
"swmansion.com/scarb/docs/extensions/starknet/starknet-package.html)."
msgstr ""
"Not: Starknet için sözleşmeler oluşturuyorsanız, [Scarb dokümantasyonunda](https://docs."
"swmansion.com/scarb/docs/extensions/starknet/starknet-package.html) bahsedildiği gibi "
"`starknet` bağımlılığını eklemeniz gerekecek. "


#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""
"Scarb tarafından oluşturulan diğer dosya _src/lib.cairo_ adını taşıyor, şimdi tüm içeriği "
"silelim ve aşağıdaki içeriği ekleyelim, nedenini daha sonra açıklayacağız. "


#: src/ch01-02-hello-world.md:94
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr ""
"Ardından _src/hello_world.cairo_ adında yeni bir dosya oluşturun ve aşağıdaki kodu içine "
"ekleyin: "


#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr "Dosya Adı: src/hello_world.cairo"

#: src/ch01-02-hello-world.md:100 src/ch01-02-hello-world.md:179
msgid "\"Hello, World!\""
msgstr ""

#: src/ch01-02-hello-world.md:104
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"Şimdi _lib.cairo_ adında bir dosya oluşturduk, bu dosya başka bir `hello_world` adlı modülü referans "
"alan bir modül bildirimi içeriyor. Ayrıca `hello_world` modülünün uygulama detaylarını içeren _hello_world.cairo_ "
"dosyasını içeriyor. "


#: src/ch01-02-hello-world.md:106
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr ""
"Scarb, kaynak dosyalarınızın _src_ dizini içinde bulunmasını gerektirir."

#: src/ch01-02-hello-world.md:108
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"Üst düzey proje dizini, README dosyaları, lisans bilgileri, yapılandırma dosyaları ve diğer "
"tüm kodla ilgili olmayan içerikler için ayrılmıştır. Scarb, tüm proje bileşenleri için "
"belirlenmiş bir konum sağlar ve yapılandırılmış bir düzeni korur."


#: src/ch01-02-hello-world.md:111
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""
"Eğer Scarb kullanmayan bir projeye başladıysanız, onu Scarb kullanan bir projeye dönüştürebilirsiniz. "
"Proje kodunu _src_ dizinine taşıyın ve uygun bir _Scarb.toml_ dosyası oluşturun. Ayrıca _src_ klasörünü ve "
"içeriğini içeren _Scarb.toml_ dosyasını oluşturmak için `scarb init` komutunu da kullanabilirsiniz."


#: src/ch01-02-hello-world.md:120
msgid " A sample Scarb project structure"
msgstr "Örnek bir Scarb proje yapısı"

#: src/ch01-02-hello-world.md:122
msgid "Building a Scarb Project"
msgstr "Bir Scarb Projesi Oluşturmak"

#: src/ch01-02-hello-world.md:124
msgid ""
"From your _hello_world_ directory, build your project by entering the "
"following command:"
msgstr ""
"_hello_world_ dizininizden aşağıdaki komutu girerek projenizi oluşturun:"

#: src/ch01-02-hello-world.md:132
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr ""
"Bu komut, _target/dev_ içinde bir `sierra` dosyası oluşturur, şimdilik `sierra` dosyasını göz ardı edelim."


#: src/ch01-02-hello-world.md:134
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""
"Eğer Cairo'yu doğru bir şekilde kurduysanız, `scarb cairo-run` komutunu kullanarak "
"programınızın `main` fonksiyonunu çalıştırabilir ve aşağıdaki çıktıyı görmelisiniz:"


#: src/ch01-02-hello-world.md:143
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to the terminal."
msgstr ""
"İşletim sisteminiz ne olursa olsun, dize `Merhaba, dünya!` terminalde yazdırılmalıdır."


#: src/ch01-02-hello-world.md:146
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer—welcome!"
msgstr ""
"Eğer `Merhaba, dünya!` yazdırıldıysa, tebrikler! Resmi olarak bir "
"Cairo programı yazdınız. Sizi bir Cairo programcısı yapıyor, hoş geldiniz!"

#: src/ch01-02-hello-world.md:149
msgid "Anatomy of a Cairo Program"
msgstr "Bir Cairo Programının Anatomisi"

#: src/ch01-02-hello-world.md:151
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr ""
"Hadi bu "Merhaba, dünya!" programını detaylı bir şekilde inceleyelim. İşte bulmacanın ilk parçası:"

#: src/ch01-02-hello-world.md:160
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"Bu satırlar, `main` adında bir fonksiyon tanımlar. `main` fonksiyonu "
"özeldir: her yürütülebilir Cairo programında her zaman çalışan ilk kod "
"parçasıdır. Burada, ilk satır, parametresiz ve hiçbir değer döndürmeyen `main` "
"adında bir fonksiyonu tanır. Eğer parametreler olsaydı, parantezlerin içine yerleştirilirdi `()`. "


#: src/ch01-02-hello-world.md:165
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"Fonksiyon gövdesi `{}` içine alınmıştır. Cairo, tüm fonksiyon gövdelerinin etrafında "
"süslü parantezler `{}` gerektirir. İyi bir yazım stili, açılı süslü parantezi fonksiyon "
"bildirimiyle aynı satıra koymaktır, araya bir boşluk eklenir."


#: src/ch01-02-hello-world.md:169
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix D]"
"(appendix-04-useful-development-tools.md)). The Cairo team has included this "
"tool with the standard Cairo distribution, as `cairo-run` is, so it should "
"already be installed on your computer!"
msgstr ""
"Not: Eğer Cairo projeleri arasında standart bir stil kullanmak isterseniz, kodunuzu "
"belirli bir stilde biçimlendirmek için kullanılabilen `scarb fmt` ile gelen otomatik "
"biçimlendirme aracını kullanabilirsiniz (daha fazlası için [Ek D](appendix-04-useful-development-tools.md)). Cairo "
"ekibi, bu aracı standart Cairo dağıtımıyla birlikte eklemiştir, bu yüzden muhtemelen "
"bilgisayarınıza zaten yüklenmiştir!"


#: src/ch01-02-hello-world.md:176
msgid "The body of the `main` function holds the following code:"
msgstr "`main` fonksiyonunun gövdesi aşağıdaki kodu içerir:"

#: src/ch01-02-hello-world.md:182
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""
"Bu satır, bu küçük programdaki tüm işi yapar: ekrana "
"metin yazdırır. Burada dikkat edilmesi gereken dört önemli ayrıntı vardır."

#: src/ch01-02-hello-world.md:185
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "İlk olarak, Cairo stili sekme ile değil dört boşluk ile girinti yapmaktır."

#: src/ch01-02-hello-world.md:187
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead, "
"it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in [Chapter Macros](./ch11-02-macros.md). For now, you "
"just need to know that using a `!` means that you’re calling a macro instead "
"of a normal function and that macros don’t always follow the same rules as "
"functions."
msgstr ""
"Ikinci olarak, `println!`, bir Cairo makrosunu çağırır. Eğer bir işlevi "
"çağırsaydı, `println` olarak girilirdi ( `!` olmadan). Cairo makrolarını [Makrolar Bölümü](./ch11-02-macros.md) 'nde "
"daha detaylı olarak tartışacağız. Şimdilik sadece `!` kullanmanızın bir makro çağırdığınızı ve makroların her zaman "
"işlevlerle aynı kuralları izlemediğini bilmeniz yeterlidir."


#: src/ch01-02-hello-world.md:190
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""
"Üçüncü olarak, `\"Hello, world!\"` dizesini görüyorsunuz. Bu dizesini `println!`'a bir "
"argüman olarak geçiriyoruz ve dize ekranınıza yazdırılıyor."


#: src/ch01-02-hello-world.md:192
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""
"Dördüncü olarak, satırı bir noktalı virgül (`;`) ile sonlandırıyoruz, bu ifadenin "
"sona erdiğini ve bir sonrakinin başlamaya hazır olduğunu gösterir. Cairo kodunun "
"çoğu satırı noktalı virgül ile sonlanır."


#: src/ch01-02-hello-world.md:198 src/ch02-05-control-flow.md:302
#: src/ch03-03-custom-data-structures.md:338 src/ch05-03-method-syntax.md:290
#: src/ch07-05-separating-modules-into-different-files.md:98
#: src/ch10-02-recoverable-errors.md:190
msgid "Summary"
msgstr "Özet"

#: src/ch01-02-hello-world.md:200
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "Scarb hakkında şimdiye kadar öğrendiklerimizi özetleyelim:"

#: src/ch01-02-hello-world.md:202
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a "
"specific one, using asdf."
msgstr ""
"asdf kullanarak en son kararlı veya belirli bir Scarb sürümü olmak üzere "
"bir veya birden fazla Scarb sürümü yükleyebiliriz."

#: src/ch01-02-hello-world.md:203
msgid "We can create a project using `scarb new`."
msgstr "`scarb new` kullanarak bir proje oluşturabiliriz"

#: src/ch01-02-hello-world.md:204
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr ""
"Derlenmiş Sierra kodunu oluşturmak için `scarb build` kullanarak bir proje oluşturabiliriz."

#: src/ch01-02-hello-world.md:205
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr "Bir Cairo programını `scarb cairo-run` komutunu kullanarak çalıştırabiliriz."

#: src/ch01-02-hello-world.md:207
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Scarb kullanmanın ek bir avantajı, hangi işletim sistemi üzerinde çalıştığınıza "
"bakılmaksızın komutların aynı olmasıdır. Bu nedenle, bu noktadan itibaren, Linux ve "
"macOS ile Windows arasındaki belirli talimatları artık sağlamayacağız."


#: src/ch01-02-hello-world.md:209
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""
"Cairo yolculuğunuzda harika bir başlangıç yaptınız! Cairo kodu okumaya ve yazmaya "
"alışmak için daha sağlam bir program oluşturmak için harika bir zaman!"


#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"Bu bölüm, hemen hemen her programlama dilinde bulunan kavramları ve bunların Cairo'da nasıl "
"çalıştığını kapsar. Birçok programlama dili, temelde birçok ortak özelliğe sahiptir. Bu bölümde "
"sunulan hiçbir kavram Cairo'ya özgü değildir, ancak bu kavramları Cairo bağlamında tartışacak ve "
"bu kavramları kullanma konusundaki gelenekleri açıklayacağız."


#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""
"Daha spesifik olarak, değişkenler, temel tipler, işlevler, yorumlar ve kontrol "
"akışı hakkında bilgi edineceksiniz. Bu temeller, her Cairo programında bulunacak ve "
"erken öğrenmek size güçlü bir başlangıç yapma imkanı sağlayacaktır."


#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"Cairo, değişmez bir bellek modeli kullanır, yani bir bellek hücresine "
"yazıldığında üzerine yazılamaz, yalnızca okunabilir. Bu değişmez bellek "
"modelini yansıtmak için, Cairo'daki değişkenler varsayılan olarak değişmezdir. Bununla "
"birlikte, dil bu modeli soyutlar ve değişkenlerinizi değişken yapma seçeneği sunar. Cairo'un "
"neden ve nasıl değişmezliği zorladığını ve değişkenlerinizi nasıl "
"değiştirilebilir hale getirebileceğinizi keşfetmeye başlayalım."


#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"Bir değişken değişmez olduğunda, bir değer bir isme bağlandığında, o "
"değeri değiştiremezsiniz. Bu durumu göstermek için, `scarb new variables` komutunu "
"kullanarak _cairo_projects_ dizininizde _variables_ adlı yeni bir proje oluşturun."


#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""
"Ardından, yeni _variables_ dizininde, _src/lib.cairo_ dosyasını açın ve aşağıdaki kod ile değiştirin, ancak henüz derlenmeyecektir:"


#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:83
#: src/ch02-01-variables-and-mutability.md:166 src/ch02-04-comments.md:21
#: src/ch02-04-comments.md:31 src/ch02-05-control-flow.md:11
#: src/ch02-05-control-flow.md:51 src/ch02-05-control-flow.md:104
#: src/ch02-05-control-flow.md:136 src/ch02-05-control-flow.md:173
#: src/ch04-01-what-is-ownership.md:237 src/ch04-01-what-is-ownership.md:283
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:113
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:48
#: src/ch05-01-defining-and-instantiating-structs.md:84
#: src/ch05-01-defining-and-instantiating-structs.md:120
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:48
#: src/ch05-02-an-example-program-using-structs.md:73
#: src/ch05-02-an-example-program-using-structs.md:100
#: src/ch05-02-an-example-program-using-structs.md:135
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:100
#: src/ch05-03-method-syntax.md:141 src/ch05-03-method-syntax.md:194
#: src/ch05-03-method-syntax.md:232
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-how-to-write-tests.md:28 src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:118 src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:206 src/ch09-01-how-to-write-tests.md:311
#: src/ch09-01-how-to-write-tests.md:456 src/ch09-01-how-to-write-tests.md:541
#: src/ch09-01-how-to-write-tests.md:622 src/ch09-01-how-to-write-tests.md:660
#: src/ch09-01-how-to-write-tests.md:696 src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr "Dosya Adı: src/lib.cairo"

#: src/ch02-01-variables-and-mutability.md:23
#: src/ch02-01-variables-and-mutability.md:25
#: src/ch02-01-variables-and-mutability.md:88
#: src/ch02-01-variables-and-mutability.md:90
#: src/ch02-01-variables-and-mutability.md:227
#: src/ch02-01-variables-and-mutability.md:229 src/ch02-03-functions.md:67
#: src/ch02-03-functions.md:261 src/ch02-03-functions.md:295
#: src/ch02-03-functions.md:312
msgid "\"The value of x is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""
"Programı kaydedin ve `scarb cairo-run` kullanarak çalıştırın. Bu çıktıda "
"gösterildiği gibi, bir değişmezlik hatası ile ilgili bir hata mesajı almalısınız:"


#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"Bu örnek, derleyicinin programlarınızdaki hataları bulmanıza nasıl "
"yardımcı olduğunu göstermektedir. Derleyici hataları sinir bozucu olabilir, ancak "
"yalnızca programınızın henüz istediğiniz şekilde güvenli bir şekilde "
"çalışmadığı anlamına gelir; bunlar sadece programcıların iyi olmadığı "
"anlamına gelmez! Deneyimli Caironautes hala derleyici hataları alır."


#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr ""
"Değişmez `x` değişkenine ikinci bir değer atamaya çalıştığınız için `Cannot assign to an immutable variable` hata mesajını aldınız."


#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"Bir değeri değiştirmeye çalıştığımızda derleme zamanı hataları "
"almak önemlidir, çünkü bu özel durumlar hatalara yol açabilir. Kodumuzun "
"bir kısmı, bir değerin asla değişmeyeceği varsayımıyla çalışırken, kodumuzun "
"başka bir kısmı bu değeri değiştirirse, kodun ilk kısmının tasarlandığı şekilde "
"çalışmayabileceği bir durum olabilir. Bu tür bir hatanın nedeni, özellikle ikinci "
"kod parçasının değeri sadece _sometimes_ değiştirdiğinde, sonradan takip etmek zor olabilir."

#: src/ch02-01-variables-and-mutability.md:58
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole "
"class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""
"Cairo, çoğu diğer dilden farklı olarak değişmez belleğe sahiptir. Bu, beklenmedik "
"bir şekilde değerlerin asla değişmeyeceği için tüm hata türünü imkansız kılar. Bu, kodun "
"daha kolay anlaşılmasını sağlar."


#: src/ch02-01-variables-and-mutability.md:62
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"Ancak değişkenler varsayılan olarak değişmez olsalar da, değişken "
"adının önüne `mut` ekleyerek onları değiştirilebilir hale getirebilirsiniz. `mut` eklemek "
"aynı zamanda kodun gelecekteki okuyucularına, bu değişkenle ilişkilendirilen "
"değerin diğer kod parçaları tarafından değiştirileceğini belirterek niyeti iletecektir."


#: src/ch02-01-variables-and-mutability.md:70
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon "
"examining the low-level Cairo Assembly code, it becomes clear that variable "
"mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only "
"difference is that at the Cairo level, the variable is not redeclared so its "
"type cannot change."
msgstr ""
"Ancak bu noktada, bir değişkenin `mut` olarak bildirildiğinde tam olarak ne olduğunu "
"merak ediyor olabilirsiniz, çünkü önceki olarak Cairo'nun belleğinin değişmez olduğunu "
"belirtmiştik. Cevap, _değerin_ değişmez olduğu, ancak _değişkenin_ değişmez olmadığıdır. Değişkenle ilişkilendirilen "
"değer değiştirilebilir. Cairo'da bir değişkenin değiştirilebilir bir şekilde atanması, özünde onu başka bir bellek "
"hücresinde başka bir değere başvuracak şekilde yeniden bildirmekle eşdeğerdir, ancak "
"derleyici bunu sizin için halleder ve `mut` anahtar kelimesi bu durumu açıkça "
"belirtir. Düşük seviyeli Cairo Assembly kodunu incelediğinizde, değişken mutasyonunun, mutasyon "
"işlemlerini değişken gölgesine eşdeğer bir dizi adıma çeviren sözdizimsel şeker olarak "
"uygulandığı açık hale gelir. Tek fark, Cairo seviyesinde değişkenin yeniden "
"bildirilmediği ve bu nedenle türünün değişmediği yerdir."


#: src/ch02-01-variables-and-mutability.md:81
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "Örneğin, _src/lib.cairo_ dosyasını aşağıdaki şekilde değiştirelim"

#: src/ch02-01-variables-and-mutability.md:94
msgid "When we run the program now, we get this:"
msgstr "Programı şimdi çalıştırdığımızda şunu elde ediyoruz"

#: src/ch02-01-variables-and-mutability.md:103
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr ""
"`mut` kullanıldığında `x`'e bağlanan değeri `5`'ten `6`'ya değiştirmemize izin "
"verilir. Sonuçta, mutabiliteyi kullanıp kullanmamaya karar vermek size bağlıdır "
"ve bu, belirli bir durumda neyin daha net olduğuna bağlıdır."

#: src/ch02-01-variables-and-mutability.md:107
msgid "Constants"
msgstr "Sabitler"

#: src/ch02-01-variables-and-mutability.md:109
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr ""
"Değişmez değişkenler gibi, _sabitler_ bir isme bağlanan ve değiştirilmesine izin verilmeyen "
"değerlerdir, ancak sabitler ile değişkenler arasında birkaç fark vardır."


#: src/ch02-01-variables-and-mutability.md:113
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"İlk olarak, sabitlerle `mut` kullanmanıza izin verilmez. Sabitler sadece varsayılan olarak değişmez "
"değildir - her zaman değişmezdirler. Sabitleri `let` anahtar kelimesi yerine `const` anahtar kelimesini "
"kullanarak bildirirsiniz ve değerin türü _mutlaka_ belirtilmelidir. Türleri ve tür açıklamalarını "
"bir sonraki bölüm olan [“Veri Tipleri”](ch02-02-data-types.md) bölümünde ele alacağız, bu nedenle "
"şu anda ayrıntıları düşünmeyin. Sadece türün her zaman açıklanması gerektiğini bilin."


#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr ""
"Sabitler yalnızca global kapsamda bildirilebilir, bu da onları kodun birçok "
"kısmının bilmesi gereken değerler için kullanışlı hale getirir."

#: src/ch02-01-variables-and-mutability.md:123
msgid ""
"The last difference is that constants may natively be set only to a constant "
"expression, not the result of a value that could only be computed at "
"runtime. Only literal constants are currently supported."
msgstr ""
"Son fark, sabitlerin yalnızca bir sabit ifadeye ayarlanabilmesidir, çalışma zamanında "
"hesaplanabilen bir değerin sonucu değil. Şu anda yalnızca literal sabitler desteklenmektedir."


#: src/ch02-01-variables-and-mutability.md:127
msgid "Here’s an example of a constant declaration:"
msgstr "İşte bir sabit bildirim örneği"

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""
"Yine de, `consteval_int!` macrosunu kullanarak bazı hesaplamanın sonucu olan bir `const` değişkeni oluşturmak mümkündür:"


#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"We will dive into more detail about macros in the [dedicated section](./"
"ch11-02-macros.md)."
msgstr ""
"Daha fazla ayrıntıya [özel bölümde](./ch11-02-macros.md) macro'lar hakkında daha fazla ayrıntıya gireceğiz."


#: src/ch02-01-variables-and-mutability.md:141
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr ""
"Cairo'nun sabitler için isimlendirme kuralı, tüm harfleri büyük harf ve kelimeler arasında alt çizgi kullanmaktır."


#: src/ch02-01-variables-and-mutability.md:144
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"Sabitler, programın çalıştığı süre boyunca, bildirildikleri kapsam içinde geçerlidir. Bu özellik, sabitleri "
"programınızın birçok kısmının bilmesi gereken uygulama alanınızdaki değerler için kullanışlı hale "
"getirir, örneğin bir oyuncunun kazanabileceği maksimum puan sayısı veya ışığın hızı gibi."


#: src/ch02-01-variables-and-mutability.md:150
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"Programınız boyunca kullanılan sabit değerlere sabitler olarak isim vermek, bu değerin anlamını "
"kodun gelecekteki bakımını yapacak kişilere iletmek için kullanışlıdır. Ayrıca, eğer "
"sabit değeri gelecekte güncellenmesi gerekiyorsa, kodunuzda değiştirmeniz gereken tek bir yer olmasına yardımcı olur."


#: src/ch02-01-variables-and-mutability.md:155
msgid "Shadowing"
msgstr "Gölgeleme"

#: src/ch02-01-variables-and-mutability.md:157
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same "
"name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of "
"the `let` keyword as follows:"
msgstr ""
"Değişken gölgesi, önceki bir değişkenle aynı ada sahip yeni bir değişkenin bildirilmesini "
"ifade eder. Caironautes, ilk değişkenin ikinci tarafından _gölgelediğini_ söyler, bu da ikinci "
"değişkenin, değişkenin adını kullandığınızda derleyicinin göreceği şey olduğu anlamına gelir. Etkide, ikinci "
"değişken birinciyi gölgeleyerek, değişken adının kullanıldığı herhangi bir kullanımı kendisine alır, ya kendisi "
"gölgelenir ya da kapsam sona erene kadar. Bir değişkeni, aynı değişken adını kullanarak ve `let` anahtar kelimesini "
"kullanımını tekrarlayarak gölgeleyebiliriz, aşağıdaki gibi:"


#: src/ch02-01-variables-and-mutability.md:174
msgid "\"Inner scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:176
msgid "\"Outer scope x value is: {}\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:180
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr ""
"Bu program önce `x`'i `5` değerine bağlar. Sonra, `let x =`'yi tekrarlayarak yeni bir değişken `x` oluşturur "
"ve orijinal değeri alır ve `1` ekler, böylece `x`'in değeri `6` olur. Ardından, "
"süslü parantezlerle oluşturulan iç içe kapsamda, üçüncü `let` ifadesi de `x`'i "
"gölgeleyerek yeni bir değişken oluşturur, önceki değeri `2` ile çarparak `x`'e `12` değerini "
"verir. Bu kapsam sona erdiğinde, iç içe gölgeleme sona erer ve `x` tekrar `6` olur. Bu "
"programı çalıştırdığımızda, aşağıdaki çıktıyı verecektir:"


#: src/ch02-01-variables-and-mutability.md:195
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"Gölgeleme, bir değişkeni `mut` olarak işaretlemeden farklıdır çünkü bu değişkeni "
"yanlışlıkla `let` anahtar kelimesini kullanmadan yeniden atamaya çalışırsak "
"derleme zamanı hatası alırız. `let` kullanarak bir değeri birkaç dönüşüm "
"yapabiliriz, ancak bu dönüşümler tamamlandıktan sonra değişken değiştirilemez olur."


#: src/ch02-01-variables-and-mutability.md:201
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at "
"the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"`mut` ve gölgeleme arasındaki bir başka fark, `let` anahtar kelimesini "
"tekrar kullandığımızda etkili bir şekilde yeni bir değişken oluşturuyor "
"olmamızdır, bu da aynı adı yeniden kullanarak değerin türünü değiştirmemize "
"olanak tanır. Daha önce belirtildiği gibi, değişken gölgeleme ve değişkenler "
"de düşük düzeyde eşdeğerdir. Tek fark, bir değişkeni gölgelediğinizde derleyici, "
"türünü değiştirirseniz şikayet etmez. Örneğin, programımız `u64` "
"ve `felt252` türleri arasında bir tür dönüşümü gerçekleştirirse."


#: src/ch02-01-variables-and-mutability.md:212
msgid "\"The value of x is {} of type u64\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:213
msgid "// converts x to a felt, type annotation is required.\n"
msgstr ""

#: src/ch02-01-variables-and-mutability.md:214
msgid "\"The value of x is {} of type felt252\""
msgstr ""

#: src/ch02-01-variables-and-mutability.md:218
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"Ilk `x` değişkeni `u64` türüne sahipken ikinci `x` değişkeni `felt252` türüne "
"sahiptir. Bu nedenle, gölgeleme bize `x_u64` ve `x_felt252` gibi farklı isimler "
"bulma zorunluluğundan kurtarır; bunun yerine daha basit `x` adını yeniden "
"kullanabiliriz. Ancak, bunun için `mut` kullanmaya çalışırsak, burada "
"gösterildiği gibi derleme zamanı hatası alırız:"


#: src/ch02-01-variables-and-mutability.md:233
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr ""
"Hata, bir `u64` (orijinal tür) beklediğimizi ancak farklı bir tür elde ettiğimizi söylüyor:"

#: src/ch02-01-variables-and-mutability.md:246
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr ""
"Artık değişkenlerin nasıl çalıştığını keşfettiğimize göre, sahip olabilecekleri daha fazla veri türüne bakalım."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This "
"section covers two subsets of data types: scalars and compounds."
msgstr ""
"Her Cairo değeri belirli bir veri türüne sahiptir, bu da Cairo'ya "
"hangi tür verinin belirtildiğini söyler, böylece o veriyle nasıl "
"çalışması gerektiğini bilir. Bu bölüm, veri türlerinin iki alt "
"kümesini kapsar: skalerler ve bileşenler."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a conversion method where we specify the "
"desired output type."
msgstr ""
"Cairo'nun statik tipli bir dil olduğunu unutmayın; bu, derleme anında "
"tüm değişkenlerin tiplerini bilmesi gerektiği anlamına gelir. Derleyici, genellikle "
"değerin ve kullanımının istenen türünü, değer ve kullanımına dayalı olarak "
"çıkarabilir. Birden çok türün mümkün olduğu durumlarda, istenen çıktı "
"türünü belirttiğimiz bir dönüşüm yöntemi kullanabiliriz."

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr "Diğer veri türleri için farklı tür ek açıklamaları göreceksiniz."

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr "Skaler Tipler"

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"Bir skaler tip tek bir değeri temsil eder. Cairo'nun üç temel skaler "
"tipi vardır: felt, tamsayılar ve booleanlar. Bunları diğer programlama dillerinden "
"tanıyor olabilirsiniz. Cairo'da nasıl çalıştıklarına geçelim"

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr "Felt Tipi"

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where `P` is a very large prime number "
"currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). When "
"adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of P is added or subtracted to bring the result back "
"within the range (i.e., the result is computed modulo P)."
msgstr ""
"Cairo'da, bir değişkenin veya argümanın türünü belirtmezseniz, türü varsayılan olarak ``felt252`` "
"anahtar sözcüğü ile temsil edilen bir alan öğesi olur. Cairo "
"bağlamında, "bir alan elemanı" dediğimizde \\\\( 0 \\leq x \\< P \\\\) aralığındaki bir tamsayıyı kastediyoruz "
"Burada `P`, şu anda \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\)'e eşit olan çok büyük bir asal sayıdır. "
"Toplama, çıkarma veya çarpma sırasında, sonuç asal sayının belirtilen aralığının dışında "
"kalırsa, bir taşma (veya düşük taşma) meydana gelir ve sonucu aralığa geri getirmek için P'nin "
"uygun bir katı eklenir veya çıkarılır. "

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} \\"
"\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\"
"\\( \\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\"
"\\( \\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` "
"by `y`."
msgstr ""
"En önemli fark, tam sayılar ile alan elemanları arasında bölmedir: Alan " 
"elemanlarının bölünmesi (ve dolayısıyla Cairo'daki bölme) normal CPU bölmesinden " 
"farklıdır, burada tam sayı bölmesi \\\\( \\frac{x}{y} \\\\) \\\\( \\left\\lfloor " 
"\\frac{x}{y} \\right\\rfloor \\\\) olarak tanımlanır ve bölenin tam kısmı geri " 
"döndürülür (bu yüzden \\( \\frac{7}{3} = 2 \\\\) alırsınız) ve bu denklem \\( " 
"\\frac{x}{y} \\cdot y == x \\\\) bağlı olarak `x`'in `y`'e bölünebilirliğine " 
"göre tatmin edilir veya edilmez. "


#: src/ch02-02-data-types.md:35
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\"
"\\( \\frac{6}{2} \\\\) will indeed result in `3`). But when y does not "
"divide x, you may get a surprising result: for example, since \\\\( 2 \\cdot "
"\\frac{P + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\"
"\\( \\frac{1}{2} \\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 "
"or 0.5), as it satisfies the above equation."
msgstr ""
"Cairo'da, \\\\( \\frac{x}{y} \\\\) sonucu her zaman \\\\( \\frac{x}{y} \\cdot y " 
"== x \\\\) denklemini tatmin edecek şekilde tanımlanır. Eğer y, x'i tam sayılar " 
"olarak bölerse, Cairo'da beklenen sonucu alırsınız (örneğin \\( \\frac{6}{2} \\) " 
"gerçekten `3` sonucunu verir). Ancak y, x'i bölmüyorsa, şaşırtıcı bir sonuç alabilirsiniz: " 
"örneğin, \\\\( 2 \\cdot \\frac{P + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\) olduğundan, " 
"Cairo'daki \\( \\frac{1}{2} \\) değeri \\\\( \\frac{P + 1}{2} \\\\) (ve 0 veya 0.5 " 
"değil) olarak tanımlanır, çünkü bu yukarıdaki denklemi tatmin eder. "

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr "Tamsayı Türleri"

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating "
"all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such "
"as overflow and underflow checks. By using these integer types, programmers "
"can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the "
"programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type "
"of an integer value."
msgstr ""
"felt252 türü, temel kütüphanedeki tüm türlerin oluşturulması için temel olarak hizmet veren temel bir türdür. Ancak, programcıların mümkün "
"olduğunda `felt252` türünün yerine `integer` türlerini kullanmaları şiddetle tavsiye edilir, çünkü "
"`integer` türleri, kodda potansiyel zafiyetlere karşı ekstra koruma sağlayan 
"ek güvenlik özellikleri ile gelir, örneğin taşma ve taşma altı kontrolleri. Bu  
"integer türlerini kullanarak, programcılar programlarının daha güvenli ve saldırılara  
"veya diğer güvenlik tehditlerine karşı daha az hassas olduğundan emin olabilirler. Bir  
"`integer`, kesirli bir bileşeni olmayan bir sayıdır. Bu tür bildirimi, programcının  
"integer'ı depolamak için kullanabileceği bit sayısını gösterir. Tablo 3-1, Cairo'daki 
"yerleşik integer türlerini gösterir. Bu çeşitlerden herhangi birini kullanarak integer  
"değerinin türünü beyan edebiliriz."


#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr "Cairo'da Tamsayı Türleri"

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr ""

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr ""

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr ""

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr ""

#: src/ch02-02-data-types.md:53 src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr ""

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr ""

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr ""

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr ""

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr ""

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr ""

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain "
"a negative number. This code will cause the program to panic:"
msgstr ""
"Her çeşidin açık bir boyutu vardır. Şimdilik, `usize` türü sadece `u32` için bir  
"takma addır; ancak, gelecekte Cairo MLIR'ye derlenebilecek olduğunda faydalı  
"olabilir. Değişkenler işaretsiz olduğundan, negatif bir sayı içeremezler. Bu kod  
"programın paniklemesine neden olacaktır: "

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""
"Tüm önceden bahsedilen tam sayı  
"türleri bir `felt252` içine sığar, ancak `u256` saklanmak için 4 fazladan bit  
"ihtiyacı var. Kaputun altında, `u256` temelde 2 alana sahip bir yapıdır: `u256 
"{low: u128, high: u128}`. "

#: src/ch02-02-data-types.md:74
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""
"Cairo ayrıca, `i` öneki ile başlayan işaretli tam sayılar için de destek  
"sağlar. Bu tam sayılar hem pozitif hem de negatif değerleri temsil edebilir,  
"boyutları `i8`'den `i128`'e kadar değişir. Her işaretli çeşit \\\\( -({2^{n -  
"1}}) \\\\) ile \\\\( {2^{n - 1}} - 1 \\\\) arasında sayıları depolayabilir,  
"burada `n`, o çeşidin kullandığı bit sayısıdır. Yani bir i8 \\\\( -({2^7}) \\\\)  
"ile \\\\( {2^7} - 1 \\\\) arasında sayıları depolayabilir, bu da `-128` ile  
"`127`'ye eşittir."


#: src/ch02-02-data-types.md:77
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57_u8`, to designate the type. It is also possible to use a visual "
"separator `_` for number literals, in order to improve code readability."
msgstr ""
"Tam sayı sabitlerini, Tablo 3-2'de gösterilen herhangi bir formatta yazabilirsiniz. 
"Not edin ki, birden fazla sayısal tür olabilen sayı sabitleri, türü belirtmek için  
"`57_u8` gibi bir tür soneki kullanmaya izin verir. Ayrıca, kod okunurluğunu artırmak  
"için sayı sabitlerinde görsel bir ayırıcı `_` kullanmak da mümkündür."


#: src/ch02-02-data-types.md:82
msgid "Table 3-2: Integer Literals in Cairo"
msgstr "Cairo'da Tamsayı Değişmezleri"

#: src/ch02-02-data-types.md:84
msgid "Numeric literals"
msgstr ""

#: src/ch02-02-data-types.md:84 src/appendix-02-operators-and-symbols.md:11
#: src/appendix-07-system-calls.md:177 src/appendix-07-system-calls.md:256
#: src/appendix-07-system-calls.md:331
msgid "Example"
msgstr ""

#: src/ch02-02-data-types.md:86
msgid "Decimal"
msgstr ""

#: src/ch02-02-data-types.md:86
msgid "`98222`"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid "Hex"
msgstr ""

#: src/ch02-02-data-types.md:87
msgid "`0xff`"
msgstr ""

#: src/ch02-02-data-types.md:88
msgid "Octal"
msgstr ""

#: src/ch02-02-data-types.md:88
msgid "`0o04321`"
msgstr ""

#: src/ch02-02-data-types.md:89
msgid "Binary"
msgstr ""

#: src/ch02-02-data-types.md:89
msgid "`0b01`"
msgstr ""

#: src/ch02-02-data-types.md:91
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"Bir tam sayının hangi türünü kullanacağınızı nasıl anlarsınız? Tam sayınızın  
"alabileceği maksimum değeri tahmin etmeye çalışın ve uygun boyutu seçin.  
"`usize` kullanmanın başlıca durumu, bir tür koleksiyonu dizinlendiğinde olur.


#: src/ch02-02-data-types.md:94
msgid "Numeric Operations"
msgstr "Sayısal İşlemler"

#: src/ch02-02-data-types.md:96
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"Cairo, tüm tam sayı türleri için beklediğiniz temel matematik işlemlerini  
"destekler: toplama, çıkarma, çarpma, bölme ve kalan. Tam sayı bölmesi sıfıra  
"doğru kesirli kısmı atarak en yakın tam sayıya yuvarlar. Aşağıdaki kod, bir  
"`let` ifadesinde her bir sayısal işlemi nasıl kullanacağınızı gösterir:"


#: src/ch02-02-data-types.md:103
msgid "// addition\n"
msgstr ""

#: src/ch02-02-data-types.md:106
msgid "// subtraction\n"
msgstr ""

#: src/ch02-02-data-types.md:109
msgid "// multiplication\n"
msgstr ""

#: src/ch02-02-data-types.md:112
msgid "// division\n"
msgstr ""

#: src/ch02-02-data-types.md:113
msgid "//result is 1\n"
msgstr ""

#: src/ch02-02-data-types.md:114
msgid "//result is 2\n"
msgstr ""

#: src/ch02-02-data-types.md:116
msgid "// remainder\n"
msgstr ""

#: src/ch02-02-data-types.md:117
msgid "// result is 3\n"
msgstr ""

#: src/ch02-02-data-types.md:121
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr ""
"Bu ifadelerdeki her bir ifade, matematiksel bir operatör kullanır ve tek bir  
"değere değerlendirilir, ardından bu değer bir değişkene bağlanır.


#: src/ch02-02-data-types.md:124
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list "
"of all operators that Cairo provides."
msgstr ""
"[Ek B](appendix-02-operators-and-symbols.md#operators), Cairo'nun sağladığı  
"tüm operatörlerin bir listesini içerir."


#: src/ch02-02-data-types.md:126
msgid "The Boolean Type"
msgstr "Boolean Türü"

#: src/ch02-02-data-types.md:128
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The "
"Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"Diğer çoğu programlama dilinde olduğu gibi, Cairo'daki bir Boolean türünün  
"iki olası değeri vardır: `true` ve `false`. Booleanlar bir `felt252` boyutundadır.  
"Cairo'da Boolean türü `bool` kullanılarak belirtilir. Örneğin:"


#: src/ch02-02-data-types.md:136
msgid "// with explicit type annotation\n"
msgstr ""

#: src/ch02-02-data-types.md:140
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations. "
msgstr ""
"Bir `bool` değişkeni tanımlarken, değer olarak ya `true` ya da `false`  
"sabitlerinin kullanılması zorunludur. Dolayısıyla, `bool` tanımlamaları için  
"tam sayı sabitleri (yani `0` yerine false) kullanmak mümkün değildir. "


#: src/ch02-02-data-types.md:142
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control "
"Flow”](ch02-05-control-flow.md) section."
msgstr ""
"Boolean değerlerini kullanmanın ana yolu, bir `if` ifadesi gibi koşullulardır.  
"Cairo'da `if` ifadelerinin nasıl çalıştığı [“Kontrol Akışı”](ch02-05-control-flow.md)  
"bölümünde ele alınacaktır."


#: src/ch02-02-data-types.md:146
msgid "The Short String Type"
msgstr "Kısa Dize Türü"

#: src/ch02-02-data-types.md:148
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples "
"of declaring values by putting them between single quotes:"
msgstr ""
"Cairo, yerleşik bir string türüne sahip değildir, ancak `felt252` içinde  
"\"kısa string\" olarak adlandırdığımız karakterleri saklayabilirsiniz. Bir kısa  
"stringin maksimum uzunluğu 31 karakterdir. Bu, tek bir felt içine sığdırılabilmesini  
"sağlamak içindir (bir felt 252 bit, bir ASCII karakteri 8 bittir). İşte tek tırnak  
"arasına değerleri koyarak değer tanımlama örnekleri:"


#: src/ch02-02-data-types.md:153
msgid "'C'"
msgstr ""

#: src/ch02-02-data-types.md:158
msgid "Type Conversion"
msgstr "Tip döküm"

#: src/ch02-02-data-types.md:160
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the "
"`try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"Cairo'da, temel kütüphaneden sağlanan `TryInto` ve `Into` traitlerinin  
"`try_into` ve `into` yöntemlerini kullanarak skaler türleri birbirine  
"çevirebilirsiniz."


#: src/ch02-02-data-types.md:162
msgid ""
"The `try_into` method allows for safe type conversion when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"`try_into` yöntemi, hedef tür kaynak değere sığmayabileceği durumlarda güvenli  
"tür dönüşümü sağlar. `try_into`'nun bir `Option<T>` türü döndürdüğünü ve yeni  
"değere erişmek için bunun açılması gerektiğini unutmayın."


#: src/ch02-02-data-types.md:164
msgid ""
"On the other hand, the `into` method can be used for type conversion when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""
"Diğer yandan, `into` yöntemi, kaynak tür hedef türden daha küçük olduğu gibi, 
"başarının garanti edildiği tür dönüşümleri için kullanılabilir."


#: src/ch02-02-data-types.md:166
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to convert it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"Dönüşümü gerçekleştirmek için, kaynak değeri başka bir türe dönüştürmek için  
"`var.into()` veya `var.try_into()` çağırın. Yeni değişkenin türü, aşağıdaki 
"örnekte gösterildiği gibi açıkça tanımlanmalıdır."


#: src/ch02-02-data-types.md:171
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr ""

#: src/ch02-02-data-types.md:177
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr ""

#: src/ch02-02-data-types.md:185
msgid "The Tuple Type"
msgstr "Tuple Türü"

#: src/ch02-02-data-types.md:187
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""
"Bir _tuple_, çeşitli türlerdeki bir dizi değeri tek bir bileşik tür olarak  
"bir araya getirmenin genel bir yoludur. Tupleların sabit bir uzunluğu vardır:  
"bir kez tanımlandıktan sonra, boyutları büyüyemez veya küçülemez."


#: src/ch02-02-data-types.md:191
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"Bir tuple'ı, parantez içinde virgülle ayrılmış bir değer listesi yazarak  
"oluştururuz. Tupledaki her pozisyonun bir türü vardır ve tupledaki farklı  
"değerlerin türleri aynı olmak zorunda değildir. Bu örnekte isteğe bağlı tür  
"annotasyonları ekledik:"


#: src/ch02-02-data-types.md:202
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a "
"single compound element. To get the individual values out of a tuple, we can "
"use pattern matching to destructure a tuple value, like this:"
msgstr ""
"`tup` değişkeni, bir tuple'ın tek bir bileşik eleman olarak kabul edilmesi  
"nedeniyle tüm tuple'ı bağlar. Bir tupledan tekil değerleri çıkarmak için, bir  
"tuple değerini yapılandırmak için kalıp eşleştirmeyi kullanabiliriz, şöyle ki:"


#: src/ch02-02-data-types.md:213
msgid "\"y is 6!\""
msgstr ""

#: src/ch02-02-data-types.md:218
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"six` as the value of `y` is `6`."
msgstr ""
"Bu program ilk olarak bir tuple oluşturur ve onu `tup` değişkenine bağlar.  
"Ardından `let` ile bir kalıp kullanarak `tup`'ı alır ve onu `x`, `y` ve `z` 
"olmak üzere üç ayrı değişkene dönüştürür. Bu, tek bir tuple'ı üç parçaya  
"ayırması nedeniyle _yapılandırma_ olarak adlandırılır. Son olarak, program  
"`y is six` olarak `y`'nin değerinin `6` olduğunu yazdırır."


#: src/ch02-02-data-types.md:224
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr ""
"Aynı zamanda değer ve türlerle tuple'ı bildirebilir ve onu yapılandırabiliriz. 
"Örneğin:"


#: src/ch02-02-data-types.md:233
msgid "The unit type ()"
msgstr "Birim tipi ()"

#: src/ch02-02-data-types.md:235
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""
"Bir _birim türü_, yalnızca bir değeri `()` olan bir türdür. Hiçbir elemanı  
"olmayan bir tuple temsil edilir. Boyutu her zaman sıfırdır ve derlenmiş  
"kodda var olmadığı garanti edilir."


#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""
"Fonksiyonlar Cairo kodunda yaygındır. Dilin en önemli fonksiyonlarından birini  
"zaten gördünüz: birçok programın giriş noktası olan `main` fonksiyonu. Ayrıca yeni  
"fonksiyonlar bildirmenize izin veren `fn` anahtar kelimesini de gördünüz."


#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"Cairo kodu, fonksiyon ve değişken adları için geleneksel stil olarak _snake case_  
"kullanır, burada tüm harfler küçük harftir ve alt çizgiler kelimeleri ayırır. İşte bir  
"fonksiyon tanımı içeren bir program örneği:"


#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr ""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr ""

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""
"Bir fonksiyonu Cairo'da `fn`'yi takiben bir fonksiyon adı ve bir parantez kümesi  
"girerek tanımlarız. Süslü parantezler, fonksiyon gövdesinin nerede başlayıp  
"bittiğini derleyiciye söyler."


#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could "
"have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"Tanımladığımız herhangi bir fonksiyonu, adını takiben bir parantez kümesi girerek  
"çağırabiliriz. Programda `another_function` tanımlandığından, `main` fonksiyonunun  
"içinden çağrılabilir. Kaynak kodda `another_function`'ı `main` fonksiyonundan  
"_önce_ tanımladığımızı unutmayın; bunu sonrasında da tanımlayabilirdik. Cairo,  
"fonksiyonlarınızı nerede tanımladığınızı umursamaz, yeter ki çağıran tarafından  
"görülebilecek bir kapsamda tanımlansınlar."


#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it. "
"You should see the following output:"
msgstr ""
"Fonksiyonları daha fazla keşfetmek için Scarb ile _functions_ adında yeni bir  
"proje başlatalım. `another_function` örneğini _src/lib.cairo_ içine yerleştirin ve  
"çalıştırın. Aşağıdaki çıktıyı görmelisiniz:"


#: src/ch02-03-functions.md:45
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""
"Satırlar, `main` fonksiyonunda göründükleri sırayla çalışır. İlk olarak “Hello,  
"world!” mesajı yazdırılır ve ardından `another_function` çağrılır ve onun mesajı  
"yazdırılır."


#: src/ch02-03-functions.md:49
msgid "Parameters"
msgstr "Parametreler"

#: src/ch02-03-functions.md:51
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"Fonksiyonları, fonksiyonun imzasının bir parçası olan özel değişkenler olan _parametreler_  
"ile tanımlayabiliriz. Bir fonksiyonun parametreleri olduğunda, bu parametreler için somut  
"değerler sağlayabilirsiniz. Teknik olarak, somut değerlere _argümanlar_ denir, ancak  
"günlük konuşmada, insanlar genellikle fonksiyonun tanımındaki değişkenler veya fonksiyonu  
"çağırdığınızda geçirilen somut değerler için _parametre_ ve _argüman_ kelimelerini birbirinin  
"yerine kullanır."


#: src/ch02-03-functions.md:59
msgid "In this version of `another_function` we add a parameter:"
msgstr "`another_function`'un bu versiyonunda bir parametre ekliyoruz"

#: src/ch02-03-functions.md:71
msgid "Try running this program; you should get the following output:"
msgstr "Bu programı çalıştırmayı deneyin; aşağıdaki çıktıyı almalısınız"

#: src/ch02-03-functions.md:79
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`, "
"the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"`another_function`'ın bildirimi `x` adında bir parametreye sahiptir. `x`'in türü  
"`felt252` olarak belirtilmiştir. `another_function`'a `5` geçirdiğimizde, `println!` makrosu  
"`x`'i içeren süslü parantez çiftinin olduğu yere format dizgisinde `5` koyar."


#: src/ch02-03-functions.md:83
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr ""
"Fonksiyon imzalarında, her parametrenin türünü _mutlaka_ belirtmelisiniz. Bu, Cairo’nun  
"tasarımında bilinçli bir karardır: fonksiyon tanımlarında tür annotasyonları gerektirmek,  
"kodun geri kalanında ne tür bir şey kastettiğinizi anlamak için derleyicinin neredeyse hiç  
"sizin tarafınızdan bunları kullanmanızı gerektirmez. Derleyici, fonksiyonun hangi türleri  
"beklediğini bildiğinde daha yardımcı hata mesajları verebilir."


#: src/ch02-03-functions.md:89
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""
"Birden fazla parametre tanımlarken, parametre bildirimlerini aşağıdaki gibi virgülle ayırın:"

#: src/ch02-03-functions.md:94
msgid "\"h\""
msgstr ""

#: src/ch02-03-functions.md:98
msgid "\"The measurement is: {value}{unit_label}\""
msgstr ""

#: src/ch02-03-functions.md:102
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second "
"is named `unit_label` and is of type `ByteArray` - Cairo's internal type to "
"represent string literals. The function then prints text containing both the "
"`value` and the `unit_label`."
msgstr ""
"Bu örnek, `value` ve `unit_label` adında iki parametre ile `print_labeled_measurement` adında  
"bir fonksiyon oluşturur. İlk parametre `value` adını taşır ve bir `u128`'dir. İkincisi `unit_label`  
"adında ve `ByteArray` türündedir - Cairo'nun string literallerini temsil etmek için içsel türü.  
"Fonksiyon daha sonra hem `value` hem de `unit_label` içeren bir metin yazdırır."


#: src/ch02-03-functions.md:106
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""
"Bu kodu çalıştırmayı deneyelim. _functions_ projesinin _src/lib.cairo_ dosyasındaki mevcut  
"programı önceki örnekle değiştirin ve `scarb cairo-run` kullanarak çalıştırın:"


#: src/ch02-03-functions.md:115
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""
"Fonksiyonu `value` için `5` değeriyle ve `unit_label` için `\"h\"` değeriyle çağırdığımız için,  
"program çıktısı bu değerleri içerir."


#: src/ch02-03-functions.md:117
msgid "Named parameters"
msgstr "Adlandırılmış parametreler"

#: src/ch02-03-functions.md:119
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"Cairo'da, adlandırılmış parametreler bir fonksiyonu çağırırken argümanların  
"isimlerini belirtmenize olanak tanır. Bu, fonksiyon çağrılarını daha okunabilir  
"ve kendini açıklayıcı hale getirir. Eğer adlandırılmış parametreleri kullanmak  
"istiyorsanız, parametrenin adını ve ona geçirmek istediğiniz değeri belirtmeniz  
"gereklidir. Sözdizimi şöyledir: `parameter_name: value`. Eğer parametre ile aynı  
"ada sahip bir değişken geçirirseniz, `parameter_name: variable_name` yerine  
"sadece `:parameter_name` yazabilirsiniz."


#: src/ch02-03-functions.md:122
msgid "Here is an example:"
msgstr "İşte bir örnek"

#: src/ch02-03-functions.md:137
msgid "Statements and Expressions"
msgstr "Statements ve Expressions"

#: src/ch02-03-functions.md:139
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"Fonksiyon gövdeleri, isteğe bağlı olarak bir expression ile sonlanan bir dizi statement'tan  
"oluşur. Şu ana kadar ele aldığımız fonksiyonlar, bir sonlandırma expression'ı içermemişti,  
"ancak bir statement içinde bir expression görmüşsünüzdür. Cairo bir expression tabanlı dil  
"olduğundan, bu önemli bir ayrımı anlamak önemlidir. Diğer diller aynı ayrımlara sahip değildir,  
"bu yüzden statement'lar ve expression'lar neyi ifade eder ve farklılıkları fonksiyon gövdelerini  
"nasıl etkiler, bunlara bakalım."


#: src/ch02-03-functions.md:147
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr "**Statements**, bazı eylemleri gerçekleştiren ve bir değer döndürmeyen talimatlardır."

#: src/ch02-03-functions.md:149
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "**Expressions** bir sonuç değerine göre değerlendirilir. Şimdi bazı örneklere bakalım."

#: src/ch02-03-functions.md:151
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"Biz aslında zaten statement'lar ve expression'lar kullanmışızdır. Bir değişken oluşturmak ve  
"`let` anahtar kelimesi ile ona bir değer atamak bir statement'dır. Listing 2-1'de, `let y = 6;`  
"bir statement'dır."


#: src/ch02-03-functions.md:161
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr "Liste 2-1: Bir deyim içeren bir `main` fonksiyonu bildirimi"

#: src/ch02-03-functions.md:163
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr ""
"Fonksiyon tanımları da ifadelerdir; önceki örneğin tamamı kendi içinde bir ifadedir."

#: src/ch02-03-functions.md:166
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""
"Statement'lar değer döndürmez. Bu nedenle, bir `let` statement'ını başka bir değişkene  
"atayamazsınız, aşağıdaki kodun yapmaya çalıştığı gibi; bir hata alırsınız:"


#: src/ch02-03-functions.md:175
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "Bu programı çalıştırdığınızda alacağınız hata şuna benzer:"

#: src/ch02-03-functions.md:199
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"`let y = 6` statement'ı bir değer döndürmez, bu yüzden `x`'in bağlanacak bir şeyi yoktur. Bu, C  
"ve Ruby gibi diğer dillerde olanlardan farklıdır, bu dillerde atama, atamanın değerini döndürür.  
"Bu dillerde `x = y = 6` yazabilir ve hem `x` hem de `y`'nin değeri `6` olur; bu Cairo'da söz  
"konusu değildir."
 

#: src/ch02-03-functions.md:205
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is "
"an expression that evaluates to the value `6`."
msgstr ""
"Expression'lar bir değere değerlendirilir ve Cairo'da yazacağınız kodun çoğunu oluşturur. Örneğin,  
"`5 + 6` gibi bir matematik işlemi, değeri `11` olarak değerlendirilen bir expression'dır.  
"Expression'lar statement'ların bir parçası olabilir: Listing 2-1'de, `let y = 6;` statement'ındaki  
"`6`, değeri `6` olarak değerlendirilen bir expression'dır."


#: src/ch02-03-functions.md:211
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""
"Bir fonksiyonu çağırmak bir expression'dır çünkü her zaman bir değere değerlendirilir: belirtilmişse  
"fonksiyonun açık dönüş değeri, aksi takdirde 'unit' türü `()`."


#: src/ch02-03-functions.md:213
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr ""
"Örneğin, küme parantezleriyle oluşturulan yeni bir kapsam bloğu bir ifadedir:"

#: src/ch02-03-functions.md:223
msgid "\"The value of y is: {}\""
msgstr ""

#: src/ch02-03-functions.md:227
msgid "This expression:"
msgstr "Bu expression:"

#: src/ch02-03-functions.md:236
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""
"bu durumda `4` olarak değerlendirilen bir bloktur. Bu değer, `let` statement'ının bir parçası olarak  
"`y`'e bağlanır. `x + 1` satırının sonunda, şimdiye kadar gördüğünüz çoğu satırdan farklı olarak bir  
"noktalı virgül yoktur. Expression'lar sonunda noktalı virgül içermez. Bir expression'ın sonuna  
"noktalı virgül eklerseniz, onu bir statement'a dönüştürürsünüz ve o zaman bir değer döndürmez.  
"Bunu, fonksiyon dönüş değerlerini ve expression'ları keşfederken aklınızda bulundurun."


#: src/ch02-03-functions.md:244
msgid "Functions with Return Values"
msgstr "Dönüş Değerleri Olan Fonksiyonlar"

#: src/ch02-03-functions.md:246
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""
"Fonksiyonlar, onları çağıran koda değerler döndürebilir. Dönüş değerlerini  
"isimlendirmeyiz, ancak türlerini bir ok (`->`) sonrasında belirtmeliyiz.  
"Cairo'da, fonksiyonun dönüş değeri, fonksiyonun gövde bloğundaki son  
"expression ile eşanlamlıdır. `return` anahtar kelimesini kullanarak ve bir  
"değer belirterek bir fonksiyondan erken dönüş yapabilirsiniz, ancak çoğu  
"fonksiyon son expression'ı dolaylı olarak döndürür. İşte bir değer döndüren  
"bir fonksiyonun örneği:"


#: src/ch02-03-functions.md:265
msgid ""
"There are no function calls, or even `let` statements in the `five` function—"
"just the number `5` by itself. That’s a perfectly valid function in Cairo. "
"Note that the function’s return type is specified too, as `-> u32`. Try "
"running this code; the output should look like this:"
msgstr ""
"`five` fonksiyonunda fonksiyon çağrıları veya hatta `let` statement'ları  
"yoktur—sadece tek başına `5` numarası vardır. Bu, Cairo'da geçerli bir  
"fonksiyondur. Fonksiyonun dönüş türünün de `-> u32` olarak belirtildiğine  
"dikkat edin. Bu kodu çalıştırmayı deneyin; çıktı şöyle görünmelidir:"


#: src/ch02-03-functions.md:276
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"`five` içindeki `5`, fonksiyonun dönüş değeridir, bu yüzden dönüş türü  
"`u32`'dir. Bunu daha detaylı inceleyelim. İki önemli nokta var: ilk olarak,  
"`let x = five();` satırı, bir fonksiyonun dönüş değerini bir değişkeni  
"başlatmak için kullandığımızı gösterir. Çünkü `five` fonksiyonu bir `5`  
"döndürür, bu satır aşağıdakiyle aynıdır:"


#: src/ch02-03-functions.md:286
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""
"İkincisi, `five` fonksiyonunun parametreleri yoktur ve dönüş değerinin  
"türünü tanımlar, ancak fonksiyonun gövdesi, döndürmek istediğimiz değerin  
"bir expression'ı olduğu için noktalı virgül olmadan yalnız bir `5`'tir.  
"Bir başka örneğe bakalım:"


#: src/ch02-03-functions.md:303
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end "
"of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"Bu kodu çalıştırmak `x = 6` yazdıracaktır. Ancak, `x + 1` satırının sonuna  
"noktalı virgül koyarsak, bunu bir expression'dan bir statement'a çevirirsek,  
"bir hata alırız:"


#: src/ch02-03-functions.md:320
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: "
"\"()\".\n"
"```"
msgstr ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: 
"\"()\".\n"
"```"


#: src/ch02-03-functions.md:324
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"Ana hata mesajı olan `Unexpected return type`, bu kodla ilgili temel sorunu  
"ortaya koyar. `plus_one` fonksiyonunun tanımı, bir `u32` döndüreceğini  
"söyler, ancak statement'lar bir değere değerlendirilmez, bu `()`, yani unit  
"türü ile ifade edilir. Dolayısıyla, hiçbir şey döndürülmez, bu da fonksiyonun  
"tanımı ile çelişir ve bir hataya neden olur. "


#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""
"Tüm programcılar kodlarını anlaşılır kılmaya çalışır, ancak bazen ek açıklama  
"gerekebilir. Bu durumlarda, programcılar kaynak kodlarında derleyicinin  
"yoksayacağı ancak kaynak kodunu okuyanların faydalı bulabileceği yorumlar  
"bırakır."


#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr "İşte basit bir yorum:"

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr "// Merhaba, dünya\n"

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and "
"the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""
"Cairo'da, özdeş yorum stili bir yorumu iki eğik çizgi ile başlatır ve yorum  
"satırın sonuna kadar devam eder. Tek bir satırın ötesine uzanan yorumlar için,  
"her satırda `//` eklemeniz gerekir, şöyle ki:"


#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "Yorumlar, kod içeren satırların sonuna da yerleştirilebilir:"

#: src/ch02-04-comments.md:25
msgid "// return the sum of 1 and 4\n"
msgstr ""

#: src/ch02-04-comments.md:29
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr ""
"Ancak onları daha sık bu formatta, yorumunun açıkladığı kodun üzerinde ayrı bir  
"satırda göreceksiniz:"


#: src/ch02-04-comments.md:35
msgid "// this function performs a simple addition\n"
msgstr ""

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to "
"run some code repeatedly while a condition is true are basic building blocks "
"in most programming languages. The most common constructs that let you "
"control the flow of execution of Cairo code are if expressions and loops."
msgstr ""
"Bir koşul doğru olduğunda bazı kodların çalıştırılması ve bir koşul doğru  
"olduğu sürece bazı kodların tekrar tekrar çalıştırılması, çoğu programlama  
"dilinde temel yapı taşlarıdır. Cairo kodunun yürütme akışını kontrol etmenize  
"izin veren en yaygın yapılar if ifadeleri ve döngülerdir."


#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "`if` İfadesi"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You "
"provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"Bir if ifadesi, koşullara bağlı olarak kodunuzu dallandırmanıza olanak tanır.  
"Bir koşul sağlarsınız ve ardından, “Bu koşul karşılanırsa, bu kod bloğunu  
"çalıştır. Koşul karşılanmazsa, bu kod bloğunu çalıştırma.” dersiniz."


#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to "
"explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""
"_cairo_projects_ dizininizde _branches_ adında yeni bir proje oluşturun ve  
"`if` ifadesini keşfedin. _src/lib.cairo_ dosyasına aşağıdakileri girin:"


#: src/ch02-05-control-flow.md:18
msgid "\"condition was true and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:20
msgid "\"condition was false and number = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"Tüm `if` ifadeleri `if` anahtar kelimesiyle başlar, ardından bir koşul gelir.  
"Bu durumda, koşul `number` değişkeninin değerinin 5'e eşit olup olmadığını  
"kontrol eder. Koşul `true` ise yürütülecek kod bloğunu koşulun hemen ardından  
"süslü parantezler içine yerleştiririz."


#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr ""
"İsteğe bağlı olarak, koşul `false` olarak değerlendirilirse programın  
"yürüteceği alternatif bir kod bloğu vermek için burada yaptığımız gibi bir  
"`else` ifadesi de ekleyebiliriz. Bir `else` ifadesi sağlamazsanız ve koşul  
"`false` ise, program `if` bloğunu atlayıp kodun bir sonraki kısmına geçer."


#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "Bu kodu çalıştırmayı deneyin; aşağıdaki çıktıyı görmelisiniz:"

#: src/ch02-05-control-flow.md:37
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`true` to see what happens:"
msgstr ""
"Koşulun `true` olmasını sağlayacak bir değere `number` değerini değiştirip  
"ne olacağını görelim:"


#: src/ch02-05-control-flow.md:49
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""
"Bu kodda koşulun bir `bool` olması gerektiğini belirtmek de önemlidir.  
"Koşul bir `bool` değilse, bir hata alırız. Örneğin, aşağıdaki kodu  
"çalıştırmayı deneyin:"


#: src/ch02-05-control-flow.md:59
msgid "\"number was three\""
msgstr ""

#: src/ch02-05-control-flow.md:64
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr "`if` koşulu bu kez 3 değerini değerlendirir ve Cairo bir hata atar:"

#: src/ch02-05-control-flow.md:78
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will "
"not automatically try to convert non-Boolean types to a Boolean. If we want "
"the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""
"Hata, `number`'ın daha sonra `if` ifadesinin koşulu olarak kullanılmasına  
"dayanarak Cairo'nun `number` için `bool` türünü çıkardığını gösterir. Değer  
"`3`'ten bir `bool` oluşturmaya çalışır, ancak Cairo zaten bir sayısal  
"literalden `bool` oluşturmayı desteklemez - bir `bool` oluşturmak için sadece  
"`true` veya `false` kullanabilirsiniz. Ruby ve JavaScript gibi dillerin  
"aksine, Cairo otomatik olarak Boolean olmayan türleri Boolean'a dönüştürmeye  
"çalışmaz. Örneğin, bir sayı 0'a eşit olmadığında `if` kod bloğunun yalnızca  
"çalışmasını istiyorsak, if ifadesini şu şekilde değiştirebiliriz:"


#: src/ch02-05-control-flow.md:92
msgid "\"number was something other than zero\""
msgstr ""

#: src/ch02-05-control-flow.md:98
msgid "Running this code will print `number was something other than zero`."
msgstr "Bu kodu çalıştırmak, `number was something other than zero` yazdıracaktır."

#: src/ch02-05-control-flow.md:100
msgid "Handling Multiple Conditions with `else if`"
msgstr "Birden Fazla Koşulu `else if` ile İşleme"

#: src/ch02-05-control-flow.md:102
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if` "
"expression. For example:"
msgstr ""
"`if` ve `else`'i bir `else if` ifadesinde birleştirerek birden fazla koşulu  
"kullanabilirsiniz. Örneğin:"


#: src/ch02-05-control-flow.md:111
msgid "\"number is 12\""
msgstr ""

#: src/ch02-05-control-flow.md:113
msgid "\"number is 3\""
msgstr ""

#: src/ch02-05-control-flow.md:115
msgid "\"number minus 2 is 1\""
msgstr ""

#: src/ch02-05-control-flow.md:117
msgid "\"number not found\""
msgstr ""

#: src/ch02-05-control-flow.md:122
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr ""
"Bu programın alabileceği dört olası yolu vardır. Çalıştırdıktan sonra,  
"şu çıktıyı görmelisiniz:"


#: src/ch02-05-control-flow.md:130
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using "
"too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter 6](./ch06-02-the-"
"match-control-flow-construct.md) describes a powerful Cairo branching "
"construct called `match` for these cases."
msgstr ""
"Bu program çalıştırıldığında, sırayla her `if` ifadesini kontrol eder ve  
"koşul `true` olarak değerlendirilen ilk gövdeyi yürütür. `number - 2 == 1`  
"`true` olsa da, çıktı olarak `number minus 2 is 1` ya da `else` bloğundan  
"`number not found` metnini görmeyiz. Çünkü Cairo, ilk `true` koşulunun  
"bloğunu yürütür ve bir tane bulduğunda, geri kalanını bile kontrol etmez.  
"Çok fazla `else if` ifadesi kullanmak kodunuzu karışık hale getirebilir, bu  
"yüzden birden fazla varsa kodunuzu yeniden düzenlemek isteyebilirsiniz.  
"[6. Bölüm](./ch06-02-the-match-control-flow-construct.md) bu durumlar için  
"`match` adında güçlü bir Cairo dallanma yapısını tanımlar."


#: src/ch02-05-control-flow.md:132
msgid "Using `if` in a `let` statement"
msgstr "`let` içinde `if` kullanmak"

#: src/ch02-05-control-flow.md:134
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr ""
"`if` bir ifade olduğu için, sonucu bir değişkene atamak için bir `let`  
"ifadesinin sağ tarafında kullanabiliriz."


#: src/ch02-05-control-flow.md:148
msgid "\"condition was true and number is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:159
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr ""
"`number` değişkeni, `if` ifadesinin sonucuna bağlı olarak bir değere bağlanır,  
"burada bu değer 5 olacaktır."


#: src/ch02-05-control-flow.md:161
msgid "Repetition with Loops"
msgstr "Döngülerle Tekrarlama"

#: src/ch02-05-control-flow.md:163
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""
"Bir kod bloğunu birden fazla kez çalıştırmak sıklıkla faydalıdır. Bu görev için,  
"Cairo, döngü gövdesi içindeki kodun sonuna kadar çalıştırıp ardından hemen başa  
"dönecek basit bir döngü sözdizimi sağlar. Döngülerle deney yapmak için _loops_  
"adında yeni bir proje oluşturalım."


#: src/ch02-05-control-flow.md:165
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr "Cairo'da iki tür döngü vardır: `loop` ve `while`."

#: src/ch02-05-control-flow.md:167
msgid "Repeating Code with `loop`"
msgstr "Döngü ile Kod Tekrarı"

#: src/ch02-05-control-flow.md:169
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr ""
"`loop` anahtar kelimesi, Cairo'ya bir kod bloğunu sürekli olarak ya da siz  
"açıkça durmasını söyleyene kadar tekrar tekrar çalıştırmasını söyler."


#: src/ch02-05-control-flow.md:171
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr ""
"Örnek olarak, _loops_ dizininizdeki _src/lib.cairo_ dosyasını şu şekilde  
"değiştirin:"


#: src/ch02-05-control-flow.md:177
msgid "\"again!\""
msgstr ""

#: src/ch02-05-control-flow.md:185
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr ""
"Not: Bu program, bir kırılma koşulu olmadan derlenmez. Örneğin amacıyla,  
"hiç ulaşılmayacak bir `break` ifadesi ekledik, ancak bu derleyiciyi  
"tatmin eder."


#: src/ch02-05-control-flow.md:187
msgid ""
"When we run this program, we’ll see again! printed over and over "
"continuously until either the program runs out of gas or we stop the program "
"manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a "
"program that is stuck in a continual loop. Give it a try:"
msgstr ""
"Bu programı çalıştırdığımızda, program ya gazı tükenene kadar ya da biz  
"programı manuel olarak durdurana kadar sürekli olarak tekrar yazdırıldığını  
"göreceğiz. Çoğu terminal, sürekli bir döngüde takılıp kalan bir programı  
"kesmek için ctrl-c klavye kısayolunu destekler. Bir deneyin:"


#: src/ch02-05-control-flow.md:188
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=2000000000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:198
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""
"`^C` sembolü, ctrl-c'ye bastığınız yeri temsil eder. Kod döngüde kesme  
"sinyalini aldığında neredeyse bağlı olarak, ^C'den sonra `again!` yazılıp  
"yazılmadığını görebilir veya göremeyebilirsiniz."


#: src/ch02-05-control-flow.md:200
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the `--"
"available-gas` flag, we can set the maximum amount of gas available to the "
"program. Gas is a unit of measurement that expresses the computation cost of "
"an instruction. When the gas meter runs out, the program will stop. In the "
"previous case, we set the gas limit high enough for the the program to run "
"for quite some time."
msgstr ""
"Not: Cairo, gaz sayacı içeren bir programın sonsuz döngülerle çalışmasını  
"önler. Gaz sayacı, bir programda yapılabilecek hesaplamanın miktarını sınırlayan  
"bir mekanizmadır. `--available-gas` bayrağına bir değer ayarlayarak, programa  
"müsait maksimum gaz miktarını ayarlayabiliriz. Gaz, bir talimatın hesaplama  
"maliyetini ifade eden bir ölçüm birimidir. Gaz sayacı tükendiğinde, program  
"durur. Önceki durumda, programın oldukça uzun bir süre çalışması için gaz  
"limitini yeterince yüksek ayarladık."


#: src/ch02-05-control-flow.md:202
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""
"Akıllı kontratların Starknet üzerinde dağıtılması bağlamında, ağda sonsuz  
"döngülerin çalışmasını önlemek özellikle önemlidir. Eğer bir döngü  
"çalıştırması gereken bir program yazıyorsanız, programı çalıştırmak için  
"yeterince büyük bir değere sahip `--available-gas` bayrağı ile çalıştırmanız  
"gerekecek."


#: src/ch02-05-control-flow.md:205
msgid ""
"Now, try running the same program again, but this time with the `--available-"
"gas` flag set to `200000` instead of `2000000000000`. You will see the "
"program only prints `again!` 3 times before it stops, as it ran out of gas "
"to keep executing the loop."
msgstr ""
"Şimdi, aynı programı tekrar çalıştırın, ancak bu sefer `--available-gas`  
"bayrağını `2000000000000` yerine `200000` olarak ayarlayın. Programın yalnızca  
"3 kez `tekrar!` yazdırdığını ve döngüyü sürdürmek için gazı tükendiği için  
"durduğunu göreceksiniz."


#: src/ch02-05-control-flow.md:207
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""
"Şans eseri, Cairo ayrıca kod kullanarak bir döngüden çıkmanın bir yolunu da  
"sağlar. Programa döngüyü ne zaman durdurması gerektiğini söylemek için döngü  
"içine `break` anahtar kelimesini yerleştirebilirsiniz."


#: src/ch02-05-control-flow.md:216 src/ch02-05-control-flow.md:236
msgid "\"i = {}\""
msgstr ""

#: src/ch02-05-control-flow.md:222
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration.  Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""
"`continue` anahtar kelimesi, programın döngünün bir sonraki yinelemesine  
"gitmesini ve bu yinelemedeki kodun geri kalanını atlamasını söyler. Döngümüze  
"`i` `5`e eşit olduğunda `print` ifadesini atlamak için bir `continue`  
"ifadesi ekleyelim."


#: src/ch02-05-control-flow.md:242
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr "Bu program çalıştırıldığında, `i` değeri `5`'e eşit olduğunda yazdırılmayacaktır."

#: src/ch02-05-control-flow.md:244
msgid "Returning Values from Loops"
msgstr "Döngülerden Değer Döndürme"

#: src/ch02-05-control-flow.md:246
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"`loop` kullanımının yollarından biri, başarılı olup olmadığını kontrol etmek  
"gibi, başarısız olabileceğini bildiğiniz bir işlemi tekrar denemektir. Ayrıca,  
"bu işlemin sonucunu döngüden kodunuzun geri kalanına aktarmanız gerekebilir.  
"Bunu yapmak için, döngüyü durdurmak için kullandığınız `break` ifadesinin  
"ardından döndürmek istediğiniz değeri ekleyebilirsiniz; bu değer döngüden  
"döndürülecek ve aşağıda gösterildiği gibi kullanabilirsiniz:"


#: src/ch02-05-control-flow.md:264
msgid "\"The result is {}\""
msgstr ""

#: src/ch02-05-control-flow.md:268
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When "
"the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the "
"value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"Döngüden önce, `counter` adında bir değişken tanımlarız ve onu `0` olarak  
"başlatırız. Sonra döngüden dönen değeri tutacak `result` adında bir değişken  
"tanımlarız. Döngünün her yinelemesinde, `counter`'ın `10`'a eşit olup  
"olmadığını kontrol eder ve sonra `counter` değişkenine `1` ekleriz. Koşul  
"karşılandığında, `counter * 2` değeri ile `break` anahtar kelimesini  
"kullanırız. Döngüden sonra, `result`'a değeri atayan ifadeyi sonlandırmak için  
"bir noktalı virgül kullanırız. Sonunda, bu durumda `20` olan `result`  
"değerini yazdırırız."


#: src/ch02-05-control-flow.md:275
msgid "Conditional Loops with `while`"
msgstr "`while` ile Koşullu Döngüler"

#: src/ch02-05-control-flow.md:277
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`; "
"you could try that now in a program, if you’d like. However, this pattern is "
"so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""
"Bir program sıklıkla döngü içinde bir koşulu değerlendirmeye ihtiyaç duyar.  
"Koşul `true` olduğu sürece döngü çalışır. Koşul artık `true` olmadığında,  
"program `break`'i çağırır, döngüyü durdurur. Bu tür bir davranışı `loop`,  
"`if`, `else` ve `break` kombinasyonunu kullanarak uygulamak mümkündür;  
"isterseniz şimdi bir programda bunu deneyebilirsiniz. Ancak, bu desen o kadar  
"yaygındır ki, Cairo bunun için yerleşik bir dil yapısı sunar, buna `while`  
"döngüsü denir."


#: src/ch02-05-control-flow.md:283
msgid ""
"In Listing 2-3, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""
"Listing 2-3'te, programı üç kez döngüye almak için `while` kullanırız, her  
"seferinde `number` değerini yazdırdıktan sonra sayımı azaltırız ve sonra,  
"döngüden sonra, bir mesaj yazdırır ve çıkarız."


#: src/ch02-05-control-flow.md:290
msgid "\"{number}!\""
msgstr ""

#: src/ch02-05-control-flow.md:294
msgid "\"LIFTOFF!!!\""
msgstr ""

#: src/ch02-05-control-flow.md:297
msgid ""
"Listing 2-3: Using a `while` loop to run code while a condition holds `true`"
msgstr ""
"Liste 2-3: Bir koşul `true` olduğu sürece kodu çalıştırmak için `while` döngüsü kullanma"

#: src/ch02-05-control-flow.md:299
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""
"Bu yapı, `loop`, `if`, `else` ve `break` kullanıldığında gerekli olacak  
"çok fazla iç içe geçmeyi ortadan kaldırır ve daha açıktır. Bir koşul `true`  
"olarak değerlendirildiğinde, kod çalışır; aksi takdirde, döngüden çıkar."


#: src/ch02-05-control-flow.md:304
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the "
"concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"Başardınız! Oldukça büyük bir bölümdü: değişkenler, veri tipleri, fonksiyonlar,  
"yorumlar, `if` ifadeleri ve döngüler hakkında öğrendiniz! Bu bölümde  
"tartışılan kavramlarla pratik yapmak için, aşağıdaki programları  
"oluşturmayı deneyin"


#: src/ch02-05-control-flow.md:308
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "_n_'inci Fibonacci sayısını oluşturun."

#: src/ch02-05-control-flow.md:309
msgid "Compute the factorial of a number _n_."
msgstr "Bir _n_ sayısının faktöriyelini hesaplayın."

#: src/ch02-05-control-flow.md:311
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr ""
"Şimdi, bir sonraki bölümde Cairo'daki yaygın koleksiyon türlerini inceleyeceğiz."

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""
"Cairo, verileri saklamak ve manipüle etmek için kullanılabilecek ortak  
"koleksiyon tipleri sunar. Bu koleksiyonlar verimli, esnek ve kullanımı kolay  
"olarak tasarlanmıştır. Bu bölüm, Cairo'da mevcut olan temel koleksiyon  
"tiplerini tanıtır: Diziler ve Sözlükler."


#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""
"Bir dizi, aynı türden elemanların bir koleksiyonudur. `ArrayTrait` trait'ini  
"çekirdek kütüphaneden kullanarak dizi metodları oluşturabilir ve  
"kullanabilirsiniz."


#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options. "
"Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""
"Dikkat edilmesi gereken önemli bir nokta, dizilerin sınırlı modifikasyon  
"seçeneklerine sahip olmasıdır. Diziler, aslında değerleri değiştirilemeyen  
"kuyruklardır. Bu, bir bellek yuvasına yazıldıktan sonra, üzerine yazılamayacağı  
"ancak ondan okunabileceği gerçeğiyle ilgilidir. Bir dizinin sonuna yalnızca  
"eleman ekleyebilir ve önünden eleman çıkarabilirsiniz."


#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "Dizi Oluşturma"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""
"Bir dizi oluşturmak, `ArrayTrait::new()` çağrısı ile yapılır. İşte 3 eleman  
"eklediğimiz bir dizi oluşturma örneği:"


#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when "
"instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""
"Gerekirse, dizi örneğini oluştururken dizinin içindeki elemanların beklenen  
"türünü bu şekilde geçirebilir veya değişkenin türünü açıkça tanımlayabilirsiniz."


#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "Bir Diziyi Güncelleme"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "Elemanları Ekleme"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr ""
"Bir dizinin sonuna bir eleman eklemek için `append()` yöntemini kullanabilirsiniz:"

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "Elemanları Kaldırma"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped, "
"containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"`pop_front()` metodunu kullanarak bir diziden yalnızca ön taraftaki elemanları  
"çıkarabilirsiniz. Bu metod, kaldırılan elemanı içeren bir `Option` veya dizi  
"boşsa `Option::None` döndürür."


#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr ""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr ""
"Yukarıdaki kod, eklenen ilk elemanı çıkardığımız için `The first value is 10`  
"yazdıracaktır."


#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify "
"the elements of an array once they've been added. You can only add elements "
"to the end of an array and remove elements from the front of an array. These "
"operations do not require memory mutation, as they involve updating pointers "
"rather than directly modifying the memory cells."
msgstr ""
"Cairo'da, bellek değişmezdir, bu da ekledikten sonra bir dizinin elemanlarını  
"değiştirmenin mümkün olmadığı anlamına gelir. Bir dizinin sonuna yalnızca  
"eleman ekleyebilir ve bir dizinin önünden eleman çıkarabilirsiniz. Bu  
"işlemler, bellek hücrelerini doğrudan değiştirmek yerine işaretçileri  
"güncellemeyi içerdiğinden, bellek mutasyonu gerektirmez."


#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr "Bir Diziden Eleman Okuma"

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"Dizi elemanlarına erişmek için, farklı türler döndüren `get()` veya `at()`  
"dizi metodlarını kullanabilirsiniz. `arr.at(index)` kullanmak, alt dizin  
"operatörü `arr[index]` kullanmakla eşdeğerdir."


#: src/ch03-01-arrays.md:71
msgid "`get()` method"
msgstr "`get()` methodu"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and Snapshots](ch04-02-"
"references-and-snapshots.md) chapter."
msgstr ""
"`get` fonksiyonu bir `Option<Box<@T>>` döndürür, bu da belirtilen indeksteki  
"eleman dizi içinde varsa, o elemana ait bir kutu türüne (Cairo'nun akıllı  
"işaretçi türü) bir seçenek döndürdüğü anlamına gelir. Eleman mevcut değilse,  
"`get` `None` döndürür. Bu yöntem, dizinin sınırları içinde olmayabilecek  
"indekslere erişmeyi beklediğiniz ve böyle durumları panik olmadan zarif bir  
"şekilde ele almak istediğinizde kullanışlıdır. Snapshot'lar [Referanslar ve  
"Snapshot'lar](ch04-02-references-and-snapshots.md) bölümünde daha detaylı  
"bir şekilde açıklanacaktır."


#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr "İşte `get()` yöntemiyle bir örnek:"

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr ""

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap "
"operator\n"
"        // It basically means \"transform what get(idx) returned into a real "
"value\"\n"
msgstr ""

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr ""

#: src/ch03-01-arrays.md:94
msgid "`at()` methodu"
msgstr ""

#: src/ch03-01-arrays.md:96
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"`at` fonksiyonu ise, `unbox()` operatörünü kullanarak belirtilen indeksteki  
"elemana doğrudan bir snapshot döndürür. İndeks sınırların dışındaysa bir  
"panik hatası oluşur. Yalnızca sağlanan indeks dizinin sınırlarının dışında  
"olduğunda programın paniklemesini istiyorsanız `at` kullanmalısınız, bu  
"beklenmeyen davranışları önleyebilir."
 

#: src/ch03-01-arrays.md:98
msgid "İşte `at()` methodu ile bir örnek:"
msgstr ""

#: src/ch03-01-arrays.md:111
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""
"Bu örnekte, `first` adlı değişken `0` değerini alacak çünkü bu, dizide `0`  
"indeksindeki değerdir. `second` adlı değişken, dizide `1` indeksinden `1` 
"değerini alacak."


#: src/ch03-01-arrays.md:115
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""
"Eğer alt dizin operatörü `arr[index]` kullanmak istiyorsanız, dizinin  
"elemanlarının türünü açıkça tanımlamanız gerekecektir, aksi takdirde  
"derlenmeyecektir. Örneğin:"


#: src/ch03-01-arrays.md:128
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""
"Özetle, sınırların dışındaki erişim girişimlerinde paniklemek istiyorsanız  
"`at` kullanın ve bu tür durumları panik olmadan zarif bir şekilde ele almak  
"istiyorsanız `get` kullanın."


#: src/ch03-01-arrays.md:130
msgid "Size related methods"
msgstr "Boyutla ilgili methodlar"

#: src/ch03-01-arrays.md:132
msgid ""
"To determine the number of elements in an array, use the `len()` method. The "
"return value is of type `usize`."
msgstr ""
"Bir dizideki eleman sayısını belirlemek için `len()` metodunu kullanın.  
"Dönüş değeri `usize` türündedir."


#: src/ch03-01-arrays.md:134
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""
"Bir dizinin boş olup olmadığını kontrol etmek istiyorsanız, `is_empty()`  
"metodunu kullanabilirsiniz, bu metod dizi boşsa `true`, aksi takdirde `false`  
"döndürür."


#: src/ch03-01-arrays.md:136 src/ch11-02-macros.md:27
msgid "`array!` makrosu"
msgstr ""

#: src/ch03-01-arrays.md:138
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"Bazen, derleme zamanında zaten bilinen değerlere sahip diziler oluşturmamız  
"gerekiyor. Bunun temel yolu fazlalıklıdır. İlk olarak diziyi tanımlar ve  
"sonra her bir değeri tek tek eklerdiniz. `array!` bu görevi iki adımı  
"birleştirerek daha basit bir şekilde yapmanın yoludur. Derleme zamanında,  
"derleyici makroyu genişleterek öğeleri sırayla ekleyen kodu oluşturacaktır."


#: src/ch03-01-arrays.md:141
msgid "`array!` olmadan:"
msgstr ""

#: src/ch03-01-arrays.md:152
msgid "`array!` ile:"
msgstr ""

#: src/ch03-01-arrays.md:158
msgid "Storing multiple types with Enums"
msgstr "Enum'lar ile birden fazla türün saklanması"

#: src/ch03-01-arrays.md:160
msgid ""
"If you want to store elements of different types in an array, you can use an "
"`Enum` to define a custom data type that can hold multiple types. Enums will "
"be explained in more detail in the [Enums and Pattern Matching](ch06-00-"
"enums-and-pattern-matching.md) chapter."
msgstr ""
"Farklı türlerdeki elemanları bir dizide saklamak istiyorsanız, birden fazla  
"türü tutabilen özel bir veri türü tanımlamak için bir `Enum` kullanabilirsiniz.  
"Enumlar [Enumlar ve Desen Eşleştirme](ch06-00-enums-and-pattern-matching.md)  
"bölümünde daha detaylı bir şekilde açıklanacaktır."


#: src/ch03-01-arrays.md:178
msgid "Span"
msgstr ""

#: src/ch03-01-arrays.md:180
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""
"`Span`, bir `Array`'in bir snapshot'ını temsil eden bir yapıdır. Orijinal  
"diziyi değiştirmeden bir dizinin elemanlarına güvenli ve kontrollü erişim  
"sağlamak için tasarlanmıştır. Span, özellikle veri bütünlüğünü sağlamak ve  
"fonksiyonlar arasında diziler geçirirken veya salt okunur işlemler  
"gerçekleştirirken ödünç alma sorunlarını önlemek için faydalıdır (bkz.  
"[Referanslar ve Snapshot'lar](ch04-02-references-and-snapshots.md))"


#: src/ch03-01-arrays.md:182
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr ""
"`Array` tarafından sağlanan tüm metodlar `Span` ile de kullanılabilir,  
"`append()` metodunun istisnası dışında."


#: src/ch03-01-arrays.md:184
msgid "Turning an Array into span"
msgstr "Array'i span'a dönüştürme"

#: src/ch03-01-arrays.md:186
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "Bir `Array`'in `Span`'ini oluşturmak için `span()` yöntemini çağırın:"

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"Cairo, çekirdek kütüphanesinde bir sözlük benzeri tür sunar. `Felt252Dict<T>`  
"veri türü, her bir anahtarın benzersiz olduğu ve karşılık gelen bir değerle  
"ilişkilendirildiği anahtar-değer çiftlerinin bir koleksiyonunu temsil eder. Bu  
"tür veri yapıları, farklı programlama dillerinde haritalar, karma tablolar, " 
"ilişkisel diziler ve daha birçok farklı isimle bilinir."


#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a "
"certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"`Felt252Dict<T>` türü, verilerinizi belirli bir şekilde düzenlemek istediğinizde  
"ve bir `Array<T>` kullanmanın ve indekslemenin yetersiz kaldığı durumlar için  
"faydalıdır. Cairo sözlükleri, ayrıca programcıya, mevcut olmayan değiştirilebilir  
"belleğin varlığını kolayca simüle etme imkanı da tanır."


#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "Sözlüklerin Temel Kullanımı"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the "
"data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"Diğer dillerde yeni bir sözlük oluştururken genellikle anahtar ve değerin veri  
"türlerini tanımlamak normaldir. Cairo'da, anahtar türü `felt252` ile sınırlıdır,  
"bu da sadece değer veri türünü belirtme olasılığını bırakır, `Felt252Dict<T>`'de  
"bu `T` ile temsil edilir."


#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""
"`Felt252Dict<T>`'nin temel işlevselliği, tüm temel işlemleri içeren  
"`Felt252DictTrait` trait'inde uygulanmıştır. Bunlar arasında şunları bulabiliriz:"


#: src/ch03-02-dictionaries.md:13
msgid "`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "`insert(felt252, T) -> ()` bir sözlük örneğine değer yazmak için ve"

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "`get(felt252) -> T` içinden değerleri okumak için."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""
"Bu fonksiyonlar, diğer dillerdeki gibi sözlükleri manipüle etmemize olanak tanır.  
"Aşağıdaki örnekte, bireyler ve bakiyeleri arasındaki eşlemeyi temsil eden bir  
"sözlük oluşturuyoruz:"


#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our "
"users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"`Felt252Dict<u64>`'ün yeni bir örneğini, `Default` trait'inin `default` metodu  
"kullanılarak oluşturabilir ve `insert` metodu kullanarak her biri kendi bakiyesine  
"sahip iki birey ekleyebiliriz. Son olarak, `get` metodu ile kullanıcılarımızın  
"bakiyelerini kontrol ederiz. Bu metodlar çekirdek kütüphanedeki `Felt252DictTrait`  
"trait'inde tanımlanmıştır."


#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is "
"implemented later on in [Dictionaries Underneath](#dictionaries-underneath)."
msgstr ""
"Kitap boyunca, Cairo'nun belleğinin değişmez olduğundan, yani bir bellek hücresine  
"yalnızca bir kez yazılabileceğinden bahsettik, ancak `Felt252Dict<T>` türü, bu  
"engelin üstesinden gelmenin bir yolunu temsil eder. Bunun nasıl uygulandığını daha  
"sonra [Sözlüklerin Altında](#dictionaries-underneath) bölümünde açıklayacağız."


#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr ""
"Önceki örneğimizi temel alarak, aynı kullanıcının bakiyesinin nasıl değiştiğini  
"gösteren bir kod örneği sunalım:"


#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr ""

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr ""

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr ""

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr ""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"Bu örnekte 'Alex' kişisini iki kez eklediğimize dikkat edin, her seferinde farklı bir  
"bakiye kullanıldı ve bakiyesi kontrol edildiğinde her zaman son eklenen değeri aldı!  
"`Felt252Dict<T>` bize verilen herhangi bir anahtar için saklanan değeri \"yeniden yazma\"  
"imkanı sağlar."


#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means "
"that if for example, you tried to get the balance of an inexistent user you "
"will get 0 instead of an error or an undefined value. This also means there "
"is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"Sözlüklerin nasıl uygulandığını açıklamadan önce, bir `Felt252Dict<T>` örneği  
"oluşturduğunuzda, perde arkasında tüm anahtarların ilişkili değerlerinin sıfır olarak  
"başlatıldığını belirtmek önemlidir. Bu, örneğin, mevcut olmayan bir kullanıcının bakiyesini  
"almaya çalıştığınızda bir hata veya tanımsız bir değer yerine 0 alacağınız anlamına gelir.  
"Bu aynı zamanda bir sözlükten veri silmenin mümkün olmadığı anlamına gelir. Bu yapının  
"kodunuza dahil ederken göz önünde bulundurulması gereken bir noktadır."


#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
"Bu noktaya kadar, `Felt252Dict<T>`'nin tüm temel özelliklerini ve diğer dillerdeki  
"karşılık gelen veri yapılarının aynı davranışını nasıl taklit ettiğini gördük, tabii ki  
"dışarıdan. Cairo, temelde belirsiz bir Turing-tam programlama dilidir, var olan diğer  
"popüler dillerden çok farklıdır, bu da sözlüklerin de çok farklı şekilde uygulandığı  
"anlamına gelir!"


#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as "
"another way to interact with them."
msgstr ""
"Takip eden bölümlerde, `Felt252Dict<T>` iç mekanizmaları ve onları çalışır hale getirmek  
"için yapılan kompromisler hakkında bazı içgörüler sunacağız. Bundan sonra, sözlükleri diğer  
"veri yapılarıyla nasıl kullanacağımıza ve onlarla etkileşimde bulunmanın başka bir yolu  
"olarak `entry` metodunu nasıl kullanacağımıza bakacağız."


#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr "Sözlükler Altında"

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language "
"implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for reading/updating/"
"writing purposes. An entry has three fields:"
msgstr ""
"Cairo'nun belirsiz tasarımının kısıtlamalarından biri, bellek sisteminin değişmez olmasıdır,  
"bu nedenle değiştirilebilirliği simüle etmek için dil, `Felt252Dict<T>`'yi girişlerin bir  
"listesi olarak uygular. Girişlerin her biri, bir sözlüğün okuma/güncelleme/yazma amaçları için  
"erişildiği bir zamanı temsil eder. Bir girişin üç alanı vardır:"


#: src/ch03-02-dictionaries.md:69
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr ""
"Bir sözlükteki bu anahtar-değer çifti için anahtarı tanımlayan bir `key` alanı."


#: src/ch03-02-dictionaries.md:70
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr ""
"`key`'de hangi önceki değerin tutulduğunu belirten bir `previous_value` alanı."


#: src/ch03-02-dictionaries.md:71
msgid "A `new_value` field that indicates the new value that is held at `key`."
msgstr "`key`'de tutulan yeni değeri belirten bir `new_value` alanı."


#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would "
"internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new "
"values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"Eğer `Felt252Dict<T>`'yi yüksek seviye yapılar kullanarak uygulamaya çalışırsak,  
"içsel olarak onu `Array<Entry<T>>` olarak tanımlarız, burada her `Entry<T>`,  
"temsil ettiği anahtar-değer çifti hakkında bilgi ve tuttuğu önceki ve yeni değerleri içerir.  
"`Entry<T>`'nin tanımı şu şekilde olurdu:"


#: src/ch03-02-dictionaries.md:83
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr ""
"Bir `Felt252Dict<T>` ile her etkileşimde, yeni bir `Entry<T>` kaydedilecektir:"


#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr ""
"`get`, durumda bir değişiklik olmadığı ve önceki ile yeni değerlerin aynı değerle  
"kaydedildiği bir giriş kaydeder."


#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"`insert`, `new_value`'nun eklenen eleman ve `previous_value`'nun bu öncesi eklenen  
"son eleman olduğu yeni bir `Entry<T>` kaydeder. Belirli bir anahtar için bu ilk giriş  
"ise, önceki değer sıfır olacaktır."


#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an "
"example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"Bu giriş listesinin kullanımı, herhangi bir yeniden yazımın olmadığını, sadece  
"`Felt252Dict<T>` etkileşimi başına yeni bellek hücrelerinin oluşturulduğunu gösterir.  
"Bunu, önceki bölümden `balances` sözlüğünü kullanarak 'Alex' ve 'Maria' kullanıcılarını  
"ekleyerek gösterelim:"


#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr "Bu talimatlar daha sonra aşağıdaki giriş listesini üretecektir:"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "key"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr ""

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "new"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146 src/ch03-02-dictionaries.md:147
msgid "0"
msgstr ""

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
msgid "100"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr ""

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
msgid "50"
msgstr ""

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr ""

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"'Alex' iki kez eklendiğinden, iki kez görünür ve `previous` ile `current` değerleri  
"doğru şekilde ayarlanmıştır. Ayrıca, 'Maria'dan okuma, önceki ile mevcut değerler arasında  
"bir değişiklik olmadan bir giriş kaydetti."


#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each read/"
"write operation, there is a scan for the whole entry list in search of the "
"last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"`Felt252Dict<T>`'yi bu şekilde uygulamanın anlamı, her okuma/yazma işlemi için, aynı  
"`key` ile son girişi aramak üzere tüm giriş listesinin taranmasıdır. Giriş bulunduğunda,  
"`new_value`'si çıkarılır ve yeni eklenen girişte `previous_value` olarak kullanılır. Bu, 
"`Felt252Dict<T>` ile etkileşimin en kötü durum zaman karmaşıklığının `O(n)` olduğu anlamına  
"geliyor, burada `n` liste içindeki girişlerin sayısıdır."


#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"`Felt252Dict<T>`'yi uygulamanın alternatif yollarını düşünürseniz, muhtemelen `previous_value`  
"alanının tamamen gereksiz olduğu yöntemler bulabilirsiniz, yine de, Cairo normal bir dil  
"olmadığı için bu işe yaramaz. Cairo'nun amaçlarından biri, STARK ispat sistemi ile, hesaplama  
"bütünlüğünün kanıtlarını üretmektir. Bu, programın doğru ve Cairo kısıtlamaları içinde  
"çalıştığını doğrulamanız gerektiği anlamına gelir. Bu sınır kontrollerinden biri  
"\"sözlük sıkıştırması\"dır ve bu, her giriş için önceki ve yeni değerler hakkında bilgi gerektirir."


#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr "Sözlükleri Ezmek"

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"`Felt252Dict<T>` kullanan bir Cairo programının yürütmesiyle üretilen kanıtın doğru olduğunu  
"doğrulamak için, sözlükle herhangi bir yasa dışı oynama yapılmadığını kontrol etmemiz gerekir.  
"Bu, her girişi gözden geçiren ve yürütme boyunca sözlüğe erişimin tutarlı kaldığını kontrol eden  
"`squash_dict` adlı bir yöntem aracılığıyla yapılır."


#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"Sıkıştırma işlemi şu şekildedir: belirli bir anahtar `k` ile tüm girişler, eklenme sıraları  
"göz önünde bulundurularak alınır, i'nci girişin `new_value`'si i+1'inci girişin `previous_value`  
"ile eşit olduğu doğrulanır."


#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr "Örneğin, aşağıdaki giriş listesi göz önüne alındığında:"

#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
msgid "150"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr ""

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "70"
msgstr ""

#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138
msgid "250"
msgstr ""

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137
msgid "40"
msgstr ""

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
msgid "300"
msgstr ""

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "190"
msgstr ""

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:145
msgid "90"
msgstr ""

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr "Ezme işleminden sonra giriş listesi şu şekle indirgenecektir:"

#: src/ch03-02-dictionaries.md:149
msgid ""
"In case of a change on any of the values of the first table, squashing would "
"have failed during runtime."
msgstr ""
"İlk tablonun herhangi bir değerinde bir değişiklik olması durumunda, ezme işlemi çalışma sırasında başarısız olurdu."

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr "Sözlük İmhası"

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of Dictionaries](#basic-use-of-"
"dictionaries), you'd notice that there was never a call to squash "
"dictionary, but the program compiled successfully nonetheless. What happened "
"behind the scene was that squash was called automatically via the "
"`Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call "
"occurred just before the `balance` dictionary went out of scope."
msgstr ""
"[Sözlüklerin Temel Kullanımı](#basic-use-of-dictionaries) bölümündeki örnekleri çalıştırdığınızda,  
"sözlük sıkıştırma çağrısının yapılmadığını ancak programın yine de başarıyla derlendiğini fark  
"etmiş olabilirsiniz. Perde arkasında olan şey, `Felt252Dict<T>`'nin `Destruct<T>` trait'inin 
"uygulanması aracılığıyla squash'ın otomatik olarak çağrıldığıydı. Bu çağrı, `balance` sözlüğü  
"kapsam dışına çıkmadan hemen önce gerçekleşti."


#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which "
"actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these "
"traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-"
"destruct)."
msgstr ""
"`Destruct<T>` trait'i, `Drop<T>`'den farklı olarak, nesneleri kapsam dışına çıkarma  
"yöntemlerinden birini temsil eder. Bu ikisi arasındaki ana fark, `Drop<T>`'nin bir  
"no-op işlemi olarak ele alınması, yani yeni CASM üretmemesi, `Destruct<T>`'nin bu  
"kısıtlamaya sahip olmamasıdır. Aktif olarak `Destruct<T>` trait'ini kullanan tek tür  
"`Felt252Dict<T>`'dir, diğer her tür için `Destruct<T>` ve `Drop<T>` eşanlamlıdır. Bu  
"trait'ler hakkında daha fazla bilgiyi [Drop ve Destruct](/appendix-03-derivable-traits.md#drop-and-destruct)  
"bölümünde okuyabilirsiniz."


#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"we will have a hands-on example where we implement the `Destruct<T>` trait "
"for a custom type."
msgstr ""
"[Yapı Üyeleri Olarak Sözlükler](#dictionaries-as-struct-members) bölümünde, özel bir tür için  
"`Destruct<T>` trait'ini uyguladığımız uygulamalı bir örneğe sahip olacağız."


#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr "Daha Fazla Sözlük"

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"Bu noktaya kadar, `Felt252Dict<T>`'nin işlevselliğine ve belirli bir şekilde nasıl ve neden  
"uygulandığına dair kapsamlı bir genel bakış verdik. Hepsini anlamadıysanız endişelenmeyin,  
"çünkü bu bölümde sözlükleri kullanarak daha fazla örneğe sahip olacağız."


#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary "
"basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-types-not-supported-natively) "
"with other complex types such as `Array<T>` and how to [implement]"
"(#dictionaries-as-struct-members) a struct with a dictionary as a member."
msgstr ""
"`Felt252DictTrait<T>`'nin temel işlevselliğinin bir parçası olan ve başta bahsetmediğimiz  
"`entry` metodunu açıklayarak başlayacağız. Hemen ardından, `Felt252Dict<T>`'nin [doğal olarak  
"desteklenmeyen türlerle etkileşimi](#dictionaries-of-types-not-supported-natively) hakkında  
"örnekler göreceğiz, örneğin `Array<T>` ve bir yapıyı sözlük üyesi olarak [uygulama](#dictionaries-as-struct-members)."


#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr "Giriş ve Sonuçlandırma"

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find "
"the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""
"[Sözlüklerin Alt Yapısı](#dictionaries-underneath) bölümünde, `Felt252Dict<T>`'nin iç  
"çalışmasını açıkladık. Her sözlüğe erişimde, herhangi bir şekilde, belirli bir `key` için son  
"girişi bulup onu uygun operasyona göre güncelleyerek bir girişler listesiydi. Cairo dilinde,  
"`entry` ve `finalize` metodları aracılığıyla bunu kendimiz tekrarlamak için gereken araçları elde ederiz."


#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"`entry` metodu, belirli bir anahtar için yeni bir giriş oluşturma amacıyla `Felt252DictTrait<T>`  
"ile gelir. Çağrıldığında, bu metod sözlüğün sahipliğini alır ve güncellenecek girişi döndürür.  
"Metod imzası şöyle:"


#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second "
"one is used to create the appropriate entry. It returns a tuple containing a "
"`Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never "
"panic."
msgstr ""
"İlk giriş parametresi, sözlüğün sahipliğini alırken, ikincisi uygun girişi oluşturmak için kullanılır.  
"Bir `Felt252DictEntry<T>`, Cairo'nun sözlük girişlerini temsil etmek için kullandığı tür, ve  
"önceden tutulan bir `T` değeri içeren bir demet döndürür. `nopanic` notasyonu, fonksiyonun  
"asla panik olmayacağının garantilendiğini belirtir."


#: src/ch03-02-dictionaries.md:178
msgid ""
"The next thing to do is to update the entry with the new value. For this, we "
"use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""
"Bir sonraki adım, girişi yeni değerle güncellemektir. Bunun için, girişi ekleyen ve sözlüğün  
"sahipliğini geri döndüren `finalize` metodunu kullanırız:"


#: src/ch03-02-dictionaries.md:184
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr ""
"Bu metod, girişi ve yeni değeri parametre olarak alır ve güncellenmiş sözlüğü döndürür."

#: src/ch03-02-dictionaries.md:186
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to "
"implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""
"`entry` ve `finalize` kullanarak bir örneği inceleyelim. Sözlükten `get`  
"metodunun kendi versiyonumuzu uygulamak istediğimizi hayal edelim. O zaman " 
"şunu yapmalıyız:"


#: src/ch03-02-dictionaries.md:188
msgid "Create the new entry to add using the `entry` method."
msgstr "`entry` metodu kullanarak eklemek için yeni girişi oluşturun."


#: src/ch03-02-dictionaries.md:189
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr "`new_value` `previous_value`'a eşit olduğu yerde girişi geri ekleyin."

#: src/ch03-02-dictionaries.md:190
msgid "Return the value."
msgstr "Değeri döndür."

#: src/ch03-02-dictionaries.md:192
msgid "Implementing our custom get would look like this:"
msgstr "Özel get uygulamamız şu şekilde görünecektir:"

#: src/ch03-02-dictionaries.md:200 src/ch03-02-dictionaries.md:244
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:203 src/ch03-02-dictionaries.md:247
msgid "// Store the value to return\n"
msgstr ""

#: src/ch03-02-dictionaries.md:206 src/ch03-02-dictionaries.md:250
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:209 src/ch03-02-dictionaries.md:253
msgid "// Return the read value\n"
msgstr ""

#: src/ch03-02-dictionaries.md:214
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [References and Snapshots](ch04-02-references-and-snapshots."
"md) section."
msgstr ""
"`ref` anahtar kelimesi, değişkenin sahipliğinin fonksiyonun sonunda geri  
"verileceği anlamına gelir. Bu kavram, [Referanslar ve Snapshot'lar](ch04-02-references-and-snapshots.md)  
"bölümünde daha detaylı açıklanacaktır."


#: src/ch03-02-dictionaries.md:217
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for "
"inserting a new value when finalizing. If we were to implement it, it would "
"look like the following:"
msgstr ""
"`insert` metodunu uygulamak benzer bir iş akışını takip eder, sadece  
"sonlandırırken yeni bir değer eklenir. Uygulayacak olsaydık, şöyle  
"görünecekti:"


#: src/ch03-02-dictionaries.md:225
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:230
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:236
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows "
"some example usage:"
msgstr ""
"Son bir not olarak, bu iki metod, `Felt252Dict<T>` için `insert` ve `get`  
"nasıl uygulandıysa benzer bir şekilde uygulanır. Bu kod, bazı örnek  
"kullanımları gösterir:"


#: src/ch03-02-dictionaries.md:260
msgid "// Get the last entry associated with `key`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:261
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr ""

#: src/ch03-02-dictionaries.md:262
msgid "// be the default value of T.\n"
msgstr ""

#: src/ch03-02-dictionaries.md:265
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr ""

#: src/ch03-02-dictionaries.md:266
msgid "// and receive ownership of the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:273 src/ch03-02-dictionaries.md:275
msgid "'0'"
msgstr ""

#: src/ch03-02-dictionaries.md:277
msgid "\"Expecting 100\""
msgstr ""

#: src/ch03-02-dictionaries.md:283
msgid "Dictionaries of types not supported natively"
msgstr "Yerel olarak desteklenmeyen türlerin sözlükleri"

#: src/ch03-02-dictionaries.md:285
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more "
"complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types "
"not natively supported is not a straightforward task, because you would need "
"to write a couple of trait implementations in order to make the data type a "
"valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"`Felt252Dict<T>`'nin konuşmadığımız bir kısıtlaması, `Felt252DictValue<T>`  
"trait'idir. Bu trait, sözlükte bir değer mevcut değilken çağrılan `zero_default`  
"metodunu tanımlar. Bu, çoğu işaretsiz tamsayı, `bool` ve `felt252` gibi bazı yaygın  
"veri türleri tarafından uygulanır - ancak diziler, yapılar ( `u256` dahil) ve çekirdek  
"kütüphaneden diğer türler gibi daha karmaşık türler için uygulanmaz. Bu, doğal olarak  
"desteklenmeyen türlerin sözlüğünü yapmanın basit bir iş olmadığı anlamına gelir, çünkü  
"veri türünü geçerli bir sözlük değer türü yapmak için birkaç trait uygulaması yazmanız  
"gerekecektir. Bunu telafi etmek için, türünüzü `Nullable<T>` içine sarabilirsiniz."


#: src/ch03-02-dictionaries.md:291
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be "
"`null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a "
"pointer that can only be manipulated in one place at a time."
msgstr ""
"`Nullable<T>`, bir değere işaret edebilen veya değer yokluğunda `null`  
"olabilen akıllı bir işaretçi türüdür. Genellikle, bir referansın hiçbir yere  
"işaret etmediği Nesne Yönelimli Programlama Dillerinde kullanılır. `Option` ile  
"farkı, sarılı değerin `Box<T>` veri türü içinde depolanmasıdır. Rust'tan esinlenilen  
"`Box<T>` türü, türümüz için yeni bir bellek segmenti tahsis etmemize ve bu segmente  
"bir seferde yalnızca bir yerden manipüle edilebilen bir işaretçi kullanarak erişmemize  
"olanak tanır."


#: src/ch03-02-dictionaries.md:293
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a "
"dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"Bir örnekle kullanımını gösterelim. Bir sözlük içinde `Span<felt252>`  
"saklamayı deneyeceğiz. Bunun için `Nullable<T>` ve `Box<T>` kullanacağız. Ayrıca,  
"`Array<T>` yerine bir `Span<T>` saklıyoruz çünkü sonuncusu, bir sözlükten okuma için  
"gerekli olan `Copy<T>` trait'ini uygulamaz."


#: src/ch03-02-dictionaries.md:299 src/ch03-02-dictionaries.md:353
msgid "// Create the dictionary\n"
msgstr ""

#: src/ch03-02-dictionaries.md:302 src/ch03-02-dictionaries.md:356
msgid "// Create the array to insert\n"
msgstr ""

#: src/ch03-02-dictionaries.md:305 src/ch03-02-dictionaries.md:359
msgid "// Insert it as a `Span`\n"
msgstr ""

#: src/ch03-02-dictionaries.md:307 src/ch03-02-dictionaries.md:322
msgid "//...\n"
msgstr ""

#: src/ch03-02-dictionaries.md:311
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"Bu kod parçacığında, ilk olarak `d` adında yeni bir sözlük oluşturduk. Onun  
"`Nullable<Span>` tutmasını istiyoruz. Bunun ardından, bir dizi oluşturduk ve  
"değerlerle doldurduk."


#: src/ch03-02-dictionaries.md:313
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice "
"that we didn't do that directly, but instead, we took some steps in between:"
msgstr ""
"Son adım, diziyi sözlük içinde bir span olarak eklemek. Bunu doğrudan yapmadık,  
"ancak arada bazı adımlar attık:"


#: src/ch03-02-dictionaries.md:315
msgid ""
"We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr ""
"Diziyi `BoxTrait`'ten `new` metodu kullanarak bir `Box` içine sardık."

#: src/ch03-02-dictionaries.md:316
msgid ""
"We wrapped the `Box` inside a nullable using the `nullable_from_box` "
"function."
msgstr ""
"`Box`'ı `nullable_from_box` fonksiyonu kullanarak nullable içine sardık."

#: src/ch03-02-dictionaries.md:317
msgid "Finally, we inserted the result."
msgstr "Son olarak, sonucu ekledik."

#: src/ch03-02-dictionaries.md:319
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve "
"that:"
msgstr ""
"Eleman bir kez sözlük içine girdiğinde ve onu almak istediğimizde, aynı adımları  
"ters sırada takip ediyoruz. Aşağıdaki kod, bunun nasıl yapılabileceğini gösterir:"


#: src/ch03-02-dictionaries.md:324 src/ch03-02-dictionaries.md:362
msgid "// Get value back\n"
msgstr ""

#: src/ch03-02-dictionaries.md:327 src/ch03-02-dictionaries.md:365
msgid "// Search the value and assert it is not null\n"
msgstr ""

#: src/ch03-02-dictionaries.md:329 src/ch03-02-dictionaries.md:367
msgid "\"No value found\""
msgstr ""

#: src/ch03-02-dictionaries.md:333 src/ch03-02-dictionaries.md:371
msgid "// Verify we are having the right values\n"
msgstr ""

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:372
msgid "\"Expecting 8\""
msgstr ""

#: src/ch03-02-dictionaries.md:335 src/ch03-02-dictionaries.md:373
msgid "\"Expecting 9\""
msgstr ""

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:374
msgid "\"Expecting 10\""
msgstr ""

#: src/ch03-02-dictionaries.md:340
msgid "Here we:"
msgstr "İşte geldik:"

#: src/ch03-02-dictionaries.md:342
msgid "Read the value using `get`."
msgstr "`get` kullanarak değeri okuyun."

#: src/ch03-02-dictionaries.md:343
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "`match_nullable` işlevini kullanarak null olmadığını doğrulayın."

#: src/ch03-02-dictionaries.md:344
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "Kutunun içindeki değeri açtı ve doğru olduğunu onayladı."

#: src/ch03-02-dictionaries.md:346
msgid "The complete script would look like this:"
msgstr "Senaryonun tamamı şu şekilde görünecektir:"

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize "
"that arrays have one big limitation - the data stored in them is immutable. "
"Once you append a value to an array, you can't modify it."
msgstr ""
"Cairo'da programlamaya başladığınızda, veri koleksiyonlarını saklamak için  
"dizileri (`Array<T>`) kullanmak isteyeceksiniz. Ancak, dizilerin bir büyük  
"kısıtlaması olduğunu hızlıca fark edeceksiniz - içlerinde saklanan veriler  
"değiştirilemez. Bir dizinin sonuna bir değer ekledikten sonra, bu değeri  
"modifiye edemezsiniz."


#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"Bu, değiştirilebilir bir veri yapısı kullanmak istediğinizde sinir bozucu  
"olabilir. Örneğin, oyuncuların bir seviyesi olduğu ve seviye atlayabildikleri  
"bir oyun yapıyorsunuz diyelim. Oyuncuların seviyelerini bir diziye saklamayı  
"deneyebilirsiniz:"


#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""
"Ancak daha sonra, belirli bir indeksteki seviyeyi ayarlandıktan sonra  
"artıramayacağınızı fark edersiniz. Bir oyuncu ölürse, ilk pozisyonda değilse,  
"onu diziden çıkaramazsınız."


#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary type](./ch03-02-"
"dictionaries.md) called `Felt252Dict<T>` that allows us to simulate the "
"behavior of mutable data structures. Let's first explore how to create a "
"struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""
"Şans eseri, Cairo değiştirilebilir veri yapılarının davranışını simüle  
"etmemize izin veren `Felt252Dict<T>` adında kullanışlı yerleşik bir [sözlük  
"türü](./ch03-02-dictionaries.md) sunar. Önce, aralarında bir `Felt252Dict<T>`  
"içeren bir yapı oluşturmayı inceleyelim."


#: src/ch03-03-custom-data-structures.md:27
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of "
"the book. We recommend you to check out the following chapter first: "
"[Structs](ch05-00-using-structs-to-structure-related-data.md), [Methods](./"
"ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-types-and-"
"traits.md), [Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"Not: Bu bölümde kullanılan bazı kavramlar kitabın sonraki kısımlarında  
"sunulmuştur. Önce şu bölümlere göz atmanızı öneririz: [Yapılar](ch05-00-using-structs-to-structure-related-data.md),  
"[Metodlar](./ch05-03-method-syntax.md), [Genel türler](./ch08-00-generic-types-and-traits.md),  
"[Özellikler](./ch08-02-traits-in-cairo.md)."


#: src/ch03-03-custom-data-structures.md:34
msgid "Dictionaries as Struct Members"
msgstr "Struct Üyeleri Olarak Sözlükler"

#: src/ch03-03-custom-data-structures.md:36
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a "
"custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define "
"its functionality:"
msgstr ""
"Cairo'da yapı üyeleri olarak sözlükleri tanımlamak mümkündür ancak onlarla  
"doğru şekilde etkileşim kurmak tamamen sorunsuz olmayabilir. Kullanıcıları  
"ekleyebileceğimiz ve sorgulayabileceğimiz özel bir _kullanıcı veritabanı_  
"uygulamayı deneyelim. Yeni tipi temsil etmek için bir yapı ve işlevselliğini  
"tanımlamak için bir özellik tanımlamamız gerekecek:"


#: src/ch03-03-custom-data-structures.md:51
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic "
"over the balances of the users, giving major flexibility to whoever uses our "
"data type. Its two members are:"
msgstr ""
"Yeni tipimiz `UserDatabase<T>`, kullanıcıların bir veritabanını temsil eder.  
"Kullanıcıların bakiyeleri üzerinden genel olarak tanımlanmıştır, bu da  
"veri tipimizi kullanan herkese büyük bir esneklik sağlar. İki üyesi vardır:"


#: src/ch03-03-custom-data-structures.md:53
msgid "`users_updates`, the number of users updates in the dictionary and"
msgstr "`users_updates`, sözlükteki kullanıcı güncelleme sayısı ve"

#: src/ch03-03-custom-data-structures.md:54
msgid "`balances`, a mapping of each user to its balance."
msgstr "`balances`, her bir kullanıcının bakiyesiyle eşleştirilmesi."

#: src/ch03-03-custom-data-structures.md:56
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr ""
"Veritabanının temel işlevselliği `UserDatabaseTrait` tarafından tanımlanır.  
"Tanımlanan metodlar şunlardır:"


#: src/ch03-03-custom-data-structures.md:58
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "`new`, yeni `UserDatabase` türlerini kolayca oluşturmak için."

#: src/ch03-03-custom-data-structures.md:59
msgid "`update_user` to update the balance of users in the database."
msgstr "`update_user`, veritabanındaki kullanıcıların bakiyelerini güncellemek için."

#: src/ch03-03-custom-data-structures.md:60
msgid "`get_balance` to find user's balance in the database."
msgstr "`get_balance`, veritabanında kullanıcının bakiyesini bulmak için."

#: src/ch03-03-custom-data-structures.md:62
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [generic types](/src/"
"ch08-00-generic-types-and-traits.md) we also need to correctly establish the "
"requirements of `T` so it can be a valid `Felt252Dict<T>` value type:"
msgstr ""
"`UserDatabaseTrait` içindeki her bir metodun uygulanması kalan tek adımdır,  
"ancak [genel türler](/src/ch08-00-generic-types-and-traits.md) ile çalıştığımız için, `T`'nin  
"geçerli bir `Felt252Dict<T>` değer türü olabilmesi için gereksinimleri doğru bir şekilde 
"belirlememiz gerekiyor:"


#: src/ch03-03-custom-data-structures.md:64
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr ""
"`T`, bir `Felt252Dict<T>`'den değerler almak için gereken `Copy<T>` trait'ini  
"uygulamalıdır."


#: src/ch03-03-custom-data-structures.md:65
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr ""
"Bir sözlüğün tüm değer türleri `Felt252DictValue<T>`'i uygular, bizim genel  
"türümüz de bunu yapmalıdır."


#: src/ch03-03-custom-data-structures.md:66
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"destructible."
msgstr ""
"Değerleri eklemek için, `Felt252DictTrait<T>` tüm değer türlerinin  
"yok edilebilir olmasını gerektirir."


#: src/ch03-03-custom-data-structures.md:68
msgid "The implementation, with all restrictions in place, would be as follow:"
msgstr "Tüm kısıtlamalar yürürlükteyken uygulama aşağıdaki gibi olacaktır:"

#: src/ch03-03-custom-data-structures.md:74
#: src/ch03-03-custom-data-structures.md:119
msgid "// Creates a database\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:79
#: src/ch03-03-custom-data-structures.md:124
msgid "// Get the user's balance\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:84
#: src/ch03-03-custom-data-structures.md:129
msgid "// Add a user\n"
msgstr ""

#: src/ch03-03-custom-data-structures.md:92
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since "
"it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. Since "
"it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are "
"forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of [genericity](/src/ch08-00-"
"generic-types-and-traits.md) in the struct definition. We need to code the "
"`Destruct<T>` trait implementation by ourselves:"
msgstr ""
"Veritabanı uygulamamız neredeyse tamamlandı, tek bir eksik var: derleyici,  
"`UserDatabase<T>`'nin kapsam dışına çıkma şeklini bilmiyor, çünkü `Drop<T>`  
"trait'ini veya `Destruct<T>` trait'ini uygulamıyor. Bir `Felt252Dict<T>`'yi  
"üye olarak içerdiği için bırakılamaz, bu yüzden `Destruct<T>` trait'ini  
"manuel olarak uygulamak zorundayız ([Sahiplik](ch04-01-what-is-ownership.md#the-drop-trait)  
"bölümüne daha fazla bilgi için bakınız). `UserDatabase<T>` tanımının üstüne  
"`#[derive(Destruct)]` kullanmak, yapı tanımında [genellik](/src/ch08-00-generic-types-and-traits.md)  
"kullanımı nedeniyle işe yaramaz. `Destruct<T>` trait uygulamasını kendimiz kodlamalıyız:"


#: src/ch03-03-custom-data-structures.md:104
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""
"`UserDatabase` için `Destruct<T>`'yi uygulamak, tamamen işlevsel bir veritabanına  
"sahip olmak için son adımımızdı. Şimdi bunu deneyebiliriz:"


#: src/ch03-03-custom-data-structures.md:154
msgid "\"Expected 40\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:155
msgid "\"Expected 0\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:161
msgid "Simulating a dynamic array with dicts"
msgstr "Dinamik bir diziyi dicts ile simüle etme"

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr ""
"Öncelikle, değiştirilebilir dinamik dizimizin nasıl davranmasını istediğimiz  
"hakkında düşünelim. Hangi işlemleri desteklemelidir?"


#: src/ch03-03-custom-data-structures.md:166
msgid "It should:"
msgstr ""

#: src/ch03-03-custom-data-structures.md:168
msgid "Allow us to append items at the end."
msgstr "Sonuna öğe eklememize izin verin."

#: src/ch03-03-custom-data-structures.md:169
msgid "Let us access any item by index."
msgstr "Herhangi bir öğeye dizine göre erişelim."

#: src/ch03-03-custom-data-structures.md:170
msgid "Allow setting the value of an item at a specific index."
msgstr "Bir öğenin değerini belirli bir dizinde ayarlamaya izin verir."

#: src/ch03-03-custom-data-structures.md:171
msgid "Return the current length."
msgstr "Geçerli uzunluğu döndürür."

#: src/ch03-03-custom-data-structures.md:173
msgid "We can define this interface in Cairo like:"
msgstr "Bu arayüzü Cairo'daki gibi tanımlayabiliriz:"

#: src/ch03-03-custom-data-structures.md:186
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"Bu, dinamik dizimizin uygulaması için bir plan sağlar. Bunu Rust'taki `Vec<T>`  
"veri yapısına benzer olduğu için _Vec_ olarak adlandırdık."


#: src/ch03-03-custom-data-structures.md:189
msgid "Implementing a dynamic array in Cairo"
msgstr "Cairo'da dinamik bir dizi uygulama"

#: src/ch03-03-custom-data-structures.md:191
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"Verilerimizi saklamak için, indeks numaralarını (felts) değerlere eşleyen bir  
"`Felt252Dict<T>` kullanacağız. Ayrıca, uzunluğu takip etmek için ayrı bir `len` alanı saklayacağız."


#: src/ch03-03-custom-data-structures.md:194
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"İşte yapımızın nasıl göründüğü. `T` türünü `Nullable` işaretçi içine sarıyoruz ki,  
"[Sözlükler](./ch03-02-dictionaries.md#dictionaries-of-types-not-supported-natively) bölümünde açıklandığı gibi,  
"veri yapımızda herhangi bir `T` türünü kullanabilmemize izin verilsin:"


#: src/ch03-03-custom-data-structures.md:206
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""
"Bu vektörü değiştirilebilir kılan ana şey, veri yapımızda değerleri ayarlamak veya  
"güncellemek için sözlüğe değerler ekleyebilmemizdir. Örneğin, belirli bir indeksteki  
"değeri güncellemek için şunu yaparız:"


#: src/ch03-03-custom-data-structures.md:212
#: src/ch03-03-custom-data-structures.md:241
#: src/ch03-03-custom-data-structures.md:250
msgid "\"Index out of bounds\""
msgstr ""

#: src/ch03-03-custom-data-structures.md:217
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr ""
"Bu, sözlükteki o indeksteki önceden var olan değerin üzerine yazar."

#: src/ch03-03-custom-data-structures.md:219
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for "
"modifiable data structures like vectors."
msgstr ""
"Diziler değiştirilemezken, sözlükler vektörler gibi değiştirilebilir veri yapıları " 
"için ihtiyacımız olan esnekliği sağlar."


#: src/ch03-03-custom-data-structures.md:222
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr ""
"Arayüzün geri kalanının uygulanması basittir. Arayüzümüzde tanımlanan tüm metodların " 
"uygulanması şu şekilde yapılabilir:"


#: src/ch03-03-custom-data-structures.md:259
msgid ""
"The full implementation of the `Vec` structure can be found in the community-"
"maintained library [Alexandria](https://github.com/keep-starknet-strange/"
"alexandria/tree/main/src/data_structures)."
msgstr ""
"`Vec` yapısının tam uygulaması, topluluk tarafından sürdürülen [Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)  
"kütüphanesinde bulunabilir."


#: src/ch03-03-custom-data-structures.md:263
msgid "Simulating a Stack with dicts"
msgstr "Yığını diktelerle simüle etme"

#: src/ch03-03-custom-data-structures.md:265
msgid ""
"We will now look at a second example and its implementation details: a Stack."
msgstr ""
"Şimdi ikinci bir örneğe ve onun uygulama detaylarına bakacağız: Bir Stack."


#: src/ch03-03-custom-data-structures.md:267
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"Bir Yığın, LIFO (Last-In, First-Out) bir koleksiyondur. Yeni bir elemanın ekleme  
"ve mevcut bir elemanın çıkarma işlemi aynı uçta, yığının tepesi olarak temsil  
"edilen yerde gerçekleşir."


#: src/ch03-03-custom-data-structures.md:271
msgid "Let us define what operations we need to create a stack :"
msgstr "Bir yığın oluşturmak için hangi işlemlere ihtiyacımız olduğunu tanımlayalım:"


#: src/ch03-03-custom-data-structures.md:273
msgid "Push an item to the top of the stack."
msgstr "Yığının tepesine bir öğe ekleyin."


#: src/ch03-03-custom-data-structures.md:274
msgid "Pop an item from the top of the stack."
msgstr "Yığının tepesinden bir öğe çıkarın."


#: src/ch03-03-custom-data-structures.md:275
msgid "Check whether there are still any elements in the stack."
msgstr "Yığında hala eleman olup olmadığını kontrol edin."

#: src/ch03-03-custom-data-structures.md:277
msgid "From these specifications we can define the following interface :"
msgstr "Bu özelliklerden yola çıkarak aşağıdaki arayüzü tanımlayabiliriz:"


#: src/ch03-03-custom-data-structures.md:287
msgid "Implementing a Mutable Stack in Cairo"
msgstr "Cairo'da Değiştirilebilir Bir Yığın Uygulamak"


#: src/ch03-03-custom-data-structures.md:289
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field "
"to keep track of the length of the stack to iterate over it."
msgstr ""
"Cairo'da bir yığın veri yapısı oluşturmak için, yığının değerlerini saklamak ve  
"üzerinde yineleme yapmak için yığının uzunluğunu takip etmek amacıyla bir `usize`  
"alanı ile birlikte yine bir `Felt252Dict<T>` kullanabiliriz."


#: src/ch03-03-custom-data-structures.md:293
msgid "The Stack struct is defined as:"
msgstr "Stack yapısı şu şekilde tanımlanır:"

#: src/ch03-03-custom-data-structures.md:302
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr ""
"Şimdi, ana fonksiyonlarımız olan `push` ve `pop`'un nasıl uygulandığını görelim."

#: src/ch03-03-custom-data-structures.md:325
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function retrieves the last value at position "
"`len-1` and then decreases the value of `len` to update the position of the "
"stack top accordingly."
msgstr ""
"Kod, `Felt252Dict<T>` içindeki değerlere erişmek için `insert` ve `get` metodlarını 
"kullanır. Yığının tepesine bir eleman eklemek için, `push` fonksiyonu elemanı `len`  
"indeksinde sözlüğe ekler ve yığının tepesinin pozisyonunu takip etmek için `len` alanını 
"artırır. Bir değeri kaldırmak için, `pop` fonksiyonu `len-1` pozisyonundaki son değeri 
"alır ve ardından yığının tepesinin pozisyonunu güncellemek için `len` değerini azaltır. "


#: src/ch03-03-custom-data-structures.md:333
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/"
"src/data_structures) library, in the \"data_structures\" crate."
msgstr ""
"Yığının tam uygulaması, kodunuzda kullanabileceğiniz daha 
"fazla veri yapısı ile birlikte, topluluk tarafından sürdürülen  
"[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/src/data_structures)  
"kütüphanesinde, \"data_structures\" crate'inde bulunabilir. "


#: src/ch03-03-custom-data-structures.md:340
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures.  While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to "
"implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"Harika! Artık diziler, sözlükler ve hatta özel veri yapıları 
"hakkında bilgiye sahipsiniz. Cairo'nun bellek modeli değiştirilemez 
"olduğu ve değiştirilebilir veri yapılarını uygulamayı zorlaştırabileceği 
"halde, neyse ki `Felt252Dict<T>` türünü değiştirilebilir veri yapılarını  
"simüle etmek için kullanabiliriz. Bu, birçok uygulama için yararlı olan 
"geniş bir veri yapısı yelpazesini uygulamamıza olanak tanır, etkili bir 
"şekilde altta yatan bellek modelinin karmaşıklığını gizler."


#: src/ch03-03-custom-data-structures.md:347
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that doesn’t commonly exist in other programming languages: "
"ownership."
msgstr ""
"Hazır olduğunuzda, Cairo'nun Rust ile paylaştığı ve diğer programlama  
"dillerinde yaygın olmayan bir kavramdan bahsedeceğiz: sahiplik."


#: src/ch04-00-understanding-ownership.md:1
msgid "Understanding Cairo's Ownership system"
msgstr "Cairo'nun Mülkiyet Sistemini Anlamak"

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once. "
"This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"Cairo, değerlerin her Cairo programında tam olarak bir kez kullanılmasını "
"statik olarak garanti altına alan doğrusal bir tip sistemine dayalı olarak "
"kurulmuş bir dildir. Bu doğrusal tip sistemi, bir bellek hücresine iki kez "
"yazma gibi hatalara yol açabilecek işlemlerin çalışma zamanı hatalarını  "
"önleyerek derleme zamanında tespit edilmesini sağlar. Bu, bir sahiplik "
"sistemi uygulayarak ve değerlerin varsayılan olarak kopyalanmasını ve "
"atılmasını yasaklayarak başarılır. Bu bölümde, Cairo'nun sahiplik sisteminden "
"ve referanslar ile anlık görüntülerden bahsedeceğiz."

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr "Doğrusal Tip Sistemi Kullanarak Sahiplik"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr "Cairo, doğrusal bir tip sistemini kullanır. Bu tip sistemde, herhangi bir değer (bir temel tip, bir yapı, bir enum) kullanılmalı ve yalnızca bir kez kullanılmalıdır. 'Kullanılmış' burada, değerin ya _yok edilmesi_ ya da _taşınması_ anlamına gelir."


#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr "_Yok etme_ birkaç şekilde gerçekleşebilir:"


#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope"
msgstr "bir değişkenin kapsamı dışına çıkması"


#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured"
msgstr "bir yapının yapılandırılması açılması"


#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using destruct()"
msgstr "destruct() kullanılarak açık yok etme"

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr "Bir değeri _taşımak_ basitçe o değeri başka bir fonksiyona geçirmek demektir."

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr "Bu, Rust sahiplik modeline benzer bazı kısıtlamalar sonucunu doğurur, ancak bazı farklılıklar vardır. Özellikle, Rust sahiplik modeli kısmen veri yarışlarını ve bir bellek değerine yönelik eşzamanlı değişebilir erişimi önlemek için var olur. Bu, Cairo'da imkansızdır çünkü bellek değişmez. Bunun yerine, Cairo doğrusal tip sistemini iki ana amaç için kullanır:"


#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr "Tüm kodun kanıtlanabilir ve dolayısıyla doğrulanabilir olduğunu sağlamak."

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr "Cairo VM'nin değişmez belleğini soyutlamak."

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr "Sahiplik"

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr "Cairo'da, sahiplik _değerlere_ değil, _değişkenlere_ uygulanır. Bir değer, değer kendisi her zaman değişmez olduğu için birçok farklı değişken tarafından güvenle atıfta bulunulabilir (hatta değişebilir değişkenler olsalar bile). Ancak değişkenler değişebilir olabilir, bu yüzden derleyici, sabit değişkenlerin yanlışlıkla programcı tarafından değiştirilmediğinden emin olmalıdır. Bu, bir değişkenin sahipliğinden bahsetmeyi mümkün kılar: sahip, değişkeni okuyabilen (ve değişebilir ise yazabilen) koddur."

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr "Bu, değişkenlerin (değerler değil) Rust değerlerine benzer kuralları izlediği anlamına gelir:"

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr "Cairo'daki her değişkenin bir sahibi vardır."

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr "Bir zaman da yalnızca bir sahip olabilir."

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr "Sahip kapsam dışına çıktığında, değişken yok edilir."

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` examples inside a `main` function manually. As a result, our examples "
"will be a code in examples, so if you’re following along, make sure to put "
"the following bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr "Artık temel Cairo sözdizimini geride bıraktığımıza göre, `fn main() {` örneklerinin tümünü manuel olarak bir `main` fonksiyonunun içine dahil etmeyeceğiz. Sonuç olarak, örneklerimiz örneklerde bir kod olacak, bu nedenle eğer takip ediyorsanız, aşağıdaki bölümü daha öz hale getirin, böylece dikkatimizi kalıp kodlar yerine gerçek detaylara odaklayabiliriz."

#: src/ch04-01-what-is-ownership.md:38
msgid "Variable Scope"
msgstr "Değişken Kapsamı"

#: src/ch04-01-what-is-ownership.md:40
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr "Doğrusal tip sisteminin ilk örneği olarak, bazı değişkenlerin _kapsamına_ bakacağız. Bir kapsam, bir program içinde bir öğenin geçerli olduğu aralıktır. Aşağıdaki değişkeni alın:"

#: src/ch04-01-what-is-ownership.md:48
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr "`s` değişkeni kısa bir metni ifade eder. Değişken, tanımlandığı noktadan itibaren geçerli olduğu mevcut _kapsamın_ sonuna kadar geçerlidir. Liste 4-1, `s` değişkeninin nerede geçerli olacağını açıklayan yorumlarla bir programı gösterir."


#: src/ch04-01-what-is-ownership.md:53
msgid "//TAG: ignore_fmt\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:55
msgid "// s is not valid here, it’s not yet declared\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:56
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:58
msgid "// this scope is now over, and s is no longer valid\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:62
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr ""

#: src/ch04-01-what-is-ownership.md:64
msgid "In other words, there are two important points in time here:"
msgstr "Diğer bir deyişle, burada iki önemli zaman noktası vardır:"

#: src/ch04-01-what-is-ownership.md:66
msgid "When `s` comes _into_ scope, it is valid."
msgstr "`s` kapsama _girdiğinde_, geçerlidir."

#: src/ch04-01-what-is-ownership.md:67
msgid "It remains valid until it goes _out of_ scope."
msgstr "_Kapsam dışına_ çıkana kadar geçerli kalır."

#: src/ch04-01-what-is-ownership.md:69
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by using the `Array` type we introduced in the [previous "
"chapter](./ch03-01-arrays.md)."
msgstr "Bu noktada, kapsamlar ve değişkenlerin ne zaman geçerli olduğu arasındaki ilişki, diğer programlama dillerindeki ile benzerdir. Şimdi, [önceki bölümde](./ch03-01-arrays.md) tanıttığımız `Array` tipini kullanarak bu anlayışın üzerine inşa edeceğiz."

#: src/ch04-01-what-is-ownership.md:71
msgid "Moving values - example with Array"
msgstr "Değerleri Taşımak - Array ile örnek"

#: src/ch04-01-what-is-ownership.md:73
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another "
"function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is "
"created to hold the same value."
msgstr "Daha önce belirtildiği gibi, bir değeri _taşımak_ basitçe o değeri başka bir fonksiyona geçirmek demektir. Bu olduğunda, orijinal kapsamdaki değere atıfta bulunan değişken yok edilir ve artık kullanılamaz hale gelir ve aynı değeri tutmak için yeni bir değişken oluşturulur."

#: src/ch04-01-what-is-ownership.md:75
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr "Diziler, başka bir fonksiyona geçirildiğinde taşınan karmaşık bir tipin bir örneğidir. İşte bir dizinin nasıl göründüğüne dair kısa bir hatırlatma:"

#: src/ch04-01-what-is-ownership.md:86
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr "Tip sistemi, Cairo programının asla aynı bellek hücresine iki kez yazmaya çalışmamasını nasıl sağlar? Aşağıdaki kodu düşünün, burada dizinin önünü iki kez kaldırmaya çalışıyoruz:"

#: src/ch04-01-what-is-ownership.md:101
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr "Bu durumda, aynı değeri (`arr` değişkenindeki dizi) her iki fonksiyon çağrısına da geçirmeye çalışıyoruz. Bu, kodumuzun ilk elemanı iki kez kaldırmaya çalıştığı anlamına gelir ki bu, aynı bellek hücresine iki kez yazmaya çalışır - bu Cairo VM tarafından yasaklanmıştır ve bir çalışma zamanı hatasına yol açar. Neyse ki, bu kod aslında derlenmez. Diziyi `foo` fonksiyonuna geçirdikten sonra, `arr` değişkeni artık kullanılamaz. Bu derleme zamanı hatasını alırız, bize Array'in Copy Trait'ini uygulaması gerektiğini söyler:"

#: src/ch04-01-what-is-ownership.md:111
msgid "The Copy trait"
msgstr "Copy özelliği"

#: src/ch04-01-what-is-ownership.md:113
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation, because variables are a cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr "Bir tip `Copy` özelliğini uygularsa, o tipten bir değeri bir fonksiyona geçirmek değeri taşımaz. Bunun yerine, aynı değere atıfta bulunan yeni bir değişken oluşturulur. Burada dikkat edilmesi gereken önemli şey, bu işlemin tamamen ücretsiz bir işlem olmasıdır, çünkü değişkenler yalnızca bir cairo soyutlamasıdır ve Cairo'daki _değerler_ her zaman değişmezdir. Bu, özellikle, değerin bellekte potansiyel olarak kopyalandığı Rust versiyonundaki `Copy` özelliğinden kavramsal olarak farklıdır."

#: src/ch04-01-what-is-ownership.md:116
msgid ""
"You can implement the `Copy` trait on your type by adding the "
"`#[derive(Copy)]` annotation to your type definition. However, Cairo won't "
"allow a type to be annotated with Copy if the type itself or any of its "
"components don't implement the Copy trait. While Arrays and Dictionaries "
"can't be copied, custom types that don't contain either of them can be."
msgstr "Tür tanımınıza `#[derive(Copy)]` ekleyerek türünüze `Copy` özelliğini uygulayabilirsiniz. Ancak, türün kendisi veya bileşenlerinden herhangi biri Copy özelliğini uygulamıyorsa, Cairo bir türün Copy ile etiketlenmesine izin vermez. Diziler ve Sözlükler kopyalanamazken, bunlardan herhangi birini içermeyen özel türler kopyalanabilir."

#: src/ch04-01-what-is-ownership.md:132
msgid "// do something with p\n"
msgstr "// p ile bir şeyler yapın\n"

#: src/ch04-01-what-is-ownership.md:136
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the main "
"function. If you remove the `Copy` trait derivation from the `Point` type, "
"you will get a compile-time error when trying to compile the code."
msgstr "Bu örnekte, `Point` tipi `Copy` özelliğini uyguladığı için `p1`'i foo fonksiyonuna iki kez geçirebiliriz. Bu, `p1`'i `foo`'ya geçirdiğimizde aslında `p1`'in bir kopyasını geçirdiğimiz anlamına gelir, bu yüzden `p1` geçerli kalır. Sahiplik terimleriyle, bu, `p1`'in sahipliğinin ana fonksiyonla kaldığı anlamına gelir. `Point` tipinden `Copy` özelliği türetmesini kaldırırsanız, kodu derlemeye çalışırken bir derleme zamanı hatası alırsınız."

#: src/ch04-01-what-is-ownership.md:139
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr "`Struct` anahtar kelimesi hakkında endişelenmeyin. Bunu [Bölüm 5](ch05-00-using-structs-to-structure-related-data.md)’te tanıtacağız."

#: src/ch04-01-what-is-ownership.md:141
msgid "Destroying values - example with FeltDict"
msgstr "Değerleri Yok Etme - FeltDict ile örnek"

#: src/ch04-01-what-is-ownership.md:143
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr "Doğrusal tiplerin _kullanılma_ yollarından bir diğeri yok edilerek olur. Yok etme, 'kaynağın' artık doğru bir şekilde serbest bırakıldığından emin olmalıdır. Örneğin Rust'ta, bu bir dosyaya erişimin kapatılması veya bir mutex'in kilitlemesi olabilir. Cairo'da, böyle bir davranışı olan bir tip `Felt252Dict`'tir. Kanıtlanabilirlik için, sözlükler yok edildiklerinde 'ezilmelidir'. Bu, çok kolay unutulabilen bir şey olduğundan, tip sistemi ve derleyici tarafından zorunlu kılınır."


#: src/ch04-01-what-is-ownership.md:147
msgid "No-op destruction: the Drop Trait"
msgstr "Etkisiz yok etme: Drop Özelliği"

#: src/ch04-01-what-is-ownership.md:149
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out "
"of scope:"
msgstr "Önceki örnekteki `Point` tipinin de `Drop` özelliğini uyguladığını fark etmiş olabilirsiniz. Örneğin, aşağıdaki kod, `A` yapısı kapsam dışına çıkmadan önce taşınmadığı veya yok edilmediği için derlenmez:"

#: src/ch04-01-what-is-ownership.md:156
msgid "// error: Value not dropped.\n"
msgstr "// hata: Değer bırakılmadı.\n"

#: src/ch04-01-what-is-ownership.md:160
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr "Ancak, `Drop` özelliğini uygulayan tipler, kapsam dışına çıktıklarında otomatik olarak yok edilir. Bu yok etme işlemi hiçbir şey yapmaz, bir etkisiz işlemdir - sadece bu tipin artık yararlı olmadığında güvenle yok edilebileceğine dair derleyiciye bir ipucudur. Buna bir değeri \"bırakmak\" diyoruz."

#: src/ch04-01-what-is-ownership.md:162
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries "
"(`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr "Şu anda, `Drop` uygulaması, sözlükler (`Felt252Dict`) ve sözlük içeren tipler hariç, tüm tipler için türetilebilir ve bunların kapsam dışına çıktıklarında bırakılmalarına izin verilir. Örneğin, aşağıdaki kod derlenir:"

#: src/ch04-01-what-is-ownership.md:170
msgid "// Now there is no error.\n"
msgstr "// Şimdi bir hata yok.\n"

#: src/ch04-01-what-is-ownership.md:174
msgid "Destruction with a side-effect: the Destruct trait"
msgstr "Yan etkili yok etme: Destruct Özelliği"

#: src/ch04-01-what-is-ownership.md:176
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr "Bir değer yok edildiğinde, derleyici önce o tip üzerinde `drop` metodunu çağırmayı dener. Eğer bu mevcut değilse, derleyici bunun yerine `destruct`'u çağırmayı dener. Bu metod, `Destruct` özelliği tarafından sağlanır."

#: src/ch04-01-what-is-ownership.md:178
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr "Daha önce belirtildiği gibi, Cairo'daki sözlükler, yok edildiklerinde \"ezilmeleri\" gereken tiplerdir, böylece erişim sırası kanıtlanabilir. Bu, geliştiricilerin unutması kolaydır, bu yüzden sözlükler kapsam dışına çıktıklarında tüm sözlüklerin _ezilmesini_ sağlamak için `Destruct` özelliğini uygularlar. Bu nedenle, aşağıdaki örnek derlenmez:"

#: src/ch04-01-what-is-ownership.md:191
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "Bu kodu çalıştırmayı denerseniz, bir derleme zamanı hatası alırsınız:"

#: src/ch04-01-what-is-ownership.md:200
msgid ""
"When A goes out of scope, it can't be dropped as it implements neither the "
"`Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr "`A` kapsam dışına çıktığında, ne `Drop`'u (bir sözlük içerdiği ve `derive(Drop)` yapılamadığı için) ne de `Destruct` özelliğini uyguladığı için bırakılamaz. Bunu düzeltmek için, `A` tipi için `Destruct` özelliği uygulamasını türetebiliriz:"

#: src/ch04-01-what-is-ownership.md:209
msgid "// No error here\n"
msgstr "// Burada bir hata yok\n"

#: src/ch04-01-what-is-ownership.md:213
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr "Şimdi, `A` kapsam dışına çıktığında, sözlüğü otomatik olarak `ezilecek` ve program derlenecek."

#: src/ch04-01-what-is-ownership.md:215
msgid "Copy Array data with Clone"
msgstr "Clone ile Dizi Verilerini Kopyala"

#: src/ch04-01-what-is-ownership.md:217
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in Chapter 6, but because "
"methods are a common feature in many programming languages, you’ve probably "
"seen them before."
msgstr "Bir `Array`'in verilerini derinlemesine kopyalamak istiyorsak, `clone` adında yaygın bir metod kullanabiliriz. Metod sözdizimini Bölüm 6'da tartışacağız, ancak metodlar birçok programlama dilinde yaygın bir özellik olduğu için, muhtemelen daha önce görmüşsünüzdür."


#: src/ch04-01-what-is-ownership.md:219
msgid "Here’s an example of the `clone` method in action."
msgstr "İşte `clone` metodunun eylemdeki bir örneği."


#: src/ch04-01-what-is-ownership.md:228
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, _value_ is being copied, "
"resulting in new memory cells being used, and a new _variable_ is created, "
"referring to the new, copied value."
msgstr "`clone` çağrısını gördüğünüzde, bazı keyfi kodların çalıştırıldığını ve bu kodun pahalı olabileceğini biliyorsunuz. Bu, farklı bir şeylerin olduğunun görsel bir göstergesidir. Bu durumda, _değer_ kopyalanır, yeni bellek hücreleri kullanılır ve yeni, kopyalanan değere atıfta bulunan yeni bir _değişken_ oluşturulur."


#: src/ch04-01-what-is-ownership.md:231
msgid "Return Values and Scope"
msgstr "Dönüş Değerleri ve Kapsam"


#: src/ch04-01-what-is-ownership.md:233
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""
"Değerleri döndürmek, onları _taşımak_ ile eşdeğerdir. Liste 4-2, benzer notasyonlarla bazı değerler döndüren bir fonksiyonun bir örneğini gösterir."


#: src/ch04-01-what-is-ownership.md:244
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:247
msgid "// a2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:249
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which "
"also\n"
"                                          // moves its return value into a3\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:253
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:256
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:260
msgid "// some_a comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:262
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:266
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:268
msgid ""
"// some_a comes into\n"
"                                          // scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:271
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:277
msgid "Listing 4-2: Moving return values"
msgstr "Liste 4-3: Birden fazla değer döndürmek"



#: src/ch04-01-what-is-ownership.md:279
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the "
"function that we might want to return as well."
msgstr ""
"Bu işe yarasa da, her fonksiyona girip çıkmak biraz yorucu. Bir değeri bir fonksiyona kullanması için vermek ama değeri taşımamak istiyorsak ne olur? İstediğimiz her şeyi içeri vermek ve tekrar kullanmak istiyorsak geri vermek zorunda olmamız oldukça can sıkıcı, fonksiyonun gövdesinden kaynaklanan herhangi bir veriyi de döndürmek isteyebiliriz."


#: src/ch04-01-what-is-ownership.md:281
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr ""
"Cairo bize bir demet kullanarak birden fazla değeri döndürme imkanı tanır, Liste 4-3'te gösterildiği gibi."


#: src/ch04-01-what-is-ownership.md:293
msgid "// len() returns the length of an array\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:299
msgid "Listing 4-3: Returning many values"
msgstr ""
"Liste 4-3: Birden fazla değer döndürmek"


#: src/ch04-01-what-is-ownership.md:301
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""
"Ama bu çok fazla tören ve olması gereken bir kavram için çok fazla iş. Neyse ki, Cairo bizim için bir değeri yok etmeden veya taşımadan geçirmek için _referanslar_ ve _anlık görüntüler_ adında iki özelliğe sahip."


#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"Önceki Liste 4-3'teki demet kodunun sorunu, `calculate_length` çağrısından sonra `Array`'i hala kullanabilmemiz için `Array`'i çağıran fonksiyona geri döndürmemiz gerektiğidir, çünkü `Array` `calculate_length` içine taşınmıştı."


#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr "Anlık Görüntüler"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""
"Önceki bölümde, Cairo'nun sahiplik sisteminin, bir değişkeni taşıdıktan sonra onu kullanmamızı engelleyerek, aynı bellek hücresine potansiyel olarak iki kez yazmamızı önlediğinden bahsettik. Ancak, bu pek uygun değil. Çağıran fonksiyonda değişkenin sahipliğini anlık görüntüler kullanarak nasıl koruyabileceğimizi görelim."


#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates "
"a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""
"Cairo'da, bir anlık görüntü, belirli bir zamandaki bir değerin değişmez bir görünümüdür. Belleğin değişmez olduğunu hatırlayın, bu yüzden bir değeri değiştirmek aslında yeni bir bellek hücresi oluşturur. Eski bellek hücresi hala var olur ve anlık görüntüler o \"eski\" değere atıfta bulunan değişkenlerdir. Bu anlamda, anlık görüntüler \"geçmişe bir bakış\"tır."


#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""
"İşte, bir dizi görüntüsünü parametre olarak alarak altta yatan değerin sahipliğini almak yerine bir `calculate_length` fonksiyonunu nasıl tanımlayıp kullanacağınızı gösteren bir örnek. Bu örnekte, `calculate_length` fonksiyonu, parametre olarak geçirilen dizinin uzunluğunu döndürür. Bu, diziye bir görüntü olarak geçirdiğimiz için, diziye mutasyon uygulanmayacağından emin olabiliriz ve dizi sahipliği `main` fonksiyonunda tutulur."

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:62
msgid "// Calculate the current length of the array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on non-"
"snapshot types."
msgstr ""
"Not: Anlık görüntü üzerinde `len()` metodunu çağırabilmemizin nedeni, `ArrayTrait` özelliğinde bu şekilde tanımlanmış olmasıdır. Anlık görüntüler için tanımlanmamış bir metodu anlık görüntü üzerinde çağırmayı denerseniz, bir derleme hatası alırsınız. Ancak, anlık görüntü bekleyen metodları anlık görüntü olmayan tipler üzerinde çağırabilirsiniz."


#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr "Bu programın çıktısı:"


#: src/ch04-02-references-and-snapshots.md:56
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""
"İlk olarak, değişken tanımı ve fonksiyon dönüş değerindeki tüm demet kodunun gittiğini fark edin. İkinci olarak, `@arr1`'i `calculate_length`'e geçirdiğimizi ve tanımında `Array<u128>` yerine `@Array<u128>` aldığımızı not edin."


#: src/ch04-02-references-and-snapshots.md:59
msgid "Let’s take a closer look at the function call here:"
msgstr "Fonksiyon çağrısına burada daha yakından bakalım:"


#: src/ch04-02-references-and-snapshots.md:65
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because "
"a snapshot is an immutable view of a value at a specific point in time, the "
"usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""
"`@arr1` sözdizimi, `arr1`'deki değerin bir anlık görüntüsünü oluşturmamıza olanak tanır. Bir anlık görüntü, belirli bir zamandaki bir değerin değişmez bir görünümü olduğundan, doğrusal tip sisteminin normal kuralları uygulanmaz. Özellikle, anlık görüntü değişkenleri her zaman `Drop` özelliğini uygular, `Destruct` özelliğini asla uygulamaz, hatta sözlük anlık görüntüleri bile."


#: src/ch04-02-references-and-snapshots.md:67
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory annotations:"
msgstr ""
"Benzer şekilde, fonksiyonun imzası `@` kullanılarak parametre `arr`'in tipinin bir anlık görüntü olduğunu belirtir. Açıklayıcı notlar ekleyelim:"


#: src/ch04-02-references-and-snapshots.md:71
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:74
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` "
"contains, the original `arr` can still be used.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:78
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any "
"function parameter’s scope, but the underlying value of the snapshot is not "
"dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"Değişken `array_snapshot`'ın geçerli olduğu kapsam, herhangi bir fonksiyon parametresinin kapsamı ile aynıdır, ancak `array_snapshot` kullanılmayı bıraktığında anlık görüntünün altındaki değer bırakılmaz. Fonksiyonların parametreleri olarak gerçek değerler yerine anlık görüntüler varsa, orijinal değerin sahipliğini geri vermek için değerleri döndürmemize gerek kalmaz, çünkü zaten sahip olmamışızdır."


#: src/ch04-02-references-and-snapshots.md:80
msgid "Desnap Operator"
msgstr "Desnap Operatörü"


#: src/ch04-02-references-and-snapshots.md:82
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap` "
"operator `*`, which serves as the opposite of the `@` operator."
msgstr ""
"Bir anlık görüntüyü normal bir değişkene geri dönüştürmek için, `@` operatörünün tersi olarak hizmet veren `desnap` operatörü `*` kullanılabilir."


#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator "
"reuses the old value, and so desnapping is a completely free operation, just "
"like `Copy`."
msgstr ""
"Yalnızca `Copy` tipleri desnap edilebilir. Ancak, genel olarak, değer değiştirilmediğinden, `desnap` operatörü tarafından oluşturulan yeni değişken eski değeri yeniden kullanır ve bu nedenle desnapping tamamen ücretsiz bir işlemdir, tıpkı `Copy` gibi."


#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"Aşağıdaki örnekte, bir dikdörtgenin alanını hesaplamak istiyoruz, ancak `calculate_area` fonksiyonunda dikdörtgenin sahipliğini almak istemiyoruz, çünkü fonksiyon çağrısından sonra dikdörtgeni tekrar kullanmak isteyebiliriz. Fonksiyonumuz dikdörtgen örneğini değiştirmediğinden, fonksiyona dikdörtgenin anlık görüntüsünü geçirebilir ve sonra anlık görüntüleri `desnap` operatörü `*` kullanarak değerlere geri dönüştürebiliriz."


#: src/ch04-02-references-and-snapshots.md:98
#: src/ch05-02-an-example-program-using-structs.md:84
#: src/ch05-03-method-syntax.md:40
msgid "\"Area: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:102
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the "
"fields types.\n"
"    // We need to transform the snapshots back into values using the desnap "
"operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for "
"u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for "
"desnapping the snapshots.\n"
msgstr ""

#: src/ch04-02-references-and-snapshots.md:110
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot? "
"Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""
"Bir anlık görüntü olarak geçirdiğimiz bir şeyi değiştirmeyi denediğimizde ne olur? Liste 4-4'teki kodu deneyin. Spoiler uyarısı: işe yaramaz!"


#: src/ch04-02-references-and-snapshots.md:134
msgid "Listing 4-4: Attempting to modify a snapshot value"
msgstr "Liste 4-4: Bir anlık görüntü değerini değiştirmeye çalışmak"


#: src/ch04-02-references-and-snapshots.md:136
msgid "Here’s the error:"
msgstr "İşte hata:"


#: src/ch04-02-references-and-snapshots.md:145
msgid "The compiler prevents us from modifying values associated to snapshots."
msgstr "Derleyici, anlık görüntülere bağlı değerlerin değiştirilmesini engeller."


#: src/ch04-02-references-and-snapshots.md:147
msgid "Mutable References"
msgstr "Değiştirilebilir Referanslar"


#: src/ch04-02-references-and-snapshots.md:149
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"Liste 4-4'teki istediğimiz davranışı, bir anlık görüntü yerine _değiştirilebilir bir referans_ kullanarak elde edebiliriz. Değiştirilebilir referanslar, aslında bir fonksiyona geçirilen ve fonksiyonun sonunda implisit olarak geri döndürülen değiştirilebilir değerlerdir, sahipliği çağrı yapan bağlama geri döndürür. Bunu yaparak, değeri geçirirken değiştirmenize izin verirler ve yürütmenin sonunda otomatik olarak geri döndürerek onun sahipliğini korumanızı sağlarlar. Cairo'da, bir parametre _değiştirilebilir referans_ olarak `ref` değiştiricisi kullanılarak geçirilebilir."


#: src/ch04-02-references-and-snapshots.md:152
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"**Not**: Cairo'da, bir parametre yalnızca `ref` değiştiricisi kullanılarak _değiştirilebilir referans_ olarak geçirilebilir, eğer değişken `mut` ile değiştirilebilir olarak tanımlanmışsa."


#: src/ch04-02-references-and-snapshots.md:154
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""
"Liste 4-5'te, `flip` fonksiyonunda `Rectangle` örneğinin `height` ve `width` alanlarının değerini değiştirmek için değiştirilebilir bir referans kullanıyoruz."


#: src/ch04-02-references-and-snapshots.md:166
msgid "\"height: {}, width: {}\""
msgstr ""

#: src/ch04-02-references-and-snapshots.md:176
msgid "Listing 4-5: Use of a mutable reference to modify a value"
msgstr ""
"Liste 4-5: Bir değeri değiştirmek için değiştirilebilir bir referans kullanımı"


#: src/ch04-02-references-and-snapshots.md:178
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"Öncelikle, `rec`'i `mut` olarak değiştiriyoruz. Sonra `rec`'in değiştirilebilir bir referansını `ref rec` ile `flip`'e geçiriyoruz ve fonksiyon imzasını `ref rec: Rectangle` ile değiştirilebilir bir referansı kabul edecek şekilde güncelliyoruz. Bu, `flip` fonksiyonunun parametre olarak geçirilen `Rectangle` örneğinin değerini değiştireceğini çok açık hale getirir."


#: src/ch04-02-references-and-snapshots.md:180
msgid "The output of the program is:"
msgstr "Programın çıktısı:"


#: src/ch04-02-references-and-snapshots.md:187
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been "
"swapped."
msgstr ""
"Beklendiği gibi, `rec` değişkeninin `height` ve `width` alanları yer değiştirdi."


#: src/ch04-02-references-and-snapshots.md:189
msgid "Small recap"
msgstr "Küçük bir özet"


#: src/ch04-02-references-and-snapshots.md:191
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr ""
"Doğrusal tip sistemi, sahiplik, anlık görüntüler ve referanslar hakkında tartıştığımız konuları özetleyelim:"


#: src/ch04-02-references-and-snapshots.md:193
msgid "At any given time, a variable can only have one owner."
msgstr "Herhangi bir zamanda, bir değişkenin yalnızca bir sahibi olabilir."


#: src/ch04-02-references-and-snapshots.md:194
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a function."
msgstr ""
"Bir değişkeni bir fonksiyona değer-olarak, anlık görüntü-olarak veya referans-olarak geçirebilirsiniz."


#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr ""
"Değer-olarak geçirirseniz, değişkenin sahipliği fonksiyona aktarılır."


#: src/ch04-02-references-and-snapshots.md:196
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr ""
"Değişkenin sahipliğini korumak ve fonksiyonunuzun onu değiştirmeyeceğini bilmek istiyorsanız, `@` ile bir anlık görüntü olarak geçirebilirsiniz."


#: src/ch04-02-references-and-snapshots.md:197
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"Değişkenin sahipliğini korumak ve fonksiyonunuzun onu değiştireceğini bilmek istiyorsanız, `ref` ile değiştirilebilir bir referans olarak geçirebilirsiniz."


#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together "
"and name multiple related values that make up a meaningful group. If you’re "
"familiar with an object-oriented language, a struct is like an object’s data "
"attributes. In this chapter, we’ll compare and contrast tuples with structs "
"to build on what you already know and demonstrate when structs are a better "
"way to group data."
msgstr ""
"Bir struct, veya yapı, birden fazla ilgili değeri bir araya getirip adlandırmanıza olanak tanıyan özel bir veri tipidir. Eğer nesne yönelimli bir dil ile tanıdıksanız, bir struct bir nesnenin veri özelliklerine benzer. Bu bölümde, struct'ları tuple'lar ile karşılaştırıp kontrast oluşturarak bildikleriniz üzerine inşa edeceğiz ve struct'ların veriyi gruplamak için ne zaman daha iyi bir yol olduğunu göstereceğiz."


#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the next chapter) are the building blocks for "
"creating new types in your program’s domain to take full advantage of "
"Cairo's compile-time type checking."
msgstr ""
"Struct'ları nasıl tanımlayıp oluşturacağımızı göstereceğiz. Bir struct türü ile ilişkilendirilmiş davranışları belirtmek için, özellikle metodlar olarak adlandırılan türdeki ilişkilendirilmiş fonksiyonları nasıl tanımlayacağımızı tartışacağız. Struct'lar ve enum'lar (bir sonraki bölümde tartışılacak), programınızın alanında yeni tipler oluşturmak için yapı taşlarıdır ve Cairo'nun derleme zamanı tip kontrolünden tam olarak yararlanmak için."


#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"Struct'lar, [Veri Tipleri](ch02-02-data-types.md) bölümünde tartışılan tuple'lar gibi, birden fazla ilgili değeri tutar. Tuple'lar gibi, bir struct'ın parçaları farklı tiplerde olabilir. Tuple'lar ile farklı olarak, bir struct'ta her bir veri parçasını adlandırırsınız, böylece değerlerin ne anlama geldiği açıktır. Bu adları eklemek, struct'ları tuple'lardan daha esnek hale getirir: bir örneğin değerlerini belirtmek veya erişmek için veri sırasına bağımlı olmanıza gerek yoktur."


#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"Bir struct tanımlamak için, `struct` anahtar kelimesini girer ve tüm struct'ı adlandırırız. Bir struct'ın adı, bir araya getirilen veri parçalarının önemini açıklamalıdır. Sonra, süslü parantezler içinde, alanları adlandırırız ve veri parçalarının adlarını ve tiplerini tanımlarız. Örneğin, Liste 5-1 bir kullanıcı hesabı hakkında bilgi depolayan bir struct'ı gösterir."


#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "Listing 5-1: A `User` struct definition"
msgstr "Liste 5-1: Bir `User` struct tanımı"


#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type."
msgstr ""
"Bir struct'ı tanımladıktan sonra kullanmak için, her bir alan için somut değerler belirterek o struct'ın bir _örneğini_ oluştururuz. Bir örneği oluşturmak için, struct'ın adını belirtir ve sonra _anahtar: değer_ çiftleri içeren süslü parantezler ekleriz, burada anahtarlar alanların adlarıdır ve değerler, bu alanlarda saklamak istediğimiz verilerdir. Struct'ta tanımladığımız sırayla aynı sırada alanları belirtmek zorunda değiliz. Diğer bir deyişle, struct tanımı, tip için genel bir şablon gibidir ve örnekler, belirli verilerle o şablonu doldurarak tipin değerlerini oluşturur."


#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid "For example, we can declare a particular user as shown in Listing 5-2."
msgstr "Örneğin, Liste 5-2'de gösterildiği gibi belirli bir kullanıcıyı beyan edebiliriz."


#: src/ch05-01-defining-and-instantiating-structs.md:44
msgid "Listing 5-2: Creating an instance of the `User` struct"
msgstr "Liste 5-2: `User` struct'ının bir örneğini oluşturmak"


#: src/ch05-01-defining-and-instantiating-structs.md:46
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""
"Bir struct'tan belirli bir değeri almak için nokta notasyonunu kullanırız. Örneğin, bu kullanıcının e-posta adresine erişmek için `user1.email` kullanırız. Örnek değiştirilebilir ise, nokta notasyonunu kullanarak belirli bir alandaki bir değeri değiştirebiliriz. Liste 5-3, değiştirilebilir bir `User` örneğindeki `email` alanındaki değeri nasıl değiştireceğinizi gösterir."


#: src/ch05-01-defining-and-instantiating-structs.md:76
msgid "Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr "Liste 5-3: Bir `User` örneğindeki email alanındaki değeri değiştirme"


#: src/ch05-01-defining-and-instantiating-structs.md:78
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr ""
"Tüm örneğin değiştirilebilir olması gerektiğini unutmayın; Cairo, belirli alanların değiştirilebilir olarak işaretlenmesine izin vermez."


#: src/ch05-01-defining-and-instantiating-structs.md:80
msgid ""
"As with any expression, we can construct a new instance of the struct as the "
"last expression in the function body to implicitly return that new instance."
msgstr ""
"Herhangi bir ifade gibi, fonksiyon gövdesinin son ifadesi olarak struct'ın yeni bir örneğini oluşturarak bu yeni örneği dolaylı olarak döndürebiliriz."


#: src/ch05-01-defining-and-instantiating-structs.md:82
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"Liste 5-4, verilen e-posta ve kullanıcı adı ile bir `User` örneği döndüren bir `build_user` fonksiyonunu gösterir. `active` alanı `true` değerini alır ve `sign_in_count` alanı `1` değerini alır."


#: src/ch05-01-defining-and-instantiating-structs.md:112
msgid ""
"Listing 5-4: A `build_user` function that takes an email and username and "
"returns a `User` instance"
msgstr ""
"Liste 5-4: Bir e-posta ve kullanıcı adı alan ve bir `User` örneği döndüren bir `build_user` fonksiyonu"


#: src/ch05-01-defining-and-instantiating-structs.md:114
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"Fonksiyon parametrelerinin adını struct alanları ile aynı adlandırmak mantıklıdır, ancak `email` ve `username` alan adlarını ve değişkenleri tekrar etmek biraz yorucudur. Struct daha fazla alana sahip olsaydı, her adı tekrar etmek daha da can sıkıcı olurdu. Neyse ki, kullanışlı bir kısayol var!"


#: src/ch05-01-defining-and-instantiating-structs.md:116
msgid "Using the Field Init Shorthand"
msgstr "Alan Başlatma Kısayolu Kullanımı"


#: src/ch05-01-defining-and-instantiating-structs.md:118
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"Liste 5-4'te parametre adları ile struct alan adları tam olarak aynı olduğu için, `build_user`'ı tam olarak aynı davranışı göstermek üzere yeniden yazmak için alan başlatma kısayol sözdizimini kullanabiliriz, böylece `username` ve `email` tekrarını ortadan kaldırabiliriz, Liste 5-5'te gösterildiği gibi."


#: src/ch05-01-defining-and-instantiating-structs.md:148
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because "
"the `username` and `email` parameters have the same name as struct fields"
msgstr ""
"Liste 5-5: `username` ve `email` parametrelerinin struct alanları ile aynı adı taşıdığı için alan başlatma kısayolunu kullanan bir `build_user` fonksiyonu"


#: src/ch05-01-defining-and-instantiating-structs.md:150
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"Burada, `email` adında bir alanı olan `User` struct'ının yeni bir örneğini oluşturuyoruz. `email` alanının değerini `build_user` fonksiyonunun `email` parametresindeki değere ayarlamak istiyoruz. `email` alanı ve `email` parametresi aynı adı taşıdığı için, `email: email` yerine yalnızca `email` yazmamız yeterlidir."


#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""
"Struct'ları kullanmak isteyebileceğimiz durumları anlamak için, bir dikdörtgenin alanını hesaplayan bir program yazalım. Tek değişkenler kullanarak başlayacak ve programı struct'ları kullanacak şekilde yeniden düzenleyene kadar devam edeceğiz."


#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Scarb ile _rectangles_ adında yeni bir proje yapalım ki bu, pikseller cinsinden belirtilen bir dikdörtgenin genişliğini ve yüksekliğini alıp dikdörtgenin alanını hesaplasın. Liste 5-6, projemizin _src/lib.cairo_'sında tam olarak bunu yapan kısa bir programı gösterir."


#: src/ch05-02-an-example-program-using-structs.md:15
#: src/ch05-02-an-example-program-using-structs.md:54
msgid "\"Area is {}\""
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:23
msgid ""
"Listing 5-6: Calculating the area of a rectangle specified by separate width "
"and height variables"
msgstr ""
"Liste 5-6: Ayrı genişlik ve yükseklik değişkenleriyle belirtilen bir dikdörtgenin alanını hesaplama"


#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run --available-gas=200000000`:"
msgstr "Şimdi programı `scarb cairo-run --available-gas=200000000` ile çalıştırın:"



#: src/ch05-02-an-example-program-using-structs.md:34
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""
"Bu kod, her boyutu `area` fonksiyonu ile çağırarak dikdörtgenin alanını bulmayı başarır, ancak bu kodu daha net ve okunabilir hale getirmek için daha fazlasını yapabiliriz."



#: src/ch05-02-an-example-program-using-structs.md:36
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "Bu kodun sorunu, `area` fonksiyonunun imzasında açıktır:"


#: src/ch05-02-an-example-program-using-structs.md:42
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in [Chapter 2](ch02-02-data-types.html#the-tuple-type): "
"using tuples."
msgstr ""
"`area` fonksiyonunun bir dikdörtgenin alanını hesaplaması gerekiyor, ancak yazdığımız fonksiyonun iki parametresi var ve programımızda bu parametrelerin ilgili olduğu hiçbir yerde açık değil. Genişliği ve yüksekliği bir arada gruplamanın daha okunabilir ve daha yönetilebilir olacağı açıktır. Bunu nasıl yapabileceğimizi [Bölüm 2](ch02-02-data-types.html#the-tuple-type)'de zaten tartışmıştık: tuple'ları kullanarak."


#: src/ch05-02-an-example-program-using-structs.md:44
msgid "Refactoring with Tuples"
msgstr "Tuple'larla Yeniden Düzenleme"


#: src/ch05-02-an-example-program-using-structs.md:46
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr "Liste 5-7, programımızın tuple'ları kullanan başka bir versiyonunu gösterir."


#: src/ch05-02-an-example-program-using-structs.md:63
msgid ""
"Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr ""
"Liste 5-7: Dikdörtgenin genişliğini ve yüksekliğini bir tuple ile belirtme"


#: src/ch05-02-an-example-program-using-structs.md:65
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"Bir yönden, bu program daha iyi. Tuple'lar biraz yapı eklememize izin verir ve artık sadece bir argüman geçiriyoruz. Ancak başka bir yönden, bu versiyon daha az açık: tuple'lar elemanlarını adlandırmaz, bu yüzden tuple'ın parçalarına indeksle erişmemiz gerekiyor, bu da hesaplamamızı daha az açık hale getiriyor."


#: src/ch05-02-an-example-program-using-structs.md:67
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep "
"in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"Genişliği ve yüksekliği karıştırmak alan hesaplaması için önemli olmaz, ancak farkı hesaplamak isteseydik önemli olurdu! `width`'ın tuple indeksi `0` ve `height`'ın tuple indeksi `1` olduğunu aklımızda tutmamız gerekirdi. Kodumuzu kullanacak başka biri için bu, anlaması ve aklında tutması daha zor olurdu. Verilerimizin anlamını kodumuzda iletemediğimiz için, hataları daha kolaylıkla tanıtmak şimdi daha kolay."


#: src/ch05-02-an-example-program-using-structs.md:69
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "Struct'larla Yeniden Düzenleme: Daha Fazla Anlam Katma"


#: src/ch05-02-an-example-program-using-structs.md:71
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""
"Verilere anlam katmak için struct'ları kullanıyoruz. Kullandığımız tuple'ı hem bütün hem de parçalar için adlarla bir struct'a dönüştürebiliriz."


#: src/ch05-02-an-example-program-using-structs.md:92
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr "Liste 5-8: Bir `Rectangle` struct'ını tanımlama"


#: src/ch05-02-an-example-program-using-structs.md:94
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the "
"tuple index values of `0` and `1`."
msgstr ""
"Burada bir struct tanımladık ve ona `Rectangle` adını verdik. Süslü parantezlerin içinde, `width` ve `height` olarak tanımlanan alanları, her ikisi de `u64` tipinde. Sonra, `main`'de `width`'ı `30` ve `height`'ı `10` olan `Rectangle`'ın belirli bir örneğini oluşturduk. `area` fonksiyonumuz artık bir parametre ile tanımlanıyor, bu parametreyi `rectangle` olarak adlandırdık ve tipi `Rectangle` struct'ı. Sonra örneğin alanlarına nokta notasyonu ile erişebiliriz ve `0` ve `1` tuple indeks değerlerini kullanmak yerine değerlere açıklayıcı adlar verir."


#: src/ch05-02-an-example-program-using-structs.md:96
msgid "Adding Useful Functionality with Trait"
msgstr "Yararlı Fonksiyonellik Eklemek İçin Trait Kullanma"


#: src/ch05-02-an-example-program-using-structs.md:98
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-9 "
"tries using the `print` as we have used in previous chapters. This won’t "
"work."
msgstr ""
"`Rectangle` örneğini programımızı hata ayıklarken yazdırabilmek ve tüm alanlarının değerlerini görebilmek yararlı olurdu. Liste 5-9, önceki bölümlerde kullandığımız gibi `print` kullanmayı dener. Bu işe yaramaz."


#: src/ch05-02-an-example-program-using-structs.md:118
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr "Liste 5-9: Bir `Rectangle` örneğini yazdırmaya çalışma"


#: src/ch05-02-an-example-program-using-structs.md:120
msgid "When we compile this code, we get an error with this message:"
msgstr "Bu kodu derlediğimizde, bu mesajla bir hata alırız:"


#: src/ch05-02-an-example-program-using-structs.md:122
msgid ""
"```text\n"
"$ cairo-compile src/lib.cairo\n"
"error: Method `print` not found on type \"../src::Rectangle\". Did you "
"import the correct trait and impl?\n"
" --> lib.cairo:16:15\n"
"    rectangle.print();\n"
"              ^***^\n"
"\n"
"Error: Compilation failed.\n"
"```"
msgstr ""

#: src/ch05-02-an-example-program-using-structs.md:132
msgid ""
"The `print` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""
"`print` trait birçok veri tipi için uygulanmıştır, ancak `Rectangle` struct'ı için değil. `Rectangle` üzerinde `PrintTrait` trait'ini uygulayarak bunu düzeltebiliriz, Liste 5-10'da gösterildiği gibi. Trait'ler hakkında daha fazla bilgi için, [Cairo'da Trait'ler](ch08-02-traits-in-cairo.md)'e bakın."


#: src/ch05-02-an-example-program-using-structs.md:160
msgid "Listing 5-10: Implementing the `PrintTrait` trait on `Rectangle`"
msgstr "Liste 5-10: `Rectangle` üzerine `PrintTrait` trait'ini uygulama"


#: src/ch05-02-an-example-program-using-structs.md:162
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr ""
"Güzel! En güzel çıktı değil, ama bu örneğin tüm alanlarının değerlerini gösteriyor, bu kesinlikle hata ayıklama sırasında yardımcı olurdu."


#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on. For those familiar with Rust, Cairo's approach "
"might be confusing, as methods cannot be defined directly on types. Instead, "
"you must define a [trait](./ch08-02-traits-in-cairo.md) and an "
"implementation associated with the type for which the method is intended."
msgstr ""
"_Metodlar_ fonksiyonlara benzerdir: `fn` anahtar kelimesi ve bir ad ile tanımlanırlar, parametreleri ve bir dönüş değeri olabilir ve metod başka bir yerden çağrıldığında çalışacak bazı kodlar içerirler. Fonksiyonlardan farklı olarak, metodlar bir tipin bağlamı içinde tanımlanır ve ilk parametreleri her zaman `self`tir, bu da metodun çağrıldığı tipin örneğini temsil eder. Rust ile tanıdık olanlar için, Cairo'nun yaklaşımı kafa karıştırıcı olabilir, çünkü metodlar doğrudan tipler üzerinde doğrudan tanımlanamaz. Bunun yerine, metodun niyet edildiği tip için bir [trait](./ch08-02-traits-in-cairo.md) ve bir uygulama tanımlamalısınız."


#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr "Metod Tanımlama"


#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `RectangleTrait` "
"trait, as shown in Listing 5-13."
msgstr ""
"`Rectangle` örneğini parametre olarak alan `area` fonksiyonunu değiştirelim ve bunun yerine `RectangleTrait` trait'i üzerinde tanımlanmış bir `area` metodunu yapalım, Liste 5-13'te gösterildiği gibi."


#: src/ch05-03-method-syntax.md:44
msgid "Listing 5-11: Defining an `area` method to use on the `Rectangle` "
msgstr "Liste 5-11: `Rectangle` üzerinde kullanılacak bir `area` metodunun tanımlanması"


#: src/ch05-03-method-syntax.md:47
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait` block with the signature of the method that we want to "
"implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we "
"define an `impl` (implementation) block for `RectangleTrait`, that defines "
"the behavior of the methods implemented. Everything within this `impl` block "
"will be associated with the type of the `self` parameter of the method "
"called. While it is technically possible to define methods for multiple "
"types within the same `impl` block, it is not a recommended practice, as it "
"can lead to confusion. We recommend that the type of the `self` parameter "
"stays consistent within the same `impl` block. Then we move the `area` "
"function within the `impl` curly brackets and change the first (and in this "
"case, only) parameter to be `self` in the signature and everywhere within "
"the body. In `main`, where we called the `area` function and passed `rect1` "
"as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an "
"instance: we add a dot followed by the method name, parentheses, and any "
"arguments."
msgstr ""
"`Rectangle` bağlamı içinde fonksiyonu tanımlamak için, uygulamak istediğimiz metodun imzası ile bir `trait` bloğu tanımlayarak başlarız. Trait'ler belirli bir tipe bağlı değildir; yalnızca metodun `self` parametresi, hangi tip ile kullanılabileceğini tanımlar. Sonra, metodların davranışını tanımlayan `RectangleTrait` için bir `impl` (uygulama) bloğu tanımlarız. Bu `impl` bloğu içindeki her şey, metodun çağrıldığı `self` parametresinin tipi ile ilişkilendirilecektir. Teknik olarak aynı `impl` bloğu içinde birden fazla tip için metod tanımlamak mümkündür, ancak bu, kafa karışıklığına yol açabileceği için önerilmez. `self` parametresinin tipinin aynı `impl` bloğu içinde tutarlı kalması önerilir. Sonra `area` fonksiyonunu `impl` süslü parantezleri içine taşırız ve imzadaki ilk (ve bu durumda tek) parametreyi ve gövde içindeki her yerde `self` olarak değiştiririz. `main`'de, `area` fonksiyonunu çağırdığımız ve argüman olarak `rect1`'i geçtiğimiz yerde, _metod sözdizimini_ kullanarak `Rectangle` örneğimizde `area` metodunu çağırabiliriz. Metod sözdizimi bir örneğin ardından gelir: bir nokta, metod adı, parantezler ve herhangi bir argüman ekleriz."


#: src/ch05-03-method-syntax.md:65
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter. Note that we used the `@` snapshot operator in "
"front of the `Rectangle` type in the function signature. By doing so, we "
"indicate that this method takes an immutable snapshot of the `Rectangle` "
"instance, which is automatically created by the compiler when passing the "
"instance to the method. Methods can take ownership of `self`, use `self` "
"with snapshots as we’ve done here, or use a mutable reference to `self` "
"using the `ref self: T` syntax."
msgstr ""
"Metodlar, uygulandıkları tip için ilk parametre olarak `self` adında bir parametreye sahip olmalıdır. İmzada `Rectangle` tipinin önünde `@` anlık görüntü operatörünü kullandığımızı unutmayın. Bunu yaparak, bu metodun `Rectangle` örneğinin değişmez bir anlık görüntüsünü aldığını belirtiyoruz, bu anlık görüntü metod örneğe geçirildiğinde derleyici tarafından otomatik olarak oluşturulur. Metodlar `self`'i sahiplenme, burada yaptığımız gibi `self` ile anlık görüntüler kullanma veya `ref self: T` sözdizimi kullanarak `self`'in değiştirilebilir referansını kullanma şeklinde kullanılabilir."


#: src/ch05-03-method-syntax.md:73
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in "
"the function version: we don’t want to take ownership, and we just want to "
"read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, "
"we’d use `ref self: Rectangle` as the first parameter. Having a method that "
"takes ownership of the instance by using just `self` as the first parameter "
"is rare; this technique is usually used when the method transforms `self` "
"into something else and you want to prevent the caller from using the "
"original instance after the transformation."
msgstr ""
"`self: @Rectangle`'ı burada fonksiyon versiyonunda `@Rectangle` kullandığımız aynı nedenle seçtik: sahipliği almak istemiyoruz ve sadece struct içindeki verileri okumak istiyoruz, yazmak değil. Eğer metodun yaptığı işin bir parçası olarak üzerinde çağrıldığı örneği değiştirmek isteseydik, ilk parametre olarak `ref self: Rectangle` kullanırdık. Bir metodun ilk parametre olarak yalnızca `self` kullanarak örneğin sahipliğini alması nadirdir; bu teknik genellikle metod `self`'i başka bir şeye dönüştürdüğünde ve çağrıyı yapanın dönüşümden sonra orijinal örneği kullanmasını önlemek istediğinizde kullanılır."


#: src/ch05-03-method-syntax.md:82
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members. This is necessary because the struct is "
"passed as a snapshot, and all of its field values are of type `@T`, "
"requiring them to be desnapped in order to manipulate them."
msgstr ""
"Alan metodunda struct üyelerine erişirken desnap operatörü `*`'ın kullanımını gözlemleyin. Bu, struct'ın bir anlık görüntü olarak geçirilmesi ve tüm alan değerlerinin `@T` tipinde olması gerektiği için, onları manipüle edebilmek için desnapped olmaları gerektiğinden gereklidir."


#: src/ch05-03-method-syntax.md:87
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide. However, we can define multiple "
"combinations of `trait` & `impl` blocks for the same type at different "
"places, which can be useful for a more granular code organization. For "
"example, you could implement the `Add` trait for your type in one `impl` "
"block, and the `Sub` trait in another block."
msgstr ""
"Metodlar yerine fonksiyonları kullanmanın ana nedeni organizasyon ve kod açıklığıdır. Bir tipin örneği ile yapabileceğimiz her şeyi bir `trait` & `impl` bloklar kombinasyonunda koyduk, kodumuzun gelecekteki kullanıcılarını `Rectangle`'ın yeteneklerini sağladığımız kütüphanenin çeşitli yerlerinde aramak zorunda bırakmadık. Ancak, aynı tip için farklı yerlerde birden fazla `trait` & `impl` blokları kombinasyonunu tanımlayabiliriz, bu da daha ince taneli bir kod organizasyonu için yararlı olabilir. Örneğin, `Add` trait'ini tipiniz için bir `impl` bloğunda ve `Sub` trait'ini başka bir blokta uygulayabilirsiniz."


#: src/ch05-03-method-syntax.md:96
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr ""
"Bir metodun adını struct'ın alanlarından biriyle aynı adı vermek serbesttir. Örneğin, `Rectangle` üzerinde de `width` adında bir metod tanımlayabiliriz:"


#: src/ch05-03-method-syntax.md:121
msgid "\"Width: {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:125
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0` and `false` if the value "
"is `0`: we can use a field within a method of the same name for any purpose. "
"In `main`, when we follow `rect1.width` with parentheses, Cairo knows we "
"mean the method `width`. When we don’t use parentheses, Cairo knows we mean "
"the field `width`."
msgstr ""
"Burada, `width` metodunun, örneğin `width` alanındaki değer `0`'dan büyükse `true`, değer `0` ise `false` dönmesini tercih ediyoruz: aynı adı taşıyan bir alana sahip bir metodun, herhangi bir amaç için kullanılabilir. `main`'de, `rect1.width`'i parantezlerle takip ettiğimizde, Cairo metod `width`'i kastettiğimizi anlar. Parantez kullanmadığımızda, Cairo alan `width`'i kastettiğimizi anlar."


#: src/ch05-03-method-syntax.md:132
msgid "Methods with More Parameters"
msgstr "Daha Fazla Parametre ile Metodlar"


#: src/ch05-03-method-syntax.md:134
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we "
"want to be able to write the program shown in Listing 5-14."
msgstr ""
"Metodları kullanmayı pratik yapalım ve `Rectangle` struct'ı üzerine ikinci bir metod uygulayalım. Bu sefer, `Rectangle` örneğinin başka bir `Rectangle` örneğini almasını ve ikinci `Rectangle` kendisine (`self` yani ilk `Rectangle`) tamamen sığabiliyorsa `true`, aksi takdirde `false` döndürmesini istiyoruz. Yani, `can_hold` metodunu tanımladıktan sonra, Liste 5-14'te gösterilen programı yazmak istiyoruz."


#: src/ch05-03-method-syntax.md:156
msgid "\"Can rect1 hold rect2? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:157
msgid "\"Can rect1 hold rect3? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:161
msgid "Listing 5-12: Using the as-yet-unwritten `can_hold` method"
msgstr "Liste 5-12: Henüz yazılmamış `can_hold` metodunu kullanma"


#: src/ch05-03-method-syntax.md:164
msgid ""
"The expected output would look like the following because both dimensions of "
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr ""
"Beklenen çıktı aşağıdaki gibi olurdu çünkü `rect2`'nin her iki boyutu da `rect1`'in boyutlarından küçüktür, ancak `rect3` `rect1`'den daha geniştir:"


#: src/ch05-03-method-syntax.md:180
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The "
"method name will be `can_hold`, and it will take a snapshot of another "
"`Rectangle` as a parameter. We can tell what the type of the parameter will "
"be by looking at the code that calls the method: `rect1.can_hold(@rect2)` "
"passes in `@rect2`, which is a snapshot to `rect2`, an instance of "
"`Rectangle`. This makes sense because we only need to read `rect2` (rather "
"than write, which would mean we’d need a mutable borrow), and we want `main` "
"to retain ownership of `rect2` so we can use it again after calling the "
"`can_hold` method. The return value of `can_hold` will be a Boolean, and the "
"implementation will check whether the width and height of `self` are greater "
"than the width and height of the other `Rectangle`, respectively. Let’s add "
"the new `can_hold` method to the `trait` and `impl` blocks from Listing "
"5-11, shown in Listing 5-13."
msgstr ""
"Bir metod tanımlamak istediğimizi biliyoruz, bu yüzden `trait RectangleTrait` ve `impl RectangleImpl of RectangleTrait` blokları içinde olacak. Metod adı `can_hold` olacak ve bir başka `Rectangle`'ın anlık görüntüsünü parametre olarak alacak. `rect1.can_hold(@rect2)` metodunu çağıran kodu inceleyerek parametrenin tipini belirleyebiliriz: `@rect2`, `Rectangle` örneği olan `rect2`'ye bir anlık görüntüdür. Bu mantıklı çünkü `rect2`'yi yalnızca okumamız gerekiyor (yazmak demek mutable borrow gerektirecekti) ve `can_hold` metodunu çağırdıktan sonra `main`'de `rect2`'yi tekrar kullanmak istiyoruz. `can_hold`'un dönüş değeri bir Boolean olacak ve uygulama, `self`'in genişliğinin ve yüksekliğinin diğer `Rectangle`'ın genişliğinden ve yüksekliğinden sırasıyla daha büyük olup olmadığını kontrol edecek. Yeni `can_hold` metodunu Liste 5-11'den `trait` ve `impl` bloklarına ekleyelim, Liste 5-13'te gösterildiği gibi."


#: src/ch05-03-method-syntax.md:213
msgid ""
"Listing 5-13: Implementing the `can_hold` method on `Rectangle` that takes "
"another `Rectangle` instance as a parameter"
msgstr ""
"Liste 5-13: Bir başka `Rectangle` örneğini parametre olarak alan `Rectangle` üzerinde `can_hold` metodunu uygulama"


#: src/ch05-03-method-syntax.md:216
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""
"Bu kodu Liste 5-14'teki `main` fonksiyonu ile çalıştırdığımızda, istediğimiz çıktıyı alırız. Metodlar, `self` parametresinden sonra imzaya eklediğimiz birden fazla parametre alabilir ve bu parametreler fonksiyonlardaki parametreler gibi çalışır."


#: src/ch05-03-method-syntax.md:221
msgid "Accessing implementation functions"
msgstr "Uygulama fonksiyonlarına erişim"


#: src/ch05-03-method-syntax.md:223
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed using the `::` operator on the implementation name. Functions in "
"traits that aren’t methods are often used for constructors that will return "
"a new instance of the struct. These are often called `new`, but `new` isn’t "
"a special name and isn’t built into the language. For example, we could "
"choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it "
"easier to create a square `Rectangle` rather than having to specify the same "
"value twice:"
msgstr ""
"`trait` ve `impl` bloğu içinde tanımlanan tüm fonksiyonlar, uygulama adı ile `::` operatörü kullanılarak doğrudan adreslenebilir. Metod olmayan trait fonksiyonları, genellikle struct'ın yeni bir örneğini döndürecek yapılandırıcılar için kullanılır. Bunlar genellikle `new` olarak adlandırılır, ancak `new` özel bir ad değildir ve dile yerleşik değildir. Örneğin, bir boyut parametresi alacak ve bunu hem genişlik hem de yükseklik olarak kullanacak, böylece aynı değeri iki kez belirtmek zorunda kalmadan kolayca bir kare `Rectangle` oluşturmayı kolaylaştıracak `square` adında bir ilişkili fonksiyon sağlamayı seçebiliriz:"


#: src/ch05-03-method-syntax.md:246
msgid ""
"To call this function, we use the `::` syntax with the implementation name; "
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by the implementation; the `::` syntax is used for both trait "
"functions and namespaces created by modules. We’ll discuss modules in "
"\\[Chapter 8\\]\\[modules\\]"
msgstr ""
"Bu fonksiyonu çağırmak için, uygulama adı ile `::` sözdizimini kullanırız; `let square = RectangleImpl::square(10);` bir örnektir. Bu fonksiyon uygulama tarafından ad alanına alınmıştır; `::` sözdizimi hem trait fonksiyonları hem de modüller tarafından oluşturulan ad alanları için kullanılır. Modüller hakkında [Bölüm 8](ch08-00-generic-types-and-traits.md)'de tartışacağız."


#: src/ch05-03-method-syntax.md:250 src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr ""

#: src/ch05-03-method-syntax.md:252
msgid ""
"Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""
"Not: Bu fonksiyonu, trait adı ile de çağırabiliriz, `RectangleTrait::square(10)` kullanarak."


#: src/ch05-03-method-syntax.md:255
msgid "Multiple `impl` Blocks"
msgstr "Çoklu `impl` Blokları"


#: src/ch05-03-method-syntax.md:257
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing 5-13 is equivalent to the code shown in Listing 5-14, which "
"has each method in its own `trait` and `impl` blocks."
msgstr ""
"Her struct, birden fazla `trait` ve `impl` bloğuna sahip olabilir. Örneğin, Liste 5-13, her metodun kendi `trait` ve `impl` bloklarında olduğu Liste 5-14'teki kod ile eşdeğerdir."


#: src/ch05-03-method-syntax.md:282
msgid "Listing 5-14: Rewriting Listing 5-13 using multiple `impl` blocks"
msgstr "Liste 5-14: Liste 5-13'ü çoklu `impl` blokları kullanarak yeniden yazma"


#: src/ch05-03-method-syntax.md:285
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl` "
"blocks here, but this is valid syntax. We’ll see a case in which multiple "
"blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where "
"we discuss generic types and traits."
msgstr ""
"Burada, bu metodları birden fazla `trait` ve `impl` bloğuna ayırmanın bir nedeni yok, ancak bu geçerli bir sözdizimidir. Birden fazla bloğun [Bölüm 8](ch08-00-generic-types-and-traits.md)'de, jenerik tipler ve trait'ler hakkında tartıştığımızda yararlı olduğu bir durumu göreceğiz."


#: src/ch05-03-method-syntax.md:292
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `trait` and `impl` "
"blocks, you can define methods, which are functions associated to a type and "
"let you specify the behavior that instances of your type have."
msgstr ""
"Struct'lar, alanınız için anlamlı olan özel tipler oluşturmanıza izin verir. Struct'ları kullanarak, ilişkili veri parçalarını birbirine bağlı tutabilir ve her bir parçayı adlandırarak kodunuzu açık hale getirebilirsiniz. `trait` ve `impl` bloklarında, bir tip ile ilişkilendirilmiş fonksiyonlar olan metodları tanımlayabilirsiniz ve tipinizin örneklerinin sahip olduğu davranışı belirtebilirsiniz."


#: src/ch05-03-method-syntax.md:298
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""
"Ancak struct'lar özel tipler oluşturmanın tek yolu değil: Cairo’nun enum özelliğine dönerek araç kutunuza başka bir araç ekleyelim."


#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"Bu bölümde, _enumerasyonlara_ veya kısaca _enumlara_ bakacağız. Enumlar, olası _varyantlarını_ sıralayarak bir tipi tanımlamanıza izin verir. Öncelikle, bir enum tanımlayıp kullanarak bir enumun veri ile birlikte nasıl anlam kodlayabileceğini göstereceğiz. Daha sonra, bir değerin bir şey veya hiçbir şey olabileceğini ifade eden, özellikle yararlı olan `Option` adlı bir enumu inceleyeceğiz. Son olarak, bir enumun farklı değerleri için farklı kodları çalıştırmayı kolaylaştıran `match` ifadesindeki desen eşleştirmeye bakacağız."


#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"Enumlar, \"enumerasyonlar\" için kısa, sabit bir adlandırılmış değer kümesinden oluşan özel bir veri tipi tanımlamanın bir yoludur. Enumlar, her biri belirgin ve belirli bir anlama sahip olan ilişkili değerlerin bir koleksiyonunu temsil etmek için yararlıdır."


#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "Enum Varyantları ve Değerleri"


#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "İşte basit bir enum örneği:"


#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""
"Bu örnekte, `Direction` adında dört varyantı olan bir enum tanımladık: `North`, `East`, `South` ve `West`. Enum varyantları için isimlendirme kuralı PascalCase kullanmaktır. Her bir varyant, Direction tipinin belirgin bir değerini temsil eder. Bu özel örnekte, varyantlarla ilişkilendirilmiş herhangi bir değer yoktur. Bir varyantı bu sözdizimi kullanarak örnekleyebiliriz:"


#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an "
"enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""
"Bir enum örneğinin varyantına bağlı olarak farklı şekilde hareket eden kod yazmak kolaydır, bu örnekte bir Yön'e göre belirli kodu çalıştırmak için. [Eşleştirme Kontrol Akışı Yapısı sayfasında](ch06-02-the-match-control-flow-construct.md) daha fazla bilgi edinebilirsiniz."


#: src/ch06-01-enums.md:39
msgid "Enums Combined with Custom Types"
msgstr "Enumlar Özel Tiplerle Birleştirilmiş"


#: src/ch06-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr ""
"Enumlar, her bir varyantla ilişkilendirilmiş daha ilginç verileri de depolamak için kullanılabilir. Örneğin:"


#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""
"Bu örnekte, `Message` enumu üç varyanta sahiptir: `Quit`, `Echo` ve `Move`, hepsi farklı tiplerdedir:"


#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr "`Quit` herhangi bir ilişkilendirilmiş değere sahip değildir."


#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr "`Echo` tek bir felt'tir."


#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr "`Move` iki u128 değerinden oluşan bir demettir."


#: src/ch06-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr ""
"Enum varyantlarınızın birinde tanımladığınız bir Struct veya başka bir Enum kullanabilirsiniz."


#: src/ch06-01-enums.md:60
msgid "Trait Implementations for Enums"
msgstr "Enumlar için Trait Uygulamaları"


#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"Cairo'da, özel enumlarınız için trait'leri tanımlayabilir ve bunları uygulayabilirsiniz. Bu, enumunuzla ilişkilendirilmiş metodları ve davranışları tanımlamanıza olanak tanır. İşte önceki `Message` enumu için bir trait tanımlayıp bunu uygulama örneği:"


#: src/ch06-01-enums.md:72 src/ch06-01-enums.md:98
msgid "\"quitting\""
msgstr ""

#: src/ch06-01-enums.md:73 src/ch06-01-enums.md:99
msgid "\"echoing {}\""
msgstr ""

#: src/ch06-01-enums.md:74 src/ch06-01-enums.md:100
msgid "\"moving\""
msgstr ""

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""
"Bu örnekte, `Message` için `Processing` trait'ini uyguladık. İşte bir Quit mesajının nasıl işlenebileceği:"


#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr "Bu kodu çalıştırdığınızda `quitting` yazdırılır."


#: src/ch06-01-enums.md:114
msgid "The Option Enum and Its Advantages"
msgstr "Option Enumu ve Avantajları"


#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"Option enumu, bir değerin isteğe bağlı olduğu kavramını temsil eden standart bir Cairo enumudur. İki varyanta sahiptir: `Some: T` ve `None: ()`. `Some: T` bir `T` tipinde değer olduğunu belirtirken, `None` bir değerin yokluğunu temsil eder."


#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused "
"by using uninitialized or unexpected `null` values."
msgstr ""
"`Option` enumu yararlıdır çünkü bir değerin yokluğunun açıkça temsil edilmesine izin verir, kodunuzu daha ifade edilebilir ve hakkında düşünmesi daha kolay hale getirir. `Option` kullanmak, başlatılmamış veya beklenmedik `null` değerleri nedeniyle oluşan hataları önlemeye de yardımcı olabilir."


#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""
"Size bir örnek vermek için, verilen bir değere sahip bir dizinin ilk elemanının indeksini döndüren veya eleman mevcut değilse None döndüren bir fonksiyon işte burada."


#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr "Yukarıdaki fonksiyon için iki yaklaşımı gösteriyoruz:"


#: src/ch06-01-enums.md:131
msgid "Recursive Approach `find_value_recursive`"
msgstr "Recursive Yaklaşım `find_value_recursive`"


#: src/ch06-01-enums.md:132
msgid "Iterative Approach `find_value_iterative`"
msgstr "Iterative Yaklaşım `find_value_iterative`"


#: src/ch06-01-enums.md:134
msgid ""
"Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr ""
"Not: Gelecekte bu örneği, bir döngü kullanarak ve gazla ilgili kod olmadan daha basit bir şeyle değiştirmek güzel olurdu."


#: src/ch06-01-enums.md:183
msgid "\"found recursively at index {}\""
msgstr ""

#: src/ch06-01-enums.md:186 src/ch06-01-enums.md:194
msgid "\"not found\""
msgstr ""

#: src/ch06-01-enums.md:191
msgid "\"found iteratively at index {}\""
msgstr ""

#: src/ch06-01-enums.md:201
msgid "Running this code would print `it worked`."
msgstr "Bu kodu çalıştırmak `it worked` yazdırır."


#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of match "
"comes from the expressiveness of the patterns and the fact that the compiler "
"confirms that all possible cases are handled."
msgstr ""
"Cairo, `match` adında son derece güçlü bir kontrol akışı yapılandırmasına sahiptir ki bu, bir değeri bir dizi desenle karşılaştırmanıza ve hangi desenin uyuştuğuna bağlı olarak kod çalıştırmanıza olanak tanır. Desenler, literal değerler, değişken isimleri, joker karakterler ve daha birçok şeyden oluşabilir. Match'in gücü, desenlerin ifade gücünden ve derleyicinin tüm olası durumların ele alındığını doğrulaması gerçeğinden gelir."


#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a match expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"Bir match ifadesini, çeşitli büyüklükteki deliklerle birlikte bir yol üzerinde kayan bozuk paraların sıralandığı bir bozuk para sıralama makinesi gibi düşünebilirsiniz: her bozuk para, içine sığdığı ilk delikten düşer. Aynı şekilde, değerler bir match'teki her desenden geçer ve değerin “uyduğu” ilk desende, değer yürütme sırasında kullanılacak ilişkili kod bloğuna düşer."


#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using match! We can write a "
"function that takes an unknown US coin and, in a similar way as the counting "
"machine, determines which coin it is and returns its value in cents, as "
"shown in Listing 6-3."
msgstr ""
"Bozuk paralardan bahsetmişken, onları match kullanarak bir örnek olarak kullanalım! Belirli bir ABD bozuk parasını alan ve sayma makinesine benzer şekilde, hangi bozuk para olduğunu belirleyip sent cinsinden değerini döndüren bir fonksiyon yazabiliriz, Liste 6-3'te gösterildiği gibi."


#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"Listing 6-3: An enum and a match expression that has the variants of the "
"enum as its patterns"
msgstr ""
"Liste 6-3: Enumun varyantlarını desenleri olarak kullanan bir enum ve bir match ifadesi"


#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list "
"the `match` keyword followed by an expression, which in this case is the "
"value `coin`. This seems very similar to a conditional expression used with "
"if, but there’s a big difference: with if, the condition needs to evaluate "
"to a Boolean value, but here it can be any type. The type of coin in this "
"example is the `Coin` enum that we defined on the first line."
msgstr ""
"`value_in_cents` fonksiyonundaki `match`'i detaylandıralım. İlk olarak `match` anahtar kelimesini bir ifade ile listeleriz, bu durumda değer `coin`. Bu, if ile kullanılan bir koşullu ifadeye çok benzer görünüyor, ancak büyük bir fark var: if ile, koşulun bir Boolean değerine değerlendirilmesi gerekirken, burada herhangi bir tür olabilir. Bu örnekte coin tipi, ilk satırda tanımladığımız `Coin` enumudur."


#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny(_)` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""
"Sonra `match` kolları gelir. Bir kolun iki bölümü vardır: bir desen ve biraz kod. İlk kolun burada `Coin::Penny(_)` değerinde bir deseni ve ardından deseni ve çalıştırılacak kodu ayıran `=>` operatörü vardır. Bu durumda kod sadece `1` değeridir. Her kol bir virgülle bir sonrakinden ayrılır."


#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in order. If a pattern matches the value, "
"the code associated with that pattern is executed. If that pattern doesn’t "
"match the value, execution continues to the next arm, much as in a coin-"
"sorting machine. We can have as many arms as we need: in the above example, "
"our match has four arms."
msgstr ""
"`match` ifadesi yürütüldüğünde, sonuç değeri her kolun deseniyle sırayla karşılaştırır. Bir desen değerle eşleşirse, o desenle ilişkili kod çalıştırılır. O desen değerle eşleşmezse, yürütme bir sonraki kola devam eder, tıpkı bir bozuk para sıralama makinesinde olduğu gibi. İhtiyacımız kadar çok kola sahip olabiliriz: yukarıdaki örnekte, bizim match'imiz dört kola sahiptir."


#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr ""
"Her kol ile ilişkili kod bir ifadedir ve eşleşen kolun ifadesinin sonuç değeri, tüm match ifadesi için döndürülen değerdir."


#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it "
"is in our example where each arm just returns a value. If you want to run "
"multiple lines of code in a match arm, you must use curly brackets, with a "
"comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"Genellikle, match kolunun kodu kısa olduğunda, örneğimizdeki gibi her kol sadece bir değer döndürdüğünde süslü parantezleri kullanmayız. Bir match kolunda birden fazla satır kod çalıştırmak istiyorsanız, bir virgül ile birlikte süslü parantezleri kullanmanız gerekir. Örneğin, aşağıdaki kod, her seferinde `Coin::Penny` ile çağrıldığında “Lucky penny!” yazdırır, ancak bloğun son değeri olan `1`'i döndürür:"


#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr "Değerlere Bağlanan Desenler"


#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""
"Match kollarının başka bir yararlı özelliği, değerlerin desene uyan kısımlarına bağlanabilmesidir. Enum varyantlarından değerleri nasıl çıkarabileceğimiz budur."


#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-4."
msgstr ""
"Bir örnek olarak, enum varyantlarımızdan birine içinde veri tutacak şekilde değiştirelim. 1999'dan 2008'e kadar, Amerika Birleşik Devletleri her biri 50 eyaletin bir yüzünde farklı tasarımlarla çeyrek dolar basmıştır. Diğer bozuk paraların eyalet tasarımları olmadığından, yalnızca çeyrek dolarlar bu ek değere sahiptir. `enum`umuza bu bilgiyi ekleyebiliriz, `Quarter` varyantını içinde `UsState` değeri tutacak şekilde değiştirdiğimizde, bunu Liste 6-4'te yaptık."


#: src/ch06-02-the-match-control-flow-construct.md:75
msgid ""
"Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr ""
"Liste 6-4: `Quarter` varyantının içinde bir `UsState` değeri tutan bir `Coin` enumu"


#: src/ch06-02-the-match-control-flow-construct.md:77
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"Hayal edelim ki bir arkadaşımız tüm 50 eyalet çeyreğini toplamaya çalışıyor. Bozuk paralarımızı madeni para türüne göre sıralarken, her çeyreğin ilişkili olduğu eyaletin adını da söyleyelim ki, arkadaşımızın koleksiyonunda olmayan bir eyaletse, onu koleksiyonlarına ekleyebilsinler."


#: src/ch06-02-the-match-control-flow-construct.md:79
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"Bu kod için match ifadesinde, `Coin::Quarter` varyantına uyan değerlerle desen eşleşen `state` adında bir değişken ekliyoruz. `Coin::Quarter` eşleştiğinde, `state` değişkeni o çeyreğin eyalet değerine bağlanacak. Sonra bu koldaki kodda `state`'i kullanabiliriz, şöyle:"


#: src/ch06-02-the-match-control-flow-construct.md:95
msgid ""
"To print the value of a variant of an enum in Cairo, we need to add an "
"implementation for the `print` function for the `debug::PrintTrait`:"
msgstr ""
"Cairo'da, bir enumun varyantının değerini yazdırmak için, `debug::PrintTrait` için `print` fonksiyonunun bir uygulamasını eklememiz gerekiyor:"


#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach `Coin::"
"Quarter(state)`. At that point, the binding for state will be the value "
"`UsState::Alaska`. We can then use that binding in the `PrintTrait`, thus "
"getting the inner state value out of the `Coin` enum variant for `Quarter`."
msgstr ""
"`value_in_cents(Coin::Quarter(UsState::Alaska))` çağırdığımızda, `coin` `Coin::Quarter(UsState::Alaska)` olacak. Her bir match kolunu değerle karşılaştırdığımızda, `Coin::Quarter(state)`'e ulaşıncaya kadar hiçbiri eşleşmez. O noktada, state'in bağlaması `UsState::Alaska` değeri olacak. Sonra bu bağlamayı `PrintTrait` içinde kullanabiliriz, böylece `Quarter` için `Coin` enum varyantından iç eyalet değerini çıkarabiliriz."


#: src/ch06-02-the-match-control-flow-construct.md:110
msgid "Matching with `Option<T>`"
msgstr "`Option<T>` ile Eşleşme"


#: src/ch06-02-the-match-control-flow-construct.md:112
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""
"Önceki bölümde, `Option<T>` kullanırken `Some` durumundaki iç `T` değerini çıkarmak istedik; `Coin` enumu ile yaptığımız gibi `Option<T>`'yi `match` kullanarak da ele alabiliriz! Madeni paraları karşılaştırmak yerine `Option<T>`'nin varyantlarını karşılaştıracağız, ancak `match` ifadesinin çalışma şekli aynı kalır."


#: src/ch06-02-the-match-control-flow-construct.md:114
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""
"Diyelim ki `Option<u8>` alan ve içinde bir değer varsa bu değere `1` ekleyen bir fonksiyon yazmak istiyoruz. İçinde bir değer yoksa, fonksiyonun `None` değerini döndürmesi ve herhangi bir işlem yapmaması gerekiyor."


#: src/ch06-02-the-match-control-flow-construct.md:116
msgid ""
"This function is very easy to write, thanks to match, and will look like "
"Listing 6-5."
msgstr ""
"Bu fonksiyon, match sayesinde çok kolay yazılır ve Liste 6-5 gibi görünür."


#: src/ch06-02-the-match-control-flow-construct.md:131
msgid "\"six: {}\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:133
msgid "\"none: {}\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:137
msgid "Listing 6-5: A function that uses a match expression on an `Option<u8>`"
msgstr "Liste 6-5: Bir `Option<u8>` üzerinde bir match ifadesi kullanan bir fonksiyon"


#: src/ch06-02-the-match-control-flow-construct.md:140
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""
"`plus_one`'ın ilk yürütülmesini daha detaylı inceleyelim. `plus_one(five)` çağırdığımızda, `plus_one`'ın gövdesindeki `x` değişkeni `Some(5)` değerine sahip olacak. Sonra bunu her match koluna karşı karşılaştırırız:"


#: src/ch06-02-the-match-control-flow-construct.md:146
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! "
"We have the same variant. The `val` binds to the value contained in `Option::"
"Some`, so `val` takes the value `5`. The code in the match arm is then "
"executed, so we add `1` to the value of `val` and create a new `Option::"
"Some` value with our total `6` inside. Because the first arm matched, no "
"other arms are compared."
msgstr ""
"`Option::Some(5)` değeri `Option::Some(val)` deseniyle eşleşir mi? Evet! Aynı varyantımız var. `val`, `Option::Some` içindeki değere bağlanır, bu yüzden `val` `5` değerini alır. Sonra match kolundaki kod çalıştırılır, böylece `val`'ın değerine `1` ekler ve içinde toplamımız olan `6` ile yeni bir `Option::Some` değeri oluştururuz. İlk kol eşleştiğinden, başka kollar karşılaştırılmaz."


#: src/ch06-02-the-match-control-flow-construct.md:148
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where "
"`x` is `Option::None`. We enter the match and compare to the first arm:"
msgstr ""
"Şimdi ana fonksiyonumuzda `plus_one`'ın ikinci çağrısını düşünelim, burada `x` `Option::None`. Match'e girer ve ilk kola karşılaştırırız:"


#: src/ch06-02-the-match-control-flow-construct.md:154
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr ""
"`Option::Some(val)` değeri `Option::None` deseniyle eşleşmez, bu yüzden bir sonraki kola devam ederiz:"


#: src/ch06-02-the-match-control-flow-construct.md:160
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`Option::None` value on the right side of `=>`."
msgstr ""
"Eşleşir! Ekleyecek bir değer yok, bu yüzden program durur ve `=>`'nin sağ tarafındaki `Option::None` değerini döndürür."


#: src/ch06-02-the-match-control-flow-construct.md:162
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"`match` ve enumları birleştirmek birçok durumda yararlıdır. Bu deseni Cairo kodunda çok göreceksiniz: bir enuma karşı `match` yapın, veri içindeki bir değişkene bir değişken bağlayın ve sonra ona göre kod çalıştırın. İlk başta biraz zor olabilir, ama alıştığınızda, tüm dillerde bunu isteyeceksiniz. Tutarsız olarak bir kullanıcı favorisidir."


#: src/ch06-02-the-match-control-flow-construct.md:164
msgid "Matches Are Exhaustive"
msgstr "Eşleşmeler Kapsamlıdır"


#: src/ch06-02-the-match-control-flow-construct.md:166
msgid ""
"There’s one other aspect of match we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""
"Match'in tartışmamız gereken bir başka yönü daha var: kolların desenleri tüm olasılıkları kapsamalı. `plus_one` fonksiyonumuzun bir hata içeren ve derlenemeyecek bir versiyonunu düşünün:"


#: src/ch06-02-the-match-control-flow-construct.md:176
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""
"`None` durumunu ele almadık, bu yüzden bu kod bir hata oluşturacak. Neyse ki, bu Cairo'nun yakalayabileceği bir hata. Bu kodu derlemeyi denediğimizde, bu hatayı alırız:"


#: src/ch06-02-the-match-control-flow-construct.md:189
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""
"Cairo, her olası durumu kapsamadığımızı ve hangi deseni unuttuğumuzu bile biliyor! Cairo'da maçlar tükenmiştir: kodun geçerli olması için son olasılığı tüketmemiz gerekir. Özellikle `Option<T>` durumunda, Cairo'nun `None` durumunu açıkça ele almayı unutmamızı önlemesi, bir değere sahip olduğumuzu varsayarken aslında null'a sahip olabileceğimiz, böylece daha önce tartışılan milyar dolarlık hatayı imkansız kılar."


#: src/ch06-02-the-match-control-flow-construct.md:191
msgid "Catch-all with the `_` Placeholder"
msgstr "_` Yer Tutucusu ile Her Şeyi Yakalama"


#: src/ch06-02-the-match-control-flow-construct.md:193
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply add a new arm with `_` as the pattern as the last arm of the `match` "
"expression."
msgstr ""
"Enumlar kullanarak, birkaç özel değer için özel eylemler alabilir, ancak diğer tüm değerler için bir varsayılan eylem alabiliriz. `_`, herhangi bir değerle eşleşen ve o değere bağlanmayan özel bir desendir. Basitçe, `_` deseni olan bir kol ekleyerek ve `match` ifadesinin son koluna ekleyerek kullanabilirsiniz."


#: src/ch06-02-the-match-control-flow-construct.md:197
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that process inserted coins and returns true only if the "
"coin is accepted."
msgstr ""
"Yalnızca Dime bozuk paralarını kabul eden bir otomat makinesi olduğunu hayal edin. İçine atılan bozuk paraları işleyen ve yalnızca bozuk para kabul edildiğinde true dönen bir fonksiyon istiyoruz."


#: src/ch06-02-the-match-control-flow-construct.md:200
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr "İşte bu mantığı uygulayan bir `vending_machine_accept` fonksiyonu:"


#: src/ch06-02-the-match-control-flow-construct.md:211
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""
"Bu örnek de tükenmişlik gereksinimini karşılıyor çünkü son kolda açıkça diğer tüm değerleri görmezden geliyoruz; hiçbir şeyi unutmadık."


#: src/ch06-02-the-match-control-flow-construct.md:213
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr ""
"Cairo'da, desenin değerini kullanmanıza izin veren herhangi bir yakalama-tümü deseni yoktur."


#: src/ch06-02-the-match-control-flow-construct.md:219
msgid "Multiple Patterns with the `|` operator"
msgstr "`|` Operatörü ile Birden Fazla Desen"


#: src/ch06-02-the-match-control-flow-construct.md:221
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr ""
"`match` ifadelerinde, `|` sözdizimini kullanarak birden fazla deseni eşleştirebilirsiniz, bu da desen _veya_ operatörüdür."


#: src/ch06-02-the-match-control-flow-construct.md:223
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""
"Örneğin, aşağıdaki kodda `vending_machine_accept` fonksiyonunu hem `Dime` hem de `Quarter` bozuk paralarını tek bir kolda kabul edecek şekilde değiştirdik:"


#: src/ch06-02-the-match-control-flow-construct.md:234
msgid "Matching over Tuples"
msgstr "Demetler Üzerinde Eşleşme"


#: src/ch06-02-the-match-control-flow-construct.md:236
msgid ""
"It is possible to match over tuples. Let's introduce a new `DayType` enum:"
msgstr ""
"Demetler üzerinde eşleşmek mümkündür. Yeni bir `DayType` enum tanıtalım:"


#: src/ch06-02-the-match-control-flow-construct.md:248
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the coin is accepted and the day is a "
"weekday:"
msgstr ""
"Şimdi, otomat makinemizin hafta içi herhangi bir bozuk parayı kabul ettiğini, ancak hafta sonları ve tatillerde yalnızca çeyrekler ve dime'ları kabul ettiğini varsayalım. `vending_machine_accept` fonksiyonunu bir `Coin` ve bir `Weekday` demetini kabul edecek şekilde değiştirebilir ve yalnızca bozuk para kabul edildiğinde ve gün hafta içi olduğunda `true` dönebiliriz:"


#: src/ch06-02-the-match-control-flow-construct.md:261
msgid "Matching over integers"
msgstr "Tamsayılar Üzerinde Eşleşme"


#: src/ch06-02-the-match-control-flow-construct.md:263
msgid ""
"You can also match integers. This is useful when you want to match against a "
"range of values. However there are some restrictions:"
msgstr ""
"Tamsayılarla da eşleşebilirsiniz. Bu, belirli bir değer aralığına karşı eşleşmek istediğinizde yararlıdır. Ancak bazı kısıtlamalar vardır:"


#: src/ch06-02-the-match-control-flow-construct.md:266
msgid ""
"Only integers that fits in a single `felt252` are supported. (i.e. `u256` is "
"not supported)"
msgstr ""
"Yalnızca tek bir `felt252` içine sığan tamsayılar desteklenir. (yani `u256` desteklenmez)"


#: src/ch06-02-the-match-control-flow-construct.md:267
msgid "The first arm must be 0."
msgstr "İlk kolun 0 olması gerekir."


#: src/ch06-02-the-match-control-flow-construct.md:268
msgid "Each arms must be over a sequential segment (from `0`)"
msgstr "Her kolun ardışık bir segment üzerinde olması gerekir (0'dan itibaren)"


#: src/ch06-02-the-match-control-flow-construct.md:270
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""
"0 ile 5 arasında bir sayı almak için altı yüzlü bir zar attığınız bir oyun uyguladığımızı hayal edin. 0, 1 veya 2'niz varsa kazanırsınız. 3'ünüz varsa, tekrar zar atabilirsiniz. Diğer tüm değerler için kaybedersiniz."


#: src/ch06-02-the-match-control-flow-construct.md:273
msgid ""
"Here's a match that implements that logic, with the number hardcoded rather "
"than a random value."
msgstr "İşte bu mantığı uygulayan bir eşleşme, rastgele bir değer yerine sabit kodlanmış sayı ile."

#: src/ch06-02-the-match-control-flow-construct.md:278
msgid "\"you won!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:279
msgid "\"you can roll again!\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:280
msgid "\"you lost...\""
msgstr ""

#: src/ch06-02-the-match-control-flow-construct.md:285
msgid ""
"These restrictions are planned to be relaxed in future versions of Cairo."
msgstr ""
"Bu kısıtlamaların Cairo'nun gelecek sürümlerinde gevşetilmesi planlanmaktadır."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"Büyük programlar yazdıkça, kodunuzu düzenlemek giderek daha önemli hale gelecektir. İlgili işlevleri gruplayarak ve farklı özelliklere sahip kodları ayırarak, belirli bir özelliği uygulayan kodu nerede bulacağınızı ve bir özelliğin nasıl çalıştığını değiştirmek için nereye gideceğinizi netleştireceksiniz."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"Şimdiye kadar yazdığımız programlar bir modülde bir dosyada yer almıştır. Bir proje büyüdükçe, kodu birden fazla modüle ve ardından birden fazla dosyaya ayırarak düzenlemeniz gerekebilir. Bir paket büyüdükçe, parçaları dışa bağımlılıklar haline gelen ayrı kraytlara çıkarabilirsiniz. Bu bölüm tüm bu teknikleri ele almaktadır."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""
"Ayrıca, uygulama ayrıntılarını kapsüllemeyi de tartışacağız; bu da size daha yüksek bir seviyede kodu yeniden kullanma imkanı tanır: Bir işlemi uyguladıktan sonra, diğer kodlar kodunuzun nasıl çalıştığını bilmeksizin kodunuzu çağırabilir. "


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"İlgili bir kavram da kapsamdır: Kodun yazıldığı iç içe bağlamın, "kapsam" denen bir kümesi vardır. Okuma, yazma ve derleme işlemleri sırasında, bir programcının ve derleyicinin belirli bir noktadaki belirli bir adın bir değişkene, işleve, yapıya, numaralandırmaya, modüle, sabite veya başka bir öğeye mi referans ettiğini ve bu öğenin ne anlama geldiğini bilmesi gerekir. Kapsamlar oluşturabilir ve hangi adların kapsam içinde veya dışında olduğunu değiştirebilirsiniz. Aynı kapsamda aynı ada sahip iki öğe bulunamaz."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr ""
"Cairo, kodunuzun organizasyonunu yönetmenize olanak tanıyan bir dizi özellik sunar. Bu özellikler bazen _modül sistemi_ olarak topluca anılır ve şunları içerir:"


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr ""
"**Paketler:** Scarb özelliği, kraytlar oluşturmanıza, test etmenize ve paylaşmanıza olanak tanır."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit. "
"It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory."
msgstr ""
"**Kutu:** Tek bir derleme birimine karşılık gelen bir modül ağacıdır. Bir kök dizine ve bu dizin altındaki `lib.cairo` dosyasında tanımlanan bir kök modüle sahiptir."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid ""
"**Modules** and **use:** Let you control the organization and scope of items."
msgstr ""
"**Modüller** ve **kullan:** Öğelerin organizasyonunu ve kapsamını kontrol etmenizi sağlar."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""
"**Yollar:** Bir öğeyi, örneğin bir yapı, işlev veya modülü adlandırmanın bir yoludur."


#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"Bu bölümde, tüm bu özellikleri ele alacak, nasıl etkileşime girdiklerini tartışacak ve kapsamı yönetmek için nasıl kullanılacaklarını açıklayacağız. Sonunda, modül sistemini sağlam bir şekilde anlamalı ve kapsamlarla profesyonelce çalışabilmelisiniz!"


#: src/ch07-01-packages-and-crates.md:3
msgid "What is a crate?"
msgstr "Kutu nedir?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a "
"single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""
"Bir kutu, Cairo derleyicisinin bir seferde dikkate aldığı en küçük kod miktarıdır. `scarb build` yerine `cairo-compile` komutunu çalıştırırsanız ve tek bir kaynak kodu dosyası geçirirseniz, derleyici o dosyayı bir kutu olarak kabul eder. Kutular modülleri içerebilir ve modüller, sandıkla derlenen diğer dosyalarda tanımlanabilir, bunlar ilerleyen bölümlerde tartışılacaktır."


#: src/ch07-01-packages-and-crates.md:7
msgid "What is the crate root?"
msgstr "Kutu kökü nedir?"

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts "
"from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control Scope”](./ch07-02-defining-"
"modules-to-control-scope.md) section)."
msgstr "Kutu kökü, Cairo derleyicisinin başladığı ve kutunuzun kök modülünü oluşturan `lib.cairo` kaynak dosyasıdır."



#: src/ch07-01-packages-and-crates.md:11
msgid "What is a package?"
msgstr "Paket nedir?"

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A Cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code "
"into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr "Bir Cairo paketi, bir veya daha fazla kutu ile birlikte, bu kutuların nasıl inşa edileceğini açıklayan bir Scarb.toml dosyasından oluşan bir demettir."

#: src/ch07-01-packages-and-crates.md:15
msgid "Creating a Package with Scarb"
msgstr "Scarb ile Paket Oluşturma"

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr "Yeni bir Cairo paketi oluşturmak için scarb komut satırı aracını kullanabilirsiniz. Yeni bir paket oluşturmak için aşağıdaki komutu çalıştırın:"

#: src/ch07-01-packages-and-crates.md:23
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr "Bu komut, aşağıdaki yapıya sahip `my_package` adında yeni bir paket dizini oluşturur:"

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"`src/` is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr "`src/`, paket için tüm Cairo kaynak dosyalarının saklanacağı ana dizindir."


#: src/ch07-01-packages-and-crates.md:33
msgid ""
"`lib.cairo` is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr "`lib.cairo`, kutunun varsayılan kök modülüdür ve aynı zamanda paketin ana giriş noktasıdır."

#: src/ch07-01-packages-and-crates.md:34
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr "`Scarb.toml`, bağımlılıklar, paket adı, sürüm ve yazarlar gibi paket için meta veri ve yapılandırma seçeneklerini içeren paket manifest dosyasıdır."

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo` "
"files within the `src` directory or its subdirectories."
msgstr "Paketinizi geliştirirken, kodunuzu birden fazla Cairo kaynak dosyasına ayırmak isteyebilirsiniz. Bunu, `src` dizini içinde veya alt dizinlerinde ek `.cairo` dosyaları oluşturarak yapabilirsiniz."

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr "Bu bölümde, modüller ve modül sisteminin diğer parçaları olan _yollar_ hakkında ve bir yolu kapsam içine alma imkanı veren `use` anahtar kelimesi hakkında konuşacağız."

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr "Öncelikle, kodunuzu gelecekte organize ederken kolay referans için bir kural listesiyle başlayacağız. Sonra bu kuralların her birini detaylı bir şekilde açıklayacağız."

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr "Modüller Hile Sayfası"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow "
"along."
msgstr "Burada, modüllerin, yolların ve `use` anahtar kelimesinin derleyicide nasıl çalıştığına ve çoğu geliştiricinin kodlarını nasıl organize ettiğine dair hızlı bir referans sunuyoruz."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr "Kutu kökünden başlayın: Bir kutuyu derlerken, derleyici önce kodu derlemek için kutu kök dosyasında (_src/lib.cairo_) arar."

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr "Modülleri bildirmek: Kutu kök dosyasında, `mod garden;` diyerek yeni modüller bildirebilirsiniz. Derleyici, modülün kodunu şu yerlerde arayacaktır:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden;`."
msgstr "Kıvırcık parantezler içinde, `mod garden;`i takip eden noktalı virgülün yerini alarak."

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr "_src/garden.cairo_ dosyasında"

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in _src/"
"garden.cairo_. The compiler will look for the submodule’s code within the "
"directory named for the parent module in these places:"
msgstr "Alt modülleri bildirmek: Kutu kök dosyası dışındaki herhangi bir dosyada, alt modüller bildirebilirsiniz."

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr "Doğrudan `mod vegetables`'ı takip eden ve noktalı virgülün yerine geçen kıvırcık parantezler içinde."

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr "_src/garden/vegetables.cairo_ dosyasında"

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at `backyard::garden::vegetables::"
"Asparagus`."
msgstr "Modüllerdeki kodlara yollar: Bir modül kutunuzun bir parçası olduktan sonra, aynı kutu içindeki herhangi bir yerden o modüldeki koda, kodun yolunu kullanarak atıfta bulunabilirsiniz."

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr "`use` anahtar kelimesi: Bir kapsam içinde, `use` anahtar kelimesi, uzun yolların tekrarını azaltmak için öğelere kısayollar oluşturur."

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr "Bu bölümde, `backyard` adında bu kuralları örneklendiren bir kutu oluşturuyoruz. Kutunun dizini, aynı zamanda `backyard` olarak adlandırılmış, bu dosya ve dizinleri içerir:"

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "Bu durumda kutu kök dosyası _src/lib.cairo_'dır ve içerdiği:"

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr "`mod garden;` satırı, derleyicinin _src/garden.cairo_ içinde bulduğu kodu dahil etmesini söyler, bu şu anlama gelir:"

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "Filename: src/garden.cairo"
msgstr "Dosya adı: src/garden.cairo"

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is "
"included too. That code is:"
msgstr "Burada, `mod vegetables;` _src/garden/vegetables.cairo_ içindeki kodun da dahil edildiği anlamına gelir. Bu kod şudur:"

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr "`use garden::vegetables::Asparagus;` satırı, `Asparagus` türünü kapsama alır, böylece onu `main` fonksiyonunda kullanabiliriz."

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr "Şimdi bu kuralların detaylarına dalalım ve onları eylemde gösterelim!"

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "Grouping Related Code in Modules"
msgstr "Modüllerde İlgili Kodları Gruplama"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. As an example, let’s write a library crate that provides the "
"functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, "
"rather than the implementation of a restaurant."
msgstr "_Modüller_, bir kutu içindeki kodu okunabilirlik ve kolay yeniden kullanım için düzenlememize izin verir. Örneğin, bir restoranın işlevselliğini sağlayan bir kütüphane kutusu yazalım. Fonksiyonların imzalarını tanımlayacağız ama kodun organizasyonuna odaklanmak için gövdelerini boş bırakacağız, restoranın uygulanması yerine."

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr "Restoran endüstrisinde, bir restoranın bazı kısımlarına _ön ev_ ve diğerlerine _arka ev_ denir. Ön ev, müşterilerin olduğu yerdir; bu, hostların müşterileri oturttuğu, garsonların sipariş ve ödemeleri aldığı ve barmenlerin içki yaptığı yerleri kapsar. Arka ev, şeflerin ve aşçıların mutfakta çalıştığı, bulaşıkçıların temizlik yaptığı ve yöneticilerin idari işleri yürüttüğü yerdir."

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named `restaurant` by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr "Kutumuzu bu şekilde yapılandırmak için, fonksiyonlarını iç içe modüller halinde düzenleyebiliriz. `scarb new restaurant` çalıştırarak `restaurant` adında yeni bir paket oluşturun; sonra bazı modülleri ve fonksiyon imzalarını tanımlamak için _src/lib.cairo_ içine Listeleme 7-1'deki kodu girin. İşte ön ev bölümü:"

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid ""
"Listing 7-1: A `front_of_house` module containing other modules that then "
"contain functions"
msgstr "Listeleme 7-1: Diğer modülleri içeren ve sonra fonksiyonları içeren bir `front_of_house` modülü"

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 6-1—functions."
msgstr "`mod` anahtar kelimesini modülün adıyla (bu durumda, `front_of_house`) takip ederek bir modül tanımlarız. Modülün gövdesi sonra kıvırcık parantezler içine girer. Modüller içinde, bu durumda olduğu gibi `hosting` ve `serving` modülleri ile diğer modüller yerleştirebiliriz. Modüller ayrıca structlar, enumlar, sabitler, traitler ve Listeleme 6-1'de olduğu gibi fonksiyonlar gibi diğer öğeler için tanımlamaları da içerebilir."

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr "Modülleri kullanarak, ilgili tanımlamaları bir araya gruplayabilir ve neden ilişkili olduklarını adlandırabiliriz. Bu kodu kullanan programcılar, tüm tanımları okumak zorunda kalmadan gruplara dayanarak kodu gezinebilir, bu da onlara ilgili tanımlamaları daha kolay bulmalarını sağlar. Bu koda yeni işlevsellik ekleyen programcılar, programı düzenli tutmak için kodu nereye yerleştireceklerini bilecektir."

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr "Daha önce, _src/lib.cairo_'nun kutu kökü olarak adlandırıldığını belirtmiştik. Bu adın nedeni, bu dosyanın içeriğinin kutunun modül yapısının kökünde, _modül ağacı_ olarak bilinen, kutu adıyla adlandırılan bir modülü oluşturmasıdır."

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "Listeleme 7-2, Listeleme 7-1'deki yapı için modül ağacını gösterir."

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr "Listeleme 7-2: Listeleme 6-1'deki kod için modül ağacı"

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate `restaurant`."
msgstr "Bu ağaç, bazı modüllerin birbirinin içine nasıl yerleştirildiğini gösterir; örneğin, `hosting` `front_of_house` içinde yer alır. Ağaç ayrıca bazı modüllerin birbirine _kardeş_ olduğunu, yani aynı modülde tanımlandıklarını gösterir; `hosting` ve `serving` `front_of_house` içinde tanımlanmış kardeşlerdir. Eğer modül A, modül B'nin içinde yer alıyorsa, modül A'nın modül B'nin _çocuğu_ olduğunu ve modül B'nin modül A'nın _ebeveyni_ olduğunu söyleriz. Tüm modül ağacının `restaurant` kutusunun açık adı altında köklendiğine dikkat edin."

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr "Modül ağacı, bilgisayarınızdaki dosya sisteminin dizin ağacını hatırlatabilir; bu çok uygun bir karşılaştırmadır! Dosya sistemindeki dizinler gibi, kodunuzu düzenlemek için modülleri kullanırsınız. Ve bir dizindeki dosyalar gibi, modüllerimizi bulmanın bir yoluna ihtiyacımız var."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr "Cairo'ya bir modül ağacında bir öğeyi nerede bulacağını göstermek için, bir dosya sistemini gezinirken yaptığımız gibi bir yolu kullanırız. Bir fonksiyonu çağırmak için, yolunu bilmemiz gerekir."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "Bir yol iki şekil alabilir:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute "
"path begins with the crate name."
msgstr "Bir _mutlak yol_, kutu kökünden başlayan tam yoldur. Mutlak yol, kutu adıyla başlar."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "Bir _göreceli yol_, mevcut modülden başlar."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr "Hem mutlak hem de göreceli yollar, çift iki nokta üst üste (`::`) ile ayrılmış bir veya daha fazla tanımlayıcı ile takip edilir."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr "Bu kavramı açıklamak için son bölümde kullandığımız restoran örneğine, Listeleme 7-1'e geri dönelim. `restaurant` adında bir kutumuz var ve bu kutuda `front_of_house` adında bir modül var. `hosting` modülü, `add_to_waitlist` adında bir fonksiyon içeriyor. `eat_at_restaurant` fonksiyonundan `add_to_waitlist` fonksiyonunu çağırmak istiyoruz. Cairo'ya `add_to_waitlist` fonksiyonunun yolunu söylememiz gerekiyor ki bulabilsin."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:36
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:37
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:40
msgid "// ✅ Compiles\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:39
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"Listing 7-3: Calling the `add_to_waitlist` function using absolute and "
"relative paths"
msgstr "Listeleme 7-3: `add_to_waitlist` fonksiyonunu mutlak ve göreceli yollar kullanarak çağırma"


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name."
msgstr "`eat_at_restaurant` içinde `add_to_waitlist` fonksiyonunu ilk kez çağırdığımızda, bir mutlak yol kullanırız. `add_to_waitlist` fonksiyonu, `eat_at_restaurant` ile aynı kutuda tanımlanmıştır. Cairo'da, mutlak yollar kutu kökünden başlar, bunun için kutu adını kullanmanız gerekir."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path `./front_of_house/hosting/"
"add_to_waitlist`. Starting with a module name means that the path is "
"relative to the current module."
msgstr "İkinci kez `add_to_waitlist`'i çağırdığımızda, bir göreceli yol kullanırız. Yol, modül ağacının aynı seviyesinde `eat_at_restaurant` ile tanımlanmış `front_of_house` modülünün adıyla başlar. Burada dosya sistemindeki eşdeğeri `./front_of_house/hosting/add_to_waitlist` yolunu kullanmaktır. Bir modül adıyla başlamak, yolun mevcut modüle göreli olduğu anlamına gelir."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "Starting Relative Paths with `super`"
msgstr "`super` ile Göreceli Yolların Başlatılması"


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on "
"your project, and depends on whether you’re more likely to move item "
"definition code separately from or together with the code that uses the item."
msgstr "Bir `super` kullanıp kullanmamaya karar vermek, projenize bağlı bir karardır ve öğe tanım kodunu, öğeyi kullanan kodla birlikte veya ayrı olarak taşıma olasılığınıza bağlıdır."


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid ""
"Listing 7-4: Calling a function using a relative path starting with super"
msgstr "Listeleme 7-4: `super` ile başlayan bir göreceli yol kullanarak bir fonksiyonu çağırma"


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr "Burada, `super` kullanarak bir ebeveyn modülüne doğrudan nasıl erişilebileceğini görebilirsiniz, bu önceki durumda mümkün değildi."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "`use` Anahtar Kelimesi ile Yolları Kapsama Almak"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr "Fonksiyonları çağırmak için yolları yazmak zorunda kalmak, rahatsız edici ve tekrar eden bir durum olabilir. Neyse ki, bu süreci basitleştirecek bir yol var: `use` anahtar kelimesi ile bir yola bir kez kısayol oluşturabilir ve sonra kapsamdaki her yerde daha kısa adı kullanabiliriz."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr "Listeleme 7-5'te, `eat_at_restaurant` fonksiyonunun kapsamına `restaurant::front_of_house::hosting` modülünü getiriyoruz, böylece `eat_at_restaurant` içinde `add_to_waitlist` fonksiyonunu çağırmak için sadece `hosting::add_to_waitlist` dememiz yeterli oluyor."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called "
"\"restaurant\", as mentioned in the section \"Defining Modules to Control "
"Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in "
"the use statement\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr "Listeleme 7-5: `use` ile bir modülü kapsama almak"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr "Kapsamda `use` ve bir yolu eklemek, dosya sisteminde sembolik bir bağlantı oluşturmaya benzer. Kutu kökünde `use restaurant::front_of_house::hosting` ekleyerek, `hosting` artık o kapsamda geçerli bir ad olur, sanki `hosting` modülü kutu kökünde tanımlanmış gibi."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr "`use` yalnızca `use`'ın gerçekleştiği belirli kapsam için kısayolu oluşturur. Listeleme 7-6, `eat_at_restaurant` fonksiyonunu `customer` adında yeni bir çocuk modüle taşır, bu da `use` ifadesinden farklı bir kapsam oluşturur, bu yüzden fonksiyon gövdesi derlenmez:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr "Listeleme 7-6: Bir `use` ifadesi yalnızca içinde bulunduğu kapsamda geçerlidir"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr "Derleyici hatası, kısayolun `customer` modülü içinde artık geçerli olmadığını gösterir:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "Creating Idiomatic `use` Paths"
msgstr "İdiyomatik `use` Yolları Oluşturma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use restaurant::"
"front_of_house::hosting` and then called `hosting::add_to_waitlist` in "
"`eat_at_restaurant` rather than specifying the `use` path all the way out to "
"the `add_to_waitlist` function to achieve the same result, as in Listing 7-7."
msgstr "Listeleme 7-5'te, `use restaurant::front_of_house::hosting` belirtip `eat_at_restaurant` içinde `hosting::add_to_waitlist` çağırmamızın nedeni, aynı sonucu elde etmek için `add_to_waitlist` fonksiyonuna kadar `use` yolunu belirtmememizdir, Listeleme 7-7'de olduğu gibi."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid ""
"Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, "
"which is unidiomatic"
msgstr "Listeleme 7-7: `use` ile `add_to_waitlist` fonksiyonunu kapsama almak, ki bu idiyomatik değildir"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 7-7 accomplish the same task, Listing 7-5 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-7 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr "Hem Listeleme 7-5 hem de 7-7 aynı görevi yerine getirse de, Listeleme 7-5 bir fonksiyonu `use` ile kapsama almanın idiyomatik yoludur. Fonksiyonun ana modülünü `use` ile kapsama almak, fonksiyonu çağırırken ana modülü belirtmemiz gerektiği anlamına gelir. Fonksiyonu çağırırken ana modülü belirtmek, fonksiyonun yerel olarak tanımlanmadığını açıkça yaparken, tam yolu tekrarlamayı da en aza indirir. Listeleme 7-7'deki kod, `add_to_waitlist`'in nerede tanımlandığı konusunda belirsizdir."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-8 shows the "
"idiomatic way to bring the core library’s `ArrayTrait` trait into the scope."
msgstr "Diğer taraftan, yapılar, enumlar, traitler ve `use` ile kapsama alınan diğer öğeleri getirirken, tam yolu belirtmek idiyomatiktir. Listeleme 7-8, çekirdek kütüphanenin `ArrayTrait` trait'ini kapsama alanına idiyomatik bir şekilde getirmeyi gösterir."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr "Listeleme 7-8: `ArrayTrait`'i idiyomatik bir şekilde kapsama almak"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and "
"writing Rust code this way. As Cairo shares many idioms with Rust, we follow "
"this convention as well."
msgstr "Bu idiyomun arkasında güçlü bir neden yoktur: bu sadece Rust topluluğunda ortaya çıkan bir gelenektir ve insanlar Rust kodunu bu şekilde okumaya ve yazmaya alışmışlardır. Cairo, Rust ile birçok idiyomu paylaştığı için, bu geleneği biz de takip ediyoruz."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr "`use` ifadeleri ile aynı isme sahip iki öğeyi kapsama almak istediğimizde bu idiyomun bir istisnası vardır, çünkü Cairo bunu izin vermez."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "Providing New Names with the `as` Keyword"
msgstr "`as` Anahtar Kelimesi ile Yeni İsimler Sağlamak"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-9 shows how you can "
"rename an import with `as`:"
msgstr "`use` ile aynı isimdeki iki tipi aynı kapsama almanın sorununa başka bir çözüm daha var: yolu belirttikten sonra, tip için yeni bir yerel ad veya _takma ad_ belirlemek üzere `as` ve bir adı belirtebiliriz. Listeleme 7-9, bir import'u `as` ile nasıl yeniden adlandırabileceğinizi gösterir:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid "// ArrayTrait was renamed to Arr\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"Listing 7-9: Renaming a trait when it’s brought into scope with the `as` "
"keyword"
msgstr "Listeleme 7-9: `as` anahtar kelimesi ile kapsama alındığında bir trait'i yeniden adlandırma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr "Burada, `ArrayTrait`'i `Arr` takma adıyla kapsama aldık. Artık trait'in metodlarına `Arr` tanımlayıcısı ile erişebiliriz."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "Importing multiple items from the same module"
msgstr "Aynı Modülden Birden Fazla Öğeyi İçe Aktarma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr "Cairo'da, aynı modülden birden fazla öğeyi (fonksiyonlar, yapılar veya enumlar gibi) içe aktarmak istediğinizde, içe aktarmak istediğiniz tüm öğeleri listelemek için küme parantezleri `{}` kullanabilirsiniz. Bu, uzun bir `use` ifadeleri listesinden kaçınarak kodunuzu temiz ve okunabilir tutmaya yardımcı olur."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr "Aynı modülden birden fazla öğeyi içe aktarmanın genel sözdizimi:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr "İşte aynı modülden üç yapıyı içe aktardığımız bir örnek:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189
#: src/ch08-02-traits-in-cairo.md:346 src/ch08-02-traits-in-cairo.md:350
#: src/ch08-02-traits-in-cairo.md:359
#: src/ch99-03-security-considerations.md:143
#: src/ch99-03-security-considerations.md:148
msgid "// ...\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr "Listeleme 7-10: Aynı modülden birden fazla öğeyi içe aktarma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "Re-exporting Names in Module Files"
msgstr "Modül Dosyalarında İsimleri Yeniden Dışa Aktarma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope."
msgstr "`use` anahtar kelimesi ile bir ismi kapsama alırken, yeni kapsamdaki isim, o kodun kapsamında tanımlanmış gibi içe aktarılabilir. Bu tekniğe _yeniden dışa aktarma_ denir çünkü bir öğeyi kapsama alıyoruz, ama aynı zamanda bu öğeyi başkalarının da kendi kapsamlarına alabilmesi için kullanılabilir hale getiriyoruz."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr "Örneğin, restoran örneğinde `add_to_waitlist` fonksiyonunu yeniden dışa aktaralım:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid ""
"Listing 7-11: Making a name available for any code to use from a new scope "
"with `pub use`"
msgstr "Listeleme 7-11: `pub use` ile bir ismi yeni bir kapsamdan herhangi bir kodun kullanımına sunma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path `restaurant::front_of_house::hosting::"
"add_to_waitlist()`. Now that this `use` has re-exported the `hosting` module "
"from the root module, external code can now use the path `restaurant::"
"hosting::add_to_waitlist()` instead."
msgstr "Bu değişiklikten önce, dış kod `add_to_waitlist` fonksiyonunu `restaurant::front_of_house::hosting::add_to_waitlist()` yoluyla çağırmak zorunda kalacaktı. Bu `use` ile `hosting` modülü kök modülden yeniden dışa aktarıldığı için, dış kod artık `restaurant::hosting::add_to_waitlist()` yolunu kullanabilir."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr "Yeniden dışa aktarma, kodunuzun iç yapısı kodunuzu çağıran programcıların alan hakkında düşündüğü şekilden farklı olduğunda faydalıdır. Örneğin, bu restoran metaforunda, restoranı işleten insanlar “ön ev” ve “arka ev” hakkında düşünür. Ancak bir restoranı ziyaret eden müşteriler muhtemelen restoranın bölümlerini bu terimlerle düşünmeyecektir. `use` ile, kodumuzu bir yapıda yazabilir ama farklı bir yapıyı sunabiliriz. Bunu yapmak, kütüphanemizi kütüphane üzerinde çalışan programcılar ve kütüphaneyi çağıran programcılar için iyi organize edilmiş hale getirir."


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "Using External Packages in Cairo with Scarb"
msgstr "Scarb ile Cairo'da Dış Paketleri Kullanma"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr "Topluluktan sağlanan işlevselliği kullanmak için dış paketlere ihtiyaç duyabilirsiniz. Scarb ile projenizde bir dış paket kullanmak için şu adımları izleyin:"


#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"The dependencies system is still a work in progress. You can check the "
"official [documentation](https://docs.swmansion.com/scarb/docs/guides/"
"dependencies.html)."
msgstr "Bağımlılıklar sistemi hala bir çalışma aşamasındadır. Resmi [belgelere](https://docs.swmansion.com/scarb/docs/guides/dependencies.html) bakabilirsiniz."


#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr "Şu ana kadar bu bölümdeki tüm örnekler, birden fazla modülü tek bir dosyada tanımladı. Modüller büyüdükçe, kodu daha kolay gezinebilir hale getirmek için tanımlarını ayrı bir dosyaya taşımak isteyebilirsiniz."


#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr "Örneğin, birden fazla restoran modülü içeren Listeleme 7-11'deki koddan başlayalım. Tüm modülleri kutu kök dosyasında tanımlamak yerine, modülleri dosyalara ayıklayacağız. Bu durumda, kutu kök dosyası _src/lib.cairo_'dur."


#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the "
"code shown in Listing 7-12. Note that this won’t compile until we create the "
"_src/front_of_house.cairo_ file in Listing 7-13."
msgstr "İlk olarak, `front_of_house` modülünü kendi dosyasına ayıklayacağız. `front_of_house` modülü için kıvırcık parantezler içindeki kodu kaldırın, yalnızca `mod front_of_house;` bildirimini bırakın, böylece _src/lib.cairo_ Listeleme 7-12'de gösterildiği gibi kodu içerir. Listeleme 7-13'teki _src/front_of_house.cairo_ dosyasını oluşturana kadar bu derlenmeyecektir."


#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"Listing 7-12: Declaring the `front_of_house` module whose body will be in "
"_src/front_of_house.cairo_"
msgstr "Listeleme 7-12: Gövdesi _src/front_of_house.cairo_'da olacak `front_of_house` modülünü bildirme"


#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr "Daha sonra, kıvırcık parantezler içindeki kodu _src/front_of_house.cairo_ adlı yeni bir dosyaya yerleştirin, Listeleme 7-13'te gösterildiği gibi. Derleyici, modül bildirimini kutu kökünde `front_of_house` adıyla karşılaştığı için bu dosyada kodu aramak için nereye bakacağını bilir."


#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
msgid "Filename: src/front_of_house.cairo"
msgstr "Dosya Adı: src/front_of_house.cairo"


#: src/ch07-05-separating-modules-into-different-files.md:46
msgid ""
"Listing 7-13: Definitions inside the `front_of_house` module in _src/"
"front_of_house.cairo_"
msgstr "Listeleme 7-13: `front_of_house` modülü içindeki tanımlar _src/front_of_house.cairo_'da"


#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module Tree”](ch06-03-paths-for-"
"referring-to-an-item-in-the-module-tree.html)"
msgstr "Bir dosyayı `mod` bildirimi kullanarak yüklemeniz yalnızca modül ağacınızda _bir kez_ gereklidir. Derleyici dosyanın projenin bir parçası olduğunu bildiği zaman (ve `mod` ifadesini nereye koyduğunuzdan dolayı kodun modül ağacında nerede bulunduğunu bildiği için), projenizdeki diğer dosyalar yüklenen dosyanın koduna, modül ağacında nerede bildirildiğine dair bir yolu kullanarak atıfta bulunmalıdır."


#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may "
"have seen in other programming languages."
msgstr "Diğer bir deyişle, `mod` diğer programlama dillerinde görebileceğiniz bir “include” işlemi _değildir_."


#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case _src/"
"front_of_house/_."
msgstr "`hosting` modülünü kendi dosyasına ayıracağız. İşlem biraz farklıdır çünkü `hosting`, kök modülün değil, `front_of_house`'un çocuk modülüdür. `hosting` dosyasını, bu durumda _src/front_of_house/_ olacak şekilde, modül ağacındaki atalarının adıyla adlandırılacak yeni bir dizine yerleştireceğiz."


#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr "`hosting`'i taşımaya başlamak için, _src/front_of_house.cairo_ içinde yalnızca `hosting` modülünün bildirimini içerecek şekilde değiştiririz:"


#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr "Ardından `hosting` modülünde yapılan tanımları içerecek _hosting.cairo_ adında bir dosya ve _src/front_of_house_ dizini oluştururuz:"


#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr "Dosya Adı: src/front_of_house/hosting.cairo"


#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would "
"expect the _hosting.cairo_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code means the "
"directories and files more closely match the module tree."
msgstr "Eğer _hosting.cairo_ dosyasını _src_ dizinine koysaydık, derleyici _hosting.cairo_ kodunun, `front_of_house` modülünün bir çocuğu olarak değil, kutu kökünde bildirilmiş bir `hosting` modülünde olmasını beklerdi. Derleyicinin hangi dosyaları hangi modüllerin kodları için kontrol edeceği kuralları, dizinlerin ve dosyaların modül ağacını daha yakından takip etmesini sağlar."


#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr "Her modülün kodunu ayrı bir dosyaya taşıdık ve modül ağacı aynı kaldı. `eat_at_restaurant` içindeki fonksiyon çağrıları, tanımlar farklı dosyalarda yaşasa bile herhangi bir değişiklik olmadan çalışacaktır. Bu teknik, modüller büyüdükçe yeni dosyalara taşınmasını sağlar."


#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in _src/"
"lib.cairo_ also hasn’t changed, nor does `use` have any impact on what files "
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Cairo looks in a file with the same name as the module for the code that "
"goes into that module."
msgstr "Ayrıca, _src/lib.cairo_ içindeki `use restaurant::front_of_house::hosting` ifadesi de değişmedi, `use` ifadesi kutunun bir parçası olarak hangi dosyaların derlendiği üzerinde herhangi bir etkiye sahip değil. `mod` anahtar kelimesi modülleri bildirir ve Cairo, modülle aynı adı taşıyan bir dosyada o modül için kodu arar."


#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is public by default."
msgstr "Cairo, bir paketi birden fazla kutuya ve bir kutuyu modüllere bölmek için size olanak tanır, böylece bir modülde tanımlanan öğelere başka bir modülden atıfta bulunabilirsiniz. Bunu yapmak için mutlak veya göreceli yolları belirtebilirsiniz. Bu yollar, bir `use` ifadesi ile kapsama alınabilir, böylece o kapsamdaki öğenin birden fazla kullanımı için daha kısa bir yol kullanabilirsiniz. Modül kodu varsayılan olarak halkadır."


#: src/ch08-00-generic-types-and-traits.md:1
msgid "Generic Types and Traits"
msgstr "Genel Türler ve Traitler"


#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract stand-"
"ins for concrete types or other properties. We can express the behavior of "
"generics or how they relate to other generics without knowing what will be "
"in their place when compiling and running the code."
msgstr "Her programlama dilinde, kavramların çoğaltılmasını etkili bir şekilde ele almanın araçları vardır. Cairo'da, bu araçlardan biri genel türlerdir: somut türler veya diğer özellikler için soyut yer tutucular. Genel türlerin davranışını veya diğer genel türlerle nasıl ilişkili olduklarını, kodu derleme ve çalıştırma sırasında yerlerinde ne olacağını bilmeksizin ifade edebiliriz."


#: src/ch08-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete type like `u32` or "
"`ContractAddress`."
msgstr "Fonksiyonlar, yapılar, enumlar ve traitler, `u32` veya `ContractAddress` gibi somut bir tür yerine genel türleri tanımlarının bir parçası olarak kapsayabilir."


#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr "Genel türler, belirli türlerle kod tekrarını ortadan kaldırmak için yer tutucu olarak kullanılmamıza olanak tanır."


#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr "Genel bir tür yerine her somut tür için derleyici yeni bir tanım oluşturur, bu da programcı için geliştirme süresini azaltır, ancak derleme seviyesinde hala kod tekrarı vardır. Eğer Starknet sözleşmeleri yazıyorsanız ve birden fazla tür için genel bir tür kullanıyorsanız, bu, sözleşme boyutunun artması nedeniyle önemli olabilir."


#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You "
"can combine traits with generic types to constrain a generic type to accept "
"only those types that have a particular behavior, as opposed to just any "
"type."
msgstr "Daha sonra, davranışı genel bir şekilde tanımlamak için traitleri nasıl kullanacağınızı öğreneceksiniz. Genel türlerle traitleri birleştirerek, genel bir türü yalnızca belirli bir davranışa sahip olan türlerle sınırlayabilirsiniz, yalnızca herhangi bir tür yerine."


#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs "
"and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums, "
"traits, implementations and methods! In this chapter we are going to take a "
"look at how to effectively use generic types with all of them."
msgstr "Genel türlerle tanım oluştururken, tanımların, örneğin yapılar ve fonksiyonlar gibi öğe bildirimleri için genel türleri kullanırız. Böylece bunları birçok farklı somut veri tipi ile kullanabiliriz. Cairo'da fonksiyonlar, yapılar, enumlar, traitler, uygulamalar ve metodlar tanımlarken genel türleri kullanabiliriz! Bu bölümde, hepsiyle genel türleri nasıl etkili bir şekilde kullanacağımıza bakacağız."


#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr "Genel türleri kullanan bir fonksiyon tanımlarken, genel türleri fonksiyon imzasına yerleştiririz, genellikle parametre ve dönüş değerinin veri tiplerini belirttiğimiz yerde. Örneğin, iki `Array` öğesi verildiğinde en büyüğünü döndüren bir fonksiyon oluşturmak istediğimizi hayal edin. Bu işlemi farklı türlerdeki listeler için gerçekleştirmemiz gerekiyorsa, her seferinde fonksiyonu yeniden tanımlamamız gerekirdi. Neyse ki, genel türleri kullanarak fonksiyonu bir kez uygulayabilir ve diğer görevlere geçebiliriz."


#: src/ch08-01-generic-data-types.md:10
msgid "// Specify generic type T between the angulars\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:31
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable "
"when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in "
"the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr "`largest_list` fonksiyonu, aynı türden iki listeyi karşılaştırır ve daha fazla elemana sahip olanı döndürüp diğerini atar. Önceki kodu derlediğinizde, genel bir tür için bir dizi bırakma işlemiyle ilgili tanımlanmış traitler olmadığını söyleyen bir hata ile başarısız olacağını fark edeceksiniz. Bu, derleyicinin `main` fonksiyonunu çalıştırırken bir `Array<T>`'nin bırakılabilir olduğunu garanti edememesinden kaynaklanır. `T` türündeki bir diziyi bırakabilmek için, derleyicinin önce `T`'yi nasıl bırakacağını bilmelidir. Bu, `largest_list` fonksiyonunun imzasında `T`'nin bırakma traitini uygulaması gerektiğini belirterek düzeltilebilir. `largest_list` fonksiyonunun doğru tanımı şu şekildedir:"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main` "
"function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr "Yeni `largest_list` fonksiyonu, tanımında, oraya yerleştirilen genel tür ne olursa olsun, bırakılabilir olması gerektiği gereksinimini içerir. `main` fonksiyonu değişmeden kalır, derleyici kullanılan somut türü ve `Drop` traitini uygulayıp uygulamadığını akıllıca çıkarabilir."

#: src/ch08-01-generic-data-types.md:51
msgid "Constraints for Generic Types"
msgstr "Genel Türler için Kısıtlamalar"


#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function "
"logic."
msgstr "Genel türler tanımlanırken, onlar hakkında bilgi sahibi olmak faydalıdır. Genel bir türün hangi traitleri uyguladığını bilmek, fonksiyon mantığında onları daha etkili bir şekilde kullanmamıza olanak tanır, bunun maliyeti ise fonksiyonla kullanılabilecek genel türleri kısıtlamaktır. Bunu daha önce, `largest_list`'in genel argümanlarına `TDrop` uygulamasını ekleyerek gördük. `TDrop`, derleyicinin gereksinimlerini karşılamak için eklenmiş olsa da, fonksiyon mantığımızı yararlandırmak için de kısıtlamalar ekleyebiliriz."


#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element "
"of type `T` to be comparable, it must implement the `PartialOrd` trait. The "
"resulting function would be:"
msgstr "Bir `T` genel türünden elemanların listesini verdiğimizde, aralarından en küçüğünü bulmak istediğimizi hayal edin. Başlangıçta, bir `T` türünden elemanın karşılaştırılabilir olması için `PartialOrd` traitini uygulaması gerektiğini biliyoruz. Sonuç fonksiyon şöyle olurdu:"


#: src/ch08-01-generic-data-types.md:58
msgid ""
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:62
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:66
msgid "// The index we will use to move through the list\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:69
msgid "// Iterate through the whole list storing the smallest\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:84
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:90
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so "
"we don't require to implement the `Drop` trait for `T` as well. Why it does "
"not compile then?"
msgstr "`smallest_element` fonksiyonu, `PartialOrd` traitini uygulayan bir genel tür `T` kullanır, `Array<T>`'nin bir anlık görüntüsünü parametre olarak alır ve en küçük elemanın bir kopyasını döndürür. Parametre `@Array<T>` türünde olduğu için, yürütmenin sonunda onu bırakmamız gerekmez ve dolayısıyla `T` için de `Drop` traitini uygulamamız gerekmez. O zaman neden derlenmiyor?"


#: src/ch08-01-generic-data-types.md:92
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element, "
"unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be "
"correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr "`list` üzerinde dizinleme yapıldığında, değer, dizinlenen öğenin bir anlık görüntüsü sonucunu verir, `@T` için `PartialOrd` uygulanmadıkça öğeyi `*` kullanarak anlık görüntüden çıkarmamız gerekir. `*` işlemi, `@T`'den `T`'ye bir kopya gerektirir, bu da `T`'nin `Copy` özelliğini uygulaması gerektiği anlamına gelir. `@T` türünden bir öğeyi `T`'ye kopyaladıktan sonra, bırakılması gereken `T` türünde değişkenler vardır, bu da `T` için `Drop` özelliğinin de uygulanması gerektiğini gerektirir. Fonksiyonun doğru olması için hem `Drop` hem de `Copy` özelliklerinin uygulanması gerekir. `smallest_element` fonksiyonunu güncelledikten sonra sonuç kod şu olacaktır:"


#: src/ch08-01-generic-data-types.md:112
msgid "Anonymous Generic Implementation Parameter (`+` operator)"
msgstr "Anonim Genel Uygulama Parametresi (`+` operatörü)"

#: src/ch08-01-generic-data-types.md:114
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr "Şimdiye kadar, gereken genel özelliklerin her biri için bir isim belirttik: `PartialOrd<T>` için `TPartialOrd`, `Drop<T>` için `TDrop` ve `Copy<T>` için `TCopy`."

#: src/ch08-01-generic-data-types.md:116
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr "Ancak, çoğu zaman, fonksiyon gövdesinde uygulamayı kullanmayız; sadece bir kısıtlama olarak kullanırız. Bu durumlarda, genel türün bir özelliği uygulaması gerektiğini belirtmek için `+` operatörünü kullanabilir ve uygulamaya bir isim vermeyebiliriz. Buna _anonim genel uygulama parametresi_ denir."

#: src/ch08-01-generic-data-types.md:118
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr "`+PartialOrd<T>`, `impl TPartialOrd: PartialOrd<T>` ile eşdeğerdir."

#: src/ch08-01-generic-data-types.md:120
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr "`smallest_element` fonksiyonun imzasını şu şekilde yeniden yazabiliriz:"

#: src/ch08-01-generic-data-types.md:138
msgid "Structs"
msgstr ""

#: src/ch08-01-generic-data-types.md:140
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of "
"type `T`."
msgstr "Yapıları, bir veya daha fazla alan için genel tür parametresi kullanacak şekilde `<>` sözdizimini kullanarak tanımlayabiliriz, fonksiyon tanımlarına benzer şekilde. Önce yapı adının hemen ardından açı parantezleri içinde tür parametresinin adını belirtiriz. Daha sonra yapı tanımında, aksi takdirde somut veri türlerini belirteceğimiz yerde genel türü kullanırız. Aşağıdaki kod örneği, `T` türünde bir `balance` alanına sahip olan `Wallet<T>` tanımını göstermektedir."

#: src/ch08-01-generic-data-types.md:154
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically. "
"It is equivalent to writing the following code:"
msgstr "Yukarıdaki kod, `Wallet` türü için `Drop` özelliğini otomatik olarak türetilir. Bu, aşağıdaki kodu yazmakla eşdeğerdir:"

#: src/ch08-01-generic-data-types.md:168
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying "
"that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr "`Wallet` için `Drop` uygulamasının `derive` makrosunu kullanmaktan kaçınıyoruz ve bunun yerine kendi `WalletDrop` uygulamamızı tanımlıyoruz. Fonksiyonlar gibi, `WalletDrop` için ek bir genel tür tanımlamamız gerektiğini unutmayın, `T`'nin `Drop` özelliğini uyguladığını söyleyin. Esasında, `Wallet<T>` yapısının, `T` bırakılabilir olduğu sürece bırakılabilir olduğunu söylüyoruz."

#: src/ch08-01-generic-data-types.md:170
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr "Son olarak, `Wallet`'a, `T`'den farklı ancak aynı zamanda genel olan bir adres alanı eklemek istiyorsak, `<>` arasına başka bir genel tür ekleyebiliriz:"

#: src/ch08-01-generic-data-types.md:184
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr "`Wallet` yapı tanımına `U` adında yeni bir genel tür ekler ve bu türü yeni alan üyesi `address`'e atarız. `Drop` özelliğinin türetme özelliğinin `U` için de çalıştığına dikkat edin."

#: src/ch08-01-generic-data-types.md:188
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr "Yapılarla yaptığımız gibi, enumları da varyantlarında genel veri türlerini tutacak şekilde tanımlayabiliriz. Örneğin, Cairo çekirdek kütüphanesi tarafından sağlanan `Option<T>` enumu:"

#: src/ch08-01-generic-data-types.md:197
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr "`Option<T>` enumu, `T` türü üzerinden genelleştirilmiştir ve iki varyanta sahiptir: `Some`, `T` türünde bir değer tutar ve `None` herhangi bir değer tutmaz. `Option<T>` enumunu kullanarak, bir değerin isteğe bağlı kavramını soyut bir şekilde ifade edebiliriz ve çünkü değer genel bir `T` türündedir, bu soyutlamayı her türle kullanabiliriz."

#: src/ch08-01-generic-data-types.md:199
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr "Enumlar birden fazla genel türü de kullanabilir, çekirdek kütüphanenin sağladığı `Result<T, E>` enumunun tanımı gibi:"

#: src/ch08-01-generic-data-types.md:208 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr "`Result<T, E>` enumu iki genel tür, `T` ve `E` içerir ve iki varyanta sahiptir: `Ok`, `T` türünde bir değer tutar ve `Err`, `E` türünde bir değer tutar. Bu tanım, bir işlemin başarılı olabileceği (bir `T` türünde değer döndürerek) veya başarısız olabileceği (bir `E` türünde değer döndürerek) herhangi bir yerde `Result` enumunu kullanmayı uygun hale getirir."

#: src/ch08-01-generic-data-types.md:210
msgid "Generic Methods"
msgstr "Genel Metodlar"

#: src/ch08-01-generic-data-types.md:212
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr "Yapılar ve enumlar üzerinde metodlar uygulayabilir ve tanımlarında genel türleri de kullanabiliriz. Önceki `Wallet<T>` yapısının tanımını kullanarak, onun için bir `balance` metodu tanımlayalım:"

#: src/ch08-01-generic-data-types.md:236
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr "Önce, `T` genel türü kullanan `WalletTrait<T>` traitini tanımlarız. Bu, `Wallet`'dan `balance` alanının bir anlık görüntüsünü döndüren bir metod tanımlar. Daha sonra `WalletImpl<T>`'de trait için bir uygulama veririz. Trait ve uygulamanın her ikisinin tanımlarında da genel bir türü dahil etmeniz gerektiğini unutmayın."

#: src/ch08-01-generic-data-types.md:238
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr "Tür üzerinde metotlar tanımlarken genel türler için kısıtlamalar da belirtebiliriz. Örneğin, `Wallet<T>` yerine yalnızca `Wallet<u128>` örnekleri için metotlar uygulayabiliriz. Kod örneğinde, `balance` alanının somut türü `u128` olan cüzdanlar için bir uygulama tanımlıyoruz."


#: src/ch08-01-generic-data-types.md:245
msgid "/// Generic trait for wallets\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:256
msgid "/// Trait for wallets of type u128\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:277
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a "
"mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr "Yeni `receive` metodu, bir `Wallet<u128>` örneğinin bakiye boyutunu artırır. `w`'yi mutable bir değişken yaparak `main` fonksiyonunu değiştirdiğimize dikkat edin, böylece bakiyesini güncelleyebilir. `w`'nin başlatılmasını `balance` türünü değiştirerek değiştirirsek, önceki kod derlenmez."

#: src/ch08-01-generic-data-types.md:279
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one "
"with a generic type of each. First, let's rewrite the struct definition:"
msgstr "Cairo, genel traitler içinde genel metotlar tanımlamamıza da olanak tanır. `Wallet<U, V>`'den geçmiş uygulamayı kullanarak, farklı genel türlerdeki iki cüzdanı alıp her birinin genel türüyle yeni bir tane oluşturan bir trait tanımlayacağız. İlk olarak, yapı tanımını yeniden yazalım:"

#: src/ch08-01-generic-data-types.md:288
msgid "Next we are going to naively define the mixup trait and implementation:"
msgstr "Şimdi karışım traitini ve uygulamasını naifçe tanımlayacağız:"

#: src/ch08-01-generic-data-types.md:291
msgid "// This does not compile!\n"
msgstr ""

#: src/ch08-01-generic-data-types.md:304
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr "`WalletMixTrait<T1, U1>` traiti ile `mixup<T2, U2>` metodlarını oluşturuyoruz ki bu, `Wallet<T1, U1>` ve `Wallet<T2, U2>` örnekleri verildiğinde yeni bir `Wallet<T1, U2>` oluşturur. `mixup` imzası belirtildiği gibi, hem `self` hem de `other` fonksiyonun sonunda bırakılıyor, bu kodun derlenmemesinin nedenidir. Başından beri takip ediyorsanız, derleyicinin `Wallet<T, U>` örneklerini nasıl bırakacağını bilmek için tüm genel türler için `Drop` traitini uygulayacaklarına dair bir gereksinim eklememiz gerektiğini biliyor olmalısınız. Güncellenmiş uygulama şu şekildedir:"

#: src/ch08-01-generic-data-types.md:322
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` "
"declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr "`WalletMixImpl` deklarasyonunda `T1` ve `U1`'in bırakılabilir olması gerektiği gereksinimlerini ekliyoruz. Sonra aynısını `T2` ve `U2` için yapıyoruz, bu sefer `mixup` imzasının bir parçası olarak. Artık `mixup` fonksiyonunu deneyebiliriz:"

#: src/ch08-01-generic-data-types.md:336
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr "İlk olarak, biri `Wallet<bool, u128>` ve diğeri `Wallet<felt252, u8>` olmak üzere iki örnek oluşturuyoruz. Sonra, `mixup`'ı çağırıp yeni bir `Wallet<bool, u8>` örneği oluşturuyoruz."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr "Bir trait, bir tip tarafından uygulanabilecek bir metodlar kümesini tanımlar. Bu trait uygulandığında, bu metodlar tipin örnekleri üzerinde çağrılabilir. Bir trait bir genel tiple birleştiğinde, belirli bir tipin sahip olduğu ve diğer tiplerle paylaşabileceği işlevselliği tanımlar. Traitleri, soyut bir şekilde paylaşılan davranışı tanımlamak için kullanabiliriz. Genel bir türün yalnızca belirli bir davranışa sahip olan herhangi bir tür olabileceğini belirtmek için _trait sınırları_ kullanabiliriz."

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr "Not: Traitler, diğer dillerde genellikle arayüzler olarak adlandırılan bir özelliğe benzer, ancak bazı farklılıklarla."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in "
"this chapter to demonstrate how traits can be used to define shared behavior "
"for generic types."
msgstr "Traitler genel türler kabul etmeyecek şekilde yazılabilirken, genel türlerle kullanıldıklarında en faydalı olurlar. Genel türleri [önceki bölümde](./ch08-01-generic-data-types.md) zaten ele aldık ve bu bölümde, genel türler için paylaşılan davranışı tanımlamak üzere traitlerin nasıl kullanılabileceğini göstermek için onları kullanacağız."

#: src/ch08-02-traits-in-cairo.md:11
msgid "Defining a Trait"
msgstr "Bir Trait Tanımlama"

#: src/ch08-02-traits-in-cairo.md:13
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr "Bir tipin davranışı, o tipe çağrılabilen metodlardan oluşur. Farklı tipler, tüm bu tipler üzerinde aynı metodları çağırabildiğimizde aynı davranışı paylaşır. Trait tanımları, belirli bir amaç gerçekleştirmek için gerekli olan bir dizi davranışı tanımlamak için metod imzalarını bir araya toplama yoludur."

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr "Örneğin, belirli bir konumdaki bir haber hikayesini tutan `NewsArticle` adında bir yapıya sahip olduğumuzu söyleyelim. `NewsArticle` türünü özetleyebilecek bir davranışı tanımlayan `Summary` adında bir trait tanımlayabiliriz."

#: src/ch08-02-traits-in-cairo.md:32
msgid "\"{:?} by {:?} ({:?})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the trait keyword and then the trait’s name, "
"which is `Summary` in this case."
msgstr "Burada, trait anahtar kelimesi kullanılarak bir trait bildirilir ve ardından trait'in adı, bu durumda `Summary` gelir."

#: src/ch08-02-traits-in-cairo.md:45
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray`. After the method signature, "
"instead of providing an implementation within curly brackets, we use a "
"semicolon."
msgstr "Süslü parantezlerin içinde, bu trait'i uygulayan tiplerin davranışlarını tanımlayan metod imzalarını bildiririz, bu durumda `fn summarize(self: @NewsArticle) -> ByteArray`'dır. Metod imzasından sonra, süslü parantezler içinde bir uygulama sağlamak yerine bir noktalı virgül kullanırız."

#: src/ch08-02-traits-in-cairo.md:47
msgid ""
"Note: the `ByteArray` type is the type used to represent Strings in Cairo."
msgstr "Not:`ByteArray` tipi, Cairo'da String'leri temsil etmek için kullanılan tiptir."

#: src/ch08-02-traits-in-cairo.md:49
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr "Trait genel olmadığı için, `self` parametresi de genel değildir ve `@NewsArticle` tipindedir. Bu, `summarize` metodunun yalnızca `NewsArticle` örnekleri üzerinde çağrılabilir olduğu anlamına gelir."


#: src/ch08-02-traits-in-cairo.md:51
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"`aggregator` that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance. By defining the `Summary` trait on generic type `T`, we can "
"implement the `summarize` method on any type we want to be able to summarize."
msgstr "Şimdi, `NewsArticle` veya `Tweet` örneğinde saklanabilecek verilerin özetlerini gösterebilecek bir medya toplayıcı kütüphane kutusu olan `aggregator` oluşturmak istediğimizi düşünelim. Bunu yapmak için her türden bir özet gerekiyor ve bu özeti bir örnekte summarize metodunu çağırarak isteyeceğiz. `Summary` trait'ini genel tür `T` üzerinde tanımlayarak, özetlemek istediğimiz herhangi bir tür üzerinde `summarize` metodunu uygulayabiliriz."

#: src/ch08-02-traits-in-cairo.md:70 src/ch08-02-traits-in-cairo.md:146
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:85 src/ch08-02-traits-in-cairo.md:161
#: src/ch08-02-traits-in-cairo.md:237
msgid "\"{}: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:95 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:96 src/ch08-02-traits-in-cairo.md:172
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:100 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:101 src/ch08-02-traits-in-cairo.md:177
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n @Starknet and "
"@StarkWareLtd are about long-term vision maximization.\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:180
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:106 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:107 src/ch08-02-traits-in-cairo.md:183
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"1 new tweet: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"A `Summary` trait that consists of the behavior provided by a `summarize` "
"method"
msgstr "`summarize` metodunu sağlayan davranışlardan oluşan bir `Summary` trait'i"


#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"Each generic type implementing this trait must provide its own custom "
"behavior for the body of the method. The compiler will enforce that any type "
"that has the Summary trait will have the method summarize defined with this "
"signature exactly."
msgstr "Bu trait'i uygulayan her genel tür, metodun gövdesi için kendi özel davranışını sağlamalıdır. Derleyici, Summary trait'ine sahip her türün bu imzaya tam olarak sahip summarize metodunu tanımladığını zorlayacaktır."

#: src/ch08-02-traits-in-cairo.md:117
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr "Bir tip üzerine bir trait uygulamak"

#: src/ch08-02-traits-in-cairo.md:119
msgid "Implementing a Trait on a type"
msgstr "Bir tip üzerine bir trait uygulamak"

#: src/ch08-02-traits-in-cairo.md:121
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The next "
"code snippet shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to "
"create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr "`Summary` trait'inin metodlarının istenen imzalarını tanımladığımıza göre, medya toplayıcımızdaki tipler üzerinde bunu uygulayabiliriz. Sonraki kod parçacığı, `summarize`'ın dönüş değerini oluşturmak için başlığı, yazarı ve konumu kullanan `NewsArticle` yapısı üzerinde `Summary` trait'inin bir uygulamasını gösterir. `Tweet` yapısı için, `summarize`'ı, tweetin tam metnini takip eden kullanıcı adı olarak tanımlarız, tweet içeriğinin zaten 280 karakterle sınırlı olduğunu varsayarız."

#: src/ch08-02-traits-in-cairo.md:189
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type, "
"we place the generic type name in the angle brackets after the trait name."
msgstr "Bir tip üzerinde bir trait uygulamak, normal metotları uygulamaya benzer. Fark, `impl`'den sonra uygulamanın adını koyduktan sonra `of` anahtar kelimesini kullanmamız ve uygulama yazdığımız trait'in adını belirtmemizdir. Uygulama genel bir tip içinse, trait adının ardından açı parantezleri içinde genel tip adını yerleştiririz."

#: src/ch08-02-traits-in-cairo.md:194
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior "
"that we want the methods of the trait to have for the particular type."
msgstr "`impl` bloğu içinde, trait tanımının belirlediği metod imzalarını koyarız. Her imzanın ardından bir noktalı virgül yerine süslü parantezler kullanırız ve metod gövdesini o belirli tip için trait metodlarının sahip olmasını istediğimiz özel davranışla doldururuz."

#: src/ch08-02-traits-in-cairo.md:199
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr "Kütüphane `Summary` trait'ini `NewsArticle` ve `Tweet` üzerinde uyguladığından, kutuyu kullananlar, `NewsArticle` ve `Tweet` örnekleri üzerinde trait metodlarını normal metodları çağırdığımız gibi çağırabilir. Tek fark, kullanıcının hem trait'i hem de tipleri kapsama alması gerektiğidir. İşte bir kutunun `aggregator` kutumuzu nasıl kullanabileceğine dair bir örnek:"

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr "Bu kod şunu yazdırır:"

#: src/ch08-02-traits-in-cairo.md:274
msgid ""
"Other crates that depend on the `aggregator` crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr "`aggregator` kutusuna bağlı diğer kutular da `Summary` trait'ini kapsama alanına alarak kendi tiplerinde `Summary`'i uygulayabilir."

#: src/ch08-02-traits-in-cairo.md:304
msgid "Implementing a trait, without writing its declaration."
msgstr "Bir trait'i, onun bildirimini yazmadan uygulama."

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"You can write implementations directly without defining the corresponding "
"trait. This is made possible by using the `#[generate_trait]` attribute "
"within the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` "
"as a suffix to your trait name, as the compiler will create the trait by "
"adding a `Trait` suffix to the implementation name."
msgstr "İlgili trait'i tanımlamadan doğrudan uygulamalar yazabilirsiniz. Bu, uygulama içinde `#[generate_trait]` özniteliğini kullanarak mümkün olur, bu da derleyicinin uygulamaya karşılık gelen trait'i otomatik olarak oluşturmasını sağlar. Trait adınıza `Trait` soneki eklemeyi unutmayın, çünkü derleyici uygulama adına `Trait` sonekini ekleyerek trait'i oluşturacaktır."

#: src/ch08-02-traits-in-cairo.md:325
msgid ""
"In the aforementioned code, there is no need to manually define the trait. "
"The compiler will automatically handle its definition, dynamically "
"generating and updating it as new functions are introduced."
msgstr "Yukarıda bahsedilen kodda, trait'i manuel olarak tanımlamaya gerek yoktur. Derleyici, tanımını otomatik olarak yönetir, yeni fonksiyonlar tanıtıldıkça dinamik olarak oluşturur ve günceller."

#: src/ch08-02-traits-in-cairo.md:329
msgid "Managing and using external trait implementations"
msgstr "Dış trait uygulamalarını yönetme ve kullanma"

#: src/ch08-02-traits-in-cairo.md:331
msgid ""
"To use traits methods, you need to make sure the correct traits/"
"implementation(s) are imported. In the code above we imported `PrintTrait` "
"from `debug` with `use core::debug::PrintTrait;` to use the `print()` "
"methods on supported types. All traits included in the prelude don't need to "
"be explicitly imported and are freely accessible."
msgstr "Trait metotlarını kullanmak için, doğru trait/uygulama(lar)ın içe aktarıldığından emin olmanız gerekir. Yukarıdaki kodda `print()` metodlarını desteklenen tiplerde kullanabilmek için `use core::debug::PrintTrait;` ile `debug`'dan `PrintTrait`'i içe aktardık. Prelude'da yer alan tüm trait'ler açıkça içe aktarılmaya gerek duymaz ve serbestçe erişilebilir."

#: src/ch08-02-traits-in-cairo.md:333
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules. If `CircleGeometry` "
"was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`."
msgstr "Bazı durumlarda, sadece trait'i değil, ayrı modüllerde bildirilmişlerse uygulamayı da içe aktarmanız gerekebilir. `CircleGeometry` ayrı bir modül/dosya `circle` içindeyse, `circ: Circle` üzerinde `boundary` kullanmak için `ShapeGeometry`'in yanı sıra `CircleGeometry`'i de içe aktarmanız gerekir."

#: src/ch08-02-traits-in-cairo.md:336
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant implementation is required."
msgstr "Kod bu şekilde modüllere ayrılmışsa, yani bir trait'in uygulaması trait'in kendisiyle farklı bir modülde tanımlanmışsa, ilgili uygulamanın açıkça içe aktarılması gerekir."

#: src/ch08-02-traits-in-cairo.md:340
msgid "// struct Circle { ... } and struct Rectangle { ... }\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:353
msgid "// Could be in a different file\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:366
msgid ""
"// Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and "
"impl?\n"
msgstr ""

#: src/ch08-02-traits-in-cairo.md:373
msgid "To make it work, in addition to,"
msgstr "Bunu düzeltmek için, ek olarak,"

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not "
"need to import `RectangleGeometry`, as it is defined in the same module as "
"the imported trait, and thus is automatically resolved."
msgstr "`CircleGeometry`'i açıkça içe aktarmanız gerekir. `RectangleGeometry`'i içe aktarmaya gerek yoktur, çünkü imported trait ile aynı modülde tanımlandığı için otomatik olarak çözülür."

#: src/ch09-01-how-to-write-tests.md:3 src/ch09-01-how-to-write-tests.md:13
msgid "The Anatomy of a Test Function"
msgstr "Bir Test Fonksiyonunun Anatomisi"

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr "Testler, test dışı kodun beklenen şekilde işlev gördüğünü doğrulayan Cairo fonksiyonlarıdır. Test fonksiyonlarının gövdeleri tipik olarak bu üç eylemi gerçekleştirir:"

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "Gerekli herhangi bir veriyi veya durumu kurun."

#: src/ch09-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "Test etmek istediğiniz kodu çalıştırın."

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "Sonuçların beklediğiniz gibi olduğunu doğrulayın."

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert!` "
"macro, and the `should_panic` attribute."
msgstr "Bu eylemleri gerçekleştirmek için Cairo'nun özellikle test yazmak için sağladığı özelliklere, `test` özelliğine, `assert!` makrosuna ve `should_panic` özelliğine bakalım."

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 5. To change "
"a function into a test function, add `#[test]` on the line before `fn`. When "
"you run your tests with the `scarb cairo-test` command, Scarb runs Cairo's "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr "En basit haliyle, Cairo'da bir test, `test` özelliği ile etiketlenmiş bir fonksiyondur. Öznitelikler, Cairo kod parçaları hakkında meta verilerdir; bir örnek, Bölüm 5'te yapılarla kullandığımız derive özelliğidir. Bir fonksiyonu test fonksiyonuna dönüştürmek için, `fn` satırından önce `#[test]` ekleyin. Testlerinizi `scarb cairo-test` komutuyla çalıştırdığınızda, Scarb, Cairo'nun test koşucu ikilisini çalıştırır, bu da etiketlenmiş fonksiyonları çalıştırır ve her test fonksiyonunun geçip geçmediği üzerine rapor verir."

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr "`adder` adında iki sayıyı ekleyecek yeni bir proje oluşturalım ve `scarb new adder` komutuyla Scarb kullanalım:"

#: src/ch09-01-how-to-write-tests.md:26
msgid ""
"In _lib.cairo_, let's remove the existing content and add a first test, as "
"shown in Listing 9-1."
msgstr "_lib.cairo_'da, mevcut içeriği kaldıralım ve Listeleme 9-1'de gösterildiği gibi ilk testi ekleyelim."

#: src/ch09-01-how-to-write-tests.md:34 src/ch09-01-how-to-write-tests.md:68
#: src/ch09-01-how-to-write-tests.md:630 src/ch09-01-how-to-write-tests.md:668
#: src/ch09-02-test-organization.md:25
msgid "\"result is not 4\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:38
msgid "Listing 9-1: A test module and function"
msgstr "Listeleme 9-1: Bir test modülü ve fonksiyonu"

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are "
"tests."
msgstr "Şimdilik, ilk iki satırı göz ardı edelim ve fonksiyona odaklanalım. `#[test]` notasyonuna dikkat edin: bu öznitelik, bu fonksiyonun bir test fonksiyonu olduğunu belirtir, böylece test koşucusu bu fonksiyonu bir test olarak işlemesi gerektiğini bilir. Test modülünde, yaygın senaryoları kurmak veya yaygın işlemleri gerçekleştirmek için yardımcı olacak test olmayan fonksiyonlar da bulunabilir, bu yüzden hangi fonksiyonların test olduğunu her zaman belirtmemiz gerekir."

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr "Örnek fonksiyon gövdesi, 2 ile 2'nin toplamının 4'e eşit olduğunu içeren `assert!` makrosunu kullanır. Bu doğrulama, tipik bir testin formatı için bir örnek olarak hizmet eder. Bunu çalıştırıp bu testin geçtiğini görelim."

#: src/ch09-01-how-to-write-tests.md:44
msgid ""
"The `scarb cairo-test` command runs all tests founds in our project, as "
"shown in Listing 9-2."
msgstr "`scarb cairo-test` komutu, projemizde bulunan tüm testleri çalıştırır, Listeleme 9-2'de gösterildiği gibi."

#: src/ch09-01-how-to-write-tests.md:54
msgid "Listing 9-2: The output from running a test"
msgstr "Listeleme 9-2: Bir testi çalıştırmanın çıktısı"

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"tests`. The next line shows the name of the test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr "`scarb cairo-test`, testi derleyip çalıştırdı. `1 tests running` satırını görüyoruz. Sonraki satır test fonksiyonunun adını, yani `it_works`'u ve bu testin çalıştırılmasının sonucunun `ok` olduğunu gösteriyor. Genel özet `test sonucu: ok.` tüm testlerin geçtiğini ve `1 passed; 0 failed` kısmı geçen veya başarısız olan testlerin sayısını toplar."

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later "
"in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. We also haven’t filtered the tests being run, so the end of the "
"summary shows `0 filtered out`."
msgstr "Bir testin belirli bir durumda çalışmaması için görmezden gelinerek işaretlenebilir; bunu bu bölümün sonraki kısımlarında [Bazı Testleri Özellikle İstenmedikçe Görmezden Gelme](#ignoring-some-tests-unless-specifically-requested) bölümünde ele alacağız. Burada bunu yapmadığımız için, özet `0 ignored` gösteriyor. `scarb cairo-test` komutuna bir argüman geçirerek sadece isminde bir dizeyle eşleşen bir testi çalıştırabiliriz; buna filtreleme denir ve bunu [Tek Testleri Çalıştırma](#running-single-tests) bölümünde ele alacağız. Çalıştırılan testleri filtrelemedik, bu yüzden özetin sonu `0 filtered out` gösteriyor."

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of "
"the `it_works` function to a different name, such as `exploration`, like so:"
msgstr "Şimdi testi kendi ihtiyaçlarımıza göre özelleştirmeye başlayalım. İlk olarak, `it_works` fonksiyonunun adını, örneğin `exploration` gibi farklı bir isme değiştirin, şöyle:"

#: src/ch09-01-how-to-write-tests.md:72
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr "Sonra `scarb cairo-test`'i tekrar çalıştırın. Çıktı şimdi `it_works` yerine `exploration` gösteriyor:"

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr "Şimdi başka bir test ekleyelim, ama bu sefer başarısız olacak bir test yapalım! Test fonksiyonları içindeki bir şey paniklediğinde testler başarısız olur. Her test yeni bir thread'de çalıştırılır ve ana thread bir test thread'inin öldüğünü gördüğünde, test başarısız olarak işaretlenir. Yeni testi `another` adında bir fonksiyon olarak girin, böylece _src/lib.cairo_ dosyanız Listeleme 9-3 gibi görünsün."

#: src/ch09-01-how-to-write-tests.md:87
msgid "\"Make this test fail\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:92
msgid "Listing 9-3: Adding a second test that will fail"
msgstr "Listeleme 9-3: Başarısız olacak ikinci bir testin eklenmesi"

#: src/ch09-01-how-to-write-tests.md:104
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr "Listeleme 9-4: Bir testin geçtiği ve bir testin başarısız olduğu durumda test sonuçları"

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` "
"in the _src/lib.cairo_ file."
msgstr "`ok` yerine, `adder::lib::tests::another` satırı `fail` gösteriyor. Bireysel sonuçlarla özet arasında yeni bir bölüm beliriyor. Her test başarısızlığının detaylı nedenini gösteriyor. Bu durumda, `another`'ın _src/lib.cairo_ dosyasında `Make this test fail` ile paniklediği için başarısız olduğu detaylarını alıyoruz."

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr "Sonuç satırı sonunda şunu gösterir: genel olarak, test sonucumuz `FAILED`. Bir test geçti ve bir test başarısız oldu."

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some functions that are useful in tests."
msgstr "Şimdi farklı senaryolarda test sonuçlarının nasıl göründüğünü gördüğünüze göre, testlerde kullanışlı bazı fonksiyonlara bakalım."

#: src/ch09-01-how-to-write-tests.md:112
msgid "Checking Results with the `assert!` macro"
msgstr "`assert!` makrosu ile Sonuçları Kontrol Etme"

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro a first argument that evaluates to a Boolean. If the value is `true`, "
"nothing happens and the test passes. If the value is `false`, the `assert!` "
"macro calls `panic()` to cause the test to fail with a message we defined as "
"the second argument. Using the `assert!` macro helps us check that our code "
"is functioning in the way we intend."
msgstr "Cairo tarafından sağlanan `assert!` makrosu, bir testteki bazı koşulların `true` olarak değerlendirilmesini sağlamak istediğinizde kullanışlıdır. `assert!` makrosuna birinci argüman olarak bir Boolean değerlendiren bir ifade veririz. Değer `true` ise, hiçbir şey olmaz ve test geçer. Değer `false` ise, `assert!` makrosu `panic()` çağırarak testin tanımladığımız bir mesajla başarısız olmasına neden olur. `assert!` makrosunu kullanmak, kodumuzun niyet ettiğimiz şekilde işlev gösterdiğini kontrol etmemize yardımcı olur."

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-13](ch05-03-method-syntax.md#multiple-impl-blocks), "
"we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert!` macro."
msgstr "[Bölüm 5, Listeleme 5-13](ch05-03-method-syntax.md#multiple-impl-blocks)’te kullandığımız `Rectangle` yapısını ve `can_hold` metodunu burada tekrar kullanıyoruz. Bu kodu _src/lib.cairo_ dosyasına koyalım, sonra `assert!` makrosunu kullanarak bazı testler yazalım."

#: src/ch09-01-how-to-write-tests.md:137
msgid ""
"Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from "
"Chapter 5"
msgstr "Listeleme 9-5: Bölüm 5'ten `Rectangle` yapısının ve `can_hold` metodunun kullanılması"

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. In Listing 9-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8` "
"and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr "`can_hold` metodu bir `bool` döndürür, bu da onun `assert!` makrosu için mükemmel bir kullanım durumu olduğu anlamına gelir. Listeleme 9-6'da, `can_hold` metodunu çalıştıran bir test yazıyoruz. `8` genişliğinde ve `7` yüksekliğinde bir `Rectangle` örneği oluşturup `5` genişliğinde ve `1` yüksekliğinde başka bir `Rectangle` örneğini tutabileceğini doğrulayarak."

#: src/ch09-01-how-to-write-tests.md:176 src/ch09-01-how-to-write-tests.md:184
#: src/ch09-01-how-to-write-tests.md:241 src/ch09-01-how-to-write-tests.md:249
msgid "\"rectangle cannot hold\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:191
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle "
"can indeed hold a smaller rectangle"
msgstr "Listeleme 9-6: Daha büyük bir dikdörtgenin gerçekten daha küçük bir dikdörtgeni tutup tutamayacağını kontrol eden `can_hold` için bir test"

#: src/ch09-01-how-to-write-tests.md:193
msgid ""
"Note that we’ve added two new lines inside the tests module: `use super::"
"Rectangle;` and `use super::RectangleTrait;`. The tests module is a regular "
"module that follows the usual visibility rules. Because the tests module is "
"an inner module, we need to bring the code under test in the outer module "
"into the scope of the inner module."
msgstr "Testler modülü içinde `use super::Rectangle;` ve `use super::RectangleTrait;` olmak üzere iki yeni satır ekledik. Testler modülü, normal görünürlük kurallarını takip eden düzenli bir modüldür. Testler modülü bir iç modül olduğu için, dış modüldeki test altındaki kodu iç modülün kapsamına getirmemiz gerekiyor."

#: src/ch09-01-how-to-write-tests.md:195
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr "Testimizi `larger_can_hold_smaller` olarak adlandırdık ve ihtiyacımız olan iki `Rectangle` örneğini oluşturduk. Sonra `assert!` makrosunu çağırdık ve ona `larger.can_hold(@smaller)` çağrısının sonucunu geçtik. Bu ifade `true` döndürmesi beklenir, bu yüzden testimiz geçmelidir. Hadi öğrenelim!"

#: src/ch09-01-how-to-write-tests.md:204
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr "Geçiyor! Şimdi, bu sefer daha küçük bir dikdörtgenin daha büyük bir dikdörtgeni tutamayacağını belirten başka bir test ekleyelim:"

#: src/ch09-01-how-to-write-tests.md:256
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns false:"
msgstr "`can_hold` fonksiyonunun bu durumda doğru sonucu `false` olduğu için, sonucu `assert!` makrosuna geçmeden önce bu sonucu tersine çevirmemiz gerekiyor. Sonuç olarak, testimiz `can_hold` `false` döndürdüğünde geçer:"

#: src/ch09-01-how-to-write-tests.md:266
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr "İki geçen test! Şimdi kodumuzda bir hata tanıttığımızda test sonuçlarımıza ne olacağını görelim. `can_hold` metodunun uygulanmasını değiştirerek genişlikleri karşılaştırırken büyük işaretini küçük işaretiyle değiştirelim:"

#: src/ch09-01-how-to-write-tests.md:280
msgid "Running the tests now produces the following:"
msgstr "Testleri şimdi çalıştırmak aşağıdakileri üretir:"

#: src/ch09-01-how-to-write-tests.md:293
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr "Testlerimiz hatayı yakaladı! `larger.width` `8` ve `smaller.width` `5` olduğu için, `can_hold` içindeki genişliklerin karşılaştırması artık `false` dönüyor: `8` `5`'ten küçük değildir."

#: src/ch09-01-how-to-write-tests.md:295
msgid "Testing Equality with the `assert_eq!` and `assert_ne!` Macros"
msgstr "`assert_eq!` ve `assert_ne!` Makroları ile Eşitliği Test Etme"

#: src/ch09-01-how-to-write-tests.md:297
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to "
"perform this test more conveniently. These macros compare two arguments for "
"equality or inequality, respectively. They’ll also print the two values if "
"the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr "Fonksiyonelliği doğrulamanın yaygın bir yolu, test altındaki kodun sonucu ile kodun döndürmesi beklenen değer arasında eşitlik testidir. Bunu `assert!` makrosunu kullanarak ve `==` operatörünü kullanan bir ifadeyi geçirerek yapabilirsiniz. Ancak, bu kadar yaygın bir test olduğu için, standart kütüphane bu testi daha uygun bir şekilde yapmak için `assert_eq!` ve `assert_ne!` olmak üzere bir çift makro sağlar. Bu makrolar, sırasıyla, iki argümanı eşitlik veya eşitsizlik için karşılaştırır. Ayrıca, doğrulama başarısız olduğunda iki değeri de yazdırırlar, bu da testin neden başarısız olduğunu görmeyi kolaylaştırır; tersine, `assert!` makrosu, `==` ifadesi için `false` bir değer aldığını belirtirken, `false` değerine yol açan değerleri yazdırmaz."

#: src/ch09-01-how-to-write-tests.md:308
msgid ""
"In Listing 9-7, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using the `assert_eq!` macro."
msgstr "Listeleme 9-7'de, parametresine `2` ekleyen `add_two` adında bir fonksiyon yazıyoruz, sonra bu fonksiyonu `assert_eq!` makrosunu kullanarak test ediyoruz."

#: src/ch09-01-how-to-write-tests.md:329
msgid ""
"Listing 9-7: Testing the function `add_two` using the `assert_eq!` macro"
msgstr "Listeleme 9-7: `add_two` fonksiyonunu `assert_eq!` makrosu kullanarak test etme"

#: src/ch09-01-how-to-write-tests.md:332
msgid "Let’s check that it passes!"
msgstr "Geçtiğini kontrol edelim!"

#: src/ch09-01-how-to-write-tests.md:341
msgid ""
"We pass `4` as the argument to `assert_eq!`, which is equal to the result of "
"calling `add_two(2)`. The line for this test is `test tests::it_adds_two ... "
"ok`, and the `ok` text indicates that our test passed!"
msgstr "`assert_eq!`'e argüman olarak `4` geçiriyoruz, bu `add_two(2)` çağrısının sonucuna eşittir. Bu testin satırı `test tests::it_adds_two ... ok` ve `ok` metni testimizin geçtiğini gösterir."

#: src/ch09-01-how-to-write-tests.md:345
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr "Kodumuza bir hata sokarak `assert_eq!`'in başarısız olduğunda nasıl göründüğünü görelim. `add_two` fonksiyonunun uygulamasını `2` yerine `3` ekleyecek şekilde değiştirin:"

#: src/ch09-01-how-to-write-tests.md:354
msgid "Run the tests again:"
msgstr "Testleri tekrar çalıştırın:"

#: src/ch09-01-how-to-write-tests.md:356
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 359600)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:368
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells "
"use that the assertion that fails was `` \"assertion `left == right` "
"failed`` and the `left` and `right` value are printed on the next lines as "
"`left: left_value` and `right: right_value`. This helps us start debugging: "
"the `left` argument was `4` but the `right` argument, where we had "
"`add_two(2)`, was `5`. You can imagine that this would be especially helpful "
"when we have a lot of tests going on."
msgstr "Testimiz hatayı yakaladı! `it_adds_two` testi şu mesajla başarısız oldu: ``\"assertion `4 == add_two(2)` failed``. Bize başarısız olan doğrulamanın ``\"assertion `left == right` failed`` olduğunu ve `left` ve `right` değerlerinin sırasıyla `left: left_value` ve `right: right_value` olarak sonraki satırlarda yazdırıldığını söyler. Bu, hata ayıklamaya başlamamıza yardımcı olur: `left` argümanı `4` fakat `add_two(2)` yerine kullanılan `right` argümanı `5` idi. Bir sürü testimiz olduğunda bunun özellikle yararlı olduğunu hayal edebilirsiniz."

#: src/ch09-01-how-to-write-tests.md:375
msgid ""
"Note that in some languages and test frameworks, the parameters to equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(add_two(2), 4)`, which would result in the same "
"failure message that displays `` assertion failed: `(left == right)` ``."
msgstr "Bazı dillerde ve test çerçevelerinde, eşitlik doğrulama fonksiyonlarına `expected` ve `actual` denir ve argümanların sırası önemlidir. Ancak, Cairo'da, bunlara `left` ve `right` denir ve beklenen değeri ve kodun ürettiği değeri belirttiğimiz sıra önemli değildir. Bu testteki doğrulamayı `assert_eq!(add_two(2), 4)` olarak yazabilirdik, bu da ``assertion failed: `(left == right)` `` hatasıyla aynı başarısızlık mesajını üretirdi."

#: src/ch09-01-how-to-write-tests.md:383
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but the way in which the input is changed "
"depends on the day of the week that we run our tests, the best thing to "
"assert might be that the output of the function is not equal to the input."
msgstr "`assert_ne!` makrosu, verdiğimiz iki değer eşit olmadığında geçer ve eşit olduklarında başarısız olur. Bu makro, bir değerin _ne olacağından_ emin olmadığımız ama kesinlikle _ne olmaması gerektiğini_ bildiğimiz durumlar için en yararlıdır. Örneğin, bir fonksiyonun girdisini kesinlikle değiştireceğini garanti ettiğimiz ama girdinin nasıl değiştirildiğinin testlerimizi çalıştırdığımız haftanın gününe bağlı olduğu durumlar için, fonksiyonun çıktısının girdiye eşit _olmaması_ gerektiğini doğrulamak en iyi şey olabilir."

#: src/ch09-01-how-to-write-tests.md:391
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators `==` and `!=`, respectively. When the assertions fail, these "
"macros print their arguments using debug formatting, which means the values "
"being compared must implement the `PartialEq` and `Debug` traits. All "
"primitive types and most of the core library types implement these traits. "
"For structs and enums that you define yourself, you’ll need to implement "
"`PartialEq` to assert equality of those types. You’ll also need to implement "
"`Debug` to print the values when the assertion fails. Because both traits "
"are derivable traits this is usually as straightforward as adding the "
"`#[derive(Drop, Debug, PartialEq)]` annotation to your struct or enum "
"definition. See Appendix C, [“Derivable Traits”](./appendix-03-derivable-"
"traits.md), for more details about these and other derivable traits."
msgstr "`assert_eq!` ve `assert_ne!` makroları altında, sırasıyla `==` ve `!=` operatörlerini kullanır. Doğrulamalar başarısız olduğunda, bu makrolar argümanlarını hata ayıklama biçimlendirmesi kullanarak yazdırır, bu da karşılaştırılan değerlerin `PartialEq` ve `Debug` trait'lerini uygulaması gerektiği anlamına gelir. Tüm ilkel tipler ve çoğu çekirdek kütüphane tipi bu trait'leri uygular. Kendi tanımladığınız yapılar ve enumlar için, bu türlerin eşitliğini doğrulamak üzere `PartialEq`'i uygulamanız gerekir. Ayrıca, doğrulama başarısız olduğunda değerleri yazdırmak için `Debug`'ı da uygulamanız gerekir. Her iki trait de türetilebilir trait'ler olduğu için, bu genellikle yapınız veya enumunuzun tanımına `#[derive(Drop, Debug, PartialEq)]` notasyonunu eklemek kadar basittir. Bu ve diğer türetilebilir trait'ler hakkında daha fazla bilgi için Ek C'ye bakın, [“Türetilebilir Trait'ler”](./appendix-03-derivable-traits.md)."

#: src/ch09-01-how-to-write-tests.md:405
msgid "Adding Custom Failure Messages"
msgstr "Özel Başarısızlık Mesajları Ekleme"

#: src/ch09-01-how-to-write-tests.md:407
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in [Chapter 11 - Macros](./ch11-02-macros."
"md#format-macro) in the `format!` section), so you can pass a format string "
"that contains `{}` placeholders and values to go in those placeholders. "
"Custom messages are useful for documenting what an assertion means; when a "
"test fails, you’ll have a better idea of what the problem is with the code."
msgstr "`assert!`, `assert_eq!` ve `assert_ne!` makrolarına isteğe bağlı argümanlar olarak başarısızlık mesajıyla birlikte yazdırılacak özel bir mesaj da ekleyebilirsiniz. Gerekli argümanlardan sonra belirtilen herhangi bir argüman, `format!` makrosuna (Bölüm 11'de tartışılan [Bölüm 11 - Makrolar](./ch11-02-macros.md#format-macro) bölümünde) aktarılır, bu yüzden `{}` yer tutucuları içeren bir biçimlendirme dizesi ve bu yer tutuculara gidecek değerler geçirebilirsiniz. Özel mesajlar, bir doğrulamanın ne anlama geldiğini belgelemek için yararlıdır; bir test başarısız olduğunda, kodla ilgili sorunun ne olduğuna dair daha iyi bir fikriniz olur."

#: src/ch09-01-how-to-write-tests.md:415
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr "`add_two` fonksiyonundan aldığımız gerçek değerle doldurulan bir biçim dizesinden oluşan özel bir başarısızlık mesajı ekleyelim:"

#: src/ch09-01-how-to-write-tests.md:426
msgid "\"Expected {}, got add_two(2)={}\""
msgstr "\"Beklenen {}, add_two(2)={} aldık\""

#: src/ch09-01-how-to-write-tests.md:431
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr "Şimdi testi çalıştırdığımızda daha bilgilendirici bir hata mesajı alacağız:"

#: src/ch09-01-how-to-write-tests.md:433
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed: "
"Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:445
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr "Test çıktısında aldığımız gerçek değeri görebiliriz, bu da beklediğimiz yerine ne olduğunu anlamamıza yardımcı olur."

#: src/ch09-01-how-to-write-tests.md:448
msgid "Checking for panics with `should_panic`"
msgstr "`should_panic` ile Panikleri Kontrol Etme"

#: src/ch09-01-how-to-write-tests.md:450
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the Guess type "
"in Listing 9-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr "Dönüş değerlerini kontrol etmenin yanı sıra, kodumuzun beklediğimiz gibi hata koşullarını ele aldığından emin olmak da önemlidir. Örneğin, Listeleme 9-8'de yer alan Guess türünü düşünün. `Guess` kullanımı diğer kodların `Guess` örneklerinin yalnızca `1` ile `100` arasında değerler içereceği garantisi üzerine kuruludur. Bu aralık dışında bir değerle `Guess` örneği oluşturmayı denemenin panikle sonuçlanacağını garanti eden bir test yazabiliriz."

#: src/ch09-01-how-to-write-tests.md:452
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr "Bunu yapmak için test fonksiyonumuza `should_panic` özniteliğini ekliyoruz. Fonksiyon içindeki kod paniklediğinde test geçer; fonksiyon içindeki kod paniklemezse test başarısız olur."

#: src/ch09-01-how-to-write-tests.md:454
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr "Listeleme 9-8, `GuessTrait::new`'un hata koşullarının beklediğimiz zamanlarda gerçekleştiğini kontrol eden bir testi göstermektedir."

#: src/ch09-01-how-to-write-tests.md:471 src/ch09-01-how-to-write-tests.md:516
msgid "\"Guess must be >= 1 and <= 100\""
msgstr "\"Guess >= 1 ve <= 100 olmalıdır\""

#: src/ch09-01-how-to-write-tests.md:490
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr "Listeleme 9-8: Bir koşulun panikle sonuçlanacağını test etme"

#: src/ch09-01-how-to-write-tests.md:492
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr "`#[should_panic]` özniteliğini `#[test]` özniteliğinden sonra ve uygulandığı test fonksiyonundan önce yerleştiriyoruz. Bu testin geçtiği durumda sonucu inceleyelim:"

#: src/ch09-01-how-to-write-tests.md:501
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr "İyi görünüyor! Şimdi kodumuza bir hata sokarak yeni fonksiyonun değeri `100`'den büyükse panikleme koşulunu kaldıralım:"

#: src/ch09-01-how-to-write-tests.md:526
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr "Listeleme 9-8'deki testi çalıştırdığımızda başarısız olur:"

#: src/ch09-01-how-to-write-tests.md:537
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr "Bu durumda çok yardımcı bir mesaj almıyoruz, ancak test fonksiyonuna baktığımızda `#[should_panic]` ile notlandırıldığını görüyoruz. Aldığımız başarısızlık, test fonksiyonundaki kodun bir panikle sonuçlanmadığı anlamına gelir."

#: src/ch09-01-how-to-write-tests.md:539
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 9-9 where the new function "
"panics with different messages depending on whether the value is too small "
"or too large."
msgstr "`should_panic` kullanılan testler kesin olmayabilir. Bir `should_panic` testi, beklediğimiz nedenle değil de başka bir nedenle test paniklediğinde bile geçer. `should_panic` testlerini daha kesin hale getirmek için, `should_panic` özniteliğine isteğe bağlı bir expected parametresi ekleyebiliriz. Test donanımı, başarısızlık mesajının sağlanan metni içerdiğinden emin olur. Örneğin, `Guess` için Listeleme 9-9'da değiştirilmiş kodu düşünün, burada yeni fonksiyon değer çok küçük veya çok büyükse farklı mesajlarla panikler."

#: src/ch09-01-how-to-write-tests.md:558 src/ch09-01-how-to-write-tests.md:594
msgid "\"Guess must be >= 1\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:560 src/ch09-01-how-to-write-tests.md:573
#: src/ch09-01-how-to-write-tests.md:592
msgid "\"Guess must be <= 100\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:582
msgid ""
"Listing 9-9: Testing for a panic with a panic message containing the error "
"message string"
msgstr "Listeleme 9-9: Hata mesajı dizesini içeren bir panik ile test etme"

#: src/ch09-01-how-to-write-tests.md:584
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr "Bu test, `should_panic` özniteliğinin beklenen parametresine koyduğumuz değer `Guess::new` fonksiyonunun paniklediği mesajın bir dizi dizesi olduğu için geçer. Beklediğimiz tüm panik mesajını belirtmemiz gerekiyor."

#: src/ch09-01-how-to-write-tests.md:586
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr "Beklenen bir mesajla `should_panic` testinin başarısız olduğunda ne olduğunu görmek için, kodumuza tekrar bir hata sokarak `value < 1` ve `value > 100` bloklarının gövdelerini değiştirelim:"

#: src/ch09-01-how-to-write-tests.md:602
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "Bu sefer `should_panic` testini çalıştırdığımızda başarısız olacak:"

#: src/ch09-01-how-to-write-tests.md:614
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr "Başarısızlık mesajı, bu testin beklediğimiz gibi panikle sonuçlandığını, ancak panik mesajının beklenen dizeyi içermediğini gösterir. Bu durumda aldığımız panik mesajı `Guess >= 1 olmalıdır` idi. Şimdi hatamızın nerede olduğunu bulmaya başlayabiliriz!"

#: src/ch09-01-how-to-write-tests.md:616
msgid "Running Single Tests"
msgstr "Tek Testleri Çalıştırma"

#: src/ch09-01-how-to-write-tests.md:618
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb "
"cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr "Bazen, tam bir test paketini çalıştırmak uzun zaman alabilir. Belirli bir alandaki kod üzerinde çalışıyorsanız, yalnızca o kodla ilgili testleri çalıştırmak isteyebilirsiniz. Hangi testleri çalıştıracağınızı seçmek için, `scarb cairo-test` komutuna `-f` (\"filtre\" için) seçeneğini takip eden bir argüman olarak çalıştırmak istediğiniz testin adını verebilirsiniz."

#: src/ch09-01-how-to-write-tests.md:620
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 9-10, and choose which ones to run."
msgstr "Tek bir testi çalıştırma şeklini göstermek için, Listeleme 9-10'da gösterildiği gibi önce iki test fonksiyonu oluşturacağız ve hangilerini çalıştıracağımızı seçeceğiz."

#: src/ch09-01-how-to-write-tests.md:636
msgid "\"result is not 5\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:641
msgid "Listing 9-10: Two tests with two different names"
msgstr "Listeleme 9-10: İki farklı adı olan iki test"

#: src/ch09-01-how-to-write-tests.md:643
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr "`cairo-test`'e herhangi bir test fonksiyonunun adını `-f` bayrağı ile birlikte geçirerek yalnızca o testi çalıştırabiliriz:"

#: src/ch09-01-how-to-write-tests.md:652
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr "Yalnızca `add_two_and_two` adına sahip test çalıştı; diğer test bu adla eşleşmedi. Test çıktısı sonunda 1 filtrelenmiş olduğunu göstererek daha fazla çalıştırılmayan bir testimiz olduğunu bize bildiriyor."

#: src/ch09-01-how-to-write-tests.md:654
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr "Ayrıca bir test adının bir kısmını belirtebiliriz ve adında o değeri içeren herhangi bir test çalıştırılır."

#: src/ch09-01-how-to-write-tests.md:656
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "Belirli İstekler Dışında Bazı Testleri Yoksayma"

#: src/ch09-01-how-to-write-tests.md:658
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude "
"them, as shown here:"
msgstr "Bazen bazı özel testlerin çalıştırılması çok zaman alabilir, bu yüzden `scarb cairo-test`'in çoğu çalıştırmasında bunları dışlamak isteyebilirsiniz. Çalıştırmak istediğiniz tüm testleri argüman olarak listelemek yerine, aşağıda gösterildiği gibi zaman alan testleri `ignore` özniteliği ile notlandırarak dışlayabilirsiniz:"

#: src/ch09-01-how-to-write-tests.md:673
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:678
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr "`#[test]`'den sonra istediğimiz testi dışlamak için `#[ignore]` satırını ekliyoruz. Şimdi testlerimizi çalıştırdığımızda, `it_works` çalışır, ancak `expensive_test` çalışmaz:"

#: src/ch09-01-how-to-write-tests.md:688
msgid "The `expensive_test` function is listed as ignored."
msgstr "`expensive_test` fonksiyonu yoksayıldı olarak listelenmiştir."

#: src/ch09-01-how-to-write-tests.md:690
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr "Yoksayılan testlerin sonuçlarını kontrol etmenin ve sonuçları beklemek için zamanınız olduğunda, `scarb cairo-test --include-ignored` komutunu çalıştırarak ister yoksayılan ister yoksayılmayan tüm testleri çalıştırabilirsiniz."

#: src/ch09-01-how-to-write-tests.md:692
msgid "Testing recursive functions or loops"
msgstr "Özyinelemeli fonksiyonları veya döngüleri test etme"

#: src/ch09-01-how-to-write-tests.md:694
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark "
"the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute on the test function. The following "
"example shows how to use it:"
msgstr "Özyinelemeli fonksiyonları veya döngüleri test ederken, test varsayılan olarak tüketeceği maksimum gaz miktarıyla başlatılır. Bu, sonsuz döngüleri çalıştırmayı veya çok fazla gaz tüketmeyi önler ve uygulamalarınızın verimliliğini ölçmenize yardımcı olabilir. Bu değer makul derecede büyük kabul edilir, ancak test fonksiyonuna `#[available_gas(<Sayı>)]` özniteliğini ekleyerek bunu geçersiz kılabilirsiniz. Aşağıdaki örnek bunun nasıl kullanılacağını gösterir:"

#: src/ch09-01-how-to-write-tests.md:716
msgid "\"result is not 55\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:721
msgid "Benchmarking the gas usage of a specific operation"
msgstr "Belirli bir işlemin gaz kullanımını ölçme"

#: src/ch09-01-how-to-write-tests.md:723
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr "Belirli bir işlemin gaz kullanımını ölçmek istediğinizde, test fonksiyonunuzda aşağıdaki deseni kullanabilirsiniz."

#: src/ch09-01-how-to-write-tests.md:728 src/ch09-01-how-to-write-tests.md:755
msgid "/// code we want to bench.\n"
msgstr ""

#: src/ch09-01-how-to-write-tests.md:729 src/ch09-01-how-to-write-tests.md:757
msgid "\"{}\\n\""
msgstr ""

#: src/ch09-01-how-to-write-tests.md:732
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr "Aşağıdaki örnek, yukarıdaki `sum_n` fonksiyonunun gaz fonksiyonunu test etmek için bunun nasıl kullanılacağını gösterir."

#: src/ch09-01-how-to-write-tests.md:762
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the operation benchmarked."
msgstr "`scarb cairo-test`'i çalıştırdığımızda yazdırılan değer, ölçülen işlem tarafından tüketilen gaz miktarıdır."

#: src/ch09-01-how-to-write-tests.md:775
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation "
"of the hex number). The total amount consumed by the test is slightly higher "
"at 98030, due to some extra steps required to run the entire test function."
msgstr "Burada, `sum_n` fonksiyonunun gaz kullanımı 96760'dır (onaltılık sayının ondalık gösterimi). Testin toplam tükettiği miktar, tüm test fonksiyonunu çalıştırmak için gerekli bazı ek adımlar nedeniyle biraz daha yüksek, 98030'dur."

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module "
"in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's "
"good practice to start organizing your code as if it were. Integration tests "
"use your code in the same way any other external code would, using only the "
"public interface and potentially exercising multiple modules per test."
msgstr "Testleri iki ana kategoriye göre düşüneceğiz: birim testleri ve entegrasyon testleri. Birim testleri küçük ve daha odaklıdır, bir seferde bir modülü izole olarak test eder ve özel fonksiyonları test edebilir. Cairo henüz kamu/özel fonksiyonlar/al...

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr "Her iki tür testi yazmak da, kütüphanenizin parçalarının ayrı ve birlikte beklediğiniz gibi çalıştığından emin olmak için önemlidir."

#: src/ch09-02-test-organization.md:7
msgid "Unit Tests"
msgstr "Birim Testleri"

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the "
"code that they’re testing."
msgstr "Birim testlerinin amacı, kodun her birimini geri kalan koddan bağımsız olarak test etmektir, böylece kodun beklenen şekilde çalışıp çalışmadığını hızlı bir şekilde belirleyebiliriz. Birim testlerini, test ettikleri kodla aynı dosyada `src` dizininde yer alır."

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the "
"test functions and to annotate the module with `cfg(test)`."
msgstr "Konvansiyon, test fonksiyonlarını içeren tests adında bir modül oluşturmak ve modülü `cfg(test)` ile not etmektir."

#: src/ch09-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "Testler Modülü ve `#[cfg(test)]`"

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and "
"run the test code only when you run `scarb cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library "
"and saves space in the resulting compiled artifact because the tests are not "
"included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr "`#[cfg(test)]` notasyonu tests modülüne, yalnızca `scarb cairo-test` çalıştırdığınızda test kodunu derleyip çalıştırmasını, `cairo-run` çalıştırdığınızda ise çalıştırmamasını söyler. Bu, sadece kütüphaneyi oluşturmak istediğinizde derleme süresinden tasarruf sağlar ve testler dahil edilmediğinden sonuçlanan derlenmiş artefaktta yer tasarrufu sağlar. Entegrasyon testlerinin farklı bir dizinde yer alması gerektiğini göreceksiniz, bu yüzden `#[cfg(test)]` notasyonuna ihtiyaç duymazlar. Ancak, birim testleri kodla aynı dosyalarda yer aldığı için, derlenmiş sonuçta dahil edilmemeleri gerektiğini belirtmek için `#[cfg(test)]` kullanacaksınız."

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr "Bu bölümün başında yeni `adder` projesini oluşturduğumuzda, bu ilk testi yazmıştık:"

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option. "
"In this case, the configuration option is `test`, which is provided by Cairo "
"for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb cairo-"
"test`. This includes any helper functions that might be within this module, "
"in addition to the functions annotated with `#[test]`."
msgstr "`cfg` yapılandırma anlamına gelir ve Cairo'ya, belirli bir yapılandırma seçeneği verildiğinde takip eden öğenin yalnızca dahil edilmesi gerektiğini söyler. Bu durumda, yapılandırma seçeneği `test`, testleri derlemek ve çalıştırmak için Cairo tarafından sağlanan bir yapılandırmadır. `cfg` notasyonunu kullanarak, testlerimizi aktif olarak `scarb cairo-test` ile çalıştırdığımızda test kodumuzu derler. Bu, `#[test]` ile not edilen fonksiyonların yanı sıra, bu modül içindeki herhangi bir yardımcı fonksiyonu da içerir."

#: src/ch09-02-test-organization.md:34
msgid "Integration Tests"
msgstr "Entegrasyon Testleri"

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr "Entegrasyon testleri, kütüphanenizi herhangi bir başka kodun yapacağı gibi kullanır. Amaçları, kütüphanenizin birçok parçasının doğru şekilde birlikte çalışıp çalışmadığını test etmektir. Tek başına doğru çalışan kod birimleri birleştirildiğinde sorunlar yaşayabilir, bu yüzden entegre edilmiş kodun test kapsamı da önemlidir. Entegrasyon testleri oluşturmak için öncelikle bir `tests` dizinine ihtiyacınız vardır."

#: src/ch09-02-test-organization.md:38
msgid "The `tests` Directory"
msgstr "`tests` Dizini"

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr "Dosya Adı: src/tests.cairo"

#: src/ch09-02-test-organization.md:68
msgid ""
"Enter the code in Listing 9-11 into the _src/tests/integration_tests.cairo_ "
"file:"
msgstr "_src/tests/integration_tests.cairo_ dosyasına Listeleme 9-11'deki kodu girin:"

#: src/ch09-02-test-organization.md:75
msgid "\"internal_adder failed\""
msgstr ""

#: src/ch09-02-test-organization.md:79
msgid "Filename: src/tests/integration_tests.cairo"
msgstr "Dosya Adı: src/tests/integration_tests.cairo"

#: src/ch09-02-test-organization.md:81
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr "Test edilen fonksiyonları her test dosyası kapsamına dahil etmemiz gerekiyor. Bu sebeple kodun en üstüne `use adder::it_adds_two` ekliyoruz, bu birim testlerde gerekli değildi."

#: src/ch09-02-test-organization.md:83
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr "Daha sonra, tüm entegrasyon testlerimizi çalıştırmak için yalnızca \"integration_tests\" içeren yolu filtrelemek üzere bir filtre ekleyebiliriz."

#: src/ch09-02-test-organization.md:94
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr "Test sonuçları, gördüğümüz gibi, her test için bir satır gösteriyor."

#: src/ch10-00-error-handling.md:1
msgid "Error handling"
msgstr "Hata Yönetimi"

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code, "
"but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr "Bu bölümde, Cairo tarafından sağlanan çeşitli hata yönetimi tekniklerini keşfedeceğiz, bu teknikler sadece kodunuzdaki potansiyel sorunları ele almanıza olanak tanımakla kalmaz, aynı zamanda programlarınızı daha esnek ve bakımı kolay hale getirmenizi de kolaylaştırır. Result enumu ile desen eşleştirmeyi, daha ergonomik hata yayılımı için ? operatörünü kullanmayı ve kurtarılabilir hataları ele almak için unwrap veya expect yöntemlerini kullanmayı içeren farklı hata yönetimi yaklaşımlarını inceleyerek, Cairo'nun hata yönetimi özelliklerine dair daha derin bir anlayış kazanacaksınız. Bu kavramlar, beklenmedik durumları etkili bir şekilde ele alabilen sağlam uygulamalar oluşturmak için hayati öneme sahiptir, böylece kodunuz üretime hazır hale gelir."

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in "
"runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic "
"(e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr "Cairo'da, program yürütülmesi sırasında beklenmedik sorunlar ortaya çıkabilir ve çalışma zamanı hatalarına neden olabilir. Core kütüphanesinden panic fonksiyonu, bu hatalar için bir çözüm sunmaz, ancak oluşumlarını kabul eder ve programı sonlandırır. Cairo'de bir panic, iki ana yolla tetiklenebilir: kodun paniklemesine neden olan eylemler yoluyla istem dışı olarak veya panic fonksiyonunu çağırarak kasıtlı olarak. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide "
"an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr "Bir panik meydana geldiğinde, programın aniden sonlanmasına yol açar. `panic` fonksiyonu, bir hata mesajı sağlamak için kullanılabilecek bir dizi alır ve programın güvenli bir şekilde sonlandırılabilmesi için tüm değişkenlerin düşürülmesini ve sözlüklerin sıkıştırılmasını sağlayan bir geri sarma işlemi gerçekleştirir. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr "İşte bir programın içinden `panic` yapmanın ve hata kodu `2`'yi döndürmenin nasıl olacağı: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:18
#: src/ch10-01-unrecoverable-errors-with-panic.md:54
msgid "\"This line isn't reached\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr "Programı çalıştırmak aşağıdaki çıktıyı üretir: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:29
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr "Çıktıda görebileceğiniz gibi, `panic` ifadesiyle karşılaştıktan sonra program sonlandığı için print ifadesine hiç ulaşılmaz. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use "
"the `panic_with_felt252` function. This function serves as an abstraction of "
"the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers "
"can panic in a one-liner by providing a felt252 error message as an "
"argument, making the code more readable and maintainable."
msgstr "Cairo'da panik yapmanın alternatif ve daha idiyomatik bir yolu, `panic_with_felt252` fonksiyonunu kullanmaktır. Bu fonksiyon, dizi tanımlama sürecinin bir soyutlaması olarak hizmet eder ve genellikle niyetin daha net ve daha özlü bir şekilde ifade edilmesi nedeniyle tercih edilir. `panic_with_felt252` kullanarak, geliştiriciler bir felt252 hata mesajını argüman olarak sağlayarak tek satırda panik yapabilirler, bu da kodu daha okunabilir ve bakımı daha kolay hale getirir. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid "Let's consider an example:"
msgstr "Bir Örnek Düşünelim: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr "Bu programı çalıştırmak, öncekiyle aynı hata mesajını verecektir. Bu durumda, bir diziye ve hata içinde birden çok değere ihtiyaç duyulmuyorsa, `panic_with_felt252` daha özlü bir alternatiftir. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "`panic!` macro"
msgstr "`panic!` makrosu "

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code 2 shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as argument like `panic` function."
msgstr "`panic!` makrosu gerçekten yardımcı olabilir. Önceki örnekte hata kodu 2'nin dönüşü, `panic!` makrosunun ne kadar uygun olduğunu gösterir. `panic` fonksiyonu gibi bir dizi oluşturup argüman olarak geçme ihtiyacı yoktur. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:52
msgid "\"2\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:58
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as parameter. For example, the "
"following line of code will successfully compile: "
msgstr "`panic_with_felt252` fonksiyonunun aksine, `panic!` kullanımı, sonunda panik hatasına dönüşecek olan girdinin, 31 bayttan daha uzun bir metin olmasına izin verir. Bu, `panic!`'in parametre olarak bir dizi alması nedeniyledir. Örneğin, aşağıdaki kod satırı başarıyla derlenecektir: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:61
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:64
msgid "nopanic notation"
msgstr "nopanic notasyonu "

#: src/ch10-01-unrecoverable-errors-with-panic.md:66
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr "Bir fonksiyonun asla panik yapmayacağını belirtmek için `nopanic` notasyonunu kullanabilirsiniz. Yalnızca `nopanic` fonksiyonları, `nopanic` olarak not edilmiş bir fonksiyonda çağrılabilir. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:68
#: src/ch10-01-unrecoverable-errors-with-panic.md:103
#: src/appendix-03-derivable-traits.md:25
#: src/appendix-03-derivable-traits.md:50
#: src/appendix-03-derivable-traits.md:71
#: src/appendix-03-derivable-traits.md:93
#: src/appendix-03-derivable-traits.md:126
#: src/appendix-03-derivable-traits.md:163
msgid "Example:"
msgstr "Örnek:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:76
msgid "Wrong example:"
msgstr "Yanlış örnek: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:84
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr "Eğer aşağıdaki gibi panik yapabilecek bir fonksiyon içeren bir fonksiyon yazarsanız, aşağıdaki hatayı alırsınız: "

#: src/ch10-01-unrecoverable-errors-with-panic.md:97
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr "Unutmayın ki burada panik yapabilecek iki fonksiyon var, assert ve eşitlik. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:99
msgid "panic_with attribute"
msgstr "panic_with özelliği "

#: src/ch10-01-unrecoverable-errors-with-panic.md:101
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data "
"that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr "`panic_with` özelliğini, bir `Option` veya `Result` döndüren bir fonksiyonu işaretlemek için kullanabilirsiniz. Bu özellik, panik nedeni olarak geçirilen verilerin yanı sıra sarıcı bir fonksiyon için bir isim olmak üzere iki argüman alır. Annotasyon yapılan fonksiyonunuz için bir sarıcı oluşturur ve fonksiyon `None` veya `Err` döndürürse, verilen verilerle panik fonksiyonu çağrılır. "

#: src/ch10-01-unrecoverable-errors-with-panic.md:116
msgid "// this returns None\n"
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:117
msgid "// this panics with 'value is 0'\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "Kurtarılabilir Hatalar ile `Result` "

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr "Çoğu hata, programın tamamen durmasını gerektirecek kadar ciddi değildir. Bazen, bir fonksiyon başarısız olduğunda, kolayca yorumlayıp yanıt verebileceğiniz bir nedenle başarısız olur. Örneğin, iki büyük tamsayı eklemeye çalıştığınızda ve işlem, toplam maksimum temsil edilebilir değeri aştığı için taşarsa, tanımsız davranışa neden olmak veya işlemi sonlandırmak yerine bir hata veya sarılı bir sonuç döndürmek isteyebilirsiniz. "

#: src/ch10-02-recoverable-errors.md:7
msgid "The `Result` enum"
msgstr "`Result` enumu "

#: src/ch10-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in "
"Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and "
"`Err`, as follows:"
msgstr "8. Bölümdeki [“Genel veri tipleri”](ch08-01-generic-data-types.md#enums) bölümünden hatırlayacağınız gibi `Result` enumu, `Ok` ve `Err` olmak üzere iki varyanta sahip olarak tanımlanmıştır: "

#: src/ch10-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "`ResultTrait` "

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>` "
"enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr "`ResultTrait` özelliği, `Result<T, E>` enumu ile çalışmak için yöntemler sağlar, örneğin değerleri açma, `Result`'un `Ok` veya `Err` olup olmadığını kontrol etme ve özel bir mesajla panik yapma. `ResultTraitImpl` uygulaması, bu yöntemlerin mantığını tanımlar. "

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to "
"provide a custom error message (as a `felt252` value) that will be used when "
"panicking, giving you more control and context over the panic. On the other "
"hand, the `unwrap` method panics with a default error message, providing "
"less information about the cause of the panic."
msgstr "`expect` ve `unwrap` yöntemleri, her ikisi de `Result<T, E>`'yi `Ok` varyantında olduğunda `T` tipindeki değeri çıkarmaya çalıştıkları için benzerdir. `Result` `Ok(x)` ise, her iki yöntem de değer `x`'i döndürür. Ancak, iki yöntem arasındaki temel fark, `Result` `Err` varyantında olduğunda gösterilen davranıştadır. `expect` yöntemi, panik yapılırken kullanılacak özel bir hata mesajı (felt252 değeri olarak) sağlamanıza izin verir, bu da panik üzerinde daha fazla kontrol ve bağlam sağlar. Öte yandan, `unwrap` yöntemi, varsayılan bir hata mesajı ile panik yapar ve panik nedeni hakkında daha az bilgi sağlar. "

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr "`expect_err` ve `unwrap_err` tam tersi davranışa sahiptir. `Result` `Err(x)` ise, her iki yöntem de değer `x`'i döndürür. Ancak, iki yöntem arasındaki temel fark, `Result::Ok()` durumundadır. `expect_err` yöntemi, panik yapılırken kullanılacak özel bir hata mesajı (felt252 değeri olarak) sağlamanıza izin verir, bu da panik üzerinde daha fazla kontrol ve bağlam sağlar. Öte yandan, `unwrap_err` yöntemi, varsayılan bir hata mesajı ile panik yapar ve panik nedeni hakkında daha az bilgi sağlar. "


#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language. These constraints indicate that the "
"associated functions require an implementation of the `Drop` trait for the "
"generic types `T` and `E`, respectively."
msgstr "Dikkatli bir okuyucu, ilk dört metod imzasında `<+Drop<T>>` ve `<+Drop<E>>` ifadelerini fark etmiş olabilir. Bu sözdizimi, Cairo dilinde genel tip kısıtlamalarını temsil eder. Bu kısıtlamalar, ilişkili fonksiyonların `T` ve `E` genel tipleri için `Drop` özelliğinin bir uygulamasını gerektirdiğini belirtir. "

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr "Son olarak, `is_ok` ve `is_err` metodları, bir `Result` enum değerinin varyantını kontrol etmek için `ResultTrait` özelliği tarafından sağlanan yardımcı fonksiyonlardır. "

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the "
"`Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr "`is_ok`, bir `Result<T, E>` değerinin anlık görüntüsünü alır ve `Result` `Ok` varyantıysa, yani işlem başarılı olduysa `true` döner. `Result` `Err` varyantıysa, `false` döner. "

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a snapshot to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr "`is_err`, bir `Result<T, E>` değerine bir anlık görüntü alır ve `Result` `Err` varyantıysa, yani işlem bir hatayla karşılaştıysa `true` döner. `Result` `Ok` varyantıysa, `false` döner. "

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr "Bu metodlar, Sonuç değerini tüketmeden bir işlemin başarısını veya başarısızlığını kontrol etmek istediğinizde yardımcı olur, bu da sizi varyantı açmadan ek işlemler yapmaya veya kararlar almaya olanak tanır. "

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation of the `ResultTrait` [here](https://github."
"com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr "`ResultTrait` uygulamasını [burada](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20) bulabilirsiniz. "

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr "Örneklerle anlamak her zaman daha kolaydır. "

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr "Bu fonksiyon imzasına bir göz atın: "

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr "İki u128 tamsayı, a ve b alır ve toplama taşmazsa `Ok` varyantında toplamı tutan, toplama taşarsa `Err` varyantında taşan değeri tutan bir `Result<u128, u128>` döndürür. "

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "Şimdi, bu fonksiyonu başka bir yerde kullanabiliriz. Örneğin: "

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr "Burada, iki u128 tamsayı, a ve b alır ve bir `Option<u128>` döndürür. `u128_overflowing_add` tarafından döndürülen `Result`u kullanarak toplama işleminin başarısını veya başarısızlığını belirler. Eşleşme ifadesi, `u128_overflowing_add`tan `Result`u kontrol eder. Sonuç `Ok(r)` ise, toplamı içeren `Option::Some(r)` döndürür. Sonuç `Err(r)` ise, işlemin taşma nedeniyle başarısız olduğunu belirtmek için `Option::None` döndürür. Fonksiyon, taşma durumunda panik yapmaz. "

#: src/ch10-02-recoverable-errors.md:81
msgid "Let's take another example demonstrating the use of `unwrap`."
msgstr "`unwrap` kullanımını gösteren başka bir örneğe bakalım. "

#: src/ch10-02-recoverable-errors.md:92
msgid "Listing 10-1: Using the Result type"
msgstr "Listeleme 10-1: Result tipini kullanma "

#: src/ch10-02-recoverable-errors.md:94
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries "
"to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns `Result::"
"Err('Invalid integer')`."
msgstr "Bu örnekte, `parse_u8` fonksiyonu bir `felt252` tamsayısını alır ve `try_into` metodunu kullanarak bunu bir `u8` tamsayısına dönüştürmeye çalışır. Başarılı olursa, `Result::Ok(değer)` döndürür, aksi takdirde `Result::Err('Geçersiz tamsayı')` döndürür. "

#: src/ch10-02-recoverable-errors.md:96
msgid "Our two test cases are:"
msgstr "İki test vakamız şunlardır:"

#: src/ch10-02-recoverable-errors.md:112
msgid "// should not panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:120
msgid "// should panic\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:128
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the "
"`unwrap` method not to panic. The second test function attempts to convert a "
"value that is out of the `u8` range, expecting the `unwrap` method to panic "
"with the error message 'Invalid integer'."
msgstr "İlk test, `felt252`den `u8`e geçerli bir dönüşümü test eder ve `unwrap` metodunun panik yapmamasını bekler. İkinci test fonksiyonu, `u8` aralığının dışında bir değeri dönüştürmeyi dener ve `unwrap` metodunun 'Geçersiz tamsayı' hata mesajıyla panik yapmasını bekler. "

#: src/ch10-02-recoverable-errors.md:130
msgid "The `?` operator"
msgstr "`?` operatörü"

#: src/ch10-02-recoverable-errors.md:132
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr "Son olarak bahsedeceğimiz operatör `?` operatörüdür. `?` operatörü, daha özdeş ve özlü hata işleme için kullanılır. Bir `Result` veya `Option` türü üzerinde `?` operatörünü kullandığınızda, aşağıdakileri yapacaktır: "

#: src/ch10-02-recoverable-errors.md:134
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr "Değer `Result::Ok(x)` veya `Option::Some(x)` ise, iç değeri `x`'i doğrudan döndürür. "

#: src/ch10-02-recoverable-errors.md:135
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr "Değer `Result::Err(e)` veya `Option::None` ise, hatayı veya `None`'ı hemen fonksiyondan dönerek yayılır. "

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let "
"the calling function deal with them."
msgstr "`?` operatörü, hataları dolaylı olarak ele almak ve çağıran fonksiyonun bunlarla ilgilenmesine izin vermek istediğinizde kullanışlıdır. "

#: src/ch10-02-recoverable-errors.md:139
msgid "Here is an example."
msgstr "İşte bir örnek. "

#: src/ch10-02-recoverable-errors.md:144 src/ch10-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr ""

#: src/ch10-02-recoverable-errors.md:150
msgid "Listing 10-1: Using the `?` operator"
msgstr "Listeleme 10-1: `?` operatörünü kullanma "

#: src/ch10-02-recoverable-errors.md:152
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr "`do_something_with_parse_u8` fonksiyonu bir `felt252` değerini girdi olarak alır ve `parse_u8`'i çağırır. Hata varsa yaymak veya başarılı değeri açmak için `?` operatörü kullanılır. "

#: src/ch10-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr "Ve küçük bir test vakası ile: "

#: src/ch10-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr ""

#: src/ch10-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr ""

#: src/ch10-02-recoverable-errors.md:186
msgid "The console will print the error \"Invalid Integer\"."
msgstr "Konsol, "Geçersiz Tamsayı" hatasını yazdıracaktır. "

#: src/ch10-02-recoverable-errors.md:192
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or "
"`Err`, and panicking with custom messages."
msgstr "Cairo'da, kurtarılabilir hataların, iki varyantı olan Result enum'u kullanılarak ele alınabildiğini gördük: `Ok` ve `Err`. `Result<T, E>` enum'u genel olup, `T` ve `E` türleri sırasıyla başarılı ve hata değerlerini temsil eder. `ResultTrait`, değerleri açma, sonucun `Ok` veya `Err` olup olmadığını kontrol etme ve özel mesajlarla panik yapma gibi `Result<T, E>` ile çalışmak için metodlar sağlar. "

#: src/ch10-02-recoverable-errors.md:194
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or "
"unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr "Kurtarılabilir hataları ele almak için, bir fonksiyon `Result` türünde bir değer döndürebilir ve bir işlemin başarısı veya başarısızlığını ele almak için desen eşleştirme kullanabilir. `?` operatörü, hatayı dolaylı olarak ele almak veya başarılı değeri açmak için kullanılabilir. Bu, daha özlü ve net hata işleme sağlar, burada çağıran, çağrılan fonksiyon tarafından yükseltilen hataları yönetmekten sorumludur. "

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr "Şimdi, Cairo tarafından sunulan daha ileri özellikleri öğrenelim. "

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr "Operatör aşırı yüklemesi, bazı programlama dillerinde standart operatörlerin, örneğin toplama (+), çıkarma (-), çarpma (\\*), ve bölme (/), kullanıcı tanımlı türlerle çalışacak şekilde yeniden tanımlanmasına izin veren bir özelliktir. Bu, kullanıcı tanımlı türlerdeki işlemlerin, ilkel türlerdeki işlemlerle aynı şekilde ifade edilebilmesini sağlayarak kodun sözdizimini daha sezgisel hale getirebilir."

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that "
"operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr "Cairo'da, operatör aşırı yüklemesi belirli özelliklerin uygulanması yoluyla gerçekleştirilir. Her operatörün ilişkili bir özelliği vardır ve o operatörü aşırı yüklemek, bir özel tür için bu özelliğin bir uygulamasını sağlamayı içerir. Ancak, operatör aşırı yüklemesini dikkatli kullanmak esastır. Kötüye kullanım, operatörün aşırı yüklenmesine semantik bir anlamın olmaması durumunda olduğu gibi, kodun daha zor bakımını yapılabilir hale getirerek kafa karışıklığına yol açabilir."

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr "İki `Potions`un birleştirilmesi gereken bir örneği düşünün. `Potions`un iki veri alanı vardır, mana ve sağlık. İki `Potions`un birleştirilmesi, ilgili alanlarının toplanmasını sağlamalıdır. "

#: src/ch11-01-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr ""

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type. "
"The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr "Yukarıdaki kodda, `Potion` türü için `Add` özelliğini uyguluyoruz. add fonksiyonu iki argüman alır: `lhs` ve `rhs` (sol ve sağ taraf). Fonksiyon gövdesi, `lhs` ve `rhs`'nin bir kombinasyonu olan yeni bir `Potion` örneği döndürür. "

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr "Örnekte gösterildiği gibi, bir operatörün aşırı yüklenmesi, aşırı yüklenen somut türün belirtilmesini gerektirir. Aşırı yüklenen genel özellik `Add<T>`'dir ve `Potion` türü için `Add<Potion>` ile somut bir uygulama tanımlıyoruz. "

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their "
"code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr "Cairo dilinde, geliştiricilerin kodlarını basitleştirmelerine olanak tanıyan bazı eklentiler vardır. Bunlara `inline_macros` denir ve diğer kodu üreten kodu yazmanın bir yolu olarak adlandırılırlar. "

#: src/ch11-02-macros.md:5
msgid "`print!` and `println!` macros"
msgstr "`print!` ve `println!` makroları"

#: src/ch11-02-macros.md:7
msgid "Two macros are available for printing values:"
msgstr "Değerleri yazdırmak için kullanılabilen iki makro vardır:"

#: src/ch11-02-macros.md:8
msgid "`println!` which prints on a new line "
msgstr "`println!` yeni bir satırda yazdırır"

#: src/ch11-02-macros.md:9
msgid "`print!` with inline printing"
msgstr "`print!` ile satır içi yazdırma"

#: src/ch11-02-macros.md:11
msgid ""
"Both can be used with curly brackets as placeholders that hold a value in "
"place:"
msgstr "Her ikisi de değer yer tutucuları olarak süslü parantezlerle birlikte kullanılabilir:"

#: src/ch11-02-macros.md:12
msgid ""
"When printing the value of a variable, the variable name can go inside the "
"curly brackets."
msgstr "Bir değişkenin değerini yazdırırken, değişken adı süslü parantezlerin içine gidebilir."

#: src/ch11-02-macros.md:13
msgid ""
"When printing the result of evaluating an expression, use empty curly "
"brackets in the format string, then follow the format string with a comma-"
"separated list of expressions to print in each empty curly bracket "
"placeholder in the same order."
msgstr "Bir ifadenin değerlendirilmesi sonucunu yazdırırken, biçim dizgisinde boş süslü parantezler kullanın, ardından her boş süslü parantez yer tutucusuna aynı sırayla yazdırılacak ifadelerin virgülle ayrılmış listesini biçim dizgisinin ardından takip edin."

#: src/ch11-02-macros.md:15
msgid "`consteval_int!` macro"
msgstr "`consteval_int!` makrosu"

#: src/ch11-02-macros.md:17
msgid ""
"In some situations, a developer might need to declare a constant that is the "
"result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr "Bazı durumlarda, bir geliştirici tamsayıların bir hesaplamasının sonucu olan bir sabiti bildirmeye ihtiyaç duyabilir. Sabit bir ifadeyi hesaplamak ve sonucunu derleme zamanında kullanmak için `consteval_int!` makrosunu kullanmak gereklidir."

#: src/ch11-02-macros.md:19
msgid "Here is an example of `consteval_int!`:"
msgstr "`consteval_int!` örneği:"

#: src/ch11-02-macros.md:25
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "Bu, derleyici tarafından `const a: felt252 = 8;` olarak yorumlanacaktır."

#: src/ch11-02-macros.md:29
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr "Lütfen [Diziler](./ch03-01-arrays.md) sayfasına bakınız."

#: src/ch11-02-macros.md:31
msgid "`panic!`, `assert!` and `assert_eq!` macros macro"
msgstr "`panic!`, `assert!` ve `assert_eq!` makroları"

#: src/ch11-02-macros.md:33
msgid ""
"See [Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-"
"panic.md) page."
msgstr "[Geridönüşümsüz Hatalarla panic](./ch10-01-unrecoverable-errors-with-panic.md) sayfasına bakınız."

#: src/ch11-02-macros.md:35
msgid "`format!` macro"
msgstr "`format!` makrosu"

#: src/ch11-02-macros.md:37
msgid ""
"The `format!` macro works like `println!`, but instead of printing the "
"output to the screen, it returns a  `ByteArray` with the contents. In the "
"following example, we perform string concatenation using either the `+` "
"operator or the `format!` macro.  The version of the code using `format!` is "
"much easier to read, and the code generated by the `format!` macro uses "
"snapshots so that this call doesn’t take ownership of any of its parameters."
msgstr "`format!` makrosu `println!` gibi çalışır, ancak çıktıyı ekrana yazdırmak yerine, içeriği ile bir `ByteArray` döndürür. Aşağıdaki örnekte, `+` operatörü veya `format!` makrosu kullanılarak dizgi birleştirme işlemi yapılıyor. `format!` makrosunu kullanan kodun versiyonu çok daha okunaklıdır ve `format!` makrosu tarafından üretilen kod, bu çağrının parametrelerinin hiçbirine sahiplik yapmaması için anlık görüntüler kullanır."

#: src/ch11-02-macros.md:46 src/ch11-02-macros.md:52
msgid "\"tic\""
msgstr ""

#: src/ch11-02-macros.md:47 src/ch11-02-macros.md:53
msgid "\"tac\""
msgstr ""

#: src/ch11-02-macros.md:48 src/ch11-02-macros.md:54
msgid "\"toe\""
msgstr ""

#: src/ch11-02-macros.md:49
msgid "\"-\""
msgstr ""

#: src/ch11-02-macros.md:50
msgid ""
"// using + operator consumes the strings, so they can't be used again!\n"
msgstr ""

#: src/ch11-02-macros.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr ""

#: src/ch11-02-macros.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr ""

#: src/ch11-02-macros.md:57
msgid "\"{}-{}-{}\""
msgstr ""

#: src/ch11-02-macros.md:58 src/ch11-02-macros.md:77
msgid "\"{}\""
msgstr ""

#: src/ch11-02-macros.md:62
msgid "`write!` macro"
msgstr "`write!` makrosu"

#: src/ch11-02-macros.md:64
msgid ""
"The `write!` and `writeln!` are two macros which are used to emit the format "
"string to a specified stream. This macro takes 2 arguments:"
msgstr "`write!` ve `writeln!`, biçim dizgisini belirli bir akışa göndermek için kullanılan iki makrodur. Bu makro 2 argüman alır:"

#: src/ch11-02-macros.md:66
msgid ""
"a Formatter, which is a struct containing a `ByteArray`, representing the "
"pending result of formatting (the _stream_)"
msgstr "Bir Formatter, bekleyen biçimlendirme sonucunu (akış) temsil eden bir `ByteArray` içeren bir yapıdır."

#: src/ch11-02-macros.md:67
msgid "the 'ByteArray' to append to the formatter"
msgstr "formatter'a eklenecek 'ByteArray'"

#: src/ch11-02-macros.md:69
msgid ""
"Calling this macro will append the provided `ByteArray` string to the "
"formatter. Example usage is:"
msgstr "Bu makroyu çağırmak, sağlanan `ByteArray` dizgisini formatter'a ekler. Kullanım örneği:"

#: src/ch11-02-macros.md:75
msgid "\"hello\""
msgstr ""

#: src/ch11-02-macros.md:76
msgid "\"world\""
msgstr ""

#: src/ch11-02-macros.md:77
msgid "// helloworld\n"
msgstr ""

#: src/ch11-03-hash.md:1
msgid "Hashes"
msgstr "Hashler"

#: src/ch11-03-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a "
"\"hash.\" This transformation is deterministic, meaning that the same input "
"will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography, and data "
"integrity verification - and are very often when developing smart contracts, "
"especially when working with Merkle trees."
msgstr "Temelinde, hashleme, herhangi bir uzunluktaki girdi verilerini (genellikle bir mesaj olarak adlandırılır) tipik olarak bir "hash" olarak adlandırılan sabit boyutta bir değere dönüştürme işlemidir. Bu dönüşüm belirlenimlidir, yani aynı giriş her zaman aynı hash değerini üretir. Hash fonksiyonları, veri depolama, kriptografi ve veri bütünlüğü doğrulama dahil olmak üzere çeşitli alanlarda temel bir bileşendir - ve özellikle Merkle ağaçları ile çalışırken akıllı sözleşmeler geliştirirken çok sık kullanılır."

#: src/ch11-03-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively "
"in the Cairo library : `Poseidon` and `Pedersen`. We will discuss about when "
"and how to use them, and see examples with cairo programs."
msgstr "Bu bölümde, Kahire kitaplığında yerel olarak uygulanan iki hash fonksiyonunu sunacağız: `Poseidon` ve `Pedersen`. Ne zaman ve nasıl kullanılacakları hakkında tartışacağız ve Kahire programları ile örnekler göreceğiz."

#: src/ch11-03-hash.md:7
msgid "Hash functions in Cairo"
msgstr "Cairo'daki Hash Fonksiyonları"

#: src/ch11-03-hash.md:9
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr "Cairo çekirdek kitaplığı iki hash fonksiyonu sağlar: Pedersen ve Poseidon."

#: src/ch11-03-hash.md:11
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on elliptic "
"curve cryptography. These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of "
"the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr "Pedersen hash fonksiyonları, eliptik eğri kriptografisine dayanan kriptografik algoritmalarıdır. Bu fonksiyonlar, bir eliptik eğri boyunca noktalar üzerinde işlemler gerçekleştirir - esasen, bu noktaların konumlarıyla matematik yapar - bunları bir yönde yapmak kolay ve geri almak zordur. Bu tek yönlü zorluk, Elips Eğrisi Ayrık Logaritma Problemi (ECDLP) üzerine kuruludur, bu da hash fonksiyonunun güvenliğini sağlayacak kadar çözülmesi zor bir problemdir. Bu işlemlerin tersine çevrilmesinin zorluğu, Pedersen hash fonksiyonunu kriptografik amaçlar için güvenli ve güvenilir kılar."

#: src/ch11-03-hash.md:13
msgid ""
"Poseidon is a family of hash functions designed for being very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a "
"'sponge construction,' which soaks up data and transforms it securely using "
"a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three element state permutation with [specific parameters]"
"(https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt)."
msgstr "Poseidon, cebirsel devrelerde çok verimli olacak şekilde tasarlanmış bir hash fonksiyonları ailesidir. Tasarımı, özellikle STARK'lar (yani, Kahire) dahil olmak üzere Sıfır-Bilgi kanıt sistemleri için özellikle verimlidir. Poseidon, verileri emen ve Hades permütasyonu olarak bilinen bir süreç kullanarak güvenli bir şekilde dönüştüren bir yöntem olan 'sünger yapısı'nı kullanır. Kahire'nin Poseidon versiyonu, [belirli parametreler](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt) ile üç elemanlı durum permütasyonuna dayanır."

#: src/ch11-03-hash.md:15
msgid "When to use them ?"
msgstr "Ne Zaman Kullanılır?"

#: src/ch11-03-hash.md:17
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses "
"Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr "Pedersen, Starknet'te kullanılan ilk hash fonksiyonuydu ve hala depolama alanındaki değişkenlerin adreslerini hesaplamak için kullanılmaktadır (örneğin, `LegacyMap` Starknet'te bir depolama eşlemesinin anahtarlarını hashlemek için Pedersen kullanır). Ancak, Poseidon STARK kanıt sistemiyle çalışırken Pedersen'den daha ucuz ve daha hızlı olduğundan, şimdi Kahire programlarında kullanılması önerilen hash fonksiyonudur."

#: src/ch11-03-hash.md:21
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or a `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr "Çekirdek kitaplık, hash'lerle çalışmayı kolaylaştırır. `Hash` özelliği, `felt252`'ye dönüştürülebilen tüm türler için uygulanır, `felt252` kendisi de dahil. Daha karmaşık türler gibi yapılar için, `Hash` türetilmesi, tercih ettiğiniz hash fonksiyonunu kullanarak kolayca hashlenmelerini sağlar - yapı alanlarının kendileri hashlenebilir olduğu sürece. `Array<T>` veya `Felt252Dict<T>` gibi hashlenemeyen değerler içeren bir yapıda `Hash` özelliği türetilemez, `T` kendisi hashlenebilir olsa bile."

#: src/ch11-03-hash.md:23
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` that defines the "
"basic methods to work with hashes. They allow you to initialize a hash state "
"that will contain the temporary values of the hash after each application of "
"the hash function; update the hash state, and finalize it when the "
"computation is completed. `HashStateTrait` is defined as follows:"
msgstr "`Hash` özelliği, hash'lerle çalışmak için temel metodları tanımlayan `HashStateTrait` ile birlikte gelir. Her bir hash fonksiyonu uygulamasından sonra hash'in geçici değerlerini içerecek bir hash durumunu başlatmanıza, hash durumunu güncellemenize ve hesaplama tamamlandığında sonlandırmanıza izin verirler. `HashStateTrait` şu şekilde tanımlanır:"

#: src/ch11-03-hash.md:26
msgid "/// A trait for hash state accumulators.\n"
msgstr ""

#: src/ch11-03-hash.md:32
msgid "/// A trait for values that can be hashed.\n"
msgstr ""

#: src/ch11-03-hash.md:35
msgid "/// Updates the hash state with the given value.\n"
msgstr ""

#: src/ch11-03-hash.md:40
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr "Kodunuzda hash'leri kullanmak için, ilgili özellikleri ve fonksiyonları önce içe aktarmanız gerekir. Aşağıdaki örnekte, hem Pedersen hem de Poseidon hash fonksiyonlarını kullanarak bir yapıyı nasıl hashleyeceğimizi göstereceğiz."

#: src/ch11-03-hash.md:42
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() -"
"> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr "İlk adım, hangi hash fonksiyonuyla çalışmak istediğimize bağlı olarak ya `PoseidonTrait::new() -> HashState` ya da `PedersenTrait::new(base: felt252) -> HashState` ile hash'i başlatmaktır. Daha sonra hash durumu, gerektiği kadar `update(self: HashState, value: felt252) -> HashState` veya `update_with(self: S, value: T) -> S` fonksiyonları ile güncellenebilir. Sonra `finalize(self: HashState) -> felt252` fonksiyonu hash durumu üzerinde çağrılır ve hash değeri bir `felt252` olarak döndürülür."

#: src/ch11-03-hash.md:68
msgid ""
"As our struct derives the trait HashTrait, we can call the function as "
"follows for Poseidon hashing :"
msgstr "Yapımız HashTrait özelliğini türettiği için, Poseidon hashleme için fonksiyonu şu şekilde çağırabiliriz:"

#: src/ch11-03-hash.md:92
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr "Pedersen, bir temel durumla başladığı için Poseidon'dan farklıdır. Bu temel durum `felt252` türünde olmalıdır, bu da bizi ya `update_with` metodunu kullanarak yapıyı keyfi bir temel durumla hashlemeye ya da yapıyı bir diziye seri hale getirip tüm alanlarını döngüye alıp elemanlarını birlikte hashlemeye zorlar."

#: src/ch11-03-hash.md:94
msgid "Here is a short example for Pedersen hashing :"
msgstr "Pedersen hashleme için kısa bir örnek:"

#: src/ch11-03-hash.md:111
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr ""

#: src/ch11-03-hash.md:124
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr ""

#: src/ch11-03-hash.md:133
msgid "Advanced Hashing: Hashing arrays with Poseidon"
msgstr "İleri Hashleme: Poseidon ile Dizileri Hashleme"

#: src/ch11-03-hash.md:135
msgid ""
"Let us look at an example of hashing a function that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function in poseidon ` "
"poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly you can "
"hash `Array<felt252>` by calling `poseidon_hash_span` on its span."
msgstr "Bir fonksiyonun bir `Span<felt252>` içerdiği bir örneğe bakalım. Bir `Span<felt252>` veya bir `Span<felt252>` içeren bir yapıyı hashlemek için, poseidon'da yerleşik olan `poseidon_hash_span(mut span: Span<felt252>) -> felt252` fonksiyonunu kullanabilirsiniz. Benzer şekilde, `Array<felt252>`'nin span'ını çağırarak `poseidon_hash_span` ile hashleyebilirsiniz."

#: src/ch11-03-hash.md:139
msgid "First let us import the following trait and function :"
msgstr "İlk olarak aşağıdaki özelliği ve fonksiyonu içe aktaralım:"

#: src/ch11-03-hash.md:147
msgid ""
"Now we define the structure, as you might have notice we didn't derived the "
"Hash trait. If you try to derive the Hash trait on this structure it will "
"rise an error because the structure contains a field not hashable."
msgstr "Şimdi yapıyı tanımlıyoruz, fark etmiş olabileceğiniz gibi Hash özelliğini türetmedik. Bu yapıya Hash özelliğini türetmeye çalışırsanız, yapının hashlenemeyen bir alan içermesi nedeniyle bir hata oluşur."

#: src/ch11-03-hash.md:160
msgid ""
"In this example, we initialized a HashState (`hash`) and updated it and then "
"called the function `finalize()` on the HashState to get the computed hash "
"`hash_felt252`. We used the `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr "Bu örnekte, bir HashState (`hash`) başlattık ve güncelledik, ardından hesaplanan hash `hash_felt252`'yi almak için HashState üzerinde `finalize()` fonksiyonunu çağırdık. `Array<felt252>`'nin hash'ini hesaplamak için `Span` üzerinde `poseidon_hash_span` kullandık."

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts "
"for the Starknet network. Starknet is a permissionless network that "
"leverages zk-STARKs technology for scalability. As a Layer-2 scalability "
"solution for Ethereum, Starknet's goal is to offer fast, secure, and low-"
"cost transactions. It functions as a Validity Rollup (commonly known as a "
"zero-knowledge Rollup) and is built on top of the Cairo language and the "
"Starknet VM."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections. If you want to learn more about the "
"Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this "
"functionality, you'll need to make some configurations in your `Scarb.toml` "
"file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a `[[target."
"starknet-contract]]` section to enable contract compilation."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:17
msgid ""
"Below is the minimal Scarb.toml file required to compile a crate containing "
"Starknet contracts:"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please "
"refer to the [Scarb documentation](https://docs.swmansion.com/scarb/docs/"
"extensions/starknet/contract-target.html#compiling-external-contracts)."
msgstr ""

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts "
"are, what are they used for, and why would blockchain developers use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "Smart-contracts"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem]"
"(https://ethereum.org/en/developers/docs/evm/), the most commonly used "
"language is Solidity, while on Starknet, it is Cairo. The way the code is "
"compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart "
"contracts are also **transparent**; the data stored by the smart contract is "
"accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They "
"require third-party software (called `oracles`) to access external data (the "
"price of a token for instance)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "Use cases"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of developers."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "DeFi"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no "
"longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, "
"stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "Tokenization"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "Voting"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems. "
"Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "Royalties"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "Decentralized identities DIDs"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with "
"third parties securely. The smart contract could verify the authenticity of "
"a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "The rise of Starknet and Cairo"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain Trilemma](https://vitalik.ca/"
"general/2021/04/07/sharding.html#the-scalability-trilemma)) in the "
"blockchain space states that it is impossible to achieve a high level of "
"scalability, decentralization, and security simultaneously; trade-offs must "
"be made. Ethereum is at the intersection of decentralization and security. "
"Eventually, it was decided that Ethereum's purpose would be to serve as a "
"secure settlement layer, while complex computations would be offloaded to "
"other networks built on top of Ethereum. These are called Layer 2s (L2s)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1). "
"The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale "
"significantly more than optimistic rollups. You can learn more about STARKs "
"from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet Book]"
"(https://book.starknet.io/chapter_4/index.html), which is a great resource "
"to learn more about the Starknet network."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM "
"(either as-is or adapted) as a base layer, Starknet employs its own VM. This "
"frees developers from the constraints of the EVM, opening up a broader range "
"of possibilities. Coupled with decreased transaction costs, the combination "
"of Starknet and Cairo creates an exciting playground for developers. Native "
"account abstraction enables more complex logic for accounts, that we call "
"\"Smart Accounts\", and transaction flows. Emerging use cases include "
"**transparent AI** and machine learning applications. Finally, **blockchain "
"games** can be developed entirely **on-chain**. Starknet has been "
"specifically designed to maximize the capabilities of STARK proofs for "
"optimal scalability."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid ""
"Learn more about Account Abstraction in the [Starknet Book](https://book."
"starknet.io/chapter_5/index.html)."
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts "
"previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have "
"a function `main` that serves as the entry point for this program:"
msgstr ""

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS, "
"and as such, have access to Starknet's state. For a module to be handled as "
"a contract by the compiler, it must be annotated with the `#[starknet::"
"contract]` attribute."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an "
"example of a basic contract. You will learn how to write a simple contract "
"that stores a single number on the blockchain."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:5
msgid "Anatomy of a simple Starknet Contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet "
"contract. It might not be easy to understand it all at once, but we will go "
"through it step by step:"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:38
msgid "Listing 99-1: A simple storage contract"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:40
msgid ""
"Note: Starknet contracts are defined within [modules](./ch07-02-defining-"
"modules-to-control-scope.md)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:42
msgid "What is this contract?"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called "
"`stored_data` of type `u128` (unsigned integer of 128 bits). You can think "
"of it as a single slot in a database that you can query and alter by calling "
"functions of the code that manages the database. The contract defines and "
"exposes publicly the functions `set` and `get` that can be used to modify or "
"retrieve the value of that variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes "
"to the outside world. Here, the interface exposes two functions: `set` and "
"`get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) "
"mechanism from Cairo, we can make sure that the actual implementation of the "
"contract matches its interface. In fact, you will get a compilation error if "
"your contract doesn’t conform with the declared interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:70
msgid ""
"Listing 99-2: A wrong implementation of the interface of the contract. This "
"does not compile."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. The `self` "
"parameter represents the contract state. Seeing the `self` argument passed "
"to `set` tells us that this function might access the state of the contract, "
"as it is what gives us access to the contract’s storage. The `ref` modifier "
"implies that `self` may be modified, meaning that the storage variables of "
"the contract may be modified inside the `set` function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which "
"immediately tells us that it does not modify the state (and indeed, the "
"compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. In the example above, `set` and `get` are "
"public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the "
"example above, `set` and `get` are public functions."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked "
"through a transaction and that can mutate the state of the contract. `set` "
"is an external function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the "
"contract, but that cannot mutate the state of the contract. `get` is a view "
"function."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the external functions of the contract must be "
"defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. "
"The implementation block must be annotated with the `#[abi(embed_v0)]` "
"attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions "
"will not be callable from the outside. All functions defined in a block "
"marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter "
"corresponding to the `self` argument in the trait must be `ContractState`. "
"The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, "
"`ContractState` gives us the ability to emit events. The name "
"`ContractState` is not surprising, as it’s a representation of the "
"contract’s state, which is what we think of `self` in the contract interface "
"trait."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the "
"contract are defined under the implementation of a trait that has a "
"`TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` "
"parameter to the function, allowing access the storage variables of the "
"contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the "
"`read` and `write` methods to either read or write the value of the storage "
"variable."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:118
msgid ""
"Using `self` and the `write` method to modify the value of a storage variable"
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, "
"attempting to modify will result in a compilation error."
msgstr ""

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a "
"single number that is accessible by anyone in the world. Anyone could call "
"`set` again with a different value and overwrite your number, but the number "
"is still stored in the history of the blockchain. Later, you will see how "
"you can impose access restrictions so that only you can alter the number."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract "
"written in Cairo. In this section, we'll be taking a deeper look at all the "
"components of a smart contract, step by step."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we "
"specified the difference between _public functions, external functions and "
"view functions_, and we mentioned how to interact with _storage_."
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid ""
"Where should I define functions that do not need to access the contract's "
"state?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the following example contract that we'll be using throughout this "
"chapter:"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:93
#: src/ch99-01-03-01-contract-storage.md:83
#: src/ch99-01-03-01-contract-storage.md:208
#: src/ch99-01-03-01-contract-storage.md:322
#: src/ch99-01-03-01-contract-storage.md:434
#: src/ch99-01-03-01-contract-storage.md:546
#: src/ch99-01-03-01-contract-storage.md:656
#: src/ch99-01-03-01-contract-storage.md:774
#: src/ch99-01-03-01-contract-storage.md:884
#: src/ch99-01-03-02-contract-functions.md:82
#: src/ch99-01-03-04-reducing-boilerplate.md:7
msgid "// Could be a group of functions about a same topic\n"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:111
#: src/ch99-01-03-01-contract-storage.md:101
#: src/ch99-01-03-01-contract-storage.md:226
#: src/ch99-01-03-01-contract-storage.md:340
#: src/ch99-01-03-01-contract-storage.md:452
#: src/ch99-01-03-01-contract-storage.md:564
#: src/ch99-01-03-01-contract-storage.md:674
#: src/ch99-01-03-01-contract-storage.md:792
#: src/ch99-01-03-01-contract-storage.md:902
#: src/ch99-01-03-02-contract-functions.md:100
msgid "// Free functions\n"
msgstr ""

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:123
msgid "Listing 99-3: Our reference contract for this chapter"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"modified anytime once the contract is deployed."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:115
msgid "A Storage Struct"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:117
msgid ""
"The storage struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"`#[storage]`. This annotation tells the compiler to generate the required "
"code to interact with the blockchain state, and allows you to read and write "
"data from and to storage. Moreover, this allows you to define storage "
"mappings using the `LegacyMap` type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:120
msgid ""
"Each variable stored in the storage struct is stored in a different location "
"in the contract's storage. The storage address of a variable is determined "
"by the variable's name, and the eventual keys of the variable if it is a "
"[mapping](#storing-mappings)."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:122
msgid "Storage Addresses"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:124
msgid "The address of a storage variable is computed as follows:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:126
msgid ""
"If the variable is a single value (not a mapping), the address is the "
"`sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` "
"is Starknet's version of the Keccak256 hash function, whose output is "
"truncated to 250 bits."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:127
msgid ""
"If the variable is a [mapping](#storing-mappings), the address of the value "
"at key `k_1,...,k_n` is `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,"
"k_n)` where ℎ is the Pedersen hash and the final value is taken `mod (2^251) "
"− 256`."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:128
msgid ""
"If it is a mapping to complex values (e.g., tuples or structs), then this "
"complex value lies in a continuous segment starting from the address "
"calculated in the previous point. Note that 256 field elements is the "
"current limitation on the maximal size of a complex storage value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:130
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:240
msgid "Interacting with Storage Variables"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:242
msgid ""
"Variables stored in the storage struct can be accessed and modified using "
"the `read` and `write` functions, and you can get their address in storage "
"using the `address` function. These functions are automatically generated by "
"the compiler for each storage variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:244
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:354
msgid "Calling the `read` function on the `owner` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:356
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:466
msgid "Calling the `read` function on the `names` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:468
msgid ""
"To write a value to a storage variable, we call the `write` function passing "
"in the eventual keys the value as arguments. As with the `read` function, "
"the number of arguments depends on the number of keys - here, we only pass "
"in the value to write to the `owner` variable as it is a simple variable."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:578
msgid "Calling the `write` function on the `owner` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:688
msgid "Calling the `write` function on the `names` variable"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:690
msgid "Storing custom types"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:692
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used "
"to specify how a type should be stored in storage. In order for a type to be "
"stored in storage, it must implement the `Store` trait. Most types from the "
"core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ContractAddress`, etc. implement the `Store` trait and "
"can thus be stored without further action."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:694
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an "
"enum or a struct? In that case, you have to explicitly tell the compiler how "
"to store this type."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:696
msgid ""
"In our example, we want to store a `Person` struct in storage, which is "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be achieved by simply adding a `#[derive(starknet::Store)]` attribute on top "
"of our struct definition."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:806
msgid ""
"Similarly, Enums can be written to storage if they implement the `Store` "
"trait, which can be trivially derived as long as all associated types "
"implement the `Store` trait."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:916
msgid "Structs storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:918
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types. "
"The elements of the struct are stored in the same order as they are defined "
"in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [Storage "
"Addresses](#storage-addresses) and can be obtained by calling `var."
"address()`, and subsequent elements are stored at addresses contiguous to "
"the first element. For example, the storage layout for the `owner` variable "
"of type `Person` will result in the following layout:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:922
msgid "Fields"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:922
#: src/ch99-01-03-01-contract-storage.md:933
msgid "Address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:924
msgid "name"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:924
msgid "owner.address()"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:925
msgid "address"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:925
msgid "owner.address() +1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:927
msgid "Enums storage layout"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:929
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and an eventual associated values. This index starts at 0 "
"for the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, it's stored starting from "
"the address immediately following the base address. For example, suppose we "
"have the `RegistrationType` enum with the `finite` variant, which carries an "
"associated limit date. The storage layout would look like this:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:933
msgid "Element"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:935
msgid "Variant index (e.g. 1 for finite)"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:935
msgid "registration_type.address()"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:936
msgid "Associated limit date"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:936
msgid "registration_type.address() + 1"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:938
msgid "Storage mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:940
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. The only way to remove a mapping is to set its value "
"to the default zero value."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:943
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:955
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:958
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"one in Listing 99-4 like the popular `allowances` storage variable in the "
"ERC20 Standard which maps an `owner` and an allowed `spender` to its "
"`allowance` amount using multiple keys passed inside a tuple:"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:967
msgid "Listing 99-4: Storing mappings"
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:969
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [Storage Addresses](#storage-addresses) "
"section. If the key of a mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the `Hash` trait, "
"which can be derived with the `#[derive(Hash)]` attribute. For example, if "
"you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:972
msgid ""
"Similarly, in the case of a nested mapping such as "
"`LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be "
"computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""

#: src/ch99-01-03-01-contract-storage.md:974
msgid ""
"For more details about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-storage/"
"#storage_variables)"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in contracts:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:5
msgid "1. Constructors"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:7
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:24
msgid "2. Public functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They must be defined inside an implementation block annotated with "
"the `#[abi(embed_v0)]` attribute. This attribute means that all functions "
"embedded inside it are implementations of the Starknet interface, and "
"therefore entry points of the contract. It only affects the visibility "
"(public vs private/internal), but it doesn't inform us on the ability of "
"these functions to modify the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:47
msgid "External functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:49
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally. "
"External functions are _public_ functions where the `self: ContractState` is "
"passed as reference with the `ref` keyword, allowing you to modify the state "
"of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:59
msgid "View functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:61
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They "
"can be called by other contracts or externally. View functions are _public_ "
"functions where the `self: ContractState` is passed as snapshot, preventing "
"you from modifying the state of the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"**Note:** It's important to note that both external and view functions are "
"public. To create an internal function in a contract, you will need to "
"define it outside of the implementation block annotated with the "
"`#[abi(embed_v0)]` attribute."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:73
msgid "3. Private functions"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the "
"`#[abi(embed_v0)]` attribute are private functions (also called internal "
"functions). They can only be called from within the contract."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:77
msgid ""
"They can be grouped in a dedicated impl block (e.g in components, to easily "
"import internal functions all at once in the embedding contracts) or just be "
"added as free functions inside the contract module. Note that these 2 "
"methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:111
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next section](./"
"ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:113
msgid "4. \\[abi(per_item)\\] attribute"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:115
msgid ""
"You can also define the entrypoint type of a function individually inside an "
"impl using the`#[abi(per_item)]` attribute on top of your impl. It is often "
"used with the `#[generate_trait]` attribute, as it allows you to define "
"entrypoints without an explicit interface. In this case, the functions will "
"not be grouped under an impl in the abi. Note that when using "
"`#[abi(per_item)]` attribute, public functions need to be annotated with "
"`#[external(v0)]` attribute - otherwise, they will not be exposed."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:117
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, `l1-"
"handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet "
"interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:119
msgid "Here is a short example:"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:131
msgid "// this is a constructor function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:135
msgid "// this is a public function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:139
msgid "// this is a l1_handler function\n"
msgstr ""

#: src/ch99-01-03-02-contract-functions.md:142
msgid "// this is an internal function\n"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:1 src/ch99-01-05-00-components.md:29
msgid "Events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during "
"execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract "
"could lead to a bad user experience. This is because users may not see their "
"NFTs appear in their wallets (wallets use these indexers to display a user's "
"NFTs)."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:9
msgid "Defining events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum, "
"which implements the `starknet::Event` trait, as enum variants. This trait "
"is defined in the core library as follows:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the Event type, "
"which in our example is the following enum:"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and "
"each variant needs to implement the `starknet::Event` trait itself. "
"Moreover, the members of these variants must implement the `Serde` trait (_c."
"f._ [Appendix C: Serializing with Serde](./appendix-03-derivable-traits."
"md)), as keys/data are added to the event using a serialization process."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl "
"of the Event trait for the variant’s type ."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with "
"the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: "
"name })`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""

#: src/ch99-01-03-03-contract-events.md:48
msgid "Emitting events"
msgstr ""

#: src/ch99-01-03-03-contract-events.md:50
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a "
"contract that didn't have any corresponding trait."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:26
msgid ""
"It's not the first time that we encounter this attribute, we already talked "
"about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this "
"section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:28
msgid ""
"In order to access the ContractState in a function in an implementation "
"block, this implementation block must be defined with a `ContractState` "
"generic parameter. This implies that we first need to define a generic trait "
"that takes a `TContractState`, and then implement this trait for the "
"`ContractState` type. But by using the `#[generate_trait]` attribute, this "
"whole process can be skipped and we can simply define the implementation "
"block directly, without any generic parameter, and use `self: ContractState` "
"in our functions."
msgstr ""

#: src/ch99-01-03-04-reducing-boilerplate.md:31
msgid ""
"If we had to manually define the trait for the `InternalFunctions` "
"implementation, it would look something like this:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into "
"fewer storage slots. For example, consider a `Sizes` struct with 3 fields of "
"different types. The total size is 8 + 32 + 64 = 104 bits. This is less than "
"the 128 bits of a single `u128`. This means we can pack all 3 fields into a "
"single `u128` variable. Since a storage slot can hold up to 251 bits, our "
"packed value will take only one storage slot instead of 3."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:49
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:58
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:66
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by "
"performing bitshift and additions. The `unpack` reverses this process to "
"extract the original fields back into a struct."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the "
"operations performed in the example: The goal is to pack the `tiny`, "
"`small`, and `medium` fields into a single `u128` value. First, when packing:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. "
"This creates a `u128` value with the low 8 bits set to `tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the "
"value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we "
"add `tiny` to `small` to combine them into a single `u128` value. The value "
"of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits "
"(`TWO_POW_40`) to make space for the previous fields. This takes bits 40-103."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& "
"MASK_8`). This isolates the lowest 8 bits of the packed value, which is "
"`tiny`'s value."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the "
"bitmask, then use bitwise AND with the 32 ones bitmask."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, "
"we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a "
"single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack "
"before writing and unpack after reading from storage. One important detail, "
"however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will "
"want to pack into a felt252 or u256 - but if you want to pack into a type of "
"your own, make sure that this one implements the `Store` trait."
msgstr ""

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr ""

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a "
"simple one, like an ownership component, or more complex like a full-fledged "
"ERC20 token."
msgstr ""

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr ""

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr ""

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr ""

#: src/ch99-01-05-00-components.md:30
msgid "External and internal functions"
msgstr ""

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr ""

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr ""

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in [Contracts](./"
"ch99-01-02-a-simple-contract.md)."
msgstr ""

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [Dispatcher](./ch99-02-02-contract-"
"dispatcher-library-dispatcher-and-system-calls.md) pattern."
msgstr ""

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the "
"component. It is different than the name of your impl."
msgstr ""

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr ""

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr ""

#: src/ch99-01-05-00-components.md:168
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""

#: src/ch99-01-05-00-components.md:172
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""

#: src/ch99-01-05-00-components.md:178
msgid "A closer look at the `impl` block"
msgstr ""

#: src/ch99-01-05-00-components.md:189
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be "
"used in the contract to refer to this component. In this case, the component "
"will be referred to as `Ownable` in contracts embedding it."
msgstr ""

#: src/ch99-01-05-00-components.md:194
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) "
"section."
msgstr ""

#: src/ch99-01-05-00-components.md:202
msgid ""
"One of the major differences from a regular smart contract is that access to "
"storage and events is done via the generic `ComponentState<TContractState>` "
"type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via `self."
"storage_var_name.read()` or `self.emit(...).`"
msgstr ""

#: src/ch99-01-05-00-components.md:208
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr ""

#: src/ch99-01-05-00-components.md:211
msgid "Migrating a Contract to a Component"
msgstr ""

#: src/ch99-01-05-00-components.md:213
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""

#: src/ch99-01-05-00-components.md:217
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr ""

#: src/ch99-01-05-00-components.md:218
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr ""

#: src/ch99-01-05-00-components.md:220
msgid "Adding generic parameters to the `impl` block:"
msgstr ""

#: src/ch99-01-05-00-components.md:221
msgid "Adding `TContractState` as a generic parameter."
msgstr ""

#: src/ch99-01-05-00-components.md:222
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr ""

#: src/ch99-01-05-00-components.md:223
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""

#: src/ch99-01-05-00-components.md:226
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""

#: src/ch99-01-05-00-components.md:231
msgid "Using components inside a contract"
msgstr ""

#: src/ch99-01-05-00-components.md:233
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To "
"integrate a component into your contract, you need to:"
msgstr ""

#: src/ch99-01-05-00-components.md:237
msgid "Declare it with the `component!()` macro, specifying"
msgstr ""

#: src/ch99-01-05-00-components.md:239
msgid "The path to the component `path::to::component`."
msgstr ""

#: src/ch99-01-05-00-components.md:240
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr ""

#: src/ch99-01-05-00-components.md:242
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr ""

#: src/ch99-01-05-00-components.md:245
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: ownable_component::"
"Event`)."
msgstr ""

#: src/ch99-01-05-00-components.md:250
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr ""

#: src/ch99-01-05-00-components.md:253
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""

#: src/ch99-01-05-00-components.md:258
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""

#: src/ch99-01-05-00-components.md:264
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the "
"following:"
msgstr ""

#: src/ch99-01-05-00-components.md:302
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""

#: src/ch99-01-05-00-components.md:315
msgid "Stacking Components for Maximum Composability"
msgstr ""

#: src/ch99-01-05-00-components.md:317
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You will be able to "
"rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""

#: src/ch99-01-05-00-components.md:323
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr ""

#: src/ch99-01-05-00-components.md:326
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the hood](./"
"ch99-01-05-01-components-under-the-hood)."
msgstr ""

#: src/ch99-01-05-00-components.md:331
msgid "Troubleshooting"
msgstr ""

#: src/ch99-01-05-00-components.md:333
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""

#: src/ch99-01-05-00-components.md:337
msgid "`Trait not found. Not a trait.`"
msgstr ""

#: src/ch99-01-05-00-components.md:339
msgid ""
"This error can occur when you're not importing the component's impl block "
"correctly in your contract. Make sure to respect the following syntax:"
msgstr ""

#: src/ch99-01-05-00-components.md:347
msgid "Referring to our previous example, this would be:"
msgstr ""

#: src/ch99-01-05-00-components.md:354
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`"
msgstr ""

#: src/ch99-01-05-00-components.md:357
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on "
"the action to take. Basically, you forgot to add the component's storage to "
"your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's "
"storage."
msgstr ""

#: src/ch99-01-05-00-components.md:362
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum. "
"Consider adding to the Event enum:`"
msgstr ""

#: src/ch99-01-05-00-components.md:365
msgid ""
"Similar to the previous error, the compiler, you forgot to add the "
"component's events to your contract's events. Make sure to add the path to "
"the component's events to your contract's events."
msgstr ""

#: src/ch99-01-05-00-components.md:369
msgid "Components functions are not accessible externally"
msgstr ""

#: src/ch99-01-05-00-components.md:371
msgid ""
"This can happen if you forgot to annotate the component's impl block with "
"`#[abi(embed_v0)]`. Make sure to add this annotation when embedding the "
"component's impl in your contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`) "
"can be made embeddable. Embeddable impls can be injected into any contract, "
"adding new entry points and modifying the ABI of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component "
"inside a contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`, "
"replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of "
"a generic contract, and `ComponentState<TContractState>`."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:75
msgid "// generated per component\n"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies ](./ch99-01-05-02-"
"component-dependencies.md) section."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we "
"expect to get an impl with the following functions:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "Contract Integration"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic "
"impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the "
"two."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl "
"aliases instantiate these generic impls with the contract's concrete storage "
"types."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need "
"to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined as follows:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:32
msgid "Testing the component by deploying a mock contract"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:34
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:36
msgid "We can define such a mock contract as follows:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:59
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:61
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:71
msgid ""
"We can now write tests for the component by deploying this mock contract and "
"calling its entry points, as we would with a typical contract."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:102
msgid "Testing components without deploying a contract"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:104
msgid ""
"In [Components under the hood](./ch99-01-05-01-components-under-the-hood."
"md), we saw that components leveraged genericity to define storage and logic "
"that could be embedded in multiple contracts. If a contract embeds a "
"component, a `HasComponent` trait is created in this contract, and the "
"component methods are made available."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:106
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:108
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need "
"to deploy it."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:110
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the `MockContract::"
"ContractState` type to do so."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:118
#: src/ch99-01-05-03-testing-components.md:162
msgid "// You can derive even `Default` on this type alias\n"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:139
msgid ""
"We defined the `TestingState` type as an alias of the `CounterComponent::"
"ComponentState<MockContract::ContractState>` type. By passing the "
"`MockContract::ContractState` type as a concrete type for `ComponentState`, "
"we aliased a concrete implementation of the `ComponentState` struct to "
"`TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:141
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:143
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:145
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:147
msgid "Let's summarize what we've done so far:"
msgstr ""

#: src/ch99-01-05-03-testing-components.md:149
msgid "We defined a mock contract that embeds the component we want to test."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:150
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:151
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""

#: src/ch99-01-05-03-testing-components.md:153
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and "
"library dispatchers and their low-level system call equivalents!"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the `#[starknet::"
"interface]` attribute. If you are new to traits, check out the dedicated "
"chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self "
"parameter of type `@TContractState`, while `external` functions have a self "
"parameter of type passed by reference `ref self: TContractState`."
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "Listing 99-5: A simple ERC20 Interface"
msgstr ""

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid ""
"Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically "
"created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing 99-5)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to "
"keep this chapter concise and straight to the point, we focused on one view "
"function `name`, and one external function `transfer`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:37
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "Listing 99-6: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to "
"call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "Listing 99-7: A sample contract which uses the Contract Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes** "
"(stateless)."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of "
"A, and updating a storage variable in B will update the storage of B."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B, "
"the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:157
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while "
"the latter uses `library_call_syscall`."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "Listing 99-8: An expanded form of the IERC20 trait"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:207
msgid "Listing 99-9: A sample contract using the Library Dispatcher"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:209
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the "
"class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call "
"to the `set_value` function in IContractA, updating the value of the storage "
"variable `value` in ContractA."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:211
msgid "Using low-level syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:213
msgid ""
"Another way to call other contracts and classes is to use the `starknet::"
"call_contract_syscall`and `starknet::library_call_syscall` system calls. The "
"dispatchers we described in the previous sections are high-level syntaxes "
"for these low-level system calls."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:215
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the "
"returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:253
msgid "\"transferFrom\""
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:263
msgid "Listing 99-10: A sample contract using syscalls"
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:265
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call, and the call arguments."
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:267
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to "
"deserialize ourselves!"
msgstr ""

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the "
"contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting, "
"the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured "
"voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:14
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:16
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:20
msgid "/// @dev Function that returns the current vote status\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:22
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:26
msgid "/// @dev Function that allows a user to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:29
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:39
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:48
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:56
msgid "// Register all voters by calling the _register_voters function\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:59
msgid "// Initialize the vote count to 0\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:64
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:72
msgid "/// @dev Represents a vote that was cast\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:79
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:85
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:88
msgid "/// @dev Returns the voting results\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:95
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:100
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:105
msgid "/// @dev Submit a vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:107
msgid "\"VOTE_0_OR_1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:123
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:126
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:144
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:147
msgid ""
"// @dev Internal function that checks if an address is allowed to vote\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:156
msgid "\"USER_NOT_REGISTERED\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:157
#: src/ch99-01-04-01-voting-contract.md:427
msgid "\"USER_ALREADY_VOTED\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:161
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:164
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:172
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:191
msgid "Voting smart contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:195
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:197
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its "
"functions. You can also use the Goerli Testnet instead of `katana`. However, "
"we recommend using `katana` for local development and testing. You can find "
"the complete tutorial for `katana` in the [Katana: A Local Node](https://"
"book.starknet.io/ch02-04-katana.html) chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo team](https://"
"github.com/dojoengine/dojo/blob/main/crates/katana/README.md). It will allow "
"you to do everything you need to do with Starknet, but locally. It is a "
"great tool for development and testing."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-installation."
"html#katana-node-installation) chapter of the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:210
msgid ""
"Note: Please verify that the version of `katana` match the specified version "
"provided below."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:215
msgid ""
"To upgrade `katana`, refer to the [Basic Installation](https://book.starknet."
"io/ch02-01-basic-installation.html#katana-node-installation) chapter of the "
"Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:218
msgid ""
"Once you have `katana` installed, you can start the local Starknet node with:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:224
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:229
msgid "================="
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how "
"accounts operate with Account Abstraction, refer to the [Account Abstraction]"
"(https://book.starknet.io/ch04-00-account-abstraction.html) chapter of the "
"Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Smart wallets for voting"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:249
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the [Basic Installation](https://book."
"starknet.io/ch02-01-basic-installation.html#starkli-installation) chapter of "
"the Starknet Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:251
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:256
msgid ""
"To upgrade `starkli` to `1.0.20`, use the `starkliup -v 0.1.20` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:258
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the [Testnet Deployment](https://book.starknet.io/ch02-05-testnet-"
"deployment.html?highlight=signer#creating-a-signer) chapter of the Starknet "
"Book."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:260
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:262
msgid "Firstly, we create a signer from a private key:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:268
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:274
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:278
#: src/ch99-01-04-01-voting-contract.md:281
#: src/ch99-01-04-01-voting-contract.md:388
msgid "\"version\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:279
msgid "\"variant\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:280
#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"type\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:280
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"public_key\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:284
msgid "\"deployment\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"status\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"deployed\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"class_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:292
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the `--"
"rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:294
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:298
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:304
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:306
msgid "Contract Deployment"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:308
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:314
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the `--"
"compiler-version x.y.z` flag."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:316
msgid ""
"If you're still encountering issues with the compiler version, try upgrading "
"Starkli using the command: `starkliup` to make sure you're using the latest "
"version of starkli."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:318
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can find it [on any block explorer](https://goerli.voyager.online/"
"class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:320
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the "
"transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:322
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:324
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:330
msgid "An example command:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:336
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with "
"the contract."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:338
msgid "Voter Eligibility Verification"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:340
msgid ""
"In our voting contract, we have two functions to validate voter eligibility, "
"`voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:342
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:344
msgid ""
"You can call these functions using the `starkli call` command. Note that the "
"`call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:346
msgid ""
"```bash+\n"
"starkli call "
"0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 "
"voter_can_vote "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc "
"http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:350
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:352
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:354
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:360
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:362
msgid "Casting a Vote"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:364
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external, "
"necessitating the use of the `starknet invoke` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:366
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we "
"submit either `1` (for Yes) or `0` (for No) as our input. When we invoke the "
"`vote` function, we are charged a fee, and the transaction must be signed by "
"the voter; we are writing to the contract's storage."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:376
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:382
msgid "This returns:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"transaction_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"max_fee\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"0x430e81\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:388
#: src/ch99-01-04-01-voting-contract.md:397
#: src/ch99-01-04-01-voting-contract.md:401
#: src/ch99-01-04-01-voting-contract.md:402
#: src/ch99-01-04-01-voting-contract.md:403
msgid "\"0x1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:389
msgid "\"signature\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:390
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:391
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"nonce\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"0x3\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"INVOKE\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"sender_address\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:396
msgid "\"calldata\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:398
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:399
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:400
msgid "\"0x0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:408
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:411
msgid "\"Contract error\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:414
msgid ""
"The error is not very informative, but you can get more details when looking "
"at the output in the terminal where you started `katana` (our local Starknet "
"node):"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:418
msgid ""
"\"Error in the called contract "
"(0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution "
"failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:424
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:430
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from "
"a public key, a smart wallet address, and the smart wallet class hash (which "
"is the same for each voter)."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:438
msgid "Visualizing Vote Outcomes"
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:440
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:446
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid "A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging "
"would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the "
"message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "The StarknetMessaging Contract"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the [`StarknetCore`]"
"(https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4) "
"contract. It is a set of Solidity contracts deployed on Ethereum that allows "
"Starknet to function properly. One of the contracts of `StarknetCore` is "
"called `StarknetMessaging` and it is the contract responsible for passing "
"messages between Starknet and Ethereum. `StarknetMessaging` follows an "
"[interface](https://github.com/starkware-libs/cairo-lang/"
"blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/"
"IStarknetMessaging.sol#L6) with functions allowing to send message to L2, "
"receiving messages on L1 from L2 and canceling messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid " Starknet messaging contract interface"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this tutorial](https://github.com/"
"glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol) where "
"we want to send a message to Starknet. The `_snMessaging` is a state "
"variable already initialized with the address of the `StarknetMessaging` "
"contract. You can check those addresses [here](https://docs.starknet.io/"
"documentation/tools/important_addresses/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:65
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:74
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:78
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of "
"your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be "
"executed by the sequencer is not bound to any account (the message "
"originates from L1), you must also ensure that you pay enough fees on L1 for "
"your message to be deserialized and processed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:112
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:113
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:123
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`. "
"There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "Sending messages from Starknet to Ethereum"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike `L1-"
">L2` messages, `L2->L1` messages must be consumed manually, which means that "
"you will need your Solidity contract to call the `consumeMessageFromL2` "
"function of the `StarknetMessaging` contract explicitly in order to consume "
"the message."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:138
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid ""
"We simply build the payload and pass it, along with the L1 contract address, "
"to the syscall function."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:158
msgid "// You can use the message hash if you want here.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:160
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256 "
"in Solidity).\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:161
msgid "\"Invalid payload\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:165
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:166
msgid "\"Invalid value\""
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:170
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs "
"(the contract address on L2 and the payload) to ensure we are only consuming "
"valid messages."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract "
"is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay "
"attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "Cairo Serde"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to "
"send a payload from L1 with **TWO** values."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:194
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Network_Architecture/messaging-mechanism/)."
msgstr ""

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging in local."
msgstr ""

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""

#: src/ch99-03-security-considerations.md:11
msgid "Disclaimer"
msgstr ""

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr ""

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr ""

#: src/ch99-03-security-considerations.md:17
msgid "Mindset"
msgstr ""

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""

#: src/ch99-03-security-considerations.md:23
msgid "Viewing smart contract as Finite State Machines"
msgstr ""

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr ""

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-panic."
"md) page."
msgstr ""

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr ""

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr ""

#: src/ch99-03-security-considerations.md:34
msgid "Execution requirements"
msgstr ""

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr ""

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr ""

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met, "
"the transaction will fail and the state of the contract will not change."
msgstr ""

#: src/ch99-03-security-considerations.md:45
msgid "\"Insufficient funds\""
msgstr ""

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly "
"define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""

#: src/ch99-03-security-considerations.md:53
msgid "Recommendations"
msgstr ""

#: src/ch99-03-security-considerations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr ""

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr ""

#: src/ch99-03-security-considerations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr ""

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr ""

#: src/ch99-03-security-considerations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr ""

#: src/ch99-03-security-considerations.md:67
msgid "Access control"
msgstr ""

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""

#: src/ch99-03-security-considerations.md:92
msgid "// Role 'owner': only one address\n"
msgstr ""

#: src/ch99-03-security-considerations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr ""

#: src/ch99-03-security-considerations.md:103
msgid "// Guard functions to check roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:118
msgid "\"Not owner\""
msgstr ""

#: src/ch99-03-security-considerations.md:123
msgid "\"Not role A\""
msgstr ""

#: src/ch99-03-security-considerations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr ""

#: src/ch99-03-security-considerations.md:128
msgid "\"Not allowed\""
msgstr ""

#: src/ch99-03-security-considerations.md:131
msgid "// Functions to manage roles\n"
msgstr ""

#: src/ch99-03-security-considerations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr ""

#: src/ch99-03-security-considerations.md:155
msgid "Static analysis tool"
msgstr ""

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code "
"against these standards."
msgstr ""

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr ""

#: src/ch99-03-security-considerations.md:163
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""

#: src/ch99-03-security-considerations.md:164
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Cairo language."
msgstr ""

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr ""

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr ""

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr ""

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr ""

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr ""

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`trait` - Define a trait"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr ""

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr ""

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr ""

#: src/appendix-01-keywords.md:50
msgid "Reserved keywords"
msgstr ""

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Cairo by "
"forbidding them to use these keywords."
msgstr ""

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr ""

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "Built-in functions"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""

#: src/appendix-01-keywords.md:85
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates "
"to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B: Operators and Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:9
msgid "Table B-1: Operators"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Operator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
#: src/appendix-02-operators-and-symbols.md:120
msgid "Explanation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:14
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Bitwise NOT"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
#: src/appendix-02-operators-and-symbols.md:40
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`%=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`RemEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Bitwise AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`&&`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr && expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "Short-circuiting logical AND"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
#: src/appendix-02-operators-and-symbols.md:23
msgid "`*`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`expr * expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:20
msgid "`Mul`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "Arithmetic multiplication and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "`MulEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:22
msgid "Snapshot"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "`*var`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:23
msgid "Desnap"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "`Add`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`var += expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic addition and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`AddEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`,`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr, expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:26
msgid "Argument and element separator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
#: src/appendix-02-operators-and-symbols.md:28
msgid "`-`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic negation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Neg`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "`Sub`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`-=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`var -= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "Arithmetic subtraction and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:29
msgid "`SubEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`->`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "`fn(...) -> type`, "
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "\\|...\\| -> type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "Function and closure return type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`.`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr.ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:31
msgid "Member access"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`Div`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`/=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`var /= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "Arithmetic division and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:33
msgid "`DivEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
#: src/appendix-02-operators-and-symbols.md:35
msgid "`:`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "`pat: type`, `ident: type`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:34
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:35
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:36
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:38
#: src/appendix-02-operators-and-symbols.md:42
#: src/appendix-02-operators-and-symbols.md:43
msgid "`PartialOrd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Less than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "`var = expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:39
msgid "Assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`==`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:40
msgid "Equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:41
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:42
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:43
msgid "Greater than or equal to comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "\\|\\|"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "expr \\|\\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "`?`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "expr?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:47
msgid "Error propagation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that "
"is, they do not have the same behavior as a function or method call."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:55
msgid "Table B-2: Stand-Alone Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "`..._u8`, `..._usize`, etc."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:59
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "Short string"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid "`_`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:61
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:63
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:65
msgid "Table B-3: Path-Related Syntax"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:69
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:70
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:73
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:75
msgid "Table B-4: Generics"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:79
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:80
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic function"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:86
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:88
msgid "Table B-5: Macros and Attributes"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:92
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:94
msgid "Table B-6 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:96
msgid "Table B-6: Comments"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "`//`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:100
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:104
msgid "Table B-7: Tuples"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "`()`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:108
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:109
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:111
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:112
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:113
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:116
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators-and-symbols.md:118
msgid "Table B-8: Curly Brackets"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:120
msgid "Context"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:122
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:123
msgid "`struct` literal"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr ""

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the "
"standard library don’t have sensible default behavior, so it’s up to you to "
"implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:9
msgid "Debug for Programmer Output"
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `Debug` trait allows you to print instances of a type for debugging "
"purposes, so you and other programmers using your type can inspect an "
"instance at a particular point in a program’s execution."
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid ""
"The `Debug` trait is required, for example, in use of the `assert_eq!` "
"macro. This macro prints the values of instances given as arguments if the "
"equality assertion fails so programmers can see why the two instances "
"weren’t equal."
msgstr ""

#: src/appendix-03-derivable-traits.md:17
msgid "PartialEq for equality comparison"
msgstr ""

#: src/appendix-03-derivable-traits.md:19
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:21
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:23
msgid ""
"The `PartialEq` trait is required, for example, with the use of the "
"`assert_eq!` macro, which needs to be able to compare two instances of a "
"type for equality."
msgstr ""

#: src/appendix-03-derivable-traits.md:44
msgid "Clone and Copy for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:46
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr ""

#: src/appendix-03-derivable-traits.md:48
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the "
"type must also implement `Clone` to derive `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:69
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy` "
"on any type whose parts all implement `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:85
msgid "// Copy Trait prevents firs_struct from moving into second_struct\n"
msgstr ""

#: src/appendix-03-derivable-traits.md:89
msgid "Serializing with Serde"
msgstr ""

#: src/appendix-03-derivable-traits.md:91
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""

#: src/appendix-03-derivable-traits.md:116
msgid "Output:"
msgstr ""

#: src/appendix-03-derivable-traits.md:119
msgid "''"
msgstr ""

#: src/appendix-03-derivable-traits.md:119
msgid "'c'"
msgstr ""

#: src/appendix-03-derivable-traits.md:122
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr ""

#: src/appendix-03-derivable-traits.md:124
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back "
"into our A struct."
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""

#: src/appendix-03-derivable-traits.md:153
msgid "Drop and Destruct"
msgstr ""

#: src/appendix-03-derivable-traits.md:155
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage [here]"
"(ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:157
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` [here]"
"(ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""

#: src/appendix-03-derivable-traits.md:159
msgid "Store"
msgstr ""

#: src/appendix-03-derivable-traits.md:161
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet "
"contract requires the `Store` trait to be implemented for this type. You can "
"automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""

#: src/appendix-03-derivable-traits.md:182
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the "
"Store trait. This `struct A` is subsequently used as a storage variable in "
"the contract."
msgstr ""

#: src/appendix-03-derivable-traits.md:185
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:187
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the "
"`PartialOrd` and `Ord` traits to compare values for ordering."
msgstr ""

#: src/appendix-03-derivable-traits.md:189
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for "
"ordering, thereby enabling the \\<, \\<=, >, and >= operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:191
msgid ""
"When `PartialOrd` is derived on structs, two instances are ordered by "
"comparing each field in turn."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:16
msgid "IDE Integration Using `cairo-language-server`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-"
"language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/"
"cairo-lang-language-server)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language "
"Server Protocol](http://langserver.org/)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate "
"with each other. Different clients can use `cairo-language-server`, such as "
"[the Cairo extension for Visual Studio Code](https://marketplace."
"visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` [page](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1)"
msgstr ""

#: src/appendix-04-useful-development-tools.md:28
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, "
"jump to definition, and inline errors."
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language server."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude "
"provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the [lib.cairo](https://github.com/"
"starkware-libs/cairo/blob/v2.4.0/corelib/src/lib.cairo) file of the corelib "
"crate and contains Cairo's primitive data types, traits, operators, and "
"utility functions. This includes: Data types - felts, bools, arrays, dicts, "
"etc. Traits - behaviors for arithmetic, comparison, serialization Operators "
"- arithmetic, logical, bitwise Utility functions - helpers for arrays, maps, "
"boxing, etc. The core library prelude delivers the fundamental programming "
"constructs and operations needed for basic Cairo programs, without requiring "
"the explicit import of elements. Since the core library prelude is "
"automatically imported, its contents are available for use in any Cairo "
"crate without explicit imports. This prevents repetition and provides a "
"better devX. This is what allows you to use `ArrayTrait::append()` or the "
"`Default` trait without bringing them explicitly into scope."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_10\"` in `Scarb.toml` configuration file will load the prelude from "
"October 2023, which is more restricted than the one from January 2023. The "
"compiler currently exposes 2 different versions of the prelude:"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:28
msgid ""
"A restricted version, including the most essential traits needed for general "
"cairo programming, corresponding to `edition = 2023_10`."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:30
msgid "List of common types and traits"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:32
msgid ""
"The following section provides a brief overview of commonly used types and "
"traits when developing Cairo programs. Most of these are included in the "
"prelude and not required to be imported explicitly - but not all of them."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Import"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Path"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Usage"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`core::option::OptionTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`OptionTrait<T>` defines a set of methods required to manipulate optional "
"value."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`core::result::ResultTrait`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`ResultTrait<T, E>` Type for Starknet contract address, a value in the range "
"\\[0, 2 \\*\\* 251)."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::ContractAddress`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of `t:"
"ContractAddress` is zero or not."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`starknet::contract_address_const`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid ""
"The `contract_address_const!` it's a function that allows instantiating "
"constant contract address values."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`Into`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an "
"implementation of Into\\<T,S> for the types T and S, you can convert T into "
"S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an "
"implementation of TryInto\\<T,S> for the types T and S, you can convert T "
"into S."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`starknet::get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid ""
"`get_caller_address()` is a function that returns the address of the caller "
"of the contract. It can be used to identify the caller of a contract "
"function."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid ""
"`get_contract_address()` is a function that returns the address of the "
"current contract. It can be used to obtain the address of the contract being "
"executed."
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:48
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr ""

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""

#: src/appendix-06-cairo-binaries.md:7
msgid "Prerequisites"
msgstr ""

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:12
msgid "# Install stable Rust\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:18
msgid ""
"Installing Cairo with a Script ([Installer](https://github.com/franalgaba/"
"cairo-installer) by [Fran](https://github.com/franalgaba))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:20
msgid "Install"
msgstr ""

#: src/appendix-06-cairo-binaries.md:22
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-environment-"
"for-cairo) to set up your shell environment."
msgstr ""

#: src/appendix-06-cairo-binaries.md:30
msgid "Update"
msgstr ""

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-"
"installer | bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:37
msgid "Uninstall"
msgstr ""

#: src/appendix-06-cairo-binaries.md:39
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:48
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:57
msgid "Set up your shell environment for Cairo"
msgstr ""

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr ""

#: src/appendix-06-cairo-binaries.md:65
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr ""

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc` "
"(for interactive shells) and the profile file that Bash would use (for login "
"shells)."
msgstr ""

#: src/appendix-06-cairo-binaries.md:75
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:78 src/appendix-06-cairo-binaries.md:88
#: src/appendix-06-cairo-binaries.md:94 src/appendix-06-cairo-binaries.md:101
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:79 src/appendix-06-cairo-binaries.md:89
#: src/appendix-06-cairo-binaries.md:95 src/appendix-06-cairo-binaries.md:102
msgid ""
"'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/"
"release:$PATH\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to `~/."
"profile`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent from Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""

#: src/appendix-06-cairo-binaries.md:129
msgid "Restart your shell"
msgstr ""

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr ""

#: src/appendix-06-cairo-binaries.md:134
msgid "\"$SHELL\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:137
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""

#: src/appendix-06-cairo-binaries.md:139
msgid "Step 1: Install Cairo 1.0"
msgstr ""

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""

#: src/appendix-06-cairo-binaries.md:143
msgid "For everyone else, we recommend compiling Cairo from source as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:146
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:147
msgid "\"${HOME}/.cairo\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:148
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:151
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:154
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the "
"compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:157
msgid "# View tags (you can also do this in the cairo compiler repository)\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:159
msgid "# Checkout the version you want\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:162
msgid "# Generate release binaries\n"
msgstr ""

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to "
"do is pull the latest changes and rebuild as follows:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:178
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr ""

#: src/appendix-06-cairo-binaries.md:181
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:184
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr ""

#: src/appendix-06-cairo-binaries.md:186
msgid "Step 3: Setup Language Server"
msgstr ""

#: src/appendix-06-cairo-binaries.md:188
msgid "VS Code Extension"
msgstr ""

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"If you have the previous Cairo 0 extension installed, you can disable/"
"uninstall it."
msgstr ""

#: src/appendix-06-cairo-binaries.md:191
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension [here](https://"
"marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false), or "
"just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""

#: src/appendix-06-cairo-binaries.md:192
msgid ""
"The extension will work out of the box once you will have [Scarb](./ch01-03-"
"hello-scarb.md) installed."
msgstr ""

#: src/appendix-06-cairo-binaries.md:194
msgid "Cairo Language Server without Scarb"
msgstr ""

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""

#: src/appendix-06-cairo-binaries.md:203
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting "
"the path."
msgstr ""

#: src/appendix-07-system-calls.md:1
msgid "System Calls"
msgstr ""

#: src/appendix-07-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/"
"Smart_Contracts/system-calls-cairo1/)."
msgstr ""

#: src/appendix-07-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""

#: src/appendix-07-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""

#: src/appendix-07-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr ""

#: src/appendix-07-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr ""

#: src/appendix-07-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr ""

#: src/appendix-07-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr ""

#: src/appendix-07-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr ""

#: src/appendix-07-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr ""

#: src/appendix-07-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr ""

#: src/appendix-07-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr ""

#: src/appendix-07-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr ""

#: src/appendix-07-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr ""

#: src/appendix-07-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr ""

#: src/appendix-07-system-calls.md:22
msgid "`get_block_hash`"
msgstr ""

#: src/appendix-07-system-calls.md:24 src/appendix-07-system-calls.md:51
#: src/appendix-07-system-calls.md:79 src/appendix-07-system-calls.md:117
#: src/appendix-07-system-calls.md:153 src/appendix-07-system-calls.md:198
#: src/appendix-07-system-calls.md:230 src/appendix-07-system-calls.md:273
#: src/appendix-07-system-calls.md:305 src/appendix-07-system-calls.md:348
msgid "Syntax"
msgstr ""

#: src/appendix-07-system-calls.md:32 src/appendix-07-system-calls.md:59
#: src/appendix-07-system-calls.md:87 src/appendix-07-system-calls.md:128
#: src/appendix-07-system-calls.md:161 src/appendix-07-system-calls.md:206
#: src/appendix-07-system-calls.md:238 src/appendix-07-system-calls.md:281
#: src/appendix-07-system-calls.md:313 src/appendix-07-system-calls.md:356
msgid "Description"
msgstr ""

#: src/appendix-07-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""

#: src/appendix-07-system-calls.md:36 src/appendix-07-system-calls.md:69
#: src/appendix-07-system-calls.md:103 src/appendix-07-system-calls.md:139
#: src/appendix-07-system-calls.md:173 src/appendix-07-system-calls.md:220
#: src/appendix-07-system-calls.md:252 src/appendix-07-system-calls.md:295
#: src/appendix-07-system-calls.md:327 src/appendix-07-system-calls.md:372
msgid "Return values"
msgstr ""

#: src/appendix-07-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr ""

#: src/appendix-07-system-calls.md:40
msgid "Error messages"
msgstr ""

#: src/appendix-07-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr ""

#: src/appendix-07-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr ""

#: src/appendix-07-system-calls.md:45 src/appendix-07-system-calls.md:73
#: src/appendix-07-system-calls.md:107 src/appendix-07-system-calls.md:147
#: src/appendix-07-system-calls.md:192 src/appendix-07-system-calls.md:224
#: src/appendix-07-system-calls.md:267 src/appendix-07-system-calls.md:299
#: src/appendix-07-system-calls.md:342 src/appendix-07-system-calls.md:376
msgid "Common library"
msgstr ""

#: src/appendix-07-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls."
"cairo#L37)"
msgstr ""

#: src/appendix-07-system-calls.md:49
msgid "`get_execution_info`"
msgstr ""

#: src/appendix-07-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr ""

#: src/appendix-07-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr ""

#: src/appendix-07-system-calls.md:65 src/appendix-07-system-calls.md:97
#: src/appendix-07-system-calls.md:132 src/appendix-07-system-calls.md:167
#: src/appendix-07-system-calls.md:212 src/appendix-07-system-calls.md:246
#: src/appendix-07-system-calls.md:291 src/appendix-07-system-calls.md:321
#: src/appendix-07-system-calls.md:364
msgid "Arguments"
msgstr ""

#: src/appendix-07-system-calls.md:67 src/appendix-07-system-calls.md:175
#: src/appendix-07-system-calls.md:254 src/appendix-07-system-calls.md:297
#: src/appendix-07-system-calls.md:374
msgid "None."
msgstr ""

#: src/appendix-07-system-calls.md:71
msgid ""
"Returns a [struct](https://github.com/starkware-libs/cairo/blob/"
"efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) "
"containing the execution info."
msgstr ""

#: src/appendix-07-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L35)"
msgstr ""

#: src/appendix-07-system-calls.md:77
msgid "`call_contract`"
msgstr ""

#: src/appendix-07-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call arguments."
msgstr ""

#: src/appendix-07-system-calls.md:91 src/appendix-07-system-calls.md:285
msgid "**Note:**"
msgstr ""

#: src/appendix-07-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr ""

#: src/appendix-07-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr ""

#: src/appendix-07-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr ""

#: src/appendix-07-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract."
msgstr ""

#: src/appendix-07-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr ""

#: src/appendix-07-system-calls.md:105 src/appendix-07-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr ""

#: src/appendix-07-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L10)"
msgstr ""

#: src/appendix-07-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""

#: src/appendix-07-system-calls.md:115
msgid "`deploy`"
msgstr ""

#: src/appendix-07-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr ""

#: src/appendix-07-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr ""

#: src/appendix-07-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender, used in the computation of the contract’s address."
msgstr ""

#: src/appendix-07-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr ""

#: src/appendix-07-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""

#: src/appendix-07-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr ""

#: src/appendix-07-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr ""

#: src/appendix-07-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of "
"type `Span::<felt252>`."
msgstr ""

#: src/appendix-07-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/"
"blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls."
"cairo#L22)"
msgstr ""

#: src/appendix-07-system-calls.md:151
msgid "`emit_event`"
msgstr ""

#: src/appendix-07-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr ""

#: src/appendix-07-system-calls.md:165
msgid ""
"For more information, and for a higher-level syntax for emitting events, see "
"[Starknet events](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/starknet-events/)."
msgstr ""

#: src/appendix-07-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""

#: src/appendix-07-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr ""

#: src/appendix-07-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and "
"`deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""

#: src/appendix-07-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L30)"
msgstr ""

#: src/appendix-07-system-calls.md:196
msgid "`library_call`"
msgstr ""

#: src/appendix-07-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr ""

#: src/appendix-07-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr ""

#: src/appendix-07-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr ""

#: src/appendix-07-system-calls.md:216
msgid "_`function_selector`_: A selector for a function within that class."
msgstr ""

#: src/appendix-07-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr ""

#: src/appendix-07-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L43)"
msgstr ""

#: src/appendix-07-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr ""

#: src/appendix-07-system-calls.md:240
msgid "Sends a message to L1."
msgstr ""

#: src/appendix-07-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 once "
"the state update, including the transaction, is received."
msgstr ""

#: src/appendix-07-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging mechanism](https://docs."
"starknet.io/documentation/architecture_and_concepts/Network_Architecture/"
"messaging-mechanism/)."
msgstr ""

#: src/appendix-07-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr ""

#: src/appendix-07-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr ""

#: src/appendix-07-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr ""

#: src/appendix-07-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L51)"
msgstr ""

#: src/appendix-07-system-calls.md:271
msgid "`replace_class`"
msgstr ""

#: src/appendix-07-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the "
"syscall is called) will be replaced by the class whose hash is given by the "
"class_hash argument."
msgstr ""

#: src/appendix-07-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr ""

#: src/appendix-07-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""

#: src/appendix-07-system-calls.md:293
msgid "_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr ""

#: src/appendix-07-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L77)"
msgstr ""

#: src/appendix-07-system-calls.md:303
msgid "`storage_read`"
msgstr ""

#: src/appendix-07-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-07-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that "
"are defined explicitly in the contract."
msgstr ""

#: src/appendix-07-system-calls.md:319 src/appendix-07-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage variables](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-storage/"
"#storage_variables)."
msgstr ""

#: src/appendix-07-system-calls.md:323 src/appendix-07-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""

#: src/appendix-07-system-calls.md:325 src/appendix-07-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr ""

#: src/appendix-07-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr ""

#: src/appendix-07-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L60)"
msgstr ""

#: src/appendix-07-system-calls.md:346
msgid "`storage_write`"
msgstr ""

#: src/appendix-07-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr ""

#: src/appendix-07-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables "
"that are defined explicitly in the contract."
msgstr ""

#: src/appendix-07-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr ""

#: src/appendix-07-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/"
"cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls."
"cairo#L70)"
msgstr ""

#~ msgid "Genel Programlama Kavramları"
#~ msgstr "Genel Programlama Kavramları"

#~ msgid "Değişkenler ve Değişkenlik"
#~ msgstr "Değişkenler ve Değişkenlik"
