#
msgid ""
msgstr ""
"Project-Id-Version: The Cairo Programming Language\n"
"POT-Creation-Date: 2024-02-08T05:36:14+03:00\n"
"PO-Revision-Date: 2024-06-18 10:19+0900\n"
"Last-Translator: Giwook <giwook@doorlabs.io>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Cairo Programming Language"
msgstr "카이로 프로그래밍 언어"

#: src/SUMMARY.md:3
msgid "The Cairo Programming Language Foreword Introduction"
msgstr "카이로 프로그래밍 언어 서문 소개"

#: src/SUMMARY.md:7 src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr "시작하기"

#: src/SUMMARY.md:11 src/ch01-01-installation.md:1
#: src/ch01-01-installation.md:19
msgid "Installation"
msgstr "설치"

#: src/SUMMARY.md:12
msgid "Hello, World!"
msgstr "Hello, World!"

#: src/SUMMARY.md:14 src/SUMMARY.md:16
#: src/ch02-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr "일반적인 프로그래밍 개념들"

#: src/SUMMARY.md:17 src/ch02-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "변수와 가변성"

#: src/SUMMARY.md:18 src/ch02-02-data-types.md:1
msgid "Data Types"
msgstr "자료형"

#: src/SUMMARY.md:19 src/ch02-03-functions.md:1
msgid "Functions"
msgstr "함수"

#: src/SUMMARY.md:20 src/ch02-04-comments.md:1
msgid "Comments"
msgstr "주석"

#: src/SUMMARY.md:21 src/ch02-05-control-flow.md:1
msgid "Control Flow"
msgstr "제어 흐름"

#: src/SUMMARY.md:23 src/SUMMARY.md:25 src/ch03-00-common-collections.md:1
msgid "Common Collections"
msgstr "일반적인 컬렉션"

#: src/SUMMARY.md:26 src/ch03-01-arrays.md:1
msgid "Arrays"
msgstr "배열"

#: src/SUMMARY.md:27 src/ch03-02-dictionaries.md:1
msgid "Dictionaries"
msgstr "사전"

#: src/SUMMARY.md:28 src/ch03-03-custom-data-structures.md:1
msgid "Custom Data Structures"
msgstr "사용자 정의 데이터 구조"

#: src/SUMMARY.md:30 src/SUMMARY.md:32
msgid "Understanding Ownership"
msgstr "오너십 이해"

#: src/SUMMARY.md:33
msgid "What is Ownership?"
msgstr "오너십이란?"

#: src/SUMMARY.md:34 src/ch04-02-references-and-snapshots.md:1
msgid "References and Snapshots"
msgstr "참조와 스냅샷"

#: src/SUMMARY.md:36 src/SUMMARY.md:38
#: src/ch05-00-using-structs-to-structure-related-data.md:1
msgid "Using Structs to Structure Related Data"
msgstr "구조체를 사용하여 관련 데이터 구조화"

#: src/SUMMARY.md:39 src/ch05-01-defining-and-instantiating-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "구조체 정의 및 인스턴스화"

#: src/SUMMARY.md:40 src/ch05-02-an-example-program-using-structs.md:1
msgid "An Example Program Using Structs"
msgstr "구조체를 사용한 예제 프로그램"

#: src/SUMMARY.md:41
msgid "Method Syntax"
msgstr "메서드 구문"

#: src/SUMMARY.md:43 src/SUMMARY.md:45
#: src/ch06-00-enums-and-pattern-matching.md:1
msgid "Enums and Pattern Matching"
msgstr "열거형과 패턴 매칭"

#: src/SUMMARY.md:46 src/ch06-01-enums.md:1
#: src/ch08-01-generic-data-types.md:186
msgid "Enums"
msgstr "열거형"

#: src/SUMMARY.md:47 src/ch06-02-the-match-control-flow-construct.md:1
msgid "The Match Control Flow Construct"
msgstr "match 흐름 제어 구조"

#: src/SUMMARY.md:49 src/SUMMARY.md:51
#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:1
msgid "Managing Cairo Projects with Packages, Crates and Modules"
msgstr "패키지, 크레이트 및 모듈을 이용한 카이로 프로젝트 관리"

#: src/SUMMARY.md:53 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "패키지와 크레이트"

#: src/SUMMARY.md:54 src/ch07-02-defining-modules-to-control-scope.md:1
msgid "Defining Modules to Control Scope"
msgstr "범위 제어를 위한 모듈 정의"

#: src/SUMMARY.md:55
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "모듈 트리에서 항목을 참조하는 경로"

#: src/SUMMARY.md:56
msgid "Bringing Paths into Scope with the 'use' Keyword"
msgstr "'use' 키워드를 사용하여 범위에 경로 가져오기"

#: src/SUMMARY.md:57 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "다른 파일로 모듈 분리하기"

#: src/SUMMARY.md:59 src/ch08-01-generic-data-types.md:1
msgid "Generic Data Types"
msgstr "제네릭 데이터 타입"

#: src/SUMMARY.md:61
msgid "Generic Types"
msgstr "제네릭 타입"

#: src/SUMMARY.md:63 src/ch08-01-generic-data-types.md:5
msgid "Generic Functions"
msgstr "제네릭 함수"

#: src/SUMMARY.md:64
msgid "Traits in Cairo"
msgstr "카이로에서의 트레잇"

#: src/SUMMARY.md:66 src/SUMMARY.md:68 src/ch09-00-testing-cairo-programs.md:1
msgid "Testing Cairo Programs"
msgstr "카이로 프로그램 테스트"

#: src/SUMMARY.md:70 src/ch09-01-how-to-write-tests.md:1
msgid "How To Write Tests"
msgstr "테스트 작성 방법"

#: src/SUMMARY.md:71
msgid "Testing Organization"
msgstr "테스트 구성"

#: src/SUMMARY.md:73 src/SUMMARY.md:75
msgid "Error Handling"
msgstr "오류 처리"

#: src/SUMMARY.md:77 src/ch10-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with panic"
msgstr "패닉과 함께 복구할 수 없는 오류"

#: src/SUMMARY.md:78
msgid "Recoverable Errors with Result"
msgstr "결과와 복구 가능한 오류"

#: src/SUMMARY.md:80 src/SUMMARY.md:82 src/ch11-00-advanced-features.md:1
msgid "Advanced Features"
msgstr "고급 기능"

#: src/SUMMARY.md:84 src/ch11-01-operator-overloading.md:1
msgid "Operator Overloading"
msgstr "연산자 오버로딩"

#: src/SUMMARY.md:85 src/ch11-02-macros.md:1
msgid "Macros"
msgstr "매크로"

#: src/SUMMARY.md:86 src/ch11-03-hash.md:19
msgid "Working with Hashes"
msgstr "해시와 함께 작업하기"

#: src/SUMMARY.md:88
msgid "Starknet smart contracts"
msgstr "스타크넷 스마트 계약"

#: src/SUMMARY.md:90 src/ch99-00-starknet-smart-contracts.md:1
msgid "Starknet Smart Contracts"
msgstr "스타크넷 스마트 계약"

#: src/SUMMARY.md:92 src/ch99-01-01-introduction-to-smart-contracts.md:1
msgid "Introduction to smart-contracts"
msgstr "스마트 계약 소개"

#: src/SUMMARY.md:93 src/ch99-01-02-a-simple-contract.md:1
msgid "A simple contract"
msgstr "간단한 계약"

#: src/SUMMARY.md:94 src/ch99-01-03-00-a-deeper-dive-into-contracts.md:1
msgid "A deeper dive into contracts"
msgstr "계약에 대한 심층적인 탐구"

#: src/SUMMARY.md:96 src/ch99-01-03-01-contract-storage.md:1
msgid "Contract Storage"
msgstr "계약 보관"

#: src/SUMMARY.md:97 src/ch99-01-03-02-contract-functions.md:1
msgid "Contract Functions"
msgstr "계약 기능"

#: src/SUMMARY.md:98
msgid "Contract Events"
msgstr "계약 이벤트"

#: src/SUMMARY.md:99 src/ch99-01-03-04-reducing-boilerplate.md:1
msgid "Reducing boilerplate"
msgstr "보일러플레이트 줄이기"

#: src/SUMMARY.md:100
msgid "Optimizing storage costs"
msgstr "저장 비용 최적화"

#: src/SUMMARY.md:102
msgid "Components"
msgstr "구성 요소"

#: src/SUMMARY.md:104
msgid "Under the hood"
msgstr "머리카락 아래"

#: src/SUMMARY.md:105 src/ch99-01-05-02-component-dependencies.md:1
msgid "Component dependencies"
msgstr "구성 요소 의존성"

#: src/SUMMARY.md:106 src/ch99-01-05-03-testing-components.md:1
msgid "Testing components"
msgstr "구성 요소 테스트"

#: src/SUMMARY.md:108
msgid "ABIs and Cross-contract Interactions"
msgstr "ABIs 및 교차 계약 상호 작용"

#: src/SUMMARY.md:110
msgid "ABIs and Interfaces"
msgstr "ABIs와 인터페이스"

#: src/SUMMARY.md:111
msgid "Contract Dispatchers, Library Dispatchers and system calls"
msgstr "계약 디스패처, 도서관 디스패처 및 시스템 호출"

#: src/SUMMARY.md:113 src/ch99-01-04-00-other-examples.md:1
msgid "Other examples"
msgstr "다른 예시"

#: src/SUMMARY.md:115 src/ch99-01-04-01-voting-contract.md:1
msgid "Deploying and Interacting with a Voting contract"
msgstr "투표 계약을 배포하고 상호 작용하기"

#: src/SUMMARY.md:117
msgid "L1 \\<\\> L2 Messaging"
msgstr "L1 \\<\\> L2 메시징"

#: src/SUMMARY.md:118 src/ch99-03-security-considerations.md:1
msgid "Security Considerations"
msgstr "보안 고려 사항"

#: src/SUMMARY.md:120 src/appendix-00.md:1
msgid "Appendix"
msgstr "부록"

#: src/SUMMARY.md:122
msgid "A - Keywords"
msgstr "A - 키워드"

#: src/SUMMARY.md:123
msgid "B - Operators and Symbols"
msgstr "B - 연산자 및 기호"

#: src/SUMMARY.md:124
msgid "C - Derivable Traits"
msgstr "C - 유도 가능한 특성"

#: src/SUMMARY.md:125
msgid "D - Useful Development Tools"
msgstr "D - 유용한 개발 도구"

#: src/SUMMARY.md:126
msgid "E - Common Types & Traits and the Cairo Prelude"
msgstr "E - 일반 유형 및 특성 및 카이로 프렐류드"

#: src/SUMMARY.md:127
msgid "F - Installing Cairo binaries"
msgstr "F - 카이로 이진 파일 설치"

#: src/SUMMARY.md:128
msgid "G - System Calls"
msgstr "G - 시스템 호출"

#: src/title-page.md:3
msgid ""
"By the Cairo Community and its [contributors](https://github.com/cairo-"
"book/cairo-book.github.io). Special thanks to "
"[Starkware](https://starkware.co/) through "
"[OnlyDust](https://www.onlydust.xyz/), and "
"[Voyager](https://voyager.online/) for supporting the creation of this book."
msgstr ""
"카이로 커뮤니티와 [기여자들](https://github.com/cairo-book/cairo-book.github.io)에 의해 "
"제작되었습니다. 이 책 제작을 지원해준 [Starkware](https://starkware.co/)의 "
"[OnlyDust](https://www.onlydust.xyz/)와 [Voyager](https://voyager.online/)에 "
"특별히 감사드립니다."

#: src/title-page.md:5
msgid ""
"This version of the text assumes you’re using the [Cairo "
"Compiler](https://github.com/starkware-libs/cairo) [version "
"2.5.1](https://github.com/starkware-libs/cairo/releases). See the "
"“Installation” section of Chapter 1 to install or update Cairo."
msgstr ""
"이 텍스트 버전은 [Cairo Compiler](https://github.com/starkware-libs/cairo) [버전 "
"2.5.1](https://github.com/starkware-libs/cairo/releases)을 사용한다고 가정합니다. "
"Cairo를 설치하거나 업데이트하려면 1장의 \"설치\" 섹션을 참조하십시오."

#: src/ch00-01-foreword.md:1
msgid "Foreword"
msgstr "서문"

#: src/ch00-01-foreword.md:3
msgid ""
"In 2020, StarkWare released Cairo 0, a Turing-complete programming language "
"supporting verifiable computation. Cairo started as an assembly language and"
" gradually became more expressive. The learning curve was initially steep, "
"as Cairo 0.x was a low-level language that did not entirely abstract the "
"underlying cryptographic primitives required to build a proof for the "
"execution of a program."
msgstr ""
"2020년에 StarkWare는 검증 가능한 계산을 지원하는 Turing-complete 프로그래밍 언어인 Cairo 0을 출시했습니다."
" Cairo는 어셈블리 언어로 시작하여 점차 표현력이 향상되었습니다. 학습 곡선은 처음에 가파르며, Cairo 0.x는 프로그램 실행에 "
"대한 증명을 구축하는 데 필요한 기본 암호학적 기본 요소를 완전히 추상화하지 않은 저수준 언어였습니다."

#: src/ch00-01-foreword.md:5
msgid ""
"With the release of Cairo 1, the developer experience has considerably "
"improved, abstracting away the underlying immutable memory model of the "
"Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has "
"been built to help you create provable programs without specific knowledge "
"of its underlying architecture so that you can focus on the program itself, "
"increasing the overall security of Cairo programs. Powered by a Rust VM, the"
" execution of Cairo programs is now _blazingly_ fast, allowing you to build "
"an extensive test suite without compromising on performance."
msgstr ""
"카이로 1의 출시로 개발자 경험이 상당히 향상되었으며, 가능한 경우 카이로 아키텍처의 기본 불변 메모리 모델을 추상화했습니다. 러스트에 "
"강한 영감을 받아, 카이로 1은 당신이 프로그램 자체에 집중할 수 있도록 기본 아키텍처에 대한 특정 지식 없이 증명 가능한 프로그램을 "
"만들 수 있도록 설계되었습니다. 러스트 VM을 기반으로 한 카이로 프로그램의 실행은 이제 _매우_ 빠르며, 성능을 희생하지 않고 광범위한"
" 테스트 스위트를 구축할 수 있습니다."

#: src/ch00-01-foreword.md:7
msgid ""
"Blockchain developers that want to deploy contracts on Starknet will use the"
" Cairo programming language to code their smart contracts. This allows the "
"Starknet OS to generate execution traces for transactions to be proved by a "
"prover, which is then verified on Ethereum L1 prior to updating the state "
"root of Starknet."
msgstr ""
"스타크넷에 계약을 배포하려는 블록체인 개발자들은 스마트 계약을 코딩하기 위해 카이로 프로그래밍 언어를 사용할 것입니다. 이는 스타크넷 "
"OS가 실행 추적을 생성하여 증명자가 증명할 거래에 대한 것을 생성하게 하며, 그 후에는 스타크넷의 상태 루트를 업데이트하기 전에 "
"이더리움 L1에서 검증됩니다."

#: src/ch00-01-foreword.md:9
msgid ""
"However, Cairo is not only for blockchain developers. As a general purpose "
"programming language, it can be used for any computation that would benefit "
"from being proved on one computer and verified on other machines with lower "
"hardware requirements."
msgstr ""
"그러나 카이로는 블록체인 개발자들을 위한 것만이 아닙니다. 일반 목적의 프로그래밍 언어로서, 한 컴퓨터에서 증명되고 다른 하드웨어 요구 "
"사양이 낮은 다른 기계에서 확인되는 계산에 사용될 수 있습니다."

#: src/ch00-01-foreword.md:11
msgid ""
"This book is designed for developers with a basic understanding of "
"programming concepts. It is a friendly and approachable text intended to "
"help you level up your knowledge of Cairo, but also help you develop your "
"programming skills in general. So, dive in and get ready to learn all there "
"is to know about Cairo!"
msgstr ""
"이 책은 프로그래밍 개념에 기본적인 이해를 가진 개발자들을 대상으로 설계되었습니다. 친근하고 접근하기 쉬운 텍스트로, 카이로에 대한 "
"지식을 높이는 데 도움을 주는 것은 물론, 프로그래밍 기술을 전반적으로 향상시키는 데도 도움이 되도록 의도되었습니다. 그러니, 들어가서 "
"카이로에 대해 알아야 할 모든 것을 배우기 위해 준비하세요!"

#: src/ch00-01-foreword.md:13
msgid "Acknowledgements"
msgstr "감사의 글"

#: src/ch00-01-foreword.md:15
msgid ""
"This book would not have been possible without the help of the Cairo "
"community. We would like to thank every contributor for their contributions "
"to this book!"
msgstr "이 책은 카이로 커뮤니티의 도움 없이는 불가능했을 것입니다. 이 책에 기여해 주신 모든 분들께 감사드립니다!"

#: src/ch00-01-foreword.md:17
msgid ""
"We would like to thank the Rust community for the [Rust "
"Book](https://doc.rust-lang.org/book/), which has been a great source of "
"inspiration for this book. Many examples and explanations have been adapted "
"from the Rust Book to fit the Cairo programming language, as the two "
"languages share many similarities."
msgstr ""
"우리는 [Rust Book](https://doc.rust-lang.org/book/)에 대해 Rust 커뮤니티에 감사드리고 싶습니다. "
"이 책은 이 책에 큰 영감을 주었습니다. 많은 예제와 설명이 Rust Book에서 채택되어 Cairo 프로그래밍 언어에 맞게 "
"조정되었는데, 두 언어는 많은 유사성을 공유합니다."

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr "소개"

#: src/ch00-00-introduction.md:3
msgid "What is Cairo?"
msgstr "카이로는 무엇인가요?"

#: src/ch00-00-introduction.md:5
msgid ""
"Cairo is a programming language designed for a virtual CPU of the same name."
" The unique aspect of this processor is that it was not created for the "
"physical constraints of our world but for cryptographic ones, making it "
"capable of efficiently proving the execution of any program running on it. "
"This means that you can perform time consuming operations on a machine you "
"don't trust, and check the result very quickly on a cheaper machine. While "
"Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo "
"1 is a higher level language. It first compiles to Sierra, an intermediate "
"representation of Cairo which will compile later down to a safe subset of "
"CASM. The point of Sierra is to ensure your CASM will always be provable, "
"even when the computation fails."
msgstr ""
"카이로는 동일한 이름의 가상 CPU를 위해 설계된 프로그래밍 언어입니다. 이 프로세서의 독특한 측면은 우리 세계의 물리적 제약을 위해 "
"만들어진 것이 아니라 암호학적 제약을 위해 만들어졌다는 것입니다. 이는 그 위에서 실행되는 모든 프로그램의 실행을 효율적으로 증명할 수 "
"있게 만들어줍니다. 이는 신뢰할 수 없는 기계에서 시간이 많이 소요되는 작업을 수행하고, 결과를 더 저렴한 기계에서 매우 빠르게 확인할 "
"수 있다는 것을 의미합니다. 카이로 0은 처음에 CASM, 카이로 CPU 어셈블리로 직접 컴파일되었지만, 카이로 1은 더 높은 수준의 "
"언어입니다. 먼저 카이로의 중간 표현인 시에라로 컴파일되며, 이후에 CASM의 안전한 하위 집합으로 컴파일됩니다. 시에라의 목적은 계산이"
" 실패해도 CASM이 항상 증명 가능하도록 하는 것입니다."

#: src/ch00-00-introduction.md:8
msgid "What can you do with it?"
msgstr "그것으로 무엇을 할 수 있나요?"

#: src/ch00-00-introduction.md:10
msgid ""
"Cairo allows you to compute trustworthy values on untrusted machines. One "
"major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a "
"decentralized blockchain platform that enables the creation of decentralized"
" applications where every single interaction between a user and a d-app is "
"verified by all the participants. Starknet is a Layer 2 built on top of "
"Ethereum. Instead of having all the participants of the network to verify "
"all user interactions, only one node, called the prover, executes the "
"programs and generates proofs that the computations were done correctly. "
"These proofs are then verified by an Ethereum smart contract, requiring "
"significantly less computational power compared to executing the "
"interactions themselves. This approach allows for increased throughput and "
"reduced transaction costs while preserving Ethereum security."
msgstr ""
"카이로는 신뢰할 수 있는 값을 신뢰할 수 없는 기계에서 계산할 수 있게 합니다. 주요 사용 사례 중 하나는 이더리움 확장 솔루션인 "
"Starknet입니다. 이더리움은 사용자와 d-앱 간의 모든 상호 작용이 모든 참여자에 의해 확인되는 탈중앙화된 블록체인 플랫폼입니다. "
"Starknet은 이더리움 위에 구축된 Layer 2입니다. 네트워크의 모든 참여자가 모든 사용자 상호 작용을 확인하는 대신, 증명자라고"
" 불리는 단일 노드만 프로그램을 실행하고 계산이 올바르게 수행되었음을 증명하는 증명을 생성합니다. 이 증명은 이후에 이더리움 스마트 "
"계약에 의해 확인되며, 상호 작용 자체를 실행하는 것에 비해 상당히 적은 계산 능력이 필요합니다. 이 접근 방식은 이더리움 보안을 "
"유지하면서 처리량을 증가시키고 거래 비용을 줄일 수 있게 합니다."

#: src/ch00-00-introduction.md:12
msgid "What are the differences with other programming languages?"
msgstr "다른 프로그래밍 언어와의 차이점은 무엇인가요?"

#: src/ch00-00-introduction.md:14
msgid ""
"Cairo is quite different from traditional programming languages, especially "
"when it comes to overhead costs and its primary advantages. Your program can"
" be executed in two different ways:"
msgstr ""
"카이로는 오버헤드 비용과 주요 장점에 관해서 트래디셔널 프로그래밍 언어와 매우 다릅니다. 당신의 프로그램은 두 가지 다른 방식으로 실행될"
" 수 있습니다:"

#: src/ch00-00-introduction.md:16
msgid ""
"When executed by the prover, it is similar to any other language. Because "
"Cairo is virtualized, and because the operations were not specifically "
"designed for maximum efficiency, this can lead to some performance overhead "
"but it is not the most relevant part to optimize."
msgstr ""
"프로버에 의해 실행될 때, 이는 다른 어떤 언어와도 유사합니다. 카이로가 가상화되어 있고, 연산이 최대 효율성을 위해 특별히 설계되지 "
"않았기 때문에 일부 성능 오버헤드가 발생할 수 있지만 최적화할 가장 중요한 부분은 아닙니다."

#: src/ch00-00-introduction.md:18
msgid ""
"When the generated proof is verified by a verifier, it is a bit different. "
"This has to be as cheap as possible since it could potentially be verified "
"on many very small machines. Fortunately verifying is faster than computing "
"and Cairo has some unique advantages to improve it even more. A notable one "
"is non-determinism. This is a topic you will cover in more detail later in "
"this book, but the idea is that you can theoretically use a different "
"algorithm for verifying than for computing. Currently, writing custom non-"
"deterministic code is not supported for the developers, but the standard "
"library leverages non-determinism for improved performance. For example "
"sorting an array in Cairo costs the same price as copying it. Because the "
"verifier doesn't sort the array, it just checks that it is sorted, which is "
"cheaper."
msgstr ""
"생성된 증명이 검증자에 의해 검증될 때 약간 다릅니다. 이는 매우 작은 기계에서 잠재적으로 검증될 수 있기 때문에 가능한 한 저렴해야 "
"합니다. 다행히 검증은 계산보다 빠릅니다. 그리고 카이로는 더 개선하기 위한 독특한 장점이 있습니다. 그 중 하나는 비결정론입니다. "
"이것은 이 책의 뒷부분에서 자세히 다룰 주제이지만, 아이디어는 이론적으로 검증을 위해 계산하는 것과는 다른 알고리즘을 사용할 수 있다는 "
"것입니다. 현재 개발자들을 위해 사용자 정의 비결정론적 코드 작성은 지원되지 않지만 표준 라이브러리는 성능을 향상시키기 위해 비결정론을 "
"활용합니다. 예를 들어, 카이로에서 배열을 정렬하는 것은 복사하는 것과 동일한 비용이 듭니다. 검증자는 배열을 정렬하지 않고 정렬되어 "
"있는지만 확인하기 때문에 더 저렴합니다."

#: src/ch00-00-introduction.md:20
msgid ""
"Another aspect that sets the language apart is its memory model. In Cairo, "
"memory access is immutable, meaning that once a value is written to memory, "
"it cannot be changed. Cairo 1 provides abstractions that help developers "
"work with these constraints, but it does not fully simulate mutability. "
"Therefore, developers must think carefully about how they manage memory and "
"data structures in their programs to optimize performance."
msgstr ""
"언어를 독특하게 만드는 또 다른 측면은 그 메모리 모델입니다. 카이로에서 메모리 접근은 불변(immutable)하며, 한 번 값이 "
"메모리에 기록되면 변경할 수 없습니다. 카이로 1은 이러한 제약 조건과 함께 작업하는 개발자들을 돕는 추상화를 제공하지만, 완전한 "
"가변성을 시뮬레이션하지는 않습니다. 따라서 개발자들은 프로그램에서 메모리와 데이터 구조를 어떻게 관리할지 신중히 생각하여 성능을 "
"최적화해야 합니다."

#: src/ch00-00-introduction.md:22
msgid "References"
msgstr "참고문헌"

#: src/ch00-00-introduction.md:24
msgid "Cairo CPU Architecture: <https://eprint.iacr.org/2021/1063>"
msgstr "카이로 CPU 아키텍처: <https://eprint.iacr.org/2021/1063>"

#: src/ch00-00-introduction.md:25
msgid ""
"Cairo, Sierra and Casm: <https://medium.com/nethermind-eth/under-the-hood-"
"of-cairo-1-0-exploring-sierra-7f32808421f5>"
msgstr ""
"카이로, 시에라 및 카스민: <https://medium.com/nethermind-eth/under-the-hood-of-"
"cairo-1-0-exploring-sierra-7f32808421f5>"

#: src/ch00-00-introduction.md:26
msgid ""
"State of non determinism: "
"<https://twitter.com/PapiniShahar/status/1638203716535713798>"
msgstr ""
"결정론적 상태: <https://twitter.com/PapiniShahar/status/1638203716535713798>"

#: src/ch01-00-getting-started.md:3
msgid ""
"Let’s start your Cairo journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr "카이로 여행을 시작해봅시다! 배울 것이 많지만 모든 여행은 어딘가에서 시작됩니다. 이 장에서는 다음을 논의할 것입니다:"

#: src/ch01-00-getting-started.md:5
msgid ""
"Installing Scarb, which is Cairo's build toolchain and package manager, on "
"Linux, macOS, and Windows."
msgstr "리눅스, macOS 및 Windows에 Cairo의 빌드 도구 및 패키지 관리자 인 Scarb를 설치하는 중입니다."

#: src/ch01-00-getting-started.md:6
msgid "Writing a program that prints `Hello, world!`."
msgstr "`Hello, world!`을 출력하는 프로그램을 작성합니다."

#: src/ch01-00-getting-started.md:7
msgid "Using basic Scarb commands to create a project and execute a program."
msgstr "기본 Scarb 명령을 사용하여 프로젝트를 생성하고 프로그램을 실행합니다."

#: src/ch01-01-installation.md:3
msgid ""
"Cairo can be installed by simply downloading "
"[Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo "
"compiler and the Cairo language server together in an easy-to-install "
"package so that you can start writing Cairo code right away."
msgstr ""
"카이로는 [Scarb](https://docs.swmansion.com/scarb/docs)를 다운로드하여 간단히 설치할 수 있습니다. "
"Scarb는 카이로 컴파일러와 카이로 언어 서버를 함께 묶어 쉽게 설치할 수 있는 패키지로 제공되어, 즉시 카이로 코드를 작성할 수 "
"있습니다."

#: src/ch01-01-installation.md:5
msgid ""
"Scarb is also Cairo's package manager and is heavily inspired by "
"[Cargo](https://doc.rust-lang.org/cargo/), Rust’s build system and package "
"manager."
msgstr ""
"Scarb는 또한 카이로의 패키지 관리자이며 [Cargo](https://doc.rust-lang.org/cargo/)에 크게 영향을 "
"받았습니다. Cargo는 러스트의 빌드 시스템 및 패키지 관리자입니다."

#: src/ch01-01-installation.md:7
msgid ""
"Scarb handles a lot of tasks for you, such as building your code (either "
"pure Cairo or Starknet contracts), downloading the libraries your code "
"depends on, building those libraries, and provides LSP support for the "
"VSCode Cairo 1 extension."
msgstr ""
"Scarb는 여러 작업을 대신 수행해 주며, 코드를 빌드하고(순수 Cairo 또는 Starknet 계약), 코드가 의존하는 라이브러리를 "
"다운로드하고, 해당 라이브러리를 빌드하며, VSCode Cairo 1 확장 프로그램을 위한 LSP 지원을 제공합니다."

#: src/ch01-01-installation.md:9
msgid ""
"As you write more complex Cairo programs, you might add dependencies, and if"
" you start a project using Scarb, managing external code and dependencies "
"will be a lot easier to do."
msgstr ""
"더 복잡한 카이로 프로그램을 작성할수록 종속성을 추가할 수 있으며, Scarb를 사용하여 프로젝트를 시작하면 외부 코드 및 종속성을 관리하는"
" 것이 훨씬 쉬워질 것입니다."

#: src/ch01-01-installation.md:11
msgid "Let's start by installing Scarb."
msgstr "Scarb를 설치하는 것으로 시작합시다."

#: src/ch01-01-installation.md:13
msgid "Installing Scarb"
msgstr "Scarb 설치하기"

#: src/ch01-01-installation.md:15
msgid "Requirements"
msgstr "요구 사항"

#: src/ch01-01-installation.md:17
msgid ""
"Scarb requires a Git executable to be available in the `PATH` environment "
"variable."
msgstr "Scarb는 `PATH` 환경 변수에 Git 실행 파일이 있어야 합니다."

#: src/ch01-01-installation.md:21
msgid ""
"To install Scarb, please refer to the [installation "
"instructions](https://docs.swmansion.com/scarb/download). We strongly "
"recommend that you install Scarb [via "
"asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a "
"CLI tool that can manage multiple language runtime versions on a per-project"
" basis. This will ensure that the version of Scarb you use to work on a "
"project always matches the one defined in the project settings, avoiding "
"problems related to version mismatches."
msgstr ""
"Scarb를 설치하려면 [설치 지침](https://docs.swmansion.com/scarb/download)을 참조하십시오. 우리는"
" 여러 언어 런타임 버전을 프로젝트 단위로 관리할 수 있는 CLI 도구인 asdf를 통해 Scarb를 설치하는 것을 강력히 권장합니다. "
"이를 통해 프로젝트에서 사용하는 Scarb 버전이 항상 프로젝트 설정에 정의된 버전과 일치하도록 보장하여 버전 불일치로 인한 문제를 피할"
" 수 있습니다. [via asdf로 설치하는 "
"방법](https://docs.swmansion.com/scarb/download.html#install-via-asdf)"

#: src/ch01-01-installation.md:25
msgid ""
"Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-"
"started.html) to install all prerequisites."
msgstr ""
"모든 전제 조건을 설치하려면 [asdf 문서](https://asdf-vm.com/guide/getting-started.html)를 "
"참조하십시오."

#: src/ch01-01-installation.md:27
msgid ""
"Once you have asdf installed locally, you can download Scarb plugin with the"
" following command:"
msgstr "로컬에 asdf를 설치한 후에 다음 명령어로 Scarb 플러그인을 다운로드할 수 있습니다:"

#: src/ch01-01-installation.md:31
msgid "This will allow you to download specific versions:"
msgstr "이를 통해 특정 버전을 다운로드할 수 있습니다."

#: src/ch01-01-installation.md:35
msgid "and set a global version: "
msgstr "그리고 전역 버전을 설정합니다: "

#: src/ch01-01-installation.md:40
msgid ""
"Otherwise, you can simply run the following command in your terminal, and "
"follow the onscreen instructions. This will install the latest stable "
"release of Scarb."
msgstr ""
"그렇지 않으면 터미널에서 다음 명령어를 실행하고 화면 안내에 따르면 됩니다. 이렇게 하면 Scarb의 최신 안정 버전이 설치됩니다."

#: src/ch01-01-installation.md:43
msgid "'=https'"
msgstr ""

#: src/ch01-01-installation.md:46
msgid ""
"In both cases, you can verify installation by running the following command "
"in a new terminal session, it should print both Scarb and Cairo language "
"versions, e.g:"
msgstr ""
"두 경우 모두 새 터미널 세션에서 다음 명령을 실행하여 설치를 확인할 수 있습니다. Scarb 및 Cairo 언어 버전이 모두 출력되어야"
" 합니다. 예:"

#: src/ch01-01-installation.md:55
msgid "Installing the VSCode extension"
msgstr "VSCode 확장 프로그램 설치하기"

#: src/ch01-01-installation.md:57
msgid ""
"Cairo has a VSCode extension that provides syntax highlighting, code "
"completion, and other useful features. You can install it from the [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
" Once installed, go into the extension settings, and make sure to tick the "
"`Enable Language Server` and `Enable Scarb` options."
msgstr ""
"카이로에는 구문 강조, 코드 완성 및 기타 유용한 기능을 제공하는 VSCode 확장 프로그램이 있습니다. [VSCode "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)에서"
" 설치할 수 있습니다. 설치한 후에는 확장 프로그램 설정으로 이동하여 `Enable Language Server` 및 `Enable "
"Scarb` 옵션을 선택해야 합니다."

#: src/ch01-02-hello-world.md:1
msgid "Hello, World"
msgstr "Hello, World"

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Cairo through Scarb, it’s time to write your first"
" Cairo program. It’s traditional when learning a new language to write a "
"little program that prints the text `Hello, world!` to the screen, so we’ll "
"do the same here!"
msgstr ""
"이제 Scarb를 통해 Cairo를 설치했으니, 첫 번째 Cairo 프로그램을 작성할 시간입니다. 새로운 언어를 배울 때 전통적으로 "
"화면에 `Hello, world!` 텍스트를 출력하는 작은 프로그램을 작성하는 것이 관행이므로, 여기서도 같은 작업을 할 것입니다!"

#: src/ch01-02-hello-world.md:7
msgid ""
" Note: This book assumes basic familiarity with the command line. Cairo makes "
" no specific demands about your editing or tooling or where your code lives, "
" so if you prefer to use an integrated development environment (IDE) instead "
" of the command line, feel free to use your favorite IDE. The Cairo team has "
" developed a VSCode extension for the Cairo language that you can use to get "
" the features from the language server and code highlighting. See [Appendix D]"
" (appendix-04-useful-development-tools.md) for more details."
msgstr "참고: 이 책은 명령줄에 대한 기본적인 이해를 전제로 합니다. 카이로는 편집 또는 도구 또는 코드가 위치하는 곳에 대해 구체적인 "
" 요구사항을 제시하지 않으므로 명령줄 대신 통합 개발 환경(IDE)을 사용하는 것을 선호한다면 마음껏 좋아하는 IDE를 사용하십시오. "
" 카이로 팀은 카이로 언어용 VSCode 확장 프로그램을 개발했으며, 이를 사용하여 언어 서버 및 코드 하이라이팅 기능을 활용할 수 "
" 있습니다. 자세한 내용은 [부록 D](appendix-04-useful-development-tools.md)를 참조하십시오."

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr "프로젝트 디렉토리 만들기"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Cairo code. It doesn’t "
"matter to Cairo where your code lives, but for the exercises and projects in"
" this book, we suggest making a _cairo_projects_ directory in your home "
"directory and keeping all your projects there."
msgstr ""
"당신은 카이로 코드를 저장할 디렉토리를 만들며 시작할 것입니다. 카이로에게 코드가 어디에 위치해 있는지는 중요하지 않지만, 이 책의 "
"연습과 프로젝트를 위해 우리는 홈 디렉토리에 _cairo_projects_ 디렉토리를 만들고 모든 프로젝트를 거기에 보관하는 것을 "
"제안합니다."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _cairo_projects_ "
"directory."
msgstr "터미널을 열고 다음 명령어를 입력하여 _cairo_projects_ 디렉토리를 만드세요."

#: src/ch01-02-hello-world.md:24
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "리눅스, macOS 및 Windows의 PowerShell을 위해 다음을 입력하십시오:"

#: src/ch01-02-hello-world.md:31
msgid "For Windows CMD, enter this:"
msgstr "Windows CMD를 위해 이것을 입력하십시오:"

#: src/ch01-02-hello-world.md:34 src/ch01-02-hello-world.md:35
msgid "\"%USERPROFILE%\\cairo_projects\""
msgstr ""

#: src/ch01-02-hello-world.md:38
msgid ""
"Note: From now on, for each example shown in the book, we assume that you "
"will be working from a Scarb project directory. If you are not using Scarb, "
"and try to run the examples from a different directory, you might need to "
"adjust the commands accordingly or create a Scarb project."
msgstr ""
"참고: 이제부터 책에 나온 각 예제에 대해, 당신이 Scarb 프로젝트 디렉토리에서 작업할 것을 가정합니다. Scarb를 사용하지 않고 "
"다른 디렉토리에서 예제를 실행하려고 하는 경우, 명령을 조정하거나 Scarb 프로젝트를 만들어야 할 수도 있습니다."

#: src/ch01-02-hello-world.md:41
msgid "Creating a Project with Scarb"
msgstr "Scarb로 프로젝트 만들기"

#: src/ch01-02-hello-world.md:43
msgid "Let’s create a new project using Scarb."
msgstr "Scarb를 사용하여 새 프로젝트를 만들어 봅시다."

#: src/ch01-02-hello-world.md:45
msgid ""
"Navigate to your _cairo_projects_ directory (or wherever you decided to "
"store your code). Then run the following:"
msgstr "_카이로_ 프로젝트 디렉토리(또는 코드를 저장하기로 결정한 위치)로 이동한 다음 다음을 실행하십시오."

#: src/ch01-02-hello-world.md:51
msgid ""
"It creates a new directory and project called `hello_world`. We’ve named our"
" project `hello_world`, and Scarb creates its files in a directory of the "
"same name."
msgstr ""
"그러면 새 디렉토리와 `hello_world` 프로젝트를 생성합니다. 저희는 프로젝트를 `hello_world`로 명명했고, Scarb는 동일한"
"이름의 디렉토리에 파일을 생성합니다."

#: src/ch01-02-hello-world.md:53
msgid ""
"Go into the `hello_world` directory with the command `cd hello_world`. "
"You’ll see that Scarb has generated two files and one directory for us: a "
"_Scarb.toml_ file and a _src_ directory with a _lib.cairo_ file inside."
msgstr ""
"명령어 `cd hello_world`를 사용하여 `hello_world` 디렉토리로 이동하십시오. Scarb가 우리를 위해 두 개의 "
"파일과 하나의 디렉토리를 생성했음을 알 수 있습니다: _Scarb.toml_ 파일과 내부에 _lib.cairo_ 파일이 있는 _src_ "
"디렉토리가 있습니다."

#: src/ch01-02-hello-world.md:55
msgid ""
"It has also initialized a new Git repository along with a `.gitignore` file"
msgstr "새로운 Git 저장소를 초기화했으며 `.gitignore` 파일도 함께 생성했습니다."

#: src/ch01-02-hello-world.md:57
msgid ""
"Note: Git is a common version control system. You can stop using version "
"control system by using the `--no-vcs` flag. Run `scarb new -help` to see "
"the available options."
msgstr ""
"참고: Git은 일반적인 버전 관리 시스템입니다. `--no-vcs` 플래그를 사용하여 버전 관리 시스템을 사용 중지할 수 있습니다. "
"사용 가능한 옵션을 보려면 `scarb new -help`를 실행하십시오."

#: src/ch01-02-hello-world.md:60
msgid ""
"Open _Scarb.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr "선호하는 텍스트 편집기에서 _Scarb.toml_을 엽니다. 이는 1-2 목록의 코드와 비슷하게 보일 것입니다."

#: src/ch01-02-hello-world.md:62
msgid "Filename: Scarb.toml"
msgstr "파일 이름: Scarb.toml"

#: src/ch01-02-hello-world.md:64
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2024_07\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"edition = \"2024_07\"\n"
"\n"
"# 더 많은 키와 그 정의를 보려면 https://docs.swmansion.com/scarb/docs/reference/manifest 를 참조하세요\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch01-02-hello-world.md:76
msgid "Listing 1-2: Contents of _Scarb.toml_ generated by `scarb new`"
msgstr "리스팅 1-2: `scarb new`로 생성된 _Scarb.toml_의 내용"

#: src/ch01-02-hello-world.md:78
msgid ""
"This file is in the [TOML](https://toml.io/) (Tom’s Obvious, Minimal "
"Language) format, which is Scarb’s configuration format."
msgstr ""
"이 파일은 [TOML](https://toml.io/) (Tom's Obvious, Minimal Language) 형식으로 되어 "
"있으며, 이는 Scarb의 구성 형식입니다."

#: src/ch01-02-hello-world.md:80
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr ""
"첫 번째 줄인 `[package]`은 이후 문장들이 패키지를 설정하는 것을 나타내는 섹션 제목입니다. 이 파일에 더 많은 정보를 "
"추가할수록 다른 섹션들을 추가할 것입니다."

#: src/ch01-02-hello-world.md:82
msgid ""
"The next three lines set the configuration information Scarb needs to "
"compile your program: the name of the package and the version of Scarb to "
"use, and the edition of the prelude to use. The prelude is the collection of"
" the most commonly used items that are automatically imported into every "
"Cairo program. You can learn more about the prelude in [Appendix "
"E](./appendix-05-common-types-and-traits-and-cairo-prelude.md)"
msgstr ""
"다음 세 줄은 Scarb가 프로그램을 컴파일하는 데 필요한 구성 정보를 설정합니다: 패키지의 이름 및 사용할 Scarb 버전, 그리고 "
"사용할 프렐루드의 에디션입니다. 프렐루드는 모든 카이로 프로그램에 자동으로 가져오는 가장 일반적으로 사용되는 항목의 모음입니다. "
"프렐루드에 대해 더 알아보려면 [부록 E](./appendix-05-common-types-and-traits-and-cairo-"
"prelude.md)를 참조하십시오."

#: src/ch01-02-hello-world.md:84
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Cairo, packages of code are referred "
"to as crates. We won’t need any other crates for this project."
msgstr ""
"마지막 줄인 `[dependencies]`는 프로젝트 의존성을 나열할 섹션의 시작입니다. 카이로에서 코드 패키지는 크레이트로 참조됩니다."
" 이 프로젝트에는 다른 크레이트가 필요하지 않을 것입니다."

#: src/ch01-02-hello-world.md:86
msgid ""
"Note: If you're building contracts for Starknet, you will need to add the "
"`starknet` dependency as mentioned in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-"
"package.html)."
msgstr ""
"참고: Starknet을 위한 계약을 작성하는 경우, [Scarb "
"문서](https://docs.swmansion.com/scarb/docs/extensions/starknet/starknet-"
"package.html)에 언급된대로 `starknet` 종속성을 추가해야 합니다."

#: src/ch01-02-hello-world.md:88
msgid ""
"The other file created by Scarb is _src/lib.cairo_, let's delete all the "
"content and put in the following content, we will explain the reason later."
msgstr ""
"Scarb에 의해 생성된 다른 파일은 _src/lib.cairo_ 입니다. 모든 내용을 삭제하고 다음 내용을 넣어주세요. 이유를 나중에 "
"설명하겠습니다."

#: src/ch01-02-hello-world.md:94
msgid ""
"Then create a new file called _src/hello_world.cairo_ and put the following "
"code in it:"
msgstr "그런 다음 _src/hello_world.cairo_ 라는 새 파일을 만들고 다음 코드를 넣으십시오:"

#: src/ch01-02-hello-world.md:96
msgid "Filename: src/hello_world.cairo"
msgstr "파일 이름: src/hello_world.cairo"

#: src/ch01-02-hello-world.md:100 src/ch01-02-hello-world.md:179
msgid "\"Hello, World!\""
msgstr "\"Hello, World!\""

#: src/ch01-02-hello-world.md:104
msgid ""
"We have just created a file called _lib.cairo_, which contains a module "
"declaration referencing another module named `hello_world`, as well as the "
"file _hello_world.cairo_, containing the implementation details of the "
"`hello_world` module."
msgstr ""
"우리는 방금 _lib.cairo_ 라는 파일을 만들었습니다. 이 파일에는 `hello_world`라는 다른 모듈을 참조하는 모듈 선언이 "
"포함되어 있습니다. 또한 `hello_world` 모듈의 구현 세부 정보를 포함하는 _hello_world.cairo_ 파일도 있습니다."

#: src/ch01-02-hello-world.md:106
msgid ""
"Scarb requires your source files to be located within the _src_ directory."
msgstr "Scarb는 소스 파일이 _src_ 디렉토리 내에 위치해야 합니다."

#: src/ch01-02-hello-world.md:108
msgid ""
"The top-level project directory is reserved for README files, license "
"information, configuration files, and any other non-code-related content. "
"Scarb ensures a designated location for all project components, maintaining "
"a structured organization."
msgstr ""
"최상위 프로젝트 디렉토리는 README 파일, 라이선스 정보, 구성 파일 및 기타 코드와 관련이 없는 콘텐츠를 위해 예약되어 있습니다. "
"Scarb는 모든 프로젝트 구성 요소에 대한 지정된 위치를 보장하여 구조화된 조직을 유지합니다."

#: src/ch01-02-hello-world.md:111
msgid ""
"If you started a project that doesn’t use Scarb, you can convert it to a "
"project that does use Scarb. Move the project code into the _src_ directory "
"and create an appropriate _Scarb.toml_ file. You can also use `scarb init` "
"command to generate the _src_ folder and the _Scarb.toml_ it contains."
msgstr ""
"만약 Scarb를 사용하지 않는 프로젝트를 시작했다면, Scarb를 사용하는 프로젝트로 변환할 수 있습니다. 프로젝트 코드를 _src_ "
"디렉토리로 이동하고 적절한 _Scarb.toml_ 파일을 생성하세요. 또한 `scarb init` 명령어를 사용하여 _src_ 폴더와 그"
" 안에 포함된 _Scarb.toml_ 을 생성할 수도 있습니다."

#: src/ch01-02-hello-world.md:120
msgid " A sample Scarb project structure"
msgstr "샘플 Scarb 프로젝트 구조"

#: src/ch01-02-hello-world.md:122
msgid "Building a Scarb Project"
msgstr "Scarb 프로젝트를 진행 중입니다."

#: src/ch01-02-hello-world.md:124
msgid ""
"From your `hello_world` directory, build your project by entering the "
"following command:"
msgstr ""
"당신의 `hello_world` 디렉토리에서 다음 명령어를 입력하여 "
"프로젝트를 빌드하세요:"

#: src/ch01-02-hello-world.md:132
msgid ""
"This command creates a `sierra` file in _target/dev_, let's ignore the "
"`sierra` file for now."
msgstr "이 명령은 _target/dev_ 에 `sierra` 파일을 생성합니다. 지금은 `sierra` 파일을 무시합시다."

#: src/ch01-02-hello-world.md:134
msgid ""
"If you have installed Cairo correctly, you should be able to run the `main` "
"function of your program with the `scarb cairo-run` command and see the "
"following output:"
msgstr ""
"만약 Cairo를 올바르게 설치했다면, `scarb cairo-run` 명령어로 프로그램의 `main` 함수를 실행하고 다음 출력을 볼 "
"수 있어야 합니다:"

#: src/ch01-02-hello-world.md:143
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print"
" to the terminal."
msgstr "어떤 운영 체제를 사용하더라도 문자열 `Hello, world!`은 터미널에 출력되어야 합니다."

#: src/ch01-02-hello-world.md:146
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Cairo program. That makes you a Cairo programmer—welcome!"
msgstr ""
"`Hello, world!`가 출력되었다면, 축하합니다! 이제 공식적으로 카이로 프로그램을 작성했습니다. 이제 당신은 카이로 프로그래머가"
" 되었습니다. 환영합니다!"

#: src/ch01-02-hello-world.md:149
msgid "Anatomy of a Cairo Program"
msgstr "카이로 프로그램의 해부학"

#: src/ch01-02-hello-world.md:151
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr "이 \"Hello, world!\" 프로그램을 자세히 검토해 봅시다. 퍼즐의 첫 번째 조각은 여기 있습니다:"

#: src/ch01-02-hello-world.md:160
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Cairo program. "
"Here, the first line declares a function named `main` that has no parameters"
" and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr ""
"이 라인들은 `main`이라는 함수를 정의합니다. `main` 함수는 특별합니다: 모든 실행 가능한 카이로 프로그램에서 항상 가장 먼저 "
"실행되는 코드입니다. 여기서 첫 번째 라인은 매개변수가 없고 아무것도 반환하지 않는 `main`이라는 함수를 선언합니다. 만약 매개변수가"
" 있다면, 그것들은 괄호 `()` 안에 들어갈 것입니다."

#: src/ch01-02-hello-world.md:165
msgid ""
"The function body is wrapped in `{}`. Cairo requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr ""
"함수 본문은 `{}`로 둘러싸여 있습니다. Cairo는 모든 함수 본문 주위에 중괄호를 필요로 합니다. 함수 선언과 동일한 줄에 여는 "
"중괄호를 두는 것이 좋은 스타일이며, 중괄호 사이에 공백을 하나 추가하는 것이 좋습니다."

#: src/ch01-02-hello-world.md:169
msgid ""
"Note: If you want to stick to a standard style across Cairo projects, you "
"can use the automatic formatter tool available with `scarb fmt` to format "
"your code in a particular style (more on `scarb fmt` in [Appendix "
"D](appendix-04-useful-development-tools.md)). The Cairo team has included "
"this tool with the standard Cairo distribution, as `cairo-run` is, so it "
"should already be installed on your computer!"
msgstr ""
"참고: 카이로 프로젝트 전체에서 표준 스타일을 유지하고 싶다면, 특정 스타일로 코드를 서식 지정하는 자동 포매터 도구 `scarb "
"fmt`를 사용할 수 있습니다 ([부록 D](appendix-04-useful-development-tools.md)에서 `scarb "
"fmt`에 대해 자세히 알아볼 수 있습니다). 카이로 팀은 이 도구를 표준 카이로 배포에 포함시켰으므로, `cairo-run`과 "
"마찬가지로 이미 컴퓨터에 설치되어 있어야 합니다!"

#: src/ch01-02-hello-world.md:176
msgid "The body of the `main` function holds the following code:"
msgstr "`main` 함수의 본문에는 다음 코드가 포함되어 있습니다."

#: src/ch01-02-hello-world.md:182
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr ""
"이 줄은 이 작은 프로그램에서 모든 작업을 수행합니다: 화면에 텍스트를 출력합니다. 여기서 주목해야 할 네 가지 중요한 세부 사항이 "
"있습니다."

#: src/ch01-02-hello-world.md:185
msgid "First, Cairo style is to indent with four spaces, not a tab."
msgstr "먼저, 카이로 스타일은 탭이 아닌 네 개의 공백으로 들여쓰기하는 것입니다."

#: src/ch01-02-hello-world.md:187
msgid ""
"Second, `println!` calls a Cairo macro. If it had called a function instead,"
" it would be entered as `println` (without the `!`). We’ll discuss Cairo "
"macros in more detail in [Chapter Macros](./ch11-02-macros.md). For now, you"
" just need to know that using a `!` means that you’re calling a macro "
"instead of a normal function and that macros don’t always follow the same "
"rules as functions."
msgstr ""
"둘째, `println!`은 카이로 매크로를 호출합니다. 대신 함수를 호출했다면 `println`으로 입력되었을 것입니다 ( `!` "
"없이). 우리는 [매크로 장](./ch11-02-macros.md)에서 카이로 매크로에 대해 더 자세히 다룰 것입니다. 지금 당장은 "
"`!`를 사용하면 일반 함수 대신 매크로를 호출한다는 것을 알아두세요. 매크로는 항상 함수와 같은 규칙을 따르지 않는다는 점을 "
"알아두세요."

#: src/ch01-02-hello-world.md:190
msgid ""
"Third, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr ""
"세 번째로, \"Hello, world!\" 문자열을 보게 됩니다. 우리는 이 문자열을 `println!`에 인수로 전달하고, 화면에 "
"문자열이 출력됩니다."

#: src/ch01-02-hello-world.md:192
msgid ""
"Fourth, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Cairo "
"code end with a semicolon."
msgstr ""
"네 번째로, 우리는 세미콜론(`;`)으로 라인을 끝냅니다. 이는 이 표현이 끝났고 다음 표현이 시작할 준비가 되었음을 나타냅니다. 카이로"
" 코드의 대부분의 라인은 세미콜론으로 끝납니다."

#: src/ch01-02-hello-world.md:198 src/ch02-05-control-flow.md:302
#: src/ch03-03-custom-data-structures.md:338 src/ch05-03-method-syntax.md:285
#: src/ch07-05-separating-modules-into-different-files.md:98
#: src/ch10-02-recoverable-errors.md:190
msgid "Summary"
msgstr "요약"

#: src/ch01-02-hello-world.md:200
msgid "Let’s recap what we’ve learned so far about Scarb:"
msgstr "지금까지 우리가 Scarb에 대해 배운 내용을 다시 한 번 요약해 보겠습니다:"

#: src/ch01-02-hello-world.md:202
msgid ""
"We can install one or multiple Scarb versions, either the latest stable or a"
" specific one, using asdf."
msgstr ""
"asdf를 사용하여 최신 안정 버전 또는 특정 버전을 설치할 수 있습니다. Scarb 버전을 하나 또는 여러 개 설치할 수 있습니다."

#: src/ch01-02-hello-world.md:203
msgid "We can create a project using `scarb new`."
msgstr "`scarb new`를 사용하여 프로젝트를 생성할 수 있습니다."

#: src/ch01-02-hello-world.md:204
msgid ""
"We can build a project using `scarb build` to generate the compiled Sierra "
"code."
msgstr "`scarb build`를 사용하여 컴파일된 Sierra 코드를 생성하여 프로젝트를 구축할 수 있습니다."

#: src/ch01-02-hello-world.md:205
msgid "We can execute a Cairo program using the `scarb cairo-run` command."
msgstr "`scarb cairo-run` 명령을 사용하여 카이로 프로그램을 실행할 수 있습니다."

#: src/ch01-02-hello-world.md:207
msgid ""
"An additional advantage of using Scarb is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no"
" longer provide specific instructions for Linux and macOS versus Windows."
msgstr ""
"Scarb를 사용하는 추가적인 장점은 어떤 운영 체제에서 작업하더라도 명령어가 동일하다는 것입니다. 따라서 이 시점에서는 더 이상 "
"Linux 및 macOS 대 Windows에 대한 구체적인 지침을 제공하지 않을 것입니다."

#: src/ch01-02-hello-world.md:209
msgid ""
"You’re already off to a great start on your Cairo journey! This is a great "
"time to build a more substantial program to get used to reading and writing "
"Cairo code."
msgstr ""
"당신은 이미 카이로 여행을 시작했습니다! 이제 카이로 코드를 읽고 쓰는 데 익숙해지기 위해 더 구체적인 프로그램을 만드는 좋은 "
"시기입니다."

#: src/ch02-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Cairo. Many programming languages have much in"
" common at their core. None of the concepts presented in this chapter are "
"unique to Cairo, but we’ll discuss them in the context of Cairo and explain "
"the conventions around using these concepts."
msgstr ""
"이 장에서는 대부분의 프로그래밍 언어에서 나타나는 개념과 그것들이 카이로에서 어떻게 작동하는지 다룹니다. 많은 프로그래밍 언어들은 "
"핵심적으로 많은 부분을 공유합니다. 이 장에서 제시된 개념들은 카이로에만 있는 것은 아니지만, 우리는 카이로의 맥락에서 이들을 논의하고 "
"이러한 개념을 사용하는 관례에 대해 설명할 것입니다."

#: src/ch02-00-common-programming-concepts.md:5
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Cairo "
"program, and learning them early will give you a strong core to start from."
msgstr ""
"구체적으로, 변수, 기본 유형, 함수, 주석 및 제어 흐름에 대해 배우게 됩니다. 이러한 기초는 모든 카이로 프로그램에 포함되어 있으며,"
" 일찍 배우는 것은 강력한 기반을 제공하여 출발할 수 있습니다."

#: src/ch02-01-variables-and-mutability.md:3
msgid ""
"Cairo uses an immutable memory model, meaning that once a memory cell is "
"written to, it can't be overwritten but only read from. To reflect this "
"immutable memory model, variables in Cairo are immutable by default. "
"However, the language abstracts this model and gives you the option to make "
"your variables mutable. Let’s explore how and why Cairo enforces "
"immutability, and how you can make your variables mutable."
msgstr ""
"카이로는 변경할 수 없는 메모리 모델을 사용합니다. 즉, 한 번 메모리 셀에 기록되면 덮어쓸 수 없고 읽기만 가능합니다. 이 변경할 수 "
"없는 메모리 모델을 반영하기 위해 카이로에서 변수는 기본적으로 변경할 수 없습니다. 그러나 이 언어는 이 모델을 추상화하고 변수를 변경할"
" 수 있도록 옵션을 제공합니다. 카이로가 변경할 수 없음을 강제하는 방법과 이를 어떻게 변경할 수 있는지 살펴보겠습니다."

#: src/ch02-01-variables-and-mutability.md:10
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _cairo_projects_ directory by using `scarb new "
"variables`."
msgstr ""
"변수가 불변일 때, 한 번 값이 이름에 바인딩되면 해당 값을 변경할 수 없습니다. 이를 설명하기 위해 `scarb new "
"variables`를 사용하여 _cairo_projects_ 디렉토리에 _variables_ 라는 새 프로젝트를 생성하세요."

#: src/ch02-01-variables-and-mutability.md:14
msgid ""
"Then, in your new _variables_ directory, open _src/lib.cairo_ and replace "
"its code with the following code, which won’t compile just yet:"
msgstr ""
"그런 다음 새 _variables_ 디렉토리에서 _src/lib.cairo_ 파일을 열고 아래 코드로 코드를 바꿉니다. 아래 코드는 아직"
" 컴파일되지 않습니다:"

#: src/ch02-01-variables-and-mutability.md:17
#: src/ch02-01-variables-and-mutability.md:83
#: src/ch02-01-variables-and-mutability.md:166 src/ch02-04-comments.md:21
#: src/ch02-04-comments.md:31 src/ch02-05-control-flow.md:11
#: src/ch02-05-control-flow.md:51 src/ch02-05-control-flow.md:104
#: src/ch02-05-control-flow.md:136 src/ch02-05-control-flow.md:173
#: src/ch04-01-what-is-ownership.md:235 src/ch04-01-what-is-ownership.md:280
#: src/ch04-02-references-and-snapshots.md:26
#: src/ch04-02-references-and-snapshots.md:113
#: src/ch05-01-defining-and-instantiating-structs.md:7
#: src/ch05-01-defining-and-instantiating-structs.md:26
#: src/ch05-01-defining-and-instantiating-structs.md:51
#: src/ch05-01-defining-and-instantiating-structs.md:87
#: src/ch05-01-defining-and-instantiating-structs.md:123
#: src/ch05-02-an-example-program-using-structs.md:7
#: src/ch05-02-an-example-program-using-structs.md:47
#: src/ch05-02-an-example-program-using-structs.md:72
#: src/ch05-02-an-example-program-using-structs.md:99
#: src/ch05-02-an-example-program-using-structs.md:135
#: src/ch05-03-method-syntax.md:18 src/ch05-03-method-syntax.md:100
#: src/ch05-03-method-syntax.md:141 src/ch05-03-method-syntax.md:190
#: src/ch05-03-method-syntax.md:228
#: src/ch07-02-defining-modules-to-control-scope.md:78
#: src/ch07-02-defining-modules-to-control-scope.md:130
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:62
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:38
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:77
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:131
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:205
#: src/ch07-05-separating-modules-into-different-files.md:18
#: src/ch09-01-how-to-write-tests.md:28 src/ch09-01-how-to-write-tests.md:62
#: src/ch09-01-how-to-write-tests.md:118 src/ch09-01-how-to-write-tests.md:141
#: src/ch09-01-how-to-write-tests.md:206 src/ch09-01-how-to-write-tests.md:311
#: src/ch09-01-how-to-write-tests.md:456 src/ch09-01-how-to-write-tests.md:541
#: src/ch09-01-how-to-write-tests.md:622 src/ch09-01-how-to-write-tests.md:660
#: src/ch09-01-how-to-write-tests.md:696 src/ch09-02-test-organization.md:30
#: src/ch09-02-test-organization.md:59
#: src/ch10-01-unrecoverable-errors-with-panic.md:9
msgid "Filename: src/lib.cairo"
msgstr "파일 이름: src/lib.cairo"

#: src/ch02-01-variables-and-mutability.md:23
#: src/ch02-01-variables-and-mutability.md:25
#: src/ch02-01-variables-and-mutability.md:88
#: src/ch02-01-variables-and-mutability.md:90
#: src/ch02-01-variables-and-mutability.md:227
#: src/ch02-01-variables-and-mutability.md:229 src/ch02-03-functions.md:67
#: src/ch02-03-functions.md:261 src/ch02-03-functions.md:295
#: src/ch02-03-functions.md:312
msgid "\"The value of x is: {}\""
msgstr "\"x의 값은: {}\""

#: src/ch02-01-variables-and-mutability.md:30
msgid ""
"Save and run the program using `scarb cairo-run`. You should receive an "
"error message regarding an immutability error, as shown in this output:"
msgstr ""
"`scarb cairo-run`를 사용하여 프로그램을 저장하고 실행하세요. 이 출력에서 보이는 대로 불변성 오류에 관한 오류 메시지를 "
"받아야 합니다."

#: src/ch02-01-variables-and-mutability.md:42
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but they only mean your program isn’t "
"safely doing what you want it to do yet; they do _not_ mean that you’re not "
"a good programmer! Experienced Caironautes still get compiler errors."
msgstr ""
"이 예시는 컴파일러가 프로그램에서 오류를 찾는 데 어떻게 도움을 주는지 보여줍니다. 컴파일러 오류는 짜증을 내게 할 수 있지만, 이는 "
"단지 당신이 원하는 대로 안전하게 작동하지 않는 프로그램일 뿐이며, 당신이 좋은 프로그래머가 아니라는 뜻은 아닙니다! 경험이 많은 "
"Caironautes도 여전히 컴파일러 오류를 만납니다."

#: src/ch02-01-variables-and-mutability.md:47
msgid ""
"You received the error message `Cannot assign to an immutable variable.` "
"because you tried to assign a second value to the immutable `x` variable."
msgstr "불변 변수 `x`에 두 번째 값을 할당하려고 시도하여 `불변 변수에 할당할 수 없습니다.` 오류 메시지를 받았습니다."

#: src/ch02-01-variables-and-mutability.md:50
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this specific situation can "
"lead to bugs. If one part of our code operates on the assumption that a "
"value will never change and another part of our code changes that value, "
"it’s possible that the first part of the code won’t do what it was designed "
"to do. The cause of this kind of bug can be difficult to track down after "
"the fact, especially when the second piece of code changes the value only "
"_sometimes_."
msgstr ""
"우리가 변경할 수 없는 값으로 지정된 값을 변경하려고 시도할 때 컴파일 시간 오류를 얻는 것이 중요합니다. 왜냐하면 이 특정 상황은 "
"버그로 이어질 수 있기 때문입니다. 코드의 한 부분이 값이 변경되지 않을 것이라는 가정으로 작동하고 다른 부분이 그 값을 변경한다면, 첫"
" 번째 코드 부분이 의도한 대로 작동하지 않을 수 있습니다. 이러한 종류의 버그의 원인은 특히 두 번째 코드 조각이 값 변경을 _가끔_ 만"
" 하는 경우에는 추적하기 어려울 수 있습니다."

#: src/ch02-01-variables-and-mutability.md:58
msgid ""
"Cairo, unlike most other languages, has immutable memory. This makes a whole"
" class of bugs impossible, because values will never change unexpectedly. "
"This makes code easier to reason about."
msgstr ""
"카이로는 대부분의 다른 언어와 달리 불변 메모리를 가지고 있습니다. 이는 값이 예기치 않게 변경되지 않기 때문에 일부 버그가 불가능하게 "
"만듭니다. 이는 코드를 이해하기 쉽게 만듭니다."

#: src/ch02-01-variables-and-mutability.md:62
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name. Adding `mut` also "
"conveys intent to future readers of the code by indicating that other parts "
"of the code will be changing the value associated to this variable."
msgstr ""
"변이성은 매우 유용할 수 있으며 코드를 더 편리하게 작성할 수 있게 해줄 수 있습니다. 변수는 기본적으로 불변이지만 변수 이름 앞에 "
"`mut`를 추가하여 가변하게 만들 수 있습니다. `mut`를 추가함으로써 코드의 미래 독자들에게 이 변수와 연관된 값이 변경될 것임을 "
"나타내어 의도를 전달할 수도 있습니다."

#: src/ch02-01-variables-and-mutability.md:70
msgid ""
"However, you might be wondering at this point what exactly happens when a "
"variable is declared as `mut`, as we previously mentioned that Cairo's "
"memory is immutable. The answer is that the _value_ is immutable, but the "
"_variable_ isn't. The value associated to the variable can be changed. "
"Assigning to a mutable variable in Cairo is essentially equivalent to "
"redeclaring it to refer to another value in another memory cell, but the "
"compiler handles that for you, and the keyword `mut` makes it explicit. Upon"
" examining the low-level Cairo Assembly code, it becomes clear that variable"
" mutation is implemented as syntactic sugar, which translates mutation "
"operations into a series of steps equivalent to variable shadowing. The only"
" difference is that at the Cairo level, the variable is not redeclared so "
"its type cannot change."
msgstr ""
"그러나 여기서 변수가 `mut`로 선언될 때 정확히 무엇이 발생하는지 궁금할 수 있습니다. 이전에 카이로의 메모리는 불변이라고 언급했었기"
" 때문입니다. 답은 _값_ 은 불변이지만 _변수_ 는 그렇지 않다는 것입니다. 변수에 연결된 값은 변경될 수 있습니다. 카이로에서 가변 "
"변수에 할당하는 것은 사실 다른 메모리 셀에서 다른 값을 참조하도록 다시 선언하는 것과 동등합니다. 그러나 컴파일러가 이를 처리하고 "
"키워드 `mut`을 명시적으로 만들어 줍니다. 저수준의 카이로 어셈블리 코드를 조사하면 변수 변이가 문법적 설탕으로 구현되어 있음을 알 "
"수 있습니다. 이는 변이 작업을 변수 음영화와 동등한 단계의 일련의 단계로 변환하는 것입니다. 유일한 차이점은 카이로 수준에서 변수가 "
"다시 선언되지 않으므로 그 유형이 변경될 수 없다는 것입니다."

#: src/ch02-01-variables-and-mutability.md:81
msgid "For example, let’s change _src/lib.cairo_ to the following:"
msgstr "예를 들어, 다음과 같이 _src/lib.cairo_ 를 변경해 봅시다:"

#: src/ch02-01-variables-and-mutability.md:94
msgid "When we run the program now, we get this:"
msgstr "지금 프로그램을 실행하면 이렇게 나옵니다."

#: src/ch02-01-variables-and-mutability.md:103
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is"
" used. Ultimately, deciding whether to use mutability or not is up to you "
"and depends on what you think is clearest in that particular situation."
msgstr ""
"우리는 `mut`을 사용할 때 `x`에 바인딩된 값을 `5`에서 `6`으로 변경할 수 있습니다. 결국 가변성을 사용할지 여부는 당신에게 "
"달려 있으며, 그 특정 상황에서 가장 명확하다고 생각하는 것에 달려 있습니다."

#: src/ch02-01-variables-and-mutability.md:107
msgid "Constants"
msgstr "상수"

#: src/ch02-01-variables-and-mutability.md:109
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr "불변 변수와 마찬가지로 _상수_ 는 이름에 바인딩된 값으로 변경할 수 없지만, 상수와 변수 사이에는 몇 가지 차이가 있습니다."

#: src/ch02-01-variables-and-mutability.md:113
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just"
" immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch02-02-data-types.md), so don’t worry about the "
"details right now. Just know that you must always annotate the type."
msgstr ""
"먼저, 상수와 `mut`을 함께 사용할 수 없습니다. 상수는 기본적으로 불변이 아니라 항상 불변입니다. 상수는 `let` 키워드 대신 "
"`const` 키워드를 사용하여 선언하며, 값의 유형은 _반드시_ 주석이 달려 있어야 합니다. 다음 섹션인 [“데이터 "
"유형”](ch02-02-data-types.md)에서 유형과 유형 주석을 다룰 것이므로 지금은 세부 사항에 대해 걱정하지 마십시오. 단지"
" 항상 유형을 주석으로 표시해야 한다는 것을 알아두세요."

#: src/ch02-01-variables-and-mutability.md:120
msgid ""
"Constants can only be declared in the global scope, which makes them useful "
"for values that many parts of code need to know about."
msgstr "상수는 전역 범위에서만 선언할 수 있으며, 이는 코드의 많은 부분이 알아야 하는 값에 유용합니다."

#: src/ch02-01-variables-and-mutability.md:123
msgid ""
"The last difference is that constants may natively be set only to a constant"
" expression, not the result of a value that could only be computed at "
"runtime. Only literal constants are currently supported."
msgstr ""
"마지막 차이점은 상수가 상수 식으로만 설정될 수 있고 런타임에서만 계산할 수 있는 값의 결과로는 설정할 수 없다는 것입니다. 현재 리터럴"
" 상수만 지원됩니다."

#: src/ch02-01-variables-and-mutability.md:127
msgid "Here’s an example of a constant declaration:"
msgstr "다음은 상수 선언의 예입니다."

#: src/ch02-01-variables-and-mutability.md:133
msgid ""
"Nonetheless, it is possible to use the `consteval_int!` macro to create a "
"`const` variable that is the result of some computation:"
msgstr ""
"그럼에도 불구하고, `consteval_int!` 매크로를 사용하여 어떤 계산의 결과인 `const` 변수를 만들 수 있습니다."

#: src/ch02-01-variables-and-mutability.md:139
msgid ""
"We will dive into more detail about macros in the [dedicated "
"section](./ch11-02-macros.md)."
msgstr "우리는 [전용 섹션](./ch11-02-macros.md)에서 매크로에 대해 더 자세히 다룰 것입니다."

#: src/ch02-01-variables-and-mutability.md:141
msgid ""
"Cairo's naming convention for constants is to use all uppercase with "
"underscores between words."
msgstr "카이로의 상수 명명 규칙은 모든 대문자를 사용하고 단어 사이에 밑줄을 넣는 것입니다."

#: src/ch02-01-variables-and-mutability.md:144
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in"
" your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr ""
"상수는 프로그램이 실행되는 동안 유효하며 선언된 범위 내에서 유효합니다. 이 특성은 상수를 응용 프로그램 도메인의 값에 유용하게 "
"만들어줍니다. 프로그램의 여러 부분이 알아야 할 수도 있는 값들에 대해, 예를 들어 게임의 플레이어가 획득할 수 있는 최대 점수 또는 "
"빛의 속도와 같은 값들입니다."

#: src/ch02-01-variables-and-mutability.md:150
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It"
" also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr ""
"프로그램 전체에서 사용되는 하드코딩된 값에 상수로 명명하는 것은 코드를 유지보수하는 사람들에게 그 값의 의미를 전달하는 데 유용합니다. "
"또한, 앞으로 하드코딩된 값이 업데이트되어야 하는 경우 코드를 변경해야 하는 곳이 하나뿐이라는 것도 도움이 됩니다."

#: src/ch02-01-variables-and-mutability.md:155
msgid "Shadowing"
msgstr "그림자 따라가기"

#: src/ch02-01-variables-and-mutability.md:157
msgid ""
"Variable shadowing refers to the declaration of a new variable with the same"
" name as a previous variable. Caironautes say that the first variable is "
"_shadowed_ by the second, which means that the second variable is what the "
"compiler will see when you use the name of the variable. In effect, the "
"second variable overshadows the first, taking any uses of the variable name "
"to itself until either it itself is shadowed or the scope ends. We can "
"shadow a variable by using the same variable’s name and repeating the use of"
" the `let` keyword as follows:"
msgstr ""
"변수 그림자화는 이전 변수와 동일한 이름으로 새 변수를 선언하는 것을 의미합니다. 카이로나우트들은 첫 번째 변수가 두 번째 변수에 의해 "
"\"가려진다\"고 말합니다. 이는 두 번째 변수가 컴파일러가 변수 이름을 사용할 때 볼 것이라는 것을 의미합니다. 사실, 두 번째 변수가"
" 첫 번째 변수를 가려서 변수 이름을 사용할 때 자신을 보게 만들며, 그 자신이 가려지거나 범위가 끝날 때까지 변수 이름의 사용을 "
"가져갑니다. 우리는 동일한 변수 이름을 사용하여 변수를 그림자화할 수 있으며 `let` 키워드의 사용을 반복하여 다음과 같이 할 수 "
"있습니다:"

#: src/ch02-01-variables-and-mutability.md:174
msgid "\"Inner scope x value is: {}\""
msgstr "\"내부 범위 x 값은: {}\""

#: src/ch02-01-variables-and-mutability.md:176
msgid "\"Outer scope x value is: {}\""
msgstr "\"외부 범위 x 값은: {}\""

#: src/ch02-01-variables-and-mutability.md:180
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the "
"following:"
msgstr ""
"이 프로그램은 먼저 `x`를 `5`의 값에 바인딩합니다. 그런 다음 `let x =`를 반복하여 새 변수 `x`를 만들어 원래 값에 "
"`1`을 더하여 `x`의 값이 `6`이 되도록합니다. 그런 다음 중괄호로 생성된 내부 스코프 내에서 세 번째 `let` 문도 `x`를 "
"가려서 새 변수를 만들어 이전 값에 `2`를 곱하여 `x`의 값이 `12`가 되도록합니다. 그 스코프가 끝나면 내부 가려짐이 종료되고 "
"`x`는 다시 `6`이 됩니다. 이 프로그램을 실행하면 다음이 출력됩니다:"

#: src/ch02-01-variables-and-mutability.md:195
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr ""
"섀도잉은 변수를 `mut`으로 표시하는 것과 다릅니다. 왜냐하면 `let` 키워드를 사용하지 않고 이 변수에 다시 할당하려고 하면 컴파일"
" 시간 오류가 발생하기 때문입니다. `let`을 사용하면 값에 대해 몇 가지 변환을 수행할 수 있지만 이러한 변환을 완료한 후에는 변수를"
" 불변하게 만들 수 있습니다."

#: src/ch02-01-variables-and-mutability.md:201
msgid ""
"Another distinction between `mut` and shadowing is that when we use the "
"`let` keyword again, we are effectively creating a new variable, which "
"allows us to change the type of the value while reusing the same name. As "
"mentioned before, variable shadowing and mutable variables are equivalent at"
" the lower level. The only difference is that by shadowing a variable, the "
"compiler will not complain if you change its type. For example, say our "
"program performs a type conversion between the `u64` and `felt252` types."
msgstr ""
"`mut`와 섀도잉 사이의 또 다른 차이점은 `let` 키워드를 다시 사용할 때 새 변수를 효과적으로 생성한다는 것입니다. 이는 동일한 "
"이름을 재사용하면서 값의 유형을 변경할 수 있게 합니다. 앞서 언급했듯이 변수 섀도잉과 가변 변수는 하위 수준에서 동등합니다. 유일한 "
"차이점은 변수를 섀도잉하면 컴파일러가 유형을 변경해도 불평하지 않는다는 것입니다. 예를 들어, 프로그램이 `u64`와 `felt252` "
"유형 사이의 유형 변환을 수행한다고 가정해 봅시다."

#: src/ch02-01-variables-and-mutability.md:212
msgid "\"The value of x is {} of type u64\""
msgstr "\"x의 값은 u64 타입입니다\""

#: src/ch02-01-variables-and-mutability.md:213
msgid "// converts x to a felt, type annotation is required.\n"
msgstr "// x를 felt로 변환합니다. 타입 주석이 필요합니다."

#: src/ch02-01-variables-and-mutability.md:214
msgid "\"The value of x is {} of type felt252\""
msgstr "\"x의 값은 felt252 유형의 {}입니다\""

#: src/ch02-01-variables-and-mutability.md:218
msgid ""
"The first `x` variable has a `u64` type while the second `x` variable has a "
"`felt252` type. Shadowing thus spares us from having to come up with "
"different names, such as `x_u64` and `x_felt252`; instead, we can reuse the "
"simpler `x` name. However, if we try to use `mut` for this, as shown here, "
"we’ll get a compile-time error:"
msgstr ""
"첫 번째 `x` 변수는 `u64` 유형을 가지고 있고 두 번째 `x` 변수는 `felt252` 유형을 가지고 있습니다. 이러한 그림자화는"
" `x_u64` 및 `x_felt252`와 같은 다른 이름을 생각해 내지 않아도 되게 해줍니다. 대신 더 간단한 `x` 이름을 재사용할 "
"수 있습니다. 그러나 여기에 표시된 것처럼 이를 위해 `mut`을 사용하려고 하면 컴파일 시간 오류가 발생합니다."

#: src/ch02-01-variables-and-mutability.md:233
msgid ""
"The error says we were expecting a `u64` (the original type) but we got a "
"different type:"
msgstr "에러는 우리가 `u64` (원래의 타입)을 기대했지만 다른 타입을 받았다고 말합니다."

#: src/ch02-01-variables-and-mutability.md:246
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr "이제 변수가 어떻게 작동하는지 살펴보았으니, 그들이 가질 수 있는 더 많은 데이터 유형을 살펴봅시다."

#: src/ch02-02-data-types.md:3
msgid ""
"Every value in Cairo is of a certain _data type_, which tells Cairo what "
"kind of data is being specified so it knows how to work with that data. This"
" section covers two subsets of data types: scalars and compounds."
msgstr ""
"카이로의 모든 값은 특정 _데이터 유형_ 을 가지고 있으며, 이는 카이로에게 어떤 종류의 데이터가 지정되었는지를 알려주어 해당 데이터를 "
"처리하는 방법을 알 수 있게 합니다. 이 섹션은 스칼라와 복합 데이터 유형 두 가지 하위 집합을 다룹니다."

#: src/ch02-02-data-types.md:6
msgid ""
"Keep in mind that Cairo is a _statically typed_ language, which means that "
"it must know the types of all variables at compile time. The compiler can "
"usually infer the desired type based on the value and its usage. In cases "
"when many types are possible, we can use a conversion method where we specify the "
"desired output type."
msgstr ""
"기억해야 할 점은 카이로는 _정적으로 타입이 지정된_ 언어이며, 이는 컴파일 시간에 모든 변수의 타입을 알아야 한다는 것을 의미합니다. "
"컴파일러는 일반적으로 값과 사용 방법을 기반으로 원하는 타입을 추론할 수 있습니다. 여러 타입이 가능한 경우, 우리는 원하는 출력 타입을"
" 지정하는 캐스트 방법을 사용할 수 있습니다."

#: src/ch02-02-data-types.md:17
msgid "You’ll see different type annotations for other data types."
msgstr "다른 데이터 유형에 대한 다른 유형 주석을 볼 수 있습니다."

#: src/ch02-02-data-types.md:19
msgid "Scalar Types"
msgstr "스칼라 유형"

#: src/ch02-02-data-types.md:21
msgid ""
"A _scalar_ type represents a single value. Cairo has three primary scalar "
"types: felts, integers, and booleans. You may recognize these from other "
"programming languages. Let’s jump into how they work in Cairo."
msgstr ""
"스칼라 유형은 단일 값 하나를 나타냅니다. 카이로에는 세 가지 주요 스칼라 유형이 있습니다: 펠트, 정수 및 부울린입니다. 이러한 "
"유형들을 다른 프로그래밍 언어에서 알아볼 수 있을 것입니다. 이제 카이로에서 이들이 어떻게 작동하는지 알아보겠습니다."

#: src/ch02-02-data-types.md:25
msgid "Felt Type"
msgstr "펠트 유형"

#: src/ch02-02-data-types.md:27
msgid ""
"In Cairo, if you don't specify the type of a variable or argument, its type "
"defaults to a field element, represented by the keyword `felt252`. In the "
"context of Cairo, when we say “a field element” we mean an integer in the "
"range \\\\( 0 \\leq x \\< P \\\\), where `P` is a very large prime number "
"currently equal to \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\). When "
"adding, subtracting, or multiplying, if the result falls outside the "
"specified range of the prime number, an overflow (or underflow) occurs, and "
"an appropriate multiple of P is added or subtracted to bring the result back"
" within the range (i.e., the result is computed modulo P)."
msgstr ""
"카이로에서 변수나 인수의 유형을 지정하지 않으면 해당 유형은 키워드 `felt252`로 표시되는 필드 요소로 기본 설정됩니다. 카이로의 "
"맥락에서 \"필드 요소\"라고 말할 때는 \\\\( 0 \\leq x \\< P \\\\) 범위의 정수를 의미하며, 여기서 `P`는 현재"
" \\\\( {2^{251}} + 17 \\cdot {2^{192}} + 1 \\\\)과 같은 매우 큰 소수입니다. 더하거나 빼거나 곱할"
" 때, 결과가 지정된 소수의 범위를 벗어나면 오버플로우(또는 언더플로우)가 발생하고, 결과를 다시 범위 내로 가져오기 위해 P의 적절한 "
"배수가 추가되거나 빼집니다(즉, 결과는 P로 모듈로 계산됩니다)."

#: src/ch02-02-data-types.md:30
msgid ""
"The most important difference between integers and field elements is "
"division: Division of field elements (and therefore division in Cairo) is "
"unlike regular CPUs division, where integer division \\\\( \\frac{x}{y} "
"\\\\) is defined as \\\\( \\left\\lfloor \\frac{x}{y} \\right\\rfloor \\\\) "
"where the integer part of the quotient is returned (so you get \\\\( "
"\\frac{7}{3} = 2 \\\\)) and it may or may not satisfy the equation \\\\( "
"\\frac{x}{y} \\cdot y == x \\\\), depending on the divisibility of `x` by "
"`y`."
msgstr ""
"정수와 필드 요소 사이의 가장 중요한 차이점은 나눗셈입니다: 필드 요소의 나눗셈(따라서 카이로의 나눗셈)은 정규 CPU의 나눗셈과 달리 "
"정의됩니다. 여기서 정수 나눗셈 \\\\( \\frac{x}{y} \\\\)은 \\\\( \\left\\lfloor "
"\\frac{x}{y} \\right\\rfloor \\\\)로 정의되며 몫의 정수 부분이 반환됩니다(따라서 \\\\( "
"\\frac{7}{3} = 2 \\\\)가 됩니다). 그리고 이는 `x`를 `y`로 나눌 때 \\\\( \\frac{x}{y} "
"\\cdot y == x \\\\) 방정식을 만족할 수도, 만족하지 않을 수도 있습니다."

#: src/ch02-02-data-types.md:35
msgid ""
"In Cairo, the result of \\\\( \\frac{x}{y} \\\\) is defined to always "
"satisfy the equation \\\\( \\frac{x}{y} \\cdot y == x \\\\). If y divides x "
"as integers, you will get the expected result in Cairo (for example \\\\( "
"\\frac{6}{2} \\\\) will indeed result in `3`). But when y does not divide x,"
" you may get a surprising result: for example, since \\\\( 2 \\cdot \\frac{P"
" + 1}{2} = P + 1 \\equiv 1 \\mod P \\\\), the value of \\\\( \\frac{1}{2} "
"\\\\) in Cairo is \\\\( \\frac{P + 1}{2} \\\\) (and not 0 or 0.5), as it "
"satisfies the above equation."
msgstr ""
"카이로에서는 \\\\( \\frac{x}{y} \\\\)의 결과가 항상 \\\\( \\frac{x}{y} \\cdot y == x "
"\\\\) 방정식을 항상 만족하도록 정의됩니다. y가 x를 정수로 나누면 카이로에서 예상한 결과를 얻을 수 있습니다 (예를 들어 "
"\\\\( \\frac{6}{2} \\\\)는 실제로 `3`이 됩니다). 그러나 y가 x를 나누지 않을 때는 놀라운 결과를 얻을 수도 "
"있습니다: 예를 들어, \\\\( 2 \\cdot \\frac{P + 1}{2} = P + 1 \\equiv 1 \\mod P "
"\\\\)이므로, 카이로에서 \\\\( \\frac{1}{2} \\\\)의 값은 \\\\( \\frac{P + 1}{2} \\\\)입니다"
" (0 또는 0.5가 아닌) 위의 방정식을 만족하기 때문입니다."

#: src/ch02-02-data-types.md:38
msgid "Integer Types"
msgstr "정수형 데이터 유형"

#: src/ch02-02-data-types.md:40
msgid ""
"The felt252 type is a fundamental type that serves as the basis for creating"
" all types in the core library. However, it is highly recommended for "
"programmers to use the integer types instead of the `felt252` type whenever "
"possible, as the `integer` types come with added security features that "
"provide extra protection against potential vulnerabilities in the code, such"
" as overflow and underflow checks. By using these integer types, programmers"
" can ensure that their programs are more secure and less susceptible to "
"attacks or other security threats. An `integer` is a number without a "
"fractional component. This type declaration indicates the number of bits the"
" programmer can use to store the integer. Table 3-1 shows the built-in "
"integer types in Cairo. We can use any of these variants to declare the type"
" of an integer value."
msgstr ""
"felt252 유형은 핵심 라이브러리의 모든 유형을 생성하는 기초로 작용하는 기본 유형입니다. 그러나 프로그래머들이 가능한 경우 "
"`felt252` 유형 대신 정수 유형을 사용하는 것이 매우 권장됩니다. 왜냐하면 `integer` 유형은 코드 내의 잠재적인 취약점에 "
"대한 추가 보호 기능을 제공하는 오버플로 및 언더플로 검사와 함께 제공되기 때문입니다. 이 정수 유형을 사용함으로써 프로그래머들은 "
"프로그램이 더 안전하고 공격이나 다른 보안 위협에 덜 취약하도록 할 수 있습니다. `integer`은 소수점 구성 요소가 없는 "
"숫자입니다. 이 유형 선언은 프로그래머가 정수를 저장하는 데 사용할 수 있는 비트 수를 나타냅니다. 표 3-1은 Cairo에 내장된 정수"
" 유형을 보여줍니다. 이러한 변형 중 어느 것이든 사용하여 정수 값의 유형을 선언할 수 있습니다."

#: src/ch02-02-data-types.md:47
msgid "Table 3-1: Integer Types in Cairo"
msgstr "표 3-1: 카이로의 정수 유형"

#: src/ch02-02-data-types.md:49
msgid "Length"
msgstr "길이"

#: src/ch02-02-data-types.md:49
msgid "Unsigned"
msgstr "미서명"

#: src/ch02-02-data-types.md:51
msgid "8-bit"
msgstr "8비트"

#: src/ch02-02-data-types.md:51
msgid "`u8`"
msgstr "`u8`"

#: src/ch02-02-data-types.md:52
msgid "16-bit"
msgstr "16비트"

#: src/ch02-02-data-types.md:52
msgid "`u16`"
msgstr "`u16`"

#: src/ch02-02-data-types.md:53 src/ch02-02-data-types.md:57
msgid "32-bit"
msgstr "32비트"

#: src/ch02-02-data-types.md:53
msgid "`u32`"
msgstr "`u32`"

#: src/ch02-02-data-types.md:54
msgid "64-bit"
msgstr "64비트"

#: src/ch02-02-data-types.md:54
msgid "`u64`"
msgstr "`u64`"

#: src/ch02-02-data-types.md:55
msgid "128-bit"
msgstr "128비트"

#: src/ch02-02-data-types.md:55
msgid "`u128`"
msgstr "`u128`"

#: src/ch02-02-data-types.md:56
msgid "256-bit"
msgstr "256비트"

#: src/ch02-02-data-types.md:56
msgid "`u256`"
msgstr "`u256`"

#: src/ch02-02-data-types.md:57
msgid "`usize`"
msgstr "`usize`"

#: src/ch02-02-data-types.md:59
msgid ""
"Each variant has an explicit size. Note that for now, the `usize` type is "
"just an alias for `u32`; however, it might be useful when in the future "
"Cairo can be compiled to MLIR. As variables are unsigned, they can't contain"
" a negative number. This code will cause the program to panic:"
msgstr ""
"각 변형에는 명시적인 크기가 있습니다. 지금은 `usize` 타입이 단순히 `u32`의 별칭일 뿐이지만, 나중에 Cairo가 MLIR로 "
"컴파일될 수 있을 때 유용할 수 있습니다. 변수가 부호 없는 정수이기 때문에 음수를 포함할 수 없습니다. 이 코드는 프로그램이 패닉 "
"상태에 빠지게 할 것입니다."

#: src/ch02-02-data-types.md:72
msgid ""
"All integer types previously mentioned fit into a `felt252`, except for "
"`u256` which needs 4 more bits to be stored. Under the hood, `u256` is "
"basically a struct with 2 fields: `u256 {low: u128, high: u128}`."
msgstr ""
"이전에 언급된 모든 정수 유형은 `felt252`에 들어갑니다. `u256`는 저장되기 위해 4개의 비트가 더 필요합니다. `u256`는"
" 기본적으로 `u256 {low: u128, high: u128}`라는 2개의 필드가 있는 구조체입니다."

#: src/ch02-02-data-types.md:74
msgid ""
"Cairo also provides support for signed integers, starting with the prefix "
"`i`. These integers can represent both positive and negative values, with "
"sizes ranging from `i8` to `i128`. Each signed variant can store numbers "
"from \\\\( -({2^{n - 1}}) \\\\) to \\\\( {2^{n - 1}} - 1 \\\\) inclusive, "
"where `n` is the number of bits that variant uses. So an i8 can store "
"numbers from \\\\( -({2^7}) \\\\) to \\\\( {2^7} - 1 \\\\), which equals "
"`-128` to `127`."
msgstr ""
"카이로는 `i` 접두어로 시작하는 부호 있는 정수를 지원합니다. 이 정수들은 양수와 음수 값을 나타낼 수 있으며, `i8`부터 "
"`i128`까지의 크기를 가집니다. 각 부호 있는 변형은 해당 변형이 사용하는 비트 수인 `n`에 따라 \\\\( -({2^{n - "
"1}}) \\\\)에서 \\\\( {2^{n - 1}} - 1 \\\\)까지의 숫자를 저장할 수 있습니다. 따라서 i8은 \\\\( "
"-({2^7}) \\\\)에서 \\\\( {2^7} - 1 \\\\)까지의 숫자를 저장할 수 있으며, 이는 `-128`부터 "
"`127`까지의 값을 나타냅니다."

#: src/ch02-02-data-types.md:77
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix,"
" such as `57_u8`, to designate the type. It is also possible to use a visual"
" separator `_` for number literals, in order to improve code readability."
msgstr ""
"표 3-2에 표시된 형식 중 어떤 형태로든 정수 리터럴을 작성할 수 있습니다. 여러 숫자 유형을 가질 수 있는 숫자 리터럴은 "
"`57_u8`와 같이 유형 접미사를 허용합니다. 또한 코드 가독성을 높이기 위해 숫자 리터럴에 시각적 구분자 `_`를 사용하는 것도 "
"가능합니다."

#: src/ch02-02-data-types.md:82
msgid "Table 3-2: Integer Literals in Cairo"
msgstr "표 3-2: 카이로의 정수 리터럴"

#: src/ch02-02-data-types.md:84
msgid "Numeric literals"
msgstr "숫자 리터럴"

#: src/ch02-02-data-types.md:84 src/appendix-02-operators-and-symbols.md:11
#: src/appendix-07-system-calls.md:177 src/appendix-07-system-calls.md:256
#: src/appendix-07-system-calls.md:331
msgid "Example"
msgstr "예시"

#: src/ch02-02-data-types.md:86
msgid "Decimal"
msgstr "십진법"

#: src/ch02-02-data-types.md:86
msgid "`98222`"
msgstr "98222 -> 98222"

#: src/ch02-02-data-types.md:87
msgid "Hex"
msgstr "16진수"

#: src/ch02-02-data-types.md:87
msgid "`0xff`"
msgstr "`0xff`"

#: src/ch02-02-data-types.md:88
msgid "Octal"
msgstr "8진수"

#: src/ch02-02-data-types.md:88
msgid "`0o04321`"
msgstr "0o04321"

#: src/ch02-02-data-types.md:89
msgid "Binary"
msgstr "이진"

#: src/ch02-02-data-types.md:89
msgid "`0b01`"
msgstr "`0b01`"

#: src/ch02-02-data-types.md:91
msgid ""
"So how do you know which type of integer to use? Try to estimate the max "
"value your int can have and choose the good size. The primary situation in "
"which you’d use `usize` is when indexing some sort of collection."
msgstr ""
"어떤 종류의 정수를 사용해야 하는지 어떻게 알 수 있을까요? int가 가질 수 있는 최대값을 추정해보고 적절한 크기를 선택해보세요. "
"`usize`를 사용하는 기본적인 상황은 어떤 종류의 컬렉션을 인덱싱할 때입니다."

#: src/ch02-02-data-types.md:94
msgid "Numeric Operations"
msgstr "숫자 연산"

#: src/ch02-02-data-types.md:96
msgid ""
"Cairo supports the basic mathematical operations you’d expect for all the "
"integer types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr ""
"카이로는 모든 정수 유형에 대해 기대할 수 있는 기본 수학 연산을 지원합니다: 덧셈, 뺄셈, 곱셈, 나눗셈 및 나머지. 정수 나눗셈은 "
"가장 가까운 정수로 소수점을 버립니다. 다음 코드는 각 숫자 연산을 `let` 문에서 사용하는 방법을 보여줍니다:"

#: src/ch02-02-data-types.md:103
msgid "// addition\n"
msgstr "// 덧셈"

#: src/ch02-02-data-types.md:106
msgid "// subtraction\n"
msgstr "뺄셈"

#: src/ch02-02-data-types.md:109
msgid "// multiplication\n"
msgstr "곱셈"

#: src/ch02-02-data-types.md:112
msgid "// division\n"
msgstr "분할"

#: src/ch02-02-data-types.md:113
msgid "//result is 1\n"
msgstr "결과는 1입니다."

#: src/ch02-02-data-types.md:114
msgid "//result is 2\n"
msgstr "결과는 2입니다."

#: src/ch02-02-data-types.md:116
msgid "// remainder\n"
msgstr "나머지"

#: src/ch02-02-data-types.md:117
msgid "// result is 3\n"
msgstr "결과는 3입니다."

#: src/ch02-02-data-types.md:121
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable."
msgstr "이 문장들의 각 표현은 수학 연산자를 사용하고 단일 값으로 평가되며, 그 값은 변수에 바인딩됩니다."

#: src/ch02-02-data-types.md:124
msgid ""
"[Appendix B](appendix-02-operators-and-symbols.md#operators) contains a list"
" of all operators that Cairo provides."
msgstr ""
"[부록 B](appendix-02-operators-and-symbols.md#operators)에는 카이로가 제공하는 모든 연산자 "
"목록이 포함되어 있습니다."

#: src/ch02-02-data-types.md:126
msgid "The Boolean Type"
msgstr "부울 자료형"

#: src/ch02-02-data-types.md:128
msgid ""
"As in most other programming languages, a Boolean type in Cairo has two "
"possible values: `true` and `false`. Booleans are one `felt252` in size. The"
" Boolean type in Cairo is specified using `bool`. For example:"
msgstr ""
"대부분의 다른 프로그래밍 언어와 마찬가지로, 카이로의 부울 유형에는 `true`와 `false`라는 두 가지 가능한 값이 있습니다. "
"부울은 `felt252` 크기입니다. 카이로의 부울 유형은 `bool`을 사용하여 지정됩니다. 예를 들어:"

#: src/ch02-02-data-types.md:136
msgid "// with explicit type annotation\n"
msgstr "명시적인 유형 주석이 있는 경우"

#: src/ch02-02-data-types.md:140
msgid ""
"When declaring a `bool` variable, it is mandatory to use either `true` or "
"`false` literals as value. Hence, it is not allowed to use integer literals "
"(i.e. `0` instead of false) for `bool` declarations. "
msgstr ""
"`bool` 변수를 선언할 때는 `true` 또는 `false` 리터럴을 값으로 사용해야 합니다. 따라서 `bool` 선언에 정수 "
"리터럴(예: `0` 대신에 false)을 사용하는 것은 허용되지 않습니다."

#: src/ch02-02-data-types.md:142
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Cairo in the [“Control "
"Flow”](ch02-05-control-flow.md) section."
msgstr ""
"부울 값 사용하는 주요 방법은 조건문을 통해 하는 것입니다. 예를 들어 `if` 표현식을 통해 사용합니다. 카이로에서 `if` 표현식이 "
"어떻게 작동하는지는 [“제어 흐름”](ch02-05-control-flow.md) 섹션에서 다룰 것입니다."

#: src/ch02-02-data-types.md:146
msgid "The Short String Type"
msgstr "짧은 문자열 유형"

#: src/ch02-02-data-types.md:148
msgid ""
"Cairo doesn't have a native type for strings, but you can store characters "
"forming what we call a \"short string\" inside `felt252`s. A short string "
"has a max length of 31 chars. This is to ensure that it can fit in a single "
"felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples "
"of declaring values by putting them between single quotes:"
msgstr ""
"카이로에는 문자열을 위한 기본 타입이 없지만, 'felt252' 안에 형성된 문자들을 저장할 수 있습니다. 짧은 문자열은 최대 "
"31자까지입니다. 이는 한 개의 felt(한 개의 felt는 252비트이며, 한 개의 ASCII 문자는 8비트입니다)에 들어갈 수 있도록"
" 보장하기 위한 것입니다. 작은 따옴표 사이에 값을 넣어 선언하는 예시는 다음과 같습니다:"

#: src/ch02-02-data-types.md:153
msgid "'C'"
msgstr "'C'"

#: src/ch02-02-data-types.md:158
msgid "Type Conversion"
msgstr "형 변환"

#: src/ch02-02-data-types.md:160
msgid ""
"In Cairo, you can convert scalar types from one type to another by using the"
" `try_into` and `into` methods provided by the `TryInto` and `Into` traits "
"from the core library."
msgstr ""
"카이로에서는 코어 라이브러리에서 제공하는 `TryInto` 및 `Into` 특성을 사용하여 `try_into` 및 `into` 메서드를 "
"사용하여 하나의 유형에서 다른 유형으로 스칼라 유형을 변환할 수 있습니다."

#: src/ch02-02-data-types.md:162
msgid ""
"The `try_into` method allows for safe type conversion when the target type "
"might not fit the source value. Keep in mind that `try_into` returns an "
"`Option<T>` type, which you'll need to unwrap to access the new value."
msgstr ""
"`try_into` 메서드는 대상 유형이 소스 값에 맞지 않을 수 있을 때 안전한 형 변환을 가능하게 합니다. `try_into`가 "
"`Option<T>` 유형을 반환한다는 것을 염두에 두세요. 이를 언랩하여 새 값에 액세스해야 합니다."

#: src/ch02-02-data-types.md:164
msgid ""
"On the other hand, the `into` method can be used for type conversion when "
"success is guaranteed, such as when the source type is smaller than the "
"destination type."
msgstr ""
"한편, 'into' 메서드는 소스 타입이 대상 타입보다 작을 때와 같이 성공이 보장된 경우에 타입 캐스팅에 사용될 수 있습니다."

#: src/ch02-02-data-types.md:166
msgid ""
"To perform the conversion, call `var.into()` or `var.try_into()` on the "
"source value to convert it to another type. The new variable's type must be "
"explicitly defined, as demonstrated in the example below."
msgstr ""
"변환을 수행하려면 소스 값에 `var.into()` 또는 `var.try_into()`를 호출하여 다른 유형으로 캐스팅해야 합니다. 새 "
"변수의 유형은 명시적으로 정의되어야 하며, 아래 예시에서 보여진 것처럼 되어야 합니다."

#: src/ch02-02-data-types.md:171
msgid ""
"// Since a felt252 might not fit in a u8, we need to unwrap the Option<T> "
"type\n"
msgstr "// felt252가 u8에 맞지 않을 수 있으므로 Option<T> 유형을 풀어야 합니다."

#: src/ch02-02-data-types.md:177
msgid "// As a felt252 is smaller than a u256, we can use the into() method\n"
msgstr "// felt252가 u256보다 작기 때문에 into() 메서드를 사용할 수 있습니다."

#: src/ch02-02-data-types.md:185
msgid "The Tuple Type"
msgstr "튜플 타입"

#: src/ch02-02-data-types.md:187
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr ""
"튜플은 여러 가지 타입의 값들을 하나의 복합 타입으로 묶는 일반적인 방법입니다. 튜플은 고정된 길이를 가지고 있습니다: 한 번 선언되면 "
"크기를 늘리거나 줄일 수 없습니다."

#: src/ch02-02-data-types.md:191
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr ""
"우리는 튜플을 만들 때 괄호 안에 쉼표로 구분된 값들의 목록을 작성합니다. 튜플의 각 위치는 타입을 가지고 있으며, 튜플 내 다른 값들의"
" 타입은 동일할 필요가 없습니다. 이 예시에서는 선택적인 타입 주석을 추가했습니다."

#: src/ch02-02-data-types.md:202
msgid ""
"The variable `tup` binds to the entire tuple because a tuple is considered a"
" single compound element. To get the individual values out of a tuple, we "
"can use pattern matching to destructure a tuple value, like this:"
msgstr ""
"변수 `tup`은 튜플 전체에 바인딩됩니다. 튜플은 단일 복합 요소로 간주되기 때문입니다. 튜플에서 개별 값들을 가져오려면, 이와 같이 "
"패턴 매칭을 사용하여 튜플 값을 해체할 수 있습니다:"

#: src/ch02-02-data-types.md:213
msgid "\"y is 6!\""
msgstr "\"y는 6입니다!\""

#: src/ch02-02-data-types.md:218
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate"
" variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints `y is "
"six` as the value of `y` is `6`."
msgstr ""
"이 프로그램은 먼저 튜플을 생성하고 변수 `tup`에 바인딩합니다. 그런 다음 `let`을 사용하여 `tup`을 가져와 `x`, `y`,"
" `z` 세 개의 별도 변수로 변환하는 패턴을 사용합니다. 이것을 _해체_ 라고 부르는데, 이는 단일 튜플을 세 부분으로 나누기 "
"때문입니다. 마지막으로 프로그램은 `y is six`를 출력합니다. `y`의 값이 `6`이기 때문입니다."

#: src/ch02-02-data-types.md:224
msgid ""
"We can also declare the tuple with value and types, and destructure it at "
"the same time. For example:"
msgstr "우리는 값과 타입을 가진 튜플을 선언하고 동시에 해체할 수도 있습니다. 예를 들면:"

#: src/ch02-02-data-types.md:233
msgid "The unit type ()"
msgstr "단위 유형 ()"

#: src/ch02-02-data-types.md:235
msgid ""
"A _unit type_ is a type which has only one value `()`. It is represented by "
"a tuple with no elements. Its size is always zero, and it is guaranteed to "
"not exist in the compiled code."
msgstr ""
"유닛 유형은 단 하나의 값 `()`을 가지는 유형입니다. 요소가 없는 튜플로 표현됩니다. 크기는 항상 0이며, 컴파일된 코드에는 존재하지"
" 않음이 보장됩니다."

#: src/ch02-03-functions.md:3
msgid ""
"Functions are prevalent in Cairo code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry"
" point of many programs. You’ve also seen the `fn` keyword, which allows you"
" to declare new functions."
msgstr ""
"기능은 카이로 코드에서 흔히 볼 수 있습니다. 이미 언어에서 가장 중요한 기능 중 하나인 `main` 함수를 보았습니다. 이 함수는 많은"
" 프로그램의 진입점입니다. 또한 새로운 함수를 선언할 수 있도록 하는 `fn` 키워드도 보았습니다."

#: src/ch02-03-functions.md:8
msgid ""
"Cairo code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""
"카이로 코드는 함수와 변수 이름에 대해 관례적으로 _스네이크 케이스_ 를 사용합니다. 이는 모든 글자가 소문자이고 밑줄로 단어가 구분되는 "
"스타일입니다. 다음은 예제 함수 정의를 포함하는 프로그램입니다:"

#: src/ch02-03-functions.md:14
msgid "\"Another function.\""
msgstr "\"또 다른 기능.\""

#: src/ch02-03-functions.md:18
msgid "\"Hello, world!\""
msgstr "Hello, World!"

#: src/ch02-03-functions.md:23
msgid ""
"We define a function in Cairo by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""
"카이로에서 함수를 정의할 때는 함수 이름 뒤에 괄호 집합을 입력하는 `fn`을 사용합니다. 중괄호는 컴파일러에게 함수 본문이 어디에서 "
"시작하고 끝나는지 알려줍니다."

#: src/ch02-03-functions.md:27
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it"
" can be called from inside the `main` function. Note that we defined "
"`another_function` _before_ the `main` function in the source code; we could"
" have defined it after as well. Cairo doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""
"우리는 정의한 모든 함수를 이름 뒤에 괄호 집합을 입력하여 호출할 수 있습니다. `another_function`이 프로그램에서 "
"정의되었기 때문에 `main` 함수 내부에서 호출할 수 있습니다. 소스 코드에서 `main` 함수보다 `another_function`을"
" _앞에_ 정의했음을 유의해야 합니다; 뒤에 정의해도 괜찮습니다. 카이로는 함수를 정의하는 위치에 상관하지 않고, 호출자가 볼 수 있는 "
"범위 내에서 정의되어 있다면 됩니다."

#: src/ch02-03-functions.md:34
msgid ""
"Let’s start a new project with Scarb named _functions_ to explore functions "
"further. Place the `another_function` example in _src/lib.cairo_ and run it."
" You should see the following output:"
msgstr ""
"Scarb라는 이름의 _functions_ 로 새 프로젝트를 시작하여 함수를 더 탐구해 봅시다. `another_function` 예제를 "
"_src/lib.cairo_ 에 배치하고 실행하세요. 다음 출력이 표시됩니다:"

#: src/ch02-03-functions.md:45
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""
"`main` 함수에 나타나는 순서대로 라인이 실행됩니다. 먼저 \"Hello, world!\" 메시지가 출력되고, 그 후에 "
"`another_function`이 호출되어 해당 메시지가 출력됩니다."

#: src/ch02-03-functions.md:49
msgid "Parameters"
msgstr "매개변수"

#: src/ch02-03-functions.md:51
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you"
" can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""
"함수를 _매개변수_ 를 가지도록 정의할 수 있습니다. 매개변수는 함수의 서명 부분에 속하는 특별한 변수들입니다. 함수에 매개변수가 있을 "
"때, 해당 매개변수에 구체적인 값을 제공할 수 있습니다. 엄밀히 말하면, 구체적인 값들을 _인수_ 라고 부르지만 일상 대화에서는 함수의 "
"정의에 있는 변수들이나 함수를 호출할 때 전달되는 구체적인 값들을 나타낼 때 _매개변수_ 와 _인수_ 라는 용어를 서로 바꿔 사용하는 경향이"
" 있습니다."

#: src/ch02-03-functions.md:59
msgid "In this version of `another_function` we add a parameter:"
msgstr "`another_function`의 이 버전에서는 매개변수를 추가합니다:"

#: src/ch02-03-functions.md:71
msgid "Try running this program; you should get the following output:"
msgstr "이 프로그램을 실행해보세요; 다음과 같은 출력을 얻어야 합니다:"

#: src/ch02-03-functions.md:79
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `felt252`. When we pass `5` in to `another_function`,"
" the `println!` macro puts `5` where the pair of curly brackets containing "
"`x` was in the format string."
msgstr ""
"`another_function`의 선언은 `x`라는 하나의 매개변수를 가지고 있습니다. `x`의 유형은 `felt252`로 지정되어 "
"있습니다. `another_function`에 `5`를 전달하면 `println!` 매크로가 형식 문자열에 있는 `x`를 포함한 중괄호 "
"쌍 자리에 `5`를 넣습니다."

#: src/ch02-03-functions.md:83
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Cairo’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also"
" able to give more helpful error messages if it knows what types the "
"function expects."
msgstr ""
"함수 시그니처에서는 각 매개변수의 유형을 _반드시_ 선언해야 합니다. 이는 Cairo의 설계에서 의도적으로 결정된 사항입니다: 함수 "
"정의에서 유형 주석을 요구함으로써 컴파일러가 다른 곳에서 유형을 알아내기 위해 거의 사용할 필요가 없다는 것을 의미합니다. 또한 "
"컴파일러는 함수가 어떤 유형을 기대하는지 알고 있을 때 더 유용한 오류 메시지를 제공할 수 있습니다."

#: src/ch02-03-functions.md:89
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr "여러 매개변수를 정의할 때는 매개변수 선언을 쉼표로 구분하여 작성합니다. 예를 들면,"

#: src/ch02-03-functions.md:94
msgid "\"h\""
msgstr "\"h\""

#: src/ch02-03-functions.md:98
msgid "\"The measurement is: {value}{unit_label}\""
msgstr "\"측정값은: {value}{unit_label}\""

#: src/ch02-03-functions.md:102
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is a `u128`. The second"
" is named `unit_label` and is of type `ByteArray` - Cairo's internal type to"
" represent string literals. The function then prints text containing both "
"the `value` and the `unit_label`."
msgstr ""
"이 예제는 두 개의 매개변수를 가진 `print_labeled_measurement` 함수를 생성합니다. 첫 번째 매개변수는 "
"`value`라는 이름을 가지며 `u128` 형식입니다. 두 번째 매개변수는 `unit_label`이라는 이름을 가지며 "
"`ByteArray` 형식입니다 - 문자열 리터럴을 나타내는 Cairo의 내부 형식입니다. 그런 다음 함수는 `value`와 "
"`unit_label`을 모두 포함하는 텍스트를 출력합니다."

#: src/ch02-03-functions.md:106
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/lib.cairo_ file with the preceding example and "
"run it using `scarb cairo-run`:"
msgstr ""
"이 코드를 실행해 봅시다. 이전 예제로 현재 _functions_ 프로젝트의 _src/lib.cairo_ 파일에 있는 프로그램을 대체하고"
" `scarb cairo-run`을 사용하여 실행해 보세요."

#: src/ch02-03-functions.md:115
msgid ""
"Because we called the function with `5` as the value for value and `\"h\"` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""
"함수를 `5`로 값으로 호출하고 `unit_label`에 `\"h\"`를 값으로 전달했기 때문에 프로그램 출력에는 해당 값이 포함되어 "
"있습니다."

#: src/ch02-03-functions.md:117
msgid "Named parameters"
msgstr "이름이 지정된 매개변수"

#: src/ch02-03-functions.md:119
msgid ""
"In Cairo, named parameters allow you to specify the names of arguments when "
"you call a function. This makes the function calls more readable and self-"
"descriptive. If you want to use named parameters, you need to specify the "
"name of the parameter and the value you want to pass to it. The syntax is "
"`parameter_name: value`. If you pass a variable that has the same name as "
"the parameter, you can simply write `:parameter_name` instead of "
"`parameter_name: variable_name`."
msgstr ""
"카이로에서는 명명된 매개변수를 사용하여 함수를 호출할 때 인수의 이름을 지정할 수 있습니다. 이렇게 하면 함수 호출이 더 가독성이 있고 "
"자기 설명적이 됩니다. 명명된 매개변수를 사용하려면 매개변수의 이름과 전달하려는 값을 지정해야 합니다. 구문은 `매개변수_이름: "
"값`입니다. 매개변수와 같은 이름을 가진 변수를 전달하려면 `매개변수_이름: 변수_이름` 대신에 `:매개변수_이름`으로 간단히 작성할 수"
" 있습니다."

#: src/ch02-03-functions.md:122
msgid "Here is an example:"
msgstr "다음은 예시입니다."

#: src/ch02-03-functions.md:137
msgid "Statements and Expressions"
msgstr "문장과 표현"

#: src/ch02-03-functions.md:139
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Cairo is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions,"
" so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""
"함수 본문은 선택적으로 표현식으로 끝나는 일련의 문으로 구성됩니다. 지금까지 다룬 함수들은 끝 표현식을 포함하지 않았지만, 문의 일부로서"
" 표현식을 보았습니다. 카이로는 표현식 중심 언어이기 때문에 이는 이해해야 할 중요한 구분입니다. 다른 언어들은 같은 구분을 가지고 있지"
" 않으므로 문과 표현식이 무엇이며 이들의 차이가 함수 본문에 어떻게 영향을 미치는지 살펴봅시다."

#: src/ch02-03-functions.md:147
msgid ""
"**Statements** are instructions that perform some action and do not return a"
" value."
msgstr "**Statements(문)**는 어떤 동작을 수행하고 값을 반환하지 않는 명령문입니다."

#: src/ch02-03-functions.md:149
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "**표현식**은 결과값으로 평가됩니다. 몇 가지 예를 살펴보겠습니다."

#: src/ch02-03-functions.md:151
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 2-1, `let y = 6;` is a statement."
msgstr ""
"우리는 실제로 이미 문장과 표현을 사용했습니다. 변수를 만들고 `let` 키워드를 사용하여 값을 할당하는 것은 문장입니다. 2-1 "
"목록에서 `let y = 6;`는 문장입니다."

#: src/ch02-03-functions.md:161
msgid "Listing 2-1: A `main` function declaration containing one statement"
msgstr "리스트 2-1: 하나의 문을 포함하는 `main` 함수 선언"

#: src/ch02-03-functions.md:163
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself."
msgstr "함수 정의는 또한 문장입니다; 앞서의 전체 예제는 그 자체로 문장입니다."

#: src/ch02-03-functions.md:166
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get"
" an error:"
msgstr ""
"문장은 값을 반환하지 않습니다. 따라서 다음 코드에서 시도하는 것처럼 `let` 문을 다른 변수에 할당할 수 없습니다. 오류가 "
"발생합니다."

#: src/ch02-03-functions.md:175
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "이 프로그램을 실행하면 발생하는 오류는 다음과 같이 보입니다:"

#: src/ch02-03-functions.md:199
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Cairo."
msgstr ""
"`let y = 6` 문은 값을 반환하지 않으므로 `x`에 바인딩할 것이 없습니다. 이는 C나 Ruby와 같은 다른 언어에서 발생하는 "
"일과 다릅니다. 거기서는 할당이 할당의 값으로 반환됩니다. 그러한 언어에서는 `x = y = 6`을 작성하여 `x`와 `y`가 모두 "
"`6`의 값을 가질 수 있습니다. 하지만 이는 Cairo에서는 그렇지 않습니다."

#: src/ch02-03-functions.md:205
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Cairo. Consider a math operation, such as `5 + 6`, "
"which is an expression that evaluates to the value `11`. Expressions can be "
"part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is"
" an expression that evaluates to the value `6`."
msgstr ""
"표현식은 값을 평가하고 카이로에서 작성할 대부분의 코드를 구성합니다. 수학 연산과 같은 것을 고려해보세요. `5 + 6`과 같은 것은 "
"`11`이라는 값으로 평가되는 표현식입니다. 표현식은 문장의 일부가 될 수 있습니다. 예를 들어, 2-1 목록에서 `let y = 6;`"
" 문장에서 `6`은 `6`이라는 값으로 평가되는 표현식입니다."

#: src/ch02-03-functions.md:211
msgid ""
"Calling a function is an expression since it always evaluates to a value: "
"the function's explicit return value, if specified, or the 'unit' type `()` "
"otherwise."
msgstr ""
"함수를 호출하는 것은 항상 값을 평가하기 때문에 표현식입니다: 함수의 명시적 반환 값(지정된 경우) 또는 그렇지 않으면 'unit' 유형"
" `()`입니다."

#: src/ch02-03-functions.md:213
msgid ""
"A new scope block created with curly brackets is an expression, for example:"
msgstr "중괄호로 생성된 새로운 스코프 블록은 표현식입니다. 예를 들어:"

#: src/ch02-03-functions.md:223
msgid "\"The value of y is: {}\""
msgstr "\"y의 값은: {}\""

#: src/ch02-03-functions.md:227
msgid "This expression:"
msgstr "이 표현:"

#: src/ch02-03-functions.md:236
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to"
" the end of an expression, you turn it into a statement, and it will then "
"not return a value. Keep this in mind as you explore function return values "
"and expressions next."
msgstr ""
"이 경우에는 `4`로 평가되는 블록입니다. 이 값은 `let` 문의 일부로 `y`에 바인딩됩니다. `x + 1` 라인에는 세미콜론이 없는"
" 것에 주목하세요. 이는 지금까지 보았던 대부분의 라인과 다릅니다. 표현식에는 끝에 세미콜론이 포함되지 않습니다. 표현식 끝에 세미콜론을"
" 추가하면 그것을 문으로 변환시키고, 그러면 값이 반환되지 않습니다. 다음에 함수 반환 값과 표현식을 탐색할 때 이를 염두에 두세요."

#: src/ch02-03-functions.md:244
msgid "Functions with Return Values"
msgstr "반환 값이 있는 함수"

#: src/ch02-03-functions.md:246
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Cairo, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""
"함수는 호출하는 코드에 값을 반환할 수 있습니다. 반환 값을 이름 지정하지 않지만 화살표(`->`) 뒤에 타입을 선언해야 합니다. "
"Cairo에서 함수의 반환 값은 함수 몸체 블록의 마지막 표현식의 값과 동의어입니다. `return` 키워드를 사용하여 값을 지정하여 "
"함수를 일찍 종료할 수 있지만 대부분의 함수는 마지막 표현식을 암시적으로 반환합니다. 값이 반환되는 함수의 예시는 다음과 같습니다:"

#: src/ch02-03-functions.md:265
msgid ""
"There are no function calls, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in"
" Cairo. Note that the function’s return type is specified too, as `-> u32`. "
"Try running this code; the output should look like this:"
msgstr ""
"`five` 함수에는 함수 호출이나 심지어 `let` 문도 없습니다. 그냥 숫자 `5`만 있습니다. 이것은 카이로에서 완벽히 유효한 "
"함수입니다. 함수의 반환 유형이 `-> u32`로 지정되어 있음에 유의하십시오. 이 코드를 실행해보세요. 출력은 다음과 같아야 합니다:"

#: src/ch02-03-functions.md:276
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `u32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""
"`five` 함수에서의 `5`는 함수의 반환 값이며, 이에 따라 반환 형식은 `u32`입니다. 이를 더 자세히 살펴봅시다. 두 가지 "
"중요한 점이 있습니다. 먼저, `let x = five();` 라인은 함수의 반환 값을 변수를 초기화하는 데 사용한다는 것을 보여줍니다."
" `five` 함수가 `5`를 반환하기 때문에 해당 라인은 다음과 같습니다:"

#: src/ch02-03-functions.md:286
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon"
" because it’s an expression whose value we want to return. Let’s look at "
"another example:"
msgstr ""
"두 번째로, `five` 함수는 매개변수가 없으며 반환 값의 유형을 정의하지만 함수의 본문은 `5`만 있는데 세미콜론이 없습니다. "
"왜냐하면 반환하려는 값의 표현식이기 때문입니다. 다른 예제를 살펴보겠습니다:"

#: src/ch02-03-functions.md:303
msgid ""
"Running this code will print `x = 6`. But if we place a semicolon at the end"
" of the line containing `x + 1`, changing it from an expression to a "
"statement, we’ll get an error:"
msgstr ""
"이 코드를 실행하면 `x = 6`이 출력됩니다. 그러나 `x + 1`을 포함하는 줄 끝에 세미콜론을 넣어 표현식을 문으로 변경하면 오류가"
" 발생합니다."

#: src/ch02-03-functions.md:320
msgid ""
"```shell\n"
"error: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n"
"```"
msgstr ""
"```shell\n"
"에러: 예상하지 못한 반환 형식. 예상: \"core::integer::u32\", 발견: \"()\".\n"
"```"

#: src/ch02-03-functions.md:324
msgid ""
"The main error message, `Unexpected return type`, reveals the core issue "
"with this code. The definition of the function `plus_one` says that it will "
"return an `u32`, but statements don’t evaluate to a value, which is "
"expressed by `()`, the unit type. Therefore, nothing is returned, which "
"contradicts the function definition and results in an error."
msgstr ""
"주요 오류 메시지인 `예상치 못한 반환 유형`은 이 코드의 핵심 문제를 드러냅니다. 함수 `plus_one`의 정의는 `u32`를 반환할"
" 것이라고 말하지만, 문장은 값으로 평가되지 않습니다. 값으로 평가되지 않는 것은 `()`로 표현되는 단위 유형입니다. 따라서 아무것도 "
"반환되지 않으며, 이는 함수 정의와 모순되어 오류를 발생시킵니다."

#: src/ch02-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave comments "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr ""
"모든 프로그래머들은 코드를 이해하기 쉽게 만들기 위해 노력하지만 때로는 추가 설명이 필요할 수 있습니다. 이러한 경우에 프로그래머들은 "
"소스 코드에 주석을 남기는데, 컴파일러는 무시하지만 소스 코드를 읽는 사람들에게 유용할 수 있습니다."

#: src/ch02-04-comments.md:5
msgid "Here’s a simple comment:"
msgstr "여기 간단한 코멘트가 있습니다:"

#: src/ch02-04-comments.md:8
msgid "// hello, world\n"
msgstr "// Hello, World"

#: src/ch02-04-comments.md:11
msgid ""
"In Cairo, the idiomatic comment style starts a comment with two slashes, and"
" the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr ""
"카이로에서는 관용적인 주석 스타일이 두 개의 슬래시로 시작하여 주석이 라인의 끝까지 계속됩니다. 한 줄을 넘어가는 주석의 경우 각 줄마다"
" `//`를 포함해야 합니다. 이렇게요:"

#: src/ch02-04-comments.md:14
msgid ""
"// So we’re doing something complicated here, long enough that we need\n"
"// multiple lines of comments to do it! Whew! Hopefully, this comment will\n"
"// explain what’s going on.\n"
msgstr ""
"// 우리는 여기서 복잡한 작업을 수행하고 있습니다. 이 작업은 너무 길어서 여러 줄의 주석이 필요합니다! 휴! 이 주석이 무슨 일이 "
"일어나고 있는지 설명해줄 것입니다."

#: src/ch02-04-comments.md:19
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "주석은 코드를 포함하는 줄의 끝에도 배치할 수 있습니다."

#: src/ch02-04-comments.md:25
msgid "// return the sum of 1 and 4\n"
msgstr "// 1과 4의 합을 반환합니다."

#: src/ch02-04-comments.md:29
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr "그러나 더 자주 이 형식으로 사용되는 것을 볼 수 있습니다. 주석이 주석 처리하는 코드 위에 별도의 줄로 작성되어 있습니다."

#: src/ch02-04-comments.md:35
msgid "// this function performs a simple addition\n"
msgstr "이 함수는 간단한 덧셈을 수행합니다."

#: src/ch02-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is true and to"
" run some code repeatedly while a condition is true are basic building "
"blocks in most programming languages. The most common constructs that let "
"you control the flow of execution of Cairo code are if expressions and "
"loops."
msgstr ""
"대부분의 프로그래밍 언어에서 조건이 참인 경우 일부 코드를 실행하고 조건이 참인 동안 일부 코드를 반복해서 실행할 수 있는 능력은 가장 "
"기본적인 구성 요소입니다. Cairo 코드의 실행 흐름을 제어할 수 있는 가장 일반적인 구조는 if 표현식과 루프입니다."

#: src/ch02-05-control-flow.md:5
msgid "`if` Expressions"
msgstr "`if` 표현"

#: src/ch02-05-control-flow.md:7
msgid ""
"An if expression allows you to branch your code depending on conditions. You"
" provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr ""
"if 표현식을 사용하면 조건에 따라 코드를 분기할 수 있습니다. 조건을 제공한 다음 \"이 조건이 충족되면 이 코드 블록을 실행합니다. "
"조건이 충족되지 않으면 이 코드 블록을 실행하지 마십시오.\" 라고 명시합니다."

#: src/ch02-05-control-flow.md:9
msgid ""
"Create a new project called _branches_ in your _cairo_projects_ directory to"
" explore the `if` expression. In the _src/lib.cairo_ file, input the "
"following:"
msgstr ""
"`if` 표현식을 탐색하기 위해 _cairo_projects_ 디렉토리에 _branches_ 라는 새 프로젝트를 생성하십시오. "
"_src/lib.cairo_ 파일에 다음을 입력하십시오:"

#: src/ch02-05-control-flow.md:18
msgid "\"condition was true and number = {}\""
msgstr "\"조건이 참이고 숫자 = {}\""

#: src/ch02-05-control-flow.md:20
msgid "\"condition was false and number = {}\""
msgstr ""
"\"condition was false and number = {}\" \n"
"\n"
"\"조건이 거짓이고 숫자 = {}\""

#: src/ch02-05-control-flow.md:25
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value equal to 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets."
msgstr ""
"모든 `if` 표현식은 `if` 키워드로 시작하고 조건이 이어집니다. 이 경우에는 조건이 변수 `number`의 값이 5와 같은지 "
"확인합니다. 조건이 `true`인 경우 실행할 코드 블록을 중괄호 안에 조건 바로 뒤에 배치합니다."

#: src/ch02-05-control-flow.md:27
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the"
" condition evaluate to `false`. If you don’t provide an `else` expression "
"and the condition is `false`, the program will just skip the `if` block and "
"move on to the next bit of code."
msgstr ""
"선택적으로, 우리는 `else` 표현식을 포함할 수도 있는데, 여기서는 그렇게 선택했고, 조건이 `false`로 평가될 경우 실행할 대체"
" 코드 블록을 프로그램에 제공합니다. 만약 `else` 표현식을 제공하지 않고 조건이 `false`인 경우, 프로그램은 `if` 블록을 "
"건너뛰고 다음 코드 조각으로 넘어갈 것입니다."

#: src/ch02-05-control-flow.md:29
msgid "Try running this code; you should see the following output:"
msgstr "이 코드를 실행해보세요; 다음 출력을 볼 수 있어야 합니다:"

#: src/ch02-05-control-flow.md:37
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition"
" `true` to see what happens:"
msgstr "`number`의 값을 'true'로 만드는 값으로 변경해 보겠습니다. 결과가 어떻게 되는지 확인해 봅시다."

#: src/ch02-05-control-flow.md:49
msgid ""
"It’s also worth noting that the condition in this code must be a `bool`. If "
"the condition isn’t a `bool`, we’ll get an error. For example, try running "
"the following code:"
msgstr ""
"이 코드에서 조건은 `bool`이어야 한다는 점도 주목할 가치가 있습니다. 조건이 `bool`이 아니면 오류가 발생합니다. 예를 들어, "
"다음 코드를 실행해 보세요:"

#: src/ch02-05-control-flow.md:59
msgid "\"number was three\""
msgstr "\"숫자는 세였다\""

#: src/ch02-05-control-flow.md:64
msgid ""
"The `if` condition evaluates to a value of 3 this time, and Cairo throws an "
"error:"
msgstr "이번에 `if` 조건은 값 3으로 평가되고, 카이로가 오류를 발생시킵니다."

#: src/ch02-05-control-flow.md:78
msgid ""
"The error indicates that Cairo inferred the type of `number` to be a `bool` "
"based on its later use as a condition of the `if` statement. It tries to "
"create a `bool` from the value `3`, but Cairo doesn't support instantiating "
"a `bool` from a numeric literal anyway - you can only use `true` or `false` "
"to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will"
" not automatically try to convert non-Boolean types to a Boolean. If we want"
" the `if` code block to run only when a number is not equal to 0, for "
"example, we can change the if expression to the following:"
msgstr ""
"오류는 Cairo가 `number`의 유형을 `if` 문의 조건으로 나중에 사용하여 `bool`로 추론했다는 것을 나타냅니다. `3` "
"값을 기반으로 `bool`을 만들려고 시도하지만 Cairo는 숫자 리터럴에서 `bool`을 인스턴스화하는 것을 지원하지 않습니다 - "
"`true` 또는 `false`만 사용하여 `bool`을 만들 수 있습니다. 루비나 자바스크립트와 같은 언어와 달리 Cairo는 자동으로"
" 비부울 유형을 부울로 변환하지 않습니다. 예를 들어 숫자가 0이 아닐 때에만 `if` 코드 블록을 실행하려면 if 표현식을 다음과 같이"
" 변경할 수 있습니다:"

#: src/ch02-05-control-flow.md:92
msgid "\"number was something other than zero\""
msgstr "\"숫자는 영(0)이 아닌 다른 것이었습니다.\""

#: src/ch02-05-control-flow.md:98
msgid "Running this code will print `number was something other than zero`."
msgstr "이 코드를 실행하면 `number was something other than zero`가 출력됩니다."

#: src/ch02-05-control-flow.md:100
msgid "Handling Multiple Conditions with `else if`"
msgstr "`else if`를 사용하여 여러 조건 처리하기"

#: src/ch02-05-control-flow.md:102
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if`"
" expression. For example:"
msgstr ""
"`if`와 `else`를 결합하여 `else if` 표현식에서 여러 조건을 사용할 수 있습니다. 예를 들어:"

#: src/ch02-05-control-flow.md:111
msgid "\"number is 12\""
msgstr "\"숫자는 12입니다\""

#: src/ch02-05-control-flow.md:113
msgid "\"number is 3\""
msgstr "\"숫자는 3입니다\""

#: src/ch02-05-control-flow.md:115
msgid "\"number minus 2 is 1\""
msgstr "\"숫자에서 2를 빼면 1이 됩니다.\""

#: src/ch02-05-control-flow.md:117
msgid "\"number not found\""
msgstr "\"번호를 찾을 수 없습니다\""

#: src/ch02-05-control-flow.md:122
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr "이 프로그램은 취할 수 있는 네 가지 가능한 경로가 있습니다. 실행한 후에는 다음 출력을 볼 수 있어야 합니다:"

#: src/ch02-05-control-flow.md:130
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though `number - 2 == 1` is `true`, we don’t see the output "
"`number minus 2 is 1` nor do we see the `number not found` text from the "
"`else` block. That’s because Cairo only executes the block for the first "
"true condition, and once it finds one, it doesn’t even check the rest. Using"
" too many `else if` expressions can clutter your code, so if you have more "
"than one, you might want to refactor your code. [Chapter 6](./ch06-02-the-"
"match-control-flow-construct.md) describes a powerful Cairo branching "
"construct called `match` for these cases."
msgstr ""
"이 프로그램이 실행되면 각 `if` 표현식을 차례로 확인하고 조건이 `true`로 평가되는 첫 번째 본문을 실행합니다. `number -"
" 2 == 1`이 `true`이지만 `number minus 2 is 1` 출력이나 `else` 블록에서 `number not "
"found` 텍스트를 볼 수 없습니다. 이는 Cairo가 첫 번째 true 조건에 대해 블록을 실행하고, 한 번 찾으면 나머지를 심지도 "
"않기 때문입니다. 너무 많은 `else if` 표현식을 사용하면 코드가 혼란스러워질 수 있으므로 하나 이상이 있는 경우 코드를 다시 "
"작성하는 것이 좋습니다. [6장](./ch06-02-the-match-control-flow-construct.md)에서는 이러한 경우에"
" 대해 강력한 Cairo 분기 구조인 `match`를 설명합니다."

#: src/ch02-05-control-flow.md:132
msgid "Using `if` in a `let` statement"
msgstr "`let` 문에서 `if`를 사용하기"

#: src/ch02-05-control-flow.md:134
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable."
msgstr "`if`가 표현식이기 때문에, `let` 문의 오른쪽에 사용하여 결과를 변수에 할당할 수 있습니다."

#: src/ch02-05-control-flow.md:148
msgid "\"condition was true and number is {}\""
msgstr "\"조건이 참이고 숫자는 {}입니다.\""

#: src/ch02-05-control-flow.md:159
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression, which will be 5 here."
msgstr "`number` 변수는 `if` 표현식의 결과에 따라 값에 바인딩될 것이며, 여기서는 5가 될 것입니다."

#: src/ch02-05-control-flow.md:161
msgid "Repetition with Loops"
msgstr "반복문을 사용한 반복"

#: src/ch02-05-control-flow.md:163
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Cairo provides a simple loop syntax, which will run through the code inside "
"the loop body to the end and then start immediately back at the beginning. "
"To experiment with loops, let’s create a new project called _loops_."
msgstr ""
"코드 블록을 한 번 이상 실행하는 것이 종종 유용합니다. 이 작업을 위해, 카이로는 간단한 루프 구문을 제공합니다. 이 구문은 루프 본문"
" 내의 코드를 끝까지 실행한 다음 즉시 다시 처음부터 시작합니다. 루프를 실험해 보기 위해 _loops_ 라는 새 프로젝트를 만들어 "
"봅시다."

#: src/ch02-05-control-flow.md:165
msgid "Cairo has two kinds of loops: `loop` and `while`."
msgstr "카이로에는 `loop`와 `while` 두 종류의 루프가 있습니다."

#: src/ch02-05-control-flow.md:167
msgid "Repeating Code with `loop`"
msgstr "`loop`를 사용하여 코드 반복하기"

#: src/ch02-05-control-flow.md:169
msgid ""
"The `loop` keyword tells Cairo to execute a block of code over and over "
"again forever or until you explicitly tell it to stop."
msgstr "`loop` 키워드는 카이로에게 코드 블록을 영원히 반복하거나 명시적으로 중지하라고 할 때까지 계속 실행하도록 지시합니다."

#: src/ch02-05-control-flow.md:171
msgid ""
"As an example, change the _src/lib.cairo_ file in your _loops_ directory to "
"look like this:"
msgstr "예를 들어, _loops_ 디렉토리의 _src/lib.cairo_ 파일을 다음과 같이 변경하십시오:"

#: src/ch02-05-control-flow.md:177
msgid "\"again!\""
msgstr "\"다시!\""

#: src/ch02-05-control-flow.md:185
msgid ""
"Note: This program would not compile without a break condition. For the "
"purpose of the example, we added a `break` statement that will never be "
"reached, but satisfies the compiler."
msgstr ""
"참고: 이 프로그램은 중단 조건 없이는 컴파일되지 않습니다. 예제를 위해 절대 도달되지 않지만 컴파일러를 만족시키는 `break` 문을 "
"추가했습니다."

#: src/ch02-05-control-flow.md:187
msgid ""
"When we run this program, we’ll see again! printed over and over "
"continuously until either the program runs out of gas or we stop the program"
" manually. Most terminals support the keyboard shortcut ctrl-c to interrupt "
"a program that is stuck in a continual loop. Give it a try:"
msgstr ""
"이 프로그램을 실행하면 계속해서 \"we’ll see again!\"가 출력됩니다. 프로그램이 연료를 다 써버리거나 우리가 프로그램을 수동으로 중지할 "
"때까지 계속 반복됩니다. 대부분의 터미널은 계속된 루프에 갇힌 프로그램을 중단하는 키보드 단축키인 ctrl-c를 지원합니다. 한 번 "
"시도해보세요."

#: src/ch02-05-control-flow.md:188
msgid ""
"```shell\n"
"$ scarb cairo-run --available-gas=2000000000000\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished release target(s) in 0 seconds\n"
"     Running loops\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch02-05-control-flow.md:198
msgid ""
"The symbol `^C` represents where you pressed ctrl-c. You may or may not see "
"the word `again!` printed after the ^C, depending on where the code was in "
"the loop when it received the interrupt signal."
msgstr ""
"심볼 `^C`는 당신이 ctrl-c를 누른 곳을 나타냅니다. 인터럽트 신호를 받은 코드가 루프 어디에 있었느냐에 따라 "
"`again!`이라는 단어가 ^C 뒤에 출력되었을 수도 있고 아닐 수도 있습니다."

#: src/ch02-05-control-flow.md:200
msgid ""
"Note: Cairo prevents us from running program with infinite loops by "
"including a gas meter. The gas meter is a mechanism that limits the amount "
"of computation that can be done in a program. By setting a value to the "
"`--available-gas` flag, we can set the maximum amount of gas available to "
"the program. Gas is a unit of measurement that expresses the computation "
"cost of an instruction. When the gas meter runs out, the program will stop. "
"In the previous case, we set the gas limit high enough for the the program "
"to run for quite some time."
msgstr ""
"참고: 카이로는 무한 루프로 인한 프로그램 실행을 방지하기 위해 가스 미터를 포함합니다. 가스 미터는 프로그램에서 수행할 수 있는 계산 "
"양을 제한하는 메커니즘입니다. `--available-gas` 플래그에 값을 설정하여 프로그램에 사용 가능한 최대 가스 양을 설정할 수 "
"있습니다. 가스는 명령의 계산 비용을 표현하는 측정 단위입니다. 가스 미터가 소진되면 프로그램이 중지됩니다. 이전 경우에는 프로그램이 "
"상당한 시간 동안 실행되도록 가스 한도를 충분히 설정했습니다."

#: src/ch02-05-control-flow.md:202
msgid ""
"It is particularly important in the context of smart contracts deployed on "
"Starknet, as it prevents from running infinite loops on the network. If "
"you're writing a program that needs to run a loop, you will need to execute "
"it with the `--available-gas` flag set to a value that is large enough to "
"run the program."
msgstr ""
"스마트 계약이 Starknet에 배포될 때 특히 중요한데, 이는 네트워크에서 무한 루프를 실행하는 것을 방지합니다. 루프를 실행해야 하는"
" 프로그램을 작성 중이라면, 프로그램을 실행하기 위해 `--available-gas` 플래그를 사용하여 충분히 큰 값으로 설정해야 "
"합니다."

#: src/ch02-05-control-flow.md:205
msgid ""
"Now, try running the same program again, but this time with the "
"`--available-gas` flag set to `200000` instead of `2000000000000`. You will "
"see the program only prints `again!` 3 times before it stops, as it ran out "
"of gas to keep executing the loop."
msgstr ""
"이제 동일한 프로그램을 다시 실행해보세요. 이번에는 `--available-gas` 플래그를 `2000000000000` 대신 "
"`200000`으로 설정해보세요. 루프를 계속 실행할 가스가 부족하여 프로그램이 멈추기 전에 `again!`을 3번만 출력하는 것을 볼 "
"수 있을 겁니다."

#: src/ch02-05-control-flow.md:207
msgid ""
"Fortunately, Cairo also provides a way to break out of a loop using code. "
"You can place the `break` keyword within the loop to tell the program when "
"to stop executing the loop."
msgstr ""
"다행히도, 카이로는 코드를 사용하여 루프를 탈출하는 방법을 제공합니다. 루프 내에 `break` 키워드를 배치하여 프로그램에게 루프 "
"실행을 중지할 때를 알릴 수 있습니다."

#: src/ch02-05-control-flow.md:216 src/ch02-05-control-flow.md:236
msgid "\"i = {}\""
msgstr "\"i = {}\""

#: src/ch02-05-control-flow.md:222
msgid ""
"The `continue` keyword tells the program to go to the next iteration of the "
"loop and to skip the rest of the code in this iteration.  Let's add a "
"`continue` statement to our loop to skip the `print` statement when `i` is "
"equal to `5`."
msgstr ""
"`continue` 키워드는 프로그램에게 루프의 다음 반복으로 이동하고 이 반복에서의 나머지 코드를 건너뛰도록 지시합니다. `i`가 "
"`5`와 같을 때 `print` 문을 건너뛰기 위해 루프에 `continue` 문을 추가해 봅시다."

#: src/ch02-05-control-flow.md:242
msgid ""
"Executing this program will not print the value of `i` when it is equal to "
"`5`."
msgstr "이 프로그램을 실행하면 `i`가 `5`와 같을 때 그 값을 출력하지 않습니다."

#: src/ch02-05-control-flow.md:244
msgid "Returning Values from Loops"
msgstr "루프에서 값을 반환하기"

#: src/ch02-05-control-flow.md:246
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether an operation has succeeded. You might also need to "
"pass the result of that operation out of the loop to the rest of your code. "
"To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr ""
"`loop`의 한 가지 용도는 작업이 실패할 수 있다는 것을 알고 있는 작업을 다시 시도하는 것입니다. 예를 들어 작업이 성공했는지 "
"확인하는 것입니다. 또한 해당 작업의 결과를 루프 외부로 전달해야 할 수도 있습니다. 이를 위해 루프를 중지하는 데 사용하는 "
"`break` 표현식 뒤에 반환하려는 값을 추가할 수 있습니다. 그 값은 루프 외부로 반환되어 사용할 수 있습니다."

#: src/ch02-05-control-flow.md:264
msgid "\"The result is {}\""
msgstr "결과는 {} 입니다."

#: src/ch02-05-control-flow.md:268
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we check whether the "
"`counter` is equal to `10`, and then add `1` to the `counter` variable. When"
" the condition is met, we use the `break` keyword with the value `counter * "
"2`. After the loop, we use a semicolon to end the statement that assigns the"
" value to `result`. Finally, we print the value in `result`, which in this "
"case is `20`."
msgstr ""
"루프 이전에 `counter`라는 변수를 선언하고 `0`으로 초기화합니다. 그런 다음 루프에서 반환된 값이 저장될 `result`라는 "
"변수를 선언합니다. 루프의 각 반복에서 `counter`가 `10`과 같은지 확인한 후 `counter` 변수에 `1`을 더합니다. "
"조건이 충족되면 `counter * 2` 값을 사용하여 `break` 키워드를 사용합니다. 루프 이후에는 `result`에 값을 할당하는"
" 문을 종결하는 세미콜론을 사용합니다. 마지막으로, 이 경우에는 `20`인 `result`의 값을 출력합니다."

#: src/ch02-05-control-flow.md:275
msgid "Conditional Loops with `while`"
msgstr "`while`를 사용한 조건부 루프"

#: src/ch02-05-control-flow.md:277
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`;"
" you could try that now in a program, if you’d like. However, this pattern "
"is so common that Cairo has a built-in language construct for it, called a "
"`while` loop."
msgstr ""
"프로그램은 종종 루프 내에서 조건을 평가해야 할 수 있습니다. 조건이 `true`인 동안 루프가 실행됩니다. 조건이 `true`가 아니게"
" 되면 프로그램은 `break`를 호출하여 루프를 중지합니다. `loop`, `if`, `else`, 그리고 `break`의 조합을 "
"사용하여 이와 같은 동작을 구현하는 것이 가능합니다. 지금 프로그램에서 시도해 볼 수 있습니다. 그러나 이 패턴은 너무 흔해서 "
"Cairo에는 `while` 루프라는 내장된 언어 구조가 있습니다."

#: src/ch02-05-control-flow.md:283
msgid ""
"In Listing 2-3, we use `while` to loop the program three times, counting "
"down each time after printing the value of `number`, and then, after the "
"loop, print a message and exit."
msgstr ""
"리스팅 2-3에서는 `while`을 사용하여 프로그램을 세 번 반복하며, 각 반복마다 `number`의 값을 출력한 후 카운트다운합니다."
" 그리고 루프 이후에 메시지를 출력하고 종료합니다."

#: src/ch02-05-control-flow.md:290
msgid "\"{number}!\""
msgstr "\"{number}!\""

#: src/ch02-05-control-flow.md:294
msgid "\"LIFTOFF!!!\""
msgstr "\"출발!!!\""

#: src/ch02-05-control-flow.md:297
msgid ""
"Listing 2-3: Using a `while` loop to run code while a condition holds `true`"
msgstr "리스트 2-3: 조건이 참인 동안 코드를 실행하는 `while` 루프 사용하기"

#: src/ch02-05-control-flow.md:299
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr ""
"이 구조는 `loop`, `if`, `else`, `break`를 사용했을 때 필요한 중첩을 많이 제거하며 더 명확합니다. 조건이 "
"`true`로 평가될 때 코드가 실행되고, 그렇지 않으면 루프를 종료합니다."

#: src/ch02-05-control-flow.md:304
msgid ""
"You made it! This was a sizable chapter: you learned about variables, data "
"types, functions, comments, `if` expressions and loops! To practice with the"
" concepts discussed in this chapter, try building programs to do the "
"following:"
msgstr ""
"당신이 성공했습니다! 이것은 상당한 챕터였습니다: 변수, 데이터 유형, 함수, 주석, `if` 표현식 및 루프에 대해 배웠습니다! 이 "
"챕터에서 논의된 개념을 연습하기 위해 다음을 수행하는 프로그램을 만들어 보세요:"

#: src/ch02-05-control-flow.md:308
msgid "Generate the _n_\\-th Fibonacci number."
msgstr "_n_ 번째 피보나치 수를 생성하세요."

#: src/ch02-05-control-flow.md:309
msgid "Compute the factorial of a number _n_."
msgstr "숫자 _n_ 의 팩토리얼을 계산하십시오."

#: src/ch02-05-control-flow.md:311
msgid ""
"Now, we’ll review the common collection types in Cairo in the next chapter."
msgstr "지금, 다음 장에서는 카이로의 일반적인 수집 유형을 검토할 것입니다."

#: src/ch03-00-common-collections.md:3
msgid ""
"Cairo provides a set of common collection types that can be used to store "
"and manipulate data. These collections are designed to be efficient, "
"flexible, and easy to use. This section introduces the primary collection "
"types available in Cairo: Arrays and Dictionaries."
msgstr ""
"카이로는 데이터를 저장하고 조작하는 데 사용할 수 있는 일반적인 컬렉션 유형을 제공합니다. 이러한 컬렉션은 효율적이고 유연하며 사용하기 "
"쉽도록 설계되었습니다. 이 섹션에서는 카이로에서 사용할 수 있는 주요 컬렉션 유형인 배열과 사전을 소개합니다."

#: src/ch03-01-arrays.md:3
msgid ""
"An array is a collection of elements of the same type. You can create and "
"use array methods by using the `ArrayTrait` trait from the core library."
msgstr ""
"배열은 동일한 유형의 요소들의 모음입니다. 핵심 라이브러리에서 `ArrayTrait` 특성을 사용하여 배열 메서드를 생성하고 사용할 수 "
"있습니다."

#: src/ch03-01-arrays.md:5
msgid ""
"An important thing to note is that arrays have limited modification options."
" Arrays are, in fact, queues whose values can't be modified. This has to do "
"with the fact that once a memory slot is written to, it cannot be "
"overwritten, but only read from it. You can only append items to the end of "
"an array and remove items from the front."
msgstr ""
"중요한 점은 배열이 수정 옵션이 제한적이라는 것입니다. 사실 배열은 값이 수정될 수 없는 큐입니다. 이는 한 번 메모리 슬롯에 쓰여지면 "
"덮어쓸 수 없고 읽기만 가능하다는 사실과 관련이 있습니다. 배열의 끝에만 항목을 추가하고 앞에서만 항목을 제거할 수 있습니다."

#: src/ch03-01-arrays.md:8
msgid "Creating an Array"
msgstr "배열 생성하기"

#: src/ch03-01-arrays.md:10
msgid ""
"Creating an array is done with the `ArrayTrait::new()` call. Here is an "
"example of the creation of an array to which we append 3 elements:"
msgstr ""
"배열을 생성하는 것은 `ArrayTrait::new()` 호출로 이루어집니다. 여기에는 3개의 요소를 추가하는 배열 생성 예제가 "
"있습니다:"

#: src/ch03-01-arrays.md:21
msgid ""
"When required, you can pass the expected type of items inside the array when"
" instantiating the array like this, or explicitly define the type of the "
"variable."
msgstr ""
"필요한 경우, 배열을 인스턴스화할 때 이와 같이 예상되는 항목 유형을 전달할 수 있거나 변수의 유형을 명시적으로 정의할 수 있습니다."

#: src/ch03-01-arrays.md:31
msgid "Updating an Array"
msgstr "배열 업데이트하기"

#: src/ch03-01-arrays.md:33
msgid "Adding Elements"
msgstr "요소 추가"

#: src/ch03-01-arrays.md:35
msgid ""
"To add an element to the end of an array, you can use the `append()` method:"
msgstr "배열 끝에 요소를 추가하려면 `append()` 메서드를 사용할 수 있습니다."

#: src/ch03-01-arrays.md:46
msgid "Removing Elements"
msgstr "요소 제거"

#: src/ch03-01-arrays.md:48
msgid ""
"You can only remove elements from the front of an array by using the "
"`pop_front()` method. This method returns an `Option` that can be unwrapped,"
" containing the removed element, or `Option::None` if the array is empty."
msgstr ""
"배열의 앞부분에서 요소를 제거하는 유일한 방법은 `pop_front()` 메서드를 사용하는 것입니다. 이 메서드는 제거된 요소를 "
"포함하거나 배열이 비어있는 경우 `Option::None`을 반환하는 언랩될 수 있는 `Option`을 반환합니다."

#: src/ch03-01-arrays.md:59
msgid "\"The first value is {}\""
msgstr "\"첫 번째 값은 {} 입니다\""

#: src/ch03-01-arrays.md:63
msgid ""
"The above code will print `The first value is 10` as we remove the first "
"element that was added."
msgstr "위의 코드는 '첫 번째 값은 10입니다'를 출력합니다. 왜냐하면 추가된 첫 번째 요소를 제거했기 때문입니다."

#: src/ch03-01-arrays.md:65
msgid ""
"In Cairo, memory is immutable, which means that it is not possible to modify"
" the elements of an array once they've been added. You can only add elements"
" to the end of an array and remove elements from the front of an array. "
"These operations do not require memory mutation, as they involve updating "
"pointers rather than directly modifying the memory cells."
msgstr ""
"카이로에서는 메모리가 불변이기 때문에 배열 요소를 한 번 추가하면 수정할 수 없습니다. 배열의 끝에만 요소를 추가하거나 배열의 앞에서 "
"요소를 제거할 수 있습니다. 이러한 작업은 메모리 변이를 필요로하지 않으며, 메모리 셀을 직접 수정하는 것이 아니라 포인터를 업데이트하는"
" 것이기 때문입니다."

#: src/ch03-01-arrays.md:67
msgid "Reading Elements from an Array"
msgstr "배열에서 요소 읽기"

#: src/ch03-01-arrays.md:69
msgid ""
"To access array elements, you can use `get()` or `at()` array methods that "
"return different types. Using `arr.at(index)` is equivalent to using the "
"subscripting operator `arr[index]`."
msgstr ""
"배열 요소에 액세스하려면 다른 유형을 반환하는 `get()` 또는 `at()` 배열 메서드를 사용할 수 있습니다. "
"`arr.at(index)`를 사용하는 것은 배열 첨자 연산자 `arr[index]`를 사용하는 것과 동일합니다."

#: src/ch03-01-arrays.md:71
msgid "`get()` method"
msgstr "`get()` 메서드"

#: src/ch03-01-arrays.md:73
msgid ""
"The `get` function returns an `Option<Box<@T>>`, which means it returns an "
"option to a Box type (Cairo's smart-pointer type) containing a snapshot to "
"the element at the specified index if that element exists in the array. If "
"the element doesn't exist, `get` returns `None`. This method is useful when "
"you expect to access indices that may not be within the array's bounds and "
"want to handle such cases gracefully without panics. Snapshots will be "
"explained in more detail in the [References and "
"Snapshots](ch04-02-references-and-snapshots.md) chapter."
msgstr ""
"`get` 함수는 `Option<Box<@T>>`를 반환하며, 이는 배열에서 지정된 인덱스의 요소에 대한 스냅샷을 포함하는 상자 "
"유형(Cairo의 스마트 포인터 유형)에 대한 옵션을 반환한다는 것을 의미합니다. 요소가 배열에 존재하는 경우 해당 요소의 스냅샷을 "
"반환합니다. 요소가 존재하지 않는 경우 `get`은 `None`을 반환합니다. 이 메서드는 배열의 범위를 벗어날 수 있는 인덱스에 "
"액세스할 것으로 예상되며, 패닉 없이 이러한 경우를 우아하게 처리하고 싶을 때 유용합니다. 스냅샷은 [참조 및 "
"스냅샷](ch04-02-references-and-snapshots.md) 장에서 자세히 설명될 것입니다."

#: src/ch03-01-arrays.md:75
msgid "Here is an example with the `get()` method:"
msgstr "다음은 `get()` 메서드를 사용한 예제입니다."

#: src/ch03-01-arrays.md:82
msgid ""
"// Change this value to see different results, what would happen if the "
"index doesn't exist?\n"
msgstr "이 값을 변경하여 다른 결과를 확인할 수 있습니다. 인덱스가 존재하지 않는 경우에는 어떻게 될까요?"

#: src/ch03-01-arrays.md:86
msgid ""
"// Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator\n"
"        // It basically means \"transform what get(idx) returned into a real value\"\n"
msgstr ""
"// 지금은 *에 대해 걱정하지 마세요. 궁금하다면 4.2 장의 #desnap 연산자를 참조하세요.\n"
"// 이는 기본적으로 \"get(idx)가 반환한 것을 실제 값으로 변환\"하는 것을 의미합니다."

#: src/ch03-01-arrays.md:89
msgid "\"out of bounds\""
msgstr "\"out of bounds\" in Korean is \"경계를 넘어서다\" or \"경계 밖\"."

#: src/ch03-01-arrays.md:94
msgid "`at()` method"
msgstr "`at()` 메소드"

#: src/ch03-01-arrays.md:96
msgid ""
"The `at` function, on the other hand, directly returns a snapshot to the "
"element at the specified index using the `unbox()` operator to extract the "
"value stored in a box. If the index is out of bounds, a panic error occurs. "
"You should only use `at` when you want the program to panic if the provided "
"index is out of the array's bounds, which can prevent unexpected behavior."
msgstr ""
"`at` 함수는 반면에 `unbox()` 연산자를 사용하여 상자에 저장된 값을 추출하는 방식으로 지정된 인덱스의 요소에 대한 스냅샷을 "
"직접 반환합니다. 인덱스가 범위를 벗어나면 패닉 오류가 발생합니다. 배열의 범위를 벗어난 인덱스가 제공되면 프로그램이 패닉하도록 하려면 "
"`at`만 사용해야 합니다. 이렇게 하면 예기치 않은 동작을 방지할 수 있습니다."

#: src/ch03-01-arrays.md:98
msgid "Here is an example with the `at()` method:"
msgstr "여기 `at()` 메소드를 사용한 예제가 있습니다."

#: src/ch03-01-arrays.md:111
msgid ""
"In this example, the variable named `first` will get the value `0` because "
"that is the value at index `0` in the array. The variable named `second` "
"will get the value `1` from index `1` in the array."
msgstr ""
"이 예시에서 변수 `first`는 배열에서 인덱스 `0`에 있는 값인 `0`을 받게 됩니다. 변수 `second`는 배열에서 인덱스 "
"`1`에 있는 값인 `1`을 받게 됩니다."

#: src/ch03-01-arrays.md:115
msgid ""
"If you want to use the subscripting operator `arr[index]`, you will need to "
"explicitly define the type of the elements of the array, otherwise it will "
"not compile. For example:"
msgstr ""
"만약 당신이 인덱싱 연산자 `arr[index]`를 사용하고 싶다면, 배열의 요소의 타입을 명시적으로 정의해야 합니다. 그렇지 않으면 "
"컴파일되지 않습니다. 예를 들어:"

#: src/ch03-01-arrays.md:128
msgid ""
"In summary, use `at` when you want to panic on out-of-bounds access "
"attempts, and use `get` when you prefer to handle such cases gracefully "
"without panicking."
msgstr ""
"요약하면, `at`은 경계를 벗어난 액세스 시도에 대해 패닉하고 싶을 때 사용하고, `get`은 그러한 경우를 패닉 없이 정중하게 "
"처리하고 싶을 때 사용합니다."

#: src/ch03-01-arrays.md:130
msgid "Size related methods"
msgstr "크기 관련 메서드"

#: src/ch03-01-arrays.md:132
msgid ""
"To determine the number of elements in an array, use the `len()` method. The"
" return value is of type `usize`."
msgstr "배열의 요소 수를 결정하려면 `len()` 메서드를 사용하십시오. 반환 값은 `usize` 유형입니다."

#: src/ch03-01-arrays.md:134
msgid ""
"If you want to check if an array is empty or not, you can use the "
"`is_empty()` method, which returns `true` if the array is empty and `false` "
"otherwise."
msgstr ""
"배열이 비어 있는지 여부를 확인하려면 `is_empty()` 메서드를 사용할 수 있습니다. 이 메서드는 배열이 비어 있으면 `true`를"
" 반환하고 그렇지 않으면 `false`를 반환합니다."

#: src/ch03-01-arrays.md:136 src/ch11-02-macros.md:27
msgid "`array!` macro"
msgstr "`array!` 매크로"

#: src/ch03-01-arrays.md:138
msgid ""
"Sometimes, we need to create arrays with values that are already known at "
"compile time. The basic way of doing that is redundant. You would first "
"declare the array and then append each value one by one. `array!` is a "
"simpler way of doing this task by combining the two steps. At compile-time, "
"the compiler will expand the macro to generate the code that appends the "
"items sequentially."
msgstr ""
"가끔은 컴파일 시 이미 알려진 값으로 배열을 생성해야 할 때가 있습니다. 이를 하는 기본적인 방법은 중복됩니다. 먼저 배열을 선언한 다음"
" 각 값을 하나씩 추가해야 합니다. `array!`는 두 단계를 결합하여 이 작업을 더 간단하게 수행하는 방법입니다. 컴파일 시에 "
"컴파일러는 매크로를 확장하여 항목을 순차적으로 추가하는 코드를 생성합니다."

#: src/ch03-01-arrays.md:141
msgid "Without `array!`:"
msgstr "`array!` 없이:"

#: src/ch03-01-arrays.md:152
msgid "With `array!`:"
msgstr "`array!`와 함께:"

#: src/ch03-01-arrays.md:158
msgid "Storing multiple types with Enums"
msgstr "열거형을 사용하여 여러 유형을 저장하기"

#: src/ch03-01-arrays.md:160
msgid ""
"If you want to store elements of different types in an array, you can use an"
" `Enum` to define a custom data type that can hold multiple types. Enums "
"will be explained in more detail in the [Enums and Pattern "
"Matching](ch06-00-enums-and-pattern-matching.md) chapter."
msgstr ""
"다른 유형의 요소를 배열에 저장하려면 여러 유형을 보유할 수 있는 사용자 정의 데이터 유형을 정의하는 `Enum`을 사용할 수 있습니다."
" `Enum`은 [Enums and Pattern Matching](ch06-00-enums-and-pattern-matching.md)"
" 장에서 자세히 설명됩니다."

#: src/ch03-01-arrays.md:178
msgid "Span"
msgstr "범위"

#: src/ch03-01-arrays.md:180
msgid ""
"`Span` is a struct that represents a snapshot of an `Array`. It is designed "
"to provide safe and controlled access to the elements of an array without "
"modifying the original array. Span is particularly useful for ensuring data "
"integrity and avoiding borrowing issues when passing arrays between "
"functions or when performing read-only operations (cf. [References and "
"Snapshots](ch04-02-references-and-snapshots.md))"
msgstr ""
"`Span`은 `Array`의 스냅샷을 나타내는 구조체입니다. 이는 원본 배열을 수정하지 않고 배열 요소에 안전하고 제어된 액세스를 "
"제공하기 위해 설계되었습니다. Span은 특히 함수 간에 배열을 전달하거나 읽기 전용 작업을 수행할 때 데이터 무결성을 보장하고 빌림 "
"문제를 피하기 위해 유용합니다. (참조: [참조 및 스냅샷](ch04-02-references-and-snapshots.md))"

#: src/ch03-01-arrays.md:182
msgid ""
"All methods provided by `Array` can also be used with `Span`, with the "
"exception of the `append()` method."
msgstr "`Array`에서 제공하는 모든 메서드는 `Span`과 함께 사용할 수 있지만 `append()` 메서드는 예외입니다."

#: src/ch03-01-arrays.md:184
msgid "Turning an Array into span"
msgstr "배열을 span으로 변환하기"

#: src/ch03-01-arrays.md:186
msgid "To create a `Span` of an `Array`, call the `span()` method:"
msgstr "`Array`의 `Span`을 만들려면 `span()` 메서드를 호출하십시오."

#: src/ch03-02-dictionaries.md:3
msgid ""
"Cairo provides in its core library a dictionary-like type. The "
"`Felt252Dict<T>` data type represents a collection of key-value pairs where "
"each key is unique and associated with a corresponding value. This type of "
"data structure is known differently across different programming languages "
"such as maps, hash tables, associative arrays and many others."
msgstr ""
"카이로는 핵심 라이브러리에서 사전과 유사한 유형을 제공합니다. `Felt252Dict<T>` 데이터 유형은 각 키가 고유하고 해당 값과 "
"연관된 키-값 쌍의 컬렉션을 나타냅니다. 이 유형의 데이터 구조는 맵, 해시 테이블, 연관 배열 등과 같이 다양한 프로그래밍 언어에서 "
"다르게 알려져 있습니다."

#: src/ch03-02-dictionaries.md:5
msgid ""
"The `Felt252Dict<T>` type is useful when you want to organize your data in a"
" certain way for which using an `Array<T>` and indexing doesn't suffice. "
"Cairo dictionaries also allow the programmer to easily simulate the "
"existence of mutable memory when there is none."
msgstr ""
"`Felt252Dict<T>` 유형은 `Array<T>` 및 인덱싱만으로는 충분하지 않은 특정 방식으로 데이터를 구성하고 싶을 때 "
"유용합니다. 카이로 사전은 프로그래머가 변경 가능한 메모리의 존재를 쉽게 시뮬레이션할 수 있도록 합니다."

#: src/ch03-02-dictionaries.md:7
msgid "Basic Use of Dictionaries"
msgstr "사전의 기본 사용"

#: src/ch03-02-dictionaries.md:9
msgid ""
"It is normal in other languages when creating a new dictionary to define the"
" data types of both key and value. In Cairo, the key type is restricted to "
"`felt252`, leaving only the possibility to specify the value data type, "
"represented by `T` in `Felt252Dict<T>`."
msgstr ""
"다른 언어에서 새로운 사전을 만들 때 키와 값의 데이터 유형을 정의하는 것은 일반적입니다. 카이로에서는 키 유형이 `felt252`로 "
"제한되어 있어 값 데이터 유형을 지정하는 것만 가능하며, 이는 `Felt252Dict<T>`에서 `T`로 표시됩니다."

#: src/ch03-02-dictionaries.md:11
msgid ""
"The core functionality of a `Felt252Dict<T>` is implemented in the trait "
"`Felt252DictTrait` which includes all basic operations. Among them we can "
"find:"
msgstr ""
"`Felt252Dict<T>`의 핵심 기능은 모든 기본 작업을 포함하는 `Felt252DictTrait` 트레이트에 구현되어 있습니다. "
"그 중에는 다음과 같은 것들이 있습니다:"

#: src/ch03-02-dictionaries.md:13
msgid ""
"`insert(felt252, T) -> ()` to write values to a dictionary instance and"
msgstr "`insert(felt252, T) -> ()`을 사용하여 사전 인스턴스에 값을 작성합니다."

#: src/ch03-02-dictionaries.md:14
msgid "`get(felt252) -> T` to read values from it."
msgstr "`get(felt252) -> T` 값을 읽어오려면 사용하세요."

#: src/ch03-02-dictionaries.md:16
msgid ""
"These functions allow us to manipulate dictionaries like in any other "
"language. In the following example, we create a dictionary to represent a "
"mapping between individuals and their balance:"
msgstr ""
"이러한 함수들을 사용하면 다른 어떤 언어에서와 마찬가지로 사전을 조작할 수 있습니다. 다음 예제에서는 개인과 그들의 잔액 간의 매핑을 "
"나타내는 사전을 만듭니다."

#: src/ch03-02-dictionaries.md:26
msgid "\"Balance is not 100\""
msgstr "\"균형은 100이 아닙니다.\""

#: src/ch03-02-dictionaries.md:29
msgid "\"Balance is not 200\""
msgstr "\"밸런스는 200이 아닙니다.\""

#: src/ch03-02-dictionaries.md:33
msgid ""
"We can create a new instance of `Felt252Dict<u64>` by using the `default` "
"method of the `Default` trait and add two individuals, each one with their "
"own balance, using the `insert` method. Finally, we check the balance of our"
" users with the `get` method. These methods are defined in the "
"`Felt252DictTrait` trait in the core library."
msgstr ""
"`Default` 트레이트의 `default` 메서드를 사용하여 `Felt252Dict<u64>`의 새 인스턴스를 생성하고, "
"`insert` 메서드를 사용하여 각각 자신의 잔액을 가진 두 명의 개인을 추가할 수 있습니다. 마지막으로, `get` 메서드를 사용하여"
" 사용자의 잔액을 확인할 수 있습니다. 이러한 메서드들은 코어 라이브러리의 `Felt252DictTrait` 트레이트에 정의되어 "
"있습니다."

#: src/ch03-02-dictionaries.md:35
msgid ""
"Throughout the book we have talked about how Cairo's memory is immutable, "
"meaning you can only write to a memory cell once but the `Felt252Dict<T>` "
"type represents a way to overcome this obstacle. We will explain how this is"
" implemented later on in [Dictionaries Underneath](#dictionaries-"
"underneath)."
msgstr ""
"이 책 전체를 통해 우리는 카이로의 메모리가 불변이라는 것에 대해 이야기했습니다. 즉, 메모리 셀에 한 번만 쓸 수 있지만 "
"`Felt252Dict<T>` 유형은 이 장애물을 극복하는 방법을 나타냅니다. 나중에 [Dictionaries "
"Underneath](#dictionaries-underneath)에서 이것이 어떻게 구현되는지 설명하겠습니다."

#: src/ch03-02-dictionaries.md:37
msgid ""
"Building upon our previous example, let us show a code example where the "
"balance of the same user changes:"
msgstr "이전 예제를 바탕으로, 동일한 사용자의 잔액이 변경되는 코드 예제를 보여드리겠습니다."

#: src/ch03-02-dictionaries.md:43
msgid "// Insert Alex with 100 balance\n"
msgstr "// Alex를 100 잔고로 삽입합니다."

#: src/ch03-02-dictionaries.md:45
msgid "// Check that Alex has indeed 100 associated with him\n"
msgstr "// 알렉스가 실제로 100이 연결되어 있는지 확인하세요."

#: src/ch03-02-dictionaries.md:47
msgid "\"Alex balance is not 100\""
msgstr "\"알렉스의 잔고는 100이 아닙니다.\""

#: src/ch03-02-dictionaries.md:49
msgid "// Insert Alex again, this time with 200 balance\n"
msgstr "// Alex를 다시 삽입하고, 이번에는 잔액이 200입니다."

#: src/ch03-02-dictionaries.md:51
msgid "// Check the new balance is correct\n"
msgstr "// 새 잔고가 올바른지 확인하세요."

#: src/ch03-02-dictionaries.md:53
msgid "\"Alex balance is not 200\""
msgstr "\"알렉스의 잔고는 200이 아닙니다.\""

#: src/ch03-02-dictionaries.md:57
msgid ""
"Notice how in this example we added the 'Alex' individual twice, each time "
"using a different balance and each time that we checked for its balance it "
"had the last value inserted! `Felt252Dict<T>` effectively allows us to "
"\"rewrite\" the stored value for any given key."
msgstr ""
"이 예시에서 'Alex' 개인을 두 번 추가했음에 유의하십시오. 각각 다른 잔고를 사용하고 각각 잔고를 확인할 때마다 마지막 값이 "
"삽입되었습니다! `Felt252Dict<T>`는 우리에게 주어진 키에 대한 저장된 값을 \"재작성\"할 수 있게 해줍니다."

#: src/ch03-02-dictionaries.md:59
msgid ""
"Before heading on and explaining how dictionaries are implemented it is "
"worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the "
"scenes all keys have their associated values initialized as zero. This means"
" that if for example, you tried to get the balance of an inexistent user you"
" will get 0 instead of an error or an undefined value. This also means there"
" is no way to delete data from a dictionary. Something to take into account "
"when incorporating this structure into your code."
msgstr ""
"사전이 어떻게 구현되는지 설명하기 전에, `Felt252Dict<T>`를 인스턴스화하면 모든 키에 연결된 값이 0으로 초기화된다는 것을 "
"언급할 가치가 있다. 예를 들어, 존재하지 않는 사용자의 잔액을 가져오려고 하면 오류나 정의되지 않은 값 대신 0을 얻게 된다는 것을 "
"의미한다. 또한, 이는 사전에서 데이터를 삭제할 수 있는 방법이 없다는 것을 의미한다. 이 구조를 코드에 통합할 때 고려해야 할 "
"사항이다."

#: src/ch03-02-dictionaries.md:61
msgid ""
"Until this point, we have seen all the basic features of `Felt252Dict<T>` "
"and how it mimics the same behavior as the corresponding data structures in "
"any other language, that is, externally of course. Cairo is at its core a "
"non-deterministic Turing-complete programming language, very different from "
"any other popular language in existence, which as a consequence means that "
"dictionaries are implemented very differently as well!"
msgstr ""
"이 시점까지, 우리는 `Felt252Dict<T>`의 모든 기본 기능과 해당 데이터 구조와 동일한 동작을 모방하는 방법을 보았습니다. "
"다른 어떤 언어에서도, 외부적으로는 물론입니다. 카이로는 본질적으로 결정론적이지 않은 튜링 완전 프로그래밍 언어로, 존재하는 다른 "
"인기있는 언어와 매우 다르며, 그 결과로 사전도 매우 다르게 구현됩니다!"

#: src/ch03-02-dictionaries.md:63
msgid ""
"In the following sections, we are going to give some insights about "
"`Felt252Dict<T>` inner mechanisms and the compromises that were taken to "
"make them work. After that, we are going to take a look at how to use "
"dictionaries with other data structures as well as use the `entry` method as"
" another way to interact with them."
msgstr ""
"다음 섹션에서는 `Felt252Dict<T>` 내부 메커니즘에 대한 통찰력과 그들이 작동하도록하기 위해 취해진 타협에 대해 "
"알아보겠습니다. 그 후에는 다른 데이터 구조와 함께 사전을 사용하는 방법과 `entry` 메서드를 사용하여 상호 작용하는 또 다른 방법을"
" 살펴볼 것입니다."

#: src/ch03-02-dictionaries.md:65
msgid "Dictionaries Underneath"
msgstr "사전 아래"

#: src/ch03-02-dictionaries.md:67
msgid ""
"One of the constraints of Cairo's non-deterministic design is that its "
"memory system is immutable, so in order to simulate mutability, the language"
" implements `Felt252Dict<T>` as a list of entries. Each of the entries "
"represents a time when a dictionary was accessed for "
"reading/updating/writing purposes. An entry has three fields:"
msgstr ""
"카이로의 비결정적 디자인의 제약 중 하나는 그 메모리 시스템이 변경할 수 없다는 것입니다. 그래서 가변성을 시뮬레이션하기 위해 언어는 "
"`Felt252Dict<T>`를 항목 목록으로 구현합니다. 각 항목은 사전이 읽기/업데이트/쓰기 목적으로 액세스된 시간을 나타냅니다. "
"항목은 세 개의 필드를 가지고 있습니다."

#: src/ch03-02-dictionaries.md:69
msgid ""
"A `key` field that identifies the key for this key-value pair of the "
"dictionary."
msgstr "이것은 딕셔너리의 키-값 쌍의 키를 식별하는 `key` 필드입니다."

#: src/ch03-02-dictionaries.md:70
msgid ""
"A `previous_value` field that indicates which previous value was held at "
"`key`."
msgstr "`key`에서 이전 값이 저장되어 있던 `previous_value` 필드입니다."

#: src/ch03-02-dictionaries.md:71
msgid ""
"A `new_value` field that indicates the new value that is held at `key`."
msgstr "`key`에 보유된 새 값을 나타내는 `new_value` 필드입니다."

#: src/ch03-02-dictionaries.md:73
msgid ""
"If we try implementing `Felt252Dict<T>` using high-level structures we would"
" internally define it as `Array<Entry<T>>` where each `Entry<T>` has "
"information about what key-value pair it represents and the previous and new"
" values it holds. The definition of `Entry<T>` would be:"
msgstr ""
"만약 우리가 고수준 구조를 사용하여 `Felt252Dict<T>`를 구현하려고 한다면 내부적으로는 각 `Entry<T>`가 어떤 키-값 "
"쌍을 나타내는지와 이전 값 및 새 값에 대한 정보를 가지고 있는 `Array<Entry<T>>`로 정의될 것입니다. `Entry<T>`의"
" 정의는 다음과 같을 것입니다:"

#: src/ch03-02-dictionaries.md:83
msgid ""
"For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be "
"registered:"
msgstr "각각의 `Felt252Dict<T>`와 상호 작용할 때마다 새로운 `Entry<T>`가 등록됩니다."

#: src/ch03-02-dictionaries.md:85
msgid ""
"A `get` would register an entry where there is no change in state, and "
"previous and new values are stored with the same value."
msgstr "`get`는 상태 변화가 없는 경우에 항목을 등록하며, 이전 값과 새 값이 동일한 값으로 저장됩니다."

#: src/ch03-02-dictionaries.md:86
msgid ""
"An `insert` would register a new `Entry<T>` where the `new_value` would be "
"the element being inserted, and the `previous_value` the last element "
"inserted before this. In case it is the first entry for a certain key, then "
"the previous value will be zero."
msgstr ""
"`insert`는 `new_value`가 삽입되는 요소가 되고, `previous_value`는 이전에 삽입된 마지막 요소가 될 새로운 "
"`Entry<T>`를 등록합니다. 특정 키에 대한 첫 번째 항목인 경우, 이전 값은 0이 됩니다."

#: src/ch03-02-dictionaries.md:88
msgid ""
"The use of this entry list shows how there isn't any rewriting, just the "
"creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an"
" example of this using the `balances` dictionary from the previous section "
"and inserting the users 'Alex' and 'Maria':"
msgstr ""
"이 항목 목록의 사용은 다시 쓰기가 없고 `Felt252Dict<T>` 상호 작용당 새로운 메모리 셀이 생성되는 방식을 보여줍니다. 이전"
" 섹션의 `balances` 사전을 사용하여 'Alex'와 'Maria' 사용자를 삽입하는 예시를 보여드립시다:"

#: src/ch03-02-dictionaries.md:106
msgid "These instructions would then produce the following list of entries:"
msgstr "이 지침에 따라 다음과 같은 항목 목록이 생성됩니다:"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "key"
msgstr "열쇠"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "previous"
msgstr "이전"

#: src/ch03-02-dictionaries.md:108 src/ch03-02-dictionaries.md:130
#: src/ch03-02-dictionaries.md:143
msgid "new"
msgstr "새로운"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
#: src/ch03-02-dictionaries.md:145
msgid "Alex"
msgstr "알렉스"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:111
#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:133
#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:145
#: src/ch03-02-dictionaries.md:146 src/ch03-02-dictionaries.md:147
msgid "0"
msgstr "0"

#: src/ch03-02-dictionaries.md:110 src/ch03-02-dictionaries.md:112
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
msgid "100"
msgstr "백"

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
#: src/ch03-02-dictionaries.md:133 src/ch03-02-dictionaries.md:135
#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "Maria"
msgstr "마리아"

#: src/ch03-02-dictionaries.md:111 src/ch03-02-dictionaries.md:113
msgid "50"
msgstr "50 -> 50"

#: src/ch03-02-dictionaries.md:112
msgid "200"
msgstr ""
"200\n"
"\n"
"이백"

#: src/ch03-02-dictionaries.md:115
msgid ""
"Notice that since 'Alex' was inserted twice, it appears twice and the "
"`previous` and `current` values are set properly. Also reading from 'Maria' "
"registered an entry with no change from previous to current values."
msgstr ""
"'Alex'가 두 번 삽입되었기 때문에 두 번 나타나며 `이전` 및 `현재` 값이 올바르게 설정되었음을 주목하세요. 또한 "
"'Maria'에서 읽은 것은 이전 값에서 현재 값으로 변경이 없는 항목을 등록했습니다."

#: src/ch03-02-dictionaries.md:117
msgid ""
"This approach to implementing `Felt252Dict<T>` means that for each "
"read/write operation, there is a scan for the whole entry list in search of "
"the last entry with the same `key`. Once the entry has been found, its "
"`new_value` is extracted and used on the new entry to be added as the "
"`previous_value`. This means that interacting with `Felt252Dict<T>` has a "
"worst-case time complexity of `O(n)` where `n` is the number of entries in "
"the list."
msgstr ""
"`Felt252Dict<T>`를 구현하는 이 방법은 각 읽기/쓰기 작업마다, 동일한 `key`를 가진 마지막 항목을 찾기 위해 전체 항목"
" 목록을 스캔합니다. 항목을 찾으면, `new_value`가 추출되어 새 항목의 `previous_value`로 사용됩니다. 이는 "
"`Felt252Dict<T>`와 상호 작용하는 데 최악의 경우 시간 복잡도가 `O(n)`인 것을 의미합니다. 여기서 `n`은 목록의 항목"
" 수입니다."

#: src/ch03-02-dictionaries.md:119
msgid ""
"If you pour some thought into alternate ways of implementing "
"`Felt252Dict<T>` you'd surely find them, probably even ditching completely "
"the need for a `previous_value` field, nonetheless, since Cairo is not your "
"normal language this won't work. One of the purposes of Cairo is, with the "
"STARK proof system, to generate proofs of computational integrity. This "
"means that you need to verify that program execution is correct and inside "
"the boundaries of Cairo restrictions. One of those boundary checks consists "
"of \"dictionary squashing\" and that requires information on both previous "
"and new values for every entry."
msgstr ""
"`Felt252Dict<T>`를 구현하는 대안적인 방법에 대해 고민해 보면, 아마도 `previous_value` 필드가 필요 없어져서 "
"완전히 버려질 수도 있을 것입니다. 그러나 카이로는 일반적인 언어가 아니기 때문에 이 방법은 작동하지 않을 것입니다. 카이로의 목적 중 "
"하나는 STARK 증명 시스템을 사용하여 계산 무결성의 증명을 생성하는 것입니다. 이는 프로그램 실행이 올바르고 카이로 제한 내에서 "
"수행되었음을 확인해야 한다는 것을 의미합니다. 이러한 경계 검사 중 하나는 \"사전 압축\"이며, 이를 위해서는 각 항목의 이전 값과 새"
" 값에 대한 정보가 필요합니다."

#: src/ch03-02-dictionaries.md:122
msgid "Squashing Dictionaries"
msgstr "사전 압축하기"

#: src/ch03-02-dictionaries.md:124
msgid ""
"To verify that the proof generated by a Cairo program execution that used a "
"`Felt252Dict<T>` is correct, we need to check that there wasn't any illegal "
"tampering with the dictionary. This is done through a method called "
"`squash_dict` that reviews each entry of the entry list and checks that "
"access to the dictionary remains coherent throughout the execution."
msgstr ""
"Cairo 프로그램 실행 중 `Felt252Dict<T>`를 사용한 증명이 올바른지 확인하려면, 사전에 부정한 개입이 없었는지 확인해야 "
"합니다. 이는 `squash_dict`라는 메서드를 통해 수행되며, 각 항목을 검토하고 실행 중에 사전에 대한 접근이 일관되게 유지되는지"
" 확인합니다."

#: src/ch03-02-dictionaries.md:126
msgid ""
"The process of squashing is as follows: given all entries with certain key "
"`k`, taken in the same order as they were inserted, verify that the ith "
"entry `new_value` is equal to the ith + 1 entry `previous_value`."
msgstr ""
"압축 과정은 다음과 같습니다: 특정 키 `k`를 가진 모든 항목을 삽입된 순서대로 가져와서, i번째 항목 `new_value`가 "
"i+1번째 항목 `previous_value`와 동일한지 확인합니다."

#: src/ch03-02-dictionaries.md:128
msgid "For example, given the following entry list:"
msgstr "예를 들어, 다음과 같은 항목 목록이 주어졌을 때:"

#: src/ch03-02-dictionaries.md:132 src/ch03-02-dictionaries.md:136
msgid "150"
msgstr ""
"150\n"
"\n"
"150"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "Charles"
msgstr "찰스"

#: src/ch03-02-dictionaries.md:134 src/ch03-02-dictionaries.md:147
msgid "70"
msgstr "70 -> 70"

#: src/ch03-02-dictionaries.md:135 src/ch03-02-dictionaries.md:138
msgid "250"
msgstr "250 -> 이백 오십"

#: src/ch03-02-dictionaries.md:136 src/ch03-02-dictionaries.md:137
msgid "40"
msgstr "40 --> 사십"

#: src/ch03-02-dictionaries.md:137 src/ch03-02-dictionaries.md:139
msgid "300"
msgstr ""
"300\n"
"\n"
"300"

#: src/ch03-02-dictionaries.md:138 src/ch03-02-dictionaries.md:146
msgid "190"
msgstr "190"

#: src/ch03-02-dictionaries.md:139 src/ch03-02-dictionaries.md:145
msgid "90"
msgstr "90 --> 90"

#: src/ch03-02-dictionaries.md:141
msgid "After squashing, the entry list would be reduced to:"
msgstr "스쿼싱 후, 참가 목록은 다음과 같이 줄어들 것입니다:"

#: src/ch03-02-dictionaries.md:149
msgid ""
"In case of a change on any of the values of the first table, squashing would"
" have failed during runtime."
msgstr "첫 번째 테이블의 값 중 하나가 변경된 경우, 실행 중에 스쿼싱이 실패했을 것입니다."

#: src/ch03-02-dictionaries.md:151
msgid "Dictionary Destruction"
msgstr "사전 파괴"

#: src/ch03-02-dictionaries.md:153
msgid ""
"If you run the examples from [Basic Use of Dictionaries](#basic-use-of-"
"dictionaries), you'd notice that there was never a call to squash "
"dictionary, but the program compiled successfully nonetheless. What happened"
" behind the scene was that squash was called automatically via the "
"`Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call "
"occurred just before the `balance` dictionary went out of scope."
msgstr ""
"만약 [사전의 기본 사용](#basic-use-of-dictionaries) 예제를 실행한다면, squash 사전을 호출한 적이 없음에도"
" 불구하고 프로그램은 성공적으로 컴파일되었음을 알 수 있습니다. 실제로는 `Destruct<T>` 트레이트의 "
"`Felt252Dict<T>` 구현을 통해 squash가 자동으로 호출되었습니다. 이 호출은 `balance` 사전이 스코프를 벗어나기 "
"직전에 발생했습니다."

#: src/ch03-02-dictionaries.md:155
msgid ""
"The `Destruct<T>` trait represents another way of removing instances out of "
"scope apart from `Drop<T>`. The main difference between these two is that "
"`Drop<T>` is treated as a no-op operation, meaning it does not generate new "
"CASM while `Destruct<T>` does not have this restriction. The only type which"
" actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other "
"type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these"
" traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-"
"destruct)."
msgstr ""
"`Destruct<T>` 트레이트는 `Drop<T>` 외에도 인스턴스를 범위에서 제거하는 또 다른 방법을 나타냅니다. 이 두 가지의 주요"
" 차이점은 `Drop<T>`가 no-op 작업으로 처리된다는 것이며, 이는 새로운 CASM을 생성하지 않는다는 의미이며, "
"`Destruct<T>`는 이러한 제한이 없다는 것입니다. `Destruct<T>` 트레이트를 활성적으로 사용하는 유일한 유형은 "
"`Felt252Dict<T>`이며, 다른 모든 유형에 대해 `Destruct<T>`와 `Drop<T>`는 동의어입니다. 이러한 트레이트에"
" 대해 더 읽을 수 있습니다. [Drop and Destruct](/appendix-03-derivable-traits.md#drop-"
"and-destruct)."

#: src/ch03-02-dictionaries.md:157
msgid ""
"Later in [Dictionaries as Struct Members](#dictionaries-as-struct-members), "
"we will have a hands-on example where we implement the `Destruct<T>` trait "
"for a custom type."
msgstr ""
"나중에 [Dictionaries as Struct Members](#dictionaries-as-struct-members)에서는 사용자"
" 정의 타입에 대해 `Destruct<T>` 트레이트를 구현하는 실습 예제가 있을 것입니다."

#: src/ch03-02-dictionaries.md:159
msgid "More Dictionaries"
msgstr "더 많은 사전"

#: src/ch03-02-dictionaries.md:161
msgid ""
"Up to this point, we have given a comprehensive overview of the "
"functionality of `Felt252Dict<T>` as well as how and why it is implemented "
"in a certain way. If you haven't understood all of it, don't worry because "
"in this section we will have some more examples using dictionaries."
msgstr ""
"지금까지 `Felt252Dict<T>`의 기능에 대한 포괄적인 개요와 특정 방식으로 구현된 이유에 대해 설명해 왔습니다. 모두 이해하지 "
"못했다면 걱정하지 마세요. 이 섹션에서는 사전을 사용한 몇 가지 더 많은 예제를 살펴볼 것입니다."

#: src/ch03-02-dictionaries.md:163
msgid ""
"We will start by explaining the `entry` method which is part of a dictionary"
" basic functionality included in `Felt252DictTrait<T>` which we didn't "
"mention at the beginning. Soon after, we will see examples of how "
"`Felt252Dict<T>` [interacts](#dictionaries-of-types-not-supported-natively) "
"with other complex types such as `Array<T>` and how to "
"[implement](#dictionaries-as-struct-members) a struct with a dictionary as a"
" member."
msgstr ""
"우리는 먼저 `Felt252DictTrait<T>`에 포함된 사전 기본 기능 중 하나인 `entry` 메소드를 설명하여 시작할 것입니다."
" 이는 우리가 처음에 언급하지 않았던 것입니다. 곧 그 다음에는 `Felt252Dict<T>`가 다른 복잡한 유형들과 상호 작용하는 "
"예제들과 `Array<T>`와 같은 유형들과 어떻게 구현하는지에 대한 예제를 볼 것입니다. 또한 사전을 멤버로 가지는 구조체를 "
"[구현](#dictionaries-as-struct-members)하는 방법도 살펴볼 것입니다."

#: src/ch03-02-dictionaries.md:165
msgid "Entry and Finalize"
msgstr "등록 및 완료"

#: src/ch03-02-dictionaries.md:167
msgid ""
"In the [Dictionaries Underneath](#dictionaries-underneath) section, we "
"explained how `Felt252Dict<T>` internally worked. It was a list of entries "
"for each time the dictionary was accessed in any manner. It would first find"
" the last entry given a certain `key` and then update it accordingly to "
"whatever operation it was executing. The Cairo language gives us the tools "
"to replicate this ourselves through the `entry` and `finalize` methods."
msgstr ""
"[Dictionaries Underneath](#dictionaries-underneath) 섹션에서는 `Felt252Dict<T>`가 "
"내부적으로 어떻게 작동하는지 설명했습니다. 이는 사전이 어떠한 방식으로든 액세스될 때마다 항목 목록이었습니다. 특정 `key`가 주어졌을"
" 때 먼저 마지막 항목을 찾은 다음 해당 작업이 실행되는 대로 업데이트했습니다. Cairo 언어는 `entry` 및 `finalize` "
"메서드를 통해 우리에게 이를 직접 복제할 수 있는 도구를 제공합니다."

#: src/ch03-02-dictionaries.md:169
msgid ""
"The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose "
"of creating a new entry given a certain key. Once called, this method takes "
"ownership of the dictionary and returns the entry to update. The method "
"signature is as follows:"
msgstr ""
"`entry` 메서드는 `Felt252DictTrait<T>`의 일부로 제공되며 특정 키를 제공하여 새 항목을 만드는 목적으로 "
"제공됩니다. 한 번 호출되면 이 메서드는 사전의 소유권을 가져가고 업데이트할 항목을 반환합니다. 메서드 서명은 다음과 같습니다:"

#: src/ch03-02-dictionaries.md:175
msgid ""
"The first input parameter takes ownership of the dictionary while the second"
" one is used to create the appropriate entry. It returns a tuple containing "
"a `Felt252DictEntry<T>`, which is the type used by Cairo to represent "
"dictionary entries, and a `T` representing the value held previously. The "
"`nopanic` notation simply indicates that the function is guaranteed to never"
" panic."
msgstr ""
"첫 번째 입력 매개변수는 사전의 소유권을 가져가고, 두 번째 매개변수는 적절한 항목을 생성하는 데 사용됩니다. 이 함수는 `Cairo`가"
" 사전 항목을 나타내는 데 사용하는 `Felt252DictEntry<T>` 유형과 이전에 보유한 값을 나타내는 `T`를 포함하는 튜플을 "
"반환합니다. `nopanic` 표기법은 해당 함수가 절대로 패닉하지 않음을 나타냅니다."

#: src/ch03-02-dictionaries.md:178
msgid ""
"The next thing to do is to update the entry with the new value. For this, we"
" use the `finalize` method which inserts the entry and returns ownership of "
"the dictionary:"
msgstr ""
"다음 할 일은 새 값으로 항목을 업데이트하는 것입니다. 이를 위해 `finalize` 메소드를 사용하여 항목을 삽입하고 사전의 소유권을 "
"반환합니다:"

#: src/ch03-02-dictionaries.md:184
msgid ""
"This method receives the entry and the new value as parameters, and returns "
"the updated dictionary."
msgstr "이 방법은 항목과 새 값이 매개변수로 전달되고, 업데이트된 사전을 반환합니다."

#: src/ch03-02-dictionaries.md:186
msgid ""
"Let us see an example using `entry` and `finalize`. Imagine we would like to"
" implement our own version of the `get` method from a dictionary. We should "
"then do the following:"
msgstr ""
"다음은 `entry`와 `finalize`를 사용한 예제를 살펴봅시다. 사전에서 `get` 메서드의 자체 버전을 구현하고 싶다고 가정해 "
"봅시다. 그렇다면 다음을 수행해야 합니다."

#: src/ch03-02-dictionaries.md:188
msgid "Create the new entry to add using the `entry` method."
msgstr "`entry` 메소드를 사용하여 추가할 새 항목을 생성하십시오."

#: src/ch03-02-dictionaries.md:189
msgid ""
"Insert back the entry where the `new_value` equals the `previous_value`."
msgstr "`new_value`가 `previous_value`와 같은 항목을 다시 삽입하십시오."

#: src/ch03-02-dictionaries.md:190
msgid "Return the value."
msgstr "값을 반환하십시오."

#: src/ch03-02-dictionaries.md:192
msgid "Implementing our custom get would look like this:"
msgstr "우리의 사용자 정의 get을 구현하는 것은 다음과 같이 보일 것입니다:"

#: src/ch03-02-dictionaries.md:200 src/ch03-02-dictionaries.md:244
msgid "// Get the new entry and the previous value held at `key`\n"
msgstr "`key`에 보관된 새 항목과 이전 값 가져오기"

#: src/ch03-02-dictionaries.md:203 src/ch03-02-dictionaries.md:247
msgid "// Store the value to return\n"
msgstr "반환할 값을 저장합니다."

#: src/ch03-02-dictionaries.md:206 src/ch03-02-dictionaries.md:250
msgid ""
"// Update the entry with `prev_value` and get back ownership of the "
"dictionary\n"
msgstr "// `prev_value`로 항목을 업데이트하고 사전의 소유권을 되찾습니다."

#: src/ch03-02-dictionaries.md:209 src/ch03-02-dictionaries.md:253
msgid "// Return the read value\n"
msgstr "// 읽은 값을 반환합니다"

#: src/ch03-02-dictionaries.md:214
msgid ""
"The `ref` keyword means that the ownership of the variable will be given "
"back at the end of the function. This concept will be explained in more "
"detail in the [References and Snapshots](ch04-02-references-and-"
"snapshots.md) section."
msgstr ""
"`ref` 키워드는 변수의 소유권이 함수의 끝에서 다시 돌려받을 것을 의미합니다. 이 개념은 [참조 및 "
"스냅샷](ch04-02-references-and-snapshots.md) 섹션에서 자세히 설명될 것입니다."

#: src/ch03-02-dictionaries.md:217
msgid ""
"Implementing the `insert` method would follow a similar workflow, except for"
" inserting a new value when finalizing. If we were to implement it, it would"
" look like the following:"
msgstr ""
"`insert` 메소드를 구현하는 것은 새로운 값을 삽입할 때를 제외하고는 유사한 작업 흐름을 따를 것입니다. 만약 우리가 이를 "
"구현한다면 다음과 같이 보일 것입니다:"

#: src/ch03-02-dictionaries.md:225
msgid ""
"// Get the last entry associated with `key`\n"
"    // Notice that if `key` does not exist, `_prev_value` will\n"
"    // be the default value of T.\n"
msgstr ""
"// `key`와 관련된 마지막 항목을 가져옵니다.\n"
"    // `key`가 존재하지 않는 경우, `_prev_value`는\n"
"    // T의 기본값이 됩니다."

#: src/ch03-02-dictionaries.md:230
msgid ""
"// Insert `entry` back in the dictionary with the updated value,\n"
"    // and receive ownership of the dictionary\n"
msgstr ""
"// `entry`를 업데이트된 값과 함께 다시 사전에 삽입하고,\n"
"    // 사전의 소유권을 받습니다"

#: src/ch03-02-dictionaries.md:236
msgid ""
"As a finalizing note, these two methods are implemented in a similar way to "
"how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows"
" some example usage:"
msgstr ""
"마무리로, 이 두 가지 방법은 `Felt252Dict<T>`에 대해 `insert`와 `get`가 구현된 방식과 유사하게 구현됩니다. 이"
" 코드는 몇 가지 사용 예시를 보여줍니다:"

#: src/ch03-02-dictionaries.md:260
msgid "// Get the last entry associated with `key`\n"
msgstr "`key`와 관련된 마지막 항목을 가져옵니다."

#: src/ch03-02-dictionaries.md:261
msgid "// Notice that if `key` does not exist, `_prev_value` will\n"
msgstr "// `key`가 존재하지 않는 경우, `_prev_value`가 됩니다."

#: src/ch03-02-dictionaries.md:262
msgid "// be the default value of T.\n"
msgstr "T의 기본값이 되십시오."

#: src/ch03-02-dictionaries.md:265
msgid "// Insert `entry` back in the dictionary with the updated value,\n"
msgstr "사전에 업데이트된 값으로 'entry'를 다시 삽입하세요."

#: src/ch03-02-dictionaries.md:266
msgid "// and receive ownership of the dictionary\n"
msgstr "// 그리고 사전의 소유권을 받으십시오"

#: src/ch03-02-dictionaries.md:273 src/ch03-02-dictionaries.md:275
msgid "'0'"
msgstr "'0'"

#: src/ch03-02-dictionaries.md:277
msgid "\"Expecting 100\""
msgstr "\"100을 기대하고 있습니다\""

#: src/ch03-02-dictionaries.md:283
msgid "Dictionaries of types not supported natively"
msgstr "네이티브로 지원되지 않는 유형의 사전"

#: src/ch03-02-dictionaries.md:285
msgid ""
"One restriction of `Felt252Dict<T>` that we haven't talked about is the "
"trait `Felt252DictValue<T>`. This trait defines the `zero_default` method "
"which is the one that gets called when a value does not exist in the "
"dictionary. This is implemented by some common data types, such as most "
"unsigned integers, `bool` and `felt252` - but it is not implemented for more"
" complex ones types such as arrays, structs (including `u256`), and other "
"types from the core library. This means that making a dictionary of types "
"not natively supported is not a straightforward task, because you would need"
" to write a couple of trait implementations in order to make the data type a"
" valid dictionary value type. To compensate this, you can wrap your type "
"inside a `Nullable<T>`."
msgstr ""
"`Felt252Dict<T>`의 한 제한 사항은 우리가 이야기하지 않은 `Felt252DictValue<T>` 트레이트입니다. 이 "
"트레이트는 딕셔너리에 값이 없을 때 호출되는 `zero_default` 메서드를 정의합니다. 이는 대부분의 부호 없는 정수, `bool`"
" 및 `felt252`와 같은 일부 일반 데이터 유형에서 구현되지만 배열, 구조체(포함된 `u256`), 및 코어 라이브러리의 다른 "
"유형과 같은 더 복잡한 유형에 대해서는 구현되지 않습니다. 이는 네이티브로 지원되지 않는 유형의 딕셔너리를 만드는 것이 간단한 작업이 "
"아니라는 것을 의미합니다. 왜냐하면 데이터 유형을 유효한 딕셔너리 값 유형으로 만들기 위해 몇 가지 트레이트 구현을 작성해야하기 "
"때문입니다. 이를 보상하기 위해 유형을 `Nullable<T>`로 래핑할 수 있습니다."

#: src/ch03-02-dictionaries.md:291
msgid ""
"`Nullable<T>` is a smart pointer type that can either point to a value or be"
" `null` in the absence of value. It is usually used in Object Oriented "
"Programming Languages when a reference doesn't point anywhere. The "
"difference with `Option` is that the wrapped value is stored inside a "
"`Box<T>` data type. The `Box<T>` type, inspired by Rust, allows us to "
"allocate a new memory segment for our type, and access this segment using a "
"pointer that can only be manipulated in one place at a time."
msgstr ""
"`Nullable<T>`은 값에 대한 포인터가 될 수도 있고 값이 없을 때는 `null`이 될 수 있는 스마트 포인터 유형입니다. 객체 "
"지향 프로그래밍 언어에서 참조가 어디를 가리키지 않을 때 주로 사용됩니다. `Option`과의 차이점은 래핑된 값이 `Box<T>` "
"데이터 유형 내에 저장된다는 것입니다. 러스트에서 영감을 받은 `Box<T>` 유형은 우리의 유형을 위한 새로운 메모리 세그먼트를 "
"할당하고, 이 세그먼트에 대한 포인터를 사용하여 한 번에 한 곳에서만 조작할 수 있도록 합니다."

#: src/ch03-02-dictionaries.md:293
msgid ""
"Let's show using an example. We will try to store a `Span<felt252>` inside a"
" dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are "
"storing a `Span<T>` and not an `Array<T>` because the latter does not "
"implement the `Copy<T>` trait which is required for reading from a "
"dictionary."
msgstr ""
"예를 통해 보여드립시다. 우리는 사전 안에 `Span<felt252>`를 저장하려고 시도할 것입니다. 이를 위해 "
"`Nullable<T>`와 `Box<T>`를 사용할 것입니다. 또한, 우리는 `Array<T>`가 아닌 `Span<T>`를 저장하고 "
"있습니다. 왜냐하면 후자는 사전에서 읽기 위해 필요한 `Copy<T>` 특성을 구현하지 않기 때문입니다."

#: src/ch03-02-dictionaries.md:299 src/ch03-02-dictionaries.md:353
msgid "// Create the dictionary\n"
msgstr "// 사전을 생성합니다"

#: src/ch03-02-dictionaries.md:302 src/ch03-02-dictionaries.md:356
msgid "// Create the array to insert\n"
msgstr "// 삽입할 배열을 생성합니다"

#: src/ch03-02-dictionaries.md:305 src/ch03-02-dictionaries.md:359
msgid "// Insert it as a `Span`\n"
msgstr "// `Span`으로 삽입하세요"

#: src/ch03-02-dictionaries.md:307 src/ch03-02-dictionaries.md:322
msgid "//...\n"
msgstr ""
"I'm sorry, but there is no text provided for me to translate into Korean. "
"Please provide the text you would like me to translate."

#: src/ch03-02-dictionaries.md:311
msgid ""
"In this code snippet, the first thing we did was to create a new dictionary "
"`d`. We want it to hold a `Nullable<Span>`. After that, we created an array "
"and filled it with values."
msgstr ""
"이 코드 스니펫에서 우리가 먼저 한 일은 새로운 딕셔너리 `d`를 만드는 것이었습니다. `Nullable<Span>`을 보유하길 "
"원합니다. 그 후에 우리는 배열을 만들고 값으로 채웠습니다."

#: src/ch03-02-dictionaries.md:313
msgid ""
"The last step is inserting the array as a span inside the dictionary. Notice"
" that we didn't do that directly, but instead, we took some steps in "
"between:"
msgstr "마지막 단계는 배열을 사전 안에 span으로 삽입하는 것입니다. 직접 그렇게 하지 않고 중간 단계를 거쳤음을 주의하세요."

#: src/ch03-02-dictionaries.md:315
msgid ""
"We wrapped the array inside a `Box` using the `new` method from `BoxTrait`."
msgstr "우리는 `BoxTrait`에서 `new` 메서드를 사용하여 `Box` 안에 배열을 감쌌습니다."

#: src/ch03-02-dictionaries.md:316
msgid ""
"We wrapped the `Box` inside a nullable using the `nullable_from_box` "
"function."
msgstr "우리는 `nullable_from_box` 함수를 사용하여 `Box`를 nullable로 감쌌습니다."

#: src/ch03-02-dictionaries.md:317
msgid "Finally, we inserted the result."
msgstr "마침내, 우리는 결과를 삽입했습니다."

#: src/ch03-02-dictionaries.md:319
msgid ""
"Once the element is inside the dictionary, and we want to get it, we follow "
"the same steps but in reverse order. The following code shows how to achieve"
" that:"
msgstr ""
"요소가 사전 안에 들어가면, 우리는 그것을 얻고 싶을 때, 같은 단계를 역순으로 따릅니다. 다음 코드는 그것을 얻는 방법을 보여줍니다:"

#: src/ch03-02-dictionaries.md:324 src/ch03-02-dictionaries.md:362
msgid "// Get value back\n"
msgstr "값을 다시 가져오기"

#: src/ch03-02-dictionaries.md:327 src/ch03-02-dictionaries.md:365
msgid "// Search the value and assert it is not null\n"
msgstr "// 값을 검색하고 null이 아님을 단언합니다."

#: src/ch03-02-dictionaries.md:329 src/ch03-02-dictionaries.md:367
msgid "\"No value found\""
msgstr "\"값을 찾을 수 없음\""

#: src/ch03-02-dictionaries.md:333 src/ch03-02-dictionaries.md:371
msgid "// Verify we are having the right values\n"
msgstr "// 올바른 값을 가지고 있는지 확인합니다"

#: src/ch03-02-dictionaries.md:334 src/ch03-02-dictionaries.md:372
msgid "\"Expecting 8\""
msgstr "\"8를 기대하고 있습니다\""

#: src/ch03-02-dictionaries.md:335 src/ch03-02-dictionaries.md:373
msgid "\"Expecting 9\""
msgstr "\"9를 기대하고 있습니다\""

#: src/ch03-02-dictionaries.md:336 src/ch03-02-dictionaries.md:374
msgid "\"Expecting 10\""
msgstr "\"10을 기대하고 있습니다\""

#: src/ch03-02-dictionaries.md:340
msgid "Here we:"
msgstr "여기 우리:"

#: src/ch03-02-dictionaries.md:342
msgid "Read the value using `get`."
msgstr "`get`를 사용하여 값 읽기."

#: src/ch03-02-dictionaries.md:343
msgid "Verified it is non-null using the `match_nullable` function."
msgstr "`match_nullable` 함수를 사용하여 비-널임을 확인했습니다."

#: src/ch03-02-dictionaries.md:344
msgid "Unwrapped the value inside the box and asserted it was correct."
msgstr "상자 안의 가치를 풀어보고 올바르다고 주장했다."

#: src/ch03-02-dictionaries.md:346
msgid "The complete script would look like this:"
msgstr "전체 스크립트는 다음과 같을 것입니다:"

#: src/ch03-03-custom-data-structures.md:3
msgid ""
"When you first start programming in Cairo, you'll likely want to use arrays "
"(`Array<T>`) to store collections of data. However, you will quickly realize"
" that arrays have one big limitation - the data stored in them is immutable."
" Once you append a value to an array, you can't modify it."
msgstr ""
"카이로에서 프로그래밍을 처음 시작할 때, 데이터 컬렉션을 저장하기 위해 배열(`Array<T>`)을 사용하고 싶어할 것입니다. 그러나 "
"배열에는 한 가지 큰 제한이 있다는 것을 빨리 깨닫게 될 것입니다 - 배열에 저장된 데이터는 불변입니다. 배열에 값을 추가한 후에는 "
"수정할 수 없습니다."

#: src/ch03-03-custom-data-structures.md:8
msgid ""
"This can be frustrating when you want to use a mutable data structure. For "
"example, say you're making a game where the players have a level, and they "
"can level up. You might try to store the level of the players in an array:"
msgstr ""
"이것은 가변 데이터 구조를 사용하고 싶을 때 짜증날 수 있습니다. 예를 들어, 플레이어가 레벨을 가지고 있고 레벨을 올릴 수 있는 게임을"
" 만들고 있다고 가정해보세요. 플레이어들의 레벨을 배열에 저장해보려고 할 수 있습니다."

#: src/ch03-03-custom-data-structures.md:19
msgid ""
"But then you realize you can't increase the level at a specific index once "
"it's set. If a player dies, you cannot remove it from the array unless he "
"happens to be in the first position."
msgstr ""
"하지만 그런 다음에 당신은 특정 인덱스에서 레벨을 증가시킬 수 없다는 것을 깨닫게 됩니다. 플레이어가 죽으면, 그를 배열에서 제거할 수 "
"없습니다. 그는 첫 번째 위치에 있을 때만 가능합니다."

#: src/ch03-03-custom-data-structures.md:23
msgid ""
"Fortunately, Cairo provides a handy built-in [dictionary "
"type](./ch03-02-dictionaries.md) called `Felt252Dict<T>` that allows us to "
"simulate the behavior of mutable data structures. Let's first explore how to"
" create a struct that contains, among others, a `Felt252Dict<T>`."
msgstr ""
"다행히도, 카이로는 가변 데이터 구조의 동작을 모방할 수 있게 해주는 `Felt252Dict<T>`라는 편리한 내장 [사전 "
"유형](./ch03-02-dictionaries.md)을 제공합니다. 먼저, `Felt252Dict<T>`를 포함하는 구조체를 만드는 "
"방법을 살펴보겠습니다."

#: src/ch03-03-custom-data-structures.md:27
msgid ""
"Note: Several concepts used in this chapter are presented in later parts of "
"the book. We recommend you to check out the following chapter first: "
"[Structs](ch05-00-using-structs-to-structure-related-data.md), "
"[Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-"
"types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"참고: 이 장에서 사용된 여러 개념은 책의 후반부에 소개됩니다. 먼저 다음 장을 확인하는 것을 권장합니다: "
"[Structs](ch05-00-using-structs-to-structure-related-data.md), "
"[Methods](./ch05-03-method-syntax.md), [Generic types](./ch08-00-generic-"
"types-and-traits.md), [Traits](./ch08-02-traits-in-cairo.md)."

#: src/ch03-03-custom-data-structures.md:34
msgid "Dictionaries as Struct Members"
msgstr "구조체 멤버로서의 사전"

#: src/ch03-03-custom-data-structures.md:36
msgid ""
"Defining dictionaries as struct members is possible in Cairo but correctly "
"interacting with them may not be entirely seamless. Let's try implementing a"
" custom _user database_ that will allow us to add users and query them. We "
"will need to define a struct to represent the new type and a trait to define"
" its functionality:"
msgstr ""
"카이로에서는 사전을 구조체 멤버로 정의하는 것이 가능하지만, 이를 올바르게 상호 작용하는 것은 완전히 원활하지 않을 수 있습니다. 사용자"
" 데이터베이스를 구현해보겠습니다. 사용자를 추가하고 조회할 수 있는 사용자 데이터베이스를 만들어보겠습니다. 새로운 유형을 나타내는 "
"구조체를 정의하고 그 기능을 정의하기 위해 특성을 정의해야 합니다."

#: src/ch03-03-custom-data-structures.md:51
msgid ""
"Our new type `UserDatabase<T>` represents a database of users. It is generic"
" over the balances of the users, giving major flexibility to whoever uses "
"our data type. Its two members are:"
msgstr ""
"새로운 유형 `UserDatabase<T>`는 사용자 데이터베이스를 나타냅니다. 사용자의 잔액을 제네릭하게 처리하여 데이터 유형을 "
"사용하는 사람에게 주요한 유연성을 제공합니다. 이의 두 멤버는 다음과 같습니다:"

#: src/ch03-03-custom-data-structures.md:53
msgid "`users_updates`, the number of users updates in the dictionary and"
msgstr "`users_updates`, 사전에서 사용자 업데이트 수와"

#: src/ch03-03-custom-data-structures.md:54
msgid "`balances`, a mapping of each user to its balance."
msgstr "`balances`, 각 사용자의 잔액에 대한 매핑입니다."

#: src/ch03-03-custom-data-structures.md:56
msgid ""
"The database core functionality is defined by `UserDatabaseTrait`. The "
"following methods are defined:"
msgstr "데이터베이스의 핵심 기능은 `UserDatabaseTrait`에 의해 정의됩니다. 다음 메서드가 정의되어 있습니다:"

#: src/ch03-03-custom-data-structures.md:58
msgid "`new` for easily creating new `UserDatabase` types."
msgstr "`new`는 새로운 `UserDatabase` 유형을 쉽게 생성하는 데 사용됩니다."

#: src/ch03-03-custom-data-structures.md:59
msgid "`update_user` to update the balance of users in the database."
msgstr "`update_user`는 데이터베이스에서 사용자의 잔액을 업데이트합니다."

#: src/ch03-03-custom-data-structures.md:60
msgid "`get_balance` to find user's balance in the database."
msgstr "`get_balance`은 데이터베이스에서 사용자의 잔액을 찾는 데 사용됩니다."

#: src/ch03-03-custom-data-structures.md:62
msgid ""
"The only remaining step is to implement each of the methods in "
"`UserDatabaseTrait`, but since we are working with [generic "
"types](/src/ch08-00-generic-types-and-traits.md) we also need to correctly "
"establish the requirements of `T` so it can be a valid `Felt252Dict<T>` "
"value type:"
msgstr ""
"`UserDatabaseTrait`의 각 메서드를 구현하는 것이 유일하게 남은 단계입니다. 그러나 [일반 "
"유형](/src/ch08-00-generic-types-and-traits.md)을 사용하고 있기 때문에 `T`의 요구 사항을 올바르게 "
"설정하여 유효한 `Felt252Dict<T>` 값 유형이 될 수 있도록 해야 합니다."

#: src/ch03-03-custom-data-structures.md:64
msgid ""
"`T` should implement the `Copy<T>` since it's required for getting values "
"from a `Felt252Dict<T>`."
msgstr "`T`는 `Felt252Dict<T>`에서 값들을 가져오기 위해 필요하기 때문에 `Copy<T>`를 구현해야 합니다."

#: src/ch03-03-custom-data-structures.md:65
msgid ""
"All value types of a dictionary implement the `Felt252DictValue<T>`, our "
"generic type should do as well."
msgstr "사전의 모든 값 유형은 `Felt252DictValue<T>`를 구현합니다. 우리의 일반 유형도 그렇게 해야 합니다."

#: src/ch03-03-custom-data-structures.md:66
msgid ""
"To insert values, `Felt252DictTrait<T>` requires all value types to be "
"destructible."
msgstr "값을 삽입하려면 `Felt252DictTrait<T>`은 모든 값 유형이 소멸 가능해야 합니다."

#: src/ch03-03-custom-data-structures.md:68
msgid ""
"The implementation, with all restrictions in place, would be as follow:"
msgstr "구현은 모든 제한 사항이 적용된 상태에서 다음과 같이 이루어질 것입니다."

#: src/ch03-03-custom-data-structures.md:74
#: src/ch03-03-custom-data-structures.md:119
msgid "// Creates a database\n"
msgstr "데이터베이스를 생성합니다."

#: src/ch03-03-custom-data-structures.md:79
#: src/ch03-03-custom-data-structures.md:124
msgid "// Get the user's balance\n"
msgstr "사용자의 잔액을 가져옵니다."

#: src/ch03-03-custom-data-structures.md:84
#: src/ch03-03-custom-data-structures.md:129
msgid "// Add a user\n"
msgstr "사용자 추가"

#: src/ch03-03-custom-data-structures.md:92
msgid ""
"Our database implementation is almost complete, except for one thing: the "
"compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since"
" it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait. "
"Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are"
" forced to implement the `Destruct<T>` trait manually (refer to the "
"[Ownership](ch04-01-what-is-ownership.md#the-drop-trait) chapter for more "
"information). Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` "
"definition won't work because of the use of "
"[genericity](/src/ch08-00-generic-types-and-traits.md) in the struct "
"definition. We need to code the `Destruct<T>` trait implementation by "
"ourselves:"
msgstr ""
"저희 데이터베이스 구현은 거의 완료되었습니다. 하나 빼고요: 컴파일러는 `UserDatabase<T>`가 스코프를 벗어날 때 어떻게 해야"
" 하는지 모르기 때문에 `Drop<T>` 트레이트나 `Destruct<T>` 트레이트를 구현하지 않았습니다. "
"`Felt252Dict<T>`를 멤버로 가지고 있기 때문에 삭제할 수 없습니다. 그래서 우리는 `Destruct<T>` 트레이트를 "
"수동으로 구현해야 합니다 ([소유권](ch04-01-what-is-ownership.md#the-drop-trait) 장을 참조하세요)."
" `UserDatabase<T>` 정의 맨 위에 `#[derive(Destruct)]`를 사용하는 것은 구조체 정의에서 "
"[일반성](/src/ch08-00-generic-types-and-traits.md)을 사용했기 때문에 작동하지 않습니다. 우리는 "
"`Destruct<T>` 트레이트 구현을 직접 코딩해야 합니다:"

#: src/ch03-03-custom-data-structures.md:104
msgid ""
"Implementing `Destruct<T>` for `UserDatabase` was our last step to get a "
"fully functional database. We can now try it out:"
msgstr ""
"`UserDatabase`에 대한 `Destruct<T>`를 구현하는 것은 완전히 기능하는 데이터베이스를 얻기 위한 마지막 단계였습니다."
" 이제 우리는 이를 시도해 볼 수 있습니다."

#: src/ch03-03-custom-data-structures.md:154
msgid "\"Expected 40\""
msgstr "예상 40"

#: src/ch03-03-custom-data-structures.md:155
msgid "\"Expected 0\""
msgstr "예상 0"

#: src/ch03-03-custom-data-structures.md:161
msgid "Simulating a dynamic array with dicts"
msgstr "딕셔너리로 동적 배열 시뮬레이션하기"

#: src/ch03-03-custom-data-structures.md:163
msgid ""
"First, let's think about how we want our mutable dynamic array to behave. "
"What operations should it support?"
msgstr "먼저, 우리가 원하는 가변 동적 배열의 동작에 대해 생각해 봅시다. 어떤 작업을 지원해야 할까요?"

#: src/ch03-03-custom-data-structures.md:166
msgid "It should:"
msgstr "그것은 해야합니다."

#: src/ch03-03-custom-data-structures.md:168
msgid "Allow us to append items at the end."
msgstr "우리에게 항목을 끝에 추가할 수 있게 해주세요."

#: src/ch03-03-custom-data-structures.md:169
msgid "Let us access any item by index."
msgstr "우리는 색인을 통해 모든 항목에 액세스할 수 있습니다."

#: src/ch03-03-custom-data-structures.md:170
msgid "Allow setting the value of an item at a specific index."
msgstr "특정 인덱스에 항목의 값을 설정할 수 있도록 허용합니다."

#: src/ch03-03-custom-data-structures.md:171
msgid "Return the current length."
msgstr "현재 길이를 반환합니다."

#: src/ch03-03-custom-data-structures.md:173
msgid "We can define this interface in Cairo like:"
msgstr "우리는 카이로에서 이 인터페이스를 정의할 수 있습니다."

#: src/ch03-03-custom-data-structures.md:186
msgid ""
"This provides a blueprint for the implementation of our dynamic array. We "
"named it _Vec_ as it is similar to the `Vec<T>` data structure in Rust."
msgstr ""
"이것은 우리의 동적 배열 구현을 위한 청사진을 제공합니다. 우리는 Rust의 `Vec<T>` 데이터 구조와 유사하기 때문에 이를 "
"_Vec_ 이라고 이름 지었습니다."

#: src/ch03-03-custom-data-structures.md:189
msgid "Implementing a dynamic array in Cairo"
msgstr "카이로에서 동적 배열 구현하기"

#: src/ch03-03-custom-data-structures.md:191
msgid ""
"To store our data, we'll use a `Felt252Dict<T>` which maps index numbers "
"(felts) to values. We'll also store a separate `len` field to track the "
"length."
msgstr ""
"저희 데이터를 저장하기 위해 색인 번호(felts)를 값에 매핑하는 `Felt252Dict<T>`를 사용할 것입니다. 또한 길이를 "
"추적하기 위해 별도의 `len` 필드를 저장할 것입니다."

#: src/ch03-03-custom-data-structures.md:194
msgid ""
"Here is what our struct looks like. We wrap the type `T` inside `Nullable` "
"pointer to allow using any type `T` in our data structure, as explained in "
"the [Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) section:"
msgstr ""
"다음은 우리의 구조가 어떻게 보이는지에 대한 설명입니다. 우리는 `Nullable` 포인터 내부에 유형 `T`를 감싸 사용자가 "
"[Dictionaries](./ch03-02-dictionaries.md#dictionaries-of-types-not-"
"supported-natively) 섹션에서 설명된대로 데이터 구조에서 어떤 유형 `T`를 사용할 수 있도록 합니다."

#: src/ch03-03-custom-data-structures.md:206
msgid ""
"The key thing that makes this vector mutable is that we can insert values "
"into the dictionary to set or update values in our data structure. For "
"example, to update a value at a specific index, we do:"
msgstr ""
"이 벡터를 가변적으로 만드는 주요한 점은 딕셔너리에 값을 삽입하여 데이터 구조 내의 값을 설정하거나 업데이트할 수 있다는 것입니다. 예를"
" 들어, 특정 인덱스의 값을 업데이트하려면 다음을 수행합니다:"

#: src/ch03-03-custom-data-structures.md:212
#: src/ch03-03-custom-data-structures.md:241
#: src/ch03-03-custom-data-structures.md:250
msgid "\"Index out of bounds\""
msgstr "\"인덱스가 범위를 벗어남\""

#: src/ch03-03-custom-data-structures.md:217
msgid ""
"This overwrites the previously existing value at that index in the "
"dictionary."
msgstr "이것은 사전에서 해당 인덱스의 이전에 존재하던 값을 덮어씁니다."

#: src/ch03-03-custom-data-structures.md:219
msgid ""
"While arrays are immutable, dictionaries provide the flexibility we need for"
" modifiable data structures like vectors."
msgstr "배열은 변경할 수 없지만, 사전은 벡터와 같은 수정 가능한 데이터 구조에 필요한 유연성을 제공합니다."

#: src/ch03-03-custom-data-structures.md:222
msgid ""
"The implementation of the rest of the interface is straightforward. The "
"implementation of all the methods defined in our interface can be done as "
"follow :"
msgstr "인터페이스의 나머지 부분 구현은 간단합니다. 우리 인터페이스에 정의된 모든 메소드의 구현은 다음과 같이 할 수 있습니다:"

#: src/ch03-03-custom-data-structures.md:259
msgid ""
"The full implementation of the `Vec` structure can be found in the "
"community-maintained library [Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/src/data_structures)."
msgstr ""
"`Vec` 구조체의 전체 구현은 커뮤니티가 유지보수하는 라이브러리 [Alexandria](https://github.com/keep-"
"starknet-strange/alexandria/tree/main/src/data_structures)에서 찾을 수 있습니다."

#: src/ch03-03-custom-data-structures.md:263
msgid "Simulating a Stack with dicts"
msgstr "사전을 사용하여 스택 시뮬레이션하기"

#: src/ch03-03-custom-data-structures.md:265
msgid ""
"We will now look at a second example and its implementation details: a "
"Stack."
msgstr "우리는 이제 두 번째 예제와 그 구현 세부사항을 살펴볼 것입니다: 스택(Stack)."

#: src/ch03-03-custom-data-structures.md:267
msgid ""
"A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new "
"element and removal of an existing element takes place at the same end, "
"represented as the top of the stack."
msgstr ""
"스택은 LIFO(Last-In, First-Out) 컬렉션입니다. 새로운 요소의 삽입과 기존 요소의 제거는 동일한 끝에서 발생하며, 이는"
" 스택의 맨 위로 표시됩니다."

#: src/ch03-03-custom-data-structures.md:271
msgid "Let us define what operations we need to create a stack :"
msgstr "저희가 스택을 만들기 위해 필요한 작업을 정의해 봅시다."

#: src/ch03-03-custom-data-structures.md:273
msgid "Push an item to the top of the stack."
msgstr "스택의 맨 위에 항목을 밀어 넣으세요."

#: src/ch03-03-custom-data-structures.md:274
msgid "Pop an item from the top of the stack."
msgstr "스택의 맨 위에 있는 항목을 꺼내세요."

#: src/ch03-03-custom-data-structures.md:275
msgid "Check whether there are still any elements in the stack."
msgstr "스택에 아직 요소가 있는지 확인하십시오."

#: src/ch03-03-custom-data-structures.md:277
msgid "From these specifications we can define the following interface :"
msgstr "이 명세서를 토대로 다음과 같은 인터페이스를 정의할 수 있습니다:"

#: src/ch03-03-custom-data-structures.md:287
msgid "Implementing a Mutable Stack in Cairo"
msgstr "카이로에서 가변 스택 구현하기"

#: src/ch03-03-custom-data-structures.md:289
msgid ""
"To create a stack data structure in Cairo, we can again use a "
"`Felt252Dict<T>` to store the values of the stack along with a `usize` field"
" to keep track of the length of the stack to iterate over it."
msgstr ""
"카이로에서 스택 데이터 구조를 만들기 위해, 우리는 다시 `Felt252Dict<T>`를 사용하여 스택의 값들을 저장하고 `usize` "
"필드를 사용하여 스택의 길이를 추적하여 반복할 수 있습니다."

#: src/ch03-03-custom-data-structures.md:293
msgid "The Stack struct is defined as:"
msgstr "스택 구조체는 다음과 같이 정의됩니다:"

#: src/ch03-03-custom-data-structures.md:302
msgid ""
"Next, let's see how our main functions `push` and `pop` are implemented."
msgstr "다음으로, 주요 기능 'push'와 'pop'이 어떻게 구현되었는지 살펴봅시다."

#: src/ch03-03-custom-data-structures.md:325
msgid ""
"The code uses the `insert` and `get` methods to access the values in the "
"`Felt252Dict<T>`. To push an element to the top of the stack, the `push` "
"function inserts the element in the dict at index `len` and increases the "
"`len` field of the stack to keep track of the position of the stack top. To "
"remove a value, the `pop` function retrieves the last value at position "
"`len-1` and then decreases the value of `len` to update the position of the "
"stack top accordingly."
msgstr ""
"해당 코드는 `Felt252Dict<T>`에서 값을 액세스하기 위해 `insert` 및 `get` 메서드를 사용합니다. 스택의 맨 위에 "
"요소를 푸시하려면 `push` 함수는 요소를 인덱스 `len`에 삽입하고 스택의 `len` 필드를 증가시켜 스택 맨 위의 위치를 "
"추적합니다. 값을 제거하려면 `pop` 함수가 `len-1` 위치의 마지막 값을 검색한 다음 `len` 값을 감소시켜 스택 맨 위의 "
"위치를 업데이트합니다."

#: src/ch03-03-custom-data-structures.md:333
msgid ""
"The full implementation of the Stack, along with more data structures that "
"you can use in your code, can be found in the community-maintained "
"[Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/src/data_structures) library, in the "
"\"data_structures\" crate."
msgstr ""
"스택의 완전한 구현과 코드에서 사용할 수 있는 더 많은 데이터 구조는 커뮤니티가 유지하는 "
"[Alexandria](https://github.com/keep-starknet-"
"strange/alexandria/tree/main/src/data_structures) 라이브러리에서 "
"\"data_structures\" 크레이트에서 찾을 수 있습니다."

#: src/ch03-03-custom-data-structures.md:340
msgid ""
"Well done! Now you have knowledge of arrays, dictionaries and even custom "
"data structures.  While Cairo's memory model is immutable and can make it "
"difficult to implement mutable data structures, we can fortunately use the "
"`Felt252Dict<T>` type to simulate mutable data structures. This allows us to"
" implement a wide range of data structures that are useful for many "
"applications, effectively hiding the complexity of the underlying memory "
"model."
msgstr ""
"잘 했어요! 이제 배열, 딕셔너리, 심지어 사용자 정의 데이터 구조에 대한 지식을 갖게 되었습니다. 카이로의 메모리 모델은 불변이기 "
"때문에 가변 데이터 구조를 구현하기 어려울 수 있지만, 다행히도 `Felt252Dict<T>` 유형을 사용하여 가변 데이터 구조를 "
"시뮬레이션할 수 있습니다. 이를 통해 많은 응용 프로그램에 유용한 다양한 데이터 구조를 구현할 수 있으며, 기본 메모리 모델의 복잡성을 "
"효과적으로 숨길 수 있습니다."

#: src/ch03-03-custom-data-structures.md:347
msgid ""
"When you’re ready to move on, we’ll talk about a concept that Cairo shares "
"with Rust and that doesn’t commonly exist in other programming languages: "
"ownership."
msgstr ""
"당신이 다음으로 넘어갈 준비가 되면, 카이로가 러스트와 공유하는 개념에 대해 이야기해 보겠습니다. 이것은 다른 프로그래밍 언어에서 흔히 "
"존재하지 않는 소유권입니다."

#: src/ch04-00-understanding-ownership.md:1
msgid "Understanding Cairo's Ownership system"
msgstr "카이로의 소유권 시스템 이해하기"

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Cairo is a language built around a linear type system that allows us to "
"statically ensure that in every Cairo program, a value is used exactly once."
" This linear type system helps preventing runtime errors by ensuring that "
"operations that could cause such errors, such as writing twice to a memory "
"cell, are detected at compile time. This is achieved by implementing an "
"ownership system and forbidding copying and dropping values by default. In "
"this chapter, we’ll talk about Cairo's ownership system as well as "
"references and snapshots."
msgstr ""
"카이로는 선형 유형 시스템을 중심으로 구축된 언어로, 모든 카이로 프로그램에서 값이 정확히 한 번 사용되도록 정적으로 보장할 수 "
"있습니다. 이 선형 유형 시스템은 런타임 오류를 방지하기 위해 도와주며, 메모리 셀에 두 번 쓰기와 같은 오류를 일으킬 수 있는 작업이 "
"컴파일 시간에 감지되도록 합니다. 이는 소유권 시스템을 구현하고 기본적으로 값의 복사 및 삭제를 금지함으로써 달성됩니다. 이 장에서는 "
"카이로의 소유권 시스템과 참조 및 스냅샷에 대해 이야기하겠습니다."

#: src/ch04-01-what-is-ownership.md:1
msgid "Ownership Using a Linear Type System"
msgstr "소유권 선형 유형 시스템 사용"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"Cairo uses a linear type system. In such a type system, any value (a basic "
"type, a struct, an enum) must be used and must only be used once. 'Used' "
"here means that the value is either _destroyed_ or _moved_."
msgstr ""
"카이로는 선형 유형 시스템을 사용합니다. 이러한 유형 시스템에서는 모든 값(기본 유형, 구조체, 열거형)은 사용되어야 하며 한 번만 "
"사용되어야 합니다. 여기서 '사용된다'는 값이 _파괴_ 되거나 _이동_ 된다는 것을 의미합니다."

#: src/ch04-01-what-is-ownership.md:5
msgid "_Destruction_ can happen in several ways:"
msgstr "\"파괴\"는 여러 가지 방법으로 일어날 수 있습니다:"

#: src/ch04-01-what-is-ownership.md:7
msgid "a variable goes out of scope."
msgstr "변수가 스코프를 벗어납니다."

#: src/ch04-01-what-is-ownership.md:8
msgid "a struct is destructured."
msgstr "구조체가 해체되었습니다."

#: src/ch04-01-what-is-ownership.md:9
msgid "explicit destruction using `destruct()`."
msgstr "`destruct()`를 사용한 명시적인 파괴."

#: src/ch04-01-what-is-ownership.md:11
msgid "_Moving_ a value simply means passing that value to another function."
msgstr "값을 _이동_ 한다는 것은 단순히 해당 값을 다른 함수에 전달하는 것을 의미합니다."

#: src/ch04-01-what-is-ownership.md:13
msgid ""
"This results in somewhat similar constraints to the Rust ownership model, "
"but there are some differences. In particular, the Rust ownership model "
"exists (in part) to avoid data races and concurrent mutable access to a "
"memory value. This is obviously impossible in Cairo since the memory is "
"immutable. Instead, Cairo leverages its linear type system for two main "
"purposes:"
msgstr ""
"이는 러스트 소유권 모델과 어느 정도 유사한 제약 조건을 초래하지만, 몇 가지 차이점이 있습니다. 특히, 러스트 소유권 모델은 데이터 "
"레이스와 메모리 값에 대한 동시적인 가변 액세스를 피하기 위해 존재합니다. 이는 명백히 Cairo에서는 불가능합니다. 대신, Cairo는"
" 선형 유형 시스템을 두 가지 주요 목적으로 활용합니다:"

#: src/ch04-01-what-is-ownership.md:17
msgid "Ensuring that all code is provable and thus verifiable."
msgstr "모든 코드가 증명 가능하고 따라서 검증 가능하도록 보장하는 것."

#: src/ch04-01-what-is-ownership.md:18
msgid "Abstracting away the immutable memory of the Cairo VM."
msgstr "카이로 VM의 불변 메모리를 추상화합니다."

#: src/ch04-01-what-is-ownership.md:20
msgid "Ownership"
msgstr "소유권"

#: src/ch04-01-what-is-ownership.md:22
msgid ""
"In Cairo, ownership applies to _variables_ and not to _values_. A value can "
"safely be referred to by many different variables (even if they are mutable "
"variables), as the value itself is always immutable. Variables however can "
"be mutable, so the compiler must ensure that constant variables aren't "
"accidentally modified by the programmer. This makes it possible to talk "
"about ownership of a variable: the owner is the code that can read (and "
"write if mutable) the variable."
msgstr ""
"카이로에서 소유권은 _변수(variables)_ 에 적용되며 _값(values)_ 에는 적용되지 않습니다. 값은 항상 불변하기 때문에 많은 "
"다른 변수에서 안전하게 참조할 수 있습니다(가변 변수라도). 그러나 변수는 가변일 수 있으므로 컴파일러는 상수 변수가 프로그래머에 의해 "
"실수로 수정되지 않도록 보장해야 합니다. 이로써 변수의 소유권에 대해 이야기할 수 있게 되었습니다: 소유자는 변수를 읽을 수 있는(가변일"
" 경우 쓸 수 있는) 코드입니다."

#: src/ch04-01-what-is-ownership.md:26
msgid ""
"This means that variables (not values) follow similar rules to Rust values:"
msgstr "이는 변수(값이 아닌)가 러스트 값과 유사한 규칙을 따른다는 것을 의미합니다."

#: src/ch04-01-what-is-ownership.md:28
msgid "Each variable in Cairo has an owner."
msgstr "카이로의 각 변수는 소유자가 있습니다."

#: src/ch04-01-what-is-ownership.md:29
msgid "There can only be one owner at a time."
msgstr "한 번에 한 명의 소유자만 있을 수 있습니다."

#: src/ch04-01-what-is-ownership.md:30
msgid "When the owner goes out of scope, the variable is destroyed."
msgstr "소유자가 범위를 벗어나면 변수가 파괴됩니다."

#: src/ch04-01-what-is-ownership.md:32
msgid ""
"Now that we’re past basic Cairo syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a main function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr ""
"기본 카이로 구문을 넘어섰으므로, 예제에서는 모든 `fn main() {` 코드를 포함하지 않을 것이므로, 따라오고 있다면 다음 예제를 "
"main 함수 내에 수동으로 넣어야 합니다. 결과적으로, 우리의 예제는 조금 더 간결해지며, 보일러플레이트 코드 대신 실제 세부 사항에 "
"집중할 수 있게 될 것입니다."

#: src/ch04-01-what-is-ownership.md:34
msgid "Variable Scope"
msgstr "변수 범위"

#: src/ch04-01-what-is-ownership.md:36
msgid ""
"As a first example of the linear type system, we’ll look at the _scope_ of "
"some variables. A scope is the range within a program for which an item is "
"valid. Take the following variable:"
msgstr ""
"선형 유형 시스템의 첫 번째 예로, 일부 변수의 _범위_ 를 살펴보겠습니다. 범위는 항목이 유효한 프로그램 내의 범위를 의미합니다. 다음 "
"변수를 살펴보세요:"

#: src/ch04-01-what-is-ownership.md:44
msgid ""
"The variable `s` refers to a short string. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be"
" valid."
msgstr ""
"변수 `s`는 짧은 문자열을 가리킵니다. 이 변수는 선언된 지점부터 현재 _스코프_ 의 끝까지 유효합니다. 4-1 목록은 변수 `s`가 "
"유효한 위치를 주석으로 설명한 프로그램을 보여줍니다."

#: src/ch04-01-what-is-ownership.md:49
msgid "//TAG: ignore_fmt\n"
msgstr ""
"//TAG: ignore_fmt\n"
"\n"
"//TAG: 형식 무시"

#: src/ch04-01-what-is-ownership.md:51
msgid "// s is not valid here, it’s not yet declared\n"
msgstr "여기서 s는 유효하지 않습니다. 아직 선언되지 않았습니다."

#: src/ch04-01-what-is-ownership.md:52
msgid ""
"// s is valid from this point forward\n"
"    // do stuff with s\n"
msgstr ""
"// s는 이 지점부터 유효합니다\n"
"    // s와 관련된 작업을 수행합니다"

#: src/ch04-01-what-is-ownership.md:54
msgid "// this scope is now over, and s is no longer valid\n"
msgstr "이 범위는 이제 끝났으며, s는 더 이상 유효하지 않습니다."

#: src/ch04-01-what-is-ownership.md:58
msgid "Listing 4-1: A variable and the scope in which it is valid"
msgstr "리스트 4-1: 변수와 해당 변수가 유효한 범위"

#: src/ch04-01-what-is-ownership.md:60
msgid "In other words, there are two important points in time here:"
msgstr "다시 말해, 여기에는 두 가지 중요한 시점이 있습니다."

#: src/ch04-01-what-is-ownership.md:62
msgid "When `s` comes _into_ scope, it is valid."
msgstr "`s`가 범위에 들어오면 유효합니다."

#: src/ch04-01-what-is-ownership.md:63
msgid "It remains valid until it goes _out of_ scope."
msgstr "그것은 범위를 벗어날 때까지 유효합니다."

#: src/ch04-01-what-is-ownership.md:65
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of"
" this understanding by using the `Array` type we introduced in the [previous"
" chapter](./ch03-01-arrays.md)."
msgstr ""
"이 시점에서, 스코프와 변수의 유효성이 언제인지에 대한 관계는 다른 프로그래밍 언어와 유사합니다. 이제 우리는 [이전 "
"장](./ch03-01-arrays.md)에서 소개한 `Array` 타입을 사용하여 이해를 더 확장해 나갈 것입니다."

#: src/ch04-01-what-is-ownership.md:67
msgid "Moving values - example with Array"
msgstr "값 이동 - 배열을 사용한 예제"

#: src/ch04-01-what-is-ownership.md:69
msgid ""
"As said earlier, _moving_ a value simply means passing that value to another"
" function. When that happens, the variable referring to that value in the "
"original scope is destroyed and can no longer be used, and a new variable is"
" created to hold the same value."
msgstr ""
"이전에 말했듯이, _이동_ 이란 단순히 그 값을 다른 함수로 전달하는 것을 의미합니다. 그렇게 되면 원래 범위에서 그 값을 가리키는 변수가"
" 파괴되어 더 이상 사용할 수 없게 되며, 동일한 값을 보유하기 위해 새 변수가 생성됩니다."

#: src/ch04-01-what-is-ownership.md:71
msgid ""
"Arrays are an example of a complex type that is moved when passing it to "
"another function. Here is a short reminder of what an array looks like:"
msgstr "배열은 다른 함수에 전달될 때 이동되는 복잡한 유형의 예입니다. 배열이 어떻게 생겼는지 간단히 상기시켜드리겠습니다:"

#: src/ch04-01-what-is-ownership.md:82
msgid ""
"How does the type system ensure that the Cairo program never tries to write "
"to the same memory cell twice? Consider the following code, where we try to "
"remove the front of the array twice:"
msgstr ""
"타입 시스템은 카이로 프로그램이 동일한 메모리 셀에 두 번 쓰려고 시도하지 않도록 어떻게 보장합니까? 다음 코드를 고려해보십시오. 여기서"
" 우리는 배열의 맨 앞을 두 번 제거하려고 시도합니다:"

#: src/ch04-01-what-is-ownership.md:97
msgid ""
"In this case, we try to pass the same value (the array in the `arr` "
"variable) to both function calls. This means our code tries to remove the "
"first element twice, which would try to write to the same memory cell twice "
"- which is forbidden by the Cairo VM, leading to a runtime error. "
"Thankfully, this code does not actually compile. Once we have passed the "
"array to the `foo` function, the variable `arr` is no longer usable. We get "
"this compile-time error, telling us that we would need Array to implement "
"the Copy Trait:"
msgstr ""
"이 경우에는 동일한 값을 (변수 `arr`에 있는 배열) 두 함수 호출에 모두 전달하려고 시도합니다. 이는 코드가 첫 번째 요소를 두 번"
" 제거하려고 시도하므로 동일한 메모리 셀에 두 번 쓰려고 하기 때문에 Cairo VM에서 금지된 런타임 오류가 발생할 것입니다. "
"다행히도, 이 코드는 실제로 컴파일되지 않습니다. 배열을 `foo` 함수에 전달한 후에는 변수 `arr`을 더 이상 사용할 수 없습니다."
" 우리는 Array가 Copy Trait을 구현해야 한다는 컴파일 시간 오류를 받게 됩니다."

#: src/ch04-01-what-is-ownership.md:107
msgid "The Copy trait"
msgstr "복사 특성"

#: src/ch04-01-what-is-ownership.md:109
msgid ""
"If a type implements the `Copy` trait, passing a value of that type to a "
"function does not move the value. Instead, a new variable is created, "
"referring to the same value. The important thing to note here is that this "
"is a completely free operation, because variables are a cairo abstraction "
"only and because _values_ in Cairo are always immutable. This, in "
"particular, conceptually differs from the Rust version of the `Copy` trait, "
"where the value is potentially copied in memory."
msgstr ""
"만약 타입이 `Copy` 트레이트를 구현한다면, 해당 타입의 값을 함수에 전달해도 값이 이동하지 않습니다. 대신, 동일한 값을 참조하는 "
"새 변수가 생성됩니다. 여기서 주목해야 할 중요한 점은 변수가 카이로 추상화일 뿐이며, 카이로의 값은 항상 불변이기 때문에 이것이 완전히"
" 무료 작업이라는 것입니다. 특히 이는 러스트 버전의 `Copy` 트레이트와 개념적으로 다르며, 러스트 버전에서는 값이 메모리에 복사될 "
"수 있습니다."

#: src/ch04-01-what-is-ownership.md:112
msgid ""
"All basic types previously described in [data types chapter](ch02-02-data-"
"types.md) implement by default the `Copy` trait."
msgstr ""
"이전에 설명된 [데이터 유형 장](ch02-02-data-types.md)에 있는 모든 기본 유형은 기본적으로 `Copy` 특성을 "
"구현합니다."

#: src/ch04-01-what-is-ownership.md:114
msgid ""
"While Arrays and Dictionaries can't be copied, custom types that don't "
"contain either of them can be. You can implement the `Copy` trait on your "
"type by adding the `#[derive(Copy)]` annotation to your type definition. "
"However, Cairo won't allow a type to be annotated with Copy if the type "
"itself or any of its components doesn't implement the Copy trait."
msgstr ""
"배열과 사전은 복사할 수 없지만, 둘 중 어느 하나도 포함하지 않는 사용자 정의 타입은 복사할 수 있습니다. 타입 정의에 "
"`#[derive(Copy)]` 주석을 추가하여 타입에 `Copy` 트레이트를 구현할 수 있습니다. 그러나 Cairo는 타입 자체나 그 "
"구성 요소 중 하나라도 `Copy` 트레이트를 구현하지 않은 경우에는 타입에 Copy 주석을 달 수 없습니다."

#: src/ch04-01-what-is-ownership.md:130
msgid "// do something with p\n"
msgstr "// p와 무언가를 수행합니다."

#: src/ch04-01-what-is-ownership.md:134
msgid ""
"In this example, we can pass `p1` twice to the foo function because the "
"`Point` type implements the `Copy` trait. This means that when we pass `p1` "
"to `foo`, we are actually passing a copy of `p1`, so `p1` remains valid. In "
"ownership terms, this means that the ownership of `p1` remains with the "
"`main` function. If you remove the `Copy` trait derivation from the `Point` "
"type, you will get a compile-time error when trying to compile the code."
msgstr ""
"이 예시에서 `Point` 타입이 `Copy` 트레이트를 구현했기 때문에 `p1`을 foo 함수에 두 번 전달할 수 있습니다. 이는 "
"`p1`을 `foo`에 전달할 때 사실은 `p1`의 복사본을 전달하므로 `p1`이 유효한 상태로 남아있게 됩니다. 소유권 관점에서 이는 "
"`p1`의 소유권이 `main` 함수에 남아있음을 의미합니다. 만약 `Point` 타입에서 `Copy` 트레이트를 제거하면 코드를 "
"컴파일하려고 할 때 컴파일 타임 에러가 발생합니다."

#: src/ch04-01-what-is-ownership.md:137
msgid ""
"_Don't worry about the `Struct` keyword. We will introduce this in [Chapter "
"5](ch05-00-using-structs-to-structure-related-data.md)._"
msgstr ""
"`Struct` 키워드에 대해 걱정하지 마십시오. 우리는 [5장](ch05-00-using-structs-to-structure-"
"related-data.md)에서 이에 대해 소개할 것입니다."

#: src/ch04-01-what-is-ownership.md:139
msgid "Destroying values - example with FeltDict"
msgstr "가치 파괴 - FeltDict를 사용한 예제"

#: src/ch04-01-what-is-ownership.md:141
msgid ""
"The other way linear types can be _used_ is by being destroyed. Destruction "
"must ensure that the 'resource' is now correctly released. In Rust for "
"example, this could be closing the access to a file, or locking a mutex. In "
"Cairo, one type that has such behaviour is `Felt252Dict`. For provability, "
"dicts must be 'squashed' when they are destructed. This would be very easy "
"to forget, so it is enforced by the type system and the compiler."
msgstr ""
"다른 방법으로 선형 유형을 _사용_ 할 수 있는 방법은 파괴되는 것입니다. 파괴는 이제 '자원'이 올바르게 해제되었음을 보장해야 합니다. "
"예를 들어 Rust에서는 파일에 대한 액세스를 닫거나 뮤텍스를 잠그는 것이 될 수 있습니다. Cairo에서 이와 같은 동작을 가진 하나의"
" 유형은 `Felt252Dict`입니다. 증명 가능성을 위해 딕셔너리는 파괴될 때 '압축'되어야 합니다. 이것은 매우 쉽게 잊을 수 있기"
" 때문에 유형 시스템과 컴파일러에서 강제됩니다."

#: src/ch04-01-what-is-ownership.md:145
msgid "No-op destruction: the `Drop` Trait"
msgstr "No-op 파괴: `Drop` 트레잇"

#: src/ch04-01-what-is-ownership.md:147
msgid ""
"You may have noticed that the `Point` type in the previous example also "
"implements the `Drop` trait. For example, the following code will not "
"compile, because the struct `A` is not moved or destroyed before it goes out"
" of scope:"
msgstr ""
"이전 예제에서 `Point` 타입도 `Drop` 트레이트를 구현했음을 알아차릴 수 있습니다. 예를 들어, 다음 코드는 컴파일되지 "
"않습니다. 왜냐하면 구조체 `A`가 스코프를 벗어나기 전에 이동되거나 파괴되지 않았기 때문입니다:"

#: src/ch04-01-what-is-ownership.md:154
msgid "// error: Value not dropped.\n"
msgstr "// 오류: 값이 삭제되지 않았습니다."

#: src/ch04-01-what-is-ownership.md:158
msgid ""
"However, types that implement the `Drop` trait are automatically destroyed "
"when going out of scope. This destruction does nothing, it is a no-op - "
"simply a hint to the compiler that this type can safely be destroyed once "
"it's no longer useful. We call this \"dropping\" a value."
msgstr ""
"그러나 `Drop` 트레이트를 구현하는 유형은 범위를 벗어날 때 자동으로 파괴됩니다. 이 파괴는 아무것도 하지 않으며, 컴파일러에게 이 "
"유형이 더 이상 유용하지 않을 때 안전하게 파괴될 수 있다는 힌트일 뿐입니다. 우리는 이를 \"값을 버리는\" 것이라고 부릅니다."

#: src/ch04-01-what-is-ownership.md:160
msgid ""
"At the moment, the `Drop` implementation can be derived for all types, "
"allowing them to be dropped when going out of scope, except for dictionaries"
" (`Felt252Dict`) and types containing dictionaries. For example, the "
"following code compiles:"
msgstr ""
"현재, `Drop` 구현은 모든 유형에 대해 파생될 수 있으며, 범위를 벗어날 때 삭제될 수 있도록 허용됩니다. 단, "
"사전(`Felt252Dict`) 및 사전을 포함하는 유형은 제외됩니다. 예를 들어, 다음 코드는 컴파일됩니다:"

#: src/ch04-01-what-is-ownership.md:168
msgid "// Now there is no error.\n"
msgstr "지금은 오류가 없습니다."

#: src/ch04-01-what-is-ownership.md:172
msgid "Destruction with a side-effect: the `Destruct` trait"
msgstr "파괴와 부작용: `Destruct` 특성"

#: src/ch04-01-what-is-ownership.md:174
msgid ""
"When a value is destroyed, the compiler first tries to call the `drop` "
"method on that type. If it doesn't exist, then the compiler tries to call "
"`destruct` instead. This method is provided by the `Destruct` trait."
msgstr ""
"값이 파괴될 때, 컴파일러는 먼저 해당 유형의 `drop` 메서드를 호출하려고 시도합니다. 그 메서드가 없는 경우 컴파일러는 대신 "
"`destruct`를 호출하려고 시도합니다. 이 메서드는 `Destruct` 트레이트에 의해 제공됩니다."

#: src/ch04-01-what-is-ownership.md:176
msgid ""
"As said earlier, dictionaries in Cairo are types that must be \"squashed\" "
"when destructed, so that the sequence of access can be proven. This is easy "
"for developers to forget, so instead dictionaries implement the `Destruct` "
"trait to ensure that all dictionaries are _squashed_ when going out of "
"scope. As such, the following example will not compile:"
msgstr ""
"이전에 말했듯이, 카이로의 사전은 파괴될 때 \"압축\"되어야 하는 유형이므로 액세스 순서를 증명할 수 있습니다. 개발자들이 이것을 잊기"
" 쉽기 때문에 사전은 대신 `Destruct` 특성을 구현하여 모든 사전이 범위를 벗어날 때 _압축_ 되도록 보장합니다. 따라서 다음 "
"예제는 컴파일되지 않습니다:"

#: src/ch04-01-what-is-ownership.md:189
msgid "If you try to run this code, you will get a compile-time error:"
msgstr "만약 이 코드를 실행하려고 하면 컴파일 시간 오류가 발생합니다."

#: src/ch04-01-what-is-ownership.md:198
msgid ""
"When `A` goes out of scope, it can't be dropped as it implements neither the"
" `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the "
"`Destruct` trait. To fix this, we can derive the `Destruct` trait "
"implementation for the `A` type:"
msgstr ""
"`A`가 스코프를 벗어나면, 딕셔너리를 포함하고 `derive(Drop)`을 할 수 없기 때문에 `Drop`도 구현되지 않은 "
"`Destruct` 트레이트를 구현할 수 없습니다. 이를 해결하기 위해 `A` 타입에 대한 `Destruct` 트레이트 구현을 파생할 수"
" 있습니다:"

#: src/ch04-01-what-is-ownership.md:207
msgid "// No error here\n"
msgstr "여기에 오류가 없습니다"

#: src/ch04-01-what-is-ownership.md:211
msgid ""
"Now, when `A` goes out of scope, its dictionary will be automatically "
"`squashed`, and the program will compile."
msgstr "이제 `A`가 범위를 벗어나면 해당 사전이 자동으로 `압축`되고 프로그램이 컴파일됩니다."

#: src/ch04-01-what-is-ownership.md:213
msgid "Copy Array data with Clone"
msgstr "배열 데이터를 복제하여 복사합니다."

#: src/ch04-01-what-is-ownership.md:215
msgid ""
"If we _do_ want to deeply copy the data of an `Array`, we can use a common "
"method called `clone`. We’ll discuss method syntax in [Chapter "
"5-3](ch05-03-method-syntax.md), but because methods are a common feature in "
"many programming languages, you’ve probably seen them before."
msgstr ""
"만약 우리가 `Array`의 데이터를 깊게 복사하고 싶다면, `clone`이라는 일반적인 메서드를 사용할 수 있습니다. 메서드 구문에 "
"대해는 [5-3장](ch05-03-method-syntax.md)에서 설명하겠지만, 메서드는 많은 프로그래밍 언어에서 흔한 기능이기 "
"때문에 이미 본 적이 있을 것입니다."

#: src/ch04-01-what-is-ownership.md:217
msgid "Here’s an example of the `clone` method in action."
msgstr "다음은 `clone` 메서드가 작동하는 예제입니다."

#: src/ch04-01-what-is-ownership.md:226
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on. In this case, the _value_ `arr1` refers to "
"is being copied, resulting in new memory cells being used, and a new "
"_variable_ `arr2` is created, referring to the new copied value."
msgstr ""
"`clone` 호출을 볼 때, 임의의 코드가 실행되고 그 코드가 비용이 많이 들 수 있다는 것을 알 수 있습니다. 이것은 무언가 다른 "
"일이 일어나고 있다는 시각적인 표시입니다. 이 경우, `_value_` `arr1`이 가리키는 것이 복사되어 새로운 메모리 셀이 "
"사용되고, 새로운 `_variable_` `arr2`가 생성되어 새로 복사된 값이 가리키게 됩니다."

#: src/ch04-01-what-is-ownership.md:229
msgid "Return Values and Scope"
msgstr "반환 값과 범위"

#: src/ch04-01-what-is-ownership.md:231
msgid ""
"Returning values is equivalent to _moving_ them. Listing 4-2 shows an "
"example of a function that returns some value, with similar annotations as "
"those in Listing 4-1."
msgstr ""
"값을 반환하는 것은 그 값을 _이동_ 하는 것과 동등합니다. 4-2 목록은 값이 반환되는 함수의 예제를 보여줍니다. 4-1 목록과 유사한 "
"주석이 달려 있습니다."

#: src/ch04-01-what-is-ownership.md:242
msgid ""
"// gives_ownership moves its return\n"
"                                          // value into a1\n"
msgstr "// gives_ownership는 반환 값을 a1로 이동합니다"

#: src/ch04-01-what-is-ownership.md:245
msgid "// a2 comes into scope\n"
msgstr "// a2가 범위에 들어옵니다"

#: src/ch04-01-what-is-ownership.md:247
msgid ""
"// a2 is moved into\n"
"                                          // takes_and_gives_back, which also\n"
"                                          // moves its return value into a3\n"
msgstr "// a2는 takes_and_gives_back으로 이동됩니다. 이 함수는 반환 값을 a3으로 이동시킵니다."

#: src/ch04-01-what-is-ownership.md:251
msgid ""
"// Here, a3 goes out of scope and is dropped. a2 was moved, so nothing\n"
"  // happens. a1 goes out of scope and is dropped.\n"
msgstr ""
"여기서 a3가 범위를 벗어나고 삭제됩니다. a2는 이동되었으므로 아무 일도 일어나지 않습니다. a1이 범위를 벗어나고 삭제됩니다."

#: src/ch04-01-what-is-ownership.md:254
msgid ""
"// gives_ownership will move its\n"
"                                          // return value into the function\n"
"                                          // that calls it\n"
msgstr ""
"// gives_ownership는\n"
"// 호출하는 함수로 반환 값을 이동시킵니다"

#: src/ch04-01-what-is-ownership.md:258 src/ch04-01-what-is-ownership.md:266
msgid "// some_a comes into scope\n"
msgstr "// some_a가 범위에 들어옵니다"

#: src/ch04-01-what-is-ownership.md:260
msgid ""
"// some_a is returned and\n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""
"// some_a가 반환되고\n"
"// 호출하는 함수로 소유권을 이동합니다"

#: src/ch04-01-what-is-ownership.md:264
msgid "// This function takes an instance some_a of A and returns it\n"
msgstr "이 함수는 A의 인스턴스 some_a를 가져와 반환합니다."

#: src/ch04-01-what-is-ownership.md:268
msgid ""
"// some_a is returned and \n"
"                                          // moves ownership to the calling\n"
"                                          // function\n"
msgstr ""
"// some_a가 반환되고\n"
"// 호출하는 함수로 소유권을 이전합니다"

#: src/ch04-01-what-is-ownership.md:274
msgid "Listing 4-2: Moving return values"
msgstr "리스트 4-2: 반환 값 이동하기"

#: src/ch04-01-what-is-ownership.md:276
msgid ""
"While this works, moving into and out of every function is a bit tedious. "
"What if we want to let a function use a value but not move the value? It’s "
"quite annoying that anything we pass in also needs to be passed back if we "
"want to use it again, in addition to any data resulting from the body of the"
" function that we might want to return as well."
msgstr ""
"이 작업은 작동하지만, 모든 함수로 이동하는 것은 약간 지루합니다. 함수가 값을 사용하되 값은 이동하지 않도록 하려면 어떻게 해야 "
"할까요? 우리가 전달하는 모든 것이 다시 사용하려면 반환해야 하는 것도 추가로 반환해야 하는 것이 귀찮습니다."

#: src/ch04-01-what-is-ownership.md:278
msgid ""
"Cairo does let us return multiple values using a tuple, as shown in Listing "
"4-3."
msgstr "카이로는 우리에게 튜플을 사용하여 여러 값을 반환할 수 있도록 해줍니다. 이는 4-3 목록에서 보여집니다."

#: src/ch04-01-what-is-ownership.md:290
msgid "// len() returns the length of an array\n"
msgstr "len()는 배열의 길이를 반환합니다."

#: src/ch04-01-what-is-ownership.md:296
msgid "Listing 4-3: Returning many values"
msgstr "리스트 4-3: 여러 값 반환하기"

#: src/ch04-01-what-is-ownership.md:298
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be"
" common. Luckily for us, Cairo has two features for passing a value without "
"destroying or moving it, called _references_ and _snapshots_."
msgstr ""
"그러나 이것은 너무 많은 의식과 많은 작업이 필요한데, 이는 보편적이어야 하는 개념에 대해 말이다. 다행히 카이로에는 값을 전달하면서 "
"파괴하거나 이동하지 않고 전달하는 두 가지 기능인 _참조_ 와 _스냅샷_ 이 있습니다."

#: src/ch04-02-references-and-snapshots.md:3
msgid ""
"The issue with the tuple code in previous Listing 4-3 is that we have to "
"return the `Array` to the calling function so we can still use the `Array` "
"after the call to `calculate_length`, because the `Array` was moved into "
"`calculate_length`."
msgstr ""
"이전 목록 4-3의 튜플 코드의 문제는 `calculate_length`를 호출한 후에도 `Array`를 계속 사용할 수 있도록 "
"`Array`를 호출 함수에 반환해야 한다는 것입니다. 왜냐하면 `Array`가 `calculate_length`로 이동되었기 "
"때문입니다."

#: src/ch04-02-references-and-snapshots.md:8
msgid "Snapshots"
msgstr "스냅샷"

#: src/ch04-02-references-and-snapshots.md:10
msgid ""
"In the previous chapter, we talked about how Cairo's ownership system "
"prevents us from using a variable after we've moved it, protecting us from "
"potentially writing twice to the same memory cell. However, it's not very "
"convenient. Let's see how we can retain ownership of the variable in the "
"calling function using snapshots."
msgstr ""
"이전 장에서는 카이로의 소유권 시스템이 변수를 이동한 후에 사용할 수 없게 하여 동일한 메모리 셀에 두 번 쓰는 것을 방지하는 방법에 "
"대해 이야기했습니다. 그러나 이것은 매우 편리하지 않습니다. 호출 함수에서 스냅샷을 사용하여 변수의 소유권을 유지하는 방법을 "
"살펴보겠습니다."

#: src/ch04-02-references-and-snapshots.md:15
msgid ""
"In Cairo, a snapshot is an immutable view of a value at a certain point in "
"time. Recall that memory is immutable, so modifying a value actually creates"
" a new memory cell. The old memory cell still exists, and snapshots are "
"variables that refer to that \"old\" value. In this sense, snapshots are a "
"view \"into the past\"."
msgstr ""
"카이로에서 스냅샷은 특정 시점의 값의 불변한 관찰입니다. 기억은 불변하기 때문에 값 수정은 사실 새로운 기억 셀을 만들어냅니다. 이전 "
"기억 셀은 여전히 존재하며, 스냅샷은 그 \"이전\" 값을 참조하는 변수입니다. 이런 의미에서 스냅샷은 \"과거로의 시각\"입니다."

#: src/ch04-02-references-and-snapshots.md:20
msgid ""
"Here is how you would define and use a `calculate_length` function that "
"takes a snapshot of an array as a parameter instead of taking ownership of "
"the underlying value. In this example, the `calculate_length` function "
"returns the length of the array passed as a parameter. As we're passing it "
"as a snapshot, which is an immutable view of the array, we can be sure that "
"the `calculate_length` function will not mutate the array, and ownership of "
"the array is kept in the `main` function."
msgstr ""
"다음은 배열의 스냅샷을 매개변수로 사용하여 소유권을 가져가지 않는 `calculate_length` 함수를 정의하고 사용하는 방법입니다."
" 이 예에서 `calculate_length` 함수는 매개변수로 전달된 배열의 길이를 반환합니다. 우리가 스냅샷으로 전달하고 있기 "
"때문에, 이는 배열의 불변 뷰이며 `calculate_length` 함수가 배열을 변경하지 않을 것이며, 배열의 소유권은 `main` "
"함수에 유지됩니다."

#: src/ch04-02-references-and-snapshots.md:31
msgid "// Take a snapshot of `arr1` at this point in time\n"
msgstr "`arr1`의 현재 상태를 스냅샷으로 찍어주세요."

#: src/ch04-02-references-and-snapshots.md:32
msgid "// Mutate `arr1` by appending a value\n"
msgstr "`arr1`에 값을 추가하여 변경하십시오."

#: src/ch04-02-references-and-snapshots.md:35
msgid "// Calculate the length of the array when the snapshot was taken\n"
msgstr "// 스냅샷이 찍힌 시점에서 배열의 길이를 계산합니다."

#: src/ch04-02-references-and-snapshots.md:36
#: src/ch04-02-references-and-snapshots.md:62
msgid "// Calculate the current length of the array\n"
msgstr "배열의 현재 길이를 계산하세요."

#: src/ch04-02-references-and-snapshots.md:37
msgid "\"The length of the array when the snapshot was taken is {}\""
msgstr "\"스냅샷이 찍힌 시점에서 배열의 길이는 {}입니다.\""

#: src/ch04-02-references-and-snapshots.md:38
msgid "\"The current length of the array is {}\""
msgstr "\"배열의 현재 길이는 {}입니다\""

#: src/ch04-02-references-and-snapshots.md:46
msgid ""
"Note: It is only possible to call the `len()` method on an array snapshot "
"because it is defined as such in the `ArrayTrait` trait. If you try to call "
"a method that is not defined for snapshots on a snapshot, you will get a "
"compilation error. However, you can call methods expecting a snapshot on "
"non-snapshot types."
msgstr ""
"참고: `len()` 메서드는 `ArrayTrait` 특성에서 그렇게 정의되어 있기 때문에 배열 스냅샷에서만 호출할 수 있습니다. "
"스냅샷에 정의되지 않은 메서드를 호출하려고 하면 컴파일 오류가 발생합니다. 그러나 스냅샷을 기대하는 메서드는 스냅샷이 아닌 유형에서 "
"호출할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:48
msgid "The output of this program is:"
msgstr "이 프로그램의 출력물은:"

#: src/ch04-02-references-and-snapshots.md:56
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `@arr1` into "
"`calculate_length` and, in its definition, we take `@Array<u128>` rather "
"than `Array<u128>`."
msgstr ""
"먼저, 변수 선언과 함수 반환 값에 있는 모든 튜플 코드가 사라진 것을 주목하세요. 둘째, `calculate_length`에 "
"`@arr1`을 전달하고, 그 정의에서 `Array<u128>` 대신 `@Array<u128>`을 사용한다는 점에 유의하세요."

#: src/ch04-02-references-and-snapshots.md:59
msgid "Let’s take a closer look at the function call here:"
msgstr "여기서 함수 호출을 좀 더 자세히 살펴보겠습니다."

#: src/ch04-02-references-and-snapshots.md:65
msgid ""
"The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because"
" a snapshot is an immutable view of a value at a specific point in time, the"
" usual rules of the linear type system are not enforced. In particular, "
"snapshot variables always implement the `Drop` trait, never the `Destruct` "
"trait, even dictionary snapshots."
msgstr ""
"`@arr1` 구문을 사용하면 `arr1`의 값에 대한 스냅샷을 만들 수 있습니다. 스냅샷은 특정 시점의 값에 대한 불변 뷰이므로 "
"일반적인 선형 타입 시스템의 규칙이 적용되지 않습니다. 특히, 스냅샷 변수는 항상 `Drop` 트레이트를 구현하며, `Destruct` "
"트레이트는 구현하지 않습니다. 딕셔너리 스냅샷도 마찬가지입니다."

#: src/ch04-02-references-and-snapshots.md:67
msgid ""
"Similarly, the signature of the function uses `@` to indicate that the type "
"of the parameter `arr` is a snapshot. Let’s add some explanatory "
"annotations:"
msgstr ""
"비슷하게, 함수의 시그니처는 `@`를 사용하여 매개변수 `arr`의 타입이 스냅샷임을 나타냅니다. 몇 가지 설명 주석을 추가해 봅시다:"

#: src/ch04-02-references-and-snapshots.md:71
msgid "// array_snapshot is a snapshot of an Array\n"
msgstr "array_snapshot은 Array의 스냅샷입니다."

#: src/ch04-02-references-and-snapshots.md:74
msgid ""
"// Here, array_snapshot goes out of scope and is dropped.\n"
"// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.\n"
msgstr ""
"여기서 array_snapshot이 범위를 벗어나고 삭제됩니다.\n"
"그러나 이는 원래 배열 'arr'이 포함하는 것의 뷰일 뿐이므로 원래 'arr'은 여전히 사용할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:78
msgid ""
"The scope in which the variable `array_snapshot` is valid is the same as any"
" function parameter’s scope, but the underlying value of the snapshot is not"
" dropped when `array_snapshot` stops being used. When functions have "
"snapshots as parameters instead of the actual values, we won’t need to "
"return the values in order to give back ownership of the original value, "
"because we never had it."
msgstr ""
"변수 'array_snapshot'이 유효한 범위는 모든 함수 매개변수의 범위와 동일하지만, 'array_snapshot'이 사용되지 "
"않을 때 스냅샷의 기본 값이 삭제되지 않습니다. 함수가 실제 값 대신 스냅샷을 매개변수로 사용할 때, 우리는 원래 값의 소유권을 반환하기"
" 위해 값을 반환할 필요가 없습니다. 왜냐하면 우리는 원래 값을 가지고 있지 않았기 때문입니다."

#: src/ch04-02-references-and-snapshots.md:80
msgid "Desnap Operator"
msgstr "데스냅 오퍼레이터"

#: src/ch04-02-references-and-snapshots.md:82
msgid ""
"To convert a snapshot back into a regular variable, you can use the `desnap`"
" operator `*`, which serves as the opposite of the `@` operator."
msgstr ""
"스냅샷을 일반 변수로 변환하려면, `desnap` 연산자 `*`를 사용할 수 있습니다. 이 연산자는 `@` 연산자의 반대 역할을 합니다."

#: src/ch04-02-references-and-snapshots.md:84
msgid ""
"Only `Copy` types can be desnapped. However, in the general case, because "
"the value is not modified, the new variable created by the `desnap` operator"
" reuses the old value, and so desnapping is a completely free operation, "
"just like `Copy`."
msgstr ""
"`Copy` 유형만 desnapped될 수 있습니다. 그러나 일반적인 경우에는 값이 수정되지 않기 때문에 `desnap` 연산자에 의해 "
"생성된 새 변수는 이전 값이 재사용되므로 desnapping은 완전히 무료한 작업으로, 마치 `Copy`와 같습니다."

#: src/ch04-02-references-and-snapshots.md:86
msgid ""
"In the following example, we want to calculate the area of a rectangle, but "
"we don't want to take ownership of the rectangle in the `calculate_area` "
"function, because we might want to use the rectangle again after the "
"function call. Since our function doesn't mutate the rectangle instance, we "
"can pass the snapshot of the rectangle to the function, and then transform "
"the snapshots back into values using the `desnap` operator `*`."
msgstr ""
"다음 예제에서는 직사각형의 면적을 계산하고 싶지만 `calculate_area` 함수에서 직사각형을 소유하고 싶지 않습니다. 왜냐하면 "
"함수 호출 후에도 직사각형을 다시 사용하고 싶을 수도 있기 때문입니다. 함수가 직사각형 인스턴스를 변경하지 않기 때문에 직사각형의 "
"스냅샷을 함수에 전달하고, 그런 다음 스냅샷을 값으로 변환하기 위해 `desnap` 연산자 `*`를 사용할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:98
msgid "\"Area: {}\""
msgstr "\"면적: {}\""

#: src/ch04-02-references-and-snapshots.md:102
msgid ""
"// As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.\n"
"    // We need to transform the snapshots back into values using the desnap operator `*`.\n"
"    // This is only possible if the type is copyable, which is the case for u64.\n"
"    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.\n"
msgstr ""
"// rec은 직사각형에 대한 스냅샷이므로, 그 필드들도 필드 유형의 스냅샷입니다.\n"
"// 우리는 desnap 연산자 `*`를 사용하여 스냅샷을 다시 값으로 변환해야 합니다.\n"
"// 이는 u64에 대해 복사 가능한 경우에만 가능합니다.\n"
"// 여기서 `*`는 높이와 너비를 곱하고 스냅샷을 다시 값으로 변환하는 데 사용됩니다."

#: src/ch04-02-references-and-snapshots.md:110
msgid ""
"But, what happens if we try to modify something we’re passing as a snapshot?"
" Try the code in Listing 4-4. Spoiler alert: it doesn’t work!"
msgstr ""
"그러나, 우리가 스냅샷으로 전달하는 것을 수정하려고 시도하면 어떻게 될까요? 4-4 목록의 코드를 시도해보세요. 스포일러 경고: 작동하지"
" 않습니다!"

#: src/ch04-02-references-and-snapshots.md:134
msgid "Listing 4-4: Attempting to modify a snapshot value"
msgstr "리스팅 4-4: 스냅샷 값을 수정하려는 시도"

#: src/ch04-02-references-and-snapshots.md:136
msgid "Here’s the error:"
msgstr "다음은 오류입니다:"

#: src/ch04-02-references-and-snapshots.md:145
msgid ""
"The compiler prevents us from modifying values associated to snapshots."
msgstr "컴파일러는 스냅샷에 연관된 값들을 수정하는 것을 방지합니다."

#: src/ch04-02-references-and-snapshots.md:147
msgid "Mutable References"
msgstr "가변 참조"

#: src/ch04-02-references-and-snapshots.md:149
msgid ""
"We can achieve the behavior we want in Listing 4-4 by using a _mutable "
"reference_ instead of a snapshot. Mutable references are actually mutable "
"values passed to a function that are implicitly returned at the end of the "
"function, returning ownership to the calling context. By doing so, they "
"allow you to mutate the value passed while keeping ownership of it by "
"returning it automatically at the end of the execution. In Cairo, a "
"parameter can be passed as _mutable reference_ using the `ref` modifier."
msgstr ""
"리스팅 4-4에서 원하는 동작을 얻을 수 있습니다. 스냅샷 대신 _가변 참조_ 를 사용함으로써. 가변 참조는 사실 함수에 전달된 가변 "
"값으로, 함수의 끝에서 암묵적으로 반환되어 호출 컨텍스트에 소유권을 반환합니다. 이렇게 함으로써, 실행의 끝에서 자동으로 반환함으로써 "
"전달된 값을 변경할 수 있으면서도 소유권을 유지할 수 있습니다. 카이로에서는 `ref` 수정자를 사용하여 매개변수를 _가변 참조_ 로 "
"전달할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:152
msgid ""
"**Note**: In Cairo, a parameter can only be passed as _mutable reference_ "
"using the `ref` modifier if the variable is declared as mutable with `mut`."
msgstr ""
"**참고**: 카이로에서는 변수가 `mut`로 선언되어야만 `ref` 수정자를 사용하여 _가변 참조_ 로 매개변수를 전달할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:154
msgid ""
"In Listing 4-5, we use a mutable reference to modify the value of the "
"`height` and `width` fields of the `Rectangle` instance in the `flip` "
"function."
msgstr ""
"리스팅 4-5에서는 `flip` 함수에서 `Rectangle` 인스턴스의 `height`와 `width` 필드의 값을 수정하기 위해 가변"
" 참조를 사용합니다."

#: src/ch04-02-references-and-snapshots.md:166
msgid "\"height: {}, width: {}\""
msgstr "\"높이: {}, 너비: {}\""

#: src/ch04-02-references-and-snapshots.md:176
msgid "Listing 4-5: Use of a mutable reference to modify a value"
msgstr "리스트 4-5: 가변 참조를 사용하여 값 수정하기"

#: src/ch04-02-references-and-snapshots.md:178
msgid ""
"First, we change `rec` to be `mut`. Then we pass a mutable reference of "
"`rec` into `flip` with `ref rec`, and update the function signature to "
"accept a mutable reference with `ref rec: Rectangle`. This makes it very "
"clear that the `flip` function will mutate the value of the `Rectangle` "
"instance passed as parameter."
msgstr ""
"먼저, 우리는 `rec`를 `mut`으로 변경합니다. 그런 다음 `flip`에 `ref rec`와 함께 `rec`의 가변 참조를 "
"전달하고, 함수 시그니처를 수정하여 가변 참조를 받도록 합니다. 이렇게 하면 `flip` 함수가 매개변수로 전달된 `Rectangle` "
"인스턴스의 값을 변경할 것임을 명확히 알 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:180
msgid "The output of the program is:"
msgstr "프로그램의 출력물은:"

#: src/ch04-02-references-and-snapshots.md:187
msgid ""
"As expected, the `height` and `width` fields of the `rec` variable have been"
" swapped."
msgstr "예상대로, `rec` 변수의 `height`와 `width` 필드가 교환되었습니다."

#: src/ch04-02-references-and-snapshots.md:189
msgid "Small recap"
msgstr "작은 요약"

#: src/ch04-02-references-and-snapshots.md:191
msgid ""
"Let’s recap what we’ve discussed about the linear type system, ownership, "
"snapshots, and references:"
msgstr "선형 유형 시스템, 소유권, 스냅샷 및 참조에 대해 논의한 내용을 다시 정리해 봅시다:"

#: src/ch04-02-references-and-snapshots.md:193
msgid "At any given time, a variable can only have one owner."
msgstr "어떤 시점에서도 변수는 하나의 소유자만 가질 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:194
msgid ""
"You can pass a variable by-value, by-snapshot, or by-reference to a "
"function."
msgstr "함수에 변수를 값으로, 스냅샷으로 또는 참조로 전달할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:195
msgid ""
"If you pass-by-value, ownership of the variable is transferred to the "
"function."
msgstr "만약 pass-by-value를 사용하면, 변수의 소유권이 함수로 이전됩니다."

#: src/ch04-02-references-and-snapshots.md:196
msgid ""
"If you want to keep ownership of the variable and know that your function "
"won’t mutate it, you can pass it as a snapshot with `@`."
msgstr "변수의 소유권을 유지하고 함수가 변형하지 않을 것을 알고 싶다면 `@`로 스냅샷으로 전달할 수 있습니다."

#: src/ch04-02-references-and-snapshots.md:197
msgid ""
"If you want to keep ownership of the variable and know that your function "
"will mutate it, you can pass it as a mutable reference with `ref`."
msgstr ""
"만약 변수의 소유권을 유지하고 함수가 해당 변수를 변경할 것임을 알고 싶다면, `ref`를 사용하여 가변 참조로 전달할 수 있습니다."

#: src/ch05-00-using-structs-to-structure-related-data.md:3
msgid ""
"A struct, or structure, is a custom data type that lets you package together"
" and name multiple related values that make up a meaningful group. If you’re"
" familiar with an object-oriented language, a struct is like an object’s "
"data attributes. In this chapter, we’ll compare and contrast tuples with "
"structs to build on what you already know and demonstrate when structs are a"
" better way to group data."
msgstr ""
"구조체는 사용자 정의 데이터 유형으로, 의미 있는 그룹을 구성하는 여러 관련 값을 함께 묶고 이름을 붙일 수 있게 해주는 것입니다. 객체"
" 지향 언어에 익숙하다면, 구조체는 객체의 데이터 속성과 유사합니다. 이 장에서는 이미 알고 있는 내용을 바탕으로 튜플과 구조체를 "
"비교하고 대조하여, 언제 구조체가 데이터를 그룹화하는 더 나은 방법인지를 보여줍니다."

#: src/ch05-00-using-structs-to-structure-related-data.md:5
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called methods, to specify behavior associated with a struct type. Structs "
"and enums (discussed in the [next chapter](ch06-01-enums.md)) are the "
"building blocks for creating new types in your program’s domain to take full"
" advantage of Cairo's compile-time type checking."
msgstr ""
"우리는 어떻게 구조체를 정의하고 인스턴스화하는지를 보여줄 것입니다. 특히 메서드라고 불리는 연관 함수를 정의하는 방법에 대해 논의할 "
"것입니다. 구조체와 열거형(다음 장에서 다룰 예정)은 Cairo의 컴파일 시간 타입 체크를 최대한 활용하기 위해 프로그램 도메인에서 "
"새로운 타입을 생성하는 데 사용되는 기본 요소입니다."

#: src/ch05-01-defining-and-instantiating-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in the [Data Types](ch02-02-data-"
"types.md) section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""
"구조체는 튜플과 유사하며, [데이터 유형](ch02-02-data-types.md) 섹션에서 설명된 것처럼 둘 다 여러 관련 값들을 "
"보유합니다. 튜플과 마찬가지로 구조체의 구성 요소는 다른 유형일 수 있습니다. 튜플과 달리 구조체에서는 각 데이터 조각에 이름을 지정하여"
" 값의 의미를 명확하게 합니다. 이러한 이름을 추가하면 구조체가 튜플보다 유연해지며, 데이터의 순서에 의존하지 않고 인스턴스의 값을 "
"지정하거나 액세스할 수 있습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:5
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call fields. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""
"구조체를 정의하려면 키워드 'struct'를 입력하고 전체 구조체의 이름을 지정합니다. 구조체의 이름은 함께 그룹화된 데이터 조각의 "
"중요성을 설명해야 합니다. 그런 다음 중괄호 안에서 데이터 조각의 이름과 유형을 정의합니다. 이를 필드라고 합니다. 예를 들어, "
"Listing 5-1은 사용자 계정 정보를 저장하는 구조체를 보여줍니다."

#: src/ch05-01-defining-and-instantiating-structs.md:19
msgid "Listing 5-1: A `User` struct definition"
msgstr "리스트 5-1: `User` 구조체 정의"

#: src/ch05-01-defining-and-instantiating-structs.md:21
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for"
" the type, and instances fill in that template with particular data to "
"create values of the type."
msgstr ""
"구조체를 정의한 후에 사용하려면, 각 필드에 구체적인 값을 지정하여 해당 구조체의 _인스턴스_ 를 생성합니다. 우리는 구조체의 이름을 "
"명시하고 그 다음에 _키: 값_ 쌍을 포함하는 중괄호를 추가하여 인스턴스를 생성합니다. 여기서 키는 필드의 이름이고 값은 해당 필드에 "
"저장하려는 데이터입니다. 우리는 구조체를 선언할 때 필드를 동일한 순서로 지정할 필요가 없습니다. 다시 말해, 구조체 정의는 해당 유형에"
" 대한 일반 템플릿과 같으며, 인스턴스는 해당 템플릿을 특정 데이터로 채워 해당 유형의 값을 생성합니다."

#: src/ch05-01-defining-and-instantiating-structs.md:24
msgid ""
"For example, we can declare two particular users as shown in Listing 5-2."
msgstr "예를 들어, 우리는 5-2 목록에 표시된 두 명의 특정 사용자를 선언할 수 있습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:47
msgid "Listing 5-2: Creating two instances of the `User` struct"
msgstr "리스트 5-2: `User` 구조체의 두 인스턴스 생성하기"

#: src/ch05-01-defining-and-instantiating-structs.md:49
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access `user1`'s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email`"
" field of a mutable `User` instance."
msgstr ""
"구조체에서 특정 값을 가져오려면 점 표기법을 사용합니다. 예를 들어 `user1`의 이메일 주소에 접근하려면 `user1.email`을 "
"사용합니다. 인스턴스가 가변적인 경우, 특정 필드에 값을 할당하여 값을 변경할 수 있습니다. 5-3 목록은 가변적인 `User` "
"인스턴스의 `email` 필드의 값을 변경하는 방법을 보여줍니다."

#: src/ch05-01-defining-and-instantiating-structs.md:79
msgid ""
"Listing 5-3: Changing the value in the email field of a `User` instance"
msgstr "리스팅 5-3: `User` 인스턴스의 이메일 필드 값 변경하기"

#: src/ch05-01-defining-and-instantiating-structs.md:81
msgid ""
"Note that the entire instance must be mutable; Cairo doesn’t allow us to "
"mark only certain fields as mutable."
msgstr "전체 인스턴스가 가변해야 한다는 점을 유의하세요. 카이로는 특정 필드만을 가변으로 표시할 수 없습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:83
msgid ""
"As with any expression, we can construct a new instance of the struct as the"
" last expression in the function body to implicitly return that new "
"instance."
msgstr ""
"모든 표현과 마찬가지로, 우리는 새로운 구조체의 인스턴스를 함수 본문의 마지막 표현식으로 구성하여 해당 새 인스턴스를 암시적으로 반환할 "
"수 있습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:85
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""
"5-4 목록은 주어진 이메일과 사용자 이름을 가진 `User` 인스턴스를 반환하는 `build_user` 함수를 보여줍니다. "
"`active` 필드는 `true`의 값을 받고, `sign_in_count`는 `1`의 값을 받습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:115
msgid ""
"Listing 5-4: A `build_user` function that takes an email and username and "
"returns a `User` instance"
msgstr "리스팅 5-4: 이메일과 사용자 이름을 가져와 `User` 인스턴스를 반환하는 `build_user` 함수"

#: src/ch05-01-defining-and-instantiating-structs.md:117
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""
"함수 매개변수를 구조체 필드와 동일한 이름으로 지정하는 것은 이치에 맞지만, `email`과 `username` 필드 이름과 변수를 "
"반복해야 하는 것은 약간 지루합니다. 구조체에 더 많은 필드가 있다면, 각 이름을 반복하는 것이 더 귀찮아질 것입니다. 다행히도 편리한 "
"축약형이 있습니다!"

#: src/ch05-01-defining-and-instantiating-structs.md:119
msgid "Using the Field Init Shorthand"
msgstr "필드 이닛 축약법 사용하기"

#: src/ch05-01-defining-and-instantiating-structs.md:121
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the field init shorthand syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""
"리스팅 5-4에서 매개변수 이름과 구조체 필드 이름이 정확히 같기 때문에, 우리는 필드 초기화 축약 구문을 사용하여 "
"`build_user`를 다시 작성할 수 있습니다. 이렇게 하면 `username`과 `email`의 반복을 없앨 수 있지만 동일하게 "
"작동합니다. 이는 리스팅 5-5에 나와 있습니다."

#: src/ch05-01-defining-and-instantiating-structs.md:151
msgid ""
"Listing 5-5: A `build_user` function that uses field init shorthand because "
"the `username` and `email` parameters have the same name as struct fields"
msgstr ""
"리스트 5-5: `username` 및 `email` 매개변수가 구조체 필드와 동일한 이름을 가지고 있기 때문에 필드 초기화 단축 구문을"
" 사용하는 `build_user` 함수"

#: src/ch05-01-defining-and-instantiating-structs.md:153
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""
"여기서는 `User` 구조체의 새 인스턴스를 생성하고 있습니다. 이 구조체는 `email`이라는 필드를 가지고 있습니다. 우리는 "
"`email` 필드의 값을 `build_user` 함수의 `email` 매개변수의 값으로 설정하고 싶습니다. `email` 필드와 "
"`email` 매개변수가 같은 이름을 가지고 있기 때문에 `email: email` 대신에 `email`만 작성하면 됩니다."

#: src/ch05-02-an-example-program-using-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""
"우리가 구조체를 사용하고 싶을 때를 이해하기 위해, 직사각형의 면적을 계산하는 프로그램을 작성해 봅시다. 우리는 먼저 단일 변수를 "
"사용하여 시작하고, 그런 다음 구조체를 사용하도록 프로그램을 리팩터링할 것입니다."

#: src/ch05-02-an-example-program-using-structs.md:5
msgid ""
"Let’s make a new project with Scarb called _rectangles_ that will take the "
"width and height of a rectangle specified in pixels and calculate the area "
"of the rectangle. Listing 5-6 shows a short program with one way of doing "
"exactly that in our project’s _src/lib.cairo_."
msgstr ""
"Scarb와 함께 _rectangles_ 라는 새 프로젝트를 만들어 보겠습니다. 이 프로젝트는 픽셀로 지정된 직사각형의 너비와 높이를 "
"가져와 직사각형의 면적을 계산할 것입니다. 5-6 목록은 프로젝트의 _src/lib.cairo_ 에서 정확히 그 작업을 수행하는 한 가지 "
"방법을 보여줍니다."

#: src/ch05-02-an-example-program-using-structs.md:15
#: src/ch05-02-an-example-program-using-structs.md:53
#: src/ch05-02-an-example-program-using-structs.md:83
#: src/ch05-03-method-syntax.md:40
msgid "\"Area is {}\""
msgstr "\"면적은 {}입니다\""

#: src/ch05-02-an-example-program-using-structs.md:23
msgid ""
"Listing 5-6: Calculating the area of a rectangle specified by separate width"
" and height variables"
msgstr "리스팅 5-6: 별도의 너비와 높이 변수로 지정된 직사각형의 면적 계산"

#: src/ch05-02-an-example-program-using-structs.md:25
msgid "Now run the program with `scarb cairo-run`:"
msgstr "지금 `scarb cairo-run`으로 프로그램을 실행하세요."

#: src/ch05-02-an-example-program-using-structs.md:33
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""
"이 코드는 각 차원을 사용하여 `area` 함수를 호출하여 직사각형의 면적을 계산하는 데 성공합니다. 그러나 이 코드를 더 명확하고 "
"가독성 있게 만들 수 있습니다."

#: src/ch05-02-an-example-program-using-structs.md:35
msgid "The issue with this code is evident in the signature of `area`:"
msgstr "이 코드의 문제는 `area`의 시그니처에서 명확하게 나타납니다."

#: src/ch05-02-an-example-program-using-structs.md:41
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our"
" program that the parameters are related. It would be more readable and more"
" manageable to group width and height together. We’ve already discussed one "
"way we might do that in the [tuple section of Chapter 2](ch02-02-data-"
"types.html#the-tuple-type)."
msgstr ""
"`area` 함수는 하나의 직사각형의 넓이를 계산해야하지만, 우리가 작성한 함수는 두 개의 매개변수를 가지고 있으며, 우리 프로그램 "
"어디에서도 이 매개변수들이 관련되어 있다는 것이 명확하지 않습니다. 너비와 높이를 함께 그룹화하는 것이 더 읽기 쉽고 관리하기 쉬울 "
"것입니다. 이미 [2장 튜플 섹션](ch02-02-data-types.html#the-tuple-type)에서 그것을 어떻게 할 수 "
"있는지에 대해 논의했습니다."

#: src/ch05-02-an-example-program-using-structs.md:43
msgid "Refactoring with Tuples"
msgstr "튜플을 사용한 리팩터링"

#: src/ch05-02-an-example-program-using-structs.md:45
msgid "Listing 5-7 shows another version of our program that uses tuples."
msgstr "5-7 목록은 튜플을 사용하는 우리 프로그램의 다른 버전을 보여줍니다."

#: src/ch05-02-an-example-program-using-structs.md:62
msgid ""
"Listing 5-7: Specifying the width and height of the rectangle with a tuple"
msgstr "리스트 5-7: 튜플을 사용하여 직사각형의 너비와 높이 지정하기"

#: src/ch05-02-an-example-program-using-structs.md:64
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is"
" less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""
"한 가지 측면에서 이 프로그램은 더 나아졌습니다. 튜플을 사용하면 약간의 구조를 추가할 수 있고, 이제는 하나의 인수만 전달하고 "
"있습니다. 그러나 다른 한 측면에서는 이 버전이 덜 명확합니다: 튜플은 요소에 이름을 지정하지 않으므로 튜플의 부분에 색인을 사용해야 "
"하며, 이로 인해 계산이 덜 명확해집니다."

#: src/ch05-02-an-example-program-using-structs.md:66
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but"
" if we want to calculate the difference, it would matter! We would have to "
"keep in mind that `width` is the tuple index `0` and `height` is the tuple "
"index `1`. This would be even harder for someone else to figure out and keep"
" in mind if they were to use our code. Because we haven’t conveyed the "
"meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""
"너비와 높이를 혼동해도 면적 계산에는 상관이 없지만, 차이를 계산하려면 상관이 있습니다! '너비'가 튜플 인덱스 '0'이고 '높이'가 "
"튜플 인덱스 '1'임을 염두에 두어야 합니다. 우리의 코드를 사용하는 다른 사람이 이를 이해하고 기억하는 것은 더 어려울 것입니다. "
"우리의 코드에서 데이터의 의미를 전달하지 않았기 때문에 이제 오류를 도입하기가 더 쉬워졌습니다."

#: src/ch05-02-an-example-program-using-structs.md:68
msgid "Refactoring with Structs: Adding More Meaning"
msgstr "구조체를 사용한 리팩터링: 더 많은 의미 추가하기"

#: src/ch05-02-an-example-program-using-structs.md:70
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts."
msgstr ""
"우리는 데이터에 레이블을 붙여 의미를 추가하기 위해 구조체를 사용합니다. 우리는 사용 중인 튜플을 전체를 위한 이름과 각 부분을 위한 "
"이름을 가진 구조체로 변환할 수 있습니다."

#: src/ch05-02-an-example-program-using-structs.md:91
msgid "Listing 5-8: Defining a `Rectangle` struct"
msgstr "리스트 5-8: `Rectangle` 구조체 정의하기"

#: src/ch05-02-an-example-program-using-structs.md:93
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u64`. Then, in `main`, we created a particular instance of `Rectangle`"
" that has a width of `30` and a height of `10`. Our `area` function is now "
"defined with one parameter, which we’ve named `rectangle` which is of type "
"`Rectangle` struct. We can then access the fields of the instance with dot "
"notation, and it gives descriptive names to the values rather than using the"
" tuple index values of `0` and `1`."
msgstr ""
"여기서는 구조체를 정의하고 `Rectangle`이라고 이름 지었습니다. 중괄호 안에서 `width`와 `height` 필드를 정의했는데,"
" 둘 다 `u64` 타입입니다. 그런 다음 `main`에서 `Rectangle`의 특정 인스턴스를 만들었는데, 너비가 `30`이고 높이가"
" `10`입니다. 이제 `area` 함수는 하나의 매개변수로 정의되었는데, 우리는 그것을 `Rectangle` 구조체 타입인 "
"`rectangle`로 지정했습니다. 그런 다음 인스턴스의 필드에 점 표기법(dot notation)을 사용하여 액세스할 수 있으며, "
"튜플 인덱스 값인 `0`과 `1` 대신 값에 설명적인 이름을 부여합니다."

#: src/ch05-02-an-example-program-using-structs.md:95
msgid "Adding Useful Functionality with Trait"
msgstr "Trait을 사용하여 유용한 기능 추가하기"

#: src/ch05-02-an-example-program-using-structs.md:97
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-9 "
"tries to print `rectangle` using the `print` function. This won’t work."
msgstr ""
"프로그램을 디버깅하는 동안 `Rectangle`의 인스턴스를 인쇄하고 모든 필드의 값을 볼 수 있다면 유용할 것입니다. 5-9 목록은 "
"`print` 함수를 사용하여 `rectangle`을 인쇄하려고 시도합니다. 이것은 작동하지 않습니다."

#: src/ch05-02-an-example-program-using-structs.md:118
msgid "Listing 5-9: Attempting to print a `Rectangle` instance"
msgstr "리스트 5-9: `Rectangle` 인스턴스를 출력하려는 시도"

#: src/ch05-02-an-example-program-using-structs.md:120
msgid "When we compile this code, we get an error with this message:"
msgstr "이 코드를 컴파일하면 이 메시지와 함께 오류가 발생합니다:"

#: src/ch05-02-an-example-program-using-structs.md:133
msgid ""
"The `PrintTrait` trait is implemented for many data types, but not for the "
"`Rectangle` struct. We can fix this by implementing the `PrintTrait` trait "
"on `Rectangle` as shown in Listing 5-10. To learn more about traits, see "
"[Traits in Cairo](ch08-02-traits-in-cairo.md)."
msgstr ""
"`PrintTrait` 트레이트는 많은 데이터 유형에 대해 구현되어 있지만 `Rectangle` 구조체에 대해서는 구현되어 있지 "
"않습니다. 우리는 Listing 5-10에 표시된 대로 `Rectangle`에 `PrintTrait` 트레이트를 구현함으로써 이를 해결할"
" 수 있습니다. 트레이트에 대해 더 알아보려면 [Traits in Cairo](ch08-02-traits-in-cairo.md)를 "
"참조하십시오."

#: src/ch05-02-an-example-program-using-structs.md:161
msgid "Listing 5-10: Implementing the `PrintTrait` trait on Rectangle"
msgstr "리스트 5-10: 직사각형에 `PrintTrait` 트레이트 구현하기"

#: src/ch05-02-an-example-program-using-structs.md:163
msgid "When we run the `main` function, we get the following output:"
msgstr "`main` 함수를 실행하면 다음과 같은 출력이 나옵니다."

#: src/ch05-02-an-example-program-using-structs.md:168
msgid ""
"'\n"
"'"
msgstr ""
"I'm sorry, but it seems like you haven't provided any text for me to "
"translate. Please provide the English text you would like me to translate to"
" Korean."

#: src/ch05-02-an-example-program-using-structs.md:173
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging."
msgstr "좋아요! 가장 예쁘지는 않지만, 이 인스턴스의 모든 필드 값들을 보여주기 때문에 디버깅하는 동안 도움이 될 것입니다."

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a type and their first "
"parameter is always `self`, which represents the instance of the type the "
"method is being called on. For those familiar with Rust, Cairo's approach "
"might be confusing, as methods cannot be defined directly on types. Instead,"
" you must define a [trait](./ch08-02-traits-in-cairo.md) and an "
"implementation associated with the type for which the method is intended."
msgstr ""
"_메소드(Methods)_ 는 함수와 유사합니다: `fn` 키워드와 이름으로 선언하며, 매개변수와 반환 값이 있을 수 있으며, 메소드가 "
"다른 곳에서 호출될 때 실행되는 코드가 포함되어 있습니다. 함수와 달리 메소드는 타입의 문맥 내에서 정의되며, 첫 번째 매개변수는 항상 "
"`self`이며, 이는 메소드가 호출되는 타입의 인스턴스를 나타냅니다. Rust에 익숙한 사람들에게는 Cairo의 접근 방식이 혼란스러울"
" 수 있습니다. 메소드를 타입에 직접 정의할 수 없습니다. 대신, [trait](./ch08-02-traits-in-cairo.md)를 "
"정의하고, 메소드가 의도된 타입과 관련된 구현을 해야 합니다."

#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr "메소드 정의"

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `RectangleTrait` "
"trait, as shown in Listing 5-11."
msgstr ""
"`area` 함수를 변경하여 `Rectangle` 인스턴스를 매개변수로 사용하는 대신, `RectangleTrait` 트레이트에 정의된 "
"`area` 메서드로 만들어봅시다. (리스팅 5-11 참조)"

#: src/ch05-03-method-syntax.md:44
msgid "Listing 5-11: Defining an `area` method to use on the `Rectangle` "
msgstr "리스팅 5-11: `Rectangle`에서 사용할 `area` 메소드 정의하기"

#: src/ch05-03-method-syntax.md:47
msgid ""
"To define the function within the context of `Rectangle`, we start by "
"defining a `trait` block with the signature of the method that we want to "
"implement. Traits are not linked to a specific type; only the `self` "
"parameter of the method defines which type it can be used with. Then, we "
"define an `impl` (implementation) block for `RectangleTrait`, that defines "
"the behavior of the methods implemented. Everything within this `impl` block"
" will be associated with the type of the `self` parameter of the method "
"called. While it is technically possible to define methods for multiple "
"types within the same `impl` block, it is not a recommended practice, as it "
"can lead to confusion. We recommend that the type of the `self` parameter "
"stays consistent within the same `impl` block. Then we move the `area` "
"function within the `impl` curly brackets and change the first (and in this "
"case, only) parameter to be `self` in the signature and everywhere within "
"the body. In `main`, where we called the `area` function and passed `rect1` "
"as an argument, we can instead use the _method syntax_ to call the `area` "
"method on our `Rectangle` instance. The method syntax goes after an "
"instance: we add a dot followed by the method name, parentheses, and any "
"arguments."
msgstr ""
"'Rectangle'의 맥락 내에서 함수를 정의하기 위해, 우리는 구현하고자 하는 메소드의 서명을 가진 'trait' 블록을 정의하는 "
"것으로 시작합니다. Traits는 특정 유형에 연결되지 않으며, 메소드의 'self' 매개변수만이 어떤 유형과 함께 사용될 수 있는지를 "
"정의합니다. 그런 다음, 'RectangleTrait'에 대한 'impl' (구현) 블록을 정의하여 구현된 메소드의 동작을 정의합니다. "
"이 'impl' 블록 내의 모든 것은 호출된 메소드의 'self' 매개변수의 유형과 관련이 있습니다. 동일한 'impl' 블록 내에서 "
"여러 유형에 대한 메소드를 정의하는 것은 기술적으로 가능하지만 혼란을 초래할 수 있으므로 권장되지 않습니다. 'self' 매개변수의 "
"유형이 동일하도록 유지하는 것이 좋습니다. 그런 다음, 'area' 함수를 'impl' 중괄호 내로 이동하고 서명에서 첫 번째 (이 "
"경우에는 유일한) 매개변수를 'self'로 변경하고 본문 내에서 모두 변경합니다. 'main'에서 'area' 함수를 호출하고 "
"'rect1'을 인수로 전달한 곳에서, 대신 _메소드 구문_ 을 사용하여 'Rectangle' 인스턴스에서 'area' 메소드를 호출할 수"
" 있습니다. 메소드 구문은 인스턴스 뒤에 옵니다: 점을 추가한 다음 메소드 이름, 괄호 및 모든 인수를 추가합니다."

#: src/ch05-03-method-syntax.md:65
msgid ""
"Methods must have a parameter named `self` of the type they will be applied "
"to for their first parameter. Note that we used the `@` snapshot operator in"
" front of the `Rectangle` type in the function signature. By doing so, we "
"indicate that this method takes an immutable snapshot of the `Rectangle` "
"instance, which is automatically created by the compiler when passing the "
"instance to the method. Methods can take ownership of `self`, use `self` "
"with snapshots as we’ve done here, or use a mutable reference to `self` "
"using the `ref self: T` syntax."
msgstr ""
"메서드는 적용될 유형의 첫 번째 매개변수로 `self`라는 매개변수를 가져야 합니다. 함수 시그니처에서 `Rectangle` 유형 앞에 "
"`@` 스냅샷 연산자를 사용했다는 점에 유의하십시오. 이렇게 함으로써 이 메서드가 `Rectangle` 인스턴스의 불변 스냅샷을 취하는 "
"것을 나타냅니다. 이 스냅샷은 인스턴스를 메서드에 전달할 때 컴파일러가 자동으로 생성합니다. 메서드는 `self`의 소유권을 가져갈 수 "
"있으며, 여기서처럼 스냅샷을 사용할 수 있거나 `ref self: T` 구문을 사용하여 `self`에 대한 가변 참조를 사용할 수 "
"있습니다."

#: src/ch05-03-method-syntax.md:73
msgid ""
"We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in"
" the function version: we don’t want to take ownership, and we just want to "
"read the data in the struct, not write to it. If we wanted to change the "
"instance that we’ve called the method on as part of what the method does, "
"we’d use `ref self: Rectangle` as the first parameter. Having a method that "
"takes ownership of the instance by using just `self` as the first parameter "
"is rare; this technique is usually used when the method transforms `self` "
"into something else and you want to prevent the caller from using the "
"original instance after the transformation."
msgstr ""
"우리는 여기서 `self: @Rectangle`를 선택한 이유가 함수 버전에서 `@Rectangle`을 사용한 이유와 같습니다. 우리는 "
"소유권을 가져가고 싶지 않고, 구조체의 데이터를 읽기만 하고 쓰기를 하고 싶지 않기 때문입니다. 만약 메서드가 호출된 인스턴스를 변경하고"
" 싶다면, 메서드의 첫 번째 매개변수로 `ref self: Rectangle`를 사용할 것입니다. 인스턴스의 소유권을 가져가는 메서드를 "
"가지고 있는 것은 드물지만, 이 기술은 일반적으로 메서드가 `self`을 다른 것으로 변환하고 변환 후에 원래 인스턴스를 사용하지 "
"못하도록 하려는 경우에 사용됩니다."

#: src/ch05-03-method-syntax.md:82
msgid ""
"Observe the use of the desnap operator `*` within the area method when "
"accessing the struct's members. This is necessary because the struct is "
"passed as a snapshot, and all of its field values are of type `@T`, "
"requiring them to be desnapped in order to manipulate them."
msgstr ""
"구조체의 멤버에 액세스할 때 area 메서드 내에서 desnap 연산자 `*`의 사용을 관찰하세요. 이는 구조체가 스냅샷으로 전달되고 그"
" 모든 필드 값이 `@T` 유형이기 때문에 조작하기 위해 desnap되어야 하기 때문에 필요합니다."

#: src/ch05-03-method-syntax.md:87
msgid ""
"The main reason for using methods instead of functions is for organization "
"and code clarity. We’ve put all the things we can do with an instance of a "
"type in one combination of `trait` & `impl` blocks, rather than making "
"future users of our code search for capabilities of `Rectangle` in various "
"places in the library we provide. However, we can define multiple "
"combinations of `trait` & `impl` blocks for the same type at different "
"places, which can be useful for a more granular code organization. For "
"example, you could implement the `Add` trait for your type in one `impl` "
"block, and the `Sub` trait in another block."
msgstr ""
"메서드를 사용하는 주요 이유는 조직화와 코드 가독성 때문입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 `trait` 및"
" `impl` 블록 조합에 넣어 코드 라이브러리의 다양한 위치에서 `Rectangle`의 기능을 찾아야 하는 미래 사용자들을 방지합니다."
" 그러나 동일한 타입에 대해 서로 다른 위치에서 여러 `trait` 및 `impl` 블록 조합을 정의할 수 있으며, 이는 더 세분화된 "
"코드 조직에 유용할 수 있습니다. 예를 들어, 한 `impl` 블록에서 타입에 대한 `Add` trait를 구현하고, 다른 블록에서 "
"`Sub` trait를 구현할 수 있습니다."

#: src/ch05-03-method-syntax.md:96
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr ""
"주의할 점은 메서드에 구조체의 필드와 동일한 이름을 지정할 수 있다는 것입니다."
"예를 들어, `Rectangle`에도 `width`라는 이름의 메서드를 정의할 수 있습니다."

#: src/ch05-03-method-syntax.md:121
msgid "\"Width is {}\""
msgstr "\"폭은 {}입니다\""

#: src/ch05-03-method-syntax.md:125
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0`, and `false` if the "
"value is `0`: we can use a field within a method of the same name for any "
"purpose. In `main`, when we follow `rect1.width` with parentheses, Cairo "
"knows we mean the method `width`. When we don’t use parentheses, Cairo knows"
" we mean the field `width`."
msgstr ""
"여기서는 `width` 메소드가 인스턴스의 `width` 필드 값이 `0`보다 크면 `true`를 반환하고, 값이 `0`이면 "
"`false`를 반환하도록 선택했습니다: 우리는 동일한 이름의 메소드 내에서 필드를 사용할 수 있습니다. `main`에서 "
"`rect1.width` 뒤에 괄호를 사용하면, Cairo는 우리가 `width` 메소드를 의미한다는 것을 알 수 있습니다. 괄호를 "
"사용하지 않으면, Cairo는 `width` 필드를 의미한다는 것을 알 수 있습니다."

#: src/ch05-03-method-syntax.md:132
msgid "Methods with More Parameters"
msgstr "더 많은 매개변수를 가진 방법들"

#: src/ch05-03-method-syntax.md:134
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we"
" want to be able to write the program shown in Listing 5-12."
msgstr ""
"`Rectangle` 구조체에 두 번째 메소드를 구현하여 메소드 사용을 연습해 봅시다. 이번에는 `Rectangle`의 인스턴스가 다른 "
"`Rectangle`의 인스턴스를 받아서 두 번째 `Rectangle`이 `self` (첫 번째 `Rectangle`) 안에 완전히 "
"들어갈 수 있는지 여부를 반환하는 메소드를 만들고 싶습니다. 즉, `can_hold` 메소드를 정의한 후에는 Listing 5-12에 "
"표시된 프로그램을 작성할 수 있기를 원합니다."

#: src/ch05-03-method-syntax.md:156
msgid "\"Can rect1 hold rect2? {}\""
msgstr "\"rect1이 rect2를 보유할 수 있습니까? {}\""

#: src/ch05-03-method-syntax.md:157
msgid "\"Can rect1 hold rect3? {}\""
msgstr "\"rect1이 rect3을 보유할 수 있습니까? {}\""

#: src/ch05-03-method-syntax.md:161
msgid "Listing 5-12: Using the as-yet-unwritten `can_hold` method"
msgstr "리스트 5-12: 아직 작성되지 않은 `can_hold` 메서드 사용하기"

#: src/ch05-03-method-syntax.md:164
msgid ""
"The expected output would look like the following because both dimensions of"
" `rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr ""
"`rect2`의 두 차원이 `rect1`의 차원보다 작지만, `rect3`는 `rect1`보다 넓기 때문에 예상 출력은 다음과 같이 보일"
" 것입니다:"

#: src/ch05-03-method-syntax.md:176
msgid ""
"We know we want to define a method, so it will be within the `trait "
"RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The "
"method name will be `can_hold`, and it will take a snapshot of another "
"`Rectangle` as a parameter. We can tell what the type of the parameter will "
"be by looking at the code that calls the method: `rect1.can_hold(@rect2)` "
"passes in `@rect2`, which is a snapshot to `rect2`, an instance of "
"`Rectangle`. This makes sense because we only need to read `rect2` (rather "
"than write, which would mean we’d need a mutable borrow), and we want `main`"
" to retain ownership of `rect2` so we can use it again after calling the "
"`can_hold` method. The return value of `can_hold` will be a Boolean, and the"
" implementation will check whether the width and height of `self` are "
"greater than the width and height of the other `Rectangle`, respectively. "
"Let’s add the new `can_hold` method to the `trait` and `impl` blocks from "
"Listing 5-11, shown in Listing 5-13."
msgstr ""
"우리는 메소드를 정의하고 싶다는 것을 알고 있으므로, `trait RectangleTrait`와 `impl RectangleTrait의 "
"RectangleImpl` 블록 내에 있을 것입니다. 메소드 이름은 `can_hold`이고, 다른 `Rectangle`의 스냅샷을 "
"매개변수로 사용할 것입니다. 메소드를 호출하는 코드를 보면 매개변수의 타입을 알 수 있습니다: "
"`rect1.can_hold(@rect2)`는 `@rect2`를 전달하는데, 이는 `Rectangle`의 인스턴스인 `rect2`에 대한"
" 스냅샷입니다. 이는 `rect2`를 읽기만 하면 되기 때문에 (쓰기가 아닌 경우, 변경 가능한 빌림이 필요할 것입니다), `main`이"
" `can_hold` 메소드를 호출한 후에도 `rect2`의 소유권을 유지하고 싶기 때문입니다. `can_hold`의 반환 값은 부울 "
"값이며, 구현은 `self`의 너비와 높이가 다른 `Rectangle`의 너비와 높이보다 큰지 확인할 것입니다. 새로운 "
"`can_hold` 메소드를 Listing 5-11의 `trait`와 `impl` 블록에 추가해봅시다. (Listing 5-13에 "
"표시됨)"

#: src/ch05-03-method-syntax.md:209
msgid ""
"Listing 5-13: Implementing the `can_hold` method on `Rectangle` that takes "
"another `Rectangle` instance as a parameter"
msgstr ""
"리스팅 5-13: 다른 `Rectangle` 인스턴스를 매개변수로 사용하는 `Rectangle`의 `can_hold` 메서드 구현"

#: src/ch05-03-method-syntax.md:212
msgid ""
"When we run this code with the `main` function in Listing 5-12, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr ""
"이 코드를 Listing 5-12의 `main` 함수와 함께 실행하면 원하는 출력을 얻을 수 있습니다. 메소드는 `self` 매개변수 "
"뒤에 시그니처에 추가하는 여러 매개변수를 사용할 수 있으며, 이러한 매개변수는 함수의 매개변수와 마찬가지로 작동합니다."

#: src/ch05-03-method-syntax.md:217
msgid "Accessing implementation functions"
msgstr "구현 함수에 액세스하기"

#: src/ch05-03-method-syntax.md:219
msgid ""
"All functions defined within a `trait` and `impl` block can be directly "
"addressed using the `::` operator on the implementation name. Functions in "
"traits that aren’t methods are often used for constructors that will return "
"a new instance of the struct. These are often called `new`, but `new` isn’t "
"a special name and isn’t built into the language. For example, we could "
"choose to provide an associated function named `square` that would have one "
"dimension parameter and use that as both width and height, thus making it "
"easier to create a square `Rectangle` rather than having to specify the same"
" value twice:"
msgstr ""
"`trait` 및 `impl` 블록 내에서 정의된 모든 함수는 구현 이름에 `::` 연산자를 사용하여 직접 호출할 수 있습니다. 메서드가"
" 아닌 트레이트 내의 함수들은 종종 구조체의 새 인스턴스를 반환하는 생성자로 사용됩니다. 이러한 함수들은 종종 `new`로 불리지만, "
"`new`는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 우리는 한 변의 매개변수를 가진 연관 함수인 "
"`square`를 제공할 수 있으며, 이를 너비와 높이로 사용하여 사각형 `Rectangle`을 쉽게 생성할 수 있도록 할 수 있습니다."
" 이렇게 하면 동일한 값을 두 번 지정할 필요 없이 사각형 `Rectangle`을 만들 수 있습니다."

#: src/ch05-03-method-syntax.md:242
msgid ""
"To call this function, we use the `::` syntax with the implementation name: "
"`let square = RectangleImpl::square(10);` is an example. This function is "
"namespaced by the implementation; the `::` syntax is used for both trait "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](ch07-02-defining-modules-to-control-scope.md)."
msgstr ""
"이 함수를 호출하려면 구현 이름과 함께 `::` 구문을 사용합니다: `let square = "
"RectangleImpl::square(10);`은 예시입니다. 이 함수는 구현에 의해 네임스페이스화되며, `::` 구문은 트레이트 "
"함수와 모듈에 의해 생성된 네임스페이스 모두에 사용됩니다. 모듈에 대해는 [Chapter 7](ch07-02-defining-"
"modules-to-control-scope.md)에서 논의할 것입니다."

#: src/ch05-03-method-syntax.md:247
msgid ""
"Note: It is also possible to call this function using the trait name, with "
"`RectangleTrait::square(10)`."
msgstr ""
"참고: 또한 이 함수를 특성 이름을 사용하여 호출하는 것도 가능합니다. `RectangleTrait::square(10)`으로 호출할 수"
" 있습니다."

#: src/ch05-03-method-syntax.md:250
msgid "Multiple `impl` Blocks"
msgstr "여러 개의 `impl` 블록"

#: src/ch05-03-method-syntax.md:252
msgid ""
"Each struct is allowed to have multiple `trait` and `impl` blocks. For "
"example, Listing 5-13 is equivalent to the code shown in Listing 5-14, which"
" has each method in its own `trait` and `impl` blocks."
msgstr ""
"각 구조체는 여러 `trait` 및 `impl` 블록을 가질 수 있습니다. 예를 들어, 5-13 목록은 각 메서드가 자체 `trait` "
"및 `impl` 블록에 있는 코드와 동일한 코드인 5-14 목록에 표시된 코드와 동등합니다."

#: src/ch05-03-method-syntax.md:277
msgid "Listing 5-14: Rewriting Listing 5-13 using multiple `impl` blocks"
msgstr "리스팅 5-14: 여러 `impl` 블록을 사용하여 리스팅 5-13을 다시 작성하기"

#: src/ch05-03-method-syntax.md:280
msgid ""
"There’s no reason to separate these methods into multiple `trait` and `impl`"
" blocks here, but this is valid syntax. We’ll see a case in which multiple "
"blocks are useful in [Chapter 8](ch08-00-generic-types-and-traits.md), where"
" we discuss generic types and traits."
msgstr ""
"이러한 메서드를 여러 `trait` 및 `impl` 블록으로 분리할 이유는 없지만, 이는 유효한 구문입니다. 우리는 여러 블록이 유용한 "
"경우를 볼 것입니다. [8장](ch08-00-generic-types-and-traits.md)에서 일반적인 타입 및 트레이트를 논의할 "
"때입니다."

#: src/ch05-03-method-syntax.md:287
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `trait` and `impl` "
"blocks, you can define methods, which are functions associated to a type and"
" let you specify the behavior that instances of your type have."
msgstr ""
"구조체를 사용하면 도메인에 의미 있는 사용자 정의 유형을 만들 수 있습니다. 구조체를 사용하면 연결된 데이터 조각을 유지하고 각 조각에 "
"이름을 지어 코드를 명확하게 만들 수 있습니다. `trait` 및 `impl` 블록에서 메서드를 정의할 수 있으며 이는 유형에 연결된 "
"함수이며 유형의 인스턴스가 가지는 동작을 지정할 수 있습니다."

#: src/ch05-03-method-syntax.md:293
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Cairo’s enum feature to add another tool to your toolbox."
msgstr ""
"그러나 구조체만이 사용자 정의 타입을 만들 수 있는 유일한 방법은 아닙니다. 대신, Cairo의 enum 기능을 활용하여 도구 상자에 또"
" 다른 도구를 추가해 봅시다."

#: src/ch06-00-enums-and-pattern-matching.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First, we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Finally, we’ll look at how pattern matching in the `match` expression makes "
"it easy to run different code for different values of an enum."
msgstr ""
"이 장에서는 _열거형_ 또는 _enums_ 로도 불리는 것을 살펴볼 것입니다. Enums를 사용하면 가능한 _변형_ 을 나열하여 유형을 "
"정의할 수 있습니다. 먼저, enum을 정의하고 사용하여 enum이 데이터와 함께 의미를 인코딩하는 방법을 보여줄 것입니다. 그 "
"다음으로, `Option`이라는 특히 유용한 enum을 탐색하여 값이 무언가이거나 아무것도 아닐 수 있다는 것을 표현합니다. 마지막으로,"
" `match` 표현식에서 패턴 매칭이 어떻게 enum의 다른 값에 대해 다른 코드를 실행하기 쉽게 만드는지 살펴볼 것입니다."

#: src/ch06-01-enums.md:3
msgid ""
"Enums, short for \"enumerations,\" are a way to define a custom data type "
"that consists of a fixed set of named values, called _variants_. Enums are "
"useful for representing a collection of related values where each value is "
"distinct and has a specific meaning."
msgstr ""
"열거형은 \"enumerations\"의 줄임말로, 고정된 일련의 이름이 지정된 값으로 구성된 사용자 정의 데이터 유형을 정의하는 "
"방법입니다. 열거형은 각 값이 구별되고 특정 의미를 가지는 관련 값의 컬렉션을 나타내는 데 유용합니다."

#: src/ch06-01-enums.md:5
msgid "Enum Variants and Values"
msgstr "열거형 변형 및 값들"

#: src/ch06-01-enums.md:7
msgid "Here's a simple example of an enum:"
msgstr "다음은 enum의 간단한 예제입니다."

#: src/ch06-01-enums.md:19
msgid ""
"In this example, we've defined an enum called `Direction` with four "
"variants: `North`, `East`, `South`, and `West`. The naming convention is to "
"use PascalCase for enum variants. Each variant represents a distinct value "
"of the Direction type. In this particular example, variants don't have any "
"associated value. One variant can be instantiated using this syntax:"
msgstr ""
"이 예시에서는 `Direction`이라는 enum을 정의했습니다. 이 enum은 `North`, `East`, `South`, "
"`West` 네 가지 변형을 가지고 있습니다. 네이밍 규칙은 enum 변형에 대해 PascalCase를 사용하는 것입니다. 각 변형은 "
"Direction 타입의 구별된 값 하나를 나타냅니다. 이 특정 예시에서는 변형에 연관된 값이 없습니다. 하나의 변형은 다음 구문을 "
"사용하여 인스턴스화될 수 있습니다:"

#: src/ch06-01-enums.md:37
msgid ""
"It's easy to write code that acts differently depending on the variant of an"
" enum instance, in this example to run specific code according to a "
"Direction. You can learn more about it on [The Match Control Flow Construct "
"page](ch06-02-the-match-control-flow-construct.md)."
msgstr ""
"열거형 인스턴스의 변형에 따라 다르게 작동하는 코드를 작성하는 것은 쉽습니다. 이 예제에서는 Direction에 따라 특정 코드를 실행할"
" 수 있습니다. [The Match Control Flow Construct 페이지](ch06-02-the-match-control-"
"flow-construct.md)에서 더 자세히 알아볼 수 있습니다."

#: src/ch06-01-enums.md:39
msgid "Enums Combined with Custom Types"
msgstr "열거형과 사용자 정의 타입 결합"

#: src/ch06-01-enums.md:41
msgid ""
"Enums can also be used to store more interesting data associated with each "
"variant. For example:"
msgstr "열거형은 각 변형과 관련된 더 흥미로운 데이터를 저장하는 데에도 사용될 수 있습니다. 예를 들어:"

#: src/ch06-01-enums.md:52
msgid ""
"In this example, the `Message` enum has three variants: `Quit`, `Echo` and "
"`Move`, all with different types:"
msgstr ""
"이 예시에서 `Message` enum에는 세 가지 변형이 있습니다: `Quit`, `Echo` 및 `Move`, 각각 다른 타입을 "
"가지고 있습니다:"

#: src/ch06-01-enums.md:54
msgid "`Quit` doesn't have any associated value."
msgstr "`Quit`에는 관련 값이 없습니다."

#: src/ch06-01-enums.md:55
msgid "`Echo` is a single felt."
msgstr "`Echo`는 한 장의 펠트입니다."

#: src/ch06-01-enums.md:56
msgid "`Move` is a tuple of two u128 values."
msgstr "`Move`은 두 개의 u128 값으로 이루어진 튜플입니다."

#: src/ch06-01-enums.md:58
msgid ""
"You could even use a Struct or another Enum you defined inside one of your "
"Enum variants."
msgstr "하나의 Enum 변형 내부에 정의한 Struct나 다른 Enum을 사용할 수도 있습니다."

#: src/ch06-01-enums.md:60
msgid "Trait Implementations for Enums"
msgstr "열거형에 대한 특성 구현"

#: src/ch06-01-enums.md:62
msgid ""
"In Cairo, you can define traits and implement them for your custom enums. "
"This allows you to define methods and behaviors associated with the enum. "
"Here's an example of defining a trait and implementing it for the previous "
"`Message` enum:"
msgstr ""
"카이로에서는 사용자 정의 열거형을 위해 특성을 정의하고 구현할 수 있습니다. 이를 통해 열거형과 관련된 메서드와 동작을 정의할 수 "
"있습니다. 이전 `Message` 열거형을 위해 특성을 정의하고 구현하는 예시가 있습니다."

#: src/ch06-01-enums.md:72 src/ch06-01-enums.md:98
msgid "\"quitting\""
msgstr "그만두기"

#: src/ch06-01-enums.md:73 src/ch06-01-enums.md:99
msgid "\"echoing {}\""
msgstr "\"반복 {}\""

#: src/ch06-01-enums.md:74 src/ch06-01-enums.md:100
msgid "\"moving\""
msgstr "이동 중"

#: src/ch06-01-enums.md:80
msgid ""
"In this example, we implemented the `Processing` trait for `Message`. Here "
"is how it could be used to process a Quit message:"
msgstr ""
"이 예시에서는 `Message`에 대한 `Processing` 특성을 구현했습니다. 여기에는 Quit 메시지를 처리하는 방법이 나와 "
"있습니다."

#: src/ch06-01-enums.md:112
msgid "Running this code would print `quitting`."
msgstr "이 코드를 실행하면 `quitting`이 출력됩니다."

#: src/ch06-01-enums.md:114
msgid "The Option Enum and Its Advantages"
msgstr "옵션 Enum 및 그 이점"

#: src/ch06-01-enums.md:116
msgid ""
"The Option enum is a standard Cairo enum that represents the concept of an "
"optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` "
"indicates that there's a value of type `T`, while `None` represents the "
"absence of a value."
msgstr ""
"Option 열거형은 선택적인 값의 개념을 나타내는 표준 Cairo 열거형입니다. 두 가지 변형이 있습니다: `Some: T`와 "
"`None: ()`. `Some: T`는 `T` 유형의 값이 있는 것을 나타내고, `None`은 값이 없음을 나타냅니다."

#: src/ch06-01-enums.md:125
msgid ""
"The `Option` enum is helpful because it allows you to explicitly represent "
"the possibility of a value being absent, making your code more expressive "
"and easier to reason about. Using `Option` can also help prevent bugs caused"
" by using uninitialized or unexpected `null` values."
msgstr ""
"`Option` 열거형은 값이 없을 수 있는 가능성을 명시적으로 나타낼 수 있기 때문에 코드를 더 표현력 있고 이해하기 쉽게 "
"만들어줍니다. `Option`을 사용하면 초기화되지 않거나 예기치 않은 `null` 값으로 인한 버그를 방지하는 데도 도움이 될 수 "
"있습니다."

#: src/ch06-01-enums.md:127
msgid ""
"To give you an example, here is a function which returns the index of the "
"first element of an array with a given value, or None if the element is not "
"present."
msgstr ""
"예를 들어, 주어진 값이 있는 배열의 첫 번째 요소의 인덱스를 반환하는 함수를 여기에 제시합니다. 만약 해당 요소가 없다면 None을 "
"반환합니다."

#: src/ch06-01-enums.md:129
msgid "We are demonstrating two approaches for the above function:"
msgstr "우리는 위의 함수에 대해 두 가지 접근 방식을 보여주고 있습니다."

#: src/ch06-01-enums.md:131
msgid "Recursive Approach `find_value_recursive`"
msgstr "재귀적 접근 `find_value_recursive`"

#: src/ch06-01-enums.md:132
msgid "Iterative Approach `find_value_iterative`"
msgstr "반복적인 접근 `find_value_iterative`"

#: src/ch06-01-enums.md:134
msgid ""
"Note: in the future it would be nice to replace this example by something "
"simpler using a loop and without gas related code."
msgstr "참고: 미래에는 루프를 사용하고 가스 관련 코드 없이 더 간단한 예제로 대체하는 것이 좋을 것입니다."

#: src/ch06-01-enums.md:183
msgid "\"found recursively at index {}\""
msgstr "\"인덱스 {}에서 재귀적으로 발견되었습니다\""

#: src/ch06-01-enums.md:186 src/ch06-01-enums.md:194
msgid "\"not found\""
msgstr "\"찾을 수 없음\""

#: src/ch06-01-enums.md:191
msgid "\"found iteratively at index {}\""
msgstr "\"인덱스 {}에서 반복적으로 찾음\""

#: src/ch06-01-enums.md:201
msgid "Running this code would print `it worked`."
msgstr "이 코드를 실행하면 `작동했습니다`가 출력됩니다."

#: src/ch06-02-the-match-control-flow-construct.md:3
msgid ""
"Cairo has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things. The power of "
"`match` comes from the expressiveness of the patterns and the fact that the "
"compiler confirms that all possible cases are handled."
msgstr ""
"카이로에는 `match`라는 매우 강력한 제어 흐름 구조가 있습니다. 이를 사용하면 값과 일련의 패턴을 비교한 다음 일치하는 패턴에 따라"
" 코드를 실행할 수 있습니다. 패턴은 리터럴 값, 변수 이름, 와일드카드 및 기타 여러 가지로 구성될 수 있습니다. `match`의 "
"강점은 패턴의 표현력과 컴파일러가 모든 가능한 경우를 처리했음을 확인하는 점에 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:5
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a match, and at the first pattern the "
"value “fits”, the value falls into the associated code block to be used "
"during execution."
msgstr ""
"`match` 표현식을 동전을 분류하는 기계와 같이 생각해보세요: 동전이 다양한 크기의 구멍이 있는 트랙을 따라 미끄러지고, 각 동전은 "
"적합한 구멍을 처음으로 만나면 그 구멍으로 떨어집니다. 마찬가지로, 값들은 `match`의 각 패턴을 거치며, 값이 \"적합\"한 첫 "
"번째 패턴에서 해당하는 코드 블록으로 떨어져 실행 중에 사용됩니다."

#: src/ch06-02-the-match-control-flow-construct.md:7
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-3."
msgstr ""
"동전에 대해 말씀드리면, `match`를 사용하는 예시로 사용해 봅시다! 우리는 알 수 없는 미국 동전을 받아들이고, 계수기와 비슷한 "
"방식으로 어떤 동전인지 판별하고 센트 단위로 값을 반환하는 함수를 작성할 수 있습니다. (리스트 6-3에 표시된 대로)"

#: src/ch06-02-the-match-control-flow-construct.md:27
msgid ""
"Listing 6-3: An enum and a `match` expression that has the variants of the "
"enum as its patterns"
msgstr "리스트 6-3: 열거형과 해당 패턴으로 사용하는 `match` 표현식"

#: src/ch06-02-the-match-control-flow-construct.md:29
msgid ""
"Let’s break down the `match` expression in the `value_in_cents` function. "
"First we list the `match` keyword followed by an expression, which in this "
"case is the value `coin`. This seems very similar to a conditional "
"expression used with if, but there’s a big difference: with if, the "
"condition needs to evaluate to a Boolean value, but here it can be any type."
" The type of `coin` in this example is the `Coin` enum that we defined on "
"the first line."
msgstr ""
"`value_in_cents` 함수의 `match` 표현식을 분해해 봅시다. 먼저 `match` 키워드를 나열한 후에 이번 경우에는 "
"`coin` 값이 됩니다. 이는 if와 함께 사용되는 조건 표현식과 매우 유사해 보이지만, 큰 차이가 있습니다: if에서는 조건이 부울 "
"값으로 평가되어야 하지만, 여기서는 어떤 유형이든 될 수 있습니다. 이 예제에서 `coin`의 유형은 첫 번째 줄에서 정의한 `Coin`"
" 열거형입니다."

#: src/ch06-02-the-match-control-flow-construct.md:31
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with"
" a comma."
msgstr ""
"다음은 `match` 암입니다. 암에는 두 부분이 있습니다: 패턴과 코드입니다. 여기 첫 번째 암은 값 `Coin::Penny`인 패턴과"
" 패턴과 코드를 구분하는 `=>` 연산자가 있습니다. 이 경우 코드는 단순히 값 `1`입니다. 각 암은 쉼표로 구분됩니다."

#: src/ch06-02-the-match-control-flow-construct.md:33
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in the order they are given. If a pattern "
"matches the value, the code associated with that pattern is executed. If "
"that pattern doesn’t match the value, execution continues to the next arm, "
"much as in a coin-sorting machine. We can have as many arms as we need: in "
"the above example, our `match` has four arms."
msgstr ""
"`match` 표현식이 실행될 때, 결과 값은 각 팔에 대한 패턴과 비교됩니다. 주어진 순서대로. 패턴이 값과 일치하면 해당 패턴과 "
"관련된 코드가 실행됩니다. 그 패턴이 값과 일치하지 않으면 실행은 다음 팔로 계속됩니다. 동전 분류기와 마찬가지로 필요한 만큼 많은 팔을"
" 가질 수 있습니다. 위 예제에서는 `match`가 네 개의 팔을 가지고 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:35
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire match expression."
msgstr "각 팔에 연결된 코드는 표현식이며, 일치하는 팔의 표현식의 결과 값은 전체 일치 표현식에 대한 반환 값이 됩니다."

#: src/ch06-02-the-match-control-flow-construct.md:37
msgid ""
"We don’t typically use curly brackets if the `match` arm code is short, as "
"it is in our example where each arm just returns a value. If you want to run"
" multiple lines of code in a `match` arm, you must use curly brackets, with "
"a comma following the arm. For example, the following code prints “Lucky "
"penny!” every time the method is called with a `Coin::Penny`, but still "
"returns the last value of the block, `1`:"
msgstr ""
"일반적으로 `match` 팔 코드가 짧을 경우 중괄호를 사용하지 않습니다. 예를 들어 각 팔이 값만 반환하는 예제에서와 같이요. "
"`match` 팔에서 여러 줄의 코드를 실행하려면 각 팔 뒤에 쉼표를 붙여 중괄호를 사용해야 합니다. 예를 들어 다음 코드는 "
"`Coin::Penny`로 호출될 때마다 \"Lucky penny!\"를 출력하지만 블록의 마지막 값인 `1`을 반환합니다:"

#: src/ch06-02-the-match-control-flow-construct.md:43
msgid "\"Lucky penny!\""
msgstr "\"행운의 페니!\""

#: src/ch06-02-the-match-control-flow-construct.md:53
msgid "Patterns That Bind to Values"
msgstr "값에 바인딩되는 패턴"

#: src/ch06-02-the-match-control-flow-construct.md:55
msgid ""
"Another useful feature of `match` arms is that they can bind to the parts of"
" the values that match the pattern. This is how we can extract values out of"
" enum variants."
msgstr ""
"`match` 팔에 대한 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩할 수 있다는 것입니다. 이것이 enum 변형에서 값을"
" 추출하는 방법입니다."

#: src/ch06-02-the-match-control-flow-construct.md:57
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it."
" From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information"
" to our `enum` by changing the `Quarter` variant to include a `UsState` "
"value stored inside it, which we’ve done in Listing 6-4."
msgstr ""
"예를 들어, 우리의 enum 변형 중 하나를 내부에 데이터를 보유하도록 변경해 봅시다. 1999년부터 2008년까지 미국은 50개 주 "
"각각에 대해 다른 디자인이 새겨진 쿼터를 조제했습니다. 다른 동전들은 주 디자인이 없었기 때문에, 쿼터만이 이 추가 가치를 가지고 "
"있습니다. 우리는 `enum`에 이 정보를 추가할 수 있습니다. `Quarter` 변형을 변경하여 내부에 저장된 `UsState` 값을 "
"포함시키는 방식으로, 우리는 Listing 6-4에서 수행한 것과 같이 할 수 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:61
msgid "// Debug so we can inspect the state in a minute\n"
msgstr "// 조사를 위해 상태를 검사할 수 있도록 디버그합니다"

#: src/ch06-02-the-match-control-flow-construct.md:76
msgid ""
"Listing 6-4: A `Coin` enum in which the `Quarter` variant also holds a "
"`UsState` value"
msgstr "리스트 6-4: `Quarter` 변형이 `UsState` 값을 보유하는 `Coin` 열거형"

#: src/ch06-02-the-match-control-flow-construct.md:78
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of"
" the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""
"친구가 50개의 주 쿼터를 모으려고 노력하고 있다고 상상해 봅시다. 우리가 동전 종류별로 잔돈을 정리하는 동안, 각 쿼터와 연관된 주 "
"이름을 외쳐서, 만약 우리 친구가 갖고 있지 않은 쿼터라면 그들이 컬렉션에 추가할 수 있도록 도와줍시다."

#: src/ch06-02-the-match-control-flow-construct.md:80
msgid ""
"In the `match` expression for this code, we add a variable called `state` to"
" the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that"
" quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""
"이 코드의 `match` 표현식에서는 `Coin::Quarter` 변형값과 일치하는 패턴에 `state`라는 변수를 추가합니다. "
"`Coin::Quarter`가 일치하면 `state` 변수가 해당 쿼터의 상태 값에 바인딩됩니다. 그런 다음 해당 arm의 코드에서 "
"`state`를 사용할 수 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:89
msgid "\"State quarter from {:?}!\""
msgstr "\"{:?}에서 온 주 쿼터!\""

#: src/ch06-02-the-match-control-flow-construct.md:96
msgid ""
"Because `state` is an `UsState` enum which implements the `Debug` trait, we "
"can print `state` value with `println!` macro."
msgstr ""
"`state`는 `Debug` 트레이트를 구현한 `UsState` enum이기 때문에 `println!` 매크로로 `state` 값을 "
"출력할 수 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:98
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in `println!` macro, "
"thus getting the inner state value out of the Coin enum variant for Quarter."
msgstr ""
"만약 `value_in_cents(Coin::Quarter(UsState::Alaska))`를 호출한다면, `coin`은 "
"`Coin::Quarter(UsState::Alaska)`가 될 것입니다. 해당 값을 각 match arm과 비교할 때, "
"`Coin::Quarter(state)`에 도달할 때까지 일치하는 것이 없습니다. 그 순간에, `state`에 대한 바인딩은 "
"`UsState::Alaska`의 값이 될 것입니다. 이후에는 `println!` 매크로에서 해당 바인딩을 사용하여, Quarter에 "
"대한 Coin enum 변형의 내부 상태 값을 가져올 수 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:102
msgid "Matching with `Option<T>`"
msgstr "`Option<T>`과 일치하는 것"

#: src/ch06-02-the-match-control-flow-construct.md:104
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""
"이전 섹션에서는 `Option<T>`를 사용할 때 `Some` 케이스에서 내부 `T` 값을 가져오고 싶었습니다. `Coin` enum과 "
"같이 `match`를 사용하여 `Option<T>`를 처리할 수도 있습니다! 동전을 비교하는 대신 `Option<T>`의 변형을 비교할 "
"것이지만, `match` 표현식이 작동하는 방식은 동일합니다."

#: src/ch06-02-the-match-control-flow-construct.md:106
msgid ""
"Let’s say we want to write a function that takes an `Option<u8>` and, if "
"there’s a value inside, adds `1` to that value. If there isn’t a value "
"inside, the function should return the `None` value and not attempt to "
"perform any operations."
msgstr ""
"우리가 `Option<u8>`를 가져와서, 그 안에 값이 있으면 그 값에 `1`을 더하는 함수를 작성하고 싶다고 가정해 봅시다. 값이 "
"없으면 함수는 `None` 값을 반환하고 어떤 작업도 수행하지 않아야 합니다."

#: src/ch06-02-the-match-control-flow-construct.md:108
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-5."
msgstr "이 함수는 `match` 덕분에 매우 쉽게 작성할 수 있으며, 6-5 목록과 같이 보일 것입니다."

#: src/ch06-02-the-match-control-flow-construct.md:125
msgid ""
"Listing 6-5: A function that uses a `match` expression on an `Option<u8>`"
msgstr "리스트 6-5: `Option<u8>`에서 `match` 표현식을 사용하는 함수"

#: src/ch06-02-the-match-control-flow-construct.md:127
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call"
" `plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each `match` arm:"
msgstr ""
"`plus_one`의 첫 번째 실행을 더 자세히 살펴봅시다. `plus_one(five)`를 호출하면 `plus_one`의 본문에서 변수"
" `x`는 `Some(5)`의 값을 가질 것입니다. 그런 다음 각 `match` 팔에 대해 비교합니다:"

#: src/ch06-02-the-match-control-flow-construct.md:133
msgid ""
"Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does!"
" We have the same variant. The `val` binds to the value contained in "
"`Option::Some`, so `val` takes the value `5`. The code in the `match` arm is"
" then executed, so we add `1` to the value of `val` and create a new "
"`Option::Some` value with our total `6` inside. Because the first arm "
"matched, no other arms are compared."
msgstr ""
"`Option::Some(5)` 값이 `Option::Some(val)` 패턴과 일치합니까? 그렇습니다! 우리는 동일한 변형을 갖고 "
"있습니다. `val`은 `Option::Some`에 포함된 값에 바인딩되므로 `val`은 값 `5`를 가집니다. 그런 다음 `match`"
" 팔에있는 코드가 실행되어 `val`의 값에 `1`을 추가하고 총 `6`이 내부에있는 새로운 `Option::Some` 값을 만듭니다. "
"첫 번째 팔이 일치했기 때문에 다른 팔은 비교되지 않습니다."

#: src/ch06-02-the-match-control-flow-construct.md:135
msgid ""
"Now let’s consider the second call of `plus_one` in our main function, where"
" `x` is `Option::None`. We enter the `match` and compare to the first arm:"
msgstr ""
"이제 `plus_one`의 두 번째 호출을 고려해 봅시다. 여기서 `x`는 `Option::None`입니다. 우리는 `match`에 "
"들어가서 첫 번째 팔과 비교합니다:"

#: src/ch06-02-the-match-control-flow-construct.md:141
msgid ""
"The `Option::Some(val)` value doesn’t match the pattern `Option::None`, so "
"we continue to the next arm:"
msgstr "`Option::Some(val)` 값은 `Option::None` 패턴과 일치하지 않으므로 다음 팔로 이동합니다:"

#: src/ch06-02-the-match-control-flow-construct.md:147
msgid ""
"It matches! There’s no value to add to, so the matching construct ends and "
"returns the `Option::None` value on the right side of `=>`."
msgstr "일치합니다! 추가할 값이 없으므로 일치하는 구조가 끝나고 `=>` 오른쪽에 `Option::None` 값을 반환합니다."

#: src/ch06-02-the-match-control-flow-construct.md:149
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Cairo code: `match` against an enum, bind a variable to the"
" data inside, and then execute code based on it. It’s a bit tricky at first,"
" but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""
"`match`와 열거형을 결합하는 것은 많은 상황에서 유용합니다. Cairo 코드에서 이 패턴을 자주 볼 수 있습니다: 열거형에 대해 "
"`match`를 수행하고, 데이터 내부에 변수를 바인딩한 다음 그에 기반하여 코드를 실행합니다. 처음에는 조금 까다롭지만, 익숙해지면 "
"모든 언어에서 이것을 가지고 싶어할 것입니다. 사용자들이 일관되게 좋아하는 기능입니다."

#: src/ch06-02-the-match-control-flow-construct.md:151
msgid "Matches Are Exhaustive"
msgstr "경기는 지치게 해요."

#: src/ch06-02-the-match-control-flow-construct.md:153
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""
"우리가 논의해야 할 `match`의 또 다른 측면이 있습니다: arms의 패턴은 모든 가능성을 포함해야 합니다. 컴파일되지 않는 버그가 "
"있는 `plus_one` 함수 버전을 고려해보세요."

#: src/ch06-02-the-match-control-flow-construct.md:163
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Cairo knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""
"우리는 `None` 케이스를 처리하지 않았기 때문에 이 코드는 버그를 발생시킬 것입니다. 다행히, Cairo가 잡을 수 있는 버그입니다."
" 이 코드를 컴파일하려고 하면 다음 오류가 발생할 것입니다:"

#: src/ch06-02-the-match-control-flow-construct.md:175
msgid ""
"Cairo knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Cairo prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""
"카이로는 우리가 모든 가능한 경우를 다 다루지 않았음을 알고 있고, 우리가 빠뜨린 패턴까지도 알고 있습니다! 카이로에서의 매치는 "
"철저합니다: 코드가 유효하게 되려면 가능한 모든 가능성을 다 고려해야 합니다. 특히 `Option<T>`의 경우에는, 카이로가 우리가 "
"`None` 케이스를 명시적으로 처리하지 않게 잊지 않도록 막아줌으로써, 우리가 값이 있는 것으로 가정하고 null이 될 수도 있는 "
"경우를 방지하여, 앞서 논의한 10억 달러의 실수를 불가능하게 만들어줍니다."

#: src/ch06-02-the-match-control-flow-construct.md:177
msgid "Catch-all with the `_` Placeholder"
msgstr "`_` 플레이스홀더를 사용한 캐치-올"

#: src/ch06-02-the-match-control-flow-construct.md:179
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. `_` is a special pattern "
"that matches any value and does not bind to that value. You can use it by "
"simply adding a new arm with `_` as the pattern for the last arm of the "
"`match` expression."
msgstr ""
"열거형을 사용하면 몇 가지 특정 값에 대해 특별한 작업을 수행할 수도 있지만 다른 모든 값에 대해서는 기본 작업을 수행할 수 있습니다. "
"`_`는 어떤 값과도 일치하며 해당 값에 바인딩되지 않는 특별한 패턴입니다. `match` 표현식의 마지막 arm으로 `_`를 패턴으로 "
"사용하여 간단히 새로운 arm을 추가할 수 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:183
msgid ""
"Imagine we have a vending machine that only accepts Dime coins. We want to "
"have a function that process inserted coins and returns `true` only if the "
"coin is accepted."
msgstr ""
"우리가 다임 동전만 받는 자동판매기가 있다고 상상해보세요. 우리는 삽입된 동전을 처리하고 동전이 받아들여지는 경우에만 `true`를 "
"반환하는 함수를 가지고 싶습니다."

#: src/ch06-02-the-match-control-flow-construct.md:186
msgid "Here's a `vending_machine_accept` function that implements this logic:"
msgstr "다음은이 논리를 구현하는 `vending_machine_accept` 함수입니다:"

#: src/ch06-02-the-match-control-flow-construct.md:197
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr ""
"이 예제는 마지막 분기에서 다른 모든 값들을 명시적으로 무시하기 때문에 완전성 요구 사항을 충족합니다; 우리는 아무 것도 잊지 "
"않았습니다."

#: src/ch06-02-the-match-control-flow-construct.md:199
msgid ""
"There's no catch-all pattern in Cairo that allows you to use the value of "
"the pattern."
msgstr "카이로에는 패턴의 값을 사용할 수 있는 모든 패턴이 없습니다."

#: src/ch06-02-the-match-control-flow-construct.md:205
msgid "Multiple Patterns with the `|` operator"
msgstr "`|` 연산자를 사용한 여러 패턴"

#: src/ch06-02-the-match-control-flow-construct.md:207
msgid ""
"In `match` expressions, you can match multiple patterns using the `|` "
"syntax, which is the pattern _or_ operator."
msgstr "`match` 표현식에서는 `|` 구문을 사용하여 여러 패턴을 매칭할 수 있습니다. 이는 패턴 _또는_ 연산자입니다."

#: src/ch06-02-the-match-control-flow-construct.md:209
msgid ""
"For example, in the following code we modified the `vending_machine_accept` "
"function to accept both `Dime` and `Quarter` coins in a single arm:"
msgstr ""
"예를 들어, 다음 코드에서는 `vending_machine_accept` 함수를 수정하여 `Dime`과 `Quarter` 동전을 한 팔에"
" 동시에 받아들일 수 있도록 했습니다."

#: src/ch06-02-the-match-control-flow-construct.md:220
msgid "Matching Tuples"
msgstr "튜플 매칭"

#: src/ch06-02-the-match-control-flow-construct.md:222
msgid "It is possible to match tuples. Let's introduce a new `DayType` enum:"
msgstr "튜플을 매칭하는 것이 가능합니다. 새로운 `DayType` 열거형을 소개해보겠습니다:"

#: src/ch06-02-the-match-control-flow-construct.md:234
msgid ""
"Now, let's suppose that our vending machine accepts any coin on weekdays, "
"but only accepts quarters and dimes on weekends and holidays. We can modify "
"the `vending_machine_accept` function to accept a tuple of a `Coin` and a "
"`Weekday` and return `true` only if the given coin is accepted on the "
"specified day:"
msgstr ""
"이제, 자판기가 주중에는 모든 동전을 받지만 주말과 공휴일에는 25센트와 10센트 동전만 받는다고 가정해 봅시다. "
"`vending_machine_accept` 함수를 수정하여 `Coin`과 `Weekday`의 튜플을 받아 지정된 날짜에 주어진 동전이 "
"받아들여지는 경우에만 `true`를 반환하도록 할 수 있습니다:"

#: src/ch06-02-the-match-control-flow-construct.md:247
msgid "Matching `felt252` and integer variables"
msgstr "`felt252`와 정수 변수를 매칭하기"

#: src/ch06-02-the-match-control-flow-construct.md:249
msgid ""
"You can also match `felt252` and integer variables. This is useful when you "
"want to match against a range of values. However there are some "
"restrictions:"
msgstr ""
"`felt252`와 정수 변수도 일치시킬 수 있습니다. 값 범위와 일치시키고 싶을 때 유용합니다. 그러나 일부 제한 사항이 있습니다."

#: src/ch06-02-the-match-control-flow-construct.md:252
msgid ""
"Only integers that fit into a single `felt252` are supported (i.e. `u256` is"
" not supported)."
msgstr "단일 `felt252`에 맞는 정수만 지원됩니다 (`u256`은 지원되지 않습니다)."

#: src/ch06-02-the-match-control-flow-construct.md:253
msgid "The first arm must be 0."
msgstr "첫 번째 팔은 0이어야 합니다."

#: src/ch06-02-the-match-control-flow-construct.md:254
msgid ""
"Each arm must cover a sequential segment, contiguously with other arms."
msgstr "각 팔은 다른 팔과 연속적으로 이어져야 하는 일련의 세그먼트를 커버해야 합니다."

#: src/ch06-02-the-match-control-flow-construct.md:256
msgid ""
"Imagine we’re implementing a game where you roll a six-sided die to get a "
"number between 0 and 5. If you have 0, 1 or 2 you win. If you have 3, you "
"can roll again. For all other values you lose."
msgstr ""
"0부터 5 사이의 숫자를 얻기 위해 여섯 면 주사위를 굴리는 게임을 구현 중이라고 상상해보세요. 0, 1 또는 2가 나오면 이기는 "
"것입니다. 3이 나오면 다시 굴릴 수 있습니다. 그 외의 모든 값에서는 패배합니다."

#: src/ch06-02-the-match-control-flow-construct.md:259
msgid "Here's a match that implements that logic:"
msgstr "이것은 그 논리를 구현하는 매치입니다."

#: src/ch06-02-the-match-control-flow-construct.md:264
msgid "\"you won!\""
msgstr "\"당신이 이겼어요!\""

#: src/ch06-02-the-match-control-flow-construct.md:265
msgid "\"you can roll again!\""
msgstr "\"다시 굴릴 수 있어요!\""

#: src/ch06-02-the-match-control-flow-construct.md:266
msgid "\"you lost...\""
msgstr "\"당신은 졌어요...\""

#: src/ch06-02-the-match-control-flow-construct.md:271
msgid ""
"These restrictions are planned to be relaxed in future versions of Cairo."
msgstr "이러한 제한 사항은 향후 카이로의 버전에서 완화될 예정입니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""
"대규모 프로그램을 작성할수록 코드를 조직하는 것이 점점 중요해집니다. 관련 기능을 그룹화하고 구별되는 기능으로 코드를 분리함으로써, 특정"
" 기능을 구현하는 코드를 찾을 수 있는 위치와 기능이 작동하는 방식을 변경할 위치를 명확히 할 수 있습니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. As a package grows, you can extract parts "
"into separate crates that become external dependencies. This chapter covers "
"all these techniques."
msgstr ""
"지금까지 작성한 프로그램은 하나의 모듈에 하나의 파일에 있었습니다. 프로젝트가 커질수록 코드를 여러 모듈로 분할하고 그 다음 여러 파일로"
" 분할하는 것이 좋습니다. 패키지가 커지면 일부를 별도의 크레이트로 추출하여 외부 종속성이 되도록 할 수 있습니다. 이 장에서는 이러한 "
"모든 기술을 다룹니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:14
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code without having to know how the implementation works."
msgstr ""
"우리는 또한 구현 세부 정보를 캡슐화하는 것에 대해 논의할 것입니다. 이를 통해 코드를 더 높은 수준에서 재사용할 수 있습니다. 한 번 "
"작업을 구현한 후에는 다른 코드가 구현 방식을 알 필요 없이 코드를 호출할 수 있습니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:19
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope."
msgstr ""
"관련 개념 중 하나는 범위(scope)입니다: 코드가 작성된 중첩된 컨텍스트에는 \"범위 내에 정의된 이름\"이라는 것이 있습니다. "
"코드를 읽고 쓰고 컴파일할 때 프로그래머와 컴파일러는 특정 위치의 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 다른 "
"항목을 가리키는지, 그 항목이 무엇을 의미하는지를 알아야 합니다. 범위를 생성하고 범위 내에 있는 이름을 변경할 수 있습니다. 동일한 "
"범위 내에 동일한 이름을 가진 항목을 두 개 가질 수 없습니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:27
msgid ""
"Cairo has a number of features that allow you to manage your code’s "
"organization. These features, sometimes collectively referred to as the "
"_module system_, include:"
msgstr "카이로에는 코드 조직을 관리할 수 있는 여러 기능이 있습니다. 이러한 기능은 때로 _모듈 시스템_ 이라고도 불립니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:31
msgid ""
"**Packages:** A Scarb feature that lets you build, test, and share crates"
msgstr "**패키지:** 크레이트를 빌드, 테스트 및 공유할 수 있는 Scarb 기능"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:32
msgid ""
"**Crates:** A tree of modules that corresponds to a single compilation unit."
" It has a root directory, and a root module defined at the file `lib.cairo` "
"under this directory."
msgstr ""
"**크레이트:** 단일 컴파일 단위에 해당하는 모듈 트리입니다. 루트 디렉토리와 이 디렉토리 아래의 `lib.cairo` 파일에 정의된 "
"루트 모듈이 있습니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:34
msgid ""
"**Modules** and **use:** Let you control the organization and scope of "
"items."
msgstr "**모듈** 및 **사용:** 항목의 구성 및 범위를 제어할 수 있게 합니다."

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:35
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr "**경로:** 구조체, 함수 또는 모듈과 같은 항목의 이름을 지정하는 방법"

#: src/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.md:37
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""
"이 장에서는 이러한 기능을 모두 다루고, 그들이 어떻게 상호 작용하는지 논의하며, 범위를 관리하는 방법을 설명할 것입니다. 끝날 때쯤에는"
" 모듈 시스템에 대한 튼튼한 이해를 가지고 있고, 전문가처럼 범위를 다룰 수 있을 것입니다!"

#: src/ch07-01-packages-and-crates.md:3
msgid "What is a crate?"
msgstr "크레이트란 무엇인가요?"

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A crate is the smallest amount of code that the Cairo compiler considers at "
"a time. Even if you run `cairo-compile` rather than `scarb build` and pass a"
" single source code file, the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as will be discussed in the subsequent "
"sections."
msgstr ""
"크레이트는 카이로 컴파일러가 한 번에 고려하는 코드의 가장 작은 양입니다. `scarb build` 대신 `cairo-compile`을 "
"실행하고 단일 소스 코드 파일을 전달하더라도 컴파일러는 해당 파일을 크레이트로 간주합니다. 크레이트에는 모듈을 포함할 수 있으며, 모듈은"
" 크레이트와 함께 컴파일되는 다른 파일에서 정의될 수 있습니다. 이에 대해 후속 섹션에서 논의될 것입니다."

#: src/ch07-01-packages-and-crates.md:7
msgid "What is the crate root?"
msgstr "크레이트 루트란 무엇인가요?"

#: src/ch07-01-packages-and-crates.md:9
msgid ""
"The crate root is the `lib.cairo` source file that the Cairo compiler starts"
" from and makes up the root module of your crate (we’ll explain modules in "
"depth in the [“Defining Modules to Control Scope”](./ch07-02-defining-"
"modules-to-control-scope.md) section)."
msgstr ""
"크레이트 루트는 Cairo 컴파일러가 시작하는 `lib.cairo` 소스 파일이며, 크레이트의 루트 모듈을 구성합니다 (우리는 [“범위 "
"제어를 위한 모듈 정의”](./ch07-02-defining-modules-to-control-scope.md) 섹션에서 모듈을 자세히 "
"설명할 것입니다)."

#: src/ch07-01-packages-and-crates.md:11
msgid "What is a package?"
msgstr "패키지란 무엇인가요?"

#: src/ch07-01-packages-and-crates.md:13
msgid ""
"A cairo package is a bundle of one or more crates with a Scarb.toml file "
"that describes how to build those crates. This enables the splitting of code"
" into smaller, reusable parts and facilitates more structured dependency "
"management."
msgstr ""
"카이로 패키지는 하나 이상의 크레이트를 번들로 포장한 것으로, Scarb 톰톰 파일이 포함되어 있어 이 크레이트들을 어떻게 빌드할지 "
"설명합니다. 이를 통해 코드를 더 작고 재사용 가능한 부분으로 분할하고, 보다 구조화된 의존성 관리를 용이하게 합니다."

#: src/ch07-01-packages-and-crates.md:15
msgid "Creating a Package with Scarb"
msgstr "Scarb와 함께 패키지 만들기"

#: src/ch07-01-packages-and-crates.md:17
msgid ""
"You can create a new Cairo package using the scarb command-line tool. To "
"create a new package, run the following command:"
msgstr ""
"scarb 명령 줄 도구를 사용하여 새 Cairo 패키지를 만들 수 있습니다. 새 패키지를 만들려면 다음 명령을 실행하십시오:"

#: src/ch07-01-packages-and-crates.md:23
msgid ""
"This command will generate a new package directory named `my_package` with "
"the following structure:"
msgstr "이 명령은 다음 구조로 `my_package`라는 새 패키지 디렉토리를 생성합니다:"

#: src/ch07-01-packages-and-crates.md:32
msgid ""
"`src/` is the main directory where all the Cairo source files for the "
"package will be stored."
msgstr "`src/`는 패키지의 모든 카이로 소스 파일이 저장될 주요 디렉토리입니다."

#: src/ch07-01-packages-and-crates.md:33
msgid ""
"`lib.cairo` is the default root module of the crate, which is also the main "
"entry point of the package."
msgstr "`lib.cairo`는 크레이트의 기본 루트 모듈이며, 또한 패키지의 주 진입점입니다."

#: src/ch07-01-packages-and-crates.md:34
msgid ""
"`Scarb.toml` is the package manifest file, which contains metadata and "
"configuration options for the package, such as dependencies, package name, "
"version, and authors. You can find documentation about it on the [scarb "
"reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html)."
msgstr ""
"`Scarb.toml`은 패키지 매니페스트 파일로, 패키지에 대한 메타데이터와 구성 옵션을 포함하고 있습니다. 이는 의존성, 패키지 "
"이름, 버전 및 저자와 같은 정보를 담고 있습니다. 이에 대한 문서는 [scarb "
"참조](https://docs.swmansion.com/scarb/docs/reference/manifest.html)에서 찾을 수 "
"있습니다."

#: src/ch07-01-packages-and-crates.md:36
msgid ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch07-01-packages-and-crates.md:45
msgid ""
"As you develop your package, you may want to organize your code into "
"multiple Cairo source files. You can do this by creating additional `.cairo`"
" files within the `src` directory or its subdirectories."
msgstr ""
"패키지를 개발하는 과정에서 코드를 여러 개의 카이로 소스 파일로 구성하고 싶을 수 있습니다. 이를 위해 `src` 디렉토리나 그 하위 "
"디렉토리 내에 추가적인 `.cairo` 파일을 생성함으로써 이를 수행할 수 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_ that allow you to name items and the `use` keyword "
"that brings a path into scope."
msgstr ""
"이 섹션에서는 모듈 및 모듈 시스템의 다른 부분, 즉 항목을 명명할 수 있게 해주는 _paths_ 와 경로를 범위 내로 가져오는 `use`"
" 키워드에 대해 이야기할 것입니다."

#: src/ch07-02-defining-modules-to-control-scope.md:7
msgid ""
"First, we’re going to start with a list of rules for easy reference when "
"you’re organizing your code in the future. Then we’ll explain each of the "
"rules in detail."
msgstr "먼저, 앞으로 코드를 구성할 때 참고하기 쉬운 규칙 목록부터 시작할 것입니다. 그런 다음 각 규칙을 자세히 설명하겠습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:11
msgid "Modules Cheat Sheet"
msgstr "모듈 요약 시트"

#: src/ch07-02-defining-modules-to-control-scope.md:13
msgid ""
"Here we provide a quick reference on how modules, paths and the `use` "
"keyword work in the compiler, and how most developers organize their code. "
"We’ll be going through examples of each of these rules throughout this "
"chapter, but this is a great place to refer to as a reminder of how modules "
"work. You can create a new Scarb project with `scarb new backyard` to follow"
" along."
msgstr ""
"여기서는 컴파일러에서 모듈, 경로 및 `use` 키워드가 어떻게 작동하는지, 대부분의 개발자들이 코드를 어떻게 구성하는지에 대한 빠른 "
"참조를 제공합니다. 이 장 전체에서 이러한 규칙 각각에 대한 예제를 살펴보겠지만, 모듈이 작동하는 방법을 상기시키기 위한 좋은 "
"장소입니다. `scarb new backyard`를 사용하여 새로운 Scarb 프로젝트를 만들 수 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:19
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (_src/lib.cairo_) for code to compile."
msgstr ""
"**크레이트 루트에서 시작**: 크레이트를 컴파일할 때 컴파일러는 먼저 코드를 컴파일할 크레이트 루트 "
"파일(_src/lib.cairo_)을 찾습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:21
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say, you declare a “garden” module with `mod garden;`. The compiler will "
"look for the module’s code in these places:"
msgstr ""
"**모듈 선언하기**: 크레이트 루트 파일에서 새 모듈을 선언할 수 있습니다. 예를 들어 `mod garden;`와 같이 "
"\"garden\" 모듈을 선언할 수 있습니다. 컴파일러는 이 모듈의 코드를 다음 위치에서 찾습니다:"

#: src/ch07-02-defining-modules-to-control-scope.md:25
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden;`."
msgstr "`mod garden;` 다음의 세미콜론을 대체하는 중괄호 내부에서."

#: src/ch07-02-defining-modules-to-control-scope.md:28
msgid "// crate root file (src/lib.cairo)\n"
msgstr "// 루트 파일 생성 (src/lib.cairo)"

#: src/ch07-02-defining-modules-to-control-scope.md:30
msgid "// code defining the garden module goes here\n"
msgstr ""
"// 정원 모듈을 정의하는 코드는 이곳에 위치합니다"

#: src/ch07-02-defining-modules-to-control-scope.md:34
msgid "In the file _src/garden.cairo_"
msgstr "파일 _src/garden.cairo_ 에서"

#: src/ch07-02-defining-modules-to-control-scope.md:36
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in "
"_src/garden.cairo_. The compiler will look for the submodule’s code within "
"the directory named for the parent module in these places:"
msgstr ""
"**서브모듈 선언하기**: 크레이트 루트 이외의 모든 파일에서 서브모듈을 선언할 수 있습니다. 예를 들어, "
"_src/garden.cairo_ 에서 `mod vegetables;`를 선언할 수 있습니다. 컴파일러는 부모 모듈의 이름으로 된 디렉토리"
" 내에서 서브모듈의 코드를 찾습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:41
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon."
msgstr "`mod vegetables` 다음에 직접 인라인으로, 세미콜론 대신 중괄호 내에 위치합니다."

#: src/ch07-02-defining-modules-to-control-scope.md:45
msgid "// src/garden.cairo file\n"
msgstr "// src/garden.cairo 파일"

#: src/ch07-02-defining-modules-to-control-scope.md:47
msgid "// code defining the vegetables submodule goes here\n"
msgstr "// 채소 하위 모듈을 정의하는 코드가 여기에 있습니다"

#: src/ch07-02-defining-modules-to-control-scope.md:51
msgid "In the file _src/garden/vegetables.cairo_"
msgstr "파일 _src/garden/vegetables.cairo_ 에서"

#: src/ch07-02-defining-modules-to-control-scope.md:53
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, using "
"the path to the code. For example, an `Asparagus` type in the garden "
"vegetables module would be found at "
"`backyard::garden::vegetables::Asparagus`."
msgstr ""
"**모듈 내 코드로의 경로**: 한 번 모듈이 크레이트의 일부가 되면, 해당 모듈의 코드를 동일한 크레이트의 다른 곳에서 경로를 사용하여"
" 참조할 수 있습니다. 예를 들어, 정원 채소 모듈의 `Asparagus` 타입은 "
"`backyard::garden::vegetables::Asparagus`에서 찾을 수 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:57
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`backyard::garden::vegetables::Asparagus`, you can create a shortcut with "
"`use backyard::garden::vegetables::Asparagus;` and from then on you only "
"need to write `Asparagus` to make use of that type in the scope."
msgstr ""
"**`use` 키워드**: 특정 범위 내에서 `use` 키워드는 긴 경로의 반복을 줄이기 위해 항목에 대한 바로 가기를 생성합니다. "
"`backyard::garden::vegetables::Asparagus`를 참조할 수 있는 모든 범위에서 `use "
"backyard::garden::vegetables::Asparagus;`를 사용하여 바로 가기를 만들 수 있으며, 이후에는 해당 "
"범위에서 그 유형을 사용하기 위해 `Asparagus`만 작성하면 됩니다."

#: src/ch07-02-defining-modules-to-control-scope.md:63
msgid ""
"Here we create a crate named `backyard` that illustrates these rules. The "
"crate’s directory, also named `backyard`, contains these files and "
"directories:"
msgstr ""
"여기에서는 이러한 규칙을 설명하는 `backyard`라는 크레이트를 만듭니다. 크레이트의 디렉토리인 `backyard`에는 다음과 같은 "
"파일과 디렉토리가 포함되어 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:76
msgid "The crate root file in this case is _src/lib.cairo_, and it contains:"
msgstr "이 경우의 크레이트 루트 파일은 _src/lib.cairo_ 이며, 다음을 포함합니다:"

#: src/ch07-02-defining-modules-to-control-scope.md:90
msgid ""
"The `mod garden;` line tells the compiler to include the code it finds in "
"_src/garden.cairo_, which is:"
msgstr "`mod garden;` 라인은 컴파일러에게 _src/garden.cairo_ 에서 찾은 코드를 포함하도록 지시합니다."

#: src/ch07-02-defining-modules-to-control-scope.md:92
msgid "Filename: src/garden.cairo"
msgstr "파일 이름: src/garden.cairo"

#: src/ch07-02-defining-modules-to-control-scope.md:98
msgid ""
"Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is "
"included too. That code is:"
msgstr ""
"여기서 `mod vegetables;`는 _src/garden/vegetables.cairo_ 에 있는 코드도 포함된다는 것을 의미합니다."
" 해당 코드는:"

#: src/ch07-02-defining-modules-to-control-scope.md:106
msgid ""
"The line `use garden::vegetables::Asparagus;` lets us bring the `Asparagus` "
"type into scope, so we can use it in the `main` function."
msgstr ""
"`use garden::vegetables::Asparagus;` 라인은 `Asparagus` 타입을 범위 내로 가져오게 해줍니다. "
"따라서 `main` 함수에서 사용할 수 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:109
msgid ""
"Now let’s get into the details of these rules and demonstrate them in "
"action!"
msgstr "이제 이 규칙들의 세부 내용을 살펴보고, 실제로 그들을 실천해 보겠습니다!"

#: src/ch07-02-defining-modules-to-control-scope.md:111
msgid "Grouping Related Code in Modules"
msgstr "모듈 내 관련 코드 그룹화"

#: src/ch07-02-defining-modules-to-control-scope.md:113
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. As an example, let’s write a library crate that provides the "
"functionality of a restaurant. We’ll define the signatures of functions but "
"leave their bodies empty to concentrate on the organization of the code, "
"rather than the implementation of a restaurant."
msgstr ""
"\"모듈\"은 코드를 가독성 있게 구성하고 쉽게 재사용할 수 있도록 합니다. 예를 들어, 레스토랑의 기능을 제공하는 라이브러리 크레이트를"
" 작성해 보겠습니다. 함수의 시그니처를 정의하고 그 본문을 비워 코드의 구성에 집중하겠습니다. 식당의 구현이 아닌 코드의 구성에 집중할 "
"것입니다."

#: src/ch07-02-defining-modules-to-control-scope.md:119
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take"
" orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""
"식당 업계에서는 일부 부분을 '전면'이라고 하고 다른 부분을 '후면'이라고 합니다. 전면은 고객이 있는 곳이며, 이곳에는 호스트가 고객을"
" 안내하는 곳, 서버가 주문과 결제를 받는 곳, 그리고 바텐더가 음료를 만드는 곳이 포함됩니다. 후면은 요리사와 조리사가 주방에서 일하는"
" 곳, 설거지원이 청소를 하는 곳, 그리고 관리자가 행정 업무를 하는 곳입니다."

#: src/ch07-02-defining-modules-to-control-scope.md:126
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new package named `restaurant` by running `scarb "
"new restaurant`; then enter the code in Listing 7-1 into _src/lib.cairo_ to "
"define some modules and function signatures. Here’s the front of house "
"section:"
msgstr ""
"이러한 방식으로 우리의 크레이트를 구조화하기 위해, 우리는 그 함수들을 중첩된 모듈로 구성할 수 있습니다. `scarb new "
"restaurant`를 실행하여 `restaurant`라는 새 패키지를 생성한 다음, 몇 가지 모듈과 함수 시그니처를 정의하기 위해 "
"_src/lib.cairo_ 에 코드를 입력하십시오. 여기가 프론트 오브 하우스 섹션입니다:"

#: src/ch07-02-defining-modules-to-control-scope.md:150
msgid ""
"Listing 7-1: A `front_of_house` module containing other modules that then "
"contain functions"
msgstr "리스팅 7-1: 다른 모듈을 포함하고 있는 `front_of_house` 모듈, 그 안에는 함수들이 포함돼 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:153
msgid ""
"We define a module with the `mod` keyword followed by the name of the module"
" (in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 6-1—functions."
msgstr ""
"우리는 `mod` 키워드로 모듈을 정의합니다. 모듈의 이름 뒤에는 모듈의 이름 (이 경우 `front_of_house`)이 옵니다. 그런"
" 다음 모듈의 본문은 중괄호 내부에 들어갑니다. 모듈 내부에서는 다른 모듈을 배치할 수 있습니다. 이 경우 `hosting`과 "
"`serving` 모듈이 있습니다. 모듈은 또한 구조체, 열거형, 상수, 트레이트 및 6-1 목록에서와 같이 함수에 대한 정의를 보유할 "
"수 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:160
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it"
" easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""
"모듈을 사용함으로써 관련된 정의들을 함께 그룹화하고 그들이 왜 관련되어 있는지 명명할 수 있습니다. 이 코드를 사용하는 프로그래머들은 "
"모든 정의를 읽는 대신 그룹을 기반으로 코드를 탐색할 수 있어서, 자신에게 관련된 정의를 쉽게 찾을 수 있습니다. 이 코드에 새로운 "
"기능을 추가하는 프로그래머들은 프로그램을 조직화하기 위해 코드를 배치해야 할 위치를 알 수 있을 것입니다."

#: src/ch07-02-defining-modules-to-control-scope.md:166
msgid ""
"Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The "
"reason for this name is that the content of this file form a module named "
"after the crate name at the root of the crate’s module structure, known as "
"the _module tree_."
msgstr ""
"이전에 우리는 _src/lib.cairo_ 가 크레이트 루트라고 불리는 것을 언급했습니다. 이 이름의 이유는 이 파일의 내용이 크레이트 "
"이름에 따라 명명된 모듈을 형성하기 때문입니다. 이 모듈은 크레이트의 모듈 구조의 루트에 위치하며 _모듈 트리_ 로 알려져 있습니다."

#: src/ch07-02-defining-modules-to-control-scope.md:170
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "리스팅 7-2는 리스팅 7-1의 구조에 대한 모듈 트리를 보여줍니다."

#: src/ch07-02-defining-modules-to-control-scope.md:184
msgid "Listing 7-2: The module tree for the code in Listing 6-1"
msgstr "리스팅 7-2: 리스팅 6-1의 코드에 대한 모듈 트리"

#: src/ch07-02-defining-modules-to-control-scope.md:187
msgid ""
"This tree shows how some of the modules nest inside one another; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_ to each other, meaning they’re defined in the "
"same module; `hosting` and `serving` are siblings defined within "
"`front_of_house`. If module A is contained inside module B, we say that "
"module A is the _child_ of module B and that module B is the _parent_ of "
"module A. Notice that the entire module tree is rooted under the explicit "
"name of the crate `restaurant`."
msgstr ""
"이 트리는 일부 모듈이 서로 중첩되어 있는 방식을 보여줍니다. 예를 들어, `hosting`은 `front_of_house` 내부에 "
"중첩됩니다. 이 트리는 또한 일부 모듈이 서로 _형제_ 임을 보여줍니다. 즉, 같은 모듈에 정의된 것을 의미합니다. `hosting`과 "
"`serving`은 `front_of_house` 내에서 정의된 형제입니다. 모듈 A가 모듈 B 내에 포함되어 있다면, 모듈 A를 모듈 "
"B의 _자식_ 이라고 하고, 모듈 B를 모듈 A의 _부모_ 라고 합니다. 전체 모듈 트리가 명시적으로 `restaurant` 크레이트 이름 "
"아래에 뿌리를 내리는 것에 유의하십시오."

#: src/ch07-02-defining-modules-to-control-scope.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""
"모듈 트리는 컴퓨터의 파일 시스템 디렉토리 트리를 떠올리게 할 수 있습니다. 이는 매우 적절한 비교입니다! 파일 시스템의 디렉토리와 "
"마찬가지로 모듈을 사용하여 코드를 구성합니다. 그리고 디렉토리의 파일과 마찬가지로 모듈을 찾는 방법이 필요합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Cairo where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""
"카이로에게 모듈 트리에서 품목을 찾는 방법을 보여주기 위해, 파일 시스템을 탐색할 때와 같은 방식으로 경로를 사용합니다. 함수를 "
"호출하려면 해당 함수의 경로를 알아야 합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:5
msgid "A path can take two forms:"
msgstr "한 경로는 두 가지 형태를 취할 수 있습니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid ""
"An _absolute path_ is the full path starting from a crate root. The absolute"
" path begins with the crate name."
msgstr "절대 경로는 크레이트 루트부터 시작하는 전체 경로입니다. 절대 경로는 크레이트 이름으로 시작합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:8
msgid "A _relative path_ starts from the current module."
msgstr "상대 경로는 현재 모듈에서 시작합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:10
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr "절대 경로와 상대 경로 모두 두 콜론(`::`)으로 구분된 하나 이상의 식별자를 따릅니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:13
msgid ""
"To illustrate this notion let's take back our example Listing 7-1 for the "
"restaurant we used in the last chapter. We have a crate named `restaurant` "
"in which we have a module named `front_of_house` that contains a module "
"named `hosting`. The `hosting` module contains a function named "
"`add_to_waitlist`. We want to call the `add_to_waitlist` function from the "
"`eat_at_restaurant` function. We need to tell Cairo the path to the "
"`add_to_waitlist` function so it can find it."
msgstr ""
"이 개념을 설명하기 위해 지난 장에서 사용한 레스토랑 예제인 Listing 7-1을 다시 살펴보겠습니다. 우리는 "
"`front_of_house` 모듈을 포함하는 `restaurant`라는 상자가 있습니다. `front_of_house` 모듈에는 "
"`hosting`이라는 모듈이 포함되어 있습니다. `hosting` 모듈에는 `add_to_waitlist`라는 함수가 포함되어 "
"있습니다. 우리는 `eat_at_restaurant` 함수에서 `add_to_waitlist` 함수를 호출하고 싶습니다. Cairo에게 "
"`add_to_waitlist` 함수의 경로를 알려주어야 찾을 수 있습니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:36
msgid "// Absolute path\n"
msgstr "절대 경로"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:37
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:40
msgid "// ✅ Compiles\n"
msgstr "// ✅ 컴파일됨"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:39
msgid "// Relative path\n"
msgstr "상대 경로"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:44
msgid ""
"Listing 7-3: Calling the `add_to_waitlist` function using absolute and "
"relative paths"
msgstr "리스팅 7-3: 절대 경로와 상대 경로를 사용하여 `add_to_waitlist` 함수를 호출하기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:46
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function"
" is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute "
"paths start from the crate root, which you need to refer to by using the "
"crate name."
msgstr ""
"`eat_at_restaurant`에서 `add_to_waitlist` 함수를 처음 호출할 때, 우리는 절대 경로를 사용합니다. "
"`add_to_waitlist` 함수는 `eat_at_restaurant`와 동일한 크레이트에 정의되어 있습니다. 카이로에서 절대 경로는"
" 크레이트 루트부터 시작하며, 크레이트 이름을 사용하여 참조해야 합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:50
msgid ""
"The second time we call `add_to_waitlist`, we use a relative path. The path "
"starts with `front_of_house`, the name of the module defined at the same "
"level of the module tree as `eat_at_restaurant`. Here the filesystem "
"equivalent would be using the path "
"`./front_of_house/hosting/add_to_waitlist`. Starting with a module name "
"means that the path is relative to the current module."
msgstr ""
"`add_to_waitlist`를 두 번째 호출할 때 상대 경로를 사용합니다. 경로는 `front_of_house`로 시작하며, "
"`eat_at_restaurant`과 동일한 수준의 모듈 트리에 정의된 모듈의 이름입니다. 여기서 파일 시스템과 동등한 것은 경로 "
"`./front_of_house/hosting/add_to_waitlist`를 사용하는 것입니다. 모듈 이름으로 시작하면 해당 경로가 "
"현재 모듈을 기준으로 상대적임을 의미합니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:56
msgid "Starting Relative Paths with `super`"
msgstr "`super`를 사용하여 상대 경로 시작하기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:58
msgid ""
"Choosing whether to use a `super` or not is a decision you’ll make based on "
"your project, and depends on whether you’re more likely to move item "
"definition code separately from or together with the code that uses the "
"item."
msgstr ""
"`super`를 사용할지 여부를 결정하는 것은 프로젝트에 따라 달라지며, 항목 정의 코드를 별도로 이동할지 아니면 항목을 사용하는 코드와"
" 함께 이동할지에 따라 결정됩니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:77
msgid ""
"Listing 7-4: Calling a function using a relative path starting with super"
msgstr "리스트 7-4: super로 시작하는 상대 경로를 사용하여 함수 호출하기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:79
msgid ""
"Here you can see directly that you access a parent's module easily using "
"`super`, which wasn't the case previously."
msgstr ""
"여기에서는 이전에 그랬지 않았던 `super`를 사용하여 부모 모듈에 쉽게 액세스할 수 있다는 것을 직접 확인할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "`use` 키워드를 사용하여 경로를 스코프에 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. Fortunately, there’s a way to simplify this process: we can "
"create a shortcut to a path with the `use` keyword once, and then use the "
"shorter name everywhere else in the scope."
msgstr ""
"함수를 호출하기 위한 경로를 작성해야 하는 것은 불편하고 반복적일 수 있습니다. 다행히도, 이 프로세스를 간소화하는 방법이 있습니다: "
"`use` 키워드를 사용하여 경로에 대한 바로 가기를 한 번 만들고, 그 다음에는 스코프 내 어디에서든 더 짧은 이름을 사용할 수 "
"있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:5
msgid ""
"In Listing 7-5, we bring the `restaurant::front_of_house::hosting` module "
"into the scope of the `eat_at_restaurant` function so we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in"
" `eat_at_restaurant`."
msgstr ""
"리스팅 7-5에서는 `restaurant::front_of_house::hosting` 모듈을 `eat_at_restaurant` 함수의"
" 범위로 가져와 `eat_at_restaurant` 함수에서 `add_to_waitlist` 함수를 호출할 때 "
"`hosting::add_to_waitlist`만 지정하면 됩니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:13
msgid ""
"// Assuming \"front_of_house\" module is contained in a crate called \"restaurant\", as mentioned in the section \"Defining Modules to Control Scope\"\n"
"// If the path is created in the same crate, \"restaurant\" is optional in the use statement\n"
msgstr ""
"// \"front_of_house\" 모듈이 \"Defining Modules to Control Scope\" 섹션에서 언급된대로 \"restaurant\" 크레이트에 포함되어 있다고 가정합니다.\n"
"// 경로가 동일한 크레이트에 생성된 경우, \"restaurant\"는 use 문에서 선택 사항입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:25
msgid "// ✅ Shorter path\n"
msgstr "// ✅ 더 짧은 경로"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:29
msgid "Listing 7-5: Bringing a module into scope with `use`"
msgstr "리스팅 7-5: `use`를 사용하여 모듈을 스코프로 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:32
msgid ""
"Adding use and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use restaurant::front_of_house::hosting` in the "
"crate root, hosting is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root."
msgstr ""
"범위에 use와 경로를 추가하는 것은 파일 시스템에서 심볼릭 링크를 생성하는 것과 유사합니다. 크레이트 루트에 `use "
"restaurant::front_of_house::hosting`을 추가하면 해당 범위에서 hosting은 이제 유효한 이름이 되며, "
"마치 `hosting` 모듈이 크레이트 루트에 정의된 것처럼 작동합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:34
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-6 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile:"
msgstr ""
"`use`는 `use`가 발생하는 특정 범위에 대한 바로 가기만 생성한다는 점을 유의하십시오. 7-6 목록은 "
"`eat_at_restaurant` 함수를 `customer`라는 새로운 하위 모듈로 이동시키는데, 이는 `use` 문이 있는 범위와 "
"다른 범위이므로 함수 본문이 컴파일되지 않습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:56
msgid "Listing 7-6: A `use` statement only applies in the scope it’s in"
msgstr "리스팅 7-6: `use` 문은 그것이 있는 범위에만 적용됩니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:59
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr "컴파일러 오류는 `customer` 모듈 내에서 더 이상 해당 단축키가 적용되지 않음을 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:70
msgid "Creating Idiomatic `use` Paths"
msgstr "`use` 경로 만들기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:72
msgid ""
"In Listing 7-5, you might have wondered why we specified `use "
"restaurant::front_of_house::hosting` and then called "
"`hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the"
" `use` path all the way out to the `add_to_waitlist` function to achieve the"
" same result, as in Listing 7-7."
msgstr ""
"리스팅 7-5에서 `restaurant::front_of_house::hosting`을 지정한 후 `eat_at_restaurant`에서"
" `hosting::add_to_waitlist`를 호출하는 이유에 대해 궁금해 할 수 있습니다. 이것을 `use` 경로를 "
"`add_to_waitlist` 함수까지 모두 지정하여 동일한 결과를 얻기 위해 지정하지 않았을까요, 리스팅 7-7에서처럼요."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:93
msgid ""
"Listing 7-7: Bringing the `add_to_waitlist` function into scope with `use`, "
"which is unidiomatic"
msgstr "리스팅 7-7: `use`를 사용하여 `add_to_waitlist` 함수를 범위 내로 가져오는 것은 비표준적입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:96
msgid ""
"Although both Listing 7-5 and 7-7 accomplish the same task, Listing 7-5 is "
"the idiomatic way to bring a function into scope with `use`. Bringing the "
"function’s parent module into scope with `use` means we have to specify the "
"parent module when calling the function. Specifying the parent module when "
"calling the function makes it clear that the function isn’t locally defined "
"while still minimizing repetition of the full path. The code in Listing 7-7 "
"is unclear as to where `add_to_waitlist` is defined."
msgstr ""
"리스팅 7-5와 7-7 모두 동일한 작업을 수행하지만, 리스팅 7-5가 `use`를 사용하여 함수를 스코프로 가져오는 관용적인 "
"방법입니다. `use`를 사용하여 함수의 부모 모듈을 스코프로 가져오면 함수를 호출할 때 부모 모듈을 명시해야 합니다. 함수를 호출할 때"
" 부모 모듈을 명시함으로써 함수가 로컬로 정의되지 않았음을 명확히 하면서도 전체 경로의 반복을 최소화합니다. 리스팅 7-7의 코드는 "
"`add_to_waitlist`가 어디에 정의되어 있는지 명확하지 않습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:104
msgid ""
"On the other hand, when bringing in structs, enums, traits, and other items "
"with `use`, it’s idiomatic to specify the full path. Listing 7-8 shows the "
"idiomatic way to bring the core library’s `ArrayTrait` trait into the scope."
msgstr ""
"한편, `use`를 사용하여 구조체, 열거형, 트레이트 및 기타 항목을 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 7-8 "
"목록은 코어 라이브러리의 `ArrayTrait` 트레이트를 범위 내로 가져오는 관용적인 방법을 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:115
msgid "Listing 7-8: Bringing `ArrayTrait` into scope in an idiomatic way"
msgstr "리스팅 7-8: `ArrayTrait`을 관용적인 방식으로 범위에 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:118
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged in the Rust community, and folks have gotten used to reading and"
" writing Rust code this way. As Cairo shares many idioms with Rust, we "
"follow this convention as well."
msgstr ""
"이 속담 뒤에 강력한 이유는 없습니다: 이것은 러스트 커뮤니티에서 나타난 관례일 뿐이며, 사람들은 러스트 코드를 읽고 쓰는 데 이 방식에"
" 익숙해졌습니다. 카이로는 러스트와 많은 관용구를 공유하기 때문에 우리도 이 관례를 따릅니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:122
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Cairo doesn’t allow that."
msgstr ""
"이 속담의 예외는 Cairo가 그것을 허용하지 않기 때문에 `use` 문으로 동일한 이름을 가진 두 항목을 범위로 가져오는 경우입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid "Providing New Names with the `as` Keyword"
msgstr "`as` 키워드를 사용하여 새로운 이름 제공하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:127
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and"
" a new local name, or _alias_, for the type. Listing 7-9 shows how you can "
"rename an import with `as`:"
msgstr ""
"`use`를 사용하여 동일한 이름의 두 가지 유형을 동일한 범위로 가져오는 문제에 대한 또 다른 해결책이 있습니다: 경로 뒤에 `as`와"
" 새로운 로컬 이름 또는 _별칭_ 을 지정할 수 있습니다. 7-9 목록은 `as`를 사용하여 가져온 항목의 이름을 바꾸는 방법을 "
"보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:137
msgid "// ArrayTrait was renamed to Arr\n"
msgstr "ArrayTrait가 Arr로 이름이 변경되었습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:142
msgid ""
"Listing 7-9: Renaming a trait when it’s brought into scope with the `as` "
"keyword"
msgstr "리스트 7-9: `as` 키워드를 사용하여 특성을 스코프로 가져올 때 특성의 이름을 변경하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:145
msgid ""
"Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now "
"access the trait's methods with the `Arr` identifier."
msgstr ""
"여기서 우리는 `ArrayTrait`을 `Arr` 별칭과 함께 스코프로 가져왔습니다. 이제 `Arr` 식별자를 사용하여 트레이트의 "
"메소드에 접근할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:147
msgid "Importing multiple items from the same module"
msgstr "동일한 모듈에서 여러 항목을 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:149
msgid ""
"When you want to import multiple items (like functions, structs or enums) "
"from the same module in Cairo, you can use curly braces `{}` to list all of "
"the items that you want to import. This helps to keep your code clean and "
"easy to read by avoiding a long list of individual use statements."
msgstr ""
"카이로에서 동일한 모듈에서 여러 항목(함수, 구조체 또는 열거형과 같은)을 가져오고 싶을 때는 중괄호 `{}`를 사용하여 가져오고 싶은 "
"모든 항목을 나열할 수 있습니다. 이렇게 하면 개별적인 사용 문을 길게 나열하는 것을 피하고 코드를 깔끔하고 읽기 쉽게 유지할 수 "
"있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid ""
"The general syntax for importing multiple items from the same module is:"
msgstr "동일한 모듈에서 여러 항목을 가져오는 일반 구문은 다음과 같습니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:160
msgid ""
"Here is an example where we import three structures from the same module:"
msgstr "여기 같은 모듈에서 세 개의 구조체를 가져오는 예제가 있습니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:163
msgid ""
"// Assuming we have a module called `shapes` with the structures `Square`, "
"`Circle`, and `Triangle`.\n"
msgstr "// `shapes`라는 모듈에 `Square`, `Circle`, 그리고 `Triangle` 구조체가 있다고 가정합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:181
msgid ""
"// We can import the structures `Square`, `Circle`, and `Triangle` from the "
"`shapes` module like this:\n"
msgstr ""
"우리는 `shapes` 모듈에서 `Square`, `Circle`, 그리고 `Triangle` 구조체를 이렇게 가져올 수 있습니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.\n"
msgstr "이제 우리는 코드에서 `Square`, `Circle`, 그리고 `Triangle`을 직접 사용할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:189
#: src/ch08-02-traits-in-cairo.md:346 src/ch08-02-traits-in-cairo.md:350
#: src/ch08-02-traits-in-cairo.md:359
#: src/ch99-03-security-considerations.md:143
#: src/ch99-03-security-considerations.md:148
msgid "// ...\n"
msgstr ""
"I'm sorry, but it seems like you have not provided any English text for me "
"to translate to Korean. Please provide the text you would like me to "
"translate."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:194
msgid "Listing 7-10: Importing multiple items from the same module"
msgstr "리스트 7-10: 동일한 모듈에서 여러 항목 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
msgid "Re-exporting Names in Module Files"
msgstr "모듈 파일에서 이름 재내보내기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:198
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope can be imported as if it had been defined in that code’s "
"scope. This technique is called _re-exporting_ because we’re bringing an "
"item into scope, but also making that item available for others to bring "
"into their scope."
msgstr ""
"`use` 키워드를 사용하여 이름을 스코프에 가져올 때, 새로운 스코프에서 사용 가능한 이름은 해당 코드의 스코프에서 정의된 것처럼 "
"가져올 수 있습니다. 이 기술은 _재내보내기(re-exporting)_ 라고 불리며, 우리는 항목을 스코프에 가져오면서 그 항목을 다른 "
"사람들이 자신의 스코프로 가져올 수 있도록 만드는 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:203
msgid ""
"For example, let's re-export the `add_to_waitlist` function in the "
"restaurant example:"
msgstr "예를 들어, 레스토랑 예제에서 `add_to_waitlist` 함수를 다시 내보내 봅시다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:221
msgid ""
"Listing 7-11: Making a name available for any code to use from a new scope "
"with `pub use`"
msgstr "리스팅 7-11: `pub use`를 사용하여 새로운 범위에서 모든 코드가 사용할 수 있는 이름을 만드는 방법"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:224
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`. Now that this "
"`use` has re-exported the `hosting` module from the root module, external "
"code can now use the path `restaurant::hosting::add_to_waitlist()` instead."
msgstr ""
"이 변경 이전에는 외부 코드가 `restaurant::front_of_house::hosting::add_to_waitlist()` "
"경로를 사용하여 `add_to_waitlist` 함수를 호출해야 했습니다. 이제 이 `use`가 루트 모듈에서 `hosting` 모듈을 "
"다시 내보냈기 때문에, 외부 코드는 이제 `restaurant::hosting::add_to_waitlist()` 경로를 사용할 수 "
"있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:230
msgid ""
"Re-exporting is useful when the internal structure of your code is different"
" from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library."
msgstr ""
"재수출은 코드의 내부 구조가 프로그래머가 도메인을 생각하는 방식과 다를 때 유용합니다. 예를 들어, 이 레스토랑 비유에서 레스토랑을 "
"운영하는 사람들은 \"앞집\"과 \"뒷집\"에 대해 생각하지만 레스토랑을 방문하는 고객들은 아마도 그 용어로 레스토랑의 부분을 생각하지 "
"않을 것입니다. `use`를 사용하면 코드를 한 구조로 작성하고 다른 구조를 노출시킬 수 있습니다. 이렇게 함으로써 라이브러리를 사용하는"
" 프로그래머와 라이브러리를 호출하는 프로그래머들을 위해 우리의 라이브러리를 잘 구성할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:239
msgid "Using External Packages in Cairo with Scarb"
msgstr "Scarb를 사용하여 카이로에서 외부 패키지 사용하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:241
msgid ""
"You might need to use external packages to leverage the functionality "
"provided by the community. To use an external package in your project with "
"Scarb, follow these steps:"
msgstr ""
"커뮤니티에서 제공하는 기능을 활용하기 위해 외부 패키지를 사용해야 할 수도 있습니다. Scarb를 사용하여 프로젝트에 외부 패키지를 "
"사용하려면 다음 단계를 따르세요:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"The dependencies system is still a work in progress. You can check the "
"official "
"[documentation](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)."
msgstr ""
"의존성 시스템은 아직 진행 중인 작업입니다. 공식 "
"[문서](https://docs.swmansion.com/scarb/docs/guides/dependencies.html)를 확인할 수 "
"있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr ""
"지금까지 이 장의 모든 예시는 한 파일에 여러 모듈을 정의했습니다. 모듈이 커지면 코드를 쉽게 탐색하기 위해 그 정의를 별도의 파일로 "
"옮기고 싶을 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-11 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.cairo_."
msgstr ""
"예를 들어, 여러 레스토랑 모듈을 가진 코드인 리스트 7-11에서 시작해 보겠습니다. 모듈을 모두 크레이트 루트 파일에 정의하는 대신 "
"파일로 추출할 것입니다. 이 경우 크레이트 루트 파일은 _src/lib.cairo_ 입니다."

#: src/ch07-05-separating-modules-into-different-files.md:12
msgid ""
"First, we’ll extract the `front_of_house` module to its own file. Remove the"
" code inside the curly brackets for the `front_of_house` module, leaving "
"only the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains"
" the code shown in Listing 7-12. Note that this won’t compile until we "
"create the _src/front_of_house.cairo_ file in Listing 7-13."
msgstr ""
"먼저 `front_of_house` 모듈을 별도의 파일로 추출합니다. `front_of_house` 모듈 내 중괄호 안의 코드를 제거하여"
" `mod front_of_house;` 선언만 남겨두어야 합니다. 이렇게 하면 _src/lib.cairo_ 파일에 7-12 목록에 "
"표시된 코드가 포함됩니다. 7-13 목록에 있는 _src/front_of_house.cairo_ 파일을 생성하기 전까지는 컴파일되지 "
"않음을 유의하세요."

#: src/ch07-05-separating-modules-into-different-files.md:30
msgid ""
"Listing 7-12: Declaring the `front_of_house` module whose body will be in "
"_src/front_of_house.cairo_"
msgstr ""
"리스팅 7-12: `front_of_house` 모듈을 선언하고, 해당 내용은 _src/front_of_house.cairo_ 에 있을 "
"것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.cairo_, as shown in Listing 7-13. The compiler knows to "
"look in this file because it came across the module declaration in the crate"
" root with the name `front_of_house`."
msgstr ""
"다음으로, 중괄호 안에 있던 코드를 새 파일에 _src/front_of_house.cairo_ 라는 이름으로 넣어주세요. 이는 7-13 "
"목록에 나와 있는 것처럼 하면 됩니다. 컴파일러는 `front_of_house`라는 이름을 가진 크레이트 루트에서 모듈 선언을 만나 "
"파일을 찾을 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:38
#: src/ch07-05-separating-modules-into-different-files.md:66
msgid "Filename: src/front_of_house.cairo"
msgstr "파일 이름: src/front_of_house.cairo"

#: src/ch07-05-separating-modules-into-different-files.md:46
msgid ""
"Listing 7-13: Definitions inside the `front_of_house` module in "
"_src/front_of_house.cairo_"
msgstr "리스팅 7-13: _src/front_of_house.cairo_ 파일 내 `front_of_house` 모듈 안의 정의"

#: src/ch07-05-separating-modules-into-different-files.md:49
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve"
" put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module Tree”](ch06-03-paths-for-"
"referring-to-an-item-in-the-module-tree.html)"
msgstr ""
"주의하세요. 모듈 트리에서 `mod` 선언을 사용하여 파일을 _한 번_ 만로드해야합니다. 컴파일러가 파일이 프로젝트의 일부임을 알고 있고 "
"(그리고 `mod` 문을 넣은 위치 때문에 코드가 있는 모듈 트리의 위치를 알고 있음), 프로젝트의 다른 파일은 로드된 파일의 코드를 "
"선언된 위치로 가는 경로를 사용하여 참조해야합니다. [“모듈 트리에서 항목을 참조하는 경로”](ch06-03-paths-for-"
"referring-to-an-item-in-the-module-tree.html)에서 다루었습니다."

#: src/ch07-05-separating-modules-into-different-files.md:54
msgid ""
" section. In other words, `mod` is _not_ an “include” operation that you may"
" have seen in other programming languages."
msgstr "다른 말로, `mod`는 다른 프로그래밍 언어에서 볼 수 있는 \"포함\" 연산이 아닙니다."

#: src/ch07-05-separating-modules-into-different-files.md:58
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case "
"_src/front_of_house/_."
msgstr ""
"다음으로, `hosting` 모듈을 별도의 파일로 추출할 것입니다. 이 과정은 `hosting`이 루트 모듈이 아닌 "
"`front_of_house`의 하위 모듈이기 때문에 약간 다릅니다. 우리는 `hosting`을 모듈 트리의 조상에 따라 명명된 새 "
"디렉토리에 배치할 것입니다. 이 경우에는 _src/front_of_house/_ 로 이름 지어진 디렉토리에 `hosting` 파일을 배치할"
" 것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:63
msgid ""
"To start moving `hosting`, we change _src/front_of_house.cairo_ to contain "
"only the declaration of the `hosting` module:"
msgstr ""
"`hosting`를 시작하려면 _src/front_of_house.cairo_ 를 `hosting` 모듈의 선언만 포함하도록 변경합니다."

#: src/ch07-05-separating-modules-into-different-files.md:72
msgid ""
"Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ "
"to contain the definitions made in the `hosting` module:"
msgstr ""
"그럼 _src/front_of_house_ 디렉토리를 만들고 `hosting` 모듈에서 만든 정의를 담은 _hosting.cairo_ "
"파일을 생성합니다."

#: src/ch07-05-separating-modules-into-different-files.md:75
msgid "Filename: src/front_of_house/hosting.cairo"
msgstr "파일 이름: src/front_of_house/hosting.cairo"

#: src/ch07-05-separating-modules-into-different-files.md:81
msgid ""
"If we instead put _hosting.cairo_ in the _src_ directory, the compiler would"
" expect the _hosting.cairo_ code to be in a `hosting` module declared in the"
" crate root, and not declared as a child of the `front_of_house` module. The"
" compiler’s rules for which files to check for which modules’ code means the"
" directories and files more closely match the module tree."
msgstr ""
"만약 대신 _hosting.cairo_ 를 _src_ 디렉토리에 넣는다면, 컴파일러는 _hosting.cairo_ 코드가 크레이트 루트에서"
" 선언된 `hosting` 모듈에 있어야 하며 `front_of_house` 모듈의 하위로 선언되어서는 안 된다고 예상할 것입니다. "
"컴파일러가 어떤 모듈의 코드를 어떤 파일에서 확인해야 하는지에 대한 규칙은 디렉토리와 파일이 모듈 트리와 더 밀접하게 일치하도록 합니다."

#: src/ch07-05-separating-modules-into-different-files.md:87
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr ""
"우리는 각 모듈의 코드를 별도의 파일로 옮겼고, 모듈 트리는 그대로 유지되었습니다. `eat_at_restaurant`에서의 함수 호출은"
" 수정 없이 작동할 것이며, 정의는 다른 파일에 존재하더라도 문제 없이 작동합니다. 이 기술을 사용하면 모듈이 커지면 새 파일로 모듈을 "
"이동할 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"Note that the `use restaurant::front_of_house::hosting` statement in "
"_src/lib.cairo_ also hasn’t changed, nor does `use` have any impact on what "
"files are compiled as part of the crate. The `mod` keyword declares modules,"
" and Cairo looks in a file with the same name as the module for the code "
"that goes into that module."
msgstr ""
"_src/lib.cairo_ 파일의 `use restaurant::front_of_house::hosting` 문장도 변경되지 "
"않았습니다. `use`는 크레이트의 일부로 컴파일되는 파일에 영향을 미치지 않습니다. `mod` 키워드는 모듈을 선언하며, Cairo는 "
"모듈 이름과 동일한 이름을 가진 파일에서 해당 모듈에 들어가는 코드를 찾습니다."

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"Cairo lets you split a package into multiple crates and a crate into modules"
" so you can refer to items defined in one module from another module. You "
"can do this by specifying absolute or relative paths. These paths can be "
"brought into scope with a `use` statement so you can use a shorter path for "
"multiple uses of the item in that scope. Module code is public by default."
msgstr ""
"카이로는 패키지를 여러 개의 크레이트로 분할하고 크레이트를 모듈로 분할할 수 있어서 한 모듈에서 정의된 항목을 다른 모듈에서 참조할 수 "
"있습니다. 이를 절대 경로 또는 상대 경로를 지정하여 수행할 수 있습니다. 이러한 경로는 `use` 문으로 스코프 내에서 항목을 여러 번"
" 사용할 때 더 짧은 경로를 사용할 수 있도록 가져올 수 있습니다. 모듈 코드는 기본적으로 공개(public)입니다."

#: src/ch08-00-generic-types-and-traits.md:1
msgid "Generic Types and Traits"
msgstr "일반 유형 및 특성"

#: src/ch08-00-generic-types-and-traits.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Cairo, one such tool is generics: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr ""
"모든 프로그래밍 언어에는 개념의 중복을 효과적으로 처리하는 도구가 있습니다. 카이로에서는 이러한 도구 중 하나가 제네릭입니다: 구체적인 "
"유형이나 다른 속성을 대신하는 추상적인 대리인들입니다. 우리는 컴파일하고 코드를 실행할 때 그 자리에 무엇이 올지 모르는 제네릭의 "
"동작이나 다른 제네릭과의 관련을 표현할 수 있습니다."

#: src/ch08-00-generic-types-and-traits.md:5
msgid ""
"Functions, structs, enums and traits can incorporate generic types as part "
"of their definition instead of a concrete type like `u32` or "
"`ContractAddress`."
msgstr ""
"함수, 구조체, 열거형 및 트레이트는 `u32` 또는 `ContractAddress`와 같은 구체적인 유형 대신에 정의의 일부로 제네릭 "
"유형을 포함할 수 있습니다."

#: src/ch08-00-generic-types-and-traits.md:7
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication."
msgstr "제네릭을 사용하면 특정 유형을 대체하여 여러 유형을 나타내는 자리 표시자로 코드 중복을 제거할 수 있습니다."

#: src/ch08-00-generic-types-and-traits.md:9
msgid ""
"For each concrete type that replaces a generic type the compiler creates a "
"new definition, reducing development time for the programmer, but code "
"duplication at compile level still exists. This may be of importance if you "
"are writing Starknet contracts and using a generic for multiple types which "
"will cause contract size to increment."
msgstr ""
"각각의 일반 타입을 대체하는 구체적인 타입마다 컴파일러는 새로운 정의를 생성하며, 이는 프로그래머의 개발 시간을 줄이지만 컴파일 레벨에서"
" 코드 중복이 여전히 존재합니다. 이는 Starknet 계약을 작성하고 여러 타입에 대해 일반 타입을 사용하는 경우 계약 크기가 증가할 "
"수 있기 때문에 중요할 수 있습니다."

#: src/ch08-00-generic-types-and-traits.md:11
msgid ""
"Then you’ll learn how to use traits to define behavior in a generic way. You"
" can combine traits with generic types to constrain a generic type to accept"
" only those types that have a particular behavior, as opposed to just any "
"type."
msgstr ""
"그럼 특성을 사용하여 행동을 일반적인 방식으로 정의하는 방법을 배우게 됩니다. 특성을 일반 타입과 결합하여 특정 행동을 가진 타입만 "
"허용하도록 제네릭 타입을 제한할 수 있습니다. 그냥 어떤 타입이든 허용하는 것과는 달리 특정 행동을 가진 타입만 허용하도록 할 수 "
"있습니다."

#: src/ch08-01-generic-data-types.md:3
msgid ""
"We use generics to create definitions for item declarations, such as structs"
" and functions, which we can then use with many different concrete data "
"types. In Cairo we can use generics when defining functions, structs, enums,"
" traits, implementations and methods! In this chapter we are going to take a"
" look at how to effectively use generic types with all of them."
msgstr ""
"우리는 제네릭을 사용하여 구조체 및 함수와 같은 항목 선언을 위한 정의를 만들고, 그런 다음 여러 가지 다른 구체적인 데이터 유형과 함께"
" 사용할 수 있습니다. 카이로에서는 함수, 구조체, 열거형, 트레이트, 구현 및 메서드를 정의할 때 제네릭을 사용할 수 있습니다! 이 "
"장에서는 이러한 모든 것들과 효과적으로 제네릭 유형을 사용하는 방법을 살펴볼 것입니다."

#: src/ch08-01-generic-data-types.md:7
msgid ""
"When defining a function that uses generics, we place the generics in the "
"function signature, where we would usually specify the data types of the "
"parameter and return value. For example, imagine we want to create a "
"function which given two `Array` of items, will return the largest one. If "
"we need to perform this operation for lists of different types, then we "
"would have to redefine the function each time. Luckily we can implement the "
"function once using generics and move on to other tasks."
msgstr ""
"제네릭을 사용하는 함수를 정의할 때, 일반적으로 매개변수와 반환 값의 데이터 유형을 지정하는 곳에 제네릭을 배치합니다. 예를 들어, 두 "
"개의 항목 'Array'를 제공하면 더 큰 항목을 반환하는 함수를 만들고 싶다고 가정해보십시오. 서로 다른 유형의 목록에 대해 이 작업을"
" 수행해야 한다면 매번 함수를 재정의해야 합니다. 다행히도 우리는 한 번의 제네릭을 사용하여 함수를 구현하고 다른 작업으로 넘어갈 수 "
"있습니다."

#: src/ch08-01-generic-data-types.md:10
msgid "// Specify generic type T between the angulars\n"
msgstr "// 각괄호 사이에 일반 유형 T를 지정합니다."

#: src/ch08-01-generic-data-types.md:31
msgid ""
"// There is no need to specify the concrete type of T because\n"
"    // it is inferred by the compiler\n"
msgstr "// 컴파일러에 의해 추론되기 때문에 T의 구체적인 유형을 지정할 필요가 없습니다."

#: src/ch08-01-generic-data-types.md:37
msgid ""
"The `largest_list` function compares two lists of the same type and returns "
"the one with more elements and drops the other. If you compile the previous "
"code, you will notice that it will fail with an error saying that there are "
"no traits defined for dropping an array of a generic type. This happens "
"because the compiler has no way to guarantee that an `Array<T>` is droppable"
" when executing the `main` function. In order to drop an array of `T`, the "
"compiler must first know how to drop `T`. This can be fixed by specifying in"
" the function signature of `largest_list` that `T` must implement the drop "
"trait. The correct function definition of `largest_list` is as follows:"
msgstr ""
"`largest_list` 함수는 동일한 유형의 두 목록을 비교하고 요소가 더 많은 것을 반환하고 다른 것을 삭제합니다. 이전 코드를 "
"컴파일하면, 일반 유형의 배열을 삭제하는 데 정의된 특성이 없다는 오류가 발생하여 실패한다는 것을 알 수 있습니다. 이는 컴파일러가 "
"`main` 함수를 실행할 때 `Array<T>`가 삭제 가능하다는 것을 보장할 방법이 없기 때문에 발생합니다. `T`의 배열을 "
"삭제하려면 컴파일러가 먼저 `T`를 삭제하는 방법을 알아야 합니다. 이는 `largest_list` 함수의 함수 서명에서 `T`가 삭제 "
"특성을 구현해야 한다고 지정하여 수정할 수 있습니다. `largest_list`의 올바른 함수 정의는 다음과 같습니다:"

#: src/ch08-01-generic-data-types.md:49
msgid ""
"The new `largest_list` function includes in its definition the requirement "
"that whatever generic type is placed there, it must be droppable. The `main`"
" function remains unchanged, the compiler is smart enough to deduce which "
"concrete type is being used and if it implements the `Drop` trait."
msgstr ""
"새로운 `largest_list` 함수에는 제네릭 타입이 무엇이든 드롭 가능해야 한다는 요구 사항이 포함되어 있습니다. `main` "
"함수는 변경되지 않았으며, 컴파일러는 사용되는 구체적인 타입이 무엇이며 `Drop` 트레이트를 구현했는지를 추론하는 데 충분히 "
"똑똑합니다."

#: src/ch08-01-generic-data-types.md:51
msgid "Constraints for Generic Types"
msgstr "일반 유형에 대한 제약 조건"

#: src/ch08-01-generic-data-types.md:53
msgid ""
"When defining generic types, it is useful to have information about them. "
"Knowing which traits a generic type implements allow us to use them more "
"effectively in a functions logic at the cost of constraining the generic "
"types that can be used with the function. We saw an example of this "
"previously by adding the `TDrop` implementation as part of the generic "
"arguments of `largest_list`. While `TDrop` was added to satisfy the "
"compiler's requirements, we can also add constraints to benefit our function"
" logic."
msgstr ""
"일반 유형을 정의할 때, 그들에 대한 정보를 가지고 있는 것이 유용합니다. 일반 유형이 구현하는 특성을 알면 함수 논리에서 더 효과적으로"
" 사용할 수 있지만, 함수와 함께 사용할 수 있는 일반 유형을 제한하는 비용이 발생합니다. 이전에 `largest_list`의 일반 "
"인수로 `TDrop` 구현을 추가함으로써 이에 대한 예를 볼 수 있었습니다. `TDrop`은 컴파일러의 요구 사항을 충족시키기 위해 "
"추가되었지만, 함수 논리에 이점을 얻기 위해 제약 조건을 추가할 수도 있습니다."

#: src/ch08-01-generic-data-types.md:55
msgid ""
"Imagine that we want, given a list of elements of some generic type `T`, to "
"find the smallest element among them. Initially, we know that for an element"
" of type `T` to be comparable, it must implement the `PartialOrd` trait. The"
" resulting function would be:"
msgstr ""
"일반적인 유형 `T`의 요소 목록이 주어졌을 때, 그 중에서 가장 작은 요소를 찾고 싶다고 상상해보십시오. 처음에는 유형 `T`의 요소가"
" 비교 가능하려면 `PartialOrd` 트레이트를 구현해야 한다는 것을 알고 있습니다. 결과 함수는 다음과 같을 것입니다:"

#: src/ch08-01-generic-data-types.md:58
msgid ""
"// Given a list of T get the smallest one.\n"
"// The PartialOrd trait implements comparison operations for T\n"
msgstr ""
"// T 목록이 주어지면 가장 작은 값을 가져옵니다.\n"
"// PartialOrd 트레이트는 T에 대한 비교 연산을 구현합니다."

#: src/ch08-01-generic-data-types.md:62
msgid ""
"// This represents the smallest element through the iteration\n"
"    // Notice that we use the desnap (*) operator\n"
msgstr ""
"// 이는 반복을 통해 가장 작은 요소를 나타냅니다\n"
"    // desnap (*) 연산자를 사용한다는 점에 유의하세요"

#: src/ch08-01-generic-data-types.md:66
msgid "// The index we will use to move through the list\n"
msgstr "// 우리가 목록을 통해 이동하는 데 사용할 인덱스"

#: src/ch08-01-generic-data-types.md:69
msgid "// Iterate through the whole list storing the smallest\n"
msgstr "전체 목록을 반복하면서 가장 작은 값을 저장합니다."

#: src/ch08-01-generic-data-types.md:84
msgid ""
"// We need to specify that we are passing a snapshot of `list` as an "
"argument\n"
msgstr "우리는 `list`의 스냅샷을 인수로 전달하고 있다는 것을 명시해야 합니다."

#: src/ch08-01-generic-data-types.md:90
msgid ""
"The `smallest_element` function uses a generic type `T` that implements the "
"`PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and "
"returns a copy of the smallest element. Because the parameter is of type "
"`@Array<T>`, we no longer need to drop it at the end of the execution and so"
" we don't require to implement the `Drop` trait for `T` as well. Why it does"
" not compile then?"
msgstr ""
"`smallest_element` 함수는 `PartialOrd` 트레이트를 구현하는 일반 타입 `T`를 사용하며, `Array<T>`의 "
"스냅샷을 매개변수로 사용하고 가장 작은 요소의 복사본을 반환합니다. 매개변수가 `@Array<T>` 타입이기 때문에 실행이 끝날 때 더 "
"이상 삭제할 필요가 없으므로 `T`에 대해 `Drop` 트레이트를 구현할 필요가 없습니다. 그렇다면 왜 컴파일되지 않을까요?"

#: src/ch08-01-generic-data-types.md:92
msgid ""
"When indexing on `list`, the value results in a snap of the indexed element,"
" unless `PartialOrd` is implemented for `@T` we need to desnap the element "
"using `*`. The `*` operation requires a copy from `@T` to`T`, which means "
"that `T` needs to implement the `Copy` trait. After copying an element of "
"type `@T` to `T`, there are now variables with type `T` that need to be "
"dropped, requiring for `T` to implement the `Drop` trait as well. We must "
"then add both `Drop` and `Copy` traits implementation for the function to be"
" correct. After updating the`smallest_element` function the resulting code "
"would be:"
msgstr ""
"`list`에 대한 인덱싱을 할 때, 값은 인덱스된 요소의 스냅으로 나타납니다. 단, `@T`에 대한 `PartialOrd`가 구현되어 "
"있지 않은 경우에는 `*`를 사용하여 요소를 스냅해제해야 합니다. `*` 연산은 `@T`에서 `T`로의 복사를 필요로 하며, 이는 "
"`T`가 `Copy` 트레이트를 구현해야 함을 의미합니다. `@T` 유형의 요소를 `T`로 복사한 후, 이제 `T` 유형의 변수가 "
"생성되어야 하며, 이는 `T`가 `Drop` 트레이트를 구현해야 함을 의미합니다. 따라서 함수가 올바르게 작동하려면 `Drop`와 "
"`Copy` 트레이트 모두를 구현해야 합니다. `smallest_element` 함수를 업데이트한 후, 결과 코드는 다음과 같을 "
"것입니다:"

#: src/ch08-01-generic-data-types.md:112
msgid "Anonymous Generic Implementation Parameter (`+` operator)"
msgstr "익명 일반 구현 매개변수 (`+` 연산자)"

#: src/ch08-01-generic-data-types.md:114
msgid ""
"Until now, we have always specified a name for each implementation of the "
"required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for "
"`Drop<T>`, and `TCopy` for `Copy<T>`."
msgstr ""
"지금까지, 우리는 필요한 일반적 특성의 각 구현에 대해 항상 이름을 지정해 왔습니다: `PartialOrd<T>`에 대한 "
"`TPartialOrd`, `Drop<T>`에 대한 `TDrop`, 그리고 `Copy<T>`에 대한 `TCopy`."

#: src/ch08-01-generic-data-types.md:116
msgid ""
"However, most of the time, we don't use the implementation in the function "
"body; we only use it as a constraint. In these cases, we can use the `+` "
"operator to specify that the generic type must implement a trait without "
"naming the implementation. This is referred to as an _anonymous generic "
"implementation parameter_."
msgstr ""
"그러나 대부분의 경우, 우리는 함수 본문에서 구현을 사용하지 않습니다; 우리는 그것을 제약 조건으로만 사용합니다. 이러한 경우에는 제네릭"
" 타입이 특성을 구현해야 한다는 것을 명시하기 위해 `+` 연산자를 사용할 수 있습니다. 이를 _익명 제네릭 구현 매개변수_ 라고 "
"합니다."

#: src/ch08-01-generic-data-types.md:118
msgid ""
"For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: "
"PartialOrd<T>`."
msgstr "예를 들어, `+PartialOrd<T>`은 `impl TPartialOrd: PartialOrd<T>`과 동등합니다."

#: src/ch08-01-generic-data-types.md:120
msgid "We can rewrite the `smallest_element` function signature as follows:"
msgstr "우리는 `smallest_element` 함수 서명을 다음과 같이 다시 작성할 수 있습니다:"

#: src/ch08-01-generic-data-types.md:138
msgid "Structs"
msgstr "구조체"

#: src/ch08-01-generic-data-types.md:140
msgid ""
"We can also define structs to use a generic type parameter for one or more "
"fields using the `<>` syntax, similar to function definitions. First we "
"declare the name of the type parameter inside the angle brackets just after "
"the name of the struct. Then we use the generic type in the struct "
"definition where we would otherwise specify concrete data types. The next "
"code example shows the definition `Wallet<T>` which has a `balance` field of"
" type `T`."
msgstr ""
"우리는 또한 `<>` 구문을 사용하여 하나 이상의 필드에 대한 일반 유형 매개변수를 사용하도록 구조체를 정의할 수 있습니다. 이는 함수 "
"정의와 유사합니다. 먼저 우리는 구조체의 이름 바로 뒤에 꺾쇠 괄호 내에 유형 매개변수의 이름을 선언합니다. 그런 다음 우리는 일반 "
"유형을 사용하여 구조체 정의를 하며, 그 곳에 구체적인 데이터 유형을 지정했던 자리에 일반 유형을 사용합니다. 다음 코드 예제는 "
"`Wallet<T>`라는 정의를 보여줍니다. 이 정의는 `balance` 필드가 `T` 유형임을 가지고 있습니다."

#: src/ch08-01-generic-data-types.md:154
msgid ""
"The above code derives the `Drop` trait for the `Wallet` type automatically."
" It is equivalent to writing the following code:"
msgstr "위의 코드는 `Wallet` 타입에 대한 `Drop` 트레이트를 자동으로 파생합니다. 다음 코드를 작성하는 것과 동일합니다:"

#: src/ch08-01-generic-data-types.md:168
msgid ""
"We avoid using the `derive` macro for `Drop` implementation of `Wallet` and "
"instead define our own `WalletDrop` implementation. Notice that we must "
"define, just like functions, an additional generic type for `WalletDrop` "
"saying that `T` implements the `Drop` trait as well. We are basically saying"
" that the struct `Wallet<T>` is droppable as long as `T` is also droppable."
msgstr ""
"`Wallet`의 `Drop` 구현에 `derive` 매크로를 사용하지 않고 대신 우리만의 `WalletDrop` 구현을 정의합니다. "
"함수와 마찬가지로 `WalletDrop`에 대한 추가적인 제네릭 타입을 정의해야 함을 주목하세요. 이는 `T`가 `Drop` 트레이트를 "
"구현해야 한다는 것을 말합니다. 기본적으로 `Wallet<T>` 구조체가 `T`도 삭제 가능한 경우에만 삭제 가능하다고 말하는 것입니다."

#: src/ch08-01-generic-data-types.md:170
msgid ""
"Finally, if we want to add a field to `Wallet` representing its address and "
"we want that field to be different than `T` but generic as well, we can "
"simply add another generic type between the `<>`:"
msgstr ""
"마지막으로, `Wallet`에 주소를 나타내는 필드를 추가하고 그 필드를 `T`와 다르게 하고 싶지만 제네릭하게 유지하고 싶다면, `< "
">` 사이에 또 다른 제네릭 타입을 간단히 추가할 수 있습니다:"

#: src/ch08-01-generic-data-types.md:184
msgid ""
"We add to `Wallet` struct definition a new generic type `U` and then assign "
"this type to the new field member `address`. Notice that the derive "
"attribute for the `Drop` trait works for `U` as well."
msgstr ""
"`Wallet` 구조체 정의에 새로운 제네릭 타입 `U`를 추가하고 이 타입을 새로운 필드 멤버 `address`에 할당합니다. "
"`Drop` 트레이트에 대한 derive 속성이 `U`에도 작동한다는 점에 유의하세요."

#: src/ch08-01-generic-data-types.md:188
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. For example the `Option<T>` enum provided by the Cairo core "
"library:"
msgstr ""
"우리는 구조체와 마찬가지로 열거형을 정의하여 변형에 일반 데이터 유형을 보유할 수 있습니다. 예를 들어, 카이로 코어 라이브러리에서 "
"제공하는 `Option<T>` 열거형:"

#: src/ch08-01-generic-data-types.md:197
msgid ""
"The `Option<T>` enum is generic over a type `T` and has two variants: "
"`Some`, which holds one value of type `T` and `None` that doesn't hold any "
"value. By using the `Option<T>` enum, it is possible for us to express the "
"abstract concept of an optional value and because the value has a generic "
"type `T` we can use this abstraction with any type."
msgstr ""
"`Option<T>` 열거형은 타입 `T`에 대해 제네릭하며 `Some`과 `None` 두 가지 변형을 가지고 있습니다. `Some`은 "
"타입 `T`의 값을 하나 보유하고 있고 `None`은 어떤 값도 보유하지 않습니다. `Option<T>` 열거형을 사용함으로써 선택적인 "
"값의 추상적 개념을 표현할 수 있으며 값이 제네릭 타입 `T`를 가지고 있기 때문에 이 추상화를 어떤 타입에도 사용할 수 있습니다."

#: src/ch08-01-generic-data-types.md:199
msgid ""
"Enums can use multiple generic types as well, like definition of the "
"`Result<T, E>` enum that the core library provides:"
msgstr ""
"열거형은 `Result<T, E>`와 같이 여러 개의 제네릭 타입을 사용할 수도 있습니다. 이는 코어 라이브러리에서 제공하는 열거형의 "
"정의입니다."

#: src/ch08-01-generic-data-types.md:208 src/ch10-02-recoverable-errors.md:18
msgid ""
"The `Result<T, E>` enum has two generic types, `T` and `E`, and two "
"variants: `Ok` which holds the value of type `T` and `Err` which holds the "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (by returning a value "
"of type `T`) or fail (by returning a value of type `E`)."
msgstr ""
"`Result<T, E>` 열거형은 두 개의 제네릭 타입인 `T`와 `E`를 가지며, `Ok`와 `Err` 두 가지 변형이 있습니다. "
"`Ok`는 `T` 타입의 값을 보유하고, `Err`은 `E` 타입의 값을 보유합니다. 이 정의는 성공할 수도 있고(타입 `T`의 값을 "
"반환함으로써), 실패할 수도 있는(타입 `E`의 값을 반환함으로써) 작업이 있는 곳에서 `Result` 열거형을 편리하게 사용할 수 있게"
" 합니다."

#: src/ch08-01-generic-data-types.md:210
msgid "Generic Methods"
msgstr "일반 메소드"

#: src/ch08-01-generic-data-types.md:212
msgid ""
"We can implement methods on structs and enums, and use the generic types in "
"their definition, too. Using our previous definition of `Wallet<T>` struct, "
"we define a `balance` method for it:"
msgstr ""
"우리는 구조체와 열거형에 메서드를 구현하고, 그 정의에 일반 타입을 사용할 수도 있습니다. 이전에 정의한 `Wallet<T>` 구조체를 "
"사용하여, 해당 구조체에 `balance` 메서드를 정의합니다:"

#: src/ch08-01-generic-data-types.md:236
msgid ""
"We first define `WalletTrait<T>` trait using a generic type `T` which "
"defines a method that returns a snapshot of the field `balance` from "
"`Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. "
"Note that you need to include a generic type in both definitions of the "
"trait and the implementation."
msgstr ""
"먼저, `WalletTrait<T>` 트레이트를 정의합니다. 이 트레이트는 제네릭 타입 `T`를 사용하여 `Wallet`에서 "
"`balance` 필드의 스냅샷을 반환하는 메소드를 정의합니다. 그런 다음, 이 트레이트에 대한 구현을 `WalletImpl<T>`에서 "
"제공합니다. 트레이트와 구현의 모두에 제네릭 타입을 포함해야 함에 유의하세요."

#: src/ch08-01-generic-data-types.md:238
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only for `Wallet<u128>` "
"instances rather than `Wallet<T>`. In the code example we define an "
"implementation for wallets which have a concrete type of `u128` for the "
"`balance` field."
msgstr ""
"우리는 또한 유형에 대한 메소드를 정의할 때 일반 유형에 대한 제약 조건을 지정할 수 있습니다. 예를 들어, `Wallet<T>` 대신 "
"`Wallet<u128>` 인스턴스에 대해서만 메소드를 구현할 수 있습니다. 코드 예제에서는 `balance` 필드의 구체적인 유형이 "
"`u128`인 지갑에 대한 구현을 정의합니다."

#: src/ch08-01-generic-data-types.md:245
msgid "/// Generic trait for wallets\n"
msgstr "지갑에 대한 일반적인 특성"

#: src/ch08-01-generic-data-types.md:256
msgid "/// Trait for wallets of type u128\n"
msgstr "/// u128 유형의 지갑에 대한 특성"

#: src/ch08-01-generic-data-types.md:277
msgid ""
"The new method `receive` increments the size of the balance of any instance "
"of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a"
" mutable variable in order for it to be able to update its balance. If we "
"were to change the initialization of `w` by changing the type of `balance` "
"the previous code wouldn't compile."
msgstr ""
"새로운 `receive` 메서드는 `Wallet<u128>`의 인스턴스의 잔액 크기를 증가시킵니다. `main` 함수를 변경하여 `w`를"
" 변경 가능한 변수로 만들어야만 잔액을 업데이트할 수 있습니다. `w`의 초기화를 변경하여 `balance`의 유형을 변경하면 이전 "
"코드가 컴파일되지 않을 것입니다."

#: src/ch08-01-generic-data-types.md:279
msgid ""
"Cairo allows us to define generic methods inside generic traits as well. "
"Using the past implementation from `Wallet<U, V>` we are going to define a "
"trait that picks two wallets of different generic types and create a new one"
" with a generic type of each. First, let's rewrite the struct definition:"
msgstr ""
"카이로는 일반적인 트레이트 내에서 일반적인 메소드를 정의할 수 있게 해줍니다. `Wallet<U, V>`의 이전 구현을 사용하여 서로 "
"다른 일반 타입의 두 지갑을 선택하고 각각의 일반 타입으로 새로운 지갑을 생성하는 트레이트를 정의할 것입니다. 먼저, 구조체 정의를 다시"
" 작성해 봅시다."

#: src/ch08-01-generic-data-types.md:288
msgid ""
"Next we are going to naively define the mixup trait and implementation:"
msgstr "다음에는 혼동 특성과 구현을 순진하게 정의할 것입니다."

#: src/ch08-01-generic-data-types.md:291
msgid "// This does not compile!\n"
msgstr "이것은 컴파일되지 않습니다!"

#: src/ch08-01-generic-data-types.md:304
msgid ""
"We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` "
"methods which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` "
"creates a new `Wallet<T1, U2>`. As `mixup` signature specify, both `self` "
"and `other` are getting dropped at the end of the function, which is the "
"reason for this code not to compile. If you have been following from the "
"start until now you would know that we must add a requirement for all the "
"generic types specifying that they will implement the `Drop` trait in order "
"for the compiler to know how to drop instances of `Wallet<T, U>`. The "
"updated implementation is as follow:"
msgstr ""
"우리는 `mixup<T2, U2>` 메소드를 가지고 있는 `WalletMixTrait<T1, U1>` 특성을 생성하고, "
"`Wallet<T1, U1>` 및 `Wallet<T2, U2>`의 인스턴스를 제공하면 새로운 `Wallet<T1, U2>`를 생성합니다."
" `mixup` 시그니처에서 명시된대로, `self`와 `other` 모두 함수의 끝에서 삭제되므로 이 코드가 컴파일되지 않는 "
"이유입니다. 처음부터 지금까지 따라오셨다면, 모든 제네릭 타입에 대한 요구사항을 추가해야 한다는 것을 알고 계실 것입니다. 이 요구사항은"
" 컴파일러가 `Wallet<T, U>`의 인스턴스를 삭제하는 방법을 알 수 있도록 `Drop` 특성을 구현할 것을 명시합니다. 업데이트된"
" 구현은 다음과 같습니다:"

#: src/ch08-01-generic-data-types.md:322
msgid ""
"We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl`"
" declaration. Then we do the same for `T2` and `U2`, this time as part of "
"`mixup` signature. We can now try the `mixup` function:"
msgstr ""
"우리는 `WalletMixImpl` 선언에서 `T1`과 `U1`이 삭제 가능하도록 요구 사항을 추가합니다. 그런 다음 `T2`와 "
"`U2`에 대해 동일한 작업을 수행하며, 이번에는 `mixup` 서명의 일부로 수행합니다. 이제 `mixup` 함수를 시도할 수 "
"있습니다."

#: src/ch08-01-generic-data-types.md:336
msgid ""
"We first create two instances: one of `Wallet<bool, u128>` and the other of "
"`Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, "
"u8>` instance."
msgstr ""
"먼저 `Wallet<bool, u128>`와 `Wallet<felt252, u8>`의 두 인스턴스를 생성합니다. 그런 다음 "
"`mixup`을 호출하여 새로운 `Wallet<bool, u8>` 인스턴스를 생성합니다."

#: src/ch08-02-traits-in-cairo.md:3
msgid ""
"A trait defines a set of methods that can be implemented by a type. These "
"methods can be called on instances of the type when this trait is "
"implemented. A trait combined with a generic type defines functionality a "
"particular type has and can share with other types. We can use traits to "
"define shared behavior in an abstract way. We can use _trait bounds_ to "
"specify that a generic type can be any type that has certain behavior."
msgstr ""
"특성은 유형에서 구현할 수 있는 메서드 집합을 정의합니다. 이러한 메서드는 이 특성이 구현된 경우 유형의 인스턴스에서 호출할 수 "
"있습니다. 일반 유형과 결합된 특성은 특정 유형이 가지고 있는 기능을 정의하고 다른 유형과 공유할 수 있습니다. 우리는 특성을 사용하여 "
"추상적인 방식으로 공유 동작을 정의할 수 있습니다. 일반 유형이 특정 동작을 가진 유형일 수 있음을 지정하기 위해 _특성 바운드_ 를 "
"사용할 수 있습니다."

#: src/ch08-02-traits-in-cairo.md:7
msgid ""
"Note: Traits are similar to a feature often called interfaces in other "
"languages, although with some differences."
msgstr "참고: 특성은 다른 언어에서 종종 인터페이스라고 불리는 기능과 유사하지만 일부 차이가 있습니다."

#: src/ch08-02-traits-in-cairo.md:9
msgid ""
"While traits can be written to not accept generic types, they are most "
"useful when used with generic types. We already covered generics in the "
"[previous chapter](./ch08-01-generic-data-types.md), and we will use them in"
" this chapter to demonstrate how traits can be used to define shared "
"behavior for generic types."
msgstr ""
"특성은 일반 유형을 수용하지 않도록 작성될 수 있지만, 일반 유형과 함께 사용될 때 가장 유용합니다. 이미 [이전 "
"장](./ch08-01-generic-data-types.md)에서 일반화에 대해 다루었으며, 이 장에서는 일반 유형에 대한 공유 동작을"
" 정의하는 데 특성이 어떻게 사용될 수 있는지를 보여줄 것입니다."

#: src/ch08-02-traits-in-cairo.md:11
msgid "Defining a Trait"
msgstr "특성 정의"

#: src/ch08-02-traits-in-cairo.md:13
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr ""
"유형의 동작은 해당 유형에서 호출할 수 있는 메서드로 구성됩니다. 서로 다른 유형은 모두 동일한 메서드를 호출할 수 있다면 동일한 동작을"
" 공유합니다. 트레이트 정의는 어떤 목적을 달성하기 위해 필요한 동작 집합을 정의하기 위해 메서드 시그니처를 그룹화하는 방법입니다."

#: src/ch08-02-traits-in-cairo.md:15
msgid ""
"For example, let’s say we have a struct `NewsArticle` that holds a news "
"story in a particular location. We can define a trait `Summary` that "
"describes the behavior of something that can summarize the `NewsArticle` "
"type."
msgstr ""
"예를 들어, 특정 위치에 뉴스 이야기를 담고 있는 `NewsArticle` 구조체가 있다고 가정해 봅시다. 우리는 "
"`NewsArticle` 유형을 요약할 수 있는 것의 동작을 설명하는 `Summary` 트레이트를 정의할 수 있습니다."

#: src/ch08-02-traits-in-cairo.md:32
msgid "\"{:?} by {:?} ({:?})\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:41
msgid ""
"Here, we declare a trait using the trait keyword and then the trait’s name, "
"which is `Summary` in this case."
msgstr "여기서는 `Summary`인 특성 이름을 사용하여 특성을 선언합니다."

#: src/ch08-02-traits-in-cairo.md:45
msgid ""
"Inside the curly brackets, we declare the method signatures that describe "
"the behaviors of the types that implement this trait, which in this case is "
"`fn summarize(self: @NewsArticle) -> ByteArray`. After the method signature,"
" instead of providing an implementation within curly brackets, we use a "
"semicolon."
msgstr ""
"중괄호 안에는 이 특성을 구현하는 유형의 동작을 설명하는 메서드 시그니처를 선언합니다. 이 경우에는 `fn summarize(self: "
"@NewsArticle) -> ByteArray`입니다. 메서드 시그니처 뒤에 중괄호 내에서 구현을 제공하는 대신 세미콜론을 사용합니다."

#: src/ch08-02-traits-in-cairo.md:47
msgid ""
"Note: the `ByteArray` type is the type used to represent Strings in Cairo."
msgstr "참고: `ByteArray` 타입은 카이로에서 문자열을 표현하는 데 사용되는 타입입니다."

#: src/ch08-02-traits-in-cairo.md:49
msgid ""
"As the trait is not generic, the `self` parameter is not generic either and "
"is of type `@NewsArticle`. This means that the `summarize` method can only "
"be called on instances of `NewsArticle`."
msgstr ""
"특성이 일반적이 아니기 때문에 `self` 매개변수도 일반적이 아니며 `@NewsArticle` 유형입니다. 이는 `summarize` "
"메서드가 `NewsArticle`의 인스턴스에서만 호출될 수 있다는 것을 의미합니다."

#: src/ch08-02-traits-in-cairo.md:51
msgid ""
"Now, consider that we want to make a media aggregator library crate named "
"`aggregator` that can display summaries of data that might be stored in a "
"`NewsArticle` or `Tweet` instance. To do this, we need a summary from each "
"type, and we’ll request that summary by calling a summarize method on an "
"instance. By defining the `Summary` trait on generic type `T`, we can "
"implement the `summarize` method on any type we want to be able to "
"summarize."
msgstr ""
"지금, 우리는 `NewsArticle` 또는 `Tweet` 인스턴스에 저장될 수 있는 데이터의 요약을 표시할 수 있는 미디어 집계 "
"라이브러리 크레이트인 `aggregator`를 만들고 싶다고 가정해 봅시다. 이를 위해, 우리는 각 유형에서 요약을 필요로 하며, "
"인스턴스에서 `summarize` 메서드를 호출하여 해당 요약을 요청할 것입니다. 일반 유형 `T`에 `Summary` 트레이트를 "
"정의함으로써, 우리는 요약을 할 수 있는 유형에 대해 `summarize` 메서드를 구현할 수 있습니다."

#: src/ch08-02-traits-in-cairo.md:70 src/ch08-02-traits-in-cairo.md:146
#: src/ch08-02-traits-in-cairo.md:222
msgid "\"{} by {} ({})\""
msgstr "\"{} by {} ({})\" would be translated to \"({})에 의해 {}\" in Korean."

#: src/ch08-02-traits-in-cairo.md:85 src/ch08-02-traits-in-cairo.md:161
#: src/ch08-02-traits-in-cairo.md:237
msgid "\"{}: {}\""
msgstr ""

#: src/ch08-02-traits-in-cairo.md:93 src/ch08-02-traits-in-cairo.md:169
#: src/ch08-02-traits-in-cairo.md:245
msgid "\"Cairo has become the most popular language for developers\""
msgstr "\"카이로는 개발자들 사이에서 가장 인기 있는 언어가 되었습니다.\""

#: src/ch08-02-traits-in-cairo.md:94 src/ch08-02-traits-in-cairo.md:170
#: src/ch08-02-traits-in-cairo.md:246
msgid "\"Worldwide\""
msgstr "\"전 세계적으로\""

#: src/ch08-02-traits-in-cairo.md:95 src/ch08-02-traits-in-cairo.md:171
#: src/ch08-02-traits-in-cairo.md:247
msgid "\"Cairo Digger\""
msgstr "\"카이로 디거\""

#: src/ch08-02-traits-in-cairo.md:96 src/ch08-02-traits-in-cairo.md:172
#: src/ch08-02-traits-in-cairo.md:248
msgid "\"Cairo is a new programming language for zero-knowledge proofs\""
msgstr "\"카이로는 제로 지식 증명을 위한 새로운 프로그래밍 언어입니다.\""

#: src/ch08-02-traits-in-cairo.md:100 src/ch08-02-traits-in-cairo.md:176
#: src/ch08-02-traits-in-cairo.md:252
msgid "\"EliBenSasson\""
msgstr "\"일라이벤사손\""

#: src/ch08-02-traits-in-cairo.md:101 src/ch08-02-traits-in-cairo.md:177
#: src/ch08-02-traits-in-cairo.md:253
msgid ""
"\"Crypto is full of short-term maximizing projects. \\n @Starknet and "
"@StarkWareLtd are about long-term vision maximization.\""
msgstr ""
"\"암호화폐는 단기 이익을 극대화하는 프로젝트들로 가득합니다. @Starknet과 @StarkWareLtd는 장기 비전을 극대화하는 데 "
"관심이 있습니다.\""

#: src/ch08-02-traits-in-cairo.md:104 src/ch08-02-traits-in-cairo.md:180
#: src/ch08-02-traits-in-cairo.md:256
msgid "// Tweet instantiation\n"
msgstr "// 트윗 인스턴스화"

#: src/ch08-02-traits-in-cairo.md:106 src/ch08-02-traits-in-cairo.md:182
#: src/ch08-02-traits-in-cairo.md:258
msgid "\"New article available! {}\""
msgstr "\"새로운 기사가 이용 가능합니다! {}\""

#: src/ch08-02-traits-in-cairo.md:107 src/ch08-02-traits-in-cairo.md:183
#: src/ch08-02-traits-in-cairo.md:259
msgid "\"1 new tweet: {}\""
msgstr "\"1개의 새로운 트윗: {}\""

#: src/ch08-02-traits-in-cairo.md:113
msgid ""
"A `Summary` trait that consists of the behavior provided by a `summarize` "
"method"
msgstr "`summarize` 메서드에서 제공되는 동작으로 구성된 `Summary` 트레잇"

#: src/ch08-02-traits-in-cairo.md:115
msgid ""
"Each generic type implementing this trait must provide its own custom "
"behavior for the body of the method. The compiler will enforce that any type"
" that has the Summary trait will have the method summarize defined with this"
" signature exactly."
msgstr ""
"이 특성을 구현하는 각 일반 유형은 메서드의 본문에 대한 고유한 사용자 지정 동작을 제공해야 합니다. 컴파일러는 Summary 특성을 "
"가진 모든 유형이 이 시그니처로 정확히 정의된 summarize 메서드를 가져야 함을 강제할 것입니다."

#: src/ch08-02-traits-in-cairo.md:117
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line and each line ends in a semicolon."
msgstr ""
"한 특성은 본문에 여러 메서드를 가질 수 있습니다: 메서드 시그니처는 한 줄에 하나씩 나열되며 각 줄은 세미콜론으로 끝납니다."

#: src/ch08-02-traits-in-cairo.md:119
msgid "Implementing a Trait on a type"
msgstr "유형에 특성을 구현하기"

#: src/ch08-02-traits-in-cairo.md:121
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. The next "
"code snippet shows an implementation of the `Summary` trait on the "
"`NewsArticle` struct that uses the headline, the author, and the location to"
" create the return value of `summarize`. For the `Tweet` struct, we define "
"`summarize` as the username followed by the entire text of the tweet, "
"assuming that tweet content is already limited to 280 characters."
msgstr ""
"이제 `Summary` 트레이트의 메서드들의 원하는 시그니처를 정의했으므로, 미디어 집계기의 타입들에 이를 구현할 수 있습니다. 다음 "
"코드 스니펫은 `NewsArticle` 구조체에 대한 `Summary` 트레이트의 구현을 보여줍니다. 이 구현은 헤드라인, 작성자, "
"그리고 위치를 사용하여 `summarize`의 반환 값을 생성합니다. `Tweet` 구조체의 경우, 트윗 내용이 이미 280자로 제한되어"
" 있다고 가정하고, `summarize`를 사용자 이름 뒤에 트윗의 전체 텍스트로 정의합니다."

#: src/ch08-02-traits-in-cairo.md:189
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put a name for the implementation, "
"then use the `of` keyword, and then specify the name of the trait we are "
"writing the implementation for. If the implementation is for a generic type,"
" we place the generic type name in the angle brackets after the trait name."
msgstr ""
"타입에 특성을 구현하는 것은 일반 메서드를 구현하는 것과 유사합니다. 차이점은 `impl` 다음에 구현에 대한 이름을 넣고, `of` "
"키워드를 사용한 다음, 구현을 작성하는 특성의 이름을 지정한다는 것입니다. 구현이 제네릭 타입을 위한 것인 경우, 특성 이름 뒤의 꺽쇠 "
"괄호에 제네릭 타입 이름을 넣습니다."

#: src/ch08-02-traits-in-cairo.md:194
msgid ""
"Within the `impl` block, we put the method signatures that the trait "
"definition has defined. Instead of adding a semicolon after each signature, "
"we use curly brackets and fill in the method body with the specific behavior"
" that we want the methods of the trait to have for the particular type."
msgstr ""
"`impl` 블록 내부에는 트레이트 정의가 정의한 메소드 시그니처를 넣습니다. 각 시그니처 뒤에 세미콜론을 추가하는 대신 중괄호를 "
"사용하고, 트레이트의 메소드가 특정 타입에 대해 가져야 하는 특정 동작을 메소드 본문에 채웁니다."

#: src/ch08-02-traits-in-cairo.md:199
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a crate could use our `aggregator` crate:"
msgstr ""
"이제 라이브러리는 `NewsArticle`와 `Tweet`에 `Summary` 트레이트를 구현했으므로, 크레이트 사용자는 "
"`NewsArticle`와 `Tweet`의 인스턴스에서 트레이트 메서드를 호출할 수 있습니다. 일반 메서드를 호출하는 방식과 동일합니다."
" 유일한 차이점은 사용자가 트레이트와 타입을 스코프에 가져와야 한다는 것입니다. 다음은 크레이트가 우리의 `aggregator` "
"크레이트를 사용하는 방법의 예시입니다:"

#: src/ch08-02-traits-in-cairo.md:265
msgid "This code prints the following:"
msgstr "이 코드는 다음을 출력합니다:"

#: src/ch08-02-traits-in-cairo.md:274
msgid ""
"Other crates that depend on the `aggregator` crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types."
msgstr ""
"`aggregator` 크레이트에 의존하는 다른 크레이트들도 자신의 타입에 `Summary` 트레이트를 구현하기 위해 `Summary` "
"트레이트를 스코프에 가져올 수 있습니다."

#: src/ch08-02-traits-in-cairo.md:304
msgid "Implementing a trait, without writing its declaration."
msgstr "선언을 작성하지 않고 특성을 구현하는 것."

#: src/ch08-02-traits-in-cairo.md:306
msgid ""
"You can write implementations directly without defining the corresponding "
"trait. This is made possible by using the `#[generate_trait]` attribute "
"within the implementation, which will make the compiler generate the trait "
"corresponding to the implementation automatically. Remember to add `Trait` "
"as a suffix to your trait name, as the compiler will create the trait by "
"adding a `Trait` suffix to the implementation name."
msgstr ""
"해당 특성을 정의하지 않고 직접 구현을 작성할 수 있습니다. 이는 구현 내에서 `#[generate_trait]` 속성을 사용하여 "
"가능해집니다. 이 속성을 사용하면 컴파일러가 구현에 해당하는 특성을 자동으로 생성합니다. 특성 이름에 `Trait`를 접미사로 추가하는 "
"것을 기억해야 합니다. 컴파일러는 구현 이름에 `Trait` 접미사를 추가하여 특성을 생성합니다."

#: src/ch08-02-traits-in-cairo.md:325
msgid ""
"In the aforementioned code, there is no need to manually define the trait. "
"The compiler will automatically handle its definition, dynamically "
"generating and updating it as new functions are introduced."
msgstr ""
"상기 코드에서는 특성을 수동으로 정의할 필요가 없습니다. 컴파일러가 자동으로 그 정의를 처리하며, 새로운 함수가 도입될 때 동적으로 "
"생성하고 업데이트합니다."

#: src/ch08-02-traits-in-cairo.md:329
msgid "Managing and using external trait implementations"
msgstr "외부 특성 구현을 관리하고 사용하기"

#: src/ch08-02-traits-in-cairo.md:331
msgid ""
"To use traits methods, you need to make sure the correct "
"traits/implementation(s) are imported. In the code above we imported "
"`PrintTrait` from `debug` with `use core::debug::PrintTrait;` to use the "
"`print()` methods on supported types. All traits included in the prelude "
"don't need to be explicitly imported and are freely accessible."
msgstr ""
"특성 메서드를 사용하려면 올바른 특성/구현이 가져와져야 합니다. 위의 코드에서는 `use core::debug::PrintTrait;`를"
" 사용하여 `debug`에서 `PrintTrait`를 가져왔습니다. 지원되는 유형에 대한 `print()` 메서드를 사용하기 "
"위해서입니다. 프렐루드에 포함된 모든 특성은 명시적으로 가져올 필요가 없으며 자유롭게 접근할 수 있습니다."

#: src/ch08-02-traits-in-cairo.md:333
msgid ""
"In some cases you might need to import not only the trait but also the "
"implementation if they are declared in separate modules. If `CircleGeometry`"
" was in a separate module/file `circle` then to use `boundary` on `circ: "
"Circle`, we'd need to import `CircleGeometry` in addition to "
"`ShapeGeometry`."
msgstr ""
"일부 경우에는 트레이트 뿐만 아니라 구현도 가져와야 할 수도 있습니다. 그러나 그들이 별도의 모듈에 선언된 경우입니다. "
"`CircleGeometry`가 별도의 모듈/파일 `circle`에 있었다면 `circ: Circle`에서 `boundary`를 "
"사용하려면 `ShapeGeometry`뿐만 아니라 `CircleGeometry`도 가져와야 합니다."

#: src/ch08-02-traits-in-cairo.md:336
msgid ""
"If the code was organized into modules like this, where the implementation "
"of a trait was defined in a different module than the trait itself, "
"explicitly importing the relevant implementation is required."
msgstr ""
"만약 코드가 이와 같이 모듈로 구성되어 있다면, 특성의 구현이 특성 자체와 다른 모듈에 정의된 경우, 관련 구현을 명시적으로 가져와야 "
"합니다."

#: src/ch08-02-traits-in-cairo.md:340
msgid "// struct Circle { ... } and struct Rectangle { ... }\n"
msgstr "// 구조체 Circle { ... }와 구조체 Rectangle { ... }"

#: src/ch08-02-traits-in-cairo.md:353
msgid "// Could be in a different file\n"
msgstr "다른 파일에 있을 수 있습니다"

#: src/ch08-02-traits-in-cairo.md:366
msgid ""
"// Fails with this error\n"
"    // Method `area` not found on... Did you import the correct trait and impl?\n"
msgstr ""
"// 이 오류로 실패합니다\n"
"    // `area` 메소드를 찾을 수 없습니다... 올바른 트레이트와 구현체를 가져왔는지 확인했습니까?"

#: src/ch08-02-traits-in-cairo.md:373
msgid "To make it work, in addition to,"
msgstr "작동하도록 만들려면, 추가로,"

#: src/ch08-02-traits-in-cairo.md:379
msgid ""
"you will need to import `CircleGeometry` explicitly. Note that you do not "
"need to import `RectangleGeometry`, as it is defined in the same module as "
"the imported trait, and thus is automatically resolved."
msgstr ""
"`CircleGeometry`를 명시적으로 import해야 합니다. `RectangleGeometry`를 import할 필요는 없습니다."
" 왜냐하면 import된 trait와 동일한 모듈에 정의되어 있으므로 자동으로 해결됩니다."

#: src/ch09-01-how-to-write-tests.md:3 src/ch09-01-how-to-write-tests.md:13
msgid "The Anatomy of a Test Function"
msgstr "시험 함수의 해부학"

#: src/ch09-01-how-to-write-tests.md:5
msgid ""
"Tests are Cairo functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these"
" three actions:"
msgstr ""
"테스트는 비테스트 코드가 예상한 대로 작동하는지 확인하는 카이로 함수입니다. 테스트 함수의 본문은 일반적으로 다음 세 가지 작업을 "
"수행합니다:"

#: src/ch09-01-how-to-write-tests.md:7
msgid "Set up any needed data or state."
msgstr "필요한 데이터나 상태를 설정하세요."

#: src/ch09-01-how-to-write-tests.md:8
msgid "Run the code you want to test."
msgstr "테스트하고 싶은 코드를 실행하세요."

#: src/ch09-01-how-to-write-tests.md:9
msgid "Assert the results are what you expect."
msgstr "결과가 예상한 대로라고 주장하세요."

#: src/ch09-01-how-to-write-tests.md:11
msgid ""
"Let’s look at the features Cairo provides specifically for writing tests "
"that take these actions, which include the `test` attribute, the `assert!` "
"macro, and the `should_panic` attribute."
msgstr ""
"이러한 작업을 수행하는 테스트를 작성하기 위해 Cairo가 제공하는 기능을 살펴보겠습니다. 이 기능에는 `test` 속성, "
"`assert!` 매크로, 그리고 `should_panic` 속성이 포함됩니다."

#: src/ch09-01-how-to-write-tests.md:15
msgid ""
"At its simplest, a test in Cairo is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Cairo code; one "
"example is the derive attribute we used with structs in Chapter 5. To change"
" a function into a test function, add `#[test]` on the line before `fn`. "
"When you run your tests with the `scarb cairo-test` command, Scarb runs "
"Cairo's test runner binary that runs the annotated functions and reports on "
"whether each test function passes or fails."
msgstr ""
"가장 간단히 말해서, 카이로의 테스트는 `test` 속성으로 주석 처리된 함수입니다. 속성은 카이로 코드 조각에 대한 메타데이터이며, "
"예를 들어 5장에서 구조체와 함께 사용한 derive 속성이 있습니다. 함수를 테스트 함수로 변경하려면 `fn` 앞 줄에 "
"`#[test]`를 추가하십시오. `scarb cairo-test` 명령으로 테스트를 실행하면, Scarb는 카이로의 테스트 러너 이진 "
"파일을 실행하여 주석 처리된 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고합니다."

#: src/ch09-01-how-to-write-tests.md:17
msgid ""
"Let's create a new project called `adder` that will add two numbers using "
"Scarb with the command `scarb new adder`:"
msgstr "`scarb new adder` 명령을 사용하여 두 숫자를 더하는 `adder`라는 새 프로젝트를 만들어 보겠습니다."

#: src/ch09-01-how-to-write-tests.md:26
msgid ""
"In _lib.cairo_, let's remove the existing content and add a first test, as "
"shown in Listing 9-1."
msgstr "_lib.cairo_ 에서 기존 내용을 제거하고 제시된 9-1 목록에 표시된대로 첫 번째 테스트를 추가합시다."

#: src/ch09-01-how-to-write-tests.md:34 src/ch09-01-how-to-write-tests.md:68
#: src/ch09-01-how-to-write-tests.md:630 src/ch09-01-how-to-write-tests.md:668
#: src/ch09-02-test-organization.md:25
msgid "\"result is not 4\""
msgstr "결과는 4가 아닙니다."

#: src/ch09-01-how-to-write-tests.md:38
msgid "Listing 9-1: A test module and function"
msgstr "리스트 9-1: 테스트 모듈과 함수"

#: src/ch09-01-how-to-write-tests.md:40
msgid ""
"For now, let’s ignore the top two lines and focus on the function. Note the "
"`#[test]` annotation: this attribute indicates this is a test function, so "
"the test runner knows to treat this function as a test. We might also have "
"non-test functions in the tests module to help set up common scenarios or "
"perform common operations, so we always need to indicate which functions are"
" tests."
msgstr ""
"지금은 상위 두 줄을 무시하고 함수에 집중합시다. `#[test]` 주석을 주목하세요. 이 속성은 이것이 테스트 함수임을 나타내며, "
"따라서 테스트 실행기는 이 함수를 테스트로 처리해야 함을 알 수 있습니다. 우리는 또한 테스트 모듈에 테스트가 아닌 함수를 가질 수 "
"있으며, 이는 공통 시나리오를 설정하거나 공통 작업을 수행하는 데 도움이 될 수 있습니다. 따라서 어떤 함수가 테스트인지 항상 표시해야 "
"합니다."

#: src/ch09-01-how-to-write-tests.md:42
msgid ""
"The example function body uses the `assert!` macro, which contains the "
"result of adding 2 and 2, equals 4. This assertion serves as an example of "
"the format for a typical test. Let’s run it to see that this test passes."
msgstr ""
"예제 함수 본문은 `assert!` 매크로를 사용하는데, 이는 2와 2를 더한 결과가 4인지를 포함합니다. 이 단언은 전형적인 테스트 "
"형식의 예시로 사용됩니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다."

#: src/ch09-01-how-to-write-tests.md:44
msgid ""
"The `scarb cairo-test` command runs all tests founds in our project, as "
"shown in Listing 9-2."
msgstr "`scarb cairo-test` 명령어는 프로젝트에서 찾은 모든 테스트를 실행합니다. 9-2 목록에 나와 있습니다."

#: src/ch09-01-how-to-write-tests.md:54
msgid "Listing 9-2: The output from running a test"
msgstr "리스팅 9-2: 테스트 실행 결과"

#: src/ch09-01-how-to-write-tests.md:56
msgid ""
"`scarb cairo-test` compiled and ran the test. We see the line `running 1 "
"tests`. The next line shows the name of the test function, called "
"`it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""
"`scarb cairo-test`가 컴파일되고 테스트가 실행되었습니다. 우리는 `running 1 tests` 라인을 볼 수 있습니다. "
"다음 라인에는 `it_works`라는 테스트 함수의 이름과 해당 테스트를 실행한 결과인 `ok`가 표시됩니다. 전체적인 요약인 `test"
" result: ok.`는 모든 테스트가 통과되었음을 의미하며, `1 passed; 0 failed`라고 쓰인 부분은 통과한 테스트와 "
"실패한 테스트의 총 수를 보여줍니다."

#: src/ch09-01-how-to-write-tests.md:58
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [Ignoring Some Tests Unless Specifically "
"Requested](#ignoring-some-tests-unless-specifically-requested) section later"
" in this chapter. Because we haven’t done that here, the summary shows `0 "
"ignored`. We can also pass an argument to the `scarb cairo-test` command to "
"run only a test whose name matches a string; this is called filtering and "
"we’ll cover that in the [Running Single Tests](#running-single-tests) "
"section. We also haven’t filtered the tests being run, so the end of the "
"summary shows `0 filtered out`."
msgstr ""
"이 특정 인스턴스에서 테스트를 실행하지 않도록 무시된 것으로 표시할 수 있습니다; 이에 대해 이 장의 나중에 [특정 요청이 있을 때 일부"
" 테스트 무시하기](#ignoring-some-tests-unless-specifically-requested) 섹션에서 다룰 것입니다."
" 여기서는 그렇게 하지 않았기 때문에 요약에는 `0 ignored`로 표시됩니다. 또한 `scarb cairo-test` 명령에 인수를 "
"전달하여 이름과 일치하는 테스트만 실행할 수도 있습니다; 이를 필터링이라고 하며, [단일 테스트 실행](#running-single-"
"tests) 섹션에서 다룰 것입니다. 또한 실행 중인 테스트를 필터링하지 않았기 때문에 요약의 끝에 `0 filtered out`로 "
"표시됩니다."

#: src/ch09-01-how-to-write-tests.md:60
msgid ""
"Let’s start to customize the test to our own needs. First change the name of"
" the `it_works` function to a different name, such as `exploration`, like "
"so:"
msgstr ""
"우리의 요구에 맞게 테스트를 맞춤 설정하기 시작합시다. 먼저 `it_works` 함수의 이름을 `exploration`과 같이 다른 "
"이름으로 변경해주세요."

#: src/ch09-01-how-to-write-tests.md:72
msgid ""
"Then run `scarb cairo-test` again. The output now shows `exploration` "
"instead of `it_works`:"
msgstr ""
"그런 다음 `scarb cairo-test`를 다시 실행하십시오. 출력은 이제 `it_works` 대신 `exploration`을 "
"보여줍니다."

#: src/ch09-01-how-to-write-tests.md:81
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a"
" new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. Enter the new test as a function named `another`, "
"so your _src/lib.cairo_ file looks like Listing 9-3."
msgstr ""
"이제 다른 테스트를 추가할 것이지만, 이번에는 실패하는 테스트를 만들 것입니다! 테스트는 테스트 함수에서 패닉이 발생할 때 실패합니다. "
"각 테스트는 새로운 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 감지하면 테스트가 실패로 표시됩니다. "
"`another`라는 함수로 새로운 테스트를 입력하여 _src/lib.cairo_ 파일이 9-3번 코드와 같이 보이도록 합니다."

#: src/ch09-01-how-to-write-tests.md:87
msgid "\"Make this test fail\""
msgstr "\"이 테스트를 실패하게 만들어주세요\""

#: src/ch09-01-how-to-write-tests.md:92
msgid "Listing 9-3: Adding a second test that will fail"
msgstr "리스트 9-3: 실패할 두 번째 테스트 추가하기"

#: src/ch09-01-how-to-write-tests.md:104
msgid "Listing 9-4: Test results when one test passes and one test fails"
msgstr "리스팅 9-4: 하나의 테스트가 통과하고 하나의 테스트가 실패한 경우의 테스트 결과"

#: src/ch09-01-how-to-write-tests.md:106
msgid ""
"Instead of `ok`, the line `adder::lib::tests::another` shows `fail`. A new "
"section appears between the individual results and the summary. It displays "
"the detailed reason for each test failure. In this case, we get the details "
"that `another` failed because it panicked with "
"`[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]`"
" in the _src/lib.cairo_ file."
msgstr ""
"`ok` 대신 `adder::lib::tests::another` 라인이 `fail`을 보여줍니다. 개별 결과와 요약 사이에 새로운 "
"섹션이 나타납니다. 각 테스트 실패에 대한 자세한 이유를 표시합니다. 이 경우에는 `another`가 _src/lib.cairo_ "
"파일에서 `[1725643816656041371866211894343434536761780588 ('Make this test "
"fail'), ]`로 패닉 상태가 되어 실패했다는 세부 정보를 얻습니다."

#: src/ch09-01-how-to-write-tests.md:108
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""
"요약 라인은 끝에 표시됩니다: 전반적으로, 우리의 테스트 결과는 `실패`입니다. 하나의 테스트가 통과하고 하나의 테스트가 실패했습니다."

#: src/ch09-01-how-to-write-tests.md:110
msgid ""
"Now that you’ve seen what the test results look like in different scenarios,"
" let’s look at some functions that are useful in tests."
msgstr "다양한 시나리오에서 시험 결과가 어떻게 보이는지 확인했으니, 시험에서 유용한 몇 가지 기능을 살펴보겠습니다."

#: src/ch09-01-how-to-write-tests.md:112
msgid "Checking Results with the `assert!` macro"
msgstr "`assert!` 매크로를 사용하여 결과 확인하기"

#: src/ch09-01-how-to-write-tests.md:114
msgid ""
"The `assert!` macro, provided by Cairo, is useful when you want to ensure "
"that some condition in a test evaluates to `true`. We give the `assert!` "
"macro a first argument that evaluates to a Boolean. If the value is `true`, "
"nothing happens and the test passes. If the value is `false`, the `assert!` "
"macro calls `panic()` to cause the test to fail with a message we defined as"
" the second argument. Using the `assert!` macro helps us check that our code"
" is functioning in the way we intend."
msgstr ""
"`assert!` 매크로는 Cairo에서 제공되며, 테스트에서 어떤 조건이 `true`로 평가되는지를 보장하고 싶을 때 유용합니다. "
"`assert!` 매크로에는 불리언으로 평가되는 첫 번째 인수를 제공합니다. 값이 `true`이면 아무 일도 발생하지 않고 테스트가 "
"통과됩니다. 값이 `false`이면 `assert!` 매크로가 `panic()`을 호출하여 두 번째 인수로 정의한 메시지와 함께 테스트가"
" 실패하도록 만듭니다. `assert!` 매크로를 사용하면 코드가 의도한 대로 작동하는지 확인할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:116
msgid ""
"In [Chapter 5, Listing 5-13](ch05-03-method-syntax.md#multiple-impl-blocks),"
" we used a `Rectangle` struct and a `can_hold` method, which are repeated "
"here in Listing 9-5. Let’s put this code in the _src/lib.cairo_ file, then "
"write some tests for it using the `assert!` macro."
msgstr ""
"[제 5장, 목록 5-13](ch05-03-method-syntax.md#multiple-impl-blocks)에서는 "
"`Rectangle` 구조체와 `can_hold` 메서드를 사용했는데, 이것들이 목록 9-5에서 다시 나타납니다. 이 코드를 "
"_src/lib.cairo_ 파일에 넣고, `assert!` 매크로를 사용하여 몇 가지 테스트를 작성해 보겠습니다."

#: src/ch09-01-how-to-write-tests.md:137
msgid ""
"Listing 9-5: Using the `Rectangle` struct and its `can_hold` method from "
"Chapter 5"
msgstr "리스트 9-5: 5장에서 `Rectangle` 구조체와 그 `can_hold` 메서드를 사용하기"

#: src/ch09-01-how-to-write-tests.md:139
msgid ""
"The `can_hold` method returns a `bool`, which means it’s a perfect use case "
"for the `assert!` macro. In Listing 9-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of `8`"
" and a height of `7` and asserting that it can hold another `Rectangle` "
"instance that has a width of `5` and a height of `1`."
msgstr ""
"`can_hold` 메서드는 `bool`을 반환하며, 이는 `assert!` 매크로에 완벽하게 사용되는 사례입니다. 9-6 목록에서는 "
"`can_hold` 메서드를 연습하는 테스트를 작성합니다. `Rectangle` 인스턴스를 만들어 너비가 `8`이고 높이가 `7`인 "
"`Rectangle` 인스턴스가 다른 `Rectangle` 인스턴스를 보유할 수 있다고 단언합니다. 이렇게 하면 너비가 `5`이고 높이가"
" `1`인 `Rectangle` 인스턴스를 만들 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:176 src/ch09-01-how-to-write-tests.md:184
#: src/ch09-01-how-to-write-tests.md:241 src/ch09-01-how-to-write-tests.md:249
msgid "\"rectangle cannot hold\""
msgstr "\"사각형은 보관할 수 없습니다.\""

#: src/ch09-01-how-to-write-tests.md:191
msgid ""
"Listing 9-6: A test for `can_hold` that checks whether a larger rectangle "
"can indeed hold a smaller rectangle"
msgstr "리스팅 9-6: 더 큰 직사각형이 실제로 더 작은 직사각형을 보관할 수 있는지 확인하는 `can_hold`에 대한 테스트"

#: src/ch09-01-how-to-write-tests.md:193
msgid ""
"Note that we’ve added two new lines inside the tests module: `use "
"super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a "
"regular module that follows the usual visibility rules. Because the tests "
"module is an inner module, we need to bring the code under test in the outer"
" module into the scope of the inner module."
msgstr ""
"테스트 모듈 내에 두 개의 새로운 줄을 추가했음을 유의하세요: "
"`use super::Rectangle;` 및 `use super::RectangleTrait;`. "
"테스트 모듈은 일반적인 모듈이며 일반적인 가시성 규칙을 따릅니다. "
"테스트 모듈은 내부 모듈이므로 외부 모듈의 테스트 대상 코드를 내부 모듈의 범위로 가져와야 합니다."

#: src/ch09-01-how-to-write-tests.md:195
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(@smaller)`. This expression"
" is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""
"우리는 테스트를 `larger_can_hold_smaller`로 명명했고, 필요한 두 개의 `Rectangle` 인스턴스를 생성했습니다."
" 그런 다음 `assert!` 매크로를 호출하고 `larger.can_hold(@smaller)`를 호출한 결과를 전달했습니다. 이 "
"표현식은 `true`를 반환해야 하므로 우리의 테스트는 통과해야 합니다. 확인해 봅시다!"

#: src/ch09-01-how-to-write-tests.md:204
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""
"그것은 통과합니다! 더 많은 테스트를 추가해 봅시다. 이번에는 더 작은 직사각형이 더 큰 직사각형을 담을 수 없음을 확인하는 테스트를 "
"추가해 봅시다."

#: src/ch09-01-how-to-write-tests.md:256
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns false:"
msgstr ""
"이 경우 `can_hold` 함수의 올바른 결과가 `false`이기 때문에, `assert!` 매크로에 전달하기 전에 해당 결과를 "
"부정해야 합니다. 결과적으로, `can_hold`가 false를 반환하면 테스트가 통과됩니다."

#: src/ch09-01-how-to-write-tests.md:266
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr ""
"두 개의 테스트가 통과합니다! 이제 코드에 버그를 도입할 때 우리의 테스트 결과가 어떻게 변하는지 살펴봅시다. 우리는 `can_hold`"
" 메소드의 구현을 변경하여 너비를 비교할 때 크다는 기호를 작다는 기호로 바꿀 것입니다:"

#: src/ch09-01-how-to-write-tests.md:280
msgid "Running the tests now produces the following:"
msgstr "지금 테스트를 실행하면 다음이 생성됩니다."

#: src/ch09-01-how-to-write-tests.md:293
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` "
"is not less than `5`."
msgstr ""
"우리의 테스트가 버그를 잡았습니다! `larger.width`가 `8`이고 `smaller.width`가 `5`이기 때문에, "
"`can_hold`에서 너비를 비교하면 이제 `false`를 반환합니다: `8`은 `5`보다 작지 않습니다."

#: src/ch09-01-how-to-write-tests.md:295
msgid "Testing Equality with the `assert_eq!` and `assert_ne!` Macros"
msgstr "`assert_eq!` 및 `assert_ne!` 매크로를 사용하여 동등성 테스트하기"

#: src/ch09-01-how-to-write-tests.md:297
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to "
"perform this test more conveniently. These macros compare two arguments for "
"equality or inequality, respectively. They’ll also print the two values if "
"the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false`"
" value."
msgstr ""
"기능을 확인하는 일반적인 방법은 테스트 코드의 결과와 코드가 반환해야 하는 값을 비교하는 것입니다. `assert!` 매크로를 사용하여 "
"`==` 연산자를 사용한 표현식을 전달하여 이 작업을 수행할 수 있습니다. 그러나 이는 매우 흔한 테스트이므로 표준 라이브러리는 이 "
"테스트를 더 편리하게 수행하기 위해 `assert_eq!`와 `assert_ne!`라는 매크로 쌍을 제공합니다. 이러한 매크로는 각각 두"
" 인수를 동등성 또는 부등성으로 비교합니다. 또한 단언이 실패하면 두 값을 출력하여 테스트가 실패한 이유를 더 쉽게 파악할 수 있습니다."
" 반면, `assert!` 매크로는 `==` 표현식에 대해 `false` 값을 받았다는 것만 나타내고 `false` 값을 유발한 값을 "
"출력하지 않습니다."

#: src/ch09-01-how-to-write-tests.md:308
msgid ""
"In Listing 9-7, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using the `assert_eq!` macro."
msgstr ""
"리스팅 9-7에서는 매개변수에 `2`를 더하는 `add_two`라는 함수를 작성하고, 이 함수를 `assert_eq!` 매크로를 사용하여"
" 테스트합니다."

#: src/ch09-01-how-to-write-tests.md:329
msgid ""
"Listing 9-7: Testing the function `add_two` using the `assert_eq!` macro"
msgstr "리스팅 9-7: `assert_eq!` 매크로를 사용하여 함수 `add_two`를 테스트하기"

#: src/ch09-01-how-to-write-tests.md:332
msgid "Let’s check that it passes!"
msgstr "그게 통과하는지 확인해 봅시다!"

#: src/ch09-01-how-to-write-tests.md:341
msgid ""
"We pass `4` as the argument to `assert_eq!`, which is equal to the result of"
" calling `add_two(2)`. The line for this test is `test tests::it_adds_two "
"... ok`, and the `ok` text indicates that our test passed!"
msgstr ""
"우리는 `assert_eq!`에 인수로 `4`를 전달하고, 이는 `add_two(2)`를 호출한 결과와 같습니다. 이 테스트의 라인은 "
"`test tests::it_adds_two ... ok`이며, `ok` 텍스트는 우리의 테스트가 통과되었음을 나타냅니다!"

#: src/ch09-01-how-to-write-tests.md:345
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when"
" it fails. Change the implementation of the `add_two` function to instead "
"add `3`:"
msgstr ""
"우리의 코드에 버그를 도입하여 `assert_eq!`가 실패할 때 어떻게 보이는지 살펴보겠습니다. `add_two` 함수의 구현을 "
"변경하여 대신 `3`을 추가하도록 변경하십시오."

#: src/ch09-01-how-to-write-tests.md:354
msgid "Run the tests again:"
msgstr "테스트를 다시 실행하세요."

#: src/ch09-01-how-to-write-tests.md:356
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 359600)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```console\n"
"$ scarb cairo-test\n"
"1개의 테스트 실행 중\n"
"테스트 tests::it_adds_two ... 실패 (가스 사용량 예상: 359600)\n"
"실패 사항:\n"
"   tests::it_adds_two - \"assertion `4 == add_two(2)` 실패로 패닉.\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"에러: 테스트 결과: 실패. 0개 통과; 1개 실패; 0개 무시됨\n"
"```"

#: src/ch09-01-how-to-write-tests.md:368
msgid ""
"Our test caught the bug! The `it_adds_two` test failed with the following "
"message: ``Panicked with \"assertion `4 == add_two(2)` failed``. It tells "
"use that the assertion that fails was `` \"assertion `left == right` "
"failed`` and the `left` and `right` value are printed on the next lines as "
"`left: left_value` and `right: right_value`. This helps us start debugging: "
"the `left` argument was `4` but the `right` argument, where we had "
"`add_two(2)`, was `5`. You can imagine that this would be especially helpful"
" when we have a lot of tests going on."
msgstr ""
"우리의 테스트는 버그를 잡았습니다! `it_adds_two` 테스트가 다음 메시지와 함께 실패했습니다: \"assertion `4 == "
"add_two(2)`가 실패했습니다\". 실패한 단언이 \"assertion `left == right`가 실패했습니다\"라고 알려주며,"
" `left`와 `right` 값이 다음 줄에 `left: left_value`와 `right: right_value`로 출력됩니다. "
"이는 디버깅을 시작하는 데 도움이 됩니다: `left` 인수는 `4`이지만 `add_two(2)`를 사용한 `right` 인수는 "
"`5`였습니다. 많은 테스트가 진행 중일 때 특히 도움이 될 것입니다."

#: src/ch09-01-how-to-write-tests.md:375
msgid ""
"Note that in some languages and test frameworks, the parameters to equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Cairo, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion"
" in this test as `assert_eq!(add_two(2), 4)`, which would result in the same"
" failure message that displays `` assertion failed: `(left == right)` ``."
msgstr ""
"일부 언어 및 테스트 프레임워크에서는 동등성 단언 함수의 매개변수를 `예상` 및 `실제`로 부르며, 인수를 지정하는 순서가 중요합니다. "
"그러나 Cairo에서는 `왼쪽`과 `오른쪽`으로 불리며, 우리가 기대하는 값과 코드가 생성하는 값을 지정하는 순서는 중요하지 않습니다. "
"이 테스트에서 단언을 `assert_eq!(add_two(2), 4)`로 작성할 수 있으며, 이는 `` assertion failed: "
"`(left == right)` ``라는 동일한 실패 메시지를 표시할 것입니다."

#: src/ch09-01-how-to-write-tests.md:383
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but the way in which the input is changed "
"depends on the day of the week that we run our tests, the best thing to "
"assert might be that the output of the function is not equal to the input."
msgstr ""
"`assert_ne!` 매크로는 우리가 제공하는 두 값이 동일하지 않으면 통과하고 동일하면 실패합니다. 이 매크로는 값이 무엇이 될지 "
"확실하지 않지만 값이 결코 되어서는 안 될 것을 알고 있는 경우에 가장 유용합니다. 예를 들어, 우리가 테스트하는 함수가 입력을 어떤 "
"방식으로든 변경할 것이 보장되지만 입력이 변경되는 방식은 테스트를 실행하는 요일에 따라 달라진다면, 함수의 출력이 입력과 동일하지 않아야"
" 한다는 것을 단언하는 것이 가장 좋을 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:391
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators `==` and `!=`, respectively. When the assertions fail, these "
"macros print their arguments using debug formatting, which means the values "
"being compared must implement the `PartialEq` and `Debug` traits. All "
"primitive types and most of the core library types implement these traits. "
"For structs and enums that you define yourself, you’ll need to implement "
"`PartialEq` to assert equality of those types. You’ll also need to implement"
" `Debug` to print the values when the assertion fails. Because both traits "
"are derivable traits this is usually as straightforward as adding the "
"`#[derive(Drop, Debug, PartialEq)]` annotation to your struct or enum "
"definition. See Appendix C, [“Derivable Traits”](./appendix-03-derivable-"
"traits.md), for more details about these and other derivable traits."
msgstr ""
"표면 아래에서 `assert_eq!` 및 `assert_ne!` 매크로는 각각 `==` 및 `!=` 연산자를 사용합니다. 단언문이 실패할"
" 때, 이러한 매크로는 디버그 형식을 사용하여 인수를 출력하며, 비교되는 값은 `PartialEq` 및 `Debug` 트레이트를 구현해야"
" 합니다. 모든 기본 유형과 대부분의 코어 라이브러리 유형은 이러한 트레이트를 구현합니다. 직접 정의한 구조체 및 열거형에 대해선 해당 "
"유형의 동등성을 단언하기 위해 `PartialEq`를 구현해야 합니다. 또한, 단언문이 실패할 때 값을 출력하기 위해 `Debug`를 "
"구현해야 합니다. 두 트레이트 모두 파생 가능한 트레이트이므로, 이는 보통 구조체나 열거형 정의에 `#[derive(Drop, "
"Debug, PartialEq)]` 주석을 추가하는 것만으로 간단하게 처리됩니다. 더 자세한 내용은 Appendix C, "
"[“Derivable Traits”](./appendix-03-derivable-traits.md)를 참조하세요."

#: src/ch09-01-how-to-write-tests.md:405
msgid "Adding Custom Failure Messages"
msgstr "사용자 정의 실패 메시지 추가하기"

#: src/ch09-01-how-to-write-tests.md:407
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any arguments specified after the required arguments are passed along to the"
" `format!` macro (discussed in [Chapter 11 - "
"Macros](./ch11-02-macros.md#format-macro) in the `format!` section), so you "
"can pass a format string that contains `{}` placeholders and values to go in"
" those placeholders. Custom messages are useful for documenting what an "
"assertion means; when a test fails, you’ll have a better idea of what the "
"problem is with the code."
msgstr ""
"`assert!`, `assert_eq!`, 및 `assert_ne!` 매크로에 실패 메시지와 함께 인쇄할 사용자 정의 메시지를 선택적 "
"인수로 추가할 수도 있습니다. 필수 인수 뒤에 지정된 인수는 `format!` 매크로로 전달됩니다([11장 - "
"매크로](./ch11-02-macros.md#format-macro)의 `format!` 섹션에서 설명함). 따라서 `{}` 자리 "
"표시자를 포함하는 형식 문자열 및 해당 자리 표시자에 들어갈 값들을 전달할 수 있습니다. 사용자 정의 메시지는 단언이 무엇을 의미하는지 "
"문서화하는 데 유용합니다. 테스트가 실패할 때 코드의 문제가 무엇인지 더 잘 이해할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:415
msgid ""
"Let’s add a custom failure message composed of a format string with a "
"placeholder filled in with the actual value we got from the `add_two` "
"function:"
msgstr ""
"`add_two` 함수에서 얻은 실제 값으로 채워진 플레이스홀더가 있는 형식 문자열로 구성된 사용자 정의 실패 메시지를 추가해 "
"보겠습니다."

#: src/ch09-01-how-to-write-tests.md:426
msgid "\"Expected {}, got add_two(2)={}\""
msgstr "\"예상한 값 {}, add_two(2)로 얻은 값={}\""

#: src/ch09-01-how-to-write-tests.md:431
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr "이제 테스트를 실행하면 더 많은 정보를 제공하는 오류 메시지를 받게 됩니다."

#: src/ch09-01-how-to-write-tests.md:433
msgid ""
"```console\n"
"$ scarb cairo-test\n"
"running 1 tests\n"
"test tests::it_adds_two ... fail (gas usage est.: 590230)\n"
"failures:\n"
"   tests::it_adds_two - Panicked with \"assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"Error: test result: FAILED. 0 passed; 1 failed; 0 ignored\n"
"```"
msgstr ""
"```console\n"
"$ scarb cairo-test\n"
"1개의 테스트 실행 중\n"
"테스트 tests::it_adds_two ... 실패 (가스 사용량 예상: 590230)\n"
"실패 사항:\n"
"   tests::it_adds_two - \"단언문 `4 == add_two(2)`이 실패했습니다: 예상 값은 4이지만, add_two(2)의 결과는 5입니다\n"
"4: 4\n"
"add_two(2): 5\".\n"
"\n"
"오류: 테스트 결과: 실패. 통과한 테스트: 0개; 실패한 테스트: 1개; 무시된 테스트: 0개\n"
"```"

#: src/ch09-01-how-to-write-tests.md:445
msgid ""
"We can see the value we actually got in the test output, which would help us"
" debug what happened instead of what we were expecting to happen."
msgstr ""
"우리는 테스트 결과에서 실제로 얻은 값을 볼 수 있습니다. 이는 우리가 기대했던 것이 아닌 일이 어떻게 발생했는지 디버깅하는 데 도움이 "
"될 것입니다."

#: src/ch09-01-how-to-write-tests.md:448
msgid "Checking for panics with `should_panic`"
msgstr "`should_panic`를 사용하여 패닉 여부를 확인합니다."

#: src/ch09-01-how-to-write-tests.md:450
msgid ""
"In addition to checking return values, it’s important to check that our code"
" handles error conditions as we expect. For example, consider the Guess type"
" in Listing 9-8. Other code that uses `Guess` depends on the guarantee that "
"`Guess` instances will contain only values between `1` and `100`. We can "
"write a test that ensures that attempting to create a `Guess` instance with "
"a value outside that range panics."
msgstr ""
"리턴 값 확인 외에도, 우리의 코드가 예상한대로 에러 조건을 처리하는지 확인하는 것이 중요합니다. 예를 들어, 9-8 목록의 Guess "
"유형을 고려해보십시오. `Guess`를 사용하는 다른 코드는 `Guess` 인스턴스가 `1`과 `100` 사이의 값만 포함할 것이라는 "
"보장에 의존합니다. 우리는 해당 범위를 벗어난 값을 사용하여 `Guess` 인스턴스를 생성하려고 시도할 때 패닉이 발생하는지 확인하는 "
"테스트를 작성할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:452
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""
"우리는 이를 위해 테스트 함수에 `should_panic` 속성을 추가함으로써 이를 수행합니다. 함수 내부의 코드가 패닉하면 테스트가 "
"통과되고, 함수 내부의 코드가 패닉하지 않으면 테스트가 실패합니다."

#: src/ch09-01-how-to-write-tests.md:454
msgid ""
"Listing 9-8 shows a test that checks that the error conditions of "
"`GuessTrait::new` happen when we expect them to."
msgstr "9-8 목록은 `GuessTrait::new`의 오류 조건이 우리가 기대하는 대로 발생하는지 확인하는 테스트를 보여줍니다."

#: src/ch09-01-how-to-write-tests.md:471 src/ch09-01-how-to-write-tests.md:516
msgid "\"Guess must be >= 1 and <= 100\""
msgstr "\"추측은 1 이상이어야 하며 100 이하여야 합니다.\""

#: src/ch09-01-how-to-write-tests.md:490
msgid "Listing 9-8: Testing that a condition will cause a panic"
msgstr "리스팅 9-8: 조건이 패닉을 유발할 것을 테스트하는 중"

#: src/ch09-01-how-to-write-tests.md:492
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""
"`#[should_panic]` 속성을 `#[test]` 속성 뒤에 놓고 해당 속성이 적용되는 테스트 함수 앞에 놓습니다. 이 테스트가 "
"통과될 때의 결과를 살펴봅시다."

#: src/ch09-01-how-to-write-tests.md:501
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the new function will panic if the value is greater than `100`:"
msgstr "좋아 보여요! 이제 새로운 함수가 값이 `100`보다 크면 패닉하도록 하는 조건을 제거하여 코드에 버그를 도입해 봅시다."

#: src/ch09-01-how-to-write-tests.md:526
msgid "When we run the test in Listing 9-8, it will fail:"
msgstr "리스팅 9-8에서 테스트를 실행하면 실패할 것입니다."

#: src/ch09-01-how-to-write-tests.md:537
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""
"이 경우에는 매우 유용한 메시지를 받지 못하지만, 테스트 함수를 살펴보면 `#[should_panic]`으로 주석이 달려 있음을 알 수 "
"있습니다. 우리가 받은 실패는 테스트 함수의 코드가 패닉을 유발하지 않았다는 것을 의미합니다."

#: src/ch09-01-how-to-write-tests.md:539
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional"
" expected parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 9-9 where the new function"
" panics with different messages depending on whether the value is too small "
"or too large."
msgstr ""
"`should_panic`를 사용하는 테스트는 정확하지 않을 수 있습니다. `should_panic` 테스트는 우리가 예상한 이유와는 "
"다른 이유로 테스트가 패닉해도 통과될 수 있습니다. `should_panic` 테스트를 더 정확하게 만들기 위해 "
"`should_panic` 속성에 선택적인 예상 매개변수를 추가할 수 있습니다. 테스트 하네스는 실패 메시지에 제공된 텍스트가 포함되도록"
" 할 것입니다. 예를 들어, 값이 너무 작거나 너무 큰 경우에 따라 새로운 함수가 다른 메시지로 패닉하는 경우를 고려해 보세요. 리스트 "
"9-9의 `Guess`에 대한 수정된 코드를 참고하세요."

#: src/ch09-01-how-to-write-tests.md:558 src/ch09-01-how-to-write-tests.md:594
msgid "\"Guess must be >= 1\""
msgstr "\"추측은 1 이상이어야 합니다\""

#: src/ch09-01-how-to-write-tests.md:560 src/ch09-01-how-to-write-tests.md:573
#: src/ch09-01-how-to-write-tests.md:592
msgid "\"Guess must be <= 100\""
msgstr "\"추측은 100 이하여야 합니다\""

#: src/ch09-01-how-to-write-tests.md:582
msgid ""
"Listing 9-9: Testing for a panic with a panic message containing the error "
"message string"
msgstr "리스팅 9-9: 오류 메시지 문자열을 포함한 패닉 메시지로 패닉을 테스트합니다."

#: src/ch09-01-how-to-write-tests.md:584
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s expected parameter is the array of string of the message that "
"the `Guess::new` function panics with. We need to specify the entire panic "
"message that we expect."
msgstr ""
"이 테스트는 통과될 것입니다. 왜냐하면 `should_panic` 속성의 예상 매개변수에 넣은 값은 `Guess::new` 함수가 패닉을"
" 일으킬 때 패닉 메시지의 문자열 배열이기 때문입니다. 우리는 기대하는 전체 패닉 메시지를 명시해야 합니다."

#: src/ch09-01-how-to-write-tests.md:586
msgid ""
"To see what happens when a `should_panic` test with an expected message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the if `value < 1` and the else if `value > 100` blocks:"
msgstr ""
"`should_panic` 테스트에서 예상 메시지가 실패하는 경우 무엇이 발생하는지 보려면, `value < 1`와 `value > "
"100` 블록의 본문을 교환하여 코드에 버그를 다시 도입해 보겠습니다."

#: src/ch09-01-how-to-write-tests.md:602
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr "`should_panic` 테스트를 실행할 때, 이번에는 실패할 것입니다."

#: src/ch09-01-how-to-write-tests.md:614
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string. The "
"panic message that we did get in this case was `Guess must be >= 1`. Now we "
"can start figuring out where our bug is!"
msgstr ""
"실패 메시지는 우리가 예상했던 대로 이 테스트가 실제로 패닉을 일으켰음을 나타냅니다. 그러나 패닉 메시지에는 기대했던 문자열이 포함되어 "
"있지 않았습니다. 이 경우 우리가 받은 패닉 메시지는 `Guess must be >= 1`입니다. 이제 버그가 있는 곳을 찾기 시작할 수"
" 있습니다!"

#: src/ch09-01-how-to-write-tests.md:616
msgid "Running Single Tests"
msgstr "단일 테스트 실행"

#: src/ch09-01-how-to-write-tests.md:618
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working"
" on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `scarb"
" cairo-test` an option `-f` (for \"filter\"), followed by the name of the "
"test you want to run as an argument."
msgstr ""
"가끔 전체 테스트 스위트를 실행하는 데 오랜 시간이 걸릴 수 있습니다. 특정 영역의 코드를 작업 중이라면 해당 코드에 관련된 테스트만 "
"실행하고 싶을 수 있습니다. 실행할 테스트를 선택하려면 `scarb cairo-test`에 옵션 `-f` (필터를 의미)를 전달하고, "
"실행하려는 테스트의 이름을 인수로 지정하십시오."

#: src/ch09-01-how-to-write-tests.md:620
msgid ""
"To demonstrate how to run a single test, we’ll first create two test "
"functions, as shown in Listing 9-10, and choose which ones to run."
msgstr ""
"단일 테스트를 실행하는 방법을 보여주기 위해 먼저 두 개의 테스트 함수를 생성하고, Listing 9-10에 표시된 대로 실행할 함수를 "
"선택합니다."

#: src/ch09-01-how-to-write-tests.md:636
msgid "\"result is not 5\""
msgstr "\"결과는 5가 아닙니다\""

#: src/ch09-01-how-to-write-tests.md:641
msgid "Listing 9-10: Two tests with two different names"
msgstr "리스팅 9-10: 두 가지 다른 이름을 가진 두 가지 테스트"

#: src/ch09-01-how-to-write-tests.md:643
msgid ""
"We can pass the name of any test function to `cairo-test` to run only that "
"test using the `-f` flag:"
msgstr "`cairo-test`에 `-f` 플래그를 사용하여 특정 테스트만 실행하려면 어떤 테스트 함수의 이름을 전달할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:652
msgid ""
"Only the test with the name `add_two_and_two` ran; the other test didn’t "
"match that name. The test output lets us know we had one more test that "
"didn’t run by displaying 1 filtered out at the end."
msgstr ""
"이름이 `add_two_and_two`인 테스트만 실행되었습니다. 다른 테스트는 해당 이름과 일치하지 않았습니다. 테스트 출력을 통해 "
"1개의 추가 테스트가 실행되지 않았음을 알 수 있습니다. 마지막에 1개가 필터링되었다는 메시지가 표시됩니다."

#: src/ch09-01-how-to-write-tests.md:654
msgid ""
"We can also specify part of a test name, and any test whose name contains "
"that value will be run."
msgstr "우리는 또한 테스트 이름의 일부를 지정할 수 있으며, 해당 값이 포함된 이름을 가진 모든 테스트가 실행됩니다."

#: src/ch09-01-how-to-write-tests.md:656
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr "특별히 요청하지 않는 한 일부 테스트를 무시합니다."

#: src/ch09-01-how-to-write-tests.md:658
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you"
" might want to exclude them during most runs of `scarb cairo-test`. Rather "
"than listing as arguments all tests you do want to run, you can instead "
"annotate the time-consuming tests using the `ignore` attribute to exclude "
"them, as shown here:"
msgstr ""
"가끔 특정 테스트 몇 개는 실행하는 데 매우 시간이 많이 소요될 수 있으므로 `scarb cairo-test`의 대부분 실행 중에 이러한"
" 테스트를 제외하고 싶을 수 있습니다. 실행하려는 모든 테스트를 인수로 나열하는 대신 시간이 많이 소요되는 테스트를 `ignore` "
"속성을 사용하여 제외할 수 있습니다. 여기에 표시된 대로요:"

#: src/ch09-01-how-to-write-tests.md:673
msgid "// code that takes an hour to run\n"
msgstr "// 1시간이 걸리는 코드"

#: src/ch09-01-how-to-write-tests.md:678
msgid ""
"After `#[test]` we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""
"`#[test]` 다음에 우리는 제외하고 싶은 테스트에 `#[ignore]` 라인을 추가합니다. 이제 테스트를 실행하면 "
"`it_works`는 실행되지만 `expensive_test`는 실행되지 않습니다."

#: src/ch09-01-how-to-write-tests.md:688
msgid "The `expensive_test` function is listed as ignored."
msgstr "`expensive_test` 함수가 무시된 것으로 나열되어 있습니다."

#: src/ch09-01-how-to-write-tests.md:690
msgid ""
"When you’re at a point where it makes sense to check the results of the "
"ignored tests and you have time to wait for the results, you can run `scarb "
"cairo-test --include-ignored` to run all tests whether they’re ignored or "
"not."
msgstr ""
"무시된 테스트의 결과를 확인하는 것이 합리적이며 결과를 기다릴 시간이 있는 경우, `scarb cairo-test --include-"
"ignored`를 실행하여 무시되었는지 여부에 관계없이 모든 테스트를 실행할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:692
msgid "Testing recursive functions or loops"
msgstr "재귀 함수 또는 루프를 테스트하는 중입니다."

#: src/ch09-01-how-to-write-tests.md:694
msgid ""
"When testing recursive functions or loops, the test is instantiated by "
"default with a maximum amount of gas that it can consume. This prevents "
"running infinite loops or consuming too much gas, and can help you benchmark"
" the efficiency of your implementations. This value is assumed reasonably "
"large enough, but you can override it by adding the "
"`#[available_gas(<Number>)]` attribute on the test function. The following "
"example shows how to use it:"
msgstr ""
"재귀 함수나 루프를 테스트할 때, 테스트는 기본적으로 소비할 수 있는 최대 가스 양으로 인스턴스화됩니다. 이는 무한 루프를 실행하거나 "
"너무 많은 가스를 소비하는 것을 방지하며, 구현의 효율성을 벤치마킹하는 데 도움이 될 수 있습니다. 이 값은 충분히 크다고 가정되지만, "
"테스트 함수에 `#[available_gas(<숫자>)]` 속성을 추가하여 재정의할 수 있습니다. 다음 예제는 이를 사용하는 방법을 "
"보여줍니다:"

#: src/ch09-01-how-to-write-tests.md:716
msgid "\"result is not 55\""
msgstr "결과는 55가 아닙니다."

#: src/ch09-01-how-to-write-tests.md:721
msgid "Benchmarking the gas usage of a specific operation"
msgstr "특정 작업의 가스 사용량을 벤치마킹하는 것"

#: src/ch09-01-how-to-write-tests.md:723
msgid ""
"When you want to benchmark the gas usage of a specific operation, you can "
"use the following pattern in your test function."
msgstr "특정 작업의 가스 사용량을 벤치마킹하고 싶을 때, 테스트 함수에서 다음 패턴을 사용할 수 있습니다."

#: src/ch09-01-how-to-write-tests.md:728 src/ch09-01-how-to-write-tests.md:755
msgid "/// code we want to bench.\n"
msgstr "우리가 벤치마킹하고 싶은 코드."

#: src/ch09-01-how-to-write-tests.md:729 src/ch09-01-how-to-write-tests.md:757
msgid "\"{}\\n\""
msgstr "\"{}\\n\""

#: src/ch09-01-how-to-write-tests.md:732
msgid ""
"The following example shows how to use it to test the gas function of the "
"`sum_n` function above."
msgstr "다음 예제는 위의 `sum_n` 함수의 가스 기능을 테스트하는 방법을 보여줍니다."

#: src/ch09-01-how-to-write-tests.md:762
msgid ""
"The value printed when running `scarb cairo-test` is the amount of gas that "
"was consumed by the operation benchmarked."
msgstr "`scarb cairo-test`를 실행할 때 인쇄된 값은 벤치마킹된 작업에 의해 소비된 가스 양입니다."

#: src/ch09-01-how-to-write-tests.md:775
msgid ""
"Here, the gas usage of the `sum_n` function is 96760 (decimal representation"
" of the hex number). The total amount consumed by the test is slightly "
"higher at 98030, due to some extra steps required to run the entire test "
"function."
msgstr ""
"여기서 `sum_n` 함수의 가스 사용량은 96760입니다 (16진수 숫자의 10진수 표현). 테스트에 의해 소비된 총량은 전체 테스트 "
"함수를 실행하는 데 필요한 몇 가지 추가 단계로 인해 약간 더 높은 98030입니다."

#: src/ch09-02-test-organization.md:3
msgid ""
"We'll think about tests in terms of two main categories: unit tests and "
"integration tests. Unit tests are small and more focused, testing one module"
" in isolation at a time, and can test private functions. Although Cairo "
"doesn't implement the concept of public/private functions/fields yet, it's "
"good practice to start organizing your code as if it were. Integration tests"
" use your code in the same way any other external code would, using only the"
" public interface and potentially exercising multiple modules per test."
msgstr ""
"우리는 두 가지 주요 범주로 테스트에 대해 생각할 것입니다: 단위 테스트와 통합 테스트. 단위 테스트는 작고 더 집중된 테스트로, 한 "
"번에 한 모듈을 격리시켜 테스트하며, 비공개 함수를 테스트할 수 있습니다. 카이로는 아직 공개/비공개 함수/필드 개념을 구현하지 "
"않았지만, 코드를 구성하는 것이 좋은 실천법이라고 생각합니다. 통합 테스트는 다른 외부 코드와 마찬가지로 코드를 사용하며, 테스트 당 "
"여러 모듈을 활용할 수 있도록 공개 인터페이스만 사용합니다."

#: src/ch09-02-test-organization.md:5
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""
"당신의 라이브러리 조각들이 당신이 기대하는 대로 개별적으로와 함께 작동하는지 확인하기 위해 두 종류의 테스트를 작성하는 것이 중요합니다."

#: src/ch09-02-test-organization.md:7
msgid "Unit Tests"
msgstr "단위 테스트"

#: src/ch09-02-test-organization.md:9
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the"
" rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the `src` directory in each file with the"
" code that they’re testing."
msgstr ""
"단위 테스트의 목적은 코드의 각 단위를 다른 코드와 격리시켜 빠르게 코드가 예상대로 작동하지 않는 곳을 찾는 것입니다. 단위 테스트는 "
"테스트하는 코드와 함께 각 파일의 `src` 디렉토리에 넣을 것입니다."

#: src/ch09-02-test-organization.md:11
msgid ""
"The convention is to create a module named tests in each file to contain the"
" test functions and to annotate the module with `cfg(test)`."
msgstr "관례적으로 각 파일에 테스트 함수를 포함하는 tests 모듈을 생성하고 모듈에 `cfg(test)` 주석을 달아야 합니다."

#: src/ch09-02-test-organization.md:13
msgid "The Tests Module and `#[cfg(test)]`"
msgstr "테스트 모듈과 `#[cfg(test)]`"

#: src/ch09-02-test-organization.md:15
msgid ""
"The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and"
" run the test code only when you run `scarb cairo-test`, not when you run "
"`cairo-run`. This saves compile time when you only want to build the library"
" and saves space in the resulting compiled artifact because the tests are "
"not included. You’ll see that because integration tests go in a different "
"directory, they don’t need the `#[cfg(test)]` annotation. However, because "
"unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to "
"specify that they shouldn’t be included in the compiled result."
msgstr ""
"`#[cfg(test)]` 주석은 테스트 모듈에 대해 Cairo에게 `scarb cairo-test`를 실행할 때에만 테스트 코드를 "
"컴파일하고 실행하도록 지시합니다. `cairo-run`을 실행할 때에는 실행되지 않습니다. 이는 라이브러리를 빌드할 때 컴파일 시간을 "
"절약하고 테스트가 포함되지 않아 컴파일된 결과물의 공간을 절약합니다. 통합 테스트가 다른 디렉토리에 들어가기 때문에 "
"`#[cfg(test)]` 주석이 필요하지 않습니다. 그러나 단위 테스트는 코드와 동일한 파일에 들어가므로 컴파일된 결과물에 포함되지 "
"않아야 함을 지정하기 위해 `#[cfg(test)]`를 사용합니다."

#: src/ch09-02-test-organization.md:17
msgid ""
"Recall that when we created the new `adder` project in the first section of "
"this chapter, we wrote this first test:"
msgstr "이 장의 첫 번째 섹션에서 새 `adder` 프로젝트를 만들었을 때, 우리는 이 첫 번째 테스트를 작성했습니다."

#: src/ch09-02-test-organization.md:32
msgid ""
"The attribute `cfg` stands for configuration and tells Cairo that the "
"following item should only be included given a certain configuration option."
" In this case, the configuration option is `test`, which is provided by "
"Cairo for compiling and running tests. By using the `cfg` attribute, Cairo "
"compiles our test code only if we actively run the tests with `scarb cairo-"
"test`. This includes any helper functions that might be within this module, "
"in addition to the functions annotated with `#[test]`."
msgstr ""
"`cfg` 속성은 구성을 나타내며, Cairo에게 특정 구성 옵션이 주어진 경우에만 다음 항목을 포함해야 한다고 알려줍니다. 이 경우에는"
" 구성 옵션이 `test`이며, 이는 테스트를 컴파일하고 실행하기 위해 Cairo에서 제공하는 것입니다. `cfg` 속성을 사용하여 "
"Cairo는 `scarb cairo-test`로 테스트를 활성화한 경우에만 테스트 코드를 컴파일합니다. 이는 `#[test]`로 주석 "
"처리된 함수뿐만 아니라 이 모듈 내에 있는 어떤 도우미 함수도 포함됩니다."

#: src/ch09-02-test-organization.md:34
msgid "Integration Tests"
msgstr "통합 테스트"

#: src/ch09-02-test-organization.md:36
msgid ""
"Integration tests use your library in the same way any other code would. "
"Their purpose is to test whether many parts of your library work together "
"correctly. Units of code that work correctly on their own could have "
"problems when integrated, so test coverage of the integrated code is "
"important as well. To create integration tests, you first need a `tests` "
"directory."
msgstr ""
"통합 테스트는 다른 코드와 마찬가지로 라이브러리를 사용합니다. 그들의 목적은 여러 부분이 올바르게 함께 작동하는지 테스트하는 것입니다. "
"독립적으로 올바르게 작동하는 코드 단위들이 통합되었을 때 문제가 발생할 수 있으므로 통합된 코드의 테스트 커버리지도 중요합니다. 통합 "
"테스트를 만들려면 먼저 `tests` 디렉토리가 필요합니다."

#: src/ch09-02-test-organization.md:38
msgid "The `tests` Directory"
msgstr "`tests` 디렉토리"

#: src/ch09-02-test-organization.md:66
msgid "Filename: src/tests.cairo"
msgstr "파일 이름: src/tests.cairo"

#: src/ch09-02-test-organization.md:68
msgid ""
"Enter the code in Listing 9-11 into the _src/tests/integration_tests.cairo_ "
"file:"
msgstr "리스팅 9-11의 코드를 _src/tests/integration_tests.cairo_ 파일에 입력하세요."

#: src/ch09-02-test-organization.md:75
msgid "\"internal_adder failed\""
msgstr "\"내부 덧셈기 실패\""

#: src/ch09-02-test-organization.md:79
msgid "Filename: src/tests/integration_tests.cairo"
msgstr "파일 이름: src/tests/integration_tests.cairo"

#: src/ch09-02-test-organization.md:81
msgid ""
"We need to bring our tested functions into each test file scope. For that "
"reason we add `use adder::it_adds_two` at the top of the code, which we "
"didn’t need in the unit tests."
msgstr ""
"우리는 각 테스트 파일 범위에 테스트된 함수를 가져와야 합니다. 이를 위해 코드 상단에 `use adder::it_adds_two`를 "
"추가합니다. 이는 단위 테스트에서 필요하지 않았던 것입니다."

#: src/ch09-02-test-organization.md:83
msgid ""
"Then, to run all of our integration tests, we can just add a filter to only "
"run tests whose path contains \"integration_tests\"."
msgstr ""
"그럼, 모든 통합 테스트를 실행하려면, \"integration_tests\"를 포함하는 경로의 테스트만 실행하도록 필터를 추가할 수 "
"있습니다."

#: src/ch09-02-test-organization.md:94
msgid ""
"The result of the tests is the same as what we've been seeing: one line for "
"each test."
msgstr "시험 결과는 우리가 계속 보던 것과 같습니다: 각 시험에 대해 한 줄씩입니다."

#: src/ch10-00-error-handling.md:1
msgid "Error handling"
msgstr "오류 처리"

#: src/ch10-00-error-handling.md:3
msgid ""
"In this chapter, we will explore various error handling techniques provided "
"by Cairo, which not only allow you to address potential issues in your code,"
" but also make it easier to create programs that are adaptable and "
"maintainable. By examining different approaches to managing errors, such as "
"pattern matching with the Result enum, using the ? operator for more "
"ergonomic error propagation, and employing the unwrap or expect methods for "
"handling recoverable errors, you'll gain a deeper understanding of Cairo's "
"error handling features. These concepts are crucial for building robust "
"applications that can effectively handle unexpected situations, ensuring "
"your code is ready for production."
msgstr ""
"이 장에서는 Cairo가 제공하는 다양한 오류 처리 기술을 탐색할 것입니다. 이 기술들은 당신이 코드에서 발생할 수 있는 잠재적인 문제를"
" 해결할 뿐만 아니라, 적응 가능하고 유지보수 가능한 프로그램을 만드는 데 도움이 됩니다. Result enum을 사용한 패턴 매칭, 더"
" 편리한 오류 전파를 위한 ? 연산자 사용, 복구 가능한 오류를 처리하기 위한 unwrap 또는 expect 메서드를 활용하는 등 다양한"
" 오류 관리 접근 방식을 살펴봄으로써, Cairo의 오류 처리 기능에 대한 깊은 이해를 얻을 수 있을 것입니다. 이러한 개념들은 예기치 "
"않은 상황을 효과적으로 처리할 수 있는 견고한 애플리케이션을 구축하는 데 중요하며, 코드가 프로덕션에 준비되어 있는지 확인하는 데 도움이"
" 됩니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:3
msgid ""
"In Cairo, unexpected issues may arise during program execution, resulting in"
" runtime errors. While the panic function from the core library doesn't "
"provide a resolution for these errors, it does acknowledge their occurrence "
"and terminates the program. There are two primary ways that a panic can be "
"triggered in Cairo: inadvertently, through actions causing the code to panic"
" (e.g., accessing an array beyond its bounds), or deliberately, by invoking "
"the panic function."
msgstr ""
"카이로에서 프로그램 실행 중 예기치 않은 문제가 발생하여 런타임 오류가 발생할 수 있습니다. 핵심 라이브러리의 패닉 함수는 이러한 오류에"
" 대한 해결책을 제공하지는 않지만 발생을 인식하고 프로그램을 종료합니다. 카이로에서 패닉을 유발하는 두 가지 주요 방법이 있습니다: "
"우연히 코드가 패닉을 유발하는 작업을 통해(예: 배열의 범위를 벗어나 접근) 패닉이 발생하거나 의도적으로 패닉 함수를 호출함으로써 발생할"
" 수 있습니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:5
msgid ""
"When a panic occurs, it leads to an abrupt termination of the program. The "
"`panic` function takes an array as an argument, which can be used to provide"
" an error message and performs an unwind process where all variables are "
"dropped and dictionaries squashed to ensure the soundness of the program to "
"safely terminate the execution."
msgstr ""
"패닉이 발생하면 프로그램이 갑작스럽게 종료됩니다. `panic` 함수는 배열을 인수로 취하며, 오류 메시지를 제공하고 프로그램의 안정성을"
" 보장하기 위해 모든 변수가 삭제되고 딕셔너리가 압축되는 언바인드 프로세스를 수행하여 실행을 안전하게 종료합니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:7
msgid ""
"Here is how we can `panic` from inside a program and return the error code "
"`2`:"
msgstr "다음은 프로그램 내에서 `panic`을 일으키고 오류 코드 `2`를 반환하는 방법입니다:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:18
#: src/ch10-01-unrecoverable-errors-with-panic.md:54
msgid "\"This line isn't reached\""
msgstr "\"이 줄은 도달되지 않았습니다.\""

#: src/ch10-01-unrecoverable-errors-with-panic.md:22
msgid "Running the program will produce the following output:"
msgstr "프로그램을 실행하면 다음과 같은 출력물이 생성됩니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:29
msgid ""
"As you can notice in the output, the print statement is never reached, as "
"the program terminates after encountering the `panic` statement."
msgstr "출력에서 알 수 있듯이, 프린트 문은 도달하지 않고 `panic` 문을 만나면 프로그램이 종료됩니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:31
msgid ""
"An alternative and more idiomatic approach to panic in Cairo would be to use"
" the `panic_with_felt252` function. This function serves as an abstraction "
"of the array-defining process and is often preferred due to its clearer and "
"more concise expression of intent. By using `panic_with_felt252`, developers"
" can panic in a one-liner by providing a felt252 error message as an "
"argument, making the code more readable and maintainable."
msgstr ""
"카이로에서 패닉하는 대안적이고 더 관용적인 접근 방식은 `panic_with_felt252` 함수를 사용하는 것입니다. 이 함수는 배열 "
"정의 프로세스의 추상화 역할을 하며 의도를 더 명확하고 간결하게 표현할 수 있어 선호됩니다. `panic_with_felt252`를 "
"사용하면 개발자들은 felt252 오류 메시지를 인수로 제공하여 한 줄로 패닉할 수 있어 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들 수"
" 있습니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:33
msgid "Let's consider an example:"
msgstr "예를 살펴보겠습니다:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:43
msgid ""
"Executing this program will yield the same error message as before. In that "
"case, if there is no need for an array and multiple values to be returned "
"within the error, so `panic_with_felt252` is a more succinct alternative."
msgstr ""
"이 프로그램을 실행하면 이전과 동일한 오류 메시지가 발생합니다. 이 경우, 오류 내에서 배열이나 여러 값이 반환될 필요가 없다면 "
"`panic_with_felt252`가 더 간결한 대안입니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:45
msgid "`panic!` macro"
msgstr "`panic!` 매크로"

#: src/ch10-01-unrecoverable-errors-with-panic.md:47
msgid ""
"`panic!` macro can be really helpful. The previous example returning the "
"error code 2 shows how convenient `panic!` macro is. There is no need to "
"create an array and pass it as argument like `panic` function."
msgstr ""
"`panic!` 매크로는 정말로 유용할 수 있습니다. 이전 예제에서 오류 코드 2를 반환하는 것은 `panic!` 매크로가 얼마나 "
"편리한지 보여줍니다. `panic` 함수처럼 배열을 생성하고 인수로 전달할 필요가 없습니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:52
msgid "\"2\""
msgstr ""

#: src/ch10-01-unrecoverable-errors-with-panic.md:58
msgid ""
"Unlike the `panic_with_felt252` function, using `panic!` allows the input, "
"which is ultimately the panic error, to be a literal longer than 31 bytes. "
"This is because `panic!` takes a string as parameter. For example, the "
"following line of code will successfully compile: "
msgstr ""
"`panic_with_felt252` 함수와 달리 `panic!`을 사용하면 최종적으로 패닉 에러가 되는 입력이 31바이트보다 긴 "
"글자열이 될 수 있습니다. 이는 `panic!`이 매개변수로 문자열을 받기 때문입니다. 예를 들어, 다음 코드 라인은 성공적으로 "
"컴파일됩니다:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:61
msgid "\"the error for panic! macro is not limited to 31 characters anymore\""
msgstr "\"패닉! 매크로의 오류는 더 이상 31자로 제한되지 않습니다.\""

#: src/ch10-01-unrecoverable-errors-with-panic.md:64
msgid "nopanic notation"
msgstr "노패닉 표기법"

#: src/ch10-01-unrecoverable-errors-with-panic.md:66
msgid ""
"You can use the `nopanic` notation to indicate that a function will never "
"panic. Only `nopanic` functions can be called in a function annotated as "
"`nopanic`."
msgstr ""
"`nopanic` 표기법을 사용하여 함수가 절대 패닉하지 않을 것임을 나타낼 수 있습니다. `nopanic` 함수만이 "
"`nopanic`으로 주석이 달린 함수에서 호출될 수 있습니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:68
#: src/ch10-01-unrecoverable-errors-with-panic.md:103
#: src/appendix-03-derivable-traits.md:25
#: src/appendix-03-derivable-traits.md:50
#: src/appendix-03-derivable-traits.md:71
#: src/appendix-03-derivable-traits.md:93
#: src/appendix-03-derivable-traits.md:126
#: src/appendix-03-derivable-traits.md:163
msgid "Example:"
msgstr "예시:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:76
msgid "Wrong example:"
msgstr "잘못된 예시:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:84
msgid ""
"If you write the following function that includes a function that may panic "
"you will get the following error:"
msgstr "다음 함수를 작성하면 패닉을 유발할 수 있는 함수가 포함되어 있기 때문에 다음 오류가 발생합니다:"

#: src/ch10-01-unrecoverable-errors-with-panic.md:97
msgid ""
"Note that there are two functions that may panic here, assert and equality."
msgstr "여기서는 패닉할 수 있는 두 가지 함수가 있다는 점을 유의하십시오. assert 및 equality입니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:99
msgid "panic_with attribute"
msgstr "속성으로 패닉"

#: src/ch10-01-unrecoverable-errors-with-panic.md:101
msgid ""
"You can use the `panic_with` attribute to mark a function that returns an "
"`Option` or `Result`. This attribute takes two arguments, which are the data"
" that is passed as the panic reason as well as the name for a wrapping "
"function. It will create a wrapper for your annotated function which will "
"panic if the function returns `None` or `Err`, the panic function will be "
"called with the given data."
msgstr ""
"`panic_with` 속성을 사용하여 `Option` 또는 `Result`를 반환하는 함수를 표시할 수 있습니다. 이 속성은 두 개의 "
"인수를 취하는데, 이는 패닉 원인으로 전달되는 데이터와 래핑 함수의 이름입니다. 주석이 달린 함수에 대한 래퍼를 만들어주며, 만약 함수가"
" `None` 또는 `Err`를 반환하면 패닉이 발생하고 주어진 데이터와 함께 패닉 함수가 호출됩니다."

#: src/ch10-01-unrecoverable-errors-with-panic.md:116
msgid "// this returns None\n"
msgstr "// 이것은 None을 반환합니다"

#: src/ch10-01-unrecoverable-errors-with-panic.md:117
msgid "// this panics with 'value is 0'\n"
msgstr "// 이것은 '값이 0입니다'로 패닉합니다."

#: src/ch10-02-recoverable-errors.md:1
msgid "Recoverable Errors with `Result`"
msgstr "`Result`를 사용한 복구 가능한 오류"

#: src/ch10-02-recoverable-errors.md:5
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes, when a function fails, it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to add two large integers "
"and the operation overflows because the sum exceeds the maximum "
"representable value, you might want to return an error or a wrapped result "
"instead of causing undefined behavior or terminating the process."
msgstr ""
"대부분의 오류는 프로그램을 완전히 중지시킬만큼 심각하지 않습니다. 때로는 함수가 실패하는 경우가 있지만, 그 이유를 쉽게 해석하고 대응할"
" 수 있습니다. 예를 들어, 두 큰 정수를 더하려고 시도하면 합이 표현 가능한 최대 값을 초과하여 오버플로우가 발생하는 경우, 정의되지 "
"않은 동작이나 프로세스 종료 대신 오류를 반환하거나 래핑된 결과를 반환하는 것이 좋을 수 있습니다."

#: src/ch10-02-recoverable-errors.md:7
msgid "The `Result` enum"
msgstr "`Result` 열거형"

#: src/ch10-02-recoverable-errors.md:9
msgid ""
"Recall from [“Generic data types”](ch08-01-generic-data-types.md#enums) in "
"Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and"
" `Err`, as follows:"
msgstr ""
"8장의 [“일반 데이터 유형”](ch08-01-generic-data-types.md#enums)에서 `Result` 열거형이 `Ok`와"
" `Err` 두 가지 변형으로 정의된 것을 상기해보십시오."

#: src/ch10-02-recoverable-errors.md:20
msgid "The `ResultTrait`"
msgstr "`ResultTrait`"

#: src/ch10-02-recoverable-errors.md:22
msgid ""
"The `ResultTrait` trait provides methods for working with the `Result<T, E>`"
" enum, such as unwrapping values, checking whether the `Result` is `Ok` or "
"`Err`, and panicking with a custom message. The `ResultTraitImpl` "
"implementation defines the logic of these methods."
msgstr ""
"`ResultTrait` 트레이트는 `Result<T, E>` enum과 함께 작업하는 메서드를 제공합니다. 값 언래핑, "
"`Result`가 `Ok`인지 `Err`인지 확인, 그리고 사용자 정의 메시지와 함께 패닉하는 등의 기능을 수행할 수 있습니다. "
"`ResultTraitImpl` 구현은 이러한 메서드의 로직을 정의합니다."

#: src/ch10-02-recoverable-errors.md:40
msgid ""
"The `expect` and `unwrap` methods are similar in that they both attempt to "
"extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` "
"variant. If the `Result` is `Ok(x)`, both methods return the value `x`. "
"However, the key difference between the two methods lies in their behavior "
"when the `Result` is in the `Err` variant. The `expect` method allows you to"
" provide a custom error message (as a `felt252` value) that will be used "
"when panicking, giving you more control and context over the panic. On the "
"other hand, the `unwrap` method panics with a default error message, "
"providing less information about the cause of the panic."
msgstr ""
"`expect` 및 `unwrap` 메소드는 둘 다 `Ok` 변형에 있을 때 `Result<T, E>` 유형의 값을 추출하려고 시도한다는"
" 점에서 유사합니다. `Result`가 `Ok(x)`인 경우, 두 메소드는 모두 값 `x`를 반환합니다. 그러나 두 메소드 간의 주요 "
"차이점은 `Result`가 `Err` 변형에 있을 때의 동작에 있습니다. `expect` 메소드는 패닉 시 사용될 사용자 정의 오류 "
"메시지(`felt252` 값)를 제공할 수 있도록 하며, 패닉 시 제어 및 컨텍스트를 더 많이 제공합니다. 반면, `unwrap` "
"메소드는 기본 오류 메시지로 패닉을 유발하며, 패닉의 원인에 대한 정보를 적게 제공합니다."

#: src/ch10-02-recoverable-errors.md:42
msgid ""
"The `expect_err` and `unwrap_err` have the exact opposite behavior. If the "
"`Result` is `Err(x)`, both methods return the value `x`. However, the key "
"difference between the two methods is in case of `Result::Ok()`. The "
"`expect_err` method allows you to provide a custom error message (as a "
"`felt252` value) that will be used when panicking, giving you more control "
"and context over the panic. On the other hand, the `unwrap_err` method "
"panics with a default error message, providing less information about the "
"cause of the panic."
msgstr ""
"`expect_err`와 `unwrap_err`는 정반대의 동작을 합니다. 만약 `Result`가 `Err(x)`인 경우, 두 메서드는 "
"모두 값 `x`를 반환합니다. 그러나 두 메서드의 주요 차이점은 `Result::Ok()`인 경우에 있습니다. `expect_err` "
"메서드는 패닉이 발생할 때 사용될 사용자 정의 오류 메시지(`felt252` 값)를 제공할 수 있게 해주어 패닉에 대한 더 많은 제어와 "
"컨텍스트를 제공합니다. 반면, `unwrap_err` 메서드는 기본 오류 메시지로 패닉을 발생시키며, 패닉의 원인에 대한 정보를 덜 "
"제공합니다."

#: src/ch10-02-recoverable-errors.md:44
msgid ""
"A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the "
"first four methods signatures. This syntax represents generic type "
"constraints in the Cairo language. These constraints indicate that the "
"associated functions require an implementation of the `Drop` trait for the "
"generic types `T` and `E`, respectively."
msgstr ""
"세심한 독자는 첫 네 가지 메서드 시그니처에서 `<+Drop<T>>`와 `<+Drop<E>>`를 주목했을 수 있습니다. 이 구문은 카이로"
" 언어에서 일반적인 유형 제약을 나타냅니다. 이 제약은 관련 함수가 각각 일반 유형 `T`와 `E`에 대한 `Drop` 트레이트의 구현을"
" 필요로 함을 나타냅니다."

#: src/ch10-02-recoverable-errors.md:46
msgid ""
"Finally, the `is_ok` and `is_err` methods are utility functions provided by "
"the `ResultTrait` trait to check the variant of a `Result` enum value."
msgstr ""
"마지막으로, `is_ok` 및 `is_err` 메서드는 `ResultTrait` 트레이트에서 제공되는 유틸리티 함수로, `Result` "
"열거형 값의 변형을 확인하는 데 사용됩니다."

#: src/ch10-02-recoverable-errors.md:48
msgid ""
"`is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the"
" `Result` is the `Ok` variant, meaning the operation was successful. If the "
"`Result` is the `Err` variant, it returns `false`."
msgstr ""
"`is_ok`는 `Result<T, E>` 값을 스냅샷으로 촬영하고, `Result`가 `Ok` 변형인 경우 작업이 성공했음을 의미하므로"
" `true`를 반환합니다. `Result`가 `Err` 변형인 경우 `false`를 반환합니다."

#: src/ch10-02-recoverable-errors.md:50
msgid ""
"`is_err` takes a snapshot to a `Result<T, E>` value and returns `true` if "
"the `Result` is the `Err` variant, meaning the operation encountered an "
"error. If the `Result` is the `Ok` variant, it returns `false`."
msgstr ""
"`is_err`는 `Result<T, E>` 값에 대한 스냅샷을 취하고, 해당 `Result`가 `Err` 변형인 경우에는 `true`를"
" 반환하여 작업이 오류를 만났음을 나타냅니다. `Result`가 `Ok` 변형인 경우에는 `false`를 반환합니다."

#: src/ch10-02-recoverable-errors.md:52
msgid ""
"These methods are helpful when you want to check the success or failure of "
"an operation without consuming the Result value, allowing you to perform "
"additional operations or make decisions based on the variant without "
"unwrapping it."
msgstr ""
"이러한 방법들은 결과 값을 소비하지 않고 작업의 성공 또는 실패를 확인하고, 해당 변형을 풀지 않고도 추가 작업을 수행하거나 해당 변형을"
" 기반으로 결정을 내릴 수 있도록 도와줍니다."

#: src/ch10-02-recoverable-errors.md:54
msgid ""
"You can find the implementation of the `ResultTrait` "
"[here](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/result.cairo#L20)."
msgstr ""
"`ResultTrait`의 구현은 [여기](https://github.com/starkware-"
"libs/cairo/blob/main/corelib/src/result.cairo#L20)에서 찾을 수 있습니다."

#: src/ch10-02-recoverable-errors.md:58
msgid "It is always easier to understand with examples."
msgstr "예시를 통해 이해하는 것이 항상 더 쉽습니다."

#: src/ch10-02-recoverable-errors.md:60
msgid "Have a look at this function signature:"
msgstr "이 함수 서명을 살펴보세요."

#: src/ch10-02-recoverable-errors.md:66
msgid ""
"It takes two u128 integers, a and b, and returns a `Result<u128, u128>` "
"where the `Ok` variant holds the sum if the addition does not overflow, and "
"the `Err` variant holds the overflowed value if the addition does overflow."
msgstr ""
"두 개의 u128 정수, a와 b를 가져와서 덧셈이 오버플로우되지 않을 경우 합계를 보유하는 `Result<u128, u128>`를 "
"반환합니다. 덧셈이 오버플로우되면 오버플로우된 값을 보유하는 `Err` 변형이 반환됩니다."

#: src/ch10-02-recoverable-errors.md:68
msgid "Now, we can use this function elsewhere. For instance:"
msgstr "이제, 우리는 이 기능을 다른 곳에서도 사용할 수 있습니다. 예를 들어:"

#: src/ch10-02-recoverable-errors.md:79
msgid ""
"Here, it accepts two u128 integers, a and b, and returns an `Option<u128>`. "
"It uses the `Result` returned by `u128_overflowing_add` to determine the "
"success or failure of the addition operation. The match expression checks "
"the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it "
"returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it "
"returns `Option::None` to indicate that the operation has failed due to "
"overflow. The function does not panic in case of an overflow."
msgstr ""
"여기서는 두 개의 u128 정수, a와 b를 받아 `Option<u128>`을 반환합니다. `u128_overflowing_add`에 "
"의해 반환된 `Result`를 사용하여 덧셈 작업의 성공 또는 실패를 결정합니다. match 표현식은 "
"`u128_overflowing_add`에서 반환된 `Result`를 확인합니다. 결과가 `Ok(r)`인 경우 합계를 포함하는 "
"`Option::Some(r)`을 반환합니다. 결과가 `Err(r)`인 경우 오버플로우로 작업이 실패했음을 나타내기 위해 "
"`Option::None`을 반환합니다. 이 함수는 오버플로우 발생 시 패닉하지 않습니다."

#: src/ch10-02-recoverable-errors.md:81
msgid "Let's take another example demonstrating the use of `unwrap`."
msgstr "`unwrap`의 사용을 보여주는 또 다른 예제를 살펴보겠습니다."

#: src/ch10-02-recoverable-errors.md:92
msgid "Listing 10-1: Using the Result type"
msgstr "리스트 10-1: 결과 유형 사용하기"

#: src/ch10-02-recoverable-errors.md:94
msgid ""
"In this example, the `parse_u8` function takes a `felt252` integer and tries"
" to convert it into a `u8` integer using the `try_into` method. If "
"successful, it returns `Result::Ok(value)`, otherwise it returns "
"`Result::Err('Invalid integer')`."
msgstr ""
"이 예제에서 `parse_u8` 함수는 `felt252` 정수를 가져와 `try_into` 메서드를 사용하여 `u8` 정수로 변환하려고 "
"시도합니다. 성공하면 `Result::Ok(value)`를 반환하고, 그렇지 않으면 `Result::Err('잘못된 정수')`를 "
"반환합니다."

#: src/ch10-02-recoverable-errors.md:96
msgid "Our two test cases are:"
msgstr "우리의 두 가지 테스트 케이스는:"

#: src/ch10-02-recoverable-errors.md:112
msgid "// should not panic\n"
msgstr "// 동요하지 말아야 합니다"

#: src/ch10-02-recoverable-errors.md:120
msgid "// should panic\n"
msgstr "패닉해야 함"

#: src/ch10-02-recoverable-errors.md:128
msgid ""
"The first one tests a valid conversion from `felt252` to `u8`, expecting the"
" `unwrap` method not to panic. The second test function attempts to convert "
"a value that is out of the `u8` range, expecting the `unwrap` method to "
"panic with the error message 'Invalid integer'."
msgstr ""
"첫 번째 테스트는 `felt252`에서 `u8`로의 유효한 변환을 시도하며, `unwrap` 메서드가 패닉하지 않는 것을 기대합니다. 두"
" 번째 테스트 함수는 `u8` 범위를 벗어나는 값을 변환하려고 시도하며, 'Invalid integer' 오류 메시지와 함께 "
"`unwrap` 메서드가 패닉할 것으로 예상합니다."

#: src/ch10-02-recoverable-errors.md:130
msgid "The `?` operator"
msgstr "`?` 연산자"

#: src/ch10-02-recoverable-errors.md:132
msgid ""
"The last operator we will talk about is the `?` operator. The `?` operator "
"is used for more idiomatic and concise error handling. When you use the `?` "
"operator on a `Result` or `Option` type, it will do the following:"
msgstr ""
"다음은 `?` 연산자에 대해 이야기할 마지막 연산자입니다. `?` 연산자는 더 익숙하고 간결한 오류 처리에 사용됩니다. `Result` "
"또는 `Option` 유형에 `?` 연산자를 사용하면 다음을 수행합니다:"

#: src/ch10-02-recoverable-errors.md:134
msgid ""
"If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the "
"inner value `x` directly."
msgstr "값이 `Result::Ok(x)` 또는 `Option::Some(x)`인 경우 내부 값 `x`를 직접 반환합니다."

#: src/ch10-02-recoverable-errors.md:135
msgid ""
"If the value is `Result::Err(e)` or `Option::None`, it will propagate the "
"error or `None` by immediately returning from the function."
msgstr ""
"값이 `Result::Err(e)` 또는 `Option::None`인 경우, 해당 오류 또는 `None`을 즉시 함수에서 반환하여 "
"전파합니다."

#: src/ch10-02-recoverable-errors.md:137
msgid ""
"The `?` operator is useful when you want to handle errors implicitly and let"
" the calling function deal with them."
msgstr "`?` 연산자는 오류를 암시적으로 처리하고 호출하는 함수가 그것을 처리하도록 하고 싶을 때 유용합니다."

#: src/ch10-02-recoverable-errors.md:139
msgid "Here is an example."
msgstr "여기 예시가 있습니다."

#: src/ch10-02-recoverable-errors.md:144 src/ch10-02-recoverable-errors.md:166
msgid "// DO SOMETHING\n"
msgstr "// 무언가를 하다"

#: src/ch10-02-recoverable-errors.md:150
msgid "Listing 10-1: Using the `?` operator"
msgstr "리스트 10-1: `?` 연산자 사용하기"

#: src/ch10-02-recoverable-errors.md:152
msgid ""
"`do_something_with_parse_u8` function takes a `felt252` value as input and "
"calls `parse_u8`. The `?` operator is used to propagate the error, if any, "
"or unwrap the successful value."
msgstr ""
"`do_something_with_parse_u8` 함수는 `felt252` 값이 입력으로 전달되고 `parse_u8`를 호출합니다. "
"`?` 연산자는 오류를 전파하거나 성공적인 값으로 언래합니까."

#: src/ch10-02-recoverable-errors.md:154
msgid "And with a little test case:"
msgstr "그리고 작은 테스트 케이스로:"

#: src/ch10-02-recoverable-errors.md:178
msgid "\"Result: {}\""
msgstr "\"결과: {}\""

#: src/ch10-02-recoverable-errors.md:179
msgid "\"Error: {}\""
msgstr "\"에러: {}\""

#: src/ch10-02-recoverable-errors.md:186
msgid "The console will print the error \"Invalid Integer\"."
msgstr "콘솔은 \"잘못된 정수\" 오류를 출력할 것입니다."

#: src/ch10-02-recoverable-errors.md:192
msgid ""
"We saw that recoverable errors can be handled in Cairo using the Result "
"enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is "
"generic, with types `T` and `E` representing the successful and error "
"values, respectively. The `ResultTrait` provides methods for working with "
"`Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or"
" `Err`, and panicking with custom messages."
msgstr ""
"우리는 카이로에서 Result 열거형을 사용하여 복구 가능한 오류를 처리할 수 있다는 것을 보았습니다. Result 열거형에는 `Ok`와"
" `Err` 두 가지 변형이 있습니다. `Result<T, E>` 열거형은 제네릭이며, `T`와 `E` 타입은 각각 성공 및 오류 값을 "
"나타냅니다. `ResultTrait`는 `Result<T, E>`와 함께 작업하는 메서드를 제공하며, 값 언래핑, 결과가 `Ok` 또는 "
"`Err`인지 확인, 사용자 정의 메시지로 패닉하는 등의 작업을 수행할 수 있습니다."

#: src/ch10-02-recoverable-errors.md:194
msgid ""
"To handle recoverable errors, a function can return a `Result` type and use "
"pattern matching to handle the success or failure of an operation. The `?` "
"operator can be used to implicitly handle errors by propagating the error or"
" unwrapping the successful value. This allows for more concise and clear "
"error handling, where the caller is responsible for managing errors raised "
"by the called function."
msgstr ""
"복구 가능한 오류를 처리하기 위해 함수는 `Result` 타입을 반환하고 패턴 매칭을 사용하여 작업의 성공 또는 실패를 처리할 수 "
"있습니다. `?` 연산자를 사용하여 오류를 암시적으로 처리하거나 성공적인 값을 언래핑하여 오류를 전파할 수 있습니다. 이를 통해 호출자가"
" 호출된 함수에서 발생한 오류를 관리하는 더 간결하고 명확한 오류 처리가 가능해집니다."

#: src/ch11-00-advanced-features.md:3
msgid "Now, let's learn about more advanced features offered by Cairo."
msgstr "지금, 카이로가 제공하는 더 고급 기능에 대해 배워 봅시다."

#: src/ch11-01-operator-overloading.md:3
msgid ""
"Operator overloading is a feature in some programming languages that allows "
"the redefinition of standard operators, such as addition (+), subtraction "
"(-), multiplication (\\*), and division (/), to work with user-defined "
"types. This can make the syntax of the code more intuitive, by enabling "
"operations on user-defined types to be expressed in the same way as "
"operations on primitive types."
msgstr ""
"연산자 오버로딩은 일부 프로그래밍 언어의 기능으로, 덧셈(+), 뺄셈(-), 곱셈(\\*), 나눗셈(/)과 같은 표준 연산자를 재정의하여"
" 사용자 정의 타입과 작동하도록 허용합니다. 이는 코드의 구문을 더 직관적으로 만들어 주어 사용자 정의 타입에 대한 연산을 기본 타입에 "
"대한 연산과 동일한 방식으로 표현할 수 있게 합니다."

#: src/ch11-01-operator-overloading.md:5
msgid ""
"In Cairo, operator overloading is achieved through the implementation of "
"specific traits. Each operator has an associated trait, and overloading that"
" operator involves providing an implementation of that trait for a custom "
"type. However, it's essential to use operator overloading judiciously. "
"Misuse can lead to confusion, making the code more difficult to maintain, "
"for example when there is no semantic meaning to the operator being "
"overloaded."
msgstr ""
"카이로에서 연산자 오버로딩은 특정 특성의 구현을 통해 달성됩니다. 각 연산자에는 연관된 특성이 있으며, 해당 연산자의 오버로딩은 사용자 "
"정의 타입에 대한 해당 특성의 구현을 제공하는 것을 포함합니다. 그러나 연산자 오버로딩을 분별하여 사용하는 것이 중요합니다. 남용은 "
"혼란을 야기할 수 있으며, 연산자 오버로딩에 의미가 없는 경우 코드를 유지하기 어렵게 만들 수 있습니다."

#: src/ch11-01-operator-overloading.md:8
msgid ""
"Consider an example where two `Potions` need to be combined. `Potions` have "
"two data fields, mana and health. Combining two `Potions` should add their "
"respective fields."
msgstr ""
"두 개의 '물약'을 결합해야 하는 예시를 고려해보세요. '물약'은 마나와 체력 두 가지 데이터 필드를 가지고 있습니다. 두 개의 "
"'물약'을 결합하면 각각의 필드를 더해야 합니다."

#: src/ch11-01-operator-overloading.md:26
msgid "// Both potions were combined with the `+` operator.\n"
msgstr "두 물약은 `+` 연산자로 결합되었습니다."

#: src/ch11-01-operator-overloading.md:32
msgid ""
"In the code above, we're implementing the `Add` trait for the `Potion` type."
" The add function takes two arguments: `lhs` and `rhs` (left and right-hand "
"side). The function body returns a new `Potion` instance, its field values "
"being a combination of `lhs` and `rhs`."
msgstr ""
"위의 코드에서는 `Potion` 유형에 대해 `Add` 트레이트를 구현하고 있습니다. add 함수는 두 개의 인수 `lhs`와 `rhs`"
" (왼쪽 및 오른쪽)를 사용합니다. 함수 본문은 새로운 `Potion` 인스턴스를 반환하며, 그 필드 값은 `lhs`와 `rhs`의 "
"조합입니다."

#: src/ch11-01-operator-overloading.md:34
msgid ""
"As illustrated in the example, overloading an operator requires "
"specification of the concrete type being overloaded. The overloaded generic "
"trait is `Add<T>`, and we define a concrete implementation for the type "
"`Potion` with `Add<Potion>`."
msgstr ""
"예시에서 보듯이, 연산자 오버로딩은 오버로딩되는 구체적인 유형을 명시해야 합니다. 오버로딩된 일반적인 특성은 `Add<T>`이며, 우리는"
" `Potion` 유형에 대한 구체적인 구현을 `Add<Potion>`으로 정의합니다."

#: src/ch11-02-macros.md:3
msgid ""
"The Cairo language has some plugins that allows developers to simplify their"
" code. They are called `inline_macros` and are a way of writing code that "
"generates other code."
msgstr ""
"카이로 언어에는 개발자가 코드를 간소화할 수 있는 몇 가지 플러그인이 있습니다. 이들은 `inline_macros`라고 불리며 다른 "
"코드를 생성하는 방식의 코드 작성 방법입니다."

#: src/ch11-02-macros.md:5
msgid "`print!` and `println!` macros"
msgstr "`print!` 및 `println!` 매크로"

#: src/ch11-02-macros.md:7
msgid "Two macros are available for printing values:"
msgstr "값을 인쇄하는 두 가지 매크로가 있습니다."

#: src/ch11-02-macros.md:8
msgid "`println!` which prints on a new line "
msgstr "`println!`은 새로운 줄에 출력합니다."

#: src/ch11-02-macros.md:9
msgid "`print!` with inline printing"
msgstr "인라인 인쇄와 함께 `print!`"

#: src/ch11-02-macros.md:11
msgid ""
"Both can be used with curly brackets as placeholders that hold a value in "
"place:"
msgstr "둘 다 값이 위치를 대신하는 자리 표시자로 중괄호를 사용할 수 있습니다."

#: src/ch11-02-macros.md:12
msgid ""
"When printing the value of a variable, the variable name can go inside the "
"curly brackets."
msgstr "변수의 값을 출력할 때, 변수 이름은 중괄호 안에 들어갈 수 있습니다."

#: src/ch11-02-macros.md:13
msgid ""
"When printing the result of evaluating an expression, use empty curly "
"brackets in the format string, then follow the format string with a comma-"
"separated list of expressions to print in each empty curly bracket "
"placeholder in the same order."
msgstr ""
"식을 평가한 결과를 출력할 때, 형식 문자열에 빈 중괄호를 사용한 후 형식 문자열 다음에 쉼표로 구분된 표현식 목록을 빈 중괄호 자리에 "
"동일한 순서로 출력하세요."

#: src/ch11-02-macros.md:15
msgid "`consteval_int!` macro"
msgstr "`consteval_int!` 매크로"

#: src/ch11-02-macros.md:17
msgid ""
"In some situations, a developer might need to declare a constant that is the"
" result of a computation of integers. To compute a constant expression and "
"use its result at compile time, it is required to use the `consteval_int!` "
"macro."
msgstr ""
"일부 상황에서 개발자는 정수의 계산 결과로 상수를 선언해야 할 수도 있습니다. 상수 식을 계산하고 컴파일 시간에 그 결과를 사용하려면 "
"`consteval_int!` 매크로를 사용해야 합니다."

#: src/ch11-02-macros.md:19
msgid "Here is an example of `consteval_int!`:"
msgstr "다음은 `consteval_int!`의 예입니다:"

#: src/ch11-02-macros.md:25
msgid "This will be interpreted as `const a: felt252 = 8;` by the compiler."
msgstr "이는 컴파일러에 의해 `const a: felt252 = 8;`로 해석될 것입니다."

#: src/ch11-02-macros.md:29
msgid "Please refer to the [Arrays](./ch03-01-arrays.md) page."
msgstr "[Arrays](./ch03-01-arrays.md) 페이지를 참조해주세요."

#: src/ch11-02-macros.md:31
msgid "`panic!`, `assert!` and `assert_eq!` macros macro"
msgstr "`panic!`, `assert!` 및 `assert_eq!` 매크로입니다."

#: src/ch11-02-macros.md:33
msgid ""
"See [Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-"
"panic.md) page."
msgstr ""
"[패닉과 복구 불가능한 오류](./ch10-01-unrecoverable-errors-with-panic.md) 페이지를 참조하세요."

#: src/ch11-02-macros.md:35
msgid "`format!` macro"
msgstr "`format!` 매크로"

#: src/ch11-02-macros.md:37
msgid ""
"The `format!` macro works like `println!`, but instead of printing the "
"output to the screen, it returns a  `ByteArray` with the contents. In the "
"following example, we perform string concatenation using either the `+` "
"operator or the `format!` macro.  The version of the code using `format!` is"
" much easier to read, and the code generated by the `format!` macro uses "
"snapshots so that this call doesn’t take ownership of any of its parameters."
msgstr ""
"`format!` 매크로는 `println!`과 비슷하게 작동하지만 출력을 화면에 표시하는 대신 내용이 담긴 `ByteArray`를 "
"반환합니다. 다음 예제에서는 `+` 연산자나 `format!` 매크로를 사용하여 문자열 연결을 수행합니다. `format!`를 사용한 "
"코드 버전은 훨씬 더 읽기 쉽고, `format!` 매크로에 의해 생성된 코드는 스냅샷을 사용하여 이 호출이 매개변수 중 어느 것도 "
"소유권을 가져가지 않도록 합니다."

#: src/ch11-02-macros.md:46 src/ch11-02-macros.md:52
msgid "\"tic\""
msgstr ""

#: src/ch11-02-macros.md:47 src/ch11-02-macros.md:53
msgid "\"tac\""
msgstr ""

#: src/ch11-02-macros.md:48 src/ch11-02-macros.md:54
msgid "\"toe\""
msgstr "\"발가락\""

#: src/ch11-02-macros.md:49
msgid "\"-\""
msgstr "\"-\""

#: src/ch11-02-macros.md:50
msgid "// using + operator consumes the strings, so they can't be used again!\n"
msgstr "// + 연산자를 사용하면 문자열이 소비되어 다시 사용할 수 없습니다!"

#: src/ch11-02-macros.md:55
msgid "\"{s1}-{s2}-{s3}\""
msgstr "\"{s1}-{s2}-{s3}\" "

#: src/ch11-02-macros.md:55
msgid ""
"// s1, s2, s3 are not consumed by format!\n"
"    // or\n"
msgstr ""
"// s1, s2, s3는 format에 의해 사용되지 않습니다!\n"
"    // 또는"

#: src/ch11-02-macros.md:57
msgid "\"{}-{}-{}\""
msgstr "\"{}-{}-{}\""

#: src/ch11-02-macros.md:58 src/ch11-02-macros.md:77
msgid "\"{}\""
msgstr ""
"I'm sorry, but the text you provided is empty. Please provide the text you "
"would like me to translate to Korean."

#: src/ch11-02-macros.md:62
msgid "`write!` macro"
msgstr "`write!` 매크로"

#: src/ch11-02-macros.md:64
msgid ""
"The `write!` and `writeln!` are two macros which are used to emit the format"
" string to a specified stream. This macro takes 2 arguments:"
msgstr ""
"`write!`와 `writeln!`은 지정된 스트림으로 형식 문자열을 출력하는 데 사용되는 두 개의 매크로입니다. 이 매크로는 2개의 "
"인수를 사용합니다."

#: src/ch11-02-macros.md:66
msgid ""
"a Formatter, which is a struct containing a `ByteArray`, representing the "
"pending result of formatting (the _stream_)"
msgstr "`ByteArray`를 포함하는 구조체인 포매터, 이는 포맷팅의 보류 중인 결과를 나타냅니다. ( _스트림_ )"

#: src/ch11-02-macros.md:67
msgid "the 'ByteArray' to append to the formatter"
msgstr "포매터에 추가할 'ByteArray'"

#: src/ch11-02-macros.md:69
msgid ""
"Calling this macro will append the provided `ByteArray` string to the "
"formatter. Example usage is:"
msgstr "이 매크로를 호출하면 제공된 `ByteArray` 문자열이 포매터에 추가됩니다. 사용 예는 다음과 같습니다:"

#: src/ch11-02-macros.md:75
msgid "\"hello\""
msgstr "안녕하세요"

#: src/ch11-02-macros.md:76
msgid "\"world\""
msgstr "세계"

#: src/ch11-02-macros.md:77
msgid "// helloworld\n"
msgstr "// 안녕세상"

#: src/ch11-03-hash.md:1
msgid "Hashes"
msgstr "해시들"

#: src/ch11-03-hash.md:3
msgid ""
"At its essence, hashing is a process of converting input data (often called "
"a message) of any length into a fixed-size value, typically referred to as a"
" \"hash.\" This transformation is deterministic, meaning that the same input"
" will always produce the same hash value. Hash functions are a fundamental "
"component in various fields, including data storage, cryptography, and data "
"integrity verification - and are very often when developing smart contracts,"
" especially when working with Merkle trees."
msgstr ""
"핵심적으로 해싱은 임의의 길이를 가진 입력 데이터(일반적으로 메시지라고 함)를 고정 크기의 값으로 변환하는 과정입니다. 이 값은 "
"일반적으로 \"해시\"라고 불립니다. 이 변환은 결정론적이며, 동일한 입력은 항상 동일한 해시 값을 생성합니다. 해시 함수는 데이터 "
"저장, 암호학, 데이터 무결성 검증을 포함한 다양한 분야에서 기본 구성 요소이며, 특히 Merkle 트리와 함께 작업할 때 스마트 계약을"
" 개발할 때 매우 자주 사용됩니다."

#: src/ch11-03-hash.md:5
msgid ""
"In this chapter, we will present the two hash functions implemented natively"
" in the Cairo library : `Poseidon` and `Pedersen`. We will discuss about "
"when and how to use them, and see examples with cairo programs."
msgstr ""
"이 장에서는 Cairo 라이브러리에 네이티브로 구현된 두 해시 함수인 `Poseidon`과 `Pedersen`을 소개할 것입니다. 언제 "
"그리고 어떻게 사용하는지에 대해 논의하고, cairo 프로그램 예제를 살펴볼 것입니다."

#: src/ch11-03-hash.md:7
msgid "Hash functions in Cairo"
msgstr "카이로의 해시 함수"

#: src/ch11-03-hash.md:9
msgid ""
"The Cairo core library provides two hash functions: Pedersen and Poseidon."
msgstr "카이로 코어 라이브러리는 Pedersen과 Poseidon 두 개의 해시 함수를 제공합니다."

#: src/ch11-03-hash.md:11
msgid ""
"Pedersen hash functions are cryptographic algorithms that rely on elliptic "
"curve cryptography. These functions perform operations on points along an "
"elliptic curve — essentially, doing math with the locations of these points "
"— which are easy to do in one direction and hard to undo. This one-way "
"difficulty is based on the Elliptic Curve Discrete Logarithm Problem "
"(ECDLP), which is a problem so hard to solve that it ensures the security of"
" the hash function. The difficulty of reversing these operations is what "
"makes the Pedersen hash function secure and reliable for cryptographic "
"purposes."
msgstr ""
"페더슨 해시 함수는 타원 곡선 암호학을 기반으로 하는 암호 알고리즘입니다. 이러한 함수들은 타원 곡선 위의 점들에 대한 연산을 "
"수행하는데, 이는 본질적으로 이러한 점들의 위치에 대한 수학적 연산을 하는 것입니다. 이러한 연산은 한 방향으로 쉽게 수행되지만 되돌릴 "
"수 없게 어렵습니다. 이 단방향 어려움은 타원 곡선 이산 로그 문제(ECDLP)에 기반하고 있으며, 이 문제는 해결하기 어려운 정도로 "
"어렵기 때문에 해시 함수의 보안을 보장합니다. 이러한 연산을 되돌리는 어려움이 페더슨 해시 함수를 암호학적 목적으로 안전하고 신뢰할 수 "
"있게 만듭니다."

#: src/ch11-03-hash.md:13
msgid ""
"Poseidon is a family of hash functions designed for being very efficient as "
"algebraic circuits. Its design is particularly efficient for Zero-Knowledge "
"proof systems, including STARKs (so, Cairo). Poseidon uses a method called a"
" 'sponge construction,' which soaks up data and transforms it securely using"
" a process known as the Hades permutation. Cairo's version of Poseidon is "
"based on a three element state permutation with [specific "
"parameters](https://github.com/starkware-"
"industries/poseidon/blob/main/poseidon3.txt)."
msgstr ""
"포세이돈은 대수 회로로 매우 효율적인 해시 함수 패밀리로 설계되었습니다. 그 설계는 특히 제로-지식 증명 시스템, STARKs (그리고 "
"카이로)를 위해 특히 효율적입니다. 포세이돈은 '스펀지 구조'라는 방법을 사용하며, 이 방법은 데이터를 흡수하고 하데스 순열이라고 알려진"
" 프로세스를 사용하여 안전하게 변환합니다. 카이로의 포세이돈 버전은 [구체적인 "
"매개변수](https://github.com/starkware-"
"industries/poseidon/blob/main/poseidon3.txt)를 사용한 세 요소 상태 순열에 기반합니다."

#: src/ch11-03-hash.md:15
msgid "When to use them ?"
msgstr "그들을 언제 사용해야 하나요?"

#: src/ch11-03-hash.md:17
msgid ""
"Pedersen was the first hash function used on Starknet, and is still used to "
"compute the addresses of variables in storage (for example, `LegacyMap` uses"
" Pedersen to hash the keys of a storage mapping on Starknet). However, as "
"Poseidon is cheaper and faster than Pedersen when working with STARK proofs "
"system, it's now the recommended hash function to use in Cairo programs."
msgstr ""
"페더슨은 Starknet에서 사용된 첫 해시 함수였으며, 여전히 스토리지 변수의 주소를 계산하는 데 사용됩니다 (예: "
"`LegacyMap`은 Starknet의 스토리지 매핑의 키를 해싱하기 위해 Pedersen을 사용합니다). 그러나 Poseidon은 "
"STARK 증명 시스템과 함께 작업할 때 Pedersen보다 저렴하고 빠르기 때문에, 현재는 Cairo 프로그램에서 사용하는 권장 해시 "
"함수입니다."

#: src/ch11-03-hash.md:21
msgid ""
"The core library makes it easy to work with hashes. The `Hash` trait is "
"implemented for all types that can be converted to `felt252`, including "
"`felt252` itself. For more complex types like structs, deriving `Hash` "
"allows them to be hashed easily using the hash function of your choice - "
"given that all of the struct's fields are themselves hashable. You cannot "
"derive the `Hash` trait on a struct that contains un-hashable values, such "
"as `Array<T>` or a `Felt252Dict<T>`, even if `T` itself is hashable."
msgstr ""
"핵심 라이브러리는 해시와 작업하기 쉽게 만듭니다. `Hash` 트레이트는 `felt252`로 변환할 수 있는 모든 유형에 대해 구현되어 "
"있으며, 이는 `felt252` 자체를 포함합니다. 구조체와 같은 보다 복잡한 유형의 경우 `Hash`를 파생하여 선택한 해시 함수를 "
"사용하여 쉽게 해싱할 수 있습니다. 다만, 구조체의 모든 필드가 해시 가능한 경우에 한해 가능합니다. `Array<T>`나 "
"`Felt252Dict<T>`와 같이 해싱할 수 없는 값을 포함하는 구조체에 대해 `Hash` 트레이트를 파생할 수 없습니다. 단, "
"`T` 자체가 해시 가능한 경우에도 해당합니다."

#: src/ch11-03-hash.md:23
msgid ""
"The `Hash` trait is accompanied by the `HashStateTrait` that defines the "
"basic methods to work with hashes. They allow you to initialize a hash state"
" that will contain the temporary values of the hash after each application "
"of the hash function; update the hash state, and finalize it when the "
"computation is completed. `HashStateTrait` is defined as follows:"
msgstr ""
"`Hash` 트레이트는 해시와 관련된 `HashStateTrait`와 함께 제공되며, 해시와 작업하는 기본 메서드를 정의합니다. 이들은 "
"해시 함수를 적용한 후 해시의 임시 값들을 포함할 해시 상태를 초기화하고, 해시 상태를 업데이트하며, 계산이 완료되면 해시 상태를 "
"완료하는 것을 허용합니다. `HashStateTrait`는 다음과 같이 정의됩니다:"

#: src/ch11-03-hash.md:26
msgid "/// A trait for hash state accumulators.\n"
msgstr "해시 상태 누적기를 위한 특성입니다."

#: src/ch11-03-hash.md:32
msgid "/// A trait for values that can be hashed.\n"
msgstr "해싱할 수 있는 값에 대한 특성입니다."

#: src/ch11-03-hash.md:35
msgid "/// Updates the hash state with the given value.\n"
msgstr "주어진 값으로 해시 상태를 업데이트합니다."

#: src/ch11-03-hash.md:40
msgid ""
"To use hashes in your code, you must first import the relevant traits and "
"functions. In the following example, we will demonstrate how to hash a "
"struct using both the Pedersen and Poseidon hash functions."
msgstr ""
"당신의 코드에서 해시를 사용하려면 먼저 관련 특성과 함수를 가져와야 합니다. 다음 예제에서는 Pedersen 및 Poseidon 해시 "
"함수를 사용하여 구조체를 해싱하는 방법을 보여드리겠습니다."

#: src/ch11-03-hash.md:42
msgid ""
"The first step is to initialize the hash with either `PoseidonTrait::new() "
"-> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending "
"on which hash function we want to work with. Then the hash state can be "
"updated with the `update(self: HashState, value: felt252) -> HashState` or "
"`update_with(self: S, value: T) -> S` functions as many times as required. "
"Then the function `finalize(self: HashState) -> felt252` is called on the "
"hash state and it returns the value of the hash as a `felt252`."
msgstr ""
"첫 번째 단계는 작업하려는 해시 함수에 따라 `PoseidonTrait::new() -> HashState` 또는 "
"`PedersenTrait::new(base: felt252) -> HashState` 중 하나로 해시를 초기화하는 것입니다. 그런 다음"
" 해시 상태는 필요한 만큼 `update(self: HashState, value: felt252) -> HashState` 또는 "
"`update_with(self: S, value: T) -> S` 함수로 업데이트될 수 있습니다. 그런 다음 해시 상태에 대해 "
"`finalize(self: HashState) -> felt252` 함수가 호출되고 해시의 값이 `felt252`로 반환됩니다."

#: src/ch11-03-hash.md:68
msgid ""
"As our struct derives the trait HashTrait, we can call the function as "
"follows for Poseidon hashing :"
msgstr ""
"저희 구조체가 HashTrait 트레이트를 상속받았기 때문에 Poseidon 해싱을 위해 다음과 같이 함수를 호출할 수 있습니다:"

#: src/ch11-03-hash.md:92
msgid ""
"Pedersen is different from Poseidon, as it starts with a base state. This "
"base state must be of `felt252` type, which forces us to either hash the "
"struct with an arbitrary base state using the `update_with` method, or "
"serialize the struct into an array to loop through all of its fields and "
"hash its elements together."
msgstr ""
"페더슨은 포세이돈과 다릅니다. 왜냐하면 페더슨은 기본 상태로 시작하기 때문입니다. 이 기본 상태는 `felt252` 유형이어야 하며, "
"이는 우리에게 임의의 기본 상태로 구조체를 해싱하거나 `update_with` 메서드를 사용하여 구조체를 배열로 직렬화하여 모든 필드를 "
"루프를 통해 순회하고 그 요소들을 함께 해싱해야 한다는 것을 강제합니다."

#: src/ch11-03-hash.md:94
msgid "Here is a short example for Pedersen hashing :"
msgstr "여기 Pedersen 해싱에 대한 간단한 예제가 있습니다."

#: src/ch11-03-hash.md:111
msgid "// hash1 is the result of hashing a struct with a base state of 0\n"
msgstr "hash1은 기본 상태가 0인 구조체를 해싱한 결과입니다."

#: src/ch11-03-hash.md:124
msgid "// hash2 is the result of hashing only the fields of the struct\n"
msgstr "hash2는 구조체의 필드만 해싱한 결과입니다."

#: src/ch11-03-hash.md:133
msgid "Advanced Hashing: Hashing arrays with Poseidon"
msgstr "고급 해싱: 포세이돈을 사용한 해싱 배열"

#: src/ch11-03-hash.md:135
msgid ""
"Let us look at an example of hashing a function that contains a "
"`Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a "
"`Span<felt252>` you can use the built-in function in poseidon ` "
"poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly you can "
"hash `Array<felt252>` by calling `poseidon_hash_span` on its span."
msgstr ""
"`Span<felt252>`을 포함하는 함수를 해싱하는 예제를 살펴봅시다. `Span<felt252>` 또는 "
"`Span<felt252>`를 포함하는 구조체를 해싱하려면 포세이돈 내장 함수인 `poseidon_hash_span(mut span: "
"Span<felt252>) -> felt252`를 사용할 수 있습니다. 비슷하게 `Array<felt252>`를 해싱하려면 해당 "
"span에 `poseidon_hash_span`을 호출할 수 있습니다."

#: src/ch11-03-hash.md:139
msgid "First let us import the following trait and function :"
msgstr "먼저 다음 특성과 함수를 가져오도록 합시다:"

#: src/ch11-03-hash.md:147
msgid ""
"Now we define the structure, as you might have notice we didn't derived the "
"Hash trait. If you try to derive the Hash trait on this structure it will "
"rise an error because the structure contains a field not hashable."
msgstr ""
"이제 우리는 구조를 정의합니다. 아마도 주목했겠지만, 우리는 Hash 트레이트를 유도하지 않았습니다. 이 구조에 Hash 트레이트를 "
"유도하려고 하면, 구조에 해시할 수 없는 필드가 포함되어 있기 때문에 오류가 발생할 것입니다."

#: src/ch11-03-hash.md:160
msgid ""
"In this example, we initialized a HashState (`hash`) and updated it and then"
" called the function `finalize()` on the HashState to get the computed hash "
"`hash_felt252`. We used the `poseidon_hash_span` on the `Span` of the "
"`Array<felt252>` to compute its hash."
msgstr ""
"이 예시에서는 HashState(`hash`)를 초기화하고 업데이트한 후 HashState에서 함수 `finalize()`를 호출하여 "
"계산된 해시 `hash_felt252`를 얻었습니다. 우리는 `Array<felt252>`의 `Span`에 "
"`poseidon_hash_span`을 사용하여 해당 해시를 계산했습니다."

#: src/ch99-00-starknet-smart-contracts.md:3
msgid ""
"All through the previous sections, you've mostly written programs with a "
"`main` entrypoint. In the coming sections, you will learn to write and "
"deploy Starknet contracts."
msgstr ""
"이전 섹션을 통해 대부분 `main` 진입점을 가진 프로그램을 작성했습니다. 다음 섹션에서는 Starknet 계약을 작성하고 배포하는 "
"방법을 배우게 될 것입니다."

#: src/ch99-00-starknet-smart-contracts.md:5
msgid ""
"One of the applications of the Cairo language is to write smart contracts "
"for the Starknet network. Starknet is a permissionless network that "
"leverages zk-STARKs technology for scalability. As a Layer-2 scalability "
"solution for Ethereum, Starknet's goal is to offer fast, secure, and low-"
"cost transactions. It functions as a Validity Rollup (commonly known as a "
"zero-knowledge Rollup) and is built on top of the Cairo language and the "
"Starknet VM."
msgstr ""
"카이로 언어의 응용 중 하나는 Starknet 네트워크를 위한 스마트 계약을 작성하는 것입니다. Starknet은 확장성을 위해 zk-"
"STARKs 기술을 활용하는 허가되지 않은 네트워크입니다. 이더리움을 위한 Layer-2 확장성 솔루션으로, Starknet의 목표는 "
"빠르고 안전하며 저렴한 거래를 제공하는 것입니다. 이는 Validity Rollup(일반적으로 제로 지식 Rollup이라고 알려짐)으로 "
"작동하며, 카이로 언어와 Starknet VM 위에 구축되어 있습니다."

#: src/ch99-00-starknet-smart-contracts.md:7
msgid ""
"Starknet contracts, in simple words, are programs that can run on the "
"Starknet VM. Since they run on the VM, they have access to Starknet’s "
"persistent state, can alter or modify variables in Starknet’s states, "
"communicate with other contracts, and interact seamlessly with the "
"underlying L1."
msgstr ""
"스타크넷 계약은 간단히 말해, 스타크넷 VM에서 실행할 수 있는 프로그램입니다. VM에서 실행되기 때문에 스타크넷의 지속 상태에 액세스할"
" 수 있으며, 스타크넷 상태의 변수를 변경하거나 수정할 수 있으며, 다른 계약과 통신하고 기본 L1과 원활하게 상호 작용할 수 있습니다."

#: src/ch99-00-starknet-smart-contracts.md:9
msgid ""
"Starknet contracts are denoted by the `#[contract]` attribute. We'll dive "
"deeper into this in the next sections. If you want to learn more about the "
"Starknet network itself, its architecture and the tooling available, you "
"should read the [Starknet Book](https://book.starknet.io/). This section "
"will focus on writing smart contracts in Cairo."
msgstr ""
"Starknet 계약은 `#[contract]` 속성으로 표시됩니다. 다음 섹션에서 이에 대해 더 자세히 다룰 것입니다. Starknet"
" 네트워크 자체, 그 아키텍처 및 사용 가능한 도구에 대해 더 알고 싶다면 [Starknet "
"Book](https://book.starknet.io/)을 읽어보세요. 이 섹션은 Cairo에서 스마트 계약을 작성하는 데 초점을 맞출"
" 것입니다."

#: src/ch99-00-starknet-smart-contracts.md:12
msgid "Scarb"
msgstr "Scarb -> Scarb"

#: src/ch99-00-starknet-smart-contracts.md:14
msgid ""
"Scarb supports smart contract development for Starknet. To enable this "
"functionality, you'll need to make some configurations in your `Scarb.toml` "
"file (see [Installation](./ch01-01-installation.md) for how to install "
"Scarb). You have to add the `starknet` dependency and add a "
"`[[target.starknet-contract]]` section to enable contract compilation."
msgstr ""
"Scarb는 Starknet을 위한 스마트 계약 개발을 지원합니다. 이 기능을 활성화하려면 `Scarb.toml` 파일에서 몇 가지 구성을 "
"해야 합니다 (Scarb 설치 방법은 [설치](./ch01-01-installation.md)를 참조하세요). `starknet` "
"종속성을 추가하고 계약 컴파일을 가능하게 하려면 `[[target.starknet-contract]]` 섹션을 추가해야 합니다."

#: src/ch99-00-starknet-smart-contracts.md:17
msgid ""
"Below is the minimal Scarb.toml file required to compile a crate containing "
"Starknet contracts:"
msgstr "다음은 Starknet 계약을 포함하는 크레이트를 컴파일하는 데 필요한 최소한의 Scarb.toml 파일입니다:"

#: src/ch99-00-starknet-smart-contracts.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"package_name\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.4.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch99-00-starknet-smart-contracts.md:30
msgid ""
"For additional configuration, such as external contract dependencies, please"
" refer to the [Scarb "
"documentation](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#compiling-external-contracts)."
msgstr ""
"추가 구성, 예를 들어 외부 계약 종속성과 같은 경우, [Scarb "
"문서](https://docs.swmansion.com/scarb/docs/extensions/starknet/contract-"
"target.html#compiling-external-contracts)를 참조하십시오."

#: src/ch99-00-starknet-smart-contracts.md:32
msgid "Each example in this chapter can be used with Scarb."
msgstr "이 장의 각 예시는 Scarb와 함께 사용할 수 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:3
msgid ""
"This chapter will give you a high level introduction to what smart-contracts"
" are, what are they used for, and why would blockchain developers use Cairo "
"and Starknet. If you are already familiar with blockchain programming, feel "
"free to skip this chapter. The last part might still be interesting though."
msgstr ""
"이 장은 스마트 계약이 무엇인지, 어떻게 사용되는지, 그리고 왜 블록체인 개발자들이 Cairo와 Starknet을 사용하는지에 대한 "
"고수준 소개를 제공할 것입니다. 이미 블록체인 프로그래밍에 익숙하다면 이 장을 건너뛰어도 됩니다. 그러나 마지막 부분은 여전히 흥미로울 "
"수 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:6
msgid "Smart-contracts"
msgstr "스마트 계약"

#: src/ch99-01-01-introduction-to-smart-contracts.md:8
msgid ""
"Smart contracts gained popularity and became more widespread with the birth "
"of Ethereum. Smart contracts are essentially programs deployed on a "
"blockchain. The term \"smart contract\" is somewhat misleading, as they are "
"neither \"smart\" nor \"contracts\" but rather code and instructions that "
"are executed based on specific inputs. They primarily consist of two "
"components: storage and functions. Once deployed, users can interact with "
"smart contracts by initiating blockchain transactions containing execution "
"data (which function to call and with what input). Smart contracts can "
"modify and read the storage of the underlying blockchain. A smart contract "
"has its own address and is considered a blockchain account, meaning it can "
"hold tokens."
msgstr ""
"스마트 계약은 이더리움의 탄생과 함께 인기를 얻고 보급화되었습니다. 스마트 계약은 본질적으로 블록체인에 배포된 프로그램입니다. \"스마트"
" 계약\"이라는 용어는 다소 오해를 줄 수 있습니다. 그들은 \"스마트\"하거나 \"계약\"이 아니라 특정 입력에 기반하여 실행되는 "
"코드와 명령어입니다. 주로 두 가지 구성 요소로 이루어져 있습니다: 저장소와 함수. 배포된 후에는 사용자가 블록체인 트랜잭션을 시작하여 "
"실행 데이터를 포함시킬 수 있습니다 (어떤 입력으로 어떤 함수를 호출할지). 스마트 계약은 기본 블록체인의 저장소를 수정하고 읽을 수 "
"있습니다. 스마트 계약은 자체 주소를 가지고 있으며 블록체인 계정으로 간주되어 토큰을 보유할 수 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:10
msgid ""
"The programming language used to write smart contracts varies depending on "
"the blockchain. For example, on Ethereum and the [EVM-compatible "
"ecosystem](https://ethereum.org/en/developers/docs/evm/), the most commonly "
"used language is Solidity, while on Starknet, it is Cairo. The way the code "
"is compiled also differs based on the blockchain. On Ethereum, Solidity is "
"compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then "
"into Cairo Assembly (casm)."
msgstr ""
"스마트 계약을 작성하는 데 사용되는 프로그래밍 언어는 블록체인에 따라 다릅니다. 예를 들어, 이더리움 및 [EVM 호환 "
"생태계](https://ethereum.org/en/developers/docs/evm/)에서 가장 일반적으로 사용되는 언어는 "
"Solidity이며, Starknet에서는 Cairo입니다. 코드가 컴파일되는 방식도 블록체인에 따라 다릅니다. 이더리움에서는 "
"Solidity가 바이트코드로 컴파일됩니다. Starknet에서는 Cairo가 Sierra로 컴파일되고 그런 다음 Cairo "
"어셈블리(casm)로 컴파일됩니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:12
msgid ""
"Smart contracts possess several unique characteristics. They are "
"**permissionless**, meaning anyone can deploy a smart contract on the "
"network (within the context of a decentralized blockchain, of course). Smart"
" contracts are also **transparent**; the data stored by the smart contract "
"is accessible to anyone. The code that composes the contract can also be "
"transparent, enabling **composability**. This allows developers to write "
"smart contracts that use other smart contracts. Smart contracts can only "
"access and interact with data from the blockchain they are deployed on. They"
" require third-party software (called `oracles`) to access external data "
"(the price of a token for instance)."
msgstr ""
"스마트 계약은 몇 가지 독특한 특성을 가지고 있습니다. 그들은 **허가 없는** 특성을 가지고 있어 누구나 네트워크에 스마트 계약을 "
"배포할 수 있습니다 (물론 탈중앙화된 블록체인의 맥락 안에서). 스마트 계약은 또한 **투명**합니다; 스마트 계약에 의해 저장된 "
"데이터는 누구에게나 접근 가능합니다. 계약을 구성하는 코드도 투명할 수 있어 **가능성**을 제공합니다. 이는 개발자가 다른 스마트 "
"계약을 사용하는 스마트 계약을 작성할 수 있도록 합니다. 스마트 계약은 배포된 블록체인의 데이터에만 액세스하고 상호 작용할 수 있습니다."
" 외부 데이터에 액세스하기 위해 제3자 소프트웨어( `오라클` 라고 불림)가 필요합니다 (예를 들어 토큰의 가격)."

#: src/ch99-01-01-introduction-to-smart-contracts.md:14
msgid ""
"For developers to build smart contracts that can interact with each other, "
"it is required to know what the other contracts look like. Hence, Ethereum "
"developers started to build standards for smart contract development, the "
"`ERCxx`. The two most used and famous standards are the `ERC20`, used to "
"build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-"
"fungible tokens) like `CryptoPunks` or `Everai`."
msgstr ""
"개발자들이 서로 상호 작용할 수 있는 스마트 계약을 구축하기 위해서는 다른 계약이 어떻게 보이는지 알아야 합니다. 그래서 이더리움 "
"개발자들은 스마트 계약 개발을 위한 표준인 `ERCxx`를 만들기 시작했습니다. 가장 많이 사용되고 유명한 두 가지 표준은 "
"`ERC20`으로, `USDC`, `DAI`, 또는 `STARK`와 같은 토큰을 만드는 데 사용되며, `ERC721`은 "
"`CryptoPunks`나 `Everai`와 같은 NFT(대체 불가능한 토큰)를 위한 것입니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:16
msgid "Use cases"
msgstr "사용 사례"

#: src/ch99-01-01-introduction-to-smart-contracts.md:18
msgid ""
"There are many possible use cases for smart-contracts. The only limits are "
"the technical constraints of the blockchain and the creativity of "
"developers."
msgstr "스마트 계약에는 많은 가능한 사용 사례가 있습니다. 제한은 블록체인의 기술적 제약과 개발자들의 창의력뿐입니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:20
msgid "DeFi"
msgstr ""
"DeFi\n"
"\n"
"디파이"

#: src/ch99-01-01-introduction-to-smart-contracts.md:22
msgid ""
"Right now, the principal use case for smart contracts is similar to that of "
"Ethereum or Bitcoin, which is essentially handling money. In the context of "
"the alternative payment system promised by Bitcoin, smart contracts on "
"Ethereum enable the creation of decentralized financial applications that no"
" longer rely on traditional financial intermediaries. This is what we call "
"DeFi (decentralized finance). DeFi consists of various projects such as "
"lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives,"
" stablecoins, decentralized hedge funds, insurance, and many more."
msgstr ""
"현재 스마트 계약의 주요 사용 사례는 에테리움이나 비트코인과 유사하며, 본질적으로는 자금을 처리하는 것입니다. 비트코인이 약속한 대체 "
"결제 시스템의 맥락에서, 에테리움의 스마트 계약은 전통적인 금융 중개인에 의존하지 않는 탈중앙화된 금융 애플리케이션의 생성을 가능하게 "
"합니다. 이를 우리는 DeFi(탈중앙화된 금융)라고 합니다. DeFi에는 대출/차입 앱, 탈중앙화 거래소(DEX), 온체인 파생상품, "
"스테이블코인, 탈중앙화 헤지 펀드, 보험 등 다양한 프로젝트가 포함되어 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:24
msgid "Tokenization"
msgstr "토큰화"

#: src/ch99-01-01-introduction-to-smart-contracts.md:26
msgid ""
"Smart contracts can facilitate the tokenization of real-world assets, such "
"as real estate, art, or precious metals. Tokenization divides an asset into "
"digital tokens, which can be easily traded and managed on blockchain "
"platforms. This can increase liquidity, enable fractional ownership, and "
"simplify the buying and selling process."
msgstr ""
"스마트 계약은 부동산, 예술, 또는 귀금속과 같은 실제 자산의 토큰화를 용이하게 할 수 있습니다. 토큰화는 자산을 디지털 토큰으로 나누어"
" 블록체인 플랫폼에서 쉽게 거래하고 관리할 수 있게 합니다. 이는 유동성을 증가시키고 분할 소유권을 가능하게 하며 매매 과정을 간소화할 "
"수 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:28
msgid "Voting"
msgstr "투표"

#: src/ch99-01-01-introduction-to-smart-contracts.md:30
msgid ""
"Smart contracts can be used to create secure and transparent voting systems."
" Votes can be recorded on the blockchain, ensuring immutability and "
"transparency. The smart contract can then automatically tally the votes and "
"declare the results, minimizing the potential for fraud or manipulation."
msgstr ""
"스마트 계약은 안전하고 투명한 투표 시스템을 만드는 데 사용될 수 있습니다. 투표는 블록체인에 기록될 수 있어 변경 불가능성과 투명성을 "
"보장합니다. 스마트 계약은 그 후에 자동으로 투표를 집계하고 결과를 선언할 수 있어 사기나 조작 가능성을 최소화합니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:32
msgid "Royalties"
msgstr "로열티"

#: src/ch99-01-01-introduction-to-smart-contracts.md:34
msgid ""
"Smart contracts can automate royalty payments for artists, musicians, and "
"other content creators. When a piece of content is consumed or sold, the "
"smart contract can automatically calculate and distribute the royalties to "
"the rightful owners, ensuring fair compensation and reducing the need for "
"intermediaries."
msgstr ""
"스마트 계약은 예술가, 음악가 및 기타 콘텐츠 창작자들을 위한 로열티 지불을 자동화할 수 있습니다. 콘텐츠가 소비되거나 판매될 때, "
"스마트 계약은 자동으로 로열티를 정확히 계산하고 소유자들에게 분배하여 공정한 보상을 보장하고 중개인의 필요성을 줄입니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:36
msgid "Decentralized identities DIDs"
msgstr "분산 신원 DIDs"

#: src/ch99-01-01-introduction-to-smart-contracts.md:38
msgid ""
"Smart contracts can be used to create and manage digital identities, "
"allowing individuals to control their personal information and share it with"
" third parties securely. The smart contract could verify the authenticity of"
" a user's identity and automatically grant or revoke access to specific "
"services based on the user's credentials."
msgstr ""
"스마트 계약은 디지털 신원을 생성하고 관리하는 데 사용될 수 있으며, 개인이 개인 정보를 제어하고 안전하게 제3자와 공유할 수 있도록 "
"합니다. 스마트 계약은 사용자의 신원의 진위를 확인하고 사용자 자격 증명에 기반하여 특정 서비스에 대한 액세스를 자동으로 부여하거나 "
"철회할 수 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:44
msgid "The rise of Starknet and Cairo"
msgstr "스타크넷과 카이로의 부상"

#: src/ch99-01-01-introduction-to-smart-contracts.md:46
msgid ""
"Ethereum, being the most widely used and resilient smart-contract platform, "
"became a victim of its own success. With the rapid adoption of some "
"previously mentioned use cases, mainly DeFi, the cost of performing "
"transactions became extremely high, rendering the network almost unusable. "
"Engineers and researchers in the ecosystem began working on solutions to "
"address this scalability issue."
msgstr ""
"이더리움은 가장 널리 사용되는 강력한 스마트 계약 플랫폼으로, 자신의 성공의 희생자가 되었습니다. 이전에 언급된 사용 사례 중 일부, "
"주로 DeFi의 신속한 채택으로 인해 거래 수행 비용이 극도로 높아져 네트워크를 거의 사용할 수 없게 만들었습니다. 이 생태계의 "
"엔지니어와 연구자들은 이 확장성 문제를 해결하기 위한 솔루션에 대해 작업하기 시작했습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:48
msgid ""
"A famous trilemma ([The Blockchain "
"Trilemma](https://vitalik.ca/general/2021/04/07/sharding.html#the-"
"scalability-trilemma)) in the blockchain space states that it is impossible "
"to achieve a high level of scalability, decentralization, and security "
"simultaneously; trade-offs must be made. Ethereum is at the intersection of "
"decentralization and security. Eventually, it was decided that Ethereum's "
"purpose would be to serve as a secure settlement layer, while complex "
"computations would be offloaded to other networks built on top of Ethereum. "
"These are called Layer 2s (L2s)."
msgstr ""
"블록체인 분야의 유명한 삼중 딜레마([블록체인 삼중 "
"딜레마](https://vitalik.ca/general/2021/04/07/sharding.html#the-scalability-"
"trilemma))는 확장성, 분산화, 그리고 보안의 높은 수준을 동시에 달성하는 것은 불가능하다고 주장하며, 트레이드오프가 필요하다고 "
"합니다. 이더리움은 분산화와 보안의 교차점에 위치해 있습니다. 결국, 이더리움의 목적은 안전한 결제 계층으로 작용하는 동시에 복잡한 "
"계산은 이더리움 위에 구축된 다른 네트워크로 옮겨지도록 결정되었습니다. 이를 레이어 2(L2)라고 합니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:50
msgid ""
"The two primary types of L2s are optimistic rollups and validity rollups. "
"Both approaches involve compressing and batching numerous transactions "
"together, computing the new state, and settling the result on Ethereum (L1)."
" The difference lies in the way the result is settled on L1. For optimistic "
"rollups, the new state is considered valid by default, but there is a 7-day "
"window for nodes to identify malicious transactions."
msgstr ""
"L2의 두 가지 주요 유형은 낙관롤업(optimistic rollups)과 유효성 롤업(validity rollups)입니다. 두 접근 "
"방식 모두 많은 거래를 압축하고 일괄 처리하여 새로운 상태를 계산하고 결과를 이더리움(L1)에 결제하는 것을 포함합니다. 차이점은 결과가"
" L1에서 어떻게 결제되는지에 있습니다. 낙관롤업의 경우 새로운 상태는 기본적으로 유효하다고 간주되지만, 악의적인 거래를 식별할 노드에 "
"대한 7일 윈도우가 있습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:52
msgid ""
"In contrast, validity rollups, such as Starknet, use cryptography to prove "
"that the new state has been correctly computed. This is the purpose of "
"STARKs, this cryptographic technology could permit validity rollups to scale"
" significantly more than optimistic rollups. You can learn more about STARKs"
" from Starkware's Medium [article](https://medium.com/starkware/starks-"
"starkex-and-starknet-9a426680745a), which serves as a good primer."
msgstr ""
"대조적으로, Starknet과 같은 유효성 롤업은 암호학을 사용하여 새 상태가 올바르게 계산되었음을 증명합니다. 이것이 STARKs의 "
"목적이며, 이 암호 기술은 낙관적 롤업보다 유효성 롤업이 훨씬 더 확장될 수 있도록 할 수 있습니다. Starkware의 Medium "
"[기사](https://medium.com/starkware/starks-starkex-and-"
"starknet-9a426680745a)에서 STARKs에 대해 더 알아볼 수 있으며, 이는 좋은 입문서 역할을 합니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:54
msgid ""
"Starknet's architecture is thoroughly described in the [Starknet "
"Book](https://book.starknet.io/chapter_4/index.html), which is a great "
"resource to learn more about the Starknet network."
msgstr ""
"Starknet의 아키텍처는 [Starknet "
"Book](https://book.starknet.io/chapter_4/index.html)에서 상세히 설명되어 있으며, "
"Starknet 네트워크에 대해 더 많이 알아보는 데 좋은 자료입니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:56
msgid ""
"Remember Cairo? It is, in fact, a language developed specifically to work "
"with STARKs and make them general-purpose. With Cairo, we can write "
"**provable code**. In the context of Starknet, this allows proving the "
"correctness of computations from one state to another."
msgstr ""
"카이로를 기억하시나요? 사실, STARKs와 함께 작동하도록 특별히 개발된 언어입니다. 카이로를 사용하면 **증명 가능한 코드**를 "
"작성할 수 있습니다. Starknet의 맥락에서 이는 한 상태에서 다른 상태로의 계산의 정확성을 증명할 수 있게 합니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:58
msgid ""
"Unlike most (if not all) of Starknet's competitors that chose to use the EVM"
" (either as-is or adapted) as a base layer, Starknet employs its own VM. "
"This frees developers from the constraints of the EVM, opening up a broader "
"range of possibilities. Coupled with decreased transaction costs, the "
"combination of Starknet and Cairo creates an exciting playground for "
"developers. Native account abstraction enables more complex logic for "
"accounts, that we call \"Smart Accounts\", and transaction flows. Emerging "
"use cases include **transparent AI** and machine learning applications. "
"Finally, **blockchain games** can be developed entirely **on-chain**. "
"Starknet has been specifically designed to maximize the capabilities of "
"STARK proofs for optimal scalability."
msgstr ""
"스타크넷의 대부분(아니면 모두) 경쟁사들은 기본 레이어로 EVM(변형되거나 그대로 사용)을 선택했지만, 스타크넷은 자체 VM을 "
"사용합니다. 이는 개발자들을 EVM의 제약에서 해방시켜 더 넓은 가능성을 열어줍니다. 거래 비용이 감소하면서, 스타크넷과 카이로의 조합은"
" 개발자들을 위한 흥미로운 놀이터를 만들어냅니다. 네이티브 계정 추상화는 \"스마트 계정\"이라고 부르는 계정 및 거래 흐름에 대한 더 "
"복잡한 로직을 가능하게 합니다. **투명한 AI** 및 머신 러닝 애플리케이션을 포함한 새로운 사용 사례가 등장하고 있습니다. "
"마지막으로, **블록체인 게임**은 완전히 **체인 상에서** 개발될 수 있습니다. 스타크넷은 최적의 확장성을 위해 STARK 증명의 "
"능력을 극대화하기 위해 특별히 설계되었습니다."

#: src/ch99-01-01-introduction-to-smart-contracts.md:60
msgid ""
"Learn more about Account Abstraction in the [Starknet "
"Book](https://book.starknet.io/chapter_5/index.html)."
msgstr ""
"[Starknet Book](https://book.starknet.io/chapter_5/index.html)에서 Account "
"Abstraction에 대해 더 알아보세요."

#: src/ch99-01-01-introduction-to-smart-contracts.md:62
msgid "Cairo programs and Starknet contracts: what is the difference?"
msgstr "카이로 프로그램과 스타크넷 계약: 차이점은 무엇인가요?"

#: src/ch99-01-01-introduction-to-smart-contracts.md:64
msgid ""
"Starknet contracts are a special superset of Cairo programs, so the concepts"
" previously learned in this book are still applicable to write Starknet "
"contracts. As you may have already noticed, a Cairo program must always have"
" a function `main` that serves as the entry point for this program:"
msgstr ""
"스타크넷 계약은 카이로 프로그램의 특별한 슈퍼셋이므로, 이 책에서 이전에 배운 개념들은 여전히 스타크넷 계약을 작성하는 데 적용됩니다. "
"이미 알고 계실 것처럼, 카이로 프로그램은 항상 이 프로그램의 진입점으로 작용하는 `main` 함수를 가져야 합니다:"

#: src/ch99-01-01-introduction-to-smart-contracts.md:71
msgid ""
"Starknet contracts are essentially programs that can run on the Starknet OS,"
" and as such, have access to Starknet's state. For a module to be handled as"
" a contract by the compiler, it must be annotated with the "
"`#[starknet::contract]` attribute."
msgstr ""
"스타크넷 계약은 본질적으로 Starknet OS에서 실행할 수 있는 프로그램이며, 따라서 Starknet의 상태에 액세스할 수 있습니다."
" 컴파일러에서 모듈을 계약으로 처리하려면 `#[starknet::contract]` 속성으로 주석 처리해야 합니다."

#: src/ch99-01-02-a-simple-contract.md:3
msgid ""
"This chapter will introduce you to the basics of Starknet contracts with an "
"example of a basic contract. You will learn how to write a simple contract "
"that stores a single number on the blockchain."
msgstr ""
"이 장에서는 기본적인 Starknet 계약의 기초를 예를 통해 소개합니다. 블록체인에 단일 숫자를 저장하는 간단한 계약을 작성하는 방법을"
" 배우게 될 것입니다."

#: src/ch99-01-02-a-simple-contract.md:5
msgid "Anatomy of a simple Starknet Contract"
msgstr "간단한 Starknet 계약의 해부학"

#: src/ch99-01-02-a-simple-contract.md:7
msgid ""
"Let's consider the following contract to present the basics of a Starknet "
"contract. It might not be easy to understand it all at once, but we will go "
"through it step by step:"
msgstr ""
"다음 계약을 고려하여 Starknet 계약의 기본을 소개해 보겠습니다. 한 번에 모두 이해하기 쉽지 않을 수 있지만, 단계별로 "
"진행하겠습니다."

#: src/ch99-01-02-a-simple-contract.md:38
msgid "Listing 99-1: A simple storage contract"
msgstr "리스팅 99-1: 간단한 저장 계약"

#: src/ch99-01-02-a-simple-contract.md:40
msgid ""
"Note: Starknet contracts are defined within [modules](./ch07-02-defining-"
"modules-to-control-scope.md)."
msgstr ""
"참고: Starknet 계약은 [모듈](./ch07-02-defining-modules-to-control-scope.md) 내에서 "
"정의됩니다."

#: src/ch99-01-02-a-simple-contract.md:42
msgid "What is this contract?"
msgstr "이 계약서는 무엇인가요?"

#: src/ch99-01-02-a-simple-contract.md:44
msgid ""
"In this example, the `Storage` struct declares a storage variable called "
"`stored_data` of type `u128` (unsigned integer of 128 bits). You can think "
"of it as a single slot in a database that you can query and alter by calling"
" functions of the code that manages the database. The contract defines and "
"exposes publicly the functions `set` and `get` that can be used to modify or"
" retrieve the value of that variable."
msgstr ""
"이 예시에서 `Storage` 구조체는 `u128` 타입(128비트의 부호 없는 정수)인 `stored_data`라는 저장 변수를 "
"선언합니다. 이는 데이터베이스의 단일 슬롯으로 생각할 수 있으며, 데이터베이스를 관리하는 코드의 함수를 호출하여 쿼리하고 변경할 수 "
"있습니다. 계약은 `set` 및 `get` 함수를 정의하고 공개적으로 노출하여 이 변수의 값을 수정하거나 검색하는 데 사용할 수 "
"있습니다."

#: src/ch99-01-02-a-simple-contract.md:48
msgid "The Interface: the contract's blueprint"
msgstr "인터페이스: 계약의 청사진"

#: src/ch99-01-02-a-simple-contract.md:58
msgid ""
"The interface of a contract represents the functions this contract exposes "
"to the outside world. Here, the interface exposes two functions: `set` and "
"`get`. By leveraging the [traits & impls](./ch08-02-traits-in-cairo.md) "
"mechanism from Cairo, we can make sure that the actual implementation of the"
" contract matches its interface. In fact, you will get a compilation error "
"if your contract doesn’t conform with the declared interface."
msgstr ""
"계약의 인터페이스는 해당 계약이 외부 세계에 노출하는 기능을 나타냅니다. 여기서 인터페이스는 `set`과 `get` 두 가지 함수를 "
"노출합니다. 카이로에서 [트레이트 및 임플](./ch08-02-traits-in-cairo.md) 메커니즘을 활용하여 계약의 실제 구현이"
" 인터페이스와 일치하는지 확인할 수 있습니다. 실제로 선언된 인터페이스와 일치하지 않는 계약은 컴파일 오류가 발생합니다."

#: src/ch99-01-02-a-simple-contract.md:70
msgid ""
"Listing 99-2: A wrong implementation of the interface of the contract. This "
"does not compile."
msgstr "리스팅 99-2: 계약의 인터페이스를 잘못 구현한 것입니다. 이는 컴파일되지 않습니다."

#: src/ch99-01-02-a-simple-contract.md:72
msgid ""
"In the interface, note the generic type `TContractState` of the `self` "
"argument which is passed by reference to the `set` function. The `self` "
"parameter represents the contract state. Seeing the `self` argument passed "
"to `set` tells us that this function might access the state of the contract,"
" as it is what gives us access to the contract’s storage. The `ref` modifier"
" implies that `self` may be modified, meaning that the storage variables of "
"the contract may be modified inside the `set` function."
msgstr ""
"인터페이스에서 'set' 함수에 참조로 전달되는 'self' 인수의 일반 형식 'TContractState'을 주목하세요. 'self' "
"매개변수는 계약 상태를 나타냅니다. 'set'에 전달된 'self' 인수를 보면, 이 함수가 계약의 상태에 액세스할 수 있을 수도 있다는"
" 것을 알 수 있습니다. 'ref' 수정자는 'self'가 수정될 수 있다는 것을 의미하며, 이는 'set' 함수 내에서 계약의 저장소 "
"변수가 수정될 수 있다는 것을 의미합니다."

#: src/ch99-01-02-a-simple-contract.md:74
msgid ""
"On the other hand, `get` takes a _snapshot_ of `TContractState`, which "
"immediately tells us that it does not modify the state (and indeed, the "
"compiler will complain if we try to modify storage inside the `get` "
"function)."
msgstr ""
"한편, `get`은 `TContractState`의 _스냅샷_ 을 취하는데, 이로써 상태를 수정하지 않음을 즉시 알 수 있습니다 "
"(`get` 함수 내에서 저장소를 수정하려고 하면 컴파일러가 오류를 발생시킵니다)."

#: src/ch99-01-02-a-simple-contract.md:76
msgid "Public functions are defined in an implementation block"
msgstr "공개 함수는 구현 블록에서 정의됩니다."

#: src/ch99-01-02-a-simple-contract.md:78
msgid "Before we explore things further down, let's define some terminology."
msgstr "더 깊이 탐구하기 전에, 우리는 몇 가지 용어를 정의해 봅시다."

#: src/ch99-01-02-a-simple-contract.md:80
msgid ""
"In the context of Starknet, a _public function_ is a function that is "
"exposed to the outside world. In the example above, `set` and `get` are "
"public functions. A public function can be called by anyone, and can be "
"called from outside the contract, or from within the contract. In the "
"example above, `set` and `get` are public functions."
msgstr ""
"Starknet의 맥락에서 _public function_ 은 외부 세계에 노출된 함수입니다. 위의 예에서 `set`과 `get`은 "
"public functions입니다. public function은 누구나 호출할 수 있으며, 계약 외부 또는 내부에서 호출할 수 "
"있습니다. 위의 예에서 `set`과 `get`은 public functions입니다."

#: src/ch99-01-02-a-simple-contract.md:82
msgid ""
"What we call an _external_ function is a public function that is invoked "
"through a transaction and that can mutate the state of the contract. `set` "
"is an external function."
msgstr ""
"우리가 _외부_ 함수라고 부르는 것은 트랜잭션을 통해 호출되며 계약의 상태를 변경할 수 있는 공개 함수입니다. `set`은 외부 "
"함수입니다."

#: src/ch99-01-02-a-simple-contract.md:84
msgid ""
"A _view_ function is a public function that can be called from outside the "
"contract, but that cannot mutate the state of the contract. `get` is a view "
"function."
msgstr ""
"`view` 함수는 계약 외부에서 호출할 수 있는 공개 함수이지만 계약의 상태를 변경할 수는 없습니다. `get`은 view 함수입니다."

#: src/ch99-01-02-a-simple-contract.md:98
msgid ""
"Since the contract interface is defined as the `ISimpleStorage` trait, in "
"order to match the interface, the external functions of the contract must be"
" defined in an implementation of this trait — which allows us to make sure "
"that the implementation of the contract matches its interface."
msgstr ""
"계약 인터페이스가 `ISimpleStorage` 트레이트로 정의되었기 때문에 인터페이스와 일치하도록 계약의 외부 함수들은 이 트레이트의 "
"구현에서 정의되어야 합니다. 이를 통해 계약의 구현이 인터페이스와 일치하는지 확인할 수 있습니다."

#: src/ch99-01-02-a-simple-contract.md:101
msgid ""
"However, simply defining the functions in the implementation is not enough. "
"The implementation block must be annotated with the `#[abi(embed_v0)]` "
"attribute. This attribute exposes the functions defined in this "
"implementation to the outside world — forget to add it and your functions "
"will not be callable from the outside. All functions defined in a block "
"marked as `#[abi(embed_v0)]` are consequently _public functions_."
msgstr ""
"그러나 구현에서 함수를 정의하는 것만으로는 충분하지 않습니다. 구현 블록은 `#[abi(embed_v0)]` 속성으로 주석 처리되어야 "
"합니다. 이 속성은 이 구현에서 정의된 함수를 외부 세계에 노출시킵니다. 이 속성을 추가하지 않으면 함수가 외부에서 호출될 수 없습니다."
" `#[abi(embed_v0)]`로 표시된 블록에 정의된 모든 함수는 결과적으로 _공개 함수 _입니다."

#: src/ch99-01-02-a-simple-contract.md:103
msgid ""
"When writing the implementation of the interface, the generic parameter "
"corresponding to the `self` argument in the trait must be `ContractState`. "
"The `ContractState` type is generated by the compiler, and gives access to "
"the storage variables defined in the `Storage` struct. Additionally, "
"`ContractState` gives us the ability to emit events. The name "
"`ContractState` is not surprising, as it’s a representation of the "
"contract’s state, which is what we think of `self` in the contract interface"
" trait."
msgstr ""
"인터페이스의 구현을 작성할 때, 트레이트에서 `self` 인자에 해당하는 일반 매개변수는 `ContractState`여야 합니다. "
"`ContractState` 유형은 컴파일러에 의해 생성되며, `Storage` 구조체에서 정의된 저장 변수에 액세스할 수 있습니다. "
"또한, `ContractState`는 이벤트를 발생시키는 능력을 제공합니다. `ContractState`라는 이름은 계약의 상태를 "
"나타내는 것으로, 계약 인터페이스 트레이트에서 `self`로 생각하는 것과 일치합니다."

#: src/ch99-01-02-a-simple-contract.md:106
msgid "Modifying the contract's state"
msgstr "계약 상태 수정"

#: src/ch99-01-02-a-simple-contract.md:108
msgid ""
"As you can notice, all functions that need to access the state of the "
"contract are defined under the implementation of a trait that has a "
"`TContractState` generic parameter, and take a `self: ContractState` "
"parameter. This allows us to explicitly pass the `self: ContractState` "
"parameter to the function, allowing access the storage variables of the "
"contract. To access a storage variable of the current contract, you add the "
"`self` prefix to the storage variable name, which allows you to use the "
"`read` and `write` methods to either read or write the value of the storage "
"variable."
msgstr ""
"당신이 알 수 있듯이, 계약 상태에 액세스해야 하는 모든 함수들은 `TContractState` 제네릭 매개변수를 가진 특성의 구현 "
"아래에서 정의되며, `self: ContractState` 매개변수를 취합니다. 이를 통해 우리는 명시적으로 `self: "
"ContractState` 매개변수를 함수에 전달하여 계약의 저장 변수에 액세스할 수 있습니다. 현재 계약의 저장 변수에 액세스하려면, "
"저장 변수 이름에 `self` 접두사를 추가하여 해당 저장 변수의 값을 읽거나 쓸 수 있는 `read` 및 `write` 메서드를 사용할"
" 수 있습니다."

#: src/ch99-01-02-a-simple-contract.md:118
msgid ""
"Using `self` and the `write` method to modify the value of a storage "
"variable"
msgstr "`self`와 `write` 메소드를 사용하여 저장 변수의 값을 수정합니다."

#: src/ch99-01-02-a-simple-contract.md:120
msgid ""
"Note: if the contract state is passed as a snapshot instead of `ref`, "
"attempting to modify will result in a compilation error."
msgstr "참고: 계약 상태가 `ref` 대신 스냅샷으로 전달된 경우 수정을 시도하면 컴파일 오류가 발생합니다."

#: src/ch99-01-02-a-simple-contract.md:122
msgid ""
"This contract does not do much yet apart from allowing anyone to store a "
"single number that is accessible by anyone in the world. Anyone could call "
"`set` again with a different value and overwrite your number, but the number"
" is still stored in the history of the blockchain. Later, you will see how "
"you can impose access restrictions so that only you can alter the number."
msgstr ""
"이 계약은 아직 많은 일을 하지는 않지만 누구나 전 세계에서 접근할 수 있는 단일 숫자를 저장할 수 있도록 허용합니다. 누구나 다른 "
"값으로 'set'을 호출하여 숫자를 덮어쓸 수 있지만, 숫자는 여전히 블록체인의 기록에 저장됩니다. 나중에 액세스 제한을 부과하여 "
"당신만이 숫자를 변경할 수 있도록 할 수 있는 방법을 보게 될 것입니다."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:3
msgid ""
"In the previous section, we gave an introductory example of a smart contract"
" written in Cairo. In this section, we'll be taking a deeper look at all the"
" components of a smart contract, step by step."
msgstr ""
"이전 섹션에서는 카이로로 작성된 스마트 계약의 입문 예제를 제시했습니다. 이번 섹션에서는 스마트 계약의 모든 구성 요소를 단계별로 자세히"
" 살펴볼 것입니다."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:5
msgid ""
"When we discussed [_interfaces_](./ch99-01-02-a-simple-contract.md), we "
"specified the difference between _public functions, external functions and "
"view functions_, and we mentioned how to interact with _storage_."
msgstr ""
"[ _인터페이스_ ](./ch99-01-02-a-simple-contract.md)를 논의할 때, _public 함수, external 함수"
" 및 view 함수_ 간의 차이를 명시했으며 _storage_ 와 상호 작용하는 방법에 대해 언급했습니다."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:7
msgid "At this point, you should have multiple questions that come to mind:"
msgstr "이 시점에서 당신은 머릿속에 여러 질문들이 생기게 될 것입니다:"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:9
msgid "How do I define internal/private functions?"
msgstr "내부/비공개 함수를 어떻게 정의하나요?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:10
msgid "How can I emit events? How can I index them?"
msgstr "이벤트를 어떻게 발생시킬 수 있을까요? 어떻게 색인화할 수 있을까요?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:11
msgid ""
"Where should I define functions that do not need to access the contract's "
"state?"
msgstr "계약 상태에 액세스할 필요가 없는 함수를 정의해야 하는 곳은 어디인가요?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:12
msgid "Is there a way to reduce the boilerplate?"
msgstr "보일러플레이트를 줄일 수 있는 방법이 있나요?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:13
msgid "How can I store more complex data types?"
msgstr "더 복잡한 데이터 유형을 어떻게 저장할 수 있을까요?"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:15
msgid ""
"Luckily, we'll be answering all these questions in this chapter. Let's "
"consider the following example contract that we'll be using throughout this "
"chapter:"
msgstr "다행히도, 이 장에서는 모든 이러한 질문에 대답할 것입니다. 이 장 전체에서 사용할 예시 계약을 고려해 봅시다."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:93
#: src/ch99-01-03-01-contract-storage.md:83
#: src/ch99-01-03-01-contract-storage.md:208
#: src/ch99-01-03-01-contract-storage.md:322
#: src/ch99-01-03-01-contract-storage.md:434
#: src/ch99-01-03-01-contract-storage.md:546
#: src/ch99-01-03-01-contract-storage.md:656
#: src/ch99-01-03-01-contract-storage.md:774
#: src/ch99-01-03-01-contract-storage.md:884
#: src/ch99-01-03-02-contract-functions.md:82
#: src/ch99-01-03-04-reducing-boilerplate.md:7
msgid "// Could be a group of functions about a same topic\n"
msgstr "동일한 주제에 대한 함수 그룹일 수 있습니다."

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:111
#: src/ch99-01-03-01-contract-storage.md:101
#: src/ch99-01-03-01-contract-storage.md:226
#: src/ch99-01-03-01-contract-storage.md:340
#: src/ch99-01-03-01-contract-storage.md:452
#: src/ch99-01-03-01-contract-storage.md:564
#: src/ch99-01-03-01-contract-storage.md:674
#: src/ch99-01-03-01-contract-storage.md:792
#: src/ch99-01-03-01-contract-storage.md:902
#: src/ch99-01-03-02-contract-functions.md:100
msgid "// Free functions\n"
msgstr "// 무료 함수"

#: src/ch99-01-03-00-a-deeper-dive-into-contracts.md:123
msgid "Listing 99-3: Our reference contract for this chapter"
msgstr "리스팅 99-3: 이 장의 참조 계약"

#: src/ch99-01-03-01-contract-storage.md:3
msgid ""
"The most common way for interacting with a contract’s storage is through "
"storage variables. As stated previously, storage variables allow you to "
"store data that will be stored in the contract's storage that is itself "
"stored on the blockchain. These data are persistent and can be accessed and "
"modified anytime once the contract is deployed."
msgstr ""
"계약의 저장소와 상호 작용하는 가장 일반적인 방법은 저장소 변수를 통해 이루어집니다. 이전에 언급했듯이, 저장소 변수를 사용하면 "
"블록체인에 저장된 계약의 저장소에 저장될 데이터를 저장할 수 있습니다. 이러한 데이터는 영구적이며, 계약이 배포된 후 언제든지 액세스하고"
" 수정할 수 있습니다."

#: src/ch99-01-03-01-contract-storage.md:5
msgid ""
"Storage variables in Starknet contracts are stored in a special struct "
"called `Storage`:"
msgstr "Starknet 계약의 저장 변수는 `Storage`라는 특별한 구조체에 저장됩니다."

#: src/ch99-01-03-01-contract-storage.md:115
msgid "A Storage Struct"
msgstr "저장 구조체"

#: src/ch99-01-03-01-contract-storage.md:117
msgid ""
"The storage struct is a [struct](./ch05-00-using-structs-to-structure-"
"related-data.md) like any other, except that it **must** be annotated with "
"`#[storage]`. This annotation tells the compiler to generate the required "
"code to interact with the blockchain state, and allows you to read and write"
" data from and to storage. Moreover, this allows you to define storage "
"mappings using the `LegacyMap` type."
msgstr ""
"저장소 구조체는 다른 구조체와 마찬가지로 [struct](./ch05-00-using-structs-to-structure-"
"related-data.md)이지만, `#[storage]`로 주석이 달려 있어야만 합니다. 이 주석은 컴파일러에게 블록체인 상태와 상호"
" 작용하는 데 필요한 코드를 생성하도록 지시하고, 저장소에서 데이터를 읽고 쓸 수 있도록 합니다. 더불어, 이를 통해 "
"`LegacyMap` 유형을 사용하여 저장소 매핑을 정의할 수 있습니다."

#: src/ch99-01-03-01-contract-storage.md:120
msgid ""
"Each variable stored in the storage struct is stored in a different location"
" in the contract's storage. The storage address of a variable is determined "
"by the variable's name, and the eventual keys of the variable if it is a "
"[mapping](#storing-mappings)."
msgstr ""
"저장 구조체에 저장된 각 변수는 계약의 저장소 내에서 다른 위치에 저장됩니다. 변수의 저장 주소는 변수의 이름에 의해 결정되며, 변수가 "
"[매핑](#storing-mappings)인 경우 변수의 최종 키에 의해 결정됩니다."

#: src/ch99-01-03-01-contract-storage.md:122
msgid "Storage Addresses"
msgstr "저장 주소"

#: src/ch99-01-03-01-contract-storage.md:124
msgid "The address of a storage variable is computed as follows:"
msgstr "저장 변수의 주소는 다음과 같이 계산됩니다:"

#: src/ch99-01-03-01-contract-storage.md:126
msgid ""
"If the variable is a single value (not a mapping), the address is the "
"`sn_keccak` hash of the ASCII encoding of the variable's name. `sn_keccak` "
"is Starknet's version of the Keccak256 hash function, whose output is "
"truncated to 250 bits."
msgstr ""
"변수가 단일 값(매핑이 아닌 경우)인 경우 주소는 변수 이름의 ASCII 인코딩의 `sn_keccak` 해시입니다. "
"`sn_keccak`은 출력이 250비트로 줄어든 Keccak256 해시 함수의 Starknet 버전입니다."

#: src/ch99-01-03-01-contract-storage.md:127
msgid ""
"If the variable is a [mapping](#storing-mappings), the address of the value "
"at key `k_1,...,k_n` is "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where ℎ is the "
"Pedersen hash and the final value is taken `mod (2^251) − 256`."
msgstr ""
"만약 변수가 [매핑](#storing-mappings)이라면, 키 `k_1,...,k_n`의 값의 주소는 "
"`h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)`이며 여기서 ℎ는 Pedersen "
"해시이고 최종 값은 `mod (2^251) − 256`으로 취합니다."

#: src/ch99-01-03-01-contract-storage.md:128
msgid ""
"If it is a mapping to complex values (e.g., tuples or structs), then this "
"complex value lies in a continuous segment starting from the address "
"calculated in the previous point. Note that 256 field elements is the "
"current limitation on the maximal size of a complex storage value."
msgstr ""
"복소 값에 대한 매핑인 경우(예: 튜플 또는 구조체), 이 복소 값은 이전 지점에서 계산된 주소를 시작으로하는 연속 세그먼트에 있습니다."
" 256개의 필드 요소가 복소 저장 값의 최대 크기 제한입니다."

#: src/ch99-01-03-01-contract-storage.md:130
msgid ""
"You can access the address of a storage variable by calling the `address` "
"function on the variable, which returns a `StorageBaseAddress` value."
msgstr ""
"`address` 함수를 변수에 호출하여 저장 변수의 주소에 액세스할 수 있으며, 이는 `StorageBaseAddress` 값을 "
"반환합니다."

#: src/ch99-01-03-01-contract-storage.md:240
msgid "Interacting with Storage Variables"
msgstr "저장 변수와 상호 작용하기"

#: src/ch99-01-03-01-contract-storage.md:242
msgid ""
"Variables stored in the storage struct can be accessed and modified using "
"the `read` and `write` functions, and you can get their address in storage "
"using the `address` function. These functions are automatically generated by"
" the compiler for each storage variable."
msgstr ""
"저장 구조체에 저장된 변수는 `read` 및 `write` 함수를 사용하여 액세스하고 수정할 수 있으며, `address` 함수를 "
"사용하여 저장소에서 그들의 주소를 얻을 수 있습니다. 이러한 함수들은 컴파일러에 의해 각 저장 변수에 대해 자동으로 생성됩니다."

#: src/ch99-01-03-01-contract-storage.md:244
msgid ""
"To read the value of the `owner` storage variable, which is a single value, "
"we call the `read` function on the `owner` variable, passing in no "
"parameters."
msgstr "`owner` 스토리지 변수의 값을 읽으려면, 이 변수에 대해 `read` 함수를 호출하고 매개변수를 전달하지 않습니다."

#: src/ch99-01-03-01-contract-storage.md:354
msgid "Calling the `read` function on the `owner` variable"
msgstr "`owner` 변수에 `read` 함수를 호출합니다."

#: src/ch99-01-03-01-contract-storage.md:356
msgid ""
"To read the value of the storage variable `names`, which is a mapping from "
"`ContractAddress` to `felt252`, we call the `read` function on the `names` "
"variable, passing in the key `address` as a parameter. If the mapping had "
"more than one key, we would pass in the other keys as parameters as well."
msgstr ""
"`names` 저장 변수의 값을 읽으려면 `ContractAddress`에서 `felt252`로의 매핑이며, `names` 변수에 대해 "
"`read` 함수를 호출하여 키 `address`를 매개변수로 전달합니다. 매핑에 둘 이상의 키가 있다면 다른 키도 매개변수로 전달해야 "
"합니다."

#: src/ch99-01-03-01-contract-storage.md:466
msgid "Calling the `read` function on the `names` variable"
msgstr "`names` 변수에서 `read` 함수를 호출합니다."

#: src/ch99-01-03-01-contract-storage.md:468
msgid ""
"To write a value to a storage variable, we call the `write` function passing"
" in the eventual keys the value as arguments. As with the `read` function, "
"the number of arguments depends on the number of keys - here, we only pass "
"in the value to write to the `owner` variable as it is a simple variable."
msgstr ""
"저장 변수에 값을 쓰려면, 값으로 향하는 키를 전달하는 `write` 함수를 호출합니다. `read` 함수와 마찬가지로, 전달하는 인수의"
" 수는 키의 수에 따라 달라집니다. 여기서는 `owner` 변수에 쓸 값만 전달하면 되므로 인수의 수가 하나입니다."

#: src/ch99-01-03-01-contract-storage.md:578
msgid "Calling the `write` function on the `owner` variable"
msgstr "`owner` 변수에 `write` 함수를 호출합니다."

#: src/ch99-01-03-01-contract-storage.md:688
msgid "Calling the `write` function on the `names` variable"
msgstr "`names` 변수에 `write` 함수를 호출합니다."

#: src/ch99-01-03-01-contract-storage.md:690
msgid "Storing custom types"
msgstr "사용자 지정 타입 저장하기"

#: src/ch99-01-03-01-contract-storage.md:692
msgid ""
"The `Store` trait, defined in the `starknet::storage_access` module, is used"
" to specify how a type should be stored in storage. In order for a type to "
"be stored in storage, it must implement the `Store` trait. Most types from "
"the core library, such as unsigned integers (`u8`, `u128`, `u256`...), "
"`felt252`, `bool`, `ContractAddress`, etc. implement the `Store` trait and "
"can thus be stored without further action."
msgstr ""
"`Store` 트레이트는 `starknet::storage_access` 모듈에서 정의되며, 타입이 스토리지에 저장되는 방법을 지정하는 "
"데 사용됩니다. 타입이 스토리지에 저장되기 위해서는 `Store` 트레이트를 구현해야 합니다. 대부분의 코어 라이브러리에서 제공하는 "
"타입들, 예를 들어 부호 없는 정수(`u8`, `u128`, `u256`...), `felt252`, `bool`, "
"`ContractAddress` 등은 `Store` 트레이트를 구현하고 있으므로 추가 조치 없이 저장될 수 있습니다."

#: src/ch99-01-03-01-contract-storage.md:694
msgid ""
"But what if you wanted to store a type that you defined yourself, such as an"
" enum or a struct? In that case, you have to explicitly tell the compiler "
"how to store this type."
msgstr ""
"그러나 사용자가 정의한 enum이나 struct와 같은 유형을 저장하려면 어떻게 해야 할까요? 이 경우, 해당 유형을 어떻게 저장할지 "
"컴파일러에 명시적으로 알려주어야 합니다."

#: src/ch99-01-03-01-contract-storage.md:696
msgid ""
"In our example, we want to store a `Person` struct in storage, which is "
"possible by implementing the `Store` trait for the `Person` type. This can "
"be achieved by simply adding a `#[derive(starknet::Store)]` attribute on top"
" of our struct definition."
msgstr ""
"우리의 예시에서는 `Person` 구조체를 저장하고 싶은데, 이는 `Person` 유형에 대해 `Store` 트레이트를 구현함으로써 "
"가능합니다. 이는 단순히 우리의 구조체 정의 맨 위에 `#[derive(starknet::Store)]` 속성을 추가함으로써 달성할 수 "
"있습니다."

#: src/ch99-01-03-01-contract-storage.md:806
msgid ""
"Similarly, Enums can be written to storage if they implement the `Store` "
"trait, which can be trivially derived as long as all associated types "
"implement the `Store` trait."
msgstr ""
"비슷하게, Enums는 `Store` 트레이트를 구현한다면 저장소에 작성될 수 있으며, 모든 관련된 타입이 `Store` 트레이트를 "
"구현한다면 쉽게 파생될 수 있습니다."

#: src/ch99-01-03-01-contract-storage.md:916
msgid "Structs storage layout"
msgstr "구조체 저장 레이아웃"

#: src/ch99-01-03-01-contract-storage.md:918
msgid ""
"On Starknet, structs are stored in storage as a sequence of primitive types."
" The elements of the struct are stored in the same order as they are defined"
" in the struct definition. The first element of the struct is stored at the "
"base address of the struct, which is computed as specified in [Storage "
"Addresses](#storage-addresses) and can be obtained by calling "
"`var.address()`, and subsequent elements are stored at addresses contiguous "
"to the first element. For example, the storage layout for the `owner` "
"variable of type `Person` will result in the following layout:"
msgstr ""
"Starknet에서는 구조체가 기본 유형의 시퀀스로 저장됩니다. 구조체의 요소는 구조체 정의에서 정의된 순서대로 저장됩니다. 구조체의 첫"
" 번째 요소는 구조체의 기본 주소에 저장되며, 이는 [저장 주소](#storage-addresses)에서 지정된대로 계산되어 "
"`var.address()`를 호출하여 얻을 수 있습니다. 그 후의 요소들은 첫 번째 요소와 연속된 주소에 저장됩니다. 예를 들어, "
"`Person` 유형의 `owner` 변수에 대한 저장 레이아웃은 다음과 같습니다:"

#: src/ch99-01-03-01-contract-storage.md:922
msgid "Fields"
msgstr "분야"

#: src/ch99-01-03-01-contract-storage.md:922
#: src/ch99-01-03-01-contract-storage.md:933
msgid "Address"
msgstr "주소"

#: src/ch99-01-03-01-contract-storage.md:924
msgid "name"
msgstr "이름"

#: src/ch99-01-03-01-contract-storage.md:924
msgid "owner.address()"
msgstr "owner.address()"

#: src/ch99-01-03-01-contract-storage.md:925
msgid "address"
msgstr "주소"

#: src/ch99-01-03-01-contract-storage.md:925
msgid "owner.address() +1"
msgstr "주인.주소() +1"

#: src/ch99-01-03-01-contract-storage.md:927
msgid "Enums storage layout"
msgstr "열거형 저장 레이아웃"

#: src/ch99-01-03-01-contract-storage.md:929
msgid ""
"When you store an enum variant, what you're essentially storing is the "
"variant's index and an eventual associated values. This index starts at 0 "
"for the first variant of your enum and increments by 1 for each subsequent "
"variant. If your variant has an associated value, it's stored starting from "
"the address immediately following the base address. For example, suppose we "
"have the `RegistrationType` enum with the `finite` variant, which carries an"
" associated limit date. The storage layout would look like this:"
msgstr ""
"enum 변수를 저장할 때, 본질적으로 저장하는 것은 변수의 인덱스와 연관된 값입니다. 이 인덱스는 enum의 첫 번째 변수에 대해 "
"0부터 시작하여 각 후속 변수마다 1씩 증가합니다. 변수에 연관된 값이 있는 경우, 기본 주소 다음 주소부터 저장됩니다. 예를 들어, "
"`RegistrationType` enum에 `finite` 변수가 있는 경우, 연관된 유효 날짜를 가지고 있습니다. 저장 레이아웃은 "
"다음과 같이 보일 것입니다:"

#: src/ch99-01-03-01-contract-storage.md:933
msgid "Element"
msgstr "원소"

#: src/ch99-01-03-01-contract-storage.md:935
msgid "Variant index (e.g. 1 for finite)"
msgstr "변형 지수 (예: 유한한 경우 1)"

#: src/ch99-01-03-01-contract-storage.md:935
msgid "registration_type.address()"
msgstr "registration_type.address()"

#: src/ch99-01-03-01-contract-storage.md:936
msgid "Associated limit date"
msgstr "연관한 제한 일자"

#: src/ch99-01-03-01-contract-storage.md:936
msgid "registration_type.address() + 1"
msgstr ""
"registration_type.address() + 1\n"
"\n"
"등록 유형.주소() + 1"

#: src/ch99-01-03-01-contract-storage.md:938
msgid "Storage mappings"
msgstr "저장소 매핑"

#: src/ch99-01-03-01-contract-storage.md:940
msgid ""
"Storage mappings are similar to hash tables in that they allow mapping keys "
"to values. However, unlike a typical hash table, the key data itself is not "
"stored - only its hash is used to look up the associated value in the "
"contract's storage. Mappings do not have a concept of length or whether a "
"key/value pair is set. The only way to remove a mapping is to set its value "
"to the default zero value."
msgstr ""
"저장 매핑은 키를 값에 매핑하는 해시 테이블과 유사합니다. 그러나 일반 해시 테이블과 달리 키 데이터 자체가 저장되지 않습니다. 연관된 "
"값은 계약의 저장소에서 찾을 때 해시만 사용됩니다. 매핑에는 길이 개념이나 키/값 쌍이 설정되었는지 여부가 없습니다. 매핑을 제거하는 "
"유일한 방법은 해당 값을 기본 제로 값으로 설정하는 것입니다."

#: src/ch99-01-03-01-contract-storage.md:943
msgid ""
"Mappings are only used to compute the location of data in the storage of a "
"contract given certain keys. They are thus **only allowed as storage "
"variables**. They cannot be used as parameters or return parameters of "
"contract functions, and cannot be used as types inside structs."
msgstr ""
"매핑은 특정 키가 주어졌을 때 계약의 저장소 내 데이터 위치를 계산하는 데에만 사용됩니다. 따라서 매핑은 **저장 변수로만 "
"허용**됩니다. 매핑은 계약 함수의 매개변수나 반환 매개변수로 사용할 수 없으며, 구조체 내부의 유형으로 사용할 수도 없습니다."

#: src/ch99-01-03-01-contract-storage.md:955
msgid ""
"To declare a mapping, use the `LegacyMap` type enclosed in angle brackets "
"`<>`, specifying the key and value types."
msgstr "매핑을 선언하려면 각괄호 `<>`로 둘러싸인 `LegacyMap` 유형을 사용하고 키와 값 유형을 지정하십시오."

#: src/ch99-01-03-01-contract-storage.md:958
msgid ""
"You can also create more complex mappings with multiple keys. You can find "
"one in Listing 99-4 like the popular `allowances` storage variable in the "
"ERC20 Standard which maps an `owner` and an allowed `spender` to its "
"`allowance` amount using multiple keys passed inside a tuple:"
msgstr ""
"여러 개의 키를 사용하여 더 복잡한 매핑을 생성할 수도 있습니다. "
"99-4 목록에서 인기 있는 `allowances` 저장 변수와 같은 매핑을 찾을 수 있습니다. "
"ERC20 표준에서는 `owner`와 허용된 `spender`를 `allowance` 금액에 매핑하는 데 튜플 내에 전달된 여러 개의 키를 사용합니다."

#: src/ch99-01-03-01-contract-storage.md:967
msgid "Listing 99-4: Storing mappings"
msgstr "리스트 99-4: 매핑 저장하기"

#: src/ch99-01-03-01-contract-storage.md:969
msgid ""
"The address in storage of a variable stored in a mapping is computed "
"according to the description in the [Storage Addresses](#storage-addresses) "
"section. If the key of a mapping is a struct, each element of the struct "
"constitutes a key. Moreover, the struct should implement the `Hash` trait, "
"which can be derived with the `#[derive(Hash)]` attribute. For example, if "
"you have struct with two fields, the address will be "
"`h(h(sn_keccak(variable_name),k_1),k_2)` - where `k_1` and `k_2` are the "
"values of the two fields of the struct."
msgstr ""
"매핑에 저장된 변수의 저장 주소는 [Storage Addresses](#storage-addresses) 섹션에 설명된대로 계산됩니다. "
"매핑의 키가 구조체인 경우, 구조체의 각 요소가 키를 구성합니다. 또한, 구조체는 `Hash` 트레이트를 구현해야 하며, "
"`#[derive(Hash)]` 속성을 사용하여 파생될 수 있습니다. 예를 들어, 두 개의 필드가 있는 구조체가 있다면, 주소는 "
"`h(h(sn_keccak(variable_name),k_1),k_2)`가 됩니다 - 여기서 `k_1`과 `k_2`는 구조체의 두 필드의"
" 값입니다."

#: src/ch99-01-03-01-contract-storage.md:972
msgid ""
"Similarly, in the case of a nested mapping such as "
"`LegacyMap((ContractAddress, ContractAddress), u8)`, the address will be "
"computed in the same way: `h(h(sn_keccak(variable_name),k_1),k_2)`."
msgstr ""
"비슷하게, `LegacyMap((ContractAddress, ContractAddress), u8)`와 같이 중첩된 매핑의 경우에도 "
"주소는 동일한 방식으로 계산될 것입니다: `h(h(sn_keccak(variable_name),k_1),k_2)`."

#: src/ch99-01-03-01-contract-storage.md:974
msgid ""
"For more details about the contract storage layout in the [Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)"
msgstr ""
"더 많은 세부 정보는 [Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)의 계약 저장 레이아웃을 참조하세요."

#: src/ch99-01-03-02-contract-functions.md:3
msgid ""
"In this section, we are going to be looking at the different types of "
"functions you could encounter in contracts:"
msgstr "이 섹션에서는 계약서에서 만날 수 있는 다양한 유형의 기능을 살펴볼 것입니다."

#: src/ch99-01-03-02-contract-functions.md:5
msgid "1. Constructors"
msgstr "1. 생성자"

#: src/ch99-01-03-02-contract-functions.md:7
msgid ""
"Constructors are a special type of function that only runs once when "
"deploying a contract, and can be used to initialize the state of a contract."
msgstr "생성자는 계약을 배포할 때 한 번만 실행되는 특별한 유형의 함수로, 계약의 상태를 초기화하는 데 사용할 수 있습니다."

#: src/ch99-01-03-02-contract-functions.md:18
msgid "Some important rules to note:"
msgstr "주의할 중요한 규칙 몇 가지:"

#: src/ch99-01-03-02-contract-functions.md:20
msgid "Your contract can't have more than one constructor."
msgstr "귀하의 계약에는 둘 이상의 생성자가 있을 수 없습니다."

#: src/ch99-01-03-02-contract-functions.md:21
msgid "Your constructor function must be named `constructor`."
msgstr "생성자 함수는 `constructor`로 명명되어야 합니다."

#: src/ch99-01-03-02-contract-functions.md:22
msgid "It must be annotated with the `#[constructor]` attribute."
msgstr "`#[constructor]` 속성으로 주석이 달려 있어야 합니다."

#: src/ch99-01-03-02-contract-functions.md:24
msgid "2. Public functions"
msgstr "2. 공공 기능"

#: src/ch99-01-03-02-contract-functions.md:26
msgid ""
"As stated previously, public functions are accessible from outside of the "
"contract. They must be defined inside an implementation block annotated with"
" the `#[abi(embed_v0)]` attribute. This attribute means that all functions "
"embedded inside it are implementations of the Starknet interface, and "
"therefore entry points of the contract. It only affects the visibility "
"(public vs private/internal), but it doesn't inform us on the ability of "
"these functions to modify the state of the contract."
msgstr ""
"이전에 언급한 대로, 공개 함수는 계약 외부에서 접근할 수 있습니다. 이 함수들은 `#[abi(embed_v0)]` 속성이 지정된 구현 "
"블록 내에 정의되어야 합니다. 이 속성은 그 안에 포함된 모든 함수가 Starknet 인터페이스의 구현이며, 따라서 계약의 "
"진입점(entry points)임을 의미합니다. 이 속성은 가시성(public vs private/internal)에만 영향을 미치지만,"
" 이러한 함수들이 계약의 상태를 수정할 수 있는 능력에 대해서는 알려주지 않습니다."

#: src/ch99-01-03-02-contract-functions.md:47
msgid "External functions"
msgstr "외부 함수"

#: src/ch99-01-03-02-contract-functions.md:49
msgid ""
"External functions are functions that can modify the state of a contract. "
"They are public and can be called by any other contract or externally. "
"External functions are _public_ functions where the `self: ContractState` is"
" passed as reference with the `ref` keyword, allowing you to modify the "
"state of the contract."
msgstr ""
"외부 함수는 계약의 상태를 수정할 수 있는 함수입니다. 이러한 함수들은 공개되어 있으며 다른 모든 계약 또는 외부에서 호출될 수 "
"있습니다. 외부 함수는 `self: ContractState`이 참조로 전달되는 `_public_` 함수들이며 `ref` 키워드를 "
"사용하여 계약의 상태를 수정할 수 있습니다."

#: src/ch99-01-03-02-contract-functions.md:59
msgid "View functions"
msgstr "기능 보기"

#: src/ch99-01-03-02-contract-functions.md:61
msgid ""
"View functions are read-only functions allowing you to access data from the "
"contract while ensuring that the state of the contract is not modified. They"
" can be called by other contracts or externally. View functions are _public_"
" functions where the `self: ContractState` is passed as snapshot, preventing"
" you from modifying the state of the contract."
msgstr ""
"뷰 함수는 계약에서 데이터에 액세스할 수 있도록 허용하면서도 계약의 상태가 수정되지 않도록 하는 읽기 전용 함수입니다. 다른 계약이나 "
"외부에서 호출할 수 있습니다. 뷰 함수는 `self: ContractState`가 스냅샷으로 전달되는 _public_ 함수이며, 계약의 "
"상태를 수정할 수 없게 합니다."

#: src/ch99-01-03-02-contract-functions.md:71
msgid ""
"**Note:** It's important to note that both external and view functions are "
"public. To create an internal function in a contract, you will need to "
"define it outside of the implementation block annotated with the "
"`#[abi(embed_v0)]` attribute."
msgstr ""
"**참고:** 외부 및 뷰 함수는 모두 공개(public)임을 유의해야 합니다. 계약(contract) 내에서 내부 함수를 생성하려면 "
"`#[abi(embed_v0)]` 속성으로 주석 처리된 구현 블록 외부에서 정의해야 합니다."

#: src/ch99-01-03-02-contract-functions.md:73
msgid "3. Private functions"
msgstr "3. 비공개 함수"

#: src/ch99-01-03-02-contract-functions.md:75
msgid ""
"Functions that are not defined in a block annotated with the "
"`#[abi(embed_v0)]` attribute are private functions (also called internal "
"functions). They can only be called from within the contract."
msgstr ""
"`#[abi(embed_v0)]` 속성이 지정된 블록에 정의되지 않은 함수는 비공개 함수(내부 함수라고도 함)입니다. 이러한 함수들은 "
"계약 내에서만 호출할 수 있습니다."

#: src/ch99-01-03-02-contract-functions.md:77
msgid ""
"They can be grouped in a dedicated impl block (e.g in components, to easily "
"import internal functions all at once in the embedding contracts) or just be"
" added as free functions inside the contract module. Note that these 2 "
"methods are equivalent. Just choose the one that makes your code more "
"readable and easy to use."
msgstr ""
"그들은 전용 impl 블록에 그룹화될 수 있습니다(예: 구성 요소에서, 내부 함수를 쉽게 한꺼번에 임베딩 계약에 가져오기 위해) 또는 "
"계약 모듈 내에 자유 함수로 추가될 수 있습니다. 이 두 가지 방법은 동등합니다. 코드를 더 읽기 쉽고 사용하기 쉽게 만드는 방법을 "
"선택하십시오."

#: src/ch99-01-03-02-contract-functions.md:111
msgid ""
"Wait, what is this `#[generate_trait]` attribute? Where is the trait "
"definition for this implementation? Well, the `#[generate_trait]` attribute "
"is a special attribute that tells the compiler to generate a trait "
"definition for the implementation block. This allows you to get rid of the "
"boilerplate code of defining a trait and implementing it for the "
"implementation block. We will see more about this in the [next "
"section](./ch99-01-03-04-reducing-boilerplate.md)."
msgstr ""
"이 `#[generate_trait]` 속성은 무엇인가요? 이 구현을 위한 트레이트 정의는 어디에 있나요? "
"`#[generate_trait]` 속성은 컴파일러에게 구현 블록을 위한 트레이트 정의를 생성하도록 지시하는 특별한 속성입니다. 이를 "
"통해 트레이트를 정의하고 구현하는 보일러플레이트 코드를 제거할 수 있습니다. 이에 대해 더 자세히 알아보려면 [다음 "
"섹션](./ch99-01-03-04-reducing-boilerplate.md)에서 확인해보겠습니다."

#: src/ch99-01-03-02-contract-functions.md:113
msgid "4. \\[abi(per_item)\\] attribute"
msgstr "4. \\[abi(개별 항목)\\] 속성"

#: src/ch99-01-03-02-contract-functions.md:115
msgid ""
"You can also define the entrypoint type of a function individually inside an"
" impl using the`#[abi(per_item)]` attribute on top of your impl. It is often"
" used with the `#[generate_trait]` attribute, as it allows you to define "
"entrypoints without an explicit interface. In this case, the functions will "
"not be grouped under an impl in the abi. Note that when using "
"`#[abi(per_item)]` attribute, public functions need to be annotated with "
"`#[external(v0)]` attribute - otherwise, they will not be exposed."
msgstr ""
"함수의 엔트리포인트 유형을 개별적으로 정의할 수도 있습니다. impl 내에서 `#[abi(per_item)]` 속성을 사용하여 정의할 수"
" 있습니다. 이는 명시적 인터페이스 없이 엔트리포인트를 정의할 수 있도록 `#[generate_trait]` 속성과 함께 자주 "
"사용됩니다. 이 경우, 함수들은 abi 내에서 impl 아래에 그룹화되지 않습니다. `#[abi(per_item)]` 속성을 사용할 때,"
" public 함수는 `#[external(v0)]` 속성으로 주석 처리해야 합니다. 그렇지 않으면 노출되지 않습니다."

#: src/ch99-01-03-02-contract-functions.md:117
msgid ""
"In the case of `#[abi(per_item)]` attribute usage without "
"`#[generate_trait]`, it will only be possible to include `constructor`, "
"`l1-handler` and `internal` functions in the trait implementation. Indeed, "
"`#[abi(per_item)]` only works with a trait that is not defined as a Starknet"
" interface. Hence, it will be mandatory to create another trait defined as "
"interface to implement public functions."
msgstr ""
"`#[generate_trait]` 없이 `#[abi(per_item)]` 속성을 사용하는 경우, 트레이트 구현에는 "
"`constructor`, `l1-handler`, `internal` 함수만 포함될 수 있습니다. 실제로 "
"`#[abi(per_item)]`은 Starknet 인터페이스로 정의되지 않은 트레이트와만 작동합니다. 따라서 공개 함수를 구현하기 위해"
" 인터페이스로 정의된 다른 트레이트를 만들어야 할 것입니다."

#: src/ch99-01-03-02-contract-functions.md:119
msgid "Here is a short example:"
msgstr "다음은 간단한 예시입니다:"

#: src/ch99-01-03-02-contract-functions.md:131
msgid "// this is a constructor function\n"
msgstr "이것은 생성자 함수입니다."

#: src/ch99-01-03-02-contract-functions.md:135
msgid "// this is a public function\n"
msgstr "이것은 공개 함수입니다."

#: src/ch99-01-03-02-contract-functions.md:139
msgid "// this is a l1_handler function\n"
msgstr "// 이것은 l1_handler 함수입니다"

#: src/ch99-01-03-02-contract-functions.md:142
msgid "// this is an internal function\n"
msgstr "// 이것은 내부 함수입니다"

#: src/ch99-01-03-03-contract-events.md:1 src/ch99-01-05-00-components.md:29
msgid "Events"
msgstr "행사"

#: src/ch99-01-03-03-contract-events.md:3
msgid ""
"Events are custom data structures that are emitted by smart contracts during"
" execution. They provide a way for smart contracts to communicate with the "
"external world by logging information about specific occurrences in a "
"contract."
msgstr ""
"이벤트는 스마트 계약이 실행 중에 발생하는 사용자 정의 데이터 구조입니다. 이벤트는 스마트 계약이 특정 사건에 대한 정보를 기록함으로써 "
"외부 세계와 소통하는 방법을 제공합니다."

#: src/ch99-01-03-03-contract-events.md:7
msgid ""
"Events play a crucial role in the creation of smart contracts. Take, for "
"instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these "
"are indexed and stored in a database, then displayed to users through the "
"use of these events. Neglecting to include an event within your NFT contract"
" could lead to a bad user experience. This is because users may not see "
"their NFTs appear in their wallets (wallets use these indexers to display a "
"user's NFTs)."
msgstr ""
"이벤트는 스마트 계약의 생성에서 중요한 역할을 합니다. 예를 들어, Starknet에서 민팅된 비교적 교환할 수 없는 토큰(NFT)을 "
"살펴보십시오. 이 모든 것들은 데이터베이스에 색인화되어 저장되고, 그런 다음 이러한 이벤트를 통해 사용자에게 표시됩니다. NFT 계약에 "
"이벤트를 포함하지 않는다면 사용자 경험이 나빠질 수 있습니다. 이는 사용자가 지갑에 자신의 NFT가 나타나지 않을 수 있기 "
"때문입니다(지갑은 사용자의 NFT를 표시하기 위해 이 색인화자를 사용합니다)."

#: src/ch99-01-03-03-contract-events.md:9
msgid "Defining events"
msgstr "사건 정의"

#: src/ch99-01-03-03-contract-events.md:11
msgid ""
"All the different events in the contract are defined under the `Event` enum,"
" which implements the `starknet::Event` trait, as enum variants. This trait "
"is defined in the core library as follows:"
msgstr ""
"계약에 정의된 모든 다양한 이벤트는 'Event' enum 아래 정의되어 있습니다. 이 enum은 'starknet::Event' "
"trait을 구현하며 enum 변형으로 정의됩니다. 이 trait은 다음과 같이 코어 라이브러리에 정의되어 있습니다."

#: src/ch99-01-03-03-contract-events.md:20
msgid ""
"The `#[derive(starknet::Event)]` attribute causes the compiler to generate "
"an implementation for the above trait, instantiated with the Event type, "
"which in our example is the following enum:"
msgstr ""
"`#[derive(starknet::Event)]` 속성은 컴파일러가 위의 특성에 대한 구현을 생성하도록 하며, 이는 이벤트 유형으로 "
"인스턴스화된 이벤트 유형과 함께 사용됩니다. 예시에서는 다음과 같은 열거형입니다."

#: src/ch99-01-03-03-contract-events.md:38
msgid ""
"Each event variant has to be a struct of the same name as the variant, and "
"each variant needs to implement the `starknet::Event` trait itself. "
"Moreover, the members of these variants must implement the `Serde` trait "
"(_c.f._ [Appendix C: Serializing with Serde](./appendix-03-derivable-"
"traits.md)), as keys/data are added to the event using a serialization "
"process."
msgstr ""
"각 이벤트 변형은 해당 변형과 동일한 이름의 구조체여야 하며, 각 변형은 `starknet::Event` 트레이트를 직접 구현해야 "
"합니다. 또한, 이러한 변형들의 멤버들은 이벤트에 직렬화 프로세스를 사용하여 키/데이터가 추가되므로 `Serde` 트레이트를 구현해야 "
"합니다."

#: src/ch99-01-03-03-contract-events.md:41
msgid ""
"The auto implementation of the `starknet::Event` trait will implement the "
"`append_keys_and_data` function for each variant of our `Event` enum. The "
"generated implementation will append a single key based on the variant name "
"(`StoredName`), and then recursively call `append_keys_and_data` in the impl"
" of the Event trait for the variant’s type ."
msgstr ""
"`starknet::Event` 트레이트의 자동 구현은 `Event` enum의 각 변형에 대해 `append_keys_and_data`"
" 함수를 구현할 것입니다. 생성된 구현은 변형 이름(`StoredName`)을 기반으로 단일 키를 추가한 다음, 해당 타입의 변형에 대한"
" Event 트레이트의 impl에서 `append_keys_and_data`를 재귀적으로 호출할 것입니다."

#: src/ch99-01-03-03-contract-events.md:43
msgid ""
"In our contract, we define an event named `StoredName` that emits the "
"contract address of the caller and the name stored within the contract, "
"where the `user` field is serialized as a key and the `name` field is "
"serialized as data. To index the key of an event, simply annotate it with "
"the `#[key]` as demonstrated in the example for the `user` key."
msgstr ""
"저희 계약서에서는 호출자의 계약 주소와 계약 내에 저장된 이름을 발신하는 `StoredName`이라는 이벤트를 정의합니다. 여기서 "
"`user` 필드는 키로 직렬화되고 `name` 필드는 데이터로 직렬화됩니다. 이벤트의 키를 색인화하려면, 간단히 `user` 키에 대한"
" 예제에서와 같이 `#[key]`로 주석을 달면 됩니다."

#: src/ch99-01-03-03-contract-events.md:46
msgid ""
"When emitting the event with `self.emit(StoredName { user: user, name: name "
"})`, a key corresponding to the name ` StoredName`, specifically "
"`sn_keccak(StoredName)`, is appended to the keys list. `user`is serialized "
"as key, thanks to the `#[key]` attribute, while address is serialized as "
"data. After everything is processed, we end up with the following keys and "
"data: `keys = [sn_keccak(\"StoredName\"),user]` and `data = [name]`."
msgstr ""
"`self.emit(StoredName { user: user, name: name })` 이벤트를 발생시킬 때, 이름 "
"`StoredName`에 해당하는 키인 `sn_keccak(StoredName)`이 키 목록에 추가됩니다. `user`는 `#[key]`"
" 속성 덕분에 키로 직렬화되고, 주소는 데이터로 직렬화됩니다. 모든 처리가 완료되면 다음과 같은 키와 데이터가 생성됩니다: `keys ="
" [sn_keccak(\"StoredName\"), user]` 및 `data = [name]`."

#: src/ch99-01-03-03-contract-events.md:48
msgid "Emitting events"
msgstr "이벤트 발생"

#: src/ch99-01-03-03-contract-events.md:50
msgid ""
"After defining events, we can emit them using `self.emit`, with the "
"following syntax:"
msgstr "사건을 정의한 후에는 다음 구문을 사용하여 `self.emit`을 통해 이벤트를 발생시킬 수 있습니다."

#: src/ch99-01-03-04-reducing-boilerplate.md:3
msgid ""
"In a previous section, we saw this example of an implementation block in a "
"contract that didn't have any corresponding trait."
msgstr "이전 섹션에서 우리는 해당 계약 내의 구현 블록 예제를 보았는데, 해당 특성이 없었습니다."

#: src/ch99-01-03-04-reducing-boilerplate.md:26
msgid ""
"It's not the first time that we encounter this attribute, we already talked "
"about in it [Traits in Cairo](./ch08-02-traits-in-cairo.md). In this "
"section, we'll be taking a deeper look at it and see how it can be used in "
"contracts."
msgstr ""
"이 속성을 만나는 것은 처음이 아닙니다. 이미 [카이로의 특성](./ch08-02-traits-in-cairo.md)에서 이에 대해 "
"이야기했습니다. 이 섹션에서는 더 깊이 살펴보고 계약에서 어떻게 사용될 수 있는지 살펴보겠습니다."

#: src/ch99-01-03-04-reducing-boilerplate.md:28
msgid ""
"In order to access the ContractState in a function in an implementation "
"block, this implementation block must be defined with a `ContractState` "
"generic parameter. This implies that we first need to define a generic trait"
" that takes a `TContractState`, and then implement this trait for the "
"`ContractState` type. But by using the `#[generate_trait]` attribute, this "
"whole process can be skipped and we can simply define the implementation "
"block directly, without any generic parameter, and use `self: ContractState`"
" in our functions."
msgstr ""
"구현 블록 내의 함수에서 ContractState에 액세스하려면 해당 구현 블록은 'ContractState' 제네릭 매개변수로 "
"정의되어야 합니다. 이는 먼저 'TContractState'를 가져오는 제네릭 트레이트를 정의하고, 이 트레이트를 "
"'ContractState' 유형에 대해 구현해야 한다는 것을 의미합니다. 그러나 `#[generate_trait]` 속성을 사용하면 "
"이러한 전체 과정을 건너뛸 수 있으며, 우리는 제네릭 매개변수 없이 직접 구현 블록을 정의하고 함수에서 `self: "
"ContractState`를 사용할 수 있습니다."

#: src/ch99-01-03-04-reducing-boilerplate.md:31
msgid ""
"If we had to manually define the trait for the `InternalFunctions` "
"implementation, it would look something like this:"
msgstr "만약 우리가 `InternalFunctions` 구현을 수동으로 정의해야 한다면, 이렇게 보일 것입니다:"

#: src/ch99-01-03-05-optimizing-storage.md:1
msgid "Storage Optimization with `StorePacking`"
msgstr "`StorePacking`를 사용한 저장 공간 최적화"

#: src/ch99-01-03-05-optimizing-storage.md:3
msgid ""
"Bit-packing is a simple concept: Use as few bits as possible to store a "
"piece of data. When done well, it can significantly reduce the size of the "
"data you need to store. This is especially important in smart contracts, "
"where storage is expensive."
msgstr ""
"비트 패킹은 간단한 개념입니다: 가능한 한 적은 비트를 사용하여 데이터 조각을 저장합니다. 잘 수행되면 저장해야 하는 데이터의 크기를 "
"크게 줄일 수 있습니다. 이는 특히 저장 비용이 비싼 스마트 계약에서 중요합니다."

#: src/ch99-01-03-05-optimizing-storage.md:5
msgid ""
"When writing Cairo smart contracts, it is important to optimize storage "
"usage to reduce gas costs. Indeed, most of the cost associated with a "
"transaction is related to storage updates; and each storage slot costs gas "
"to write to. This means that by packing multiple values into fewer slots, "
"you can decrease the gas cost incurred by the users of your smart contract."
msgstr ""
"카이로 스마트 계약을 작성할 때는 가스 비용을 줄이기 위해 저장 공간 사용을 최적화하는 것이 중요합니다. 실제로, 거래와 관련된 대부분의"
" 비용은 저장 공간 업데이트와 관련이 있으며 각 저장 슬롯에 쓰기 위해 가스가 소요됩니다. 이는 여러 값을 더 적은 슬롯에 패킹하여 "
"스마트 계약 사용자가 소비하는 가스 비용을 줄일 수 있다는 것을 의미합니다."

#: src/ch99-01-03-05-optimizing-storage.md:8
msgid ""
"Cairo provides the `StorePacking` trait to enable packing struct fields into"
" fewer storage slots. For example, consider a `Sizes` struct with 3 fields "
"of different types. The total size is 8 + 32 + 64 = 104 bits. This is less "
"than the 128 bits of a single `u128`. This means we can pack all 3 fields "
"into a single `u128` variable. Since a storage slot can hold up to 251 bits,"
" our packed value will take only one storage slot instead of 3."
msgstr ""
"카이로는 `StorePacking` 특성을 제공하여 구조체 필드를 더 적은 저장 슬롯에 패킹할 수 있도록 합니다. 예를 들어, 다른 "
"유형의 3개 필드를 가진 `Sizes` 구조체를 고려해 보겠습니다. 총 크기는 8 + 32 + 64 = 104 비트입니다. 이는 단일 "
"`u128`의 128 비트보다 작습니다. 이는 모든 3개 필드를 단일 `u128` 변수에 패킹할 수 있다는 것을 의미합니다. 저장 슬롯은"
" 최대 251 비트까지 보유할 수 있으므로, 우리의 패킹된 값은 3개가 아닌 단일 저장 슬롯에만 들어갈 것입니다."

#: src/ch99-01-03-05-optimizing-storage.md:49
msgid "//don't forget to import it!\n"
msgstr ""

#: src/ch99-01-03-05-optimizing-storage.md:58
msgid ""
"// This will automatically pack the\n"
"        // struct into a single u128\n"
msgstr "이것은 구조체를 자동으로 단일 u128으로 패킹합니다."

#: src/ch99-01-03-05-optimizing-storage.md:66
msgid ""
"// this will automatically unpack the\n"
"        // packed-representation into the Sizes struct\n"
msgstr "이것은 자동으로 패킹된 표현을 Sizes 구조체로 해제할 것입니다."

#: src/ch99-01-03-05-optimizing-storage.md:75
msgid "Optimizing storage by implementing the `StorePacking` trait"
msgstr "`StorePacking` 트레이트를 구현하여 저장 공간 최적화하기"

#: src/ch99-01-03-05-optimizing-storage.md:77
msgid ""
"The `pack` function combines all three fields into a single `u128` value by "
"performing bitshift and additions. The `unpack` reverses this process to "
"extract the original fields back into a struct."
msgstr ""
"`pack` 함수는 비트 시프트와 덧셈을 통해 세 필드를 하나의 `u128` 값으로 결합합니다. `unpack` 함수는 이 과정을 반대로"
" 수행하여 원래 필드를 구조체로 다시 추출합니다."

#: src/ch99-01-03-05-optimizing-storage.md:79
msgid ""
"If you're not familiar with bit operations, here's an explanation of the "
"operations performed in the example: The goal is to pack the `tiny`, "
"`small`, and `medium` fields into a single `u128` value. First, when "
"packing:"
msgstr ""
"비트 연산에 익숙하지 않다면, 여기 예제에서 수행되는 연산에 대한 설명이 있습니다: 목표는 `tiny`, `small`, 그리고 "
"`medium` 필드를 하나의 `u128` 값으로 패킹하는 것입니다. 먼저, 패킹할 때:"

#: src/ch99-01-03-05-optimizing-storage.md:83
msgid ""
"`tiny` is a `u8` so we just convert it directly to a `u128` with `.into()`. "
"This creates a `u128` value with the low 8 bits set to `tiny`'s value."
msgstr ""
"`tiny`는 `u8`이므로 우리는 그것을 `.into()`로 직접 `u128`로 변환합니다. 이는 `tiny`의 값으로 설정된 하위 "
"8비트를 가진 `u128` 값을 생성합니다."

#: src/ch99-01-03-05-optimizing-storage.md:84
msgid ""
"`small` is a `u32` so we first shift it left by 8 bits (add 8 bits with the "
"value 0 to the left) to create room for the 8 bites taken by `tiny`. Then we"
" add `tiny` to `small` to combine them into a single `u128` value. The value"
" of `tiny` now takes bits 0-7 and the value of small takes bits 8-39."
msgstr ""
"`small`은 `u32`이므로 먼저 왼쪽으로 8비트 시프트하여(`tiny`가 차지하는 8비트를 왼쪽에 0으로 채워 넣음) `tiny`가"
" 차지하는 8비트를 위해 공간을 만듭니다. 그런 다음 `tiny`를 `small`에 추가하여 하나의 `u128` 값으로 결합합니다. 이제"
" `tiny`의 값은 비트 0-7을 차지하고 `small`의 값은 비트 8-39를 차지합니다."

#: src/ch99-01-03-05-optimizing-storage.md:85
msgid ""
"Similarly `medium` is a `u64` so we shift it left by 40 (8 + 32) bits "
"(`TWO_POW_40`) to make space for the previous fields. This takes bits "
"40-103."
msgstr ""
"비슷하게 `medium`은 `u64`이므로 이전 필드에 공간을 만들기 위해 40(8 + 32)비트(`TWO_POW_40`)만큼 왼쪽으로 "
"시프트합니다. 이는 40-103번 비트를 차지합니다."

#: src/ch99-01-03-05-optimizing-storage.md:87
msgid "When unpacking:"
msgstr "풀 때:"

#: src/ch99-01-03-05-optimizing-storage.md:89
msgid ""
"First we extract `tiny` by bitwise ANDing (&) with a bitmask of 8 ones (`& "
"MASK_8`). This isolates the lowest 8 bits of the packed value, which is "
"`tiny`'s value."
msgstr ""
"먼저 우리는 비트 AND 연산자(&)를 사용하여 8개의 1로 이루어진 비트 마스크와 `tiny`를 추출합니다(`& MASK_8`). "
"이렇게 하면 패킹된 값의 최하위 8비트를 분리하여 `tiny`의 값이 됩니다."

#: src/ch99-01-03-05-optimizing-storage.md:90
msgid ""
"For `small`, we right shift by 8 bits (`/ TWO_POW_8`) to align it with the "
"bitmask, then use bitwise AND with the 32 ones bitmask."
msgstr ""
"`small`에 대해 8비트 오른쪽 시프트(`/ TWO_POW_8`)하여 비트마스크와 일치시킨 후, 32비트 1로 이루어진 비트마스크와 "
"비트 AND 연산을 사용합니다."

#: src/ch99-01-03-05-optimizing-storage.md:91
msgid ""
"For `medium` we right shift by 40 bits. Since it is the last value packed, "
"we don't need to apply a bitmask as the higher bits are already 0."
msgstr ""
"`medium`를 40비트 오른쪽으로 시프트합니다. 마지막 값으로 패킹되었기 때문에 더 높은 비트가 이미 0이므로 비트마스크를 적용할 "
"필요가 없습니다."

#: src/ch99-01-03-05-optimizing-storage.md:93
msgid ""
"This technique can be used for any group of fields that fit within the bit "
"size of the packed storage type. For example, if you have a struct with "
"multiple fields whose bit sizes add up to 256 bits, you can pack them into a"
" single `u256` variable. If the bit sizes add up to 512 bits, you can pack "
"them into a single `u512` variable, and so on. You can define your own "
"structs and logic to pack and unpack them."
msgstr ""
"이 기술은 패킹된 저장 유형의 비트 크기 내에 맞는 필드 그룹에 사용할 수 있습니다. 예를 들어, 비트 크기가 256비트가 되도록 여러 "
"필드가 있는 구조체가 있다면, 이를 하나의 `u256` 변수에 패킹할 수 있습니다. 비트 크기가 512비트가 되도록 여러 필드가 있는 "
"경우, 이를 하나의 `u512` 변수에 패킹할 수 있으며, 이와 같이 계속됩니다. 자체 구조체 및 패킹 및 언패킹하는 논리를 정의할 수 "
"있습니다."

#: src/ch99-01-03-05-optimizing-storage.md:95
msgid ""
"The rest of the work is done magically by the compiler - if a type "
"implements the `StorePacking` trait, then the compiler will know it can use "
"the `StoreUsingPacking` implementation of the `Store` trait in order to pack"
" before writing and unpack after reading from storage. One important detail,"
" however, is that the type that `StorePacking::pack` spits out also has to "
"implement `Store` for `StoreUsingPacking` to work. Most of the time, we will"
" want to pack into a felt252 or u256 - but if you want to pack into a type "
"of your own, make sure that this one implements the `Store` trait."
msgstr ""
"일을 나머지는 컴파일러에 의해 마법처럼 처리됩니다 - 타입이 `StorePacking` 트레이트를 구현하면, 컴파일러는 저장 전에 "
"패킹하고 저장 후에 언패킹하기 위해 `Store` 트레이트의 `StoreUsingPacking` 구현을 사용할 수 있다는 것을 알게 될 "
"것입니다. 그러나 중요한 세부 사항은 `StorePacking::pack`이 출력하는 타입도 `Store`를 구현해야 "
"`StoreUsingPacking`이 작동한다는 것입니다. 대부분의 경우, felt252 또는 u256로 패킹하고 싶을 것입니다 - "
"그러나 자체 타입으로 패킹하려면, 해당 타입이 `Store` 트레이트를 구현했는지 확인하십시오."

#: src/ch99-01-05-00-components.md:1
msgid "Components: Lego-Like Building Blocks for Smart Contracts"
msgstr "구성 요소: 스마트 계약을 위한 레고처럼 조립 가능한 블록들"

#: src/ch99-01-05-00-components.md:3
msgid ""
"Developing contracts sharing a common logic and storage can be painful and "
"bug-prone, as this logic can hardly be reused and needs to be reimplemented "
"in each contract. But what if there was a way to snap in just the extra "
"functionality you need inside your contract, separating the core logic of "
"your contract from the rest?"
msgstr ""
"공통 로직 및 저장소를 공유하는 계약을 개발하는 것은 고통스럽고 버그가 발생하기 쉬울 수 있습니다. 왜냐하면 이러한 로직은 재사용하기 "
"어렵고 각 계약마다 다시 구현해야 할 수 있기 때문입니다. 그러나 계약의 핵심 로직을 나머지 부분과 분리하여 딱 필요한 추가 기능만 "
"삽입할 수 있는 방법이 있다면 어떨까요?"

#: src/ch99-01-05-00-components.md:9
msgid ""
"Components provide exactly that. They are modular add-ons encapsulating "
"reusable logic, storage, and events that can be incorporated into multiple "
"contracts. They can be used to extend a contract's functionality, without "
"having to reimplement the same logic over and over again."
msgstr ""
"구성 요소는 정확히 그 역할을 합니다. 재사용 가능한 로직, 저장소 및 이벤트를 캡슐화하는 모듈식 애드온으로, 여러 계약에 통합될 수 "
"있습니다. 동일한 로직을 반복해서 다시 구현하지 않고도 계약의 기능을 확장하는 데 사용할 수 있습니다."

#: src/ch99-01-05-00-components.md:14
msgid ""
"Think of components as Lego blocks. They allow you to enrich your contracts "
"by plugging in a module that you or someone else wrote. This module can be a"
" simple one, like an ownership component, or more complex like a full-"
"fledged ERC20 token."
msgstr ""
"구성 요소를 레고 블록으로 생각해보세요. 다른 사람이나 여러분이 작성한 모듈을 연결하여 계약을 보다 풍부하게 만들 수 있습니다. 이 "
"모듈은 소유권 구성 요소와 같이 간단한 것일 수도 있고, ERC20 토큰과 같이 복잡한 것일 수도 있습니다."

#: src/ch99-01-05-00-components.md:19
msgid ""
"A component is a separate module that can contain storage, events, and "
"functions. Unlike a contract, a component cannot be declared or deployed. "
"Its logic will eventually be part of the contract’s bytecode it has been "
"embedded in."
msgstr ""
"구성 요소는 저장소, 이벤트 및 함수를 포함할 수 있는 별도의 모듈입니다. 계약과 달리 구성 요소는 선언되거나 배포될 수 없습니다. 그 "
"로직은 결국 포함된 계약의 바이트 코드의 일부가 될 것입니다."

#: src/ch99-01-05-00-components.md:24
msgid "What's in a Component?"
msgstr "구성 요소에는 무엇이 있나요?"

#: src/ch99-01-05-00-components.md:26
msgid "A component is very similar to a contract. It can contain:"
msgstr "구성 요소는 계약과 매우 유사합니다. 다음을 포함할 수 있습니다:"

#: src/ch99-01-05-00-components.md:28
msgid "Storage variables"
msgstr "저장 변수"

#: src/ch99-01-05-00-components.md:30
msgid "External and internal functions"
msgstr "외부 및 내부 기능"

#: src/ch99-01-05-00-components.md:32
msgid ""
"Unlike a contract, a component cannot be deployed on its own. The "
"component's code becomes part of the contract it's embedded to."
msgstr "계약과는 달리, 구성 요소는 자체적으로 배포될 수 없습니다. 구성 요소의 코드는 포함된 계약의 일부가 됩니다."

#: src/ch99-01-05-00-components.md:35
msgid "Creating Components"
msgstr "구성 요소 만들기"

#: src/ch99-01-05-00-components.md:37
msgid ""
"To create a component, first define it in its own module decorated with a "
"`#[starknet::component]` attribute. Within this module, you can declare a ` "
"Storage` struct and `Event` enum, as usually done in "
"[Contracts](./ch99-01-02-a-simple-contract.md)."
msgstr ""
"컴포넌트를 만들려면 먼저 `#[starknet::component]` 속성으로 장식된 자체 모듈에서 정의해야 합니다. 이 모듈 내에서는 "
"일반적으로 [Contracts](./ch99-01-02-a-simple-contract.md)에서 수행하는 것과 같이 `Storage` "
"구조체와 `Event` 열거형을 선언할 수 있습니다."

#: src/ch99-01-05-00-components.md:42
msgid ""
"The next step is to define the component interface, containing the "
"signatures of the functions that will allow external access to the "
"component's logic. You can define the interface of the component by "
"declaring a trait with the `#[starknet::interface]` attribute, just as you "
"would with contracts. This interface will be used to enable external access "
"to the component's functions using the [Dispatcher](./ch99-02-02-contract-"
"dispatcher-library-dispatcher-and-system-calls.md) pattern."
msgstr ""
"다음 단계는 구성 요소 인터페이스를 정의하는 것입니다. 이 인터페이스에는 구성 요소 로직에 대한 외부 액세스를 허용하는 함수들의 "
"시그니처가 포함됩니다. 구성 요소의 인터페이스를 정의하려면 `#[starknet::interface]` 속성을 사용하여 특성을 선언하는 "
"것과 같은 방식으로 특성을 가진 trait를 선언할 수 있습니다. 이 인터페이스는 "
"[Dispatcher](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-"
"calls.md) 패턴을 사용하여 구성 요소 함수에 대한 외부 액세스를 가능하게 하는 데 사용됩니다."

#: src/ch99-01-05-00-components.md:51
msgid ""
"The actual implementation of the component's external logic is done in an "
"`impl` block marked as `#[embeddable_as(name)]`. Usually, this `impl` block "
"will be an implementation of the trait defining the interface of the "
"component."
msgstr ""
"구성 요소의 외부 로직의 실제 구현은 `#[embeddable_as(name)]`로 표시된 `impl` 블록에서 수행됩니다. 일반적으로,"
" 이 `impl` 블록은 구성 요소의 인터페이스를 정의하는 트레이트의 구현일 것입니다."

#: src/ch99-01-05-00-components.md:55
msgid ""
"Note: `name` is the name that we’ll be using in the contract to refer to the"
" component. It is different than the name of your impl."
msgstr "참고: `name`은 계약서에서 구성 요소를 가리키는 데 사용할 이름입니다. 이는 귀하의 구현 이름과는 다릅니다."

#: src/ch99-01-05-00-components.md:58
msgid ""
"You can also define internal functions that will not be accessible "
"externally, by simply omitting the `#[embeddable_as(name)]` attribute above "
"the internal `impl` block. You will be able to use these internal functions "
"inside the contract you embed the component in, but not interact with it "
"from outside, as they're not a part of the abi of the contract."
msgstr ""
"`#[embeddable_as(name)]` 속성을 내부 `impl` 블록 위에 생략함으로써 외부에서 접근할 수 없는 내부 함수를 정의할"
" 수도 있습니다. 이러한 내부 함수를 사용할 수는 있지만, 해당 함수는 계약의 abi의 일부가 아니기 때문에 외부에서 상호 작용할 수는 "
"없습니다. 해당 내부 함수는 해당 구성 요소를 포함하는 계약 내에서만 사용할 수 있습니다."

#: src/ch99-01-05-00-components.md:64
msgid ""
"Functions within these `impl` block expect arguments like `ref self: "
"ComponentState<TContractState>` (for state-modifying functions) or `self: "
"@ComponentState<TContractState>` (for view functions). This makes the impl "
"generic over `TContractState`, allowing us to use this component in any "
"contract."
msgstr ""
"이 `impl` 블록 내의 함수들은 `ref self: ComponentState<TContractState>` (상태 수정 함수용) "
"또는 `self: @ComponentState<TContractState>` (뷰 함수용)와 같은 인수를 기대합니다. 이는 "
"`TContractState`에 대해 일반화된 `impl`을 만들어 이 컴포넌트를 모든 계약에서 사용할 수 있게 합니다."

#: src/ch99-01-05-00-components.md:70
msgid "Example: an Ownable component"
msgstr "예시: 소유 가능한 구성요소"

#: src/ch99-01-05-00-components.md:72
msgid ""
"⚠️ The example shown below has not been audited and is not intended for "
"production use. The authors are not responsible for any damages caused by "
"the use of this code."
msgstr ""
"⚠️ 아래에 표시된 예시는 검토되지 않았으며 제품 사용을 위한 것이 아닙니다. 저자는 이 코드 사용으로 인해 발생하는 피해에 대해 "
"책임지지 않습니다."

#: src/ch99-01-05-00-components.md:76
msgid ""
"The interface of the Ownable component, defining the methods available "
"externally to manage ownership of a contract, would look like this:"
msgstr ""
"Ownable 구성 요소의 인터페이스는 계약 소유권을 관리하기 위해 외부에서 사용 가능한 메서드를 정의하며 다음과 같이 보일 것입니다:"

#: src/ch99-01-05-00-components.md:88
msgid "The component itself is defined as:"
msgstr "구성 요소 자체는 다음과 같이 정의됩니다:"

#: src/ch99-01-05-00-components.md:168
msgid ""
"This syntax is actually quite similar to the syntax used for contracts. The "
"only differences relate to the `#[embeddable_as]` attribute above the impl "
"and the genericity of the impl block that we will dissect in details."
msgstr ""
"이 구문은 실제로 계약에 사용되는 구문과 매우 유사합니다. 유일한 차이점은 impl 위에 있는 `#[embeddable_as]` 속성과 "
"우리가 자세히 살펴볼 impl 블록의 일반성과 관련이 있습니다."

#: src/ch99-01-05-00-components.md:172
msgid ""
"As you can see, our component has two `impl` blocks: one corresponding to "
"the implementation of the interface trait, and one containing methods that "
"should not be exposed externally and are only meant for internal use. "
"Exposing the `assert_only_owner` as part of the interface wouldn't make "
"sense, as it's only meant to be used internally by a contract embedding the "
"component."
msgstr ""
"보시다시피, 우리 구성 요소에는 두 개의 `impl` 블록이 있습니다: 하나는 인터페이스 트레이트의 구현에 해당하고, 다른 하나는 외부에"
" 노출되어서는 안 되는 메서드를 포함하고 있으며 내부적으로만 사용되어야 합니다. 인터페이스의 일부로 `assert_only_owner`를"
" 노출하는 것은 의미가 없습니다. 왜냐하면 이는 구성 요소를 포함하는 계약에 의해 내부적으로만 사용되도록 의도되었기 때문입니다."

#: src/ch99-01-05-00-components.md:178
msgid "A closer look at the `impl` block"
msgstr "`impl` 블록을 더 자세히 살펴보기"

#: src/ch99-01-05-00-components.md:189
msgid ""
"The `#[embeddable_as]` attribute is used to mark the impl as embeddable "
"inside a contract. It allows us to specify the name of the impl that will be"
" used in the contract to refer to this component. In this case, the "
"component will be referred to as `Ownable` in contracts embedding it."
msgstr ""
"`#[embeddable_as]` 속성은 impl을 계약 내에서 임베드 가능하다고 표시하는 데 사용됩니다. 이를 통해 계약에서 이 구성 "
"요소를 참조하기 위해 사용할 impl의 이름을 지정할 수 있습니다. 이 경우, 해당 구성 요소는 이를 임베드하는 계약에서 "
"`Ownable`로 참조될 것입니다."

#: src/ch99-01-05-00-components.md:194
msgid ""
"The implementation itself is generic over `ComponentState<TContractState>`, "
"with the added restriction that `TContractState` must implement the "
"`HasComponent<T>` trait. This allows us to use the component in any "
"contract, as long as the contract implements the `HasComponent` trait. "
"Understanding this mechanism in details is not required to use components, "
"but if you're curious about the inner workings, you can read more in the "
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md) "
"section."
msgstr ""
"구현 자체는 `ComponentState<TContractState>`에 대해 일반적이며, 추가 제한 사항은 "
"`TContractState`가 `HasComponent<T>` 트레이트를 구현해야 한다는 것입니다. 이를 통해 계약이 "
"`HasComponent` 트레이트를 구현하는 한 어떤 계약에서도 구성 요소를 사용할 수 있습니다. 이 메커니즘을 자세히 이해하는 것은 "
"구성 요소를 사용하는 데 필수적이지는 않지만, 내부 작동에 대해 궁금하다면 [Components under the "
"hood](./ch99-01-05-01-components-under-the-hood.md) 섹션에서 더 읽을 수 있습니다."

#: src/ch99-01-05-00-components.md:202
msgid ""
"One of the major differences from a regular smart contract is that access to"
" storage and events is done via the generic `ComponentState<TContractState>`"
" type and not `ContractState`. Note that while the type is different, "
"accessing storage or emitting events is done similarly via "
"`self.storage_var_name.read()` or `self.emit(...).`"
msgstr ""
"일반적인 스마트 계약과의 주요 차이점 중 하나는 저장소 및 이벤트에 대한 액세스가 일반적인 "
"`ComponentState<TContractState>` 유형을 통해 이루어지며 `ContractState`가 아닌 것입니다. 유형이 "
"다르더라도 저장소에 액세스하거나 이벤트를 발생시키는 방법은 `self.storage_var_name.read()` 또는 "
"`self.emit(...)`를 통해 유사하게 수행됩니다."

#: src/ch99-01-05-00-components.md:208
msgid ""
"Note: To avoid the confusion between the embeddable name and the impl name, "
"we recommend keeping the suffix `Impl` in the impl name."
msgstr "참고: 임베디드 이름과 구현 이름 사이의 혼란을 피하기 위해, 구현 이름에는 접미사 `Impl`을 유지하는 것을 권장합니다."

#: src/ch99-01-05-00-components.md:211
msgid "Migrating a Contract to a Component"
msgstr "계약을 구성 요소로 이동하기"

#: src/ch99-01-05-00-components.md:213
msgid ""
"Since both contracts and components share a lot of similarities, it's "
"actually very easy to migrate from a contract to a component. The only "
"changes required are:"
msgstr ""
"계약과 구성 요소 모두 많은 유사성을 공유하기 때문에 계약에서 구성 요소로 이주하는 것은 실제로 매우 쉽습니다. 필요한 변경 사항은 "
"다음과 같습니다:"

#: src/ch99-01-05-00-components.md:217
msgid "Adding the `#[starknet::component]` attribute to the module."
msgstr "모듈에 `#[starknet::component]` 속성을 추가합니다."

#: src/ch99-01-05-00-components.md:218
msgid ""
"Adding the `#[embeddable_as(name)]` attribute to the `impl` block that will "
"be embedded in another contract."
msgstr "다른 계약에 임베드될 `impl` 블록에 `#[embeddable_as(name)]` 속성을 추가합니다."

#: src/ch99-01-05-00-components.md:220
msgid "Adding generic parameters to the `impl` block:"
msgstr "`impl` 블록에 일반 매개변수 추가하기:"

#: src/ch99-01-05-00-components.md:221
msgid "Adding `TContractState` as a generic parameter."
msgstr "`TContractState`를 일반 매개변수로 추가합니다."

#: src/ch99-01-05-00-components.md:222
msgid "Adding `+HasComponent<TContractState>` as an impl restriction."
msgstr "`+HasComponent<TContractState>`를 구현 제한으로 추가합니다."

#: src/ch99-01-05-00-components.md:223
msgid ""
"Changing the type of the `self` argument in the functions inside the `impl` "
"block to `ComponentState<TContractState>` instead of `ContractState`."
msgstr ""
"`impl` 블록 내부의 함수들의 `self` 인자의 유형을 `ContractState` 대신에 "
"`ComponentState<TContractState>`로 변경합니다."

#: src/ch99-01-05-00-components.md:226
msgid ""
"For traits that do not have an explicit definition and are generated using "
"`#[generate_trait]`, the logic is the same - but the trait is generic over "
"`TContractState` instead of `ComponentState<TContractState>`, as "
"demonstrated in the example with the `InternalTrait`."
msgstr ""
"명시적 정의가 없는 특성 및 `#[generate_trait]`를 사용하여 생성된 특성의 경우, 로직은 동일하지만 "
"`ComponentState<TContractState>` 대신 `TContractState`에 대해 일반화된 특성입니다. "
"`InternalTrait` 예제에서 보여주었습니다."

#: src/ch99-01-05-00-components.md:231
msgid "Using components inside a contract"
msgstr "계약 내부에서 구성 요소를 사용하기"

#: src/ch99-01-05-00-components.md:233
msgid ""
"The major strength of components is how it allows reusing already built "
"primitives inside your contracts with a restricted amount of boilerplate. To"
" integrate a component into your contract, you need to:"
msgstr ""
"컴포넌트의 주요 강점은 이미 구축된 기본 구성 요소를 제한된 양의 보일러플레이트와 함께 계약 내에서 재사용할 수 있도록 하는 데 "
"있습니다. 컴포넌트를 계약에 통합하려면 다음을 수행해야 합니다:"

#: src/ch99-01-05-00-components.md:237
msgid "Declare it with the `component!()` macro, specifying"
msgstr "`component!()` 매크로를 사용하여 선언하세요."

#: src/ch99-01-05-00-components.md:239
msgid "The path to the component `path::to::component`."
msgstr "구성 요소 `path::to::component`로의 경로."

#: src/ch99-01-05-00-components.md:240
msgid ""
"The name of the variable in your contract's storage referring to this "
"component's storage (e.g. `ownable`)."
msgstr "이 구성 요소의 저장소를 가리키는 계약의 저장소에 대한 변수 이름 (예: `ownable`)."

#: src/ch99-01-05-00-components.md:242
msgid ""
"The name of the variant in your contract's event enum referring to this "
"component's events (e.g. `OwnableEvent`)."
msgstr "이 구성 요소의 이벤트를 참조하는 계약의 이벤트 열거형에서 변형의 이름 (예: `OwnableEvent`)."

#: src/ch99-01-05-00-components.md:245
msgid ""
"Add the path to the component's storage and events to the contract's "
"`Storage` and `Event`. They must match the names provided in step 1 (e.g. "
"`ownable: ownable_component::Storage` and `OwnableEvent: "
"ownable_component::Event`)."
msgstr ""
"컴포넌트의 저장소 및 이벤트 경로를 계약의 `Storage` 및 `Event`에 추가하십시오. 이들은 단계 1에서 제공된 이름과 일치해야"
" 합니다 (예: `ownable: ownable_component::Storage` 및 `OwnableEvent: "
"ownable_component::Event`)."

#: src/ch99-01-05-00-components.md:250
msgid ""
"The storage variable **MUST** be annotated with the `#[substorage(v0)]` "
"attribute."
msgstr "저장 변수는 `#[substorage(v0)]` 어트리뷰트로 주석 처리되어야 **합니다**."

#: src/ch99-01-05-00-components.md:253
msgid ""
"Embed the component's logic defined inside your contract, by instantiating "
"the component's generic impl with a concrete `ContractState` using an impl "
"alias. This alias must be annotated with `#[abi(embed_v0)]` to externally "
"expose the component's functions."
msgstr ""
"계약 내에서 구성 요소의 로직을 정의하고, 구성 요소의 일반적인 구현을 구체적인 `ContractState`를 사용하여 인스턴스화하여 "
"내장합니다. 이 별칭은 구성 요소의 함수를 외부에 노출하기 위해 `#[abi(embed_v0)]`로 주석 처리되어야 합니다."

#: src/ch99-01-05-00-components.md:258
msgid ""
"As you can see, the InternalImpl is not marked with `#[abi(embed_v0)]`. "
"Indeed, we don't want to expose externally the functions defined in this "
"impl. However, we might still want to access them internally."
msgstr ""
"보시다시피, InternalImpl은 `#[abi(embed_v0)]`로 표시되어 있지 않습니다. 실제로, 이 impl에 정의된 함수들을"
" 외부에 노출하고 싶지 않습니다. 그러나 내부적으로는 여전히 이에 접근하고 싶을 수도 있습니다."

#: src/ch99-01-05-00-components.md:264
msgid ""
"For example, to embed the `Ownable` component defined above, we would do the"
" following:"
msgstr "예를 들어, 위에서 정의한 `Ownable` 구성 요소를 포함시키려면 다음을 수행해야 합니다."

#: src/ch99-01-05-00-components.md:302
msgid ""
"The component's logic is now seamlessly part of the contract! We can "
"interact with the components functions externally by calling them using the "
"`IOwnableDispatcher` instantiated with the contract's address."
msgstr ""
"구성 요소의 논리는 이제 계약의 일부로 완벽하게 통합되었습니다! 우리는 `IOwnableDispatcher`를 사용하여 계약 주소로 "
"인스턴스화하여 외부에서 구성 요소 함수와 상호 작용할 수 있습니다."

#: src/ch99-01-05-00-components.md:315
msgid "Stacking Components for Maximum Composability"
msgstr "최대 구성 가능성을 위한 구성 요소 쌓기"

#: src/ch99-01-05-00-components.md:317
msgid ""
"The composability of components really shines when combining multiple of "
"them together. Each adds its features onto the contract. You will be able to"
" rely on [Openzeppelin's](https://github.com/OpenZeppelin/cairo-contracts) "
"future implementation of components to quickly plug-in all the common "
"functionalities you need a contract to have."
msgstr ""
"구성 요소의 조합성은 여러 개를 함께 결합할 때 정말 빛을 발합니다. 각각이 계약에 기능을 추가합니다. "
"[Openzeppelin](https://github.com/OpenZeppelin/cairo-contracts)의 미래 구성 요소 "
"구현을 신뢰하고, 계약이 가져야 하는 모든 공통 기능을 빠르게 플러그인할 수 있습니다."

#: src/ch99-01-05-00-components.md:323
msgid ""
"Developers can focus on their core contract logic while relying on battle-"
"tested and audited components for everything else."
msgstr "개발자들은 핵심 계약 논리에 집중할 수 있으면서 다른 모든 것에 대해 검증된 구성 요소에 의존할 수 있습니다."

#: src/ch99-01-05-00-components.md:326
msgid ""
"Components can even [depend](./ch99-01-05-02-component-dependencies.md) on "
"other components by restricting the `TContractstate` they're generic on to "
"implement the trait of another component. Before we dive into this "
"mechanism, let's first look at [how components work under the "
"hood](./ch99-01-05-01-components-under-the-hood)."
msgstr ""
"구성 요소는 다른 구성 요소에 의존할 수도 있습니다. 이는 제네릭한 `TContractstate`가 다른 구성 요소의 특성을 구현하도록 "
"제한함으로써 이루어집니다. 이 메커니즘에 대해 자세히 알아보기 전에, 먼저 [구성 요소가 어떻게 작동하는지 "
"살펴보겠습니다](./ch99-01-05-01-components-under-the-hood)."

#: src/ch99-01-05-00-components.md:331
msgid "Troubleshooting"
msgstr "문제 해결"

#: src/ch99-01-05-00-components.md:333
msgid ""
"You might encounter some errors when trying to implement components. "
"Unfortunately, some of them lack meaningful error messages to help debug. "
"This section aims to provide you with some pointers to help you debug your "
"code."
msgstr ""
"구성 요소를 구현하려고 할 때 오류가 발생할 수 있습니다. 불행하게도 그 중 일부는 디버깅을 돕는 의미 있는 오류 메시지가 부족합니다. "
"이 섹션은 코드 디버깅을 돕기 위한 몇 가지 지침을 제공하는 것을 목표로 합니다."

#: src/ch99-01-05-00-components.md:337
msgid "`Trait not found. Not a trait.`"
msgstr "`특성을 찾을 수 없습니다. 특성이 아닙니다.`"

#: src/ch99-01-05-00-components.md:339
msgid ""
"This error can occur when you're not importing the component's impl block "
"correctly in your contract. Make sure to respect the following syntax:"
msgstr ""
"이 오류는 컨트랙트에서 구성 요소의 구현 블록을 올바르게 가져오지 않을 때 발생할 수 있습니다. 다음 구문을 준수하는지 확인하십시오:"

#: src/ch99-01-05-00-components.md:347
msgid "Referring to our previous example, this would be:"
msgstr "이전 예시를 참조하면, 이것은 다음과 같을 것입니다:"

#: src/ch99-01-05-00-components.md:354
msgid ""
"`Plugin diagnostic: name is not a substorage member in the contract's "
"Storage. Consider adding to Storage: (...)`"
msgstr "플러그인 진단: 이름은 계약의 저장소의 하위 저장소 멤버가 아닙니다. 저장소에 추가하는 것을 고려해보세요: (...)"

#: src/ch99-01-05-00-components.md:357
msgid ""
"The compiler helps you a lot debugging this by giving you recommendation on "
"the action to take. Basically, you forgot to add the component's storage to "
"your contract's storage. Make sure to add the path to the component's "
"storage annotated with the `#[substorage(v0)]` attribute to your contract's "
"storage."
msgstr ""
"컴파일러는 귀하가 하는 작업에 대한 권장 사항을 제공하여 이를 디버깅하는 데 많은 도움을 줍니다. 기본적으로 컨트랙트의 저장소에 구성 "
"요소의 저장소를 추가하는 것을 잊었습니다. 컨트랙트의 저장소에 `#[substorage(v0)]` 속성으로 주석이 달린 구성 요소의 "
"저장소 경로를 추가해야 합니다."

#: src/ch99-01-05-00-components.md:362
msgid ""
"`Plugin diagnostic: name is not a nested event in the contract's Event enum."
" Consider adding to the Event enum:`"
msgstr "플러그인 진단: 이름은 계약의 이벤트 열거형에 중첩된 이벤트가 아닙니다. 이벤트 열거형에 추가하는 것을 고려해보세요:"

#: src/ch99-01-05-00-components.md:365
msgid ""
"Similar to the previous error, the compiler, you forgot to add the "
"component's events to your contract's events. Make sure to add the path to "
"the component's events to your contract's events."
msgstr ""
"이전 오류와 유사하게, 컴파일러에서 컴포넌트의 이벤트를 계약의 이벤트에 추가하는 것을 잊었습니다. 컴포넌트의 이벤트 경로를 계약의 "
"이벤트에 추가해야 합니다."

#: src/ch99-01-05-00-components.md:369
msgid "Components functions are not accessible externally"
msgstr "구성 요소 기능은 외부에서 접근할 수 없습니다."

#: src/ch99-01-05-00-components.md:371
msgid ""
"This can happen if you forgot to annotate the component's impl block with "
"`#[abi(embed_v0)]`. Make sure to add this annotation when embedding the "
"component's impl in your contract."
msgstr ""
"이는 구성 요소의 impl 블록에 `#[abi(embed_v0)]` 주석을 잊어버렸을 때 발생할 수 있습니다. 계약에 구성 요소의 "
"impl을 포함할 때 이 주석을 추가해야 합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:1
msgid "Components under the hood"
msgstr "후드 아래 구성 요소"

#: src/ch99-01-05-01-components-under-the-hood.md:3
msgid ""
"Components provide powerful modularity to Starknet contracts. But how does "
"this magic actually happen behind the scenes?"
msgstr "구성 요소는 Starknet 계약에 강력한 모듈성을 제공합니다. 그러나 실제로 이 마법은 어떻게 이루어지는 걸까요?"

#: src/ch99-01-05-01-components-under-the-hood.md:6
msgid ""
"This chapter will dive deep into the compiler internals to explain the "
"mechanisms that enable component composability."
msgstr "이 장에서는 컴파일러 내부로 깊이 파고들어 구성 요소 조합이 가능하게 하는 메커니즘을 설명할 것입니다."

#: src/ch99-01-05-01-components-under-the-hood.md:9
msgid "A Primer on Embeddable Impls"
msgstr "임베디 블 수행에 대한 기본 안내서"

#: src/ch99-01-05-01-components-under-the-hood.md:11
msgid ""
"Before digging into components, we need to understand _embeddable impls_."
msgstr "구성 요소를 파헤치기 전에 _embeddable impls_ 를 이해해야 합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:13
msgid ""
"An impl of a Starknet interface trait (marked with `#[starknet::interface]`)"
" can be made embeddable. Embeddable impls can be injected into any contract,"
" adding new entry points and modifying the ABI of the contract."
msgstr ""
"`#[starknet::interface]`로 표시된 Starknet 인터페이스 트레이트의 구현체는 임베드 가능합니다. 임베드 가능한 "
"구현체는 어떤 계약에도 주입될 수 있으며, 새로운 진입점을 추가하고 계약의 ABI를 수정할 수 있습니다."

#: src/ch99-01-05-01-components-under-the-hood.md:17
msgid "Let's look at an example to see this in action:"
msgstr "이를 실제로 확인하기 위해 예시를 살펴봅시다."

#: src/ch99-01-05-01-components-under-the-hood.md:42
msgid ""
"By embedding `SimpleImpl`, we externally expose `ret4` in the contract's "
"ABI."
msgstr "`SimpleImpl`를 임베드하여 contract의 ABI에서 `ret4`를 외부로 노출합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:44
msgid ""
"Now that we’re more familiar with the embedding mechanism, we can now see "
"how components build on this."
msgstr "이제 임베딩 메커니즘에 더 익숙해졌으니, 이제 구성 요소가 이를 기반으로 어떻게 구축되는지 볼 수 있습니다."

#: src/ch99-01-05-01-components-under-the-hood.md:47
msgid "Inside Components: Generic Impls"
msgstr "내부 구성 요소: 일반 구현체"

#: src/ch99-01-05-01-components-under-the-hood.md:49
msgid "Recall the impl block syntax used in components:"
msgstr "구성 요소에서 사용된 impl 블록 구문을 상기하십시오."

#: src/ch99-01-05-01-components-under-the-hood.md:58
msgid "The key points:"
msgstr "주요 요점:"

#: src/ch99-01-05-01-components-under-the-hood.md:60
msgid ""
"`OwnableImpl` requires the implementation of the "
"`HasComponent<TContractState>` trait by the underlying contract, which is "
"automatically generated with the `component!()` macro when using a component"
" inside a contract."
msgstr ""
"`OwnableImpl`는 기본 계약에 의해 `HasComponent<TContractState>` 특성의 구현을 요구하며, 계약 내에서"
" 구성 요소를 사용할 때 `component!()` 매크로로 자동으로 생성됩니다."

#: src/ch99-01-05-01-components-under-the-hood.md:65
msgid ""
"The compiler will generate an impl that wraps any function in `OwnableImpl`,"
" replacing the `self: ComponentState<TContractState>` argument with `self: "
"TContractState`, where access to the component state is made via the "
"`get_component` function in the `HasComponent<TContractState>` trait."
msgstr ""
"컴파일러는 `OwnableImpl`에 있는 모든 함수를 래핑하는 impl을 생성합니다. 이때 `self: "
"ComponentState<TContractState>` 인자를 `self: TContractState`로 대체하며, 컴포넌트 상태에 "
"접근은 `HasComponent<TContractState>` 트레이트의 `get_component` 함수를 통해 이루어집니다."

#: src/ch99-01-05-01-components-under-the-hood.md:70
msgid ""
"For each component, the compiler generates a `HasComponent` trait. This "
"trait defines the interface to bridge between the actual `TContractState` of"
" a generic contract, and `ComponentState<TContractState>`."
msgstr ""
"각 구성 요소에 대해 컴파일러는 `HasComponent` 트레이트를 생성합니다. 이 트레이트는 일반 계약의 실제 "
"`TContractState`와 `ComponentState<TContractState>` 사이의 인터페이스를 정의합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:75
msgid "// generated per component\n"
msgstr "// 구성 요소별로 생성됨"

#: src/ch99-01-05-01-components-under-the-hood.md:85
msgid ""
"In our context `ComponentState<TContractState>` is a type specific to the "
"ownable component, i.e. it has members based on the storage variables "
"defined in `ownable_component::Storage`. Moving from the generic "
"`TContractState` to `ComponentState<TContractState>` will allow us to embed "
"`Ownable` in any contract that wants to use it. The opposite direction "
"(`ComponentState<TContractState>` to `ContractState`) is useful for "
"dependencies (see the `Upgradeable` component depending on an `IOwnable` "
"implementation example in the [Components dependencies "
"](./ch99-01-05-02-component-dependencies.md) section."
msgstr ""
"우리 맥락에서 `ComponentState<TContractState>`는 소유 가능한 컴포넌트에 특화된 유형입니다. 즉, "
"`ownable_component::Storage`에서 정의된 저장 변수를 기반으로 하는 멤버를 가지고 있습니다. 일반적인 "
"`TContractState`에서 `ComponentState<TContractState>`로 이동함으로써 우리는 `Ownable`을 "
"사용하려는 모든 계약에 포함시킬 수 있게 될 것입니다. 반대 방향인 (`ComponentState<TContractState>`에서 "
"`ContractState`로) 이는 의존성에 유용합니다 ([Components "
"dependencies](./ch99-01-05-02-component-dependencies.md) 섹션의 `IOwnable` 구현 "
"예제에 의존하는 `Upgradeable` 컴포넌트를 참조)."

#: src/ch99-01-05-01-components-under-the-hood.md:94
msgid ""
"To put it briefly, one should think of an implementation of the above "
"`HasComponent<T>` as saying: **“Contract whose state T has the upgradeable "
"component”.**"
msgstr ""
"간단히 말하자면, 위의 `HasComponent<T>`의 구현을 생각해야 합니다. 이는 다음과 같이 말하는 것과 같습니다: **\"상태 "
"T를 가진 업그레이드 가능한 구성 요소를 가진 계약\"**."

#: src/ch99-01-05-01-components-under-the-hood.md:98
msgid "`Ownable` is annotated with the `embeddable_as(<name>)` attribute:"
msgstr "`Ownable`은 `embeddable_as(<name>)` 속성으로 주석이 달렸습니다."

#: src/ch99-01-05-01-components-under-the-hood.md:100
msgid ""
"`embeddable_as` is similar to `embeddable`; it only applies to `impls` of "
"`starknet::interface` traits and allows embedding this impl in a contract "
"module. That said, `embeddable_as(<name>)` has another role in the context "
"of components. Eventually, when embedding `OwnableImpl` in some contract, we"
" expect to get an impl with the following functions:"
msgstr ""
"`embeddable_as`는 `embeddable`과 유사하며, `starknet::interface` 트레이트의 `impls`에만 "
"적용되며, 이 `impl`을 계약 모듈에 포함시킬 수 있습니다. 그렇지만, `embeddable_as(<name>)`은 구성 요소의 "
"문맥에서 다른 역할을 합니다. 어느 정도 시간이 지나면, 어떤 계약에 `OwnableImpl`을 포함시킬 때, 다음 함수를 가진 "
"`impl`을 얻을 것으로 기대합니다:"

#: src/ch99-01-05-01-components-under-the-hood.md:112
msgid ""
"Note that while starting with a function receiving the generic type "
"`ComponentState<TContractState>`, we want to end up with a function "
"receiving `ContractState`. This is where `embeddable_as(<name>)` comes in. "
"To see the full picture, we need to see what is the impl generated by the "
"compiler due to the `embeddable_as(Ownable)` annotation:"
msgstr ""
"제네릭 타입 `ComponentState<TContractState>`을 받는 함수로 시작하더라도, "
"`ContractState`를 받는 함수로 끝내고 싶습니다. 여기서 `embeddable_as(<name>)`이 필요합니다. "
"전체 그림을 보기 위해서는 `embeddable_as(Ownable)` 어노테이션으로 생성된 컴파일러에 의한 구현을 살펴봐야 합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:143
msgid ""
"Note that thanks to having an impl of `HasComponent<TContractState>`, the "
"compiler was able to wrap our functions in a new impl that doesn’t directly "
"know about the `ComponentState` type. `Ownable`, whose name we chose when "
"writing `embeddable_as(Ownable)`, is the impl that we will embed in a "
"contract that wants ownership."
msgstr ""
"`HasComponent<TContractState>`의 impl을 가지고 있기 때문에 컴파일러는 우리의 함수를 "
"`ComponentState` 유형에 대해 직접 알지 못하는 새로운 impl로 래핑할 수 있었습니다. `Ownable`은 "
"`embeddable_as(Ownable)`을 작성할 때 선택한 이름으로, 소유권을 원하는 계약에 포함할 impl입니다."

#: src/ch99-01-05-01-components-under-the-hood.md:149
msgid "Contract Integration"
msgstr "계약 통합"

#: src/ch99-01-05-01-components-under-the-hood.md:151
msgid ""
"We've seen how generic impls enable component reusability. Next let's see "
"how a contract integrates a component."
msgstr "일반 구현이 구성 요소의 재사용을 가능하게 하는 방법을 보았습니다. 다음으로 계약이 구성 요소를 통합하는 방법을 살펴봅시다."

#: src/ch99-01-05-01-components-under-the-hood.md:154
msgid ""
"The contract uses an **impl alias** to instantiate the component's generic "
"impl with the concrete `ContractState` of the contract."
msgstr ""
"계약은 구성 요소의 일반 구현을 구체적인 `ContractState`로 인스턴스화하기 위해 **impl alias**를 사용합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:164
msgid ""
"The above lines use the Cairo impl embedding mechanism alongside the impl "
"alias syntax. We’re instantiating the generic `OwnableImpl<TContractState>` "
"with the concrete type `ContractState`. Recall that "
"`OwnableImpl<TContractState>` has the `HasComponent<TContractState>` generic"
" impl parameter. An implementation of this trait is generated by the "
"`component!` macro."
msgstr ""
"위의 라인들은 Cairo impl 임베딩 메커니즘을 사용하며 impl 별칭 구문과 함께 사용됩니다. 우리는 구체적인 타입 "
"'ContractState'로 일반적인 `OwnableImpl<TContractState>`을 인스턴스화하고 있습니다. "
"`OwnableImpl<TContractState>`은 `HasComponent<TContractState>` 일반적인 impl "
"매개변수를 가지고 있음을 기억하세요. 이 특성의 구현은 `component!` 매크로에 의해 생성됩니다."

#: src/ch99-01-05-01-components-under-the-hood.md:170
msgid ""
"Note that only the using contract could have implemented this trait since "
"only it knows about both the contract state and the component state."
msgstr ""
"주의할 점은 사용 중인 계약만이 이 특성을 구현할 수 있다는 것입니다. 왜냐하면 계약 상태와 구성 요소 상태에 대해 알고 있는 것은 오직"
" 그것 뿐이기 때문입니다."

#: src/ch99-01-05-01-components-under-the-hood.md:174
msgid ""
"This glues everything together to inject the component logic into the "
"contract."
msgstr "이것은 모든 것을 함께 붙여 계약에 구성 요소 논리를 주입합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:176
msgid "Key Takeaways"
msgstr "주요 요점"

#: src/ch99-01-05-01-components-under-the-hood.md:178
msgid ""
"Embeddable impls allow injecting components logic into contracts by adding "
"entry points and modifying the contract ABI."
msgstr "임베더블 인플은 컴포넌트 로직을 계약에 주입할 수 있게 해주며, 진입점을 추가하고 계약 ABI를 수정함으로써 가능합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:180
msgid ""
"The compiler automatically generates a `HasComponent` trait implementation "
"when a component is used in a contract. This creates a bridge between the "
"contract's state and the component's state, enabling interaction between the"
" two."
msgstr ""
"컴파일러는 컨트랙트에서 컴포넌트를 사용할 때 자동으로 `HasComponent` 트레이트 구현을 생성합니다. 이는 컨트랙트의 상태와 "
"컴포넌트의 상태 사이에 다리를 만들어 두 개 사이의 상호작용을 가능하게 합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:184
msgid ""
"Components encapsulate reusable logic in a generic, contract-agnostic way. "
"Contracts integrate components through impl aliases and access them via the "
"generated `HasComponent` trait."
msgstr ""
"구성 요소는 일반적이고 계약에 중립적인 방식으로 재사용 가능한 로직을 캡슐화합니다. 계약은 구현 별칭을 통해 구성 요소를 통합하고 생성된"
" `HasComponent` 트레이트를 통해 액세스합니다."

#: src/ch99-01-05-01-components-under-the-hood.md:187
msgid ""
"Components build on embeddable impls by defining generic component logic "
"that can be integrated into any contract wanting to use that component. Impl"
" aliases instantiate these generic impls with the contract's concrete "
"storage types."
msgstr ""
"구성 요소는 임베디드 구현을 기반으로 하며, 해당 구성 요소를 사용하려는 모든 계약에 통합할 수 있는 일반 구성 요소 논리를 정의함으로써"
" 구현을 구축합니다. 구현 별칭은 이러한 일반 구현을 계약의 구체적인 저장 유형으로 인스턴스화합니다."

#: src/ch99-01-05-03-testing-components.md:3
msgid ""
"Testing components is a bit different than testing contracts. Contracts need"
" to be tested against a specific state, which can be achieved by either "
"deploying the contract in a test, or by simply getting the `ContractState` "
"object and modifying it in the context of your tests."
msgstr ""
"컴포넌트를 테스트하는 것은 계약을 테스트하는 것과 약간 다릅니다. 계약은 특정 상태에 대해 테스트되어야 하며, 이는 테스트에서 계약을 "
"배포하거나 단순히 `ContractState` 객체를 가져와 테스트 상황에서 수정함으로써 달성할 수 있습니다."

#: src/ch99-01-05-03-testing-components.md:6
msgid ""
"Components are a generic construct, meant to be integrated in contracts, "
"that can't be deployed on their own and don't have a `ContractState` object "
"that we could use. So how do we test them?"
msgstr ""
"구성 요소는 계약에 통합되어야 하는 일반적인 구조물로, 자체적으로 배포할 수 없으며 사용할 수 있는 'ContractState' 객체가 "
"없습니다. 그렇다면 어떻게 테스트해야 할까요?"

#: src/ch99-01-05-03-testing-components.md:8
msgid ""
"Let's consider that we want to test a very simple component called "
"\"Counter\", that will allow each contract to have a counter that can be "
"incremented. The component is defined as follows:"
msgstr ""
"우리가 \"Counter\"라고 불리는 매우 간단한 구성 요소를 테스트하려고 한다고 가정해 봅시다."
"이 구성 요소는 각 계약이 증가시킬 수 있는 카운터를 가지도록 할 것입니다. 이 구성 요소는 다음과 같이 정의됩니다:"

#: src/ch99-01-05-03-testing-components.md:32
msgid "Testing the component by deploying a mock contract"
msgstr "모의 계약을 배포하여 구성 요소를 테스트합니다."

#: src/ch99-01-05-03-testing-components.md:34
msgid ""
"The easiest way to test a component is to integrate it within a mock "
"contract. This mock contract is only used for testing purposes, and only "
"integrates the component you want to test. This allows you to test the "
"component in the context of a contract, and to use a Dispatcher to call the "
"component's entry points."
msgstr ""
"구성 요소를 테스트하는 가장 쉬운 방법은 모의 계약 내에서 통합하는 것입니다. 이 모의 계약은 테스트 목적으로만 사용되며 테스트하려는 "
"구성 요소만 통합됩니다. 이를 통해 계약의 맥락에서 구성 요소를 테스트하고, 디스패처를 사용하여 구성 요소의 진입점을 호출할 수 "
"있습니다."

#: src/ch99-01-05-03-testing-components.md:36
msgid "We can define such a mock contract as follows:"
msgstr "우리는 그러한 가짜 계약을 다음과 같이 정의할 수 있습니다:"

#: src/ch99-01-05-03-testing-components.md:59
msgid ""
"This contract is entirely dedicated to testing the `Counter` component. It "
"embeds the component with the `component!` macro, exposes the component's "
"entry points by annotating the impl aliases with `#[abi(embed_v0)]`."
msgstr ""
"이 계약은 `Counter` 구성 요소의 테스트에 완전히 전념되어 있습니다. `component!` 매크로를 사용하여 구성 요소를 "
"포함하고, `#[abi(embed_v0)]`로 impl 별칭을 주석 처리하여 구성 요소의 진입점을 노출합니다."

#: src/ch99-01-05-03-testing-components.md:61
msgid ""
"We also need to define an interface that will be required to interact "
"externally with this mock contract."
msgstr "우리는 또한 이 가짜 계약과 외부 상호 작용이 필요한 인터페이스를 정의해야 합니다."

#: src/ch99-01-05-03-testing-components.md:71
msgid ""
"We can now write tests for the component by deploying this mock contract and"
" calling its entry points, as we would with a typical contract."
msgstr ""
"이제 이 목업 계약을 배포하고 일반적인 계약과 같이 해당 엔트리 포인트를 호출하여 컴포넌트에 대한 테스트를 작성할 수 있습니다."

#: src/ch99-01-05-03-testing-components.md:102
msgid "Testing components without deploying a contract"
msgstr "계약을 배포하지 않고 구성 요소를 테스트하기"

#: src/ch99-01-05-03-testing-components.md:104
msgid ""
"In [Components under the hood](./ch99-01-05-01-components-under-the-"
"hood.md), we saw that components leveraged genericity to define storage and "
"logic that could be embedded in multiple contracts. If a contract embeds a "
"component, a `HasComponent` trait is created in this contract, and the "
"component methods are made available."
msgstr ""
"[Components under the hood](./ch99-01-05-01-components-under-the-hood.md)에서 "
"우리는 컴포넌트가 일반성을 활용하여 여러 계약에 임베드될 수 있는 저장소와 논리를 정의했다는 것을 보았습니다. 계약이 컴포넌트를 "
"임베드하면 이 계약에 `HasComponent` 트레이트가 생성되고 컴포넌트 메소드가 사용 가능해집니다."

#: src/ch99-01-05-03-testing-components.md:106
msgid ""
"This informs us that if we can provide a concrete `TContractState` that "
"implements the `HasComponent` trait to the `ComponentState` struct, should "
"be able to directly invoke the methods of the component using this concrete "
"`ComponentState` object, without having to deploy a mock."
msgstr ""
"이는 `HasComponent` 트레이트를 구현하는 구체적인 `TContractState`를 `ComponentState` 구조체에 "
"제공할 수 있다면, 이 구체적인 `ComponentState` 객체를 사용하여 컴포넌트의 메서드를 직접 호출할 수 있어야 하며, 목을 "
"배포할 필요 없이 가능함을 알려줍니다."

#: src/ch99-01-05-03-testing-components.md:108
msgid ""
"Let's see how we can do that by using type aliases. We still need to define "
"a mock contract - let's use the same as above - but this time, we won't need"
" to deploy it."
msgstr ""
"우리가 타입 별칭을 사용하여 그것을 어떻게 할 수 있는지 살펴보겠습니다. 여전히 목 계약을 정의해야 합니다 - 위에서와 같이 "
"사용하겠습니다 - 하지만 이번에는 배포할 필요가 없을 것입니다."

#: src/ch99-01-05-03-testing-components.md:110
msgid ""
"First, we need to define a concrete implementation of the generic "
"`ComponentState` type using a type alias. We will use the "
"`MockContract::ContractState` type to do so."
msgstr ""
"먼저, 우리는 일반적인 `ComponentState` 유형의 구체적인 구현을 유형 별칭을 사용하여 정의해야 합니다. 이를 위해 "
"`MockContract::ContractState` 유형을 사용할 것입니다."

#: src/ch99-01-05-03-testing-components.md:118
#: src/ch99-01-05-03-testing-components.md:162
msgid "// You can derive even `Default` on this type alias\n"
msgstr "이 타입 별칭에 대해서도 `Default`를 유도할 수 있습니다."

#: src/ch99-01-05-03-testing-components.md:139
msgid ""
"We defined the `TestingState` type as an alias of the "
"`CounterComponent::ComponentState<MockContract::ContractState>` type. By "
"passing the `MockContract::ContractState` type as a concrete type for "
"`ComponentState`, we aliased a concrete implementation of the "
"`ComponentState` struct to `TestingState`."
msgstr ""
"우리는 `TestingState` 유형을 "
"`CounterComponent::ComponentState<MockContract::ContractState>` 유형의 별칭으로 "
"정의했습니다. `MockContract::ContractState` 유형을 `ComponentState`의 구체적인 유형으로 "
"전달함으로써, `ComponentState` 구조체의 구체적인 구현을 `TestingState`로 별칭 지정했습니다."

#: src/ch99-01-05-03-testing-components.md:141
msgid ""
"Because `MockContract` embeds `CounterComponent`, the methods of "
"`CounterComponent` defined in the `CounterImpl` block can now be used on a "
"`TestingState` object."
msgstr ""
"`MockContract`이 `CounterComponent`를 포함하고 있기 때문에, `CounterImpl` 블록에서 정의된 "
"`CounterComponent`의 메서드들이 이제 `TestingState` 객체에서 사용될 수 있습니다."

#: src/ch99-01-05-03-testing-components.md:143
msgid ""
"Now that we have made these methods available, we need to instantiate an "
"object of type `TestingState`, that we will use to test the component. We "
"can do so by calling the `component_state_for_testing` function, which "
"automatically infers that it should return an object of type `TestingState`."
msgstr ""
"이러한 방법을 사용할 수 있게 되었으므로, `TestingState` 유형의 객체를 인스턴스화해야 합니다. 이 객체는 컴포넌트를 "
"테스트하는 데 사용될 것입니다. `component_state_for_testing` 함수를 호출하여 이를 수행할 수 있습니다. 이 "
"함수는 자동으로 `TestingState` 유형의 객체를 반환해야 한다는 것을 추론합니다."

#: src/ch99-01-05-03-testing-components.md:145
msgid ""
"We can even implement this as part of the `Default` trait, which allows us "
"to return an empty `TestingState` with the `Default::default()` syntax."
msgstr ""
"우리는 심지어 `Default` 트레이트의 일부로 이를 구현할 수 있습니다. 이는 `Default::default()` 구문을 사용하여 "
"빈 `TestingState`을 반환할 수 있게 해줍니다."

#: src/ch99-01-05-03-testing-components.md:147
msgid "Let's summarize what we've done so far:"
msgstr "지금까지 한 일을 요약해 봅시다."

#: src/ch99-01-05-03-testing-components.md:149
msgid "We defined a mock contract that embeds the component we want to test."
msgstr "우리는 테스트하고 싶은 컴포넌트를 내장한 가짜 계약을 정의했습니다."

#: src/ch99-01-05-03-testing-components.md:150
msgid ""
"We defined a concrete implementation of `ComponentState<TContractState>` "
"using a type alias with `MockContract::ContractState`, that we named "
"`TestingState`."
msgstr ""
"우리는 `MockContract::ContractState`를 사용하여 `ComponentState<TContractState>`의 "
"구체적인 구현을 정의했고, 이를 `TestingState`라고 이름 지었습니다."

#: src/ch99-01-05-03-testing-components.md:151
msgid ""
"We defined a function that uses `component_state_for_testing` to return a "
"`TestingState` object."
msgstr ""
"`component_state_for_testing`를 사용하여 `TestingState` 객체를 반환하는 함수를 정의했습니다."

#: src/ch99-01-05-03-testing-components.md:153
msgid ""
"We can now write tests for the component by calling its functions directly, "
"without having to deploy a mock contract. This approach is more lightweight "
"than the previous one, and it allows testing internal functions of the "
"component that are not exposed to the outside world trivially."
msgstr ""
"이제 우리는 목 컨트랙트를 배포하지 않고도 컴포넌트의 함수를 직접 호출하여 테스트를 작성할 수 있습니다. 이 접근 방식은 이전 것보다 "
"가벼우며, 외부 세계에 노출되지 않은 컴포넌트의 내부 함수를 쉽게 테스트할 수 있습니다."

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:1
msgid "Starknet contracts: ABIs and cross-contract interactions"
msgstr "Starknet 계약: ABIs 및 계약 간 상호 작용"

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:3
msgid ""
"Interactions between smart contracts are an important feature when creating "
"complex decentralized applications, as it allows for composability and "
"separation of concerns. This chapter sheds light on how to make contracts "
"interact with each other."
msgstr ""
"스마트 계약 간 상호 작용은 복잡한 분산 애플리케이션을 만들 때 중요한 기능이며, 이를 통해 구성 가능성과 관심사의 분리가 가능합니다. "
"이 장은 계약이 서로 상호 작용하는 방법에 대해 밝혀줍니다."

#: src/ch99-02-00-abis-and-cross-contract-interactions.md:5
msgid ""
"Specifically, you'll learn about ABIs, contract interfaces, the contract and"
" library dispatchers and their low-level system call equivalents!"
msgstr ""
"구체적으로는 ABIs, 계약 인터페이스, 계약 및 라이브러리 디스패처 및 그들의 저수준 시스템 호출 동등물에 대해 배우게 됩니다!"

#: src/ch99-02-01-abis-and-interfaces.md:1
msgid "ABIs and Contract Interfaces"
msgstr "ABIs 및 계약 인터페이스"

#: src/ch99-02-01-abis-and-interfaces.md:3
msgid ""
"Cross-contract interactions between smart contracts on a blockchain is a "
"common practice which enables us to build flexible contracts that can speak "
"with each other."
msgstr ""
"블록체인 상의 스마트 계약 간 교차 계약 상호 작용은 서로 대화할 수 있는 유연한 계약을 구축할 수 있도록 하는 일반적인 실천법입니다."

#: src/ch99-02-01-abis-and-interfaces.md:5
msgid "Achieving this on Starknet requires something we call an interface."
msgstr "스타크넷에서 이를 달성하려면 우리가 인터페이스라고 부르는 것이 필요합니다."

#: src/ch99-02-01-abis-and-interfaces.md:7
msgid "ABI - Application Binary Interface"
msgstr "ABI - 응용 프로그램 이진 인터페이스"

#: src/ch99-02-01-abis-and-interfaces.md:9
msgid ""
"On Starknet, the ABI of a contract is a JSON representation of the "
"contract's functions and structures, giving anyone (or any other contract) "
"the ability to form encoded calls to it. It is a blueprint that instructs "
"how functions should be called, what input parameters they expect, and in "
"what format."
msgstr ""
"스타크넷에서 계약의 ABI는 계약의 함수와 구조의 JSON 표현이며, 누구든지 (또는 다른 계약)이 인코딩된 호출을 형성할 수 있는 "
"능력을 제공합니다. 이는 함수가 어떻게 호출되어야 하는지, 어떤 입력 매개변수를 예상하는지, 그리고 어떤 형식으로 하는지를 지시하는 "
"청사진입니다."

#: src/ch99-02-01-abis-and-interfaces.md:11
msgid ""
"While we write our smart contract logics in high-level Cairo, they are "
"stored on the VM as executable bytecodes which are in binary formats. Since "
"this bytecode is not human readable, it requires interpretation to be "
"understood. This is where ABIs come into play, defining specific methods "
"which can be called to a smart contract for execution. Without an ABI, it "
"becomes practically impossible for external actors to understand how to "
"interact with a contract."
msgstr ""
"우리가 스마트 계약 논리를 고수준의 카이로로 작성하는 동안, 이들은 이진 형식의 실행 가능한 바이트 코드로 VM에 저장됩니다. 이 바이트"
" 코드는 사람이 읽을 수 없기 때문에 해석이 필요합니다. 여기서 ABI가 등장하여 실행을 위해 스마트 계약에 호출할 수 있는 특정 "
"메서드를 정의합니다. ABI가 없으면 외부 주체가 계약과 상호 작용하는 방법을 이해하는 것이 사실상 불가능해집니다."

#: src/ch99-02-01-abis-and-interfaces.md:13
msgid ""
"ABIs are typically used in dApps frontends, allowing it to format data "
"correctly, making it understandable by the smart contract and vice versa. "
"When you interact with a smart contract through a block explorer like "
"[Voyager](https://voyager.online/) or [Starkscan](https://starkscan.co/), "
"they use the contract's ABI to format the data you send to the contract and "
"the data it returns."
msgstr ""
"ABIs는 일반적으로 dApps 프론트엔드에서 사용되며, 데이터를 올바르게 형식화하여 스마트 계약이 이해할 수 있도록 하고 그 반대로도 "
"가능하게 합니다. [Voyager](https://voyager.online/)나 "
"[Starkscan](https://starkscan.co/)과 같은 블록 익스플로러를 통해 스마트 계약과 상호 작용할 때, 그들은 "
"계약의 ABI를 사용하여 보내는 데이터와 반환되는 데이터를 형식화합니다."

#: src/ch99-02-01-abis-and-interfaces.md:15
msgid "Interface"
msgstr "인터페이스"

#: src/ch99-02-01-abis-and-interfaces.md:17
msgid ""
"The interface of a contract is a list of the functions it exposes publicly. "
"It specifies the function signatures (name, parameters, visibility and "
"return value) contained in a smart contract without including the function "
"body."
msgstr ""
"계약의 인터페이스는 공개적으로 노출되는 함수 목록입니다. 이는 스마트 계약에 포함된 함수 시그니처(이름, 매개변수, 가시성 및 반환 "
"값)를 함수 본문을 포함하지 않고 명시합니다."

#: src/ch99-02-01-abis-and-interfaces.md:20
msgid ""
"Contract interfaces in Cairo are traits annotated with the "
"`#[starknet::interface]` attribute. If you are new to traits, check out the "
"dedicated chapter on [traits](./ch08-02-traits-in-cairo.md)."
msgstr ""
"카이로의 계약 인터페이스는 `#[starknet::interface]` 속성이 지정된 트레이트입니다. 트레이트에 익숙하지 않은 경우 "
"[traits](./ch08-02-traits-in-cairo.md) 전용 챕터를 확인해보세요."

#: src/ch99-02-01-abis-and-interfaces.md:22
msgid ""
"One important specification is that this trait must be generic over the "
"`TContractState` type. This is required for functions to access the "
"contract's storage, so that they can read and write to it."
msgstr ""
"중요한 사양 중 하나는 이 특성이 `TContractState` 유형에 대해 일반적이어야 한다는 것입니다. 이는 함수가 계약의 저장소에 "
"액세스할 수 있도록 하기 위해 필요하며, 그것을 읽고 쓸 수 있어야 합니다."

#: src/ch99-02-01-abis-and-interfaces.md:24
msgid ""
"Note: The contract constructor is not part of the interface. Nor are "
"internal functions part of the interface."
msgstr "참고: 계약 생성자는 인터페이스의 일부가 아닙니다. 내부 함수도 인터페이스의 일부가 아닙니다."

#: src/ch99-02-01-abis-and-interfaces.md:26
msgid ""
"Here's a sample interface for an ERC20 token contract. As you can see, it's "
"a generic trait over the `TContractState` type. `view` functions have a self"
" parameter of type `@TContractState`, while `external` functions have a self"
" parameter of type passed by reference `ref self: TContractState`."
msgstr ""
"다음은 ERC20 토큰 계약을 위한 샘플 인터페이스입니다. 보시다시피, 이는 `TContractState` 유형에 대한 일반적인 "
"특성입니다. `view` 함수는 `@TContractState` 유형의 self 매개변수를 가지고 있으며, `external` 함수는 "
"참조로 전달된 `ref self: TContractState` 유형의 self 매개변수를 가지고 있습니다."

#: src/ch99-02-01-abis-and-interfaces.md:55
msgid "Listing 99-5: A simple ERC20 Interface"
msgstr "리스팅 99-5: 간단한 ERC20 인터페이스"

#: src/ch99-02-01-abis-and-interfaces.md:57
msgid ""
"In the next chapter, we will see how we can call contracts from other smart "
"contracts using _dispatchers_ and _syscalls_ ."
msgstr "다음 장에서는 _디스패처_ 와 _시스콜_ 을 사용하여 다른 스마트 계약에서 계약을 호출하는 방법을 살펴볼 것입니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:1
msgid ""
"Interacting with other contracts and classes using Dispatchers and syscalls"
msgstr "디스패처와 시스콜을 사용하여 다른 계약 및 클래스와 상호 작용하기"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:3
msgid ""
"Each time a contract interface is defined, two dispatchers are automatically"
" created and exported by the compiler. Let's consider an interface that we "
"named IERC20, these would be:"
msgstr ""
"계약 인터페이스가 정의될 때마다 컴파일러에 의해 자동으로 두 개의 디스패처가 생성되고 내보내집니다. 우리가 IERC20이라고 이름 지은 "
"인터페이스를 고려해 봅시다. 이들은 다음과 같을 것입니다:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:5
msgid "The Contract Dispatcher `IERC20Dispatcher`"
msgstr "계약 디스패처 `IERC20Dispatcher`"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:6
msgid "The Library Dispatcher `IERC20LibraryDispatcher`"
msgstr "라이브러리 디스패처 `IERC20LibraryDispatcher`"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:8
msgid ""
"The compiler also generates a trait `IERC20DispatcherTrait`, allowing us to "
"call the functions defined in the interface on the dispatcher struct."
msgstr ""
"컴파일러는 또한 `IERC20DispatcherTrait` 특성을 생성하여 디스패처 구조체에서 인터페이스에 정의된 함수를 호출할 수 "
"있도록 합니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:10
msgid ""
"In this chapter, we are going to discuss what these are, how they work and "
"how to use them."
msgstr "이 장에서는 이들이 무엇인지, 어떻게 작동하는지, 그리고 어떻게 사용하는지에 대해 논의할 것입니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:12
msgid ""
"To effectively break down the concepts in this chapter, we are going to be "
"using the IERC20 interface from the previous chapter (refer to Listing "
"99-5)."
msgstr ""
"이 장의 개념을 효과적으로 이해하기 위해, 이전 장에서 사용한 IERC20 인터페이스를 사용할 것입니다 (Listing 99-5를 "
"참조하십시오)."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:14
msgid "Contract Dispatcher"
msgstr "계약 디스패처"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:16
msgid ""
"As mentioned previously, traits annotated with the `#[starknet::interface]` "
"attribute automatically generate a dispatcher and a trait on compilation. "
"Our `IERC20` interface is expanded into something like this:"
msgstr ""
"이전에 언급했듯이, `#[starknet::interface]` 속성으로 주석이 달린 특성은 컴파일 시 자동으로 디스패처와 특성을 "
"생성합니다. 우리의 `IERC20` 인터페이스는 다음과 같이 확장됩니다:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:19
msgid ""
"**Note:** The expanded code for our IERC20 interface is a lot longer, but to"
" keep this chapter concise and straight to the point, we focused on one view"
" function `name`, and one external function `transfer`."
msgstr ""
"**참고:** 저희 IERC20 인터페이스의 확장된 코드는 훨씬 더 길지만, 이 장을 간결하고 명료하게 유지하기 위해 한 개의 뷰 함수 "
"`name`과 한 개의 외부 함수 `transfer`에 집중했습니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:37
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:41
msgid "// starknet::call_contract_syscall is called in here\n"
msgstr "// starknet::call_contract_syscall이 여기에서 호출됩니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:46
msgid "Listing 99-6: An expanded form of the IERC20 trait"
msgstr "리스팅 99-6: IERC20 특성의 확장된 형태"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:48
msgid ""
"As you can see, the \"classic\" dispatcher is just a struct that wraps a "
"contract address and implements the `DispatcherTrait` generated by the "
"compiler, allowing us to call functions from another contract. This means "
"that we can instantiate a struct with the address of the contract we want to"
" call, and then simply call the functions defined in the interface on the "
"dispatcher struct as if they were methods of that type."
msgstr ""
"보시다시피, \"클래식\" 디스패처는 컨트랙트 주소를 감싸고 컴파일러에 의해 생성된 `DispatcherTrait`를 구현하는 구조체일 "
"뿐입니다. 이를 통해 다른 컨트랙트의 함수를 호출할 수 있게 됩니다. 이는 우리가 호출하고자 하는 컨트랙트의 주소로 구조체를 "
"인스턴스화하고, 그런 다음 디스패처 구조체에서 정의된 인터페이스의 함수를 호출할 수 있다는 것을 의미합니다. 마치 해당 유형의 메서드인 "
"것처럼요."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:50
msgid ""
"It's also worthy of note that all these are abstracted behind the scenes "
"thanks to the power of Cairo plugins."
msgstr "모든 이러한 것들이 카이로 플러그인의 힘으로 뒷면에 추상화되어 있는 점도 주목할 만하다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:52
msgid "Calling Contracts using the Contract Dispatcher"
msgstr "계약 디스패처를 사용하여 계약 호출하기"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:54
msgid ""
"This is an example of a contract named `TokenWrapper` using a dispatcher to "
"call functions defined on an ERC-20 token. Calling `transfer_token` will "
"modify the state of the contract deployed at `contract_address`."
msgstr ""
"이것은 ERC-20 토큰에서 정의된 함수를 호출하기 위해 디스패처를 사용하는 `TokenWrapper`라는 계약의 예입니다. "
"`transfer_token`을 호출하면 `contract_address`에 배포된 계약의 상태가 변경됩니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:94
msgid "//**** Specify interface here ****//\n"
msgstr "//**** 여기에 인터페이스 지정 ****//"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:125
msgid "Listing 99-7: A sample contract which uses the Contract Dispatcher"
msgstr "리스팅 99-7: Contract Dispatcher를 사용하는 샘플 계약서"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:127
msgid ""
"As you can see, we had to first import `IERC20DispatcherTrait` and "
"`IERC20Dispatcher` generated by the compiler, which allows us to make calls "
"to the methods implemented for the `IERC20Dispatcher` struct (`name`, "
"`transfer`, etc), passing in the `contract_address` of the contract we want "
"to call in the `IERC20Dispatcher` struct."
msgstr ""
"위에서 볼 수 있듯이, 먼저 컴파일러에 의해 생성된 `IERC20DispatcherTrait` 및 `IERC20Dispatcher`를 "
"가져와야 했습니다. 이를 통해 `IERC20Dispatcher` 구조체에 구현된 메서드를 호출할 수 있게 되며 (`name`, "
"`transfer` 등), `IERC20Dispatcher` 구조체에서 호출하려는 계약의 `contract_address`를 전달할 수 "
"있습니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:129
msgid "Library Dispatcher"
msgstr "도서관 디스패처"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:131
msgid ""
"The key difference between the contract dispatcher and the library "
"dispatcher lies in the execution context of the logic defined in the class. "
"While regular dispatchers are used to call functions from **contracts** "
"(with an associated state), library dispatchers are used to call **classes**"
" (stateless)."
msgstr ""
"계약 디스패처와 라이브러리 디스패처 사이의 주요 차이점은 클래스에 정의된 로직의 실행 컨텍스트에 있습니다. 일반 디스패처는 "
"**계약**(관련 상태가 있는)에서 함수를 호출하는 데 사용되는 반면, 라이브러리 디스패처는 **클래스**(상태가 없는)를 호출하는 데 "
"사용됩니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:133
msgid "Let's consider two contracts A and B."
msgstr "A와 B 두 계약을 고려해 봅시다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:135
msgid ""
"When A uses `IBDispatcher` to call functions from the **contract** B, the "
"execution context of the logic defined in B is that of B. This means that "
"the value returned by `get_caller_address()` in B will return the address of"
" A, and updating a storage variable in B will update the storage of B."
msgstr ""
"A가 `IBDispatcher`를 사용하여 **contract** B에서 함수를 호출할 때, B에서 정의된 로직의 실행 컨텍스트는 B의 "
"것입니다. 이는 B의 `get_caller_address()`에서 반환된 값이 A의 주소를 반환하고, B의 스토리지 변수를 업데이트하면 "
"B의 스토리지가 업데이트된다는 것을 의미합니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:137
msgid ""
"When A uses `IBLibraryDispatcher` to call functions from the **class** of B,"
" the execution context of the logic defined in B's class is that of A. This "
"means that the value returned by `get_caller_address()` variable in B will "
"return the address of the caller of A, and updating a storage variable in "
"B's class will update the storage of A (remember that the **class** of B is "
"stateless; there is no state that can be updated!)"
msgstr ""
"A가 B의 **class**에서 함수를 호출하기 위해 `IBLibraryDispatcher`를 사용할 때, B의 클래스에 정의된 로직의 "
"실행 컨텍스트는 A의 것입니다. 이는 B의 `get_caller_address()` 변수가 A의 호출자의 주소를 반환하고, B의 클래스의"
" 저장 변수를 업데이트하면 A의 저장소가 업데이트된다는 것을 의미합니다 (B의 **class**가 상태를 가지지 않는다는 것을 "
"기억하세요; 업데이트할 수 있는 상태가 없습니다!)"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:139
msgid ""
"The expanded form of the struct and trait generated by the compiler look "
"like:"
msgstr "컴파일러에 의해 생성된 구조체와 트레이트의 확장된 형태는 다음과 같이 보입니다:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:157
#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:161
msgid "// starknet::syscalls::library_call_syscall  is called in here\n"
msgstr "여기에서 starknet::syscalls::library_call_syscall가 호출됩니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:166
msgid ""
"Notice that the main difference between the regular contract dispatcher and "
"the library dispatcher is that the former uses `call_contract_syscall` while"
" the latter uses `library_call_syscall`."
msgstr ""
"정규 계약 디스패처와 라이브러리 디스패처 사이의 주요 차이점은 전자가 `call_contract_syscall`을 사용하는 반면 후자는 "
"`library_call_syscall`을 사용한다는 것에 있습니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:168
msgid "Listing 99-8: An expanded form of the IERC20 trait"
msgstr "리스팅 99-8: IERC20 트레이트의 확장된 형태"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:170
msgid "Calling Contracts using the Library Dispatcher"
msgstr "라이브러리 디스패처를 사용하여 계약 호출하기"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:172
msgid ""
"Below's a sample code for calling contracts using the Library Dispatcher."
msgstr "라이브러리 디스패처를 사용하여 계약을 호출하는 샘플 코드가 아래에 있습니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:207
msgid "Listing 99-9: A sample contract using the Library Dispatcher"
msgstr "99-9 목록: Library Dispatcher를 사용한 샘플 계약"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:209
msgid ""
"As you can see, we had to first import in our contract the "
"`IContractADispatcherTrait` and `IContractALibraryDispatcher` which were "
"generated from our interface by the compiler. Then, we can create an "
"instance of `IContractALibraryDispatcher` passing in the `class_hash` of the"
" class we want to make library calls to. From there, we can call the "
"functions defined in that class, executing its logic in the context of our "
"contract. When we call `set_value` on ContractA, it will make a library call"
" to the `set_value` function in IContractA, updating the value of the "
"storage variable `value` in ContractA."
msgstr ""
"보시다시피, 우리는 컴파일러에 의해 인터페이스에서 생성된 `IContractADispatcherTrait` 및 "
"`IContractALibraryDispatcher`를 먼저 계약에 가져와야 했습니다. 그런 다음, 우리는 "
"`IContractALibraryDispatcher`의 인스턴스를 만들 수 있고, 호출하려는 클래스의 `class_hash`를 전달할 수"
" 있습니다. 그런 다음, 해당 클래스에서 정의된 함수를 호출하여 우리 계약의 컨텍스트에서 해당 로직을 실행할 수 있습니다. "
"ContractA에서 `set_value`를 호출하면, IContractA의 `set_value` 함수에 라이브러리 호출을 수행하여 "
"ContractA의 저장 변수 `value`의 값을 업데이트합니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:211
msgid "Using low-level syscalls"
msgstr "낮은 수준의 시스템 호출을 사용하기"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:213
msgid ""
"Another way to call other contracts and classes is to use the "
"`starknet::call_contract_syscall`and `starknet::library_call_syscall` system"
" calls. The dispatchers we described in the previous sections are high-level"
" syntaxes for these low-level system calls."
msgstr ""
"다른 계약 및 클래스를 호출하는 또 다른 방법은 `starknet::call_contract_syscall` 및 "
"`starknet::library_call_syscall` 시스템 호출을 사용하는 것입니다. 이전 섹션에서 설명한 디스패처들은 이러한 "
"저수준 시스템 호출을 위한 고수준 구문입니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:215
msgid ""
"Using these syscalls can be handy for customized error handling or to get "
"more control over the serialization/deserialization of the call data and the"
" returned data. Here's an example demonstrating how to use a "
"`call_contract_sycall` to call the `transfer` function of an ERC20 contract:"
msgstr ""
"이 syscalls를 사용하면 사용자 지정 오류 처리에 유용하거나 호출 데이터 및 반환된 데이터의 직렬화/역직렬화에 대한 더 많은 제어를"
" 얻을 수 있습니다. ERC20 계약의 `transfer` 함수를 호출하기 위해 `call_contract_sycall`을 사용하는 "
"방법을 보여주는 예제가 여기 있습니다:"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:253
msgid "\"transferFrom\""
msgstr ""

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:263
msgid "Listing 99-10: A sample contract using syscalls"
msgstr "리스팅 99-10: 시스템 호출을 사용한 샘플 계약"

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:265
msgid ""
"To use this syscall, we passed in the contract address, the selector of the "
"function we want to call, and the call arguments."
msgstr "이 시스템 호출을 사용하려면, 우리는 호출하려는 함수의 셀렉터와 호출 인수를 전달했습니다."

#: src/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md:267
msgid ""
"The call arguments must be provided as an array of `felt252`. To build this "
"array, we serialize the expected function parameters into an "
"`Array<felt252>` using the `Serde` trait, and then pass this array as "
"calldata. At the end, we are returned a serialized value which we'll need to"
" deserialize ourselves!"
msgstr ""
"호출 인수는 `felt252` 배열로 제공되어야 합니다. 이 배열을 구성하기 위해, 우리는 예상되는 함수 매개변수를 `Serde` 특성을"
" 사용하여 `Array<felt252>`로 직렬화하고, 이 배열을 calldata로 전달합니다. 마지막으로, 우리는 직렬화된 값을 "
"반환받게 되는데, 이를 직접 역직렬화해야 합니다!"

#: src/ch99-01-04-00-other-examples.md:3
msgid ""
"This section contains additional examples of Starknet smart contracts, "
"utilizing various features of the Cairo programming language. Your "
"contributions are welcome and encouraged, as we aim to gather as many "
"diverse examples as possible."
msgstr ""
"이 섹션에는 카이로 프로그래밍 언어의 다양한 기능을 활용한 Starknet 스마트 계약의 추가 예제가 포함되어 있습니다. 가능한 다양한 "
"예제를 수집하기 위해 여러분의 기여를 환영하며 장려합니다."

#: src/ch99-01-04-01-voting-contract.md:3
msgid ""
"The **`Vote`** contract in Starknet begins by registering voters through the"
" contract's constructor. Three voters are initialized at this stage, and "
"their addresses are passed to an internal function **`_register_voters`**. "
"This function adds the voters to the contract's state, marking them as "
"registered and eligible to vote."
msgstr ""
"Starknet의 **`Vote`** 계약은 계약의 생성자를 통해 유권자를 등록함으로써 시작됩니다. 이 단계에서 세 명의 유권자가 "
"초기화되고, 그들의 주소가 내부 함수 **`_register_voters`**에 전달됩니다. 이 함수는 유권자를 계약의 상태에 추가하여 "
"등록되었고 투표할 자격이 있는 것으로 표시합니다."

#: src/ch99-01-04-01-voting-contract.md:5
msgid ""
"Within the contract, the constants **`YES`** and **`NO`** are defined to "
"represent the voting options (1 and 0, respectively). These constants "
"facilitate the voting process by standardizing the input values."
msgstr ""
"계약서 내에서 상수 **`YES`**와 **`NO`**는 투표 옵션을 나타내기 위해 정의되었으며 (각각 1과 0), 이러한 상수는 입력 "
"값을 표준화하여 투표 과정을 용이하게 합니다."

#: src/ch99-01-04-01-voting-contract.md:7
msgid ""
"Once registered, a voter is able to cast a vote using the **`vote`** "
"function, selecting either the 1 (YES) or 0 (NO) as their vote. When voting,"
" the state of the contract is updated, recording the vote and marking the "
"voter as having voted. This ensures that the voter is not able to cast a "
"vote again within the same proposal. The casting of a vote triggers the "
"**`VoteCast`** event, logging the action."
msgstr ""
"한 번 등록되면 유권자는 **`vote`** 함수를 사용하여 투표할 수 있으며, 투표로 1 (YES) 또는 0 (NO) 중 하나를 "
"선택합니다. 투표 시 계약의 상태가 업데이트되어 투표가 기록되고, 유권자가 투표했음을 표시합니다. 이로써 유권자는 동일 제안서 내에서 "
"다시 투표할 수 없게 됩니다. 투표가 발생하면 **`VoteCast`** 이벤트가 트리거되어 해당 작업이 로깅됩니다."

#: src/ch99-01-04-01-voting-contract.md:9
msgid ""
"The contract also monitors unauthorized voting attempts. If an unauthorized "
"action is detected, such as a non-registered user attempting to vote or a "
"user trying to vote again, the **`UnauthorizedAttempt`** event is emitted."
msgstr ""
"계약은 무당위 투표 시도도 모니터링합니다. 무당위 행동이 감지되면, 예를 들어 등록되지 않은 사용자가 투표를 시도하거나 사용자가 다시 "
"투표하려고 하는 경우 **`UnauthorizedAttempt`** 이벤트가 발생됩니다."

#: src/ch99-01-04-01-voting-contract.md:11
msgid ""
"Together, these functions, states, constants, and events create a structured"
" voting system, managing the lifecycle of a vote from registration to "
"casting, event logging, and result retrieval within the Starknet "
"environment. Constants like **`YES`** and **`NO`** help streamline the "
"voting process, while events play a vital role in ensuring transparency and "
"traceability."
msgstr ""
"이러한 기능, 상태, 상수 및 이벤트는 Starknet 환경 내에서 투표 수명주기를 관리하는 구조화된 투표 시스템을 만듭니다. 등록부터 "
"투표, 이벤트 기록 및 결과 검색까지를 처리합니다. **`YES`**와 **`NO`**와 같은 상수는 투표 과정을 간소화하는 데 도움이 "
"되고, 이벤트는 투명성과 추적 가능성을 보장하는 데 중요한 역할을 합니다."

#: src/ch99-01-04-01-voting-contract.md:14
msgid ""
"/// @dev Core Library Imports for the Traits outside the Starknet Contract\n"
msgstr "/// @dev Starknet 계약 외부의 Traits를 위한 Core 라이브러리 Imports"

#: src/ch99-01-04-01-voting-contract.md:16
msgid ""
"/// @dev Trait defining the functions that can be implemented or called by "
"the Starknet Contract\n"
msgstr "/// @dev Starknet Contract에서 구현하거나 호출할 수 있는 함수를 정의하는 특성"

#: src/ch99-01-04-01-voting-contract.md:20
msgid "/// @dev Function that returns the current vote status\n"
msgstr "/// @dev 현재 투표 상태를 반환하는 함수"

#: src/ch99-01-04-01-voting-contract.md:22
msgid ""
"/// @dev Function that checks if the user at the specified address is "
"allowed to vote\n"
msgstr "/// @dev 지정된 주소의 사용자가 투표할 수 있는지 확인하는 함수"

#: src/ch99-01-04-01-voting-contract.md:24
msgid ""
"/// @dev Function that checks if the specified address is registered as a "
"voter\n"
msgstr "/// @dev 지정된 주소가 유권자로 등록되어 있는지 확인하는 함수"

#: src/ch99-01-04-01-voting-contract.md:26
msgid "/// @dev Function that allows a user to vote\n"
msgstr "사용자가 투표할 수 있는 기능입니다."

#: src/ch99-01-04-01-voting-contract.md:29
msgid ""
"/// @dev Starknet Contract allowing three registered voters to vote on a "
"proposal\n"
msgstr "/// @dev 세 명의 등록된 투표자가 제안에 투표할 수 있는 Starknet 계약"

#: src/ch99-01-04-01-voting-contract.md:39
msgid "/// @dev Structure that stores vote counts and voter states\n"
msgstr "/// @dev 투표 수 및 유권자 상태를 저장하는 구조체"

#: src/ch99-01-04-01-voting-contract.md:48
msgid ""
"/// @dev Contract constructor initializing the contract with a list of "
"registered voters and 0 vote count\n"
msgstr "/// @dev 계약 생성자는 등록된 유권자 목록과 0 투표 수로 계약을 초기화합니다."

#: src/ch99-01-04-01-voting-contract.md:56
msgid "// Register all voters by calling the _register_voters function\n"
msgstr "// _register_voters 함수를 호출하여 모든 유권자를 등록합니다."

#: src/ch99-01-04-01-voting-contract.md:59
msgid "// Initialize the vote count to 0\n"
msgstr "투표 수를 0으로 초기화합니다."

#: src/ch99-01-04-01-voting-contract.md:64
msgid "/// @dev Event that gets emitted when a vote is cast\n"
msgstr "/// @dev 투표가 제출될 때 발생하는 이벤트"

#: src/ch99-01-04-01-voting-contract.md:72
msgid "/// @dev Represents a vote that was cast\n"
msgstr "/// @dev 투표를 나타냅니다"

#: src/ch99-01-04-01-voting-contract.md:79
msgid "/// @dev Represents an unauthorized attempt to vote\n"
msgstr "/// @dev 투표를 시도한 권한이 없음을 나타냅니다."

#: src/ch99-01-04-01-voting-contract.md:85
msgid "/// @dev Implementation of VoteTrait for ContractState\n"
msgstr "/// @dev ContractState에 대한 VoteTrait 구현"

#: src/ch99-01-04-01-voting-contract.md:88
msgid "/// @dev Returns the voting results\n"
msgstr "/// @dev 투표 결과를 반환합니다"

#: src/ch99-01-04-01-voting-contract.md:95
msgid "/// @dev Check whether a voter is allowed to vote\n"
msgstr "/// @dev 투표자가 투표할 수 있는지 확인합니다."

#: src/ch99-01-04-01-voting-contract.md:100
msgid "/// @dev Check whether an address is registered as a voter\n"
msgstr "/// @dev 주소가 유권자로 등록되어 있는지 확인합니다."

#: src/ch99-01-04-01-voting-contract.md:105
msgid "/// @dev Submit a vote\n"
msgstr "/// @dev 투표 제출"

#: src/ch99-01-04-01-voting-contract.md:107
msgid "\"VOTE_0_OR_1\""
msgstr "\"투표_0_또는_1\""

#: src/ch99-01-04-01-voting-contract.md:123
msgid "/// @dev Internal Functions implementation for the Vote contract\n"
msgstr "/// @dev 투표 계약을 위한 내부 함수 구현"

#: src/ch99-01-04-01-voting-contract.md:126
msgid ""
"/// @dev Registers the voters and initializes their voting status to true "
"(can vote)\n"
msgstr "/// @dev 유권자를 등록하고 투표 상태를 true(투표 가능)로 초기화합니다."

#: src/ch99-01-04-01-voting-contract.md:144
msgid "/// @dev Asserts implementation for the Vote contract\n"
msgstr "/// @dev 투표 계약에 대한 구현을 단언합니다"

#: src/ch99-01-04-01-voting-contract.md:147
msgid "// @dev Internal function that checks if an address is allowed to vote\n"
msgstr "// @dev 투표를 허용하는지 확인하는 내부 함수"

#: src/ch99-01-04-01-voting-contract.md:156
msgid "\"USER_NOT_REGISTERED\""
msgstr "\"사용자가 등록되지 않았습니다\""

#: src/ch99-01-04-01-voting-contract.md:157
#: src/ch99-01-04-01-voting-contract.md:427
msgid "\"USER_ALREADY_VOTED\""
msgstr "\"사용자가 이미 투표했습니다\""

#: src/ch99-01-04-01-voting-contract.md:161
msgid "/// @dev Implement the VotingResultTrait for the Vote contract\n"
msgstr "/// @dev 투표 계약에 대한 VotingResultTrait를 구현합니다."

#: src/ch99-01-04-01-voting-contract.md:164
msgid ""
"// @dev Internal function to get the voting results (yes and no vote "
"counts)\n"
msgstr "// @dev 투표 결과(찬성 및 반대 투표 수)를 가져오는 내부 함수"

#: src/ch99-01-04-01-voting-contract.md:172
msgid ""
"// @dev Internal function to calculate the voting results in percentage\n"
msgstr "// @dev 투표 결과를 백분율로 계산하는 내부 함수"

#: src/ch99-01-04-01-voting-contract.md:191
msgid "Voting smart contract"
msgstr "투표 스마트 계약"

#: src/ch99-01-04-01-voting-contract.md:193
msgid "Deploying, calling and invoking the Voting Contract"
msgstr "투표 계약을 배포하고 호출하며 실행하기"

#: src/ch99-01-04-01-voting-contract.md:195
msgid ""
"Part of the Starknet experience is deploying and interacting with smart "
"contracts."
msgstr "스타크넷 경험의 일부는 스마트 계약을 배포하고 상호 작용하는 것입니다."

#: src/ch99-01-04-01-voting-contract.md:197
msgid ""
"Once the contract is deployed, we can interact with it by calling and "
"invoking its functions:"
msgstr "계약이 배포되면 함수를 호출하고 활용하여 상호 작용할 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:199
msgid ""
"Calling contracts: Interacting with external functions that only read from "
"the state. These functions do not alter the state of the network, so they "
"don't require fees or signing."
msgstr ""
"콜링 계약: 상태를 읽기만 하는 외부 함수와 상호 작용합니다. 이러한 함수들은 네트워크의 상태를 변경하지 않으므로 수수료나 서명이 "
"필요하지 않습니다."

#: src/ch99-01-04-01-voting-contract.md:200
msgid ""
"Invoking contracts: Interacting with external functions that can write to "
"the state. These functions do alter the state of the network and require "
"fees and signing."
msgstr ""
"계약 호출: 상태를 쓸 수 있는 외부 함수와 상호 작용합니다. 이러한 함수는 네트워크의 상태를 변경하며 수수료와 서명이 필요합니다."

#: src/ch99-01-04-01-voting-contract.md:202
msgid ""
"We will setup a local development node using `katana` to deploy the voting "
"contract. Then, we'll interact with the contract by calling and invoking its"
" functions. You can also use the Goerli Testnet instead of `katana`. "
"However, we recommend using `katana` for local development and testing. You "
"can find the complete tutorial for `katana` in the [Katana: A Local "
"Node](https://book.starknet.io/ch02-04-katana.html) chapter of the Starknet "
"Book."
msgstr ""
"우리는 투표 계약을 배포하기 위해 `katana`를 사용하여 로컬 개발 노드를 설정할 것입니다. 그런 다음, 계약과 상호 작용하기 위해 "
"함수를 호출하고 활성화할 것입니다. `katana` 대신 Goerli Testnet을 사용할 수도 있습니다. 그러나 로컬 개발 및 "
"테스트에는 `katana`를 사용하는 것을 권장합니다. `katana`에 대한 완전한 튜토리얼은 Starknet Book의 "
"[Katana: A Local Node](https://book.starknet.io/ch02-04-katana.html) 장에서 찾을 "
"수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:204
msgid "The `katana` local Starknet node"
msgstr "`katana` 로컬 Starknet 노드"

#: src/ch99-01-04-01-voting-contract.md:206
msgid ""
"`katana` is designed to support local development by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)."
" It will allow you to do everything you need to do with Starknet, but "
"locally. It is a great tool for development and testing."
msgstr ""
"`katana`는 [Dojo "
"팀](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)이 "
"지원하는 로컬 개발을 지원하기 위해 설계되었습니다. Starknet으로 할 수 있는 모든 작업을 로컬에서 수행할 수 있게 해줍니다. 개발"
" 및 테스트에 좋은 도구입니다."

#: src/ch99-01-04-01-voting-contract.md:208
msgid ""
"To install `katana` from the source code, please refer to the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"`katana`를 소스 코드에서 설치하려면 Starknet Book의 [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) 장을 참조하십시오."

#: src/ch99-01-04-01-voting-contract.md:210
msgid ""
"Note: Please verify that the version of `katana` match the specified version"
" provided below."
msgstr "참고: `katana`의 버전이 아래 제공된 지정 버전과 일치하는지 확인해주세요."

#: src/ch99-01-04-01-voting-contract.md:215
msgid ""
"To upgrade `katana`, refer to the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) chapter of the Starknet Book."
msgstr ""
"`katana`를 업그레이드하려면 Starknet Book의 [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-"
"installation.html#katana-node-installation) 장을 참조하십시오."

#: src/ch99-01-04-01-voting-contract.md:218
msgid ""
"Once you have `katana` installed, you can start the local Starknet node "
"with:"
msgstr "`katana`를 설치한 후에는 다음과 같이 로컬 Starknet 노드를 시작할 수 있습니다:"

#: src/ch99-01-04-01-voting-contract.md:224
msgid ""
"This command will start a local Starknet node with 3 deployed accounts. We "
"will use these accounts to deploy and interact with the voting contract:"
msgstr ""
"이 명령은 3개의 배포된 계정이 있는 로컬 Starknet 노드를 시작합니다. 이러한 계정을 사용하여 투표 계약을 배포하고 상호 작용할 "
"것입니다."

#: src/ch99-01-04-01-voting-contract.md:229
msgid "================="
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:245
msgid ""
"Before we can interact with the voting contract, we need to prepare the "
"voter and admin accounts on Starknet. Each voter account must be registered "
"and sufficiently funded for voting. For a more detailed understanding of how"
" accounts operate with Account Abstraction, refer to the [Account "
"Abstraction](https://book.starknet.io/ch04-00-account-abstraction.html) "
"chapter of the Starknet Book."
msgstr ""
"투표 계약과 상호 작용하기 전에, Starknet에서 투표자 및 관리자 계정을 준비해야 합니다. 각 투표자 계정은 등록되어 있고 투표를 "
"위해 충분히 자금이 지원되어 있어야 합니다. 계정 추상화와 관련된 계정 작동 방식에 대해 자세히 알고 싶다면, Starknet Book의"
" [Account Abstraction](https://book.starknet.io/ch04-00-account-"
"abstraction.html) 장을 참조하십시오."

#: src/ch99-01-04-01-voting-contract.md:247
msgid "Smart wallets for voting"
msgstr "투표용 스마트 지갑"

#: src/ch99-01-04-01-voting-contract.md:249
msgid ""
"Aside from Scarb you will need to have Starkli installed. Starkli is a "
"command line tool that allows you to interact with Starknet. You can find "
"the installation instructions in the [Basic "
"Installation](https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) chapter of the Starknet Book."
msgstr ""
"Scarb 외에도 Starkli를 설치해야 합니다. Starkli는 스타크넷과 상호 작용할 수 있는 명령 줄 도구입니다. Starkli 설치 지침은 스타크넷"
" 북의 [기본 설치](https://book.starknet.io/ch02-01-basic-"
"installation.html#starkli-installation) 장에서 찾을 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:251
msgid ""
"Note: Please verify that the version of `starkli` match the specified "
"version provided below."
msgstr "참고: `starkli`의 버전이 아래 제공된 지정된 버전과 일치하는지 확인해주세요."

#: src/ch99-01-04-01-voting-contract.md:256
msgid ""
"To upgrade `starkli` to `1.0.20`, use the `starkliup -v 0.1.20` command."
msgstr "`starkli`를 `1.0.20`으로 업그레이드하려면 `starkliup -v 0.1.20` 명령을 사용하십시오."

#: src/ch99-01-04-01-voting-contract.md:258
msgid ""
"For each smart wallet we'll use, we must create a Signer within the "
"encrypted keystore and an Account Descriptor. This process is also detailed "
"in the [Testnet Deployment](https://book.starknet.io/ch02-05-testnet-"
"deployment.html?highlight=signer#creating-a-signer) chapter of the Starknet "
"Book."
msgstr ""
"각 스마트 지갑을 사용할 때, 우리는 암호화된 키스토어 내에서 서명자와 계정 기술자를 생성해야 합니다. 이 과정은 Starknet "
"Book의 [테스트넷 배포](https://book.starknet.io/ch02-05-testnet-"
"deployment.html?highlight=signer#creating-a-signer) 장에서도 자세히 설명되어 있습니다."

#: src/ch99-01-04-01-voting-contract.md:260
msgid ""
"We can create Signers and Account Descriptors for the accounts we want to "
"use for voting. Let's create a smart wallet for voting in our smart "
"contract."
msgstr ""
"우리는 투표에 사용할 계정에 대한 서명자와 계정 설명자를 생성할 수 있습니다. 스마트 계약에서 투표를 위한 스마트 지갑을 만들어 봅시다."

#: src/ch99-01-04-01-voting-contract.md:262
msgid "Firstly, we create a signer from a private key:"
msgstr "먼저, 우리는 개인 키에서 서명자를 생성합니다."

#: src/ch99-01-04-01-voting-contract.md:268
msgid ""
"Then, we create the Account Descriptor by fetching the katana account we "
"want to use:"
msgstr "그런 다음, 우리는 사용하고 싶은 katana 계정을 가져와서 계정 기술자(Account Descriptor)를 생성합니다."

#: src/ch99-01-04-01-voting-contract.md:274
msgid ""
"This command will create a new `account0_account.json` file containing the "
"following details:"
msgstr "이 명령은 다음 세부 정보가 포함된 새 `account0_account.json` 파일을 생성합니다."

#: src/ch99-01-04-01-voting-contract.md:278
#: src/ch99-01-04-01-voting-contract.md:281
#: src/ch99-01-04-01-voting-contract.md:388
msgid "\"version\""
msgstr "버전"

#: src/ch99-01-04-01-voting-contract.md:279
msgid "\"variant\""
msgstr "\"변형\""

#: src/ch99-01-04-01-voting-contract.md:280
#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"type\""
msgstr "유형"

#: src/ch99-01-04-01-voting-contract.md:280
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"public_key\""
msgstr "\"공개 키\""

#: src/ch99-01-04-01-voting-contract.md:282
msgid "\"<SMART_WALLET_PUBLIC_KEY>\""
msgstr "\"<SMART_WALLET_PUBLIC_KEY>\""

#: src/ch99-01-04-01-voting-contract.md:284
msgid "\"deployment\""
msgstr "배치"

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"status\""
msgstr "\"상태\""

#: src/ch99-01-04-01-voting-contract.md:285
msgid "\"deployed\""
msgstr "\"배치된\""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"class_hash\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:286
msgid "\"<SMART_WALLET_CLASS_HASH>\""
msgstr "\"<SMART_WALLET_CLASS_HASH>\""

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"address\""
msgstr "주소"

#: src/ch99-01-04-01-voting-contract.md:287
msgid "\"<SMART_WALLET_ADDRESS>\""
msgstr "\"<SMART_WALLET_ADDRESS>\" "

#: src/ch99-01-04-01-voting-contract.md:292
msgid ""
"You can retrieve the smart wallet class hash (it will be the same for all "
"your smart wallets) with the following command. Notice the use of the "
"`--rpc` flag and the RPC endpoint provided by `katana`:"
msgstr ""
"다음 명령을 사용하여 스마트 지갑 클래스 해시를 검색할 수 있습니다. `--rpc` 플래그와 `katana`에서 제공하는 RPC 엔드포인트 사용에 주의하십시오."

#: src/ch99-01-04-01-voting-contract.md:294
msgid ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```\n"
"starkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n"
"``` \n"
"\n"
"-> \n"
"\n"
"```\n"
"starkli class-hash-at <스마트_지갑_주소> --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:298
msgid ""
"For the public key, you can use the `starkli signer keystore inspect` "
"command with the directory of the keystore json file:"
msgstr ""
"공개 키를 얻으려면 `starkli signer keystore inspect` 명령을 사용하여 키스토어 JSON 파일이 있는 디렉토리를"
" 지정할 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:304
msgid ""
"This process is identical for `account_1` and `account_2` in case you want "
"to have a second and a third voter."
msgstr "이 프로세스는 두 번째와 세 번째 투표자를 원하는 경우 `account_1` 및 `account_2`에 대해 동일합니다."

#: src/ch99-01-04-01-voting-contract.md:306
msgid "Contract Deployment"
msgstr "계약 배포"

#: src/ch99-01-04-01-voting-contract.md:308
msgid ""
"Before deploying, we need to declare the contract. We can do this with the "
"`starkli declare` command:"
msgstr "배포하기 전에 계약을 선언해야 합니다. 이를 `starkli declare` 명령어로 할 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:314
msgid ""
"If the compiler version you're using is older than the one used by Starkli "
"and you encounter a `compiler-version` error while using the command above, "
"you can specify a compiler version to use in the command by adding the "
"`--compiler-version x.y.z` flag."
msgstr ""
"만약 사용 중인 컴파일러 버전이 Starkli에서 사용한 것보다 오래된 경우이고 위 명령을 사용하는 동안 `compiler-"
"version` 오류가 발생하면, `--compiler-version x.y.z` 플래그를 추가하여 명령에서 사용할 컴파일러 버전을 "
"지정할 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:316
msgid ""
"If you're still encountering issues with the compiler version, try upgrading"
" Starkli using the command: `starkliup` to make sure you're using the latest"
" version of starkli."
msgstr ""
"컴파일러 버전에 문제가 계속 발생한다면, 최신 starkli 버전을 사용하도록 Starkli를 업그레이드하려면 다음 명령을 사용해보세요:"
" `starkliup`."

#: src/ch99-01-04-01-voting-contract.md:318
msgid ""
"The class hash of the contract is: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. You "
"can find it [on any block "
"explorer](https://goerli.voyager.online/class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."
msgstr ""
"계약의 클래스 해시는 다음과 같습니다: "
"`0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52`. 이 링크에서"
" 확인할 수 있습니다: [on any block "
"explorer](https://goerli.voyager.online/class/0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52)."

#: src/ch99-01-04-01-voting-contract.md:320
msgid ""
"The `--rpc` flag specifies the RPC endpoint to use (the one provided by "
"`katana`). The `--account` flag specifies the account to use for signing the"
" transaction. The account we use here is the one we created in the previous "
"step. The `--keystore` flag specifies the keystore file to use for signing "
"the transaction."
msgstr ""
"`--rpc` 플래그는 사용할 RPC 엔드포인트를 지정합니다(`katana`에서 제공하는 엔드포인트). `--account` 플래그는 "
"트랜잭션에 서명하는 데 사용할 계정을 지정합니다. 여기서 사용하는 계정은 이전 단계에서 생성한 계정입니다. `--keystore` "
"플래그는 트랜잭션에 서명하는 데 사용할 키스토어 파일을 지정합니다."

#: src/ch99-01-04-01-voting-contract.md:322
msgid ""
"Since we are using a local node, the transaction will achieve finality "
"immediately. If you are using the Goerli Testnet, you will need to wait for "
"the transaction to be final, which usually takes a few seconds."
msgstr ""
"우리는 로컬 노드를 사용하기 때문에 거래는 즉시 최종성을 달성할 것입니다. Goerli 테스트넷을 사용하는 경우 거래가 최종화되기까지 몇"
" 초 정도 기다려야 합니다."

#: src/ch99-01-04-01-voting-contract.md:324
msgid ""
"The following command deploys the voting contract and registers voter_0, "
"voter_1, and voter_2 as eligible voters. These are the constructor "
"arguments, so add a voter account that you can later vote with."
msgstr ""
"다음 명령은 투표 계약을 배포하고 voter_0, voter_1 및 voter_2를 선거자로 등록합니다. 이들은 생성자 인수이므로 나중에"
" 투표할 수 있는 투표자 계정을 추가하십시오."

#: src/ch99-01-04-01-voting-contract.md:330
msgid "An example command:"
msgstr "예시 명령어:"

#: src/ch99-01-04-01-voting-contract.md:336
msgid ""
"In this case, the contract has been deployed at an specific address: "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`. This "
"address will be different for you. We will use this address to interact with"
" the contract."
msgstr ""
"이 경우에는 계약이 특정 주소인 "
"`0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349`에 "
"배포되었습니다. 이 주소는 여러분에게는 다를 것입니다. 우리는 이 주소를 사용하여 계약과 상호 작용할 것입니다."

#: src/ch99-01-04-01-voting-contract.md:338
msgid "Voter Eligibility Verification"
msgstr "유권자 자격 확인"

#: src/ch99-01-04-01-voting-contract.md:340
msgid ""
"In our voting contract, we have two functions to validate voter eligibility,"
" `voter_can_vote` and `is_voter_registered`. These are external read "
"functions, which mean they don't alter the state of the contract but only "
"read the current state."
msgstr ""
"우리의 투표 계약에는 유권자 자격을 확인하는 두 가지 함수인 `voter_can_vote`와 `is_voter_registered`가 "
"있습니다. 이들은 외부 읽기 함수로, 계약의 상태를 변경하지 않고 현재 상태만 읽습니다."

#: src/ch99-01-04-01-voting-contract.md:342
msgid ""
"The `is_voter_registered` function checks whether a particular address is "
"registered as an eligible voter in the contract. The `voter_can_vote` "
"function, on the other hand, checks whether the voter at a specific address "
"is currently eligible to vote, i.e., they are registered and haven't voted "
"already."
msgstr ""
"`is_voter_registered` 함수는 특정 주소가 계약서에 등록된 유권자인지 확인합니다. 반면에 `voter_can_vote` "
"함수는 특정 주소의 유권자가 현재 투표 자격이 있는지 확인합니다. 즉, 그들이 등록되어 있고 아직 투표하지 않았는지를 확인합니다."

#: src/ch99-01-04-01-voting-contract.md:344
msgid ""
"You can call these functions using the `starkli call` command. Note that the"
" `call` command is used for read functions, while the `invoke` command is "
"used for functions that can also write to storage. The `call` command does "
"not require signing, while the `invoke` command does."
msgstr ""
"이 함수들은 `starkli call` 명령을 사용하여 호출할 수 있습니다. `call` 명령은 읽기 함수에 사용되는 반면, "
"`invoke` 명령은 스토리지에 쓸 수도 있는 함수에 사용됩니다. `call` 명령은 서명이 필요하지 않지만, `invoke` 명령은 "
"필요합니다."

#: src/ch99-01-04-01-voting-contract.md:346
msgid ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash+\n"
"starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch99-01-04-01-voting-contract.md:350
msgid ""
"First we added the address of the contract, then the function we want to "
"call, and finally the input for the function. In this case, we are checking "
"whether the voter at the address "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0` can "
"vote."
msgstr ""
"먼저 우리는 계약의 주소를 추가했고, 그 다음에 우리가 호출하고자 하는 함수를 추가했으며, 마지막으로 함수에 대한 입력을 추가했습니다. "
"이 경우에는 주소 "
"`0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0`에 있는 "
"투표자가 투표할 수 있는지 확인하고 있습니다."

#: src/ch99-01-04-01-voting-contract.md:352
msgid ""
"Since we provided a registered voter address as an input, the result is 1 "
"(boolean true), indicating the voter is eligible to vote."
msgstr "등록된 유권자 주소를 입력했기 때문에 결과는 1(부울 참)로, 유권자가 투표 자격이 있다는 것을 나타냅니다."

#: src/ch99-01-04-01-voting-contract.md:354
msgid ""
"Next, let's call the `is_voter_registered` function using an unregistered "
"account address to observe the output:"
msgstr "다음으로, 등록되지 않은 계정 주소를 사용하여 `is_voter_registered` 함수를 호출하여 출력을 관찰해 봅시다:"

#: src/ch99-01-04-01-voting-contract.md:360
msgid ""
"With an unregistered account address, the terminal output is 0 (i.e., "
"false), confirming that the account is not eligible to vote."
msgstr "등록되지 않은 계정 주소로 터미널 출력이 0(즉, 거짓)이 되어 해당 계정이 투표 자격이 없음을 확인합니다."

#: src/ch99-01-04-01-voting-contract.md:362
msgid "Casting a Vote"
msgstr "투표하기"

#: src/ch99-01-04-01-voting-contract.md:364
msgid ""
"Now that we have established how to verify voter eligibility, we can vote! "
"To vote, we interact with the `vote` function, which is flagged as external,"
" necessitating the use of the `starknet invoke` command."
msgstr ""
"이제 유권자 자격을 확인하는 방법을 확립했으므로 투표할 수 있습니다! 투표하려면 외부로 플래그가 지정된 `vote` 함수와 상호 작용해야"
" 하며, 이를 위해 `starknet invoke` 명령을 사용해야 합니다."

#: src/ch99-01-04-01-voting-contract.md:366
msgid ""
"The `invoke` command syntax resembles the `call` command, but for voting, we"
" submit either `1` (for Yes) or `0` (for No) as our input. When we invoke "
"the `vote` function, we are charged a fee, and the transaction must be "
"signed by the voter; we are writing to the contract's storage."
msgstr ""
"`invoke` 명령 구문은 `call` 명령과 유사하지만 투표할 때는 입력으로 `1` (찬성) 또는 `0` (반대)을 제출합니다. "
"`vote` 함수를 호출할 때 수수료가 부과되며, 거래는 투표자에 의해 서명되어야 합니다. 우리는 계약의 저장소에 쓰고 있습니다."

#: src/ch99-01-04-01-voting-contract.md:376
msgid ""
"You will be prompted to enter the password for the signer. Once you enter "
"the password, the transaction will be signed and submitted to the Starknet "
"network. You will receive the transaction hash as output. With the starkli "
"transaction command, you can get more details about the transaction:"
msgstr ""
"서명자의 비밀번호를 입력하라는 프롬프트가 표시됩니다. 비밀번호를 입력하면 거래가 서명되어 Starknet 네트워크에 제출됩니다. 거래 "
"해시를 출력으로 받게 됩니다. starkli transaction 명령을 사용하여 거래에 대한 자세한 정보를 얻을 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:382
msgid "This returns:"
msgstr "이것은 다음을 반환합니다:"

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"transaction_hash\""
msgstr "\"transaction_hash\""

#: src/ch99-01-04-01-voting-contract.md:386
msgid "\"0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"max_fee\""
msgstr "\"최대 수수료\""

#: src/ch99-01-04-01-voting-contract.md:387
msgid "\"0x430e81\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:388
#: src/ch99-01-04-01-voting-contract.md:397
#: src/ch99-01-04-01-voting-contract.md:401
#: src/ch99-01-04-01-voting-contract.md:402
#: src/ch99-01-04-01-voting-contract.md:403
msgid "\"0x1\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:389
msgid "\"signature\""
msgstr "\"서명\""

#: src/ch99-01-04-01-voting-contract.md:390
msgid "\"0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:391
msgid "\"0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"nonce\""
msgstr "\"일회용\""

#: src/ch99-01-04-01-voting-contract.md:393
msgid "\"0x3\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:394
msgid "\"INVOKE\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"sender_address\""
msgstr "\"발신자 주소\""

#: src/ch99-01-04-01-voting-contract.md:395
msgid "\"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\""
msgstr ""


#: src/ch99-01-04-01-voting-contract.md:396
msgid "\"calldata\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:398
msgid "\"0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:399
msgid "\"0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:400
msgid "\"0x0\""
msgstr ""

#: src/ch99-01-04-01-voting-contract.md:408
msgid "If you try to vote twice with the same signer you will get an error:"
msgstr "동일한 서명자로 두 번 투표를 시도하면 오류가 발생합니다."

#: src/ch99-01-04-01-voting-contract.md:411
msgid "\"Contract error\""
msgstr "\"계약 오류\""

#: src/ch99-01-04-01-voting-contract.md:414
msgid ""
"The error is not very informative, but you can get more details when looking"
" at the output in the terminal where you started `katana` (our local "
"Starknet node):"
msgstr ""
"에러 메시지는 그다지 유용하지 않지만, `katana` (로컬 Starknet 노드)를 시작한 터미널 출력을 확인하면 더 많은 세부 "
"정보를 얻을 수 있습니다."

#: src/ch99-01-04-01-voting-contract.md:418
msgid ""
"\"Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    Error at pc=0:81:\n"
"    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\n"
msgstr ""
"\"호출된 계약에서 오류 발생 (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):\n"
"    pc=0:81에서 오류 발생:\n"
"    힌트 실행 중 예외 발생: 사용자 지정 힌트 오류: 실행 실패. 실패 이유: \\\"USER_ALREADY_VOTED\\\".\n"
"    ...\""

#: src/ch99-01-04-01-voting-contract.md:424
msgid "The key for the error is `USER_ALREADY_VOTED`."
msgstr "오류의 키는 `USER_ALREADY_VOTED`입니다."

#: src/ch99-01-04-01-voting-contract.md:430
msgid ""
"We can repeat the process to create Signers and Account Descriptors for the "
"accounts we want to use for voting. Remember that each Signer must be "
"created from a private key, and each Account Descriptor must be created from"
" a public key, a smart wallet address, and the smart wallet class hash "
"(which is the same for each voter)."
msgstr ""
"우리는 투표에 사용할 계정을 위해 서명자와 계정 설명자를 만들기 위한 과정을 반복할 수 있습니다. 각 서명자는 개인 키에서 생성되어야 "
"하며, 각 계정 설명자는 공개 키, 스마트 지갑 주소 및 스마트 지갑 클래스 해시(각 투표자마다 동일함)에서 생성되어야 합니다."

#: src/ch99-01-04-01-voting-contract.md:438
msgid "Visualizing Vote Outcomes"
msgstr "투표 결과 시각화"

#: src/ch99-01-04-01-voting-contract.md:440
msgid ""
"To examine the voting results, we invoke the `get_vote_status` function, "
"another view function, through the `starknet call` command."
msgstr ""
"투표 결과를 확인하기 위해 `starknet call` 명령어를 통해 다른 뷰 함수인 `get_vote_status` 함수를 호출합니다."

#: src/ch99-01-04-01-voting-contract.md:446
msgid ""
"The output reveals the tally of \"Yes\" and \"No\" votes along with their "
"relative percentages."
msgstr "출력 결과는 \"예\"와 \"아니요\" 투표의 합계와 그에 대한 상대적인 백분율을 보여줍니다."

#: src/ch99-04-00-L1-L2-messaging.md:1
msgid "L1-L2 Messaging"
msgstr "L1-L2 메시징"

#: src/ch99-04-00-L1-L2-messaging.md:3
msgid ""
"A crucial feature of a Layer 2 is its ability to interact with Layer 1."
msgstr "Layer 2의 중요한 특징 중 하나는 Layer 1과 상호 작용할 수 있는 능력입니다."

#: src/ch99-04-00-L1-L2-messaging.md:5
msgid ""
"Starknet has its own `L1-L2` Messaging system, which is different from its "
"consensus mechanism and the submission of state updates on L1. Messaging is "
"a way for smart-contracts on L1 to interact with smart-contracts on L2 (or "
"the other way around), allowing us to do \"cross-chain\" transactions. For "
"example, we can do some computations on a chain and use the result of this "
"computation on the other chain."
msgstr ""
"스타크넷은 자체 `L1-L2` 메시징 시스템을 갖고 있으며, 이는 합의 메커니즘과 L1에서 상태 업데이트를 제출하는 것과는 다릅니다. "
"메시징은 L1의 스마트 계약이 L2의 스마트 계약과 상호 작용하는 방법입니다(또는 그 반대로), \"크로스 체인\" 거래를 할 수 있게 "
"합니다. 예를 들어, 한 체인에서 일부 계산을 수행하고 이 계산 결과를 다른 체인에서 사용할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:7
msgid ""
"Bridges on Starknet all use `L1-L2` messaging. Let's say that you want to "
"bridge tokens from Ethereum to Starknet. You will simply have to deposit "
"your tokens in the L1 bridge contract, which will automatically trigger the "
"minting of the same token on L2. Another good use case for `L1-L2` messaging"
" would be [DeFi pooling](https://starkware.co/resource/defi-pooling/)."
msgstr ""
"스타크넷의 모든 브릿지는 `L1-L2` 메시징을 사용합니다. 예를 들어, 이더리움에서 스타크넷으로 토큰을 브릿징하고 싶다고 가정해 "
"봅시다. 간단히 이더리움 토큰을 L1 브릿지 계약에 예치하면, 자동으로 L2에서 동일한 토큰을 발행하게 됩니다. `L1-L2` 메시징의 "
"또 다른 좋은 사용 사례는 [DeFi 풀링](https://starkware.co/resource/defi-pooling/)입니다."

#: src/ch99-04-00-L1-L2-messaging.md:9
msgid ""
"On Starknet, it's important to note that the messaging system is "
"**asynchronous** and **asymmetric**."
msgstr "스타크넷에서는 메시징 시스템이 **비동기적**이고 **비대칭적**이라는 점을 주목해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:11
msgid ""
"**Asynchronous**: this means that in your contract code (being Solidity or "
"Cairo), you can't wait the result of the message being sent on the other "
"chain within your contract code execution."
msgstr ""
"**비동기적**: 이는 당신의 계약 코드(Solidity 또는 Cairo)에서 다른 체인으로 전송된 메시지의 결과를 계약 코드 실행 "
"내에서 기다릴 수 없다는 것을 의미합니다."

#: src/ch99-04-00-L1-L2-messaging.md:12
msgid ""
"**Asymmetric**: sending a message from Ethereum to Starknet (`L1->L2`) is "
"fully automated by the Starknet sequencer, which means that the message is "
"being automatically delivered to the target contract on L2. However, when "
"sending a message from Starknet to Ethereum (`L2->L1`), only the hash of the"
" message is sent on L1 by the Starknet sequencer. You must then consume the "
"message manually via a transaction on L1."
msgstr ""
"**비대칭**: 이더리움에서 Starknet으로 메시지를 보내는 것(`L1->L2`)은 Starknet 시퀀서에 의해 완전히 자동화되어 "
"있어 메시지가 L2의 대상 계약에 자동으로 전달되는 것을 의미합니다. 그러나 Starknet에서 이더리움으로 메시지를 보내는 "
"경우(`L2->L1`), Starknet 시퀀서에 의해 메시지의 해시만 L1로 전송됩니다. 그런 다음 L1에서 트랜잭션을 통해 메시지를 "
"수동으로 소비해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:14
msgid "Let's dive into the details."
msgstr "세부 사항에 대해 자세히 살펴봅시다."

#: src/ch99-04-00-L1-L2-messaging.md:16
msgid "The StarknetMessaging Contract"
msgstr "스타크넷 메시징 계약"

#: src/ch99-04-00-L1-L2-messaging.md:18
msgid ""
"The crucial component of the `L1-L2` Messaging system is the "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4)"
" contract. It is a set of Solidity contracts deployed on Ethereum that "
"allows Starknet to function properly. One of the contracts of `StarknetCore`"
" is called `StarknetMessaging` and it is the contract responsible for "
"passing messages between Starknet and Ethereum. `StarknetMessaging` follows "
"an [interface](https://github.com/starkware-libs/cairo-"
"lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6)"
" with functions allowing to send message to L2, receiving messages on L1 "
"from L2 and canceling messages."
msgstr ""
"`L1-L2` 메시징 시스템의 중요한 구성 요소는 "
"[`StarknetCore`](https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4)"
" 계약입니다. 이는 이더리움에 배포된 Solidity 계약 세트로, Starknet이 올바르게 작동할 수 있도록 합니다. "
"`StarknetCore`의 계약 중 하나는 `StarknetMessaging`이라고 불리며, Starknet과 이더리움 간에 메시지를 "
"전달하는 책임을 담당하는 계약입니다. `StarknetMessaging`은 "
"[인터페이스](https://github.com/starkware-libs/cairo-"
"lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6)를"
" 따르며, L2로 메시지를 보내고, L1에서 L2로부터 메시지를 수신하고, 메시지를 취소하는 기능을 제공합니다."

#: src/ch99-04-00-L1-L2-messaging.md:49
msgid " Starknet messaging contract interface"
msgstr "스타크넷 메시징 계약 인터페이스"

#: src/ch99-04-00-L1-L2-messaging.md:51
msgid ""
"In the case of `L1->L2` messages, the Starknet sequencer is constantly "
"listening to the logs emitted by the `StarknetMessaging` contract on "
"Ethereum. Once a message is detected in a log, the sequencer prepares and "
"executes a `L1HandlerTransaction` to call the function on the target L2 "
"contract. This takes up to 1-2 minutes to be done (few seconds for ethereum "
"block to be mined, and then the sequencer must build and execute the "
"transaction)."
msgstr ""
"`L1->L2` 메시지의 경우, Starknet 시퀀서는 이더리움의 `StarknetMessaging` 계약이 발행한 로그를 계속 듣고 "
"있습니다. 로그에서 메시지가 감지되면 시퀀서는 대상 L2 계약의 함수를 호출하기 위해 `L1HandlerTransaction`을 준비하고"
" 실행합니다. 이 작업은 최대 1-2분이 소요됩니다 (이더리움 블록이 채굴되는 데 몇 초가 걸리고, 그런 다음 시퀀서가 트랜잭션을 "
"작성하고 실행해야 합니다)."

#: src/ch99-04-00-L1-L2-messaging.md:54
msgid ""
"`L2->L1` messages are prepared by contracts execution on L2 and are part of "
"the block produced. When the sequencer produces a block, it sends the hash "
"of each message prepared by contracts execution to the `StarknetCore` "
"contract on L1, where they can then be consumed once the block they belong "
"to is proven and verified on Ethereum (which for now is around 3-4 hours)."
msgstr ""
"`L2->L1` 메시지는 L2에서 계약 실행에 의해 준비되며 생성된 블록의 일부입니다. 시퀀서가 블록을 생성하면, 각 메시지의 해시를 "
"준비된 계약 실행에 의해 L1의 `StarknetCore` 계약으로 보냅니다. 해당 메시지는 해당하는 블록이 이더리움에서 증명 및 확인된"
" 후(현재로는 약 3-4시간) 소비될 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:57
msgid "Sending messages from Ethereum to Starknet"
msgstr "이더리움에서 스타크넷으로 메시지를 보내는 중"

#: src/ch99-04-00-L1-L2-messaging.md:59
msgid ""
"If you want to send messages from Ethereum to Starknet, your Solidity "
"contracts must call the `sendMessageToL2` function of the "
"`StarknetMessaging` contract. To receive these messages on Starknet, you "
"will need to annotate functions that can be called from L1 with the "
"`#[l1_handler]` attribute."
msgstr ""
"이더리움에서 스타크넷으로 메시지를 보내려면, 솔리디티 계약은 `StarknetMessaging` 계약의 `sendMessageToL2` "
"함수를 호출해야 합니다. 스타크넷에서 이러한 메시지를 받으려면, L1에서 호출할 수 있는 함수에 `#[l1_handler]` 속성을 "
"추가해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:61
msgid ""
"Let's take a simple contract taken from [this "
"tutorial](https://github.com/glihm/starknet-messaging-"
"dev/blob/main/solidity/src/ContractMsg.sol) where we want to send a message "
"to Starknet. The `_snMessaging` is a state variable already initialized with"
" the address of the `StarknetMessaging` contract. You can check those "
"addresses "
"[here](https://docs.starknet.io/documentation/tools/important_addresses/)."
msgstr ""
"[이 튜토리얼](https://github.com/glihm/starknet-messaging-"
"dev/blob/main/solidity/src/ContractMsg.sol)에서 가져온 간단한 계약을 살펴보겠습니다. 여기서는 "
"Starknet에 메시지를 보내고 싶습니다. `_snMessaging`은 이미 `StarknetMessaging` 계약의 주소로 초기화된"
" 상태 변수입니다. 해당 주소를 "
"[여기](https://docs.starknet.io/documentation/tools/important_addresses/)에서 "
"확인할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:65
msgid "// Sends a message on Starknet with a single felt.\n"
msgstr "단일 펠트로 Starknet에 메시지를 보냅니다."

#: src/ch99-04-00-L1-L2-messaging.md:74
msgid ""
"// We \"serialize\" here the felt into a payload, which is an array of "
"uint256.\n"
msgstr "여기서는 펠트를 페이로드로 직렬화합니다. 이는 uint256 배열입니다."

#: src/ch99-04-00-L1-L2-messaging.md:78
msgid "// msg.value must always be >= 20_000 wei.\n"
msgstr "// msg.value는 항상 20,000 wei 이상이어야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:87
msgid ""
"The function sends a message with a single felt value to the "
"`StarknetMessaging` contract. Please note that if you want to send more "
"complex data you can. Just be aware that your Cairo contract will only "
"understand `felt252` data type. So you must ensure that the serialization of"
" your data into the `uint256` array follow the Cairo serialization scheme."
msgstr ""
"해당 기능은 `StarknetMessaging` 계약에 단일 felt 값으로 메시지를 보냅니다. 더 복잡한 데이터를 보내고 싶다면 "
"가능합니다. 그러나 Cairo 계약이 `felt252` 데이터 유형만 이해한다는 점을 유의하십시오. 따라서 데이터를 `uint256` "
"배열로 직렬화할 때 Cairo 직렬화 체계를 따르도록 해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:90
msgid ""
"It's important to note that we have `{value: msg.value}`. In fact, the "
"minimum value we've to send here is `20k wei`, due to the fact that the "
"`StarknetMessaging` contract will register the hash of our message in the "
"storage of Ethereum."
msgstr ""
"우리가 `{value: msg.value}`를 가지고 있다는 점을 주목하는 것이 중요합니다. "
"실제로, 여기서 보내야 하는 최소 값은 `20k wei`인데, `StarknetMessaging` 계약이 우리 메시지의 해시를 이더리움의 저장소에 등록하기 때문입니다."

#: src/ch99-04-00-L1-L2-messaging.md:93
msgid ""
"Additionally to those `20k wei`, as the `L1HandlerTransaction` that will be "
"executed by the sequencer is not bound to any account (the message "
"originates from L1), you must also ensure that you pay enough fees on L1 for"
" your message to be deserialized and processed on L2."
msgstr ""
"또한, 시퀀서에 의해 실행될 `L1HandlerTransaction`이 어떤 계정에도 바인딩되어 있지 않기 때문에 (메시지가 L1에서 "
"시작되었습니다), L2에서 메시지를 역직렬화하고 처리하기 위해 충분한 수수료를 L1에 지불해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:96
msgid ""
"The fees of the `L1HandlerTransaction` are computed in a regular manner as "
"it would be done for an `Invoke` transaction. For this, you can profile the "
"gas consumption using `starkli` or `snforge` to estimate the cost of your "
"message execution."
msgstr ""
"`L1HandlerTransaction`의 수수료는 `Invoke` 트랜잭션에 대해 수행되는 것과 동일한 방식으로 계산됩니다. 이를 위해"
" `starkli` 또는 `snforge`를 사용하여 가스 소비를 프로파일링하여 메시지 실행 비용을 추정할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:99
msgid "The signature of the `sendMessageToL2` is:"
msgstr "`sendMessageToL2`의 서명은 다음과 같습니다:"

#: src/ch99-04-00-L1-L2-messaging.md:109
msgid "The parameters are as follow:"
msgstr "매개변수는 다음과 같습니다:"

#: src/ch99-04-00-L1-L2-messaging.md:111
msgid "`toAddress`: The contract address on L2 that will be called."
msgstr "`toAddress`: 호출될 L2 계약 주소입니다."

#: src/ch99-04-00-L1-L2-messaging.md:112
msgid ""
"`selector`: The selector of the function of this contract at `toAddress`. "
"This selector (function) must have the `#[l1_handler]` attribute to be "
"callable."
msgstr ""
"`selector`: 이 계약의 기능 선택기는 `toAddress`에 있습니다. 이 선택기(함수)는 호출 가능하도록 "
"`#[l1_handler]` 속성을 가져야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:113
msgid ""
"`payload`: The payload is always an array of `felt252` (which are "
"represented by `uint256` in Solidity). For this reason we've inserted the "
"input `myFelt` into the array. This is why we need to insert the input data "
"into an array."
msgstr ""
"`payload`: 페이로드는 항상 `felt252`의 배열입니다 (`Solidity`에서 `uint256`로 표현됨). 이유는 우리가 "
"입력 `myFelt`를 배열에 삽입했기 때문입니다. 그래서 입력 데이터를 배열에 삽입해야 하는 이유입니다."

#: src/ch99-04-00-L1-L2-messaging.md:116
msgid "On the Starknet side, to receive this message, we have:"
msgstr "스타크넷 쪽에서 이 메시지를 받으려면, 우리는:"

#: src/ch99-04-00-L1-L2-messaging.md:123
msgid ""
"// You can now use the data, automatically deserialized from the message "
"payload.\n"
msgstr "이제 메시지 페이로드에서 자동으로 역직렬화된 데이터를 사용할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:128
msgid ""
"We need to add the `#[l1_handler]` attribute to our function. L1 handlers "
"are special functions that can only be executed by a `L1HandlerTransaction`."
" There is nothing particular to do to receive transactions from L1, as the "
"message is relayed by the sequencer automatically. In your `#[l1_handler]` "
"functions, it is important to verify the sender of the L1 message to ensure "
"that our contract can only receive messages from a trusted L1 contract."
msgstr ""
"우리는 함수에 `#[l1_handler]` 속성을 추가해야 합니다. L1 핸들러는 `L1HandlerTransaction`에 의해서만 "
"실행될 수 있는 특별한 함수들입니다. L1에서 트랜잭션을 받기 위해 특별히 할 일은 없습니다. 메시지는 시퀀서에 의해 자동으로 "
"중계됩니다. `#[l1_handler]` 함수에서는 L1 메시지의 발신자를 확인하여 우리 계약이 신뢰할 수 있는 L1 계약으로부터만 "
"메시지를 받을 수 있도록 하는 것이 중요합니다."

#: src/ch99-04-00-L1-L2-messaging.md:130
msgid "Sending messages from Starknet to Ethereum"
msgstr "스타크넷에서 이더리움으로 메시지를 보내는 중"

#: src/ch99-04-00-L1-L2-messaging.md:132
msgid ""
"When sending messages from Starknet to Ethereum, you will have to use the "
"`send_message_to_l1` syscall in your Cairo contracts. This syscall allows "
"you to send messages to the `StarknetMessaging` contract on L1. Unlike "
"`L1->L2` messages, `L2->L1` messages must be consumed manually, which means "
"that you will need your Solidity contract to call the `consumeMessageFromL2`"
" function of the `StarknetMessaging` contract explicitly in order to consume"
" the message."
msgstr ""
"스타크넷에서 이더리움으로 메시지를 보낼 때, 카이로 계약에서 `send_message_to_l1` 시스콜을 사용해야 합니다. 이 시스콜을"
" 사용하면 L1의 `StarknetMessaging` 계약으로 메시지를 보낼 수 있습니다. `L1->L2` 메시지와는 달리, "
"`L2->L1` 메시지는 수동으로 소비해야 합니다. 즉, 소비하기 위해 솔리디티 계약에서 명시적으로 `StarknetMessaging` "
"계약의 `consumeMessageFromL2` 함수를 호출해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:134
msgid "To send a message from L2 to L1, what we would do on Starknet is:"
msgstr "L2에서 L1로 메시지를 보내려면 Starknet에서 우리가 할 일은 다음과 같습니다:"

#: src/ch99-04-00-L1-L2-messaging.md:138
msgid ""
"// Note here, we \"serialize\" my_felt, as the payload must be\n"
"            // a `Span<felt252>`.\n"
msgstr "여기서 주목해야 할 점은 페이로드가 `Span<felt252>`여야 하므로 my_felt를 \"직렬화\"한다는 것입니다."

#: src/ch99-04-00-L1-L2-messaging.md:145
msgid ""
"We simply build the payload and pass it, along with the L1 contract address,"
" to the syscall function."
msgstr "우리는 단순히 페이로드를 구축하고, L1 계약 주소와 함께 syscall 함수에 전달합니다."

#: src/ch99-04-00-L1-L2-messaging.md:147
msgid ""
"On L1, the important part is to build the same payload sent by the L2. Then "
"you call `consumeMessageFromL2` in you Solidity contract by passing the L2 "
"contract address and the payload. Please be aware that the L2 contract "
"address expected by the `consumeMessageFromL2` is the address of the "
"contract that sends the message on the L2 by calling "
"`send_message_to_l1_syscall`."
msgstr ""
"L1에서 중요한 부분은 L2에서 보낸 동일한 페이로드를 구축하는 것입니다. 그런 다음 L2 계약 주소와 페이로드를 전달하여 "
"Solidity 계약에서 `consumeMessageFromL2`를 호출합니다. `consumeMessageFromL2`에서 예상하는 "
"L2 계약 주소는 `send_message_to_l1_syscall`를 호출하여 L2에서 메시지를 보내는 계약의 주소입니다."

#: src/ch99-04-00-L1-L2-messaging.md:158
msgid "// You can use the message hash if you want here.\n"
msgstr "여기서 메시지 해시를 사용할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:160
msgid ""
"// We expect the payload to contain only a felt252 value (which is a uint256"
" in Solidity).\n"
msgstr "우리는 페이로드에는 felt252 값만 포함되어 있다고 예상합니다 (이는 Solidity에서 uint256입니다)."

#: src/ch99-04-00-L1-L2-messaging.md:161
msgid "\"Invalid payload\""
msgstr "\"잘못된 페이로드\""

#: src/ch99-04-00-L1-L2-messaging.md:165
msgid ""
"// From here, you can safely use `my_felt` as the message has been verified "
"by StarknetMessaging.\n"
msgstr ""
"여기서부터는 StarknetMessaging에 의해 메시지가 확인되었기 때문에 `my_felt`를 안전하게 사용할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:166
msgid "\"Invalid value\""
msgstr "\"잘못된 값\""

#: src/ch99-04-00-L1-L2-messaging.md:170
msgid ""
"As you can see, in this context we don't have to verify which contract from "
"L2 is sending the message (as we do on the L2 to verify which contract from "
"L1 is sending the message). But we are actually using the "
"`consumeMessageFromL2` of the `StarknetCore` contract to validate the inputs"
" (the contract address on L2 and the payload) to ensure we are only "
"consuming valid messages."
msgstr ""
"보시다시피, 이 문맥에서는 L2의 어떤 계약이 메시지를 보내는지 확인할 필요가 없습니다(L1에서 메시지를 보내는 계약을 확인하는 것과 "
"같이). 그러나 실제로 우리는 L2의 `StarknetCore` 계약의 `consumeMessageFromL2`를 사용하여 입력(계약 "
"주소 및 페이로드)를 유효한 메시지만 소비하도록 보장하기 위해 유효성을 검사합니다."

#: src/ch99-04-00-L1-L2-messaging.md:172
msgid ""
"**Note:** The `consumeMessageFromL2` function of the `StarknetCore` contract"
" is expected to be called from a Solidity contract, and not directly on the "
"`StarknetCore` contract. The reason of that is because the `StarknetCore` "
"contract is using `msg.sender` to actually compute the hash of the message. "
"And this `msg.sender` must correspond to the `to_address` field that is "
"given to the function `send_message_to_l1_syscall` that is called on "
"Starknet."
msgstr ""
"**참고:** `StarknetCore` 계약의 `consumeMessageFromL2` 함수는 Solidity 계약에서 호출되어야 "
"하며, `StarknetCore` 계약에 직접 호출되어서는 안 됩니다. 그 이유는 `StarknetCore` 계약이 실제로 메시지의 "
"해시를 계산하기 위해 `msg.sender`를 사용하고 있기 때문입니다. 그리고 이 `msg.sender`는 Starknet에서 호출되는"
" `send_message_to_l1_syscall` 함수에 주어진 `to_address` 필드와 일치해야 합니다."

#: src/ch99-04-00-L1-L2-messaging.md:174
msgid ""
"It is important to remember that on L1 we are sending a payload of "
"`uint256`, but the basic data type on Starknet is `felt252`; however, "
"`felt252` are approximately 4 bits smaller than `uint256`. So we have to pay"
" attention to the values contained in the payload of the messages we are "
"sending. If, on L1, we build a message with values above the maximum "
"`felt252`, the message will be stuck and never consumed on L2."
msgstr ""
"L1에서는 `uint256`의 페이로드를 보내고 있지만, Starknet의 기본 데이터 유형은 `felt252`입니다. 그러나 "
"`felt252`는 대략 `uint256`보다 4비트 작습니다. 따라서 우리는 보내는 메시지의 페이로드에 포함된 값에 주의해야 합니다. "
"L1에서 `felt252`의 최대값을 초과하는 값을 가진 메시지를 작성하면, 해당 메시지는 L2에서 소비되지 않고 멈춰있게 될 것입니다."

#: src/ch99-04-00-L1-L2-messaging.md:176
msgid "Cairo Serde"
msgstr "카이로 세르드"

#: src/ch99-04-00-L1-L2-messaging.md:178
msgid ""
"Before sending messages between L1 and L2, you must remember that Starknet "
"contracts, written in Cairo, can only understand serialized data. And "
"serialized data is always an array of `felt252`. In Solidity we have "
"`uint256` type, and `felt252` are approximately 4 bits smaller than "
"`uint256`. So we have to pay attention to the values contained in the "
"payload of the messages we are sending. If, on L1, we build a message with "
"values above the maximum `felt252`, the message will be stuck and never "
"consumed on L2."
msgstr ""
"L1과 L2 사이에 메시지를 보내기 전에, Cairo로 작성된 Starknet 계약이 직렬화된 데이터만 이해할 수 있다는 것을 기억해야 "
"합니다. 직렬화된 데이터는 항상 `felt252` 배열입니다. Solidity에서는 `uint256` 유형이 있고, `felt252`는 "
"대략 `uint256`보다 4비트 작습니다. 그래서 우리는 보내는 메시지의 페이로드에 포함된 값에 주의를 기울여야 합니다. L1에서 "
"`felt252` 최대값을 초과하는 값을 포함한 메시지를 작성하면, 해당 메시지는 L2에서 소비되지 않고 멈춰있게 됩니다."

#: src/ch99-04-00-L1-L2-messaging.md:182
msgid ""
"So for instance, an actual `uint256` value in Cairo is represented by a "
"struct like:"
msgstr "예를 들어, 카이로에서 실제 `uint256` 값은 다음과 같은 구조체로 표현됩니다:"

#: src/ch99-04-00-L1-L2-messaging.md:191
msgid ""
"which will be serialized as **TWO** felts, one for the `low`, and one for "
"the `high`. This means that to send only one `u256` to Cairo, you'll need to"
" send a payload from L1 with **TWO** values."
msgstr ""
"`low`와 `high` 각각을 나타내는 **두 개**의 펠트로 직렬화될 것입니다. "
"이는 카이로에 하나의 `u256`만 보내려면 L1에서 **두 개**의 값이 포함된 페이로드를 보내야 한다는 것을 의미합니다."

#: src/ch99-04-00-L1-L2-messaging.md:194
msgid "// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\n"
msgstr "카이로로 u256으로 값 1을 보내봅시다: low = 1, high = 0."

#: src/ch99-04-00-L1-L2-messaging.md:200
msgid ""
"If you want to learn more about the messaging mechanism, you can visit the "
"[Starknet "
"documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"메시징 메커니즘에 대해 더 알고 싶다면, [Starknet "
"문서](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)를 방문할 수 있습니다."

#: src/ch99-04-00-L1-L2-messaging.md:202
msgid ""
"You can also find a [detailed guide here](https://github.com/glihm/starknet-"
"messaging-dev) to test the messaging in local."
msgstr ""
"로컬에서 메시징을 테스트하려면 [여기에 자세한 가이드](https://github.com/glihm/starknet-messaging-dev)를 찾을 수도 있습니다."

#: src/ch99-03-security-considerations.md:3
msgid ""
"When developing software, ensuring it functions as intended is usually "
"straightforward. However, preventing unintended usage and vulnerabilities "
"can be more challenging."
msgstr ""
"소프트웨어를 개발할 때 의도한 대로 작동하는지 확인하는 것은 보통 간단합니다. 그러나 의도하지 않은 사용 및 취약점을 방지하는 것은 더 "
"어려울 수 있습니다."

#: src/ch99-03-security-considerations.md:5
msgid ""
"In smart contract development, security is very important. A single error "
"can result in the loss of valuable assets or the improper functioning of "
"certain features."
msgstr ""
"스마트 계약 개발에서 보안은 매우 중요합니다. 단 하나의 오류가 가치 있는 자산의 손실이나 특정 기능의 부정확한 작동으로 이어질 수 "
"있습니다."

#: src/ch99-03-security-considerations.md:7
msgid ""
"Smart contracts are executed in a public environment where anyone can "
"examine the code and interact with it. Any errors or vulnerabilities in the "
"code can be exploited by malicious actors."
msgstr ""
"스마트 계약은 누구나 코드를 검토하고 상호 작용할 수 있는 공개 환경에서 실행됩니다. 코드의 오류나 취약점은 악의적인 사용자에 의해 "
"악용될 수 있습니다."

#: src/ch99-03-security-considerations.md:9
msgid ""
"This chapter presents general recommendations for writing secure smart "
"contracts. By incorporating these concepts during development, you can "
"create robust and reliable smart contracts. This reduces the chance of "
"unexpected behavior or vulnerabilities."
msgstr ""
"이 장은 안전한 스마트 계약을 작성하기 위한 일반적인 권장 사항을 제시합니다. 이러한 개념을 개발 중에 통합함으로써 견고하고 신뢰할 수 "
"있는 스마트 계약을 만들 수 있습니다. 이는 예기치 않은 동작이나 취약점 발생 가능성을 줄입니다."

#: src/ch99-03-security-considerations.md:11
msgid "Disclaimer"
msgstr "면책 조항"

#: src/ch99-03-security-considerations.md:13
msgid ""
"This chapter does not provide an exhaustive list of all possible security "
"issues, and it does not guarantee that your contracts will be completely "
"secure."
msgstr "이 장은 모든 가능한 보안 문제의 철저한 목록을 제공하지 않으며, 귀하의 계약이 완전히 안전하다는 것을 보장하지 않습니다."

#: src/ch99-03-security-considerations.md:15
msgid ""
"If you are developing smart contracts for production use, it is highly "
"recommended to conduct external audits performed by security experts."
msgstr "생산용 스마트 계약을 개발 중이라면, 보안 전문가들에 의해 수행된 외부 감사를 실시하는 것이 강력히 권장됩니다."

#: src/ch99-03-security-considerations.md:17
msgid "Mindset"
msgstr "마음가짐"

#: src/ch99-03-security-considerations.md:19
msgid ""
"Cairo is a highly safe language inspired by Rust. It is designed in a way "
"that force you to cover all possible cases. Security issues on Starknet "
"mostly arise from the way smart contract flows are designed, not much from "
"the language itself."
msgstr ""
"카이로는 러스트에 영감을 받은 매우 안전한 언어입니다. 가능한 모든 경우를 다루도록 설계되어 있습니다. 스타크넷의 보안 문제는 대부분 "
"스마트 계약 플로우가 설계된 방식에서 발생하며, 언어 자체에서는 그렇게 많이 발생하지 않습니다."

#: src/ch99-03-security-considerations.md:21
msgid ""
"Adopting a security mindset is the initial step in writing secure smart "
"contracts. Try to always consider all possible scenarios when writing code."
msgstr ""
"보안 마인드셋을 채택하는 것은 안전한 스마트 계약을 작성하는 첫 번째 단계입니다. 코드를 작성할 때 항상 모든 가능한 시나리오를 "
"고려하려고 노력해보세요."

#: src/ch99-03-security-considerations.md:23
msgid "Viewing smart contract as Finite State Machines"
msgstr "스마트 계약을 유한 상태 기계로 보기"

#: src/ch99-03-security-considerations.md:25
msgid ""
"Transactions in smart contracts are atomic, meaning they either succeed or "
"fail without making any changes."
msgstr "스마트 계약의 거래는 원자적이며, 어떠한 변경도 없이 성공하거나 실패합니다."

#: src/ch99-03-security-considerations.md:27
msgid ""
"Think of smart contracts as state machines: they have a set of initial "
"states defined by the constructor constraints, and external function "
"represents a set of possible state transitions. A transaction is nothing "
"more than a state transition."
msgstr ""
"스마트 계약을 상태 기계로 생각해보세요: 그들은 생성자 제약 조건에 의해 정의된 초기 상태 집합을 가지고 있으며, 외부 함수는 가능한 "
"상태 전이 집합을 나타냅니다. 거래는 단순히 상태 전이에 불과합니다."

#: src/ch99-03-security-considerations.md:29
msgid ""
"The `assert!` or `panic!` macros can be used to validate conditions before "
"performing specific actions. You can learn more about these on the "
"[Unrecoverable Errors with panic](./ch10-01-unrecoverable-errors-with-"
"panic.md) page."
msgstr ""
"`assert!` 또는 `panic!` 매크로는 특정 작업을 수행하기 전에 조건을 확인하는 데 사용할 수 있습니다. 이에 대해 더 자세히"
" 알아보려면 [패닉으로 처리할 수 없는 오류](./ch10-01-unrecoverable-errors-with-panic.md) 페이지를"
" 참조하십시오."

#: src/ch99-03-security-considerations.md:31
msgid "These validations can include:"
msgstr "이러한 유효성 검사는 다음과 같을 수 있습니다:"

#: src/ch99-03-security-considerations.md:33
msgid "Inputs provided by the caller"
msgstr "통화자가 제공한 입력"

#: src/ch99-03-security-considerations.md:34
msgid "Execution requirements"
msgstr "실행 요구 사항"

#: src/ch99-03-security-considerations.md:35
msgid "Invariants (conditions that must always be true)"
msgstr "불변 조건 (항상 참이어야 하는 조건)"

#: src/ch99-03-security-considerations.md:36
msgid "Return values from other function calls"
msgstr "다른 함수 호출로부터 반환 값을 받기"

#: src/ch99-03-security-considerations.md:38
msgid ""
"For example, you could use the `assert!` macro to validate that a user has "
"enough funds to perform a withdraw transaction. If the condition is not met,"
" the transaction will fail and the state of the contract will not change."
msgstr ""
"예를 들어, `assert!` 매크로를 사용하여 사용자가 출금 거래를 수행하기에 충분한 자금을 가지고 있는지 확인할 수 있습니다. 조건이"
" 충족되지 않으면 거래가 실패하고 계약의 상태가 변경되지 않습니다."

#: src/ch99-03-security-considerations.md:45
msgid "\"Insufficient funds\""
msgstr "자금 부족"

#: src/ch99-03-security-considerations.md:51
msgid ""
"Using these functions to check conditions adds constraints that help clearly"
" define the boundaries of possible state transitions for each function in "
"your smart contract. These checks ensure that the behavior of the contract "
"stays within the expected limits."
msgstr ""
"이러한 함수를 사용하여 조건을 확인하면 스마트 계약의 각 함수에 대한 가능한 상태 전이의 경계를 명확히 정의하는 데 도움이 되는 제약 "
"조건이 추가됩니다. 이러한 확인은 계약의 동작이 예상한 한도 내에 유지되도록 보장합니다."

#: src/ch99-03-security-considerations.md:53
msgid "Recommendations"
msgstr "추천사항"

#: src/ch99-03-security-considerations.md:55
msgid "Checks Effects Interactions Pattern"
msgstr "체크 효과 상호작용 패턴"

#: src/ch99-03-security-considerations.md:57
msgid ""
"The Checks Effects Interactions pattern is a common design pattern used to "
"prevent reentrancy attacks on Ethereum. While reentrancy is harder to "
"achieve in Starknet, it is still recommended to use this pattern in your "
"smart contracts."
msgstr ""
"체크 이펙트 상호작용 패턴은 이더리움에서 재진입 공격을 방지하기 위해 사용되는 일반적인 디자인 패턴입니다. Starknet에서 재진입을 "
"달성하기는 더 어렵지만 여전히 스마트 계약에서 이 패턴을 사용하는 것이 권장됩니다."

#: src/ch99-03-security-considerations.md:61
msgid ""
"The pattern consists of following a specific order of operations in your "
"functions:"
msgstr "패턴은 함수에서 특정 작업 순서를 따르는 것으로 구성됩니다:"

#: src/ch99-03-security-considerations.md:63
msgid ""
"**Checks**: Validate all conditions and inputs before performing any state "
"changes."
msgstr "**확인**: 상태 변경을 수행하기 전에 모든 조건과 입력을 확인하십시오."

#: src/ch99-03-security-considerations.md:64
msgid "**Effects**: Perform all state changes."
msgstr "**효과**: 모든 상태 변경을 수행합니다."

#: src/ch99-03-security-considerations.md:65
msgid ""
"**Interactions**: All external calls to other contracts should be made at "
"the end of the function."
msgstr "**상호 작용**: 다른 계약에 대한 모든 외부 호출은 함수의 끝에서 이루어져야 합니다."

#: src/ch99-03-security-considerations.md:67
msgid "Access control"
msgstr "접근 제어"

#: src/ch99-03-security-considerations.md:69
msgid ""
"Access control is the process of restricting access to certain features or "
"resources. It is a common security mechanism used to prevent unauthorized "
"access to sensitive information or actions. In smart contracts, some "
"functions may often be restricted to specific users or roles."
msgstr ""
"접근 제어는 특정 기능 또는 자원에 대한 액세스를 제한하는 프로세스입니다. 민감한 정보나 작업에 대한 무단 액세스를 방지하는 데 사용되는"
" 일반적인 보안 메커니즘입니다. 스마트 계약에서는 특정 사용자나 역할에게 자주 특정 기능이 제한될 수 있습니다."

#: src/ch99-03-security-considerations.md:71
msgid ""
"You can implement the access control pattern to easily manage permissions. "
"This pattern consists of defining a set of roles and assigning them to "
"specific users. Each function can then be restricted to specific roles."
msgstr ""
"액세스 제어 패턴을 구현하여 권한을 쉽게 관리할 수 있습니다. 이 패턴은 일련의 역할을 정의하고 이를 특정 사용자에게 할당하는 것으로 "
"구성됩니다. 각 기능은 그런 다음 특정 역할로 제한될 수 있습니다."

#: src/ch99-03-security-considerations.md:92
msgid "// Role 'owner': only one address\n"
msgstr "역할 '소유자': 하나의 주소만"

#: src/ch99-03-security-considerations.md:94
msgid "// Role 'role_a': a set of addresses\n"
msgstr "'role_a' 역할: 주소 집합"

#: src/ch99-03-security-considerations.md:103
msgid "// Guard functions to check roles\n"
msgstr "역할을 확인하는 가드 함수들"

#: src/ch99-03-security-considerations.md:118
msgid "\"Not owner\""
msgstr "\"소유주가 아님\""

#: src/ch99-03-security-considerations.md:123
msgid "\"Not role A\""
msgstr "\"역할 A가 아님\""

#: src/ch99-03-security-considerations.md:126
msgid "// You can easily combine guards to perform complex checks\n"
msgstr "// 복잡한 검사를 수행하기 위해 가드를 쉽게 결합할 수 있습니다."

#: src/ch99-03-security-considerations.md:128
msgid "\"Not allowed\""
msgstr "\"허용되지 않음\""

#: src/ch99-03-security-considerations.md:131
msgid "// Functions to manage roles\n"
msgstr "역할을 관리하는 함수들"

#: src/ch99-03-security-considerations.md:138
msgid ""
"// You can now focus on the business logic of your contract\n"
"        // and reduce the complexity of your code by using guard functions\n"
msgstr "이제 계약의 비즈니스 로직에 집중할 수 있으며 가드 함수를 사용하여 코드의 복잡성을 줄일 수 있습니다."

#: src/ch99-03-security-considerations.md:155
msgid "Static analysis tool"
msgstr "정적 분석 도구"

#: src/ch99-03-security-considerations.md:157
msgid ""
"Static analysis refers to the process of examining code without its "
"execution, focusing on its structure, syntax, and properties. It involves "
"analyzing the source code to identify potential issues, vulnerabilities, or "
"violations of specified rules."
msgstr ""
"정적 분석은 코드를 실행하지 않고 구조, 구문 및 속성에 중점을 두고 검사하는 과정을 의미합니다. 소스 코드를 분석하여 잠재적인 문제, "
"취약점 또는 지정된 규칙의 위반을 식별하는 것을 포함합니다."

#: src/ch99-03-security-considerations.md:159
msgid ""
"By defining rules, such as coding conventions or security guidelines, "
"developers can utilize static analysis tools to automatically check the code"
" against these standards."
msgstr ""
"규칙을 정의함으로써 코딩 규칙이나 보안 지침과 같은 것들을 개발자들은 정적 분석 도구를 활용하여 코드를 이러한 표준에 자동으로 확인할 수"
" 있습니다."

#: src/ch99-03-security-considerations.md:161
msgid "Reference:"
msgstr "참조:"

#: src/ch99-03-security-considerations.md:163
msgid ""
"[Semgrep Cairo 1.0 support](https://semgrep.dev/blog/2023/semgrep-now-"
"supports-cairo-1-0)"
msgstr ""
"[Semgrep Cairo 1.0 지원](https://semgrep.dev/blog/2023/semgrep-now-supports-"
"cairo-1-0)"

#: src/ch99-03-security-considerations.md:164
msgid ""
"[Caracal, a Starknet static analyzer](https://github.com/crytic/caracal)"
msgstr "[Caracal, 스타크넷 정적 분석기](https://github.com/crytic/caracal)"

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your Cairo journey."
msgstr "다음 섹션에는 카이로 여행에서 유용하게 활용할 수 있는 참고 자료가 포함되어 있습니다."

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr "부록 A: 키워드"

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future"
" use by the Cairo language."
msgstr "다음 목록에는 카이로 언어에서 현재 또는 미래에 사용할 예약어가 포함되어 있습니다."

#: src/appendix-01-keywords.md:6
msgid "There are two keyword categories:"
msgstr "두 가지 키워드 카테고리가 있습니다."

#: src/appendix-01-keywords.md:8
msgid "strict"
msgstr "엄격한"

#: src/appendix-01-keywords.md:9
msgid "reserved"
msgstr "예약된"

#: src/appendix-01-keywords.md:11
msgid ""
"There is a third category, which are functions from the core library. While "
"their names are not reserved, they are not recommended to be used as names "
"of any items to follow good practices."
msgstr ""
"세 번째 카테고리는 코어 라이브러리에서 가져온 함수들입니다. 이들의 이름은 예약되어 있지 않지만, 좋은 관행을 따르기 위해 어떤 항목의 "
"이름으로 사용하는 것은 권장되지 않습니다."

#: src/appendix-01-keywords.md:16
msgid "Strict keywords"
msgstr "엄격한 키워드"

#: src/appendix-01-keywords.md:18
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as names of any items."
msgstr "이 키워드들은 올바른 맥락에서만 사용될 수 있습니다. 어떤 항목의 이름으로 사용될 수 없습니다."

#: src/appendix-01-keywords.md:21
msgid "`as` - Rename import"
msgstr "`as` - import 이름 바꾸기"

#: src/appendix-01-keywords.md:22
msgid "`break` - Exit a loop immediately"
msgstr "`break` - 루프를 즉시 종료합니다"

#: src/appendix-01-keywords.md:23
msgid "`const` - Define constant items"
msgstr "`const` - 상수 항목 정의"

#: src/appendix-01-keywords.md:24
msgid "`continue` - Continue to the next loop iteration"
msgstr "`계속` - 다음 루프 반복으로 이동합니다"

#: src/appendix-01-keywords.md:25
msgid "`else` - Fallback for `if` and `if let` control flow constructs"
msgstr "`else` - `if` 및 `if let` 제어 흐름 구조의 대체 옵션"

#: src/appendix-01-keywords.md:26
msgid "`enum` - Define an enumeration"
msgstr "`enum` - 열거형을 정의합니다."

#: src/appendix-01-keywords.md:27
msgid ""
"`extern` - Function defined at the compiler level using hint available at "
"cairo1 level with this declaration"
msgstr "`extern` - 이 선언을 사용하여 컴파일러 수준에서 cairo1 레벨 힌트를 사용하여 정의된 함수"

#: src/appendix-01-keywords.md:28
msgid "`false` - Boolean false literal"
msgstr "`false` - 부울 false 리터럴"

#: src/appendix-01-keywords.md:29
msgid "`fn` - Define a function"
msgstr "`fn` - 함수를 정의합니다"

#: src/appendix-01-keywords.md:30
msgid "`if` - Branch based on the result of a conditional expression"
msgstr "`if` - 조건식의 결과에 따라 분기함"

#: src/appendix-01-keywords.md:31
msgid "`impl` - Implement inherent or trait functionality"
msgstr "`impl` - 상속 또는 트레이트 기능 구현"

#: src/appendix-01-keywords.md:32
msgid ""
"`implicits` - Special kind of function parameters that are required to "
"perform certain actions"
msgstr "`implicits` - 특정 작업을 수행하는 데 필요한 특별한 종류의 함수 매개변수"

#: src/appendix-01-keywords.md:33
msgid "`let` - Bind a variable"
msgstr "`let` - 변수를 바인딩합니다."

#: src/appendix-01-keywords.md:34
msgid "`loop` - Loop unconditionally"
msgstr "`loop` - 무조건 반복하기"

#: src/appendix-01-keywords.md:35
msgid "`match` - Match a value to patterns"
msgstr "`match` - 값과 패턴을 매칭합니다."

#: src/appendix-01-keywords.md:36
msgid "`mod` - Define a module"
msgstr "`mod` - 모듈을 정의합니다."

#: src/appendix-01-keywords.md:37
msgid "`mut` - Denote variable mutability"
msgstr "`mut` - 변수의 가변성을 나타냅니다"

#: src/appendix-01-keywords.md:38
msgid ""
"`nopanic` - Functions marked with this notation mean that the function will "
"never panic."
msgstr "`nopanic` - 이 표기가 있는 함수는 해당 함수가 절대로 패닉하지 않음을 의미합니다."

#: src/appendix-01-keywords.md:39
msgid "`of` - Implement a trait"
msgstr "`of` - 특성 구현"

#: src/appendix-01-keywords.md:40
msgid "`ref` - Parameter passed implicitly returned at the end of a function"
msgstr "`ref` - 함수 끝에 암시적으로 전달된 매개변수가 반환됩니다."

#: src/appendix-01-keywords.md:41
msgid "`return` - Return from function"
msgstr "`return` - 함수에서 반환"

#: src/appendix-01-keywords.md:42
msgid "`struct` - Define a structure"
msgstr "`struct` - 구조체를 정의합니다."

#: src/appendix-01-keywords.md:43
msgid "`trait` - Define a trait"
msgstr "`trait` - 특성 정의"

#: src/appendix-01-keywords.md:44
msgid "`true` - Boolean true literal"
msgstr "`true` - 부울 참 리터럴"

#: src/appendix-01-keywords.md:45
msgid "`type` - Define a type alias"
msgstr "`type` - 타입 별칭을 정의합니다."

#: src/appendix-01-keywords.md:46
msgid "`use` - Bring symbols into scope"
msgstr "`use` - 심볼을 범위에 포함하기"

#: src/appendix-01-keywords.md:50
msgid "Reserved keywords"
msgstr "예약어"

#: src/appendix-01-keywords.md:52
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Cairo by"
" forbidding them to use these keywords."
msgstr ""
"이 키워드들은 아직 사용되지 않았지만, 미래 사용을 위해 예약되어 있습니다. 이들은 엄격한 키워드와 동일한 제한을 가지고 있습니다. "
"이것의 이유는 현재 프로그램들이 미래 버전의 Cairo와 호환되도록 하기 위해 이 키워드들을 사용하지 못하도록 금지하는 것입니다."

#: src/appendix-01-keywords.md:57
msgid "`Self`"
msgstr ""

#: src/appendix-01-keywords.md:58
msgid "`assert`"
msgstr ""

#: src/appendix-01-keywords.md:59
msgid "`do`"
msgstr ""

#: src/appendix-01-keywords.md:60
msgid "`dyn`"
msgstr ""

#: src/appendix-01-keywords.md:61
msgid "`for`"
msgstr ""

#: src/appendix-01-keywords.md:62
msgid "`hint`"
msgstr ""

#: src/appendix-01-keywords.md:63
msgid "`in`"
msgstr ""

#: src/appendix-01-keywords.md:64
msgid "`macro`"
msgstr ""

#: src/appendix-01-keywords.md:65
msgid "`move`"
msgstr ""

#: src/appendix-01-keywords.md:66
msgid "`pub`"
msgstr ""

#: src/appendix-01-keywords.md:67
msgid "`static_assert`"
msgstr ""

#: src/appendix-01-keywords.md:68
msgid "`self`"
msgstr ""

#: src/appendix-01-keywords.md:69
msgid "`static`"
msgstr ""

#: src/appendix-01-keywords.md:70
msgid "`super`"
msgstr ""

#: src/appendix-01-keywords.md:71
msgid "`try`"
msgstr ""

#: src/appendix-01-keywords.md:72
msgid "`typeof`"
msgstr ""

#: src/appendix-01-keywords.md:73
msgid "`unsafe`"
msgstr ""

#: src/appendix-01-keywords.md:74
msgid "`where`"
msgstr ""

#: src/appendix-01-keywords.md:75
msgid "`while`"
msgstr "``"

#: src/appendix-01-keywords.md:76
msgid "`with`"
msgstr ""

#: src/appendix-01-keywords.md:77
msgid "`yield`"
msgstr ""

#: src/appendix-01-keywords.md:81
msgid "Built-in functions"
msgstr ""

#: src/appendix-01-keywords.md:83
msgid ""
"The Cairo programming language provides several specific functions that "
"serve a special purpose. We will not cover all of them in this book, but "
"using the names of these functions as names of other items is not "
"recommended."
msgstr ""
"카이로 프로그래밍 언어는 특정 목적을 위한 여러 가지 특정 기능을 제공합니다. 이 책에서는 모든 기능을 다 다루지는 않겠지만, 이러한 "
"기능들의 이름을 다른 항목의 이름으로 사용하는 것은 권장되지 않습니다."

#: src/appendix-01-keywords.md:85
msgid ""
"\\-`assert` - This function checks a boolean expression, and if it evaluates"
" to false, it triggers the panic function. -`panic` - This function "
"terminates the program."
msgstr ""
"\\- `assert` - 이 함수는 부울 표현식을 확인하고, 그 값이 거짓이면 패닉 함수를 트리거합니다. - `panic` - 이 "
"함수는 프로그램을 종료합니다."

#: src/appendix-02-operators-and-symbols.md:1
msgid "Appendix B: Operators and Symbols"
msgstr "부록 B: 연산자 및 기호"

#: src/appendix-02-operators-and-symbols.md:3
msgid "This appendix includes a glossary of Cairo's syntax."
msgstr "이 부록에는 카이로 구문의 용어 해설이 포함되어 있습니다."

#: src/appendix-02-operators-and-symbols.md:5
msgid "Operators"
msgstr "연산자"

#: src/appendix-02-operators-and-symbols.md:7
msgid ""
"Table B-1 contains the operators in Cairo, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr ""
"표 B-1에는 카이로의 연산자, 연산자가 어떻게 문맥에서 나타나는지의 예시, 간단한 설명, 그리고 해당 연산자가 오버로드 가능한지 여부가"
" 포함되어 있습니다. 연산자가 오버로드 가능한 경우, 해당 연산자를 오버로드하는 데 사용할 수 있는 관련 특성이 나열되어 있습니다."

#: src/appendix-02-operators-and-symbols.md:9
msgid "Table B-1: Operators"
msgstr "표 B-1: 연산자"

#: src/appendix-02-operators-and-symbols.md:11
msgid "Operator"
msgstr "운영자"

#: src/appendix-02-operators-and-symbols.md:11
#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
#: src/appendix-02-operators-and-symbols.md:120
msgid "Explanation"
msgstr "설명"

#: src/appendix-02-operators-and-symbols.md:11
msgid "Overloadable?"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "`!expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
msgid "Logical complement"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:13
#: src/appendix-02-operators-and-symbols.md:14
msgid "`Not`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~`"
msgstr "`~`"

#: src/appendix-02-operators-and-symbols.md:14
msgid "`~expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:14
msgid "Bitwise NOT"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`!=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "`expr != expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
msgid "Non-equality comparison"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:15
#: src/appendix-02-operators-and-symbols.md:40
msgid "`PartialEq`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`%`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`expr % expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "Arithmetic remainder"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:16
msgid "`Rem`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`%=`"
msgstr "`%=`"

#: src/appendix-02-operators-and-symbols.md:17
msgid "`var %= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "Arithmetic remainder and assignment"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:17
msgid "`RemEq`"
msgstr "`RemEq`"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`&`"
msgstr "`&`"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`expr & expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:18
msgid "Bitwise AND"
msgstr "비트 AND"

#: src/appendix-02-operators-and-symbols.md:18
msgid "`BitAnd`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:19
msgid "`&&`"
msgstr "`&&`"

#: src/appendix-02-operators-and-symbols.md:19
msgid "`expr && expr`"
msgstr "`expr && expr`"

#: src/appendix-02-operators-and-symbols.md:19
msgid "Short-circuiting logical AND"
msgstr "논리 AND의 단락 회로(short-circuiting)"

#: src/appendix-02-operators-and-symbols.md:20
#: src/appendix-02-operators-and-symbols.md:23
msgid "`*`"
msgstr "`*` "

#: src/appendix-02-operators-and-symbols.md:20
msgid "`expr * expr`"
msgstr "`expr * expr`"

#: src/appendix-02-operators-and-symbols.md:20
msgid "Arithmetic multiplication"
msgstr "산술 곱셈"

#: src/appendix-02-operators-and-symbols.md:20
msgid "`Mul`"
msgstr "`물`"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`*=`"
msgstr "`*=` "

#: src/appendix-02-operators-and-symbols.md:21
msgid "`var *= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:21
msgid "Arithmetic multiplication and assignment"
msgstr "산술 곱셈 및 할당"

#: src/appendix-02-operators-and-symbols.md:21
msgid "`MulEq`"
msgstr "`MulEq`"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@`"
msgstr "`@`"

#: src/appendix-02-operators-and-symbols.md:22
msgid "`@var`"
msgstr "`@var`"

#: src/appendix-02-operators-and-symbols.md:22
msgid "Snapshot"
msgstr "스냅샷"

#: src/appendix-02-operators-and-symbols.md:23
msgid "`*var`"
msgstr "`*var`"

#: src/appendix-02-operators-and-symbols.md:23
msgid "Desnap"
msgstr "Desnap -> 디스냅"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`+`"
msgstr "`+`"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`expr + expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:24
msgid "Arithmetic addition"
msgstr "산술 덧셈"

#: src/appendix-02-operators-and-symbols.md:24
msgid "`Add`"
msgstr "추가하기"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`+=`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:25
msgid "`var += expr`"
msgstr "`var += expr` -> `var += expr`"

#: src/appendix-02-operators-and-symbols.md:25
msgid "Arithmetic addition and assignment"
msgstr "산술 덧셈 및 할당"

#: src/appendix-02-operators-and-symbols.md:25
msgid "`AddEq`"
msgstr "`AddEq`"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`,`"
msgstr "`,`"

#: src/appendix-02-operators-and-symbols.md:26
msgid "`expr, expr`"
msgstr "`expr, expr`"

#: src/appendix-02-operators-and-symbols.md:26
msgid "Argument and element separator"
msgstr "논거 및 요소 구분자"

#: src/appendix-02-operators-and-symbols.md:27
#: src/appendix-02-operators-and-symbols.md:28
msgid "`-`"
msgstr ""
"There is no text to translate in your message. If you provide me with the "
"text you would like me to translate into Korean, I would be happy to assist "
"you."

#: src/appendix-02-operators-and-symbols.md:27
msgid "`-expr`"
msgstr "`-expr` translates to `-식` in Korean."

#: src/appendix-02-operators-and-symbols.md:27
msgid "Arithmetic negation"
msgstr "산술 부정"

#: src/appendix-02-operators-and-symbols.md:27
msgid "`Neg`"
msgstr "부정"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`expr - expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:28
msgid "Arithmetic subtraction"
msgstr "산술 뺄셈"

#: src/appendix-02-operators-and-symbols.md:28
msgid "`Sub`"
msgstr "서브"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`-=`"
msgstr "`-=` "

#: src/appendix-02-operators-and-symbols.md:29
msgid "`var -= expr`"
msgstr "`var -= expr` 는 변수에서 표현식을 빼는 연산자입니다."

#: src/appendix-02-operators-and-symbols.md:29
msgid "Arithmetic subtraction and assignment"
msgstr "산술 뺄셈 및 할당"

#: src/appendix-02-operators-and-symbols.md:29
msgid "`SubEq`"
msgstr "`SubEq` translates to `서브 동일` in Korean."

#: src/appendix-02-operators-and-symbols.md:30
msgid "`->`"
msgstr "`->` "

#: src/appendix-02-operators-and-symbols.md:30
msgid "`fn(...) -> type`, "
msgstr ""

#: src/appendix-02-operators-and-symbols.md:30
msgid "\\|...\\| -> type"
msgstr "\\|...\\| -> 유형"

#: src/appendix-02-operators-and-symbols.md:30
msgid "Function and closure return type"
msgstr "기능과 클로저 반환 유형"

#: src/appendix-02-operators-and-symbols.md:31
msgid "`.`"
msgstr ""
"I'm sorry, but the text \".\" does not have a specific meaning or context to"
" be translated into Korean. If you provide more context or a complete "
"sentence, I would be happy to help you with the translation."

#: src/appendix-02-operators-and-symbols.md:31
msgid "`expr.ident`"
msgstr "`expr.ident` translates to `식별자` in Korean."

#: src/appendix-02-operators-and-symbols.md:31
msgid "Member access"
msgstr "회원 액세스"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`/`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "`expr / expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:32
msgid "Arithmetic division"
msgstr "산술 나눗셈"

#: src/appendix-02-operators-and-symbols.md:32
msgid "`Div`"
msgstr "`Div`"

#: src/appendix-02-operators-and-symbols.md:33
msgid "`/=`"
msgstr "`/=` 는 \"나누기 후 할당\"을 나타냅니다."

#: src/appendix-02-operators-and-symbols.md:33
msgid "`var /= expr`"
msgstr "`var /= expr`"

#: src/appendix-02-operators-and-symbols.md:33
msgid "Arithmetic division and assignment"
msgstr "산술 나눗셈 및 할당"

#: src/appendix-02-operators-and-symbols.md:33
msgid "`DivEq`"
msgstr "`DivEq` would be translated to `분배 등호` in Korean."

#: src/appendix-02-operators-and-symbols.md:34
#: src/appendix-02-operators-and-symbols.md:35
msgid "`:`"
msgstr ""
"`:`\n"
"\n"
"`:`"

#: src/appendix-02-operators-and-symbols.md:34
msgid "`pat: type`, `ident: type`"
msgstr "`pat: 유형`, `ident: 유형`"

#: src/appendix-02-operators-and-symbols.md:34
msgid "Constraints"
msgstr "제약사항"

#: src/appendix-02-operators-and-symbols.md:35
msgid "`ident: expr`"
msgstr "`식별자: 표현식`"

#: src/appendix-02-operators-and-symbols.md:35
msgid "Struct field initializer"
msgstr "구조체 필드 초기화자"

#: src/appendix-02-operators-and-symbols.md:36
msgid "`;`"
msgstr "`;` 는 세미콜론이라고 합니다."

#: src/appendix-02-operators-and-symbols.md:36
msgid "`expr;`"
msgstr "`expr;` "

#: src/appendix-02-operators-and-symbols.md:36
msgid "Statement and item terminator"
msgstr "문장 및 항목 종결자"

#: src/appendix-02-operators-and-symbols.md:37
msgid "`<`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:37
msgid "`expr < expr`"
msgstr "`expr < expr`"

#: src/appendix-02-operators-and-symbols.md:37
msgid "Less than comparison"
msgstr "미만 비교"

#: src/appendix-02-operators-and-symbols.md:37
#: src/appendix-02-operators-and-symbols.md:38
#: src/appendix-02-operators-and-symbols.md:42
#: src/appendix-02-operators-and-symbols.md:43
msgid "`PartialOrd`"
msgstr "부분 순서 (Partial Order)"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`<=`"
msgstr "`<=`"

#: src/appendix-02-operators-and-symbols.md:38
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:38
msgid "Less than or equal to comparison"
msgstr "작거나 같음 비교"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`=`"
msgstr "`=`"

#: src/appendix-02-operators-and-symbols.md:39
msgid "`var = expr`"
msgstr "`var = expr`"

#: src/appendix-02-operators-and-symbols.md:39
msgid "Assignment"
msgstr "과제"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`==`"
msgstr "`==`"

#: src/appendix-02-operators-and-symbols.md:40
msgid "`expr == expr`"
msgstr "`expr == expr`"

#: src/appendix-02-operators-and-symbols.md:40
msgid "Equality comparison"
msgstr "동등 비교"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`=>`"
msgstr "`=>`"

#: src/appendix-02-operators-and-symbols.md:41
msgid "`pat => expr`"
msgstr "`pat => expr` "

#: src/appendix-02-operators-and-symbols.md:41
msgid "Part of match arm syntax"
msgstr "매치 암 구문의 일부"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`>`"
msgstr "`>`"

#: src/appendix-02-operators-and-symbols.md:42
msgid "`expr > expr`"
msgstr "`expr > expr`"

#: src/appendix-02-operators-and-symbols.md:42
msgid "Greater than comparison"
msgstr "크기 비교"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`>=`"
msgstr "`>=`"

#: src/appendix-02-operators-and-symbols.md:43
msgid "`expr >= expr`"
msgstr "`expr >= expr` would be translated to `expr >= expr` in Korean."

#: src/appendix-02-operators-and-symbols.md:43
msgid "Greater than or equal to comparison"
msgstr "크거나 같음 비교"

#: src/appendix-02-operators-and-symbols.md:44
msgid "`^`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:44
msgid "`expr ^ expr`"
msgstr "`expr ^ expr`"

#: src/appendix-02-operators-and-symbols.md:44
msgid "Bitwise exclusive OR"
msgstr "바이트 단위 배타적 OR"

#: src/appendix-02-operators-and-symbols.md:44
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "\\|"
msgstr ""
"\\| "

#: src/appendix-02-operators-and-symbols.md:45
msgid "expr \\| expr"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:45
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:46
msgid "\\|\\|"
msgstr "\\|\\|"

#: src/appendix-02-operators-and-symbols.md:46
msgid "expr \\|\\| expr"
msgstr "표현식 \\|\\| 표현식"

#: src/appendix-02-operators-and-symbols.md:46
msgid "Short-circuiting logical OR"
msgstr "논리 OR의 단락 회로(short-circuiting)"

#: src/appendix-02-operators-and-symbols.md:47
msgid "`?`"
msgstr ""
"I'm sorry, but the text you provided is a question mark, which does not have"
" a specific meaning to translate. If you have any other text or questions "
"you would like me to translate into Korean, please feel free to ask."

#: src/appendix-02-operators-and-symbols.md:47
msgid "expr?"
msgstr "표현?"

#: src/appendix-02-operators-and-symbols.md:47
msgid "Error propagation"
msgstr "오차 전파"

#: src/appendix-02-operators-and-symbols.md:49
msgid "Non Operator Symbols"
msgstr "비 운영자 기호"

#: src/appendix-02-operators-and-symbols.md:51
msgid ""
"The following list contains all symbols that are not used as operators; that"
" is, they do not have the same behavior as a function or method call."
msgstr ""
"다음 목록은 연산자로 사용되지 않는 모든 기호를 포함하고 있습니다. 즉, 이들은 함수나 메소드 호출과 같은 동작을 하지 않습니다."

#: src/appendix-02-operators-and-symbols.md:53
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr "표 B-2는 독립적으로 나타나며 다양한 위치에서 유효한 기호를 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:55
msgid "Table B-2: Stand-Alone Syntax"
msgstr "표 B-2: 독립 구문"

#: src/appendix-02-operators-and-symbols.md:57
#: src/appendix-02-operators-and-symbols.md:67
#: src/appendix-02-operators-and-symbols.md:77
#: src/appendix-02-operators-and-symbols.md:90
#: src/appendix-02-operators-and-symbols.md:98
#: src/appendix-02-operators-and-symbols.md:106
msgid "Symbol"
msgstr "상징"

#: src/appendix-02-operators-and-symbols.md:59
msgid "`..._u8`, `..._usize`, etc."
msgstr "`..._u8`, `..._usize` 등."

#: src/appendix-02-operators-and-symbols.md:59
msgid "Numeric literal of specific type"
msgstr "특정 유형의 숫자 리터럴"

#: src/appendix-02-operators-and-symbols.md:60
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:60
msgid "Short string"
msgstr "짧은 문자열"

#: src/appendix-02-operators-and-symbols.md:61
msgid "`_`"
msgstr "There is no text provided for translation."

#: src/appendix-02-operators-and-symbols.md:61
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr "\"무시된\" 패턴 바인딩; 또한 정수 리터럴을 읽기 쉽게 만드는 데 사용됩니다."

#: src/appendix-02-operators-and-symbols.md:63
msgid ""
"Table B-3 shows symbols that are used within the context of a module "
"hierarchy path to access an item."
msgstr "표 B-3은 모듈 계층 구조 경로 내에서 항목에 액세스하는 데 사용되는 기호를 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:65
msgid "Table B-3: Path-Related Syntax"
msgstr "표 B-3: 경로 관련 구문"

#: src/appendix-02-operators-and-symbols.md:69
msgid "`ident::ident`"
msgstr "`ident::ident`"

#: src/appendix-02-operators-and-symbols.md:69
msgid "Namespace path"
msgstr "네임스페이스 경로"

#: src/appendix-02-operators-and-symbols.md:70
msgid "`super::path`"
msgstr "`슈퍼::패스`"

#: src/appendix-02-operators-and-symbols.md:70
msgid "Path relative to the parent of the current module"
msgstr "현재 모듈의 부모에 대한 상대 경로"

#: src/appendix-02-operators-and-symbols.md:71
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:71
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr "메소드 호출을 명명하여 그것을 정의하는 트레이트를 구분하는 것"

#: src/appendix-02-operators-and-symbols.md:73
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr "테이블 B-4는 일반 유형 매개변수를 사용하는 맥락에서 나타나는 기호를 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:75
msgid "Table B-4: Generics"
msgstr "표 B-4: 일반적인 것들"

#: src/appendix-02-operators-and-symbols.md:79
msgid "`path<...>`"
msgstr "경로<...>"

#: src/appendix-02-operators-and-symbols.md:79
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr "일반 유형에 매개변수를 지정합니다 (예: `Vec<u8>`)."

#: src/appendix-02-operators-and-symbols.md:80
msgid "`path::<...>`, `method::<...>`"
msgstr "`path::<...>`, `method::<...>`"

#: src/appendix-02-operators-and-symbols.md:80
msgid ""
"Specifies parameters to a generic type, function, or method in an "
"expression; often referred to as turbofish"
msgstr "식에서 일반 유형, 함수 또는 메서드에 매개변수를 지정합니다. 종종 turbofish로 불립니다."

#: src/appendix-02-operators-and-symbols.md:81
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:81
msgid "Define generic function"
msgstr "일반 함수를 정의하다"

#: src/appendix-02-operators-and-symbols.md:82
msgid "`struct ident<...> ...`"
msgstr "`구조체 식별자<...> ...`"

#: src/appendix-02-operators-and-symbols.md:82
msgid "Define generic structure"
msgstr "일반적인 구조를 정의하다"

#: src/appendix-02-operators-and-symbols.md:83
msgid "`enum ident<...> ...`"
msgstr "`열거형 식별자<...> ...`"

#: src/appendix-02-operators-and-symbols.md:83
msgid "Define generic enumeration"
msgstr "일반적인 열거형을 정의하세요."

#: src/appendix-02-operators-and-symbols.md:84
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:84
msgid "Define generic implementation"
msgstr "일반 구현을 정의하십시오."

#: src/appendix-02-operators-and-symbols.md:86
msgid ""
"Table B-5 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr "표 B-5는 매크로 호출 또는 정의 및 항목에 속성을 지정하는 맥락에서 나타나는 기호를 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:88
msgid "Table B-5: Macros and Attributes"
msgstr "표 B-5: 매크로 및 속성"

#: src/appendix-02-operators-and-symbols.md:92
msgid "`#[meta]`"
msgstr "`#[meta]` "

#: src/appendix-02-operators-and-symbols.md:92
msgid "Outer attribute"
msgstr "외부 속성"

#: src/appendix-02-operators-and-symbols.md:94
msgid "Table B-6 shows symbols that create comments."
msgstr "표 B-6에는 주석을 작성하는 데 사용되는 기호가 나와 있습니다."

#: src/appendix-02-operators-and-symbols.md:96
msgid "Table B-6: Comments"
msgstr "표 B-6: 코멘트"

#: src/appendix-02-operators-and-symbols.md:100
msgid "`//`"
msgstr "`//`"

#: src/appendix-02-operators-and-symbols.md:100
msgid "Line comment"
msgstr "라인 주석"

#: src/appendix-02-operators-and-symbols.md:102
msgid "Table B-7 shows symbols that appear in the context of using tuples."
msgstr "테이블 B-7은 튜플을 사용하는 맥락에서 나타나는 기호를 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:104
msgid "Table B-7: Tuples"
msgstr "표 B-7: 튜플"

#: src/appendix-02-operators-and-symbols.md:108
msgid "`()`"
msgstr ""
"There is no text to translate in the provided input. Could you please "
"provide me with the English text you would like me to translate to Korean?"

#: src/appendix-02-operators-and-symbols.md:108
msgid "Empty tuple (aka unit), both literal and type"
msgstr "빈 튜플 (일명 유닛), 리터럴과 타입"

#: src/appendix-02-operators-and-symbols.md:109
msgid "`(expr)`"
msgstr "`(식)`"

#: src/appendix-02-operators-and-symbols.md:109
msgid "Parenthesized expression"
msgstr "괄호로 묶인 표현"

#: src/appendix-02-operators-and-symbols.md:110
msgid "`(expr,)`"
msgstr "`(식,)`"

#: src/appendix-02-operators-and-symbols.md:110
msgid "Single-element tuple expression"
msgstr "단일 요소 튜플 표현식"

#: src/appendix-02-operators-and-symbols.md:111
msgid "`(type,)`"
msgstr "`(유형,)`"

#: src/appendix-02-operators-and-symbols.md:111
msgid "Single-element tuple type"
msgstr "단일 요소 튜플 유형"

#: src/appendix-02-operators-and-symbols.md:112
msgid "`(expr, ...)`"
msgstr "`(표현식, ...)`"

#: src/appendix-02-operators-and-symbols.md:112
msgid "Tuple expression"
msgstr "튜플 표현식"

#: src/appendix-02-operators-and-symbols.md:113
msgid "`(type, ...)`"
msgstr "`(유형, ...)`"

#: src/appendix-02-operators-and-symbols.md:113
msgid "Tuple type"
msgstr "튜플 유형"

#: src/appendix-02-operators-and-symbols.md:114
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators-and-symbols.md:114
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr "함수 호출 표현식; 또한 튜플 '구조체' 및 튜플 '열거형' 변수를 초기화하는 데 사용됩니다."

#: src/appendix-02-operators-and-symbols.md:116
msgid "Table B-8 shows the contexts in which curly braces are used."
msgstr "표 B-8은 중괄호가 사용되는 맥락을 보여줍니다."

#: src/appendix-02-operators-and-symbols.md:118
msgid "Table B-8: Curly Brackets"
msgstr "표 B-8: 중괄호"

#: src/appendix-02-operators-and-symbols.md:120
msgid "Context"
msgstr "문맥"

#: src/appendix-02-operators-and-symbols.md:122
msgid "`{...}`"
msgstr "`{...}`"

#: src/appendix-02-operators-and-symbols.md:122
msgid "Block expression"
msgstr "표현 차단"

#: src/appendix-02-operators-and-symbols.md:123
msgid "`Type {...}`"
msgstr "`입력하세요 {...}`"

#: src/appendix-02-operators-and-symbols.md:123
msgid "`struct` literal"
msgstr "`struct` 리터럴"

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr "부록 C: 유도 가능한 특성"

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which"
" you can apply to a struct or enum definition. The `derive` attribute "
"generates code to implement a default trait on the type you’ve annotated "
"with the `derive` syntax."
msgstr ""
"책의 여러 곳에서 `derive` 속성에 대해 논의했는데, 이는 구조체 또는 열거형 정의에 적용할 수 있습니다. `derive` 속성은 "
"`derive` 구문으로 주석을 달아 놓은 유형에 대한 기본 트레이트를 구현하는 코드를 생성합니다."

#: src/appendix-03-derivable-traits.md:5
msgid ""
"In this appendix, we provide a comprehensive reference detailing all the "
"traits in the standard library compatible with the `derive` attribute."
msgstr "본 부록에서는 `derive` 속성과 호환되는 표준 라이브러리의 모든 특성을 자세히 설명하는 종합 참조를 제공합니다."

#: src/appendix-03-derivable-traits.md:7
msgid ""
"These traits listed here are the only ones defined by the core library that "
"can be implemented on your types using `derive`. Other traits defined in the"
" standard library don’t have sensible default behavior, so it’s up to you to"
" implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""
"여기 나열된 이 특성들은 코어 라이브러리에서 정의된 유일한 특성들이며 `derive`를 사용하여 타입에 구현할 수 있습니다. 표준 "
"라이브러리에 정의된 다른 특성들은 합리적인 기본 동작이 없으므로, 당신이 달성하려는 목표에 맞게 구현하는 것이 중요합니다."

#: src/appendix-03-derivable-traits.md:9
msgid "Debug for Programmer Output"
msgstr "프로그래머 출력을 위한 디버깅"

#: src/appendix-03-derivable-traits.md:11
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""
"`Debug` 트레이트는 포맷 문자열에서 디버그 포맷팅을 가능하게 합니다. 이는 `{}` 자리 표시자 내에 `:?`를 추가하여 "
"표시합니다."

#: src/appendix-03-derivable-traits.md:13
msgid ""
"The `Debug` trait allows you to print instances of a type for debugging "
"purposes, so you and other programmers using your type can inspect an "
"instance at a particular point in a program’s execution."
msgstr ""
"`Debug` 트레이트는 디버깅 목적으로 타입의 인스턴스를 출력할 수 있도록 해줍니다. 따라서 당신과 당신의 타입을 사용하는 다른 "
"프로그래머들은 프로그램 실행 중 특정 시점에서 인스턴스를 검사할 수 있습니다."

#: src/appendix-03-derivable-traits.md:15
msgid ""
"The `Debug` trait is required, for example, in use of the `assert_eq!` "
"macro. This macro prints the values of instances given as arguments if the "
"equality assertion fails so programmers can see why the two instances "
"weren’t equal."
msgstr ""
"`Debug` 트레이트는 `assert_eq!` 매크로를 사용할 때 필요합니다. 이 매크로는 동등성 어설션에 실패한 경우 인수로 제공된 "
"인스턴스의 값을 출력하므로 프로그래머가 두 인스턴스가 동일하지 않은 이유를 볼 수 있습니다."

#: src/appendix-03-derivable-traits.md:17
msgid "PartialEq for equality comparison"
msgstr "동등 비교를 위한 PartialEq"

#: src/appendix-03-derivable-traits.md:19
msgid ""
"The `PartialEq` trait allows for comparison between instances of a type for "
"equality, thereby enabling the == and != operators."
msgstr ""
"`PartialEq` 트레이트는 동등성을 비교하기 위해 타입의 인스턴스 간에 사용되며, == 및 != 연산자를 가능하게 합니다."

#: src/appendix-03-derivable-traits.md:21
msgid ""
"When `PartialEq` is derived on structs, two instances are equal only if all "
"fields are equal, and the instances are not equal if any fields are not "
"equal. When derived on enums, each variant is equal to itself and not equal "
"to the other variants."
msgstr ""
"`PartialEq`가 구조체에 파생될 때 두 인스턴스는 모든 필드가 동일한 경우에만 동일하며, 어떤 필드가 동일하지 않은 경우에는 "
"인스턴스가 동일하지 않습니다. 열거형에 파생될 때 각 변형은 자신과 동일하며 다른 변형과는 동일하지 않습니다."

#: src/appendix-03-derivable-traits.md:23
msgid ""
"The `PartialEq` trait is required, for example, with the use of the "
"`assert_eq!` macro, which needs to be able to compare two instances of a "
"type for equality."
msgstr ""
"`PartialEq` 트레이트는 예를 들어 `assert_eq!` 매크로를 사용할 때 필요합니다. 이 매크로는 두 인스턴스를 동등성을 "
"비교할 수 있어야 합니다."

#: src/appendix-03-derivable-traits.md:44
msgid "Clone and Copy for Duplicating Values"
msgstr "값을 복제하고 복사하는 것에 대한 클론과 복사"

#: src/appendix-03-derivable-traits.md:46
msgid ""
"The `Clone` trait provides the functionality to explicitly create a deep "
"copy of a value."
msgstr "`Clone` 트레이트는 값의 깊은 복사를 명시적으로 생성하는 기능을 제공합니다."

#: src/appendix-03-derivable-traits.md:48
msgid ""
"Deriving `Clone` implements the `clone` method, which, in turn, calls clone "
"on each of the type's components. This means all the fields or values in the"
" type must also implement `Clone` to derive `Clone`."
msgstr ""
"`Clone`를 파생하는 것은 `clone` 메서드를 구현하는 것을 의미하며, 이 메서드는 차례로 해당 유형의 각 구성 요소에 대해 "
"clone을 호출합니다. 이는 유형의 모든 필드나 값도 `Clone`을 구현해야 한다는 것을 의미합니다."

#: src/appendix-03-derivable-traits.md:69
msgid ""
"The `Copy` trait allows for the duplication of values. You can derive `Copy`"
" on any type whose parts all implement `Copy`."
msgstr ""
"`Copy` 트레이트는 값의 복제를 허용합니다. `Copy`를 어떤 타입에도 파생시킬 수 있으며, 해당 타입의 모든 부분이 `Copy`를"
" 구현하는 경우입니다."

#: src/appendix-03-derivable-traits.md:85
msgid "// Copy Trait prevents firs_struct from moving into second_struct\n"
msgstr "// Copy Trait은 firs_struct가 second_struct로 이동되는 것을 방지합니다."

#: src/appendix-03-derivable-traits.md:89
msgid "Serializing with Serde"
msgstr "Serde를 사용하여 직렬화하기"

#: src/appendix-03-derivable-traits.md:91
msgid ""
"`Serde` provides trait implementations for `serialize` and `deserialize` "
"functions for data structures defined in your crate. It allows you to "
"transform your structure into an array (or the opposite)."
msgstr ""
"`Serde`는 크레이트에서 정의된 데이터 구조에 대한 `serialize` 및 `deserialize` 함수의 트레이트 구현을 "
"제공합니다. 이를 통해 구조체를 배열로 변환하거나 그 반대로 변환할 수 있습니다."

#: src/appendix-03-derivable-traits.md:116
msgid "Output:"
msgstr "출력:"

#: src/appendix-03-derivable-traits.md:119
msgid "''"
msgstr ""
"I'm sorry, but it seems like you haven't provided any text to be translated "
"into Korean. Please provide the text you would like me to translate."

#: src/appendix-03-derivable-traits.md:119
msgid "'c'"
msgstr "'c' -> '씨'"

#: src/appendix-03-derivable-traits.md:122
msgid ""
"We can see here that our struct A has been serialized into the output array."
msgstr "우리는 여기서 우리의 구조체 A가 출력 배열로 직렬화되었음을 볼 수 있습니다."

#: src/appendix-03-derivable-traits.md:124
msgid ""
"Also, we can use `deserialize` function to convert the serialized array back"
" into our A struct."
msgstr "또한, 우리는 `deserialize` 함수를 사용하여 직렬화된 배열을 다시 A 구조체로 변환할 수 있습니다."

#: src/appendix-03-derivable-traits.md:151
msgid ""
"Here we are converting a serialized array span back to the struct A. "
"`deserialize` returns an `Option` so we need to unwrap it. When using "
"deserialize we also need to specify the type we want to deserialize into."
msgstr ""
"여기에서는 직렬화된 배열 span을 구조체 A로 다시 변환하는 중입니다. `deserialize`는 `Option`을 반환하기 때문에 "
"언래핑이 필요합니다. deserialize를 사용할 때는 또한 어떤 유형으로 역직렬화할지 지정해주어야 합니다."

#: src/appendix-03-derivable-traits.md:153
msgid "Drop and Destruct"
msgstr "버리고 파괴하다"

#: src/appendix-03-derivable-traits.md:155
msgid ""
"When moving out of scope, variables need to be moved first. This is where "
"the `Drop` trait intervenes. You can find more details about its usage "
"[here](ch04-01-what-is-ownership.md#the-drop-trait)."
msgstr ""
"변수가 범위를 벗어날 때는 먼저 변수를 이동해야 합니다. 이것이 `Drop` 트레이트가 개입하는 곳입니다. 그 사용에 대한 자세한 내용은"
" [여기](ch04-01-what-is-ownership.md#the-drop-trait)에서 확인할 수 있습니다."

#: src/appendix-03-derivable-traits.md:157
msgid ""
"Moreover Dictionary need to be squashed before going out of scope. Calling "
"manually the `squash` method on each of them can be quickly redundant. "
"`Destruct` trait allows Dictionaries to be automatically squashed when they "
"get out of scope. You can also find more information about `Destruct` "
"[here](ch04-01-what-is-ownership.md#the-destruct-trait)."
msgstr ""
"게다가 사전은 범위를 벗어나기 전에 압축되어야 합니다. 각각에 수동으로 `squash` 메서드를 호출하는 것은 빠르게 중복될 수 "
"있습니다. `Destruct` 트레이트는 사전이 범위를 벗어날 때 자동으로 압축되도록 합니다. `Destruct`에 대한 자세한 정보는 "
"[여기](ch04-01-what-is-ownership.md#the-destruct-trait)에서 찾을 수 있습니다."

#: src/appendix-03-derivable-traits.md:159
msgid "Store"
msgstr "상점"

#: src/appendix-03-derivable-traits.md:161
msgid ""
"Storing a user-defined struct in a storage variable within a Starknet "
"contract requires the `Store` trait to be implemented for this type. You can"
" automatically derive the `store` trait for all structs that do not contain "
"complex types like Dictionaries or Arrays."
msgstr ""
"Starknet 계약 내에서 사용자 정의 구조체를 저장 변수에 저장하려면 해당 유형에 대해 `Store` 특성이 구현되어야 합니다. "
"딕셔너리나 배열과 같은 복잡한 유형을 포함하지 않는 모든 구조체에 대해 `store` 특성을 자동으로 파생시킬 수 있습니다."

#: src/appendix-03-derivable-traits.md:182
msgid ""
"Here we demonstrate the implementation of a `struct A` that derives the "
"Store trait. This `struct A` is subsequently used as a storage variable in "
"the contract."
msgstr ""
"여기에서는 Store 특성을 파생하는 'struct A'의 구현을 보여줍니다. 이 'struct A'는 이후 계약에서 저장 변수로 "
"사용됩니다."

#: src/appendix-03-derivable-traits.md:185
msgid "PartialOrd and Ord for Ordering Comparisons"
msgstr "부분 순서 및 순서를 위한 순서 비교"

#: src/appendix-03-derivable-traits.md:187
msgid ""
"In addition to the `PartialEq` trait, the standard library also provides the"
" `PartialOrd` and `Ord` traits to compare values for ordering."
msgstr ""
"표준 라이브러리는 `PartialEq` 트레이트 외에도 값의 순서를 비교하기 위한 `PartialOrd` 및 `Ord` 트레이트를 "
"제공합니다."

#: src/appendix-03-derivable-traits.md:189
msgid ""
"The `PartialOrd` trait allows for comparison between instances of a type for"
" ordering, thereby enabling the \\<, \\<=, >, and >= operators."
msgstr ""
"`PartialOrd` 트레이트는 유형의 인스턴스 간의 비교를 허용하여 \\<, \\<=, >, 그리고 >= 연산자를 가능하게 합니다."

#: src/appendix-03-derivable-traits.md:191
msgid ""
"When `PartialOrd` is derived on structs, two instances are ordered by "
"comparing each field in turn."
msgstr "`PartialOrd`가 구조체에 파생될 때 두 인스턴스는 각 필드를 차례대로 비교하여 정렬됩니다."

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr "부록 D - 유용한 개발 도구"

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Cairo"
" project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""
"본 부록에서는 카이로 프로젝트에서 제공하는 몇 가지 유용한 개발 도구에 대해 이야기합니다. 자동 서식 지정, 경고 수정을 쉽게 적용하는 "
"빠른 방법, 린터 및 IDE 통합을 살펴볼 것입니다."

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `scarb fmt`"
msgstr "`scarb fmt`를 사용한 자동 서식 지정"

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"Scarb projects can be formatted using the `scarb fmt` command. If you're "
"using the cairo binaries directly, you can run `cairo-format` instead. Many "
"collaborative projects use `scarb fmt` to prevent arguments about which "
"style to use when writing Cairo: everyone formats their code using the tool."
msgstr ""
"Scarb 프로젝트는 `scarb fmt` 명령을 사용하여 형식을 지정할 수 있습니다. 만약 cairo 이진 파일을 직접 사용 중이라면 "
"`cairo-format`을 대신 실행할 수 있습니다. 많은 협업 프로젝트에서는 Cairo를 작성할 때 어떤 스타일을 사용할지에 대한 "
"논쟁을 방지하기 위해 `scarb fmt`를 사용합니다: 모든 사람은 이 도구를 사용하여 코드를 형식화합니다."

#: src/appendix-04-useful-development-tools.md:14
msgid "To format any Cairo project, enter the following:"
msgstr "모든 카이로 프로젝트를 포맷하려면 다음을 입력하십시오:"

#: src/appendix-04-useful-development-tools.md:16
msgid "IDE Integration Using `cairo-language-server`"
msgstr "`cairo-language-server`를 사용한 IDE 통합"

#: src/appendix-04-useful-development-tools.md:18
msgid ""
"To help IDE integration, the Cairo community recommends using the [`cairo-"
"language-server`](https://github.com/starkware-"
"libs/cairo/tree/main/crates/cairo-lang-language-server)"
msgstr ""
"IDE 통합을 돕기 위해, 카이로 커뮤니티는 [`cairo-language-"
"server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-"
"lang-language-server)를 사용하는 것을 권장합니다."

#: src/appendix-04-useful-development-tools.md:19
msgid ""
". This tool is a set of compiler-centric utilities that speaks the [Language"
" Server Protocol](http://langserver.org/)"
msgstr ""
"이 도구는 [Language Server Protocol](http://langserver.org/)를 지원하는 컴파일러 중심의 유틸리티"
" 세트입니다."

#: src/appendix-04-useful-development-tools.md:21
msgid ""
", which is a specification for IDEs and programming languages to communicate"
" with each other. Different clients can use `cairo-language-server`, such as"
" [the Cairo extension for Visual Studio "
"Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)."
msgstr ""
"다른 클라이언트들은 `cairo-language-server`를 사용할 수 있습니다. 예를 들어, [Visual Studio Code용 "
"카이로 "
"익스텐션](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)과"
" 같은 것들이 있습니다."

#: src/appendix-04-useful-development-tools.md:28
msgid ""
"Visit the `vscode-cairo` "
"[page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)"
msgstr ""
"`vscode-cairo` "
"[페이지](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)을"
" 방문하세요."

#: src/appendix-04-useful-development-tools.md:28
msgid ""
" to install it on VSCode. You will get abilities such as autocompletion, "
"jump to definition, and inline errors."
msgstr "VSCode에 설치하십시오. 자동완성, 정의로 이동 및 인라인 오류와 같은 기능을 얻을 수 있습니다."

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"Note: If you have Scarb installed, it should work out of the box with the "
"Cairo VSCode extension, without a manual installation of the language "
"server."
msgstr ""
"참고: Scarb를 설치한 경우, Cairo VSCode 확장 프로그램을 수동으로 언어 서버를 설치하지 않고도 즉시 사용할 수 있어야 "
"합니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:1
msgid "Appendix E - Common Types & Traits and the Cairo Prelude"
msgstr "부록 E - 일반 유형 및 특성 및 카이로 서곡"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:3
msgid "Prelude"
msgstr "서론"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:5
msgid ""
"The Cairo prelude is a collection of commonly used modules, functions, data "
"types, and traits that are automatically brought into scope of every module "
"in a Cairo crate without needing explicit import statements. Cairo's prelude"
" provides the basic building blocks developers need to start Cairo programs "
"and writing smart contracts."
msgstr ""
"카이로 프렐류드는 명시적으로 가져오기 문을 필요로하지 않고 카이로 크레이트의 모든 모듈의 범위로 자동으로 가져오는 일반적으로 사용되는 "
"모듈, 함수, 데이터 유형 및 특성의 모음입니다. 카이로의 프렐류드는 개발자가 카이로 프로그램을 시작하고 스마트 계약을 작성하는 데 "
"필요한 기본 구성 요소를 제공합니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:11
msgid ""
"The core library prelude is defined in the "
"[lib.cairo](https://github.com/starkware-"
"libs/cairo/blob/v2.4.0/corelib/src/lib.cairo) file of the corelib crate and "
"contains Cairo's primitive data types, traits, operators, and utility "
"functions. This includes: Data types - felts, bools, arrays, dicts, etc. "
"Traits - behaviors for arithmetic, comparison, serialization Operators - "
"arithmetic, logical, bitwise Utility functions - helpers for arrays, maps, "
"boxing, etc. The core library prelude delivers the fundamental programming "
"constructs and operations needed for basic Cairo programs, without requiring"
" the explicit import of elements. Since the core library prelude is "
"automatically imported, its contents are available for use in any Cairo "
"crate without explicit imports. This prevents repetition and provides a "
"better devX. This is what allows you to use `ArrayTrait::append()` or the "
"`Default` trait without bringing them explicitly into scope."
msgstr ""
"핵심 라이브러리 프리루드는 corelib 크레이트의 [lib.cairo](https://github.com/starkware-"
"libs/cairo/blob/v2.4.0/corelib/src/lib.cairo) 파일에 정의되어 있으며, Cairo의 기본 데이터 "
"유형, 특성, 연산자 및 유틸리티 함수를 포함합니다. 이에는 다음이 포함됩니다: 데이터 유형 - felts, bools, arrays, "
"dicts 등 특성 - 산술, 비교, 직렬화를 위한 동작 연산자 - 산술, 논리, 비트 연산 유틸리티 함수 - 배열, 맵, 박싱 등을 "
"위한 도우미 핵심 라이브러리 프리루드는 기본 Cairo 프로그램에 필요한 프로그래밍 구조와 연산을 제공하며, 요소의 명시적 가져오기를 "
"필요로하지 않습니다. 핵심 라이브러리 프리루드가 자동으로 가져오기 때문에 해당 내용은 요소를 명시적으로 가져오지 않고도 모든 Cairo "
"크레이트에서 사용할 수 있습니다. 이는 반복을 방지하고 더 나은 개발 경험을 제공합니다. 이것은 `ArrayTrait::append()`"
" 또는 `Default` 특성을 명시적으로 범위 내에 가져오지 않고도 사용할 수 있게 해줍니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:25
msgid ""
"You can choose which prelude to use. For example, adding `edition = "
"\"2023_10\"` in `Scarb.toml` configuration file will load the prelude from "
"October 2023, which is more restricted than the one from January 2023. The "
"compiler currently exposes 2 different versions of the prelude:"
msgstr ""
"어떤 프렐루드를 사용할지 선택할 수 있습니다. 예를 들어, `Scarb.toml` 구성 파일에 `edition = \"2023_10\"`를 추가하면 2023년 10월의 프렐루드를 로드하게 되며, 이는 2023년 1월의 것보다 더 제한적입니다. 현재 컴파일러는 프렐루드의 2가지 다른 버전을 노출하고 있습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:27
msgid ""
"A general version, with a lot of traits that are made available, "
"corresponding to `edition = \"2023_01\"`."
msgstr "일반 버전으로, 사용 가능한 많은 특성을 갖춘 것에 해당하는 `edition = \"2023_01\"`입니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:28
msgid ""
"A restricted version, including the most essential traits needed for general"
" cairo programming, corresponding to `edition = 2023_10`."
msgstr "일반 카이로 프로그래밍에 필요한 가장 중요한 특성을 포함하는 제한된 버전은 `edition = 2023_10`에 해당합니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:30
msgid "List of common types and traits"
msgstr "일반적인 유형 및 특성 목록"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:32
msgid ""
"The following section provides a brief overview of commonly used types and "
"traits when developing Cairo programs. Most of these are included in the "
"prelude and not required to be imported explicitly - but not all of them."
msgstr ""
"다음 섹션은 카이로 프로그램을 개발할 때 일반적으로 사용되는 유형 및 특성에 대한 간단한 개요를 제공합니다. 이 중 대부분은 프렐루드에 "
"포함되어 있어 명시적으로 가져올 필요가 없지만 모두가 그렇지는 않습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Import"
msgstr "수입"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Path"
msgstr "경로"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:36
msgid "Usage"
msgstr "사용법"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`OptionTrait`"
msgstr "옵션 트레이트"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid "`core::option::OptionTrait`"
msgstr ""
"`core::option::OptionTrait` would be translated to `핵심::옵션::옵션트레이트` in "
"Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:38
msgid ""
"`OptionTrait<T>` defines a set of methods required to manipulate optional "
"value."
msgstr "`OptionTrait<T>`은 선택적인 값을 조작하는 데 필요한 일련의 메서드를 정의합니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`ResultTrait`"
msgstr "`ResultTrait` would be translated to `결과 특성` in Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid "`core::result::ResultTrait`"
msgstr ""
"`core::result::ResultTrait` would be translated to `핵심::결과::결과트레이트` in "
"Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:39
msgid ""
"`ResultTrait<T, E>` Type for Starknet contract address, a value in the range"
" \\[0, 2 \\*\\* 251)."
msgstr ""
"`ResultTrait<T, E>` 유형은 Starknet 계약 주소를 나타내며, 값의 범위는 \\[0, 2 \\*\\* 251)입니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress`"
msgstr "계약 주소"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`starknet::ContractAddress`"
msgstr ""
"`starknet::ContractAddress` would be translated to `starknet::계약주소` in "
"Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:40
msgid "`ContractAddress` is a type to represent the smart contract address"
msgstr "`ContractAddress`는 스마트 계약 주소를 나타내는 유형입니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`ContractAddressZeroable`"
msgstr ""
"`ContractAddressZeroable` would be translated to `계약 주소 제로 가능` in Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid "`starknet::contract_address::ContractAddressZeroable`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:41
msgid ""
"`ContractAddressZeroable` is the implementation of the trait `Zeroable` for "
"the `ContractAddress` type. It is required to check whether a value of "
"`t:ContractAddress` is zero or not."
msgstr ""
"`ContractAddressZeroable`는 `Zeroable` 특성을 `ContractAddress` 유형에 대해 구현한 것입니다."
" `t:ContractAddress` 값이 0인지 아닌지 확인해야 합니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`contract_address_const`"
msgstr "`contract_address_const` would be translated to `계약 주소 상수` in Korean."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid "`starknet::contract_address_const`"
msgstr ""


#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:42
msgid ""
"The `contract_address_const!` it's a function that allows instantiating "
"constant contract address values."
msgstr "`contract_address_const!`는 상수 계약 주소 값을 인스턴스화하는 기능입니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`Into`"
msgstr "들어가다"

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid "`traits::Into;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:43
msgid ""
"`Into<T>` is a trait used for conversion between types. If there is an "
"implementation of Into\\<T,S> for the types T and S, you can convert T into "
"S."
msgstr ""
"`Into<T>`은 타입 간 변환에 사용되는 트레이트입니다. T와 S 타입에 대한 Into<T, S> 구현이 있다면, T를 S로 변환할 "
"수 있습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`TryInto`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid "`traits::TryInto;`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:44
msgid ""
"`TryInto<T>` is a trait used for conversion between types.If there is an "
"implementation of TryInto\\<T,S> for the types T and S, you can convert T "
"into S."
msgstr ""
"`TryInto<T>`은 타입 간 변환에 사용되는 트레이트입니다. 만약 T와 S 타입에 대한 TryInto<T,S>의 구현이 있다면, "
"T를 S로 변환할 수 있습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`get_caller_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid "`starknet::get_caller_address`"
msgstr ""
"`starknet::get_caller_address` "

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:45
msgid ""
"`get_caller_address()` is a function that returns the address of the caller "
"of the contract. It can be used to identify the caller of a contract "
"function."
msgstr ""
"`get_caller_address()`는 계약 호출자의 주소를 반환하는 함수입니다. 이 함수는 계약 함수의 호출자를 식별하는 데 사용될"
" 수 있습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid "`starknet::info::get_contract_address`"
msgstr ""

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:46
msgid ""
"`get_contract_address()` is a function that returns the address of the "
"current contract. It can be used to obtain the address of the contract being"
" executed."
msgstr ""
"`get_contract_address()`는 현재 계약의 주소를 반환하는 함수입니다. 실행 중인 계약의 주소를 얻는 데 사용할 수 "
"있습니다."

#: src/appendix-05-common-types-and-traits-and-cairo-prelude.md:48
msgid ""
"This is not an exhaustive list, but it covers some of the commonly used "
"types and traits in contract development. For more details, refer to the "
"official documentation and explore the available libraries and frameworks."
msgstr ""
"이것은 철저한 목록은 아니지만, 계약 개발에서 일반적으로 사용되는 몇 가지 유형과 특성을 다룹니다. 더 자세한 내용은 공식 문서를 "
"참조하고 사용 가능한 라이브러리와 프레임워크를 탐색하십시오."

#: src/appendix-06-cairo-binaries.md:1
msgid "Appendix F: Installing the Cairo binaries"
msgstr "부록 F: Cairo 이진 파일 설치하기"

#: src/appendix-06-cairo-binaries.md:3
msgid ""
"If you want to have access to the Cairo binaries, for anything that you "
"could not achieve by purely using Scarb you can install them by following "
"the instructions below."
msgstr ""
"만약 당신이 Scarb만 사용해서 달성할 수 없는 것들을 위해 카이로 이진 파일에 접근하고 싶다면, 아래의 지시 사항을 따라 설치할 수 "
"있습니다."

#: src/appendix-06-cairo-binaries.md:5
msgid ""
"The first step is to install Cairo. We will download Cairo manually, using "
"cairo repository or with an installation script. You’ll need an internet "
"connection for the download."
msgstr ""
"첫 번째 단계는 Cairo를 설치하는 것입니다. Cairo를 수동으로 다운로드하거나 cairo 저장소를 사용하거나 설치 스크립트를 "
"사용하여 다운로드할 것입니다. 다운로드를 위해 인터넷 연결이 필요합니다."

#: src/appendix-06-cairo-binaries.md:7
msgid "Prerequisites"
msgstr "필수 조건"

#: src/appendix-06-cairo-binaries.md:9
msgid "First you will need to have Rust and Git installed."
msgstr "먼저 Rust와 Git을 설치해야 합니다."

#: src/appendix-06-cairo-binaries.md:12
msgid "# Install stable Rust\n"
msgstr "# 안정적인 Rust 설치"

#: src/appendix-06-cairo-binaries.md:16
msgid "Install [Git](https://git-scm.com/)."
msgstr "[Git](https://git-scm.com/)을(를) 설치하세요."

#: src/appendix-06-cairo-binaries.md:18
msgid ""
"Installing Cairo with a Script "
"([Installer](https://github.com/franalgaba/cairo-installer) by "
"[Fran](https://github.com/franalgaba))"
msgstr ""
"스크립트로 Cairo 설치하기 ([Installer](https://github.com/franalgaba/cairo-installer)"
" by [Fran](https://github.com/franalgaba))"

#: src/appendix-06-cairo-binaries.md:20
msgid "Install"
msgstr "설치하기"

#: src/appendix-06-cairo-binaries.md:22
msgid ""
"If you wish to install a specific release of Cairo rather than the latest "
"head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export "
"CAIRO_GIT_TAG=v2.5.1`)."
msgstr ""
"만약 최신 버전이 아닌 특정 버전의 Cairo를 설치하고 싶다면, `CAIRO_GIT_TAG` 환경 변수를 설정하세요 (예: "
"`export CAIRO_GIT_TAG=v2.5.1`)."

#: src/appendix-06-cairo-binaries.md:28
msgid ""
"After installing, follow [these instructions](#set-up-your-shell-"
"environment-for-cairo) to set up your shell environment."
msgstr ""
"설치 후 [이 지침](#set-up-your-shell-environment-for-cairo)을 따라 쉘 환경을 설정하십시오."

#: src/appendix-06-cairo-binaries.md:30
msgid "Update"
msgstr "업데이트"

#: src/appendix-06-cairo-binaries.md:32
msgid ""
"```\n"
"rm -fr ~/.cairo\n"
"curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash\n"
"```"
msgstr ""

#: src/appendix-06-cairo-binaries.md:37
msgid "Uninstall"
msgstr "삭제하기"

#: src/appendix-06-cairo-binaries.md:39
msgid ""
"Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, "
"just remove it:"
msgstr "카이로는 `$CAIRO_ROOT` 내에 설치되어 있습니다 (기본값: ~/.cairo). 제거하려면 그냥 삭제하면 됩니다."

#: src/appendix-06-cairo-binaries.md:45
msgid "then remove these three lines from .bashrc:"
msgstr "그런 다음 .bashrc에서 이 세 줄을 제거하십시오."

#: src/appendix-06-cairo-binaries.md:48
msgid "\"$HOME/.cairo/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:51
msgid "and finally, restart your shell:"
msgstr "그리고 마지막으로, 쉘을 다시 시작하십시오."

#: src/appendix-06-cairo-binaries.md:57
msgid "Set up your shell environment for Cairo"
msgstr "카이로를 위한 셸 환경을 설정하세요."

#: src/appendix-06-cairo-binaries.md:59
msgid ""
"Define environment variable `CAIRO_ROOT` to point to the path where Cairo "
"will store its data. `$HOME/.cairo` is the default. If you installed Cairo "
"via Git checkout, we recommend to set it to the same location as where you "
"cloned it."
msgstr ""
"Cairo가 데이터를 저장할 경로를 가리키도록 환경 변수 `CAIRO_ROOT`를 정의하십시오. `$HOME/.cairo`가 "
"기본값입니다. Git checkout을 통해 Cairo를 설치한 경우, 클론한 위치와 동일한 위치로 설정하는 것을 권장합니다."

#: src/appendix-06-cairo-binaries.md:63
msgid "Add the `cairo-*` executables to your `PATH` if it's not already there"
msgstr "`cairo-*` 실행 파일을 `PATH`에 추가하십시오. 이미 추가되어 있지 않다면."

#: src/appendix-06-cairo-binaries.md:65
msgid ""
"The below setup should work for the vast majority of users for common use "
"cases."
msgstr "아래 설정은 일반적인 사용 사례에 대부분의 사용자에게 적합해야 합니다."

#: src/appendix-06-cairo-binaries.md:67
msgid "For **bash**:"
msgstr "**bash**에 대해:"

#: src/appendix-06-cairo-binaries.md:69
msgid ""
"Stock Bash startup files vary widely between distributions in which of them "
"source which, under what circumstances, in what order and what additional "
"configuration they perform. As such, the most reliable way to get Cairo in "
"all environments is to append Cairo configuration commands to both `.bashrc`"
" (for interactive shells) and the profile file that Bash would use (for "
"login shells)."
msgstr ""
"주식 Bash 시작 파일은 어떤 배포판에서 어떤 것을 소스로 사용하는지, 어떤 상황에서, 어떤 순서로, 어떤 추가 구성을 수행하는지에 "
"따라 크게 다릅니다. 따라서 모든 환경에서 Cairo를 가장 신뢰할 수 있는 방법은 `.bashrc` (대화형 셸용)과 Bash가 사용할"
" 프로필 파일에 Cairo 구성 명령을 추가하는 것입니다."

#: src/appendix-06-cairo-binaries.md:75
msgid ""
"First, add the commands to `~/.bashrc` by running the following in your "
"terminal:"
msgstr "먼저 터미널에서 다음을 실행하여 `~/.bashrc`에 명령을 추가하십시오:"

#: src/appendix-06-cairo-binaries.md:78 src/appendix-06-cairo-binaries.md:88
#: src/appendix-06-cairo-binaries.md:94 src/appendix-06-cairo-binaries.md:101
msgid "'export CAIRO_ROOT=\"$HOME/.cairo\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:79 src/appendix-06-cairo-binaries.md:89
#: src/appendix-06-cairo-binaries.md:95 src/appendix-06-cairo-binaries.md:102
msgid ""
"'command -v cairo-compile >/dev/null || export "
"PATH=\"$CAIRO_ROOT/target/release:$PATH\"'"
msgstr ""

#: src/appendix-06-cairo-binaries.md:82
msgid ""
"Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add "
"the commands there as well. If you have none of these, add them to "
"`~/.profile`."
msgstr ""
"그런 다음, `~/.profile`, `~/.bash_profile` 또는 `~/.bash_login` 파일이 있다면 해당 파일에도 "
"명령을 추가하십시오. 이러한 파일이 없는 경우 `~/.profile`에 추가하십시오."

#: src/appendix-06-cairo-binaries.md:85
msgid "to add to `~/.profile`:"
msgstr "`~/.profile`에 추가하려면:"

#: src/appendix-06-cairo-binaries.md:92
msgid "to add to `~/.bash_profile`:"
msgstr "`~/.bash_profile`에 추가하려면:"

#: src/appendix-06-cairo-binaries.md:98
msgid "For **Zsh**:"
msgstr "**Zsh**에 대해:"

#: src/appendix-06-cairo-binaries.md:105
msgid ""
"If you wish to get Cairo in non-interactive login shells as well, also add "
"the commands to `~/.zprofile` or `~/.zlogin`."
msgstr ""
"원하신다면 Cairo를 비대화식 로그인 쉘에서도 사용하려면 `~/.zprofile` 또는 `~/.zlogin`에 명령어를 추가하세요."

#: src/appendix-06-cairo-binaries.md:107
msgid "For **Fish shell**:"
msgstr ""

#: src/appendix-06-cairo-binaries.md:109
msgid "If you have Fish 3.2.0 or newer, execute this interactively:"
msgstr "Fish 3.2.0 이나 그 이상의 버전을 사용 중이라면, 이를 대화식으로 실행하십시오:"

#: src/appendix-06-cairo-binaries.md:116
msgid "Otherwise, execute the snippet below:"
msgstr "그렇지 않으면, 아래 코드 조각을 실행하십시오."

#: src/appendix-06-cairo-binaries.md:123
msgid ""
"In MacOS, you might also want to install [Fig](https://fig.io/) which "
"provides alternative shell completions for many command line tools with an "
"IDE-like popup interface in the terminal window. (Note that their "
"completions are independent from Cairo's codebase so they might be slightly "
"out of sync for bleeding-edge interface changes.)"
msgstr ""
"맥OS에서는 터미널 창에서 IDE와 유사한 팝업 인터페이스로 많은 명령 줄 도구에 대한 대체 쉘 완성을 제공하는 "
"[Fig](https://fig.io/)를 설치할 수도 있습니다. (그들의 완성은 카이로의 코드베이스와 독립적이므로 최신 인터페이스 변경"
" 사항에 대해 약간 동기화되지 않을 수 있음에 유의하십시오.)"

#: src/appendix-06-cairo-binaries.md:129
msgid "Restart your shell"
msgstr "셸을 다시 시작하세요."

#: src/appendix-06-cairo-binaries.md:131
msgid "for the `PATH` changes to take effect."
msgstr "`PATH` 변경 사항이 적용되려면."

#: src/appendix-06-cairo-binaries.md:134
msgid "\"$SHELL\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:137
msgid ""
"Installing Cairo Manually ([Guide](https://github.com/auditless/cairo-"
"template) by [Abdel](https://github.com/abdelhamidbakhta))"
msgstr ""
"수동으로 Cairo 설치하기 ([가이드](https://github.com/auditless/cairo-template) by "
"[Abdel](https://github.com/abdelhamidbakhta))"

#: src/appendix-06-cairo-binaries.md:139
msgid "Step 1: Install Cairo 1.0"
msgstr "단계 1: Cairo 1.0 설치하기"

#: src/appendix-06-cairo-binaries.md:141
msgid ""
"If you are using an x86 Linux system and can use the release binary, "
"download Cairo here: <https://github.com/starkware-libs/cairo/releases>."
msgstr ""
"만약 x86 리눅스 시스템을 사용하고 릴리즈 바이너리를 사용할 수 있다면, Cairo를 다운로드하십시오: "
"<https://github.com/starkware-libs/cairo/releases>."

#: src/appendix-06-cairo-binaries.md:143
msgid ""
"For everyone else, we recommend compiling Cairo from source as follows:"
msgstr "다른 모든 사람들에게는, Cairo를 다음과 같이 소스에서 컴파일하는 것을 권장합니다."

#: src/appendix-06-cairo-binaries.md:146
msgid "# Start by defining environment variable CAIRO_ROOT\n"
msgstr "# CAIRO_ROOT 환경 변수를 정의하여 시작하세요."

#: src/appendix-06-cairo-binaries.md:147
msgid "\"${HOME}/.cairo\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:148
msgid "# Create .cairo folder if it doesn't exist yet\n"
msgstr "# 아직 존재하지 않는 경우 .cairo 폴더를 만듭니다."

#: src/appendix-06-cairo-binaries.md:151
msgid "# Clone the Cairo compiler in $CAIRO_ROOT (default root)\n"
msgstr "# Cairo 컴파일러를 $CAIRO_ROOT(기본 루트)에 복제합니다."

#: src/appendix-06-cairo-binaries.md:154
msgid ""
"# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler\n"
"# Fetch all tags (versions)\n"
msgstr ""
"# 선택 사항/권장 사항: 특정 버전의 컴파일러를 설치하려면\n"
"# 모든 태그(버전)을 가져옵니다"

#: src/appendix-06-cairo-binaries.md:157
msgid "# View tags (you can also do this in the cairo compiler repository)\n"
msgstr "# 태그 보기 (카이로 컴파일러 저장소에서도 이 작업을 수행할 수 있습니다)"

#: src/appendix-06-cairo-binaries.md:159
msgid "# Checkout the version you want\n"
msgstr "당신이 원하는 버전을 확인하세요."

#: src/appendix-06-cairo-binaries.md:162
msgid "# Generate release binaries\n"
msgstr "릴리스 이진 파일 생성"

#: src/appendix-06-cairo-binaries.md:167
msgid "."
msgstr ""
"I'm sorry, but I cannot translate a period as it does not contain any "
"meaningful text. If you provide me with a sentence or phrase in English, I "
"will be happy to translate it to Korean for you."

#: src/appendix-06-cairo-binaries.md:169
msgid "**NOTE: Keeping Cairo up to date**"
msgstr "**참고: 카이로 최신 상태 유지하기**"

#: src/appendix-06-cairo-binaries.md:171
msgid ""
"Now that your Cairo compiler is in a cloned repository, all you will need to"
" do is pull the latest changes and rebuild as follows:"
msgstr ""
"이제 카이로 컴파일러가 복제된 저장소에 있으므로, 당신이 해야 할 일은 최신 변경 사항을 가져오고 다음과 같이 다시 빌드하는 것뿐입니다:"

#: src/appendix-06-cairo-binaries.md:178
msgid "Step 2: Add Cairo 1.0 executables to your path"
msgstr "단계 2: 카이로 1.0 실행 파일을 경로에 추가하세요."

#: src/appendix-06-cairo-binaries.md:181
msgid "\"$CAIRO_ROOT/target/release:$PATH\""
msgstr ""

#: src/appendix-06-cairo-binaries.md:184
msgid ""
"**NOTE: If installing from a Linux binary, adapt the destination path "
"accordingly.**"
msgstr "**참고: Linux 바이너리에서 설치하는 경우, 대상 경로를 적절히 조정하십시오.**"

#: src/appendix-06-cairo-binaries.md:186
msgid "Step 3: Setup Language Server"
msgstr "3단계: 언어 서버 설정"

#: src/appendix-06-cairo-binaries.md:188
msgid "VS Code Extension"
msgstr "VS Code 확장 프로그램"

#: src/appendix-06-cairo-binaries.md:190
msgid ""
"If you have the previous Cairo 0 extension installed, you can "
"disable/uninstall it."
msgstr "이전 Cairo 0 확장 프로그램을 설치했을 경우, 비활성화/제거할 수 있습니다."

#: src/appendix-06-cairo-binaries.md:191
msgid ""
"Install the Cairo 1 extension for proper syntax highlighting and code "
"navigation. You can find the link to the extension "
"[here](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false),"
" or just search for \"Cairo 1.0\" in the VS Code marketplace."
msgstr ""
"올바른 구문 강조와 코드 탐색을 위해 Cairo 1 확장 프로그램을 설치하세요. 확장 프로그램 링크는 "
"[여기](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1&ssr=false)에서"
" 찾을 수 있습니다. 또는 VS Code Marketplace에서 \"Cairo 1.0\"을 검색하세요."

#: src/appendix-06-cairo-binaries.md:192
msgid ""
"The extension will work out of the box once you will have "
"[Scarb](./ch01-03-hello-scarb.md) installed."
msgstr "확장 프로그램은 설치된 후 즉시 작동합니다."

#: src/appendix-06-cairo-binaries.md:194
msgid "Cairo Language Server without Scarb"
msgstr "Scarb 없는 카이로 언어 서버"

#: src/appendix-06-cairo-binaries.md:196
msgid ""
"If you don't want to depend on Scarb, you can still use the Cairo Language "
"Server with the compiler binary. From [Step 1](#installing-cairo-with-a-"
"script-installer-by-fran), the `cairo-language-server` binary should be "
"built and executing this command will copy its path into your clipboard."
msgstr ""
"Scarb에 의존하고 싶지 않다면, 컴파일러 이진 파일과 함께 카이로 언어 서버를 사용할 수 있습니다. [단계 1](#installing-"
"cairo-with-a-script-installer-by-fran)에서 `cairo-language-server` 이진 파일을 빌드해야"
" 하며, 이 명령을 실행하면 해당 경로가 클립보드에 복사됩니다."

#: src/appendix-06-cairo-binaries.md:203
msgid ""
"Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting"
" the path."
msgstr "카이로 1.0 확장 프로그램의 `cairo1.languageServerPath`를 업데이트하려면 경로를 붙여넣으세요."

#: src/appendix-07-system-calls.md:1
msgid "System Calls"
msgstr "시스템 호출"

#: src/appendix-07-system-calls.md:3
msgid ""
"This chapter is based on the StarkNet documentation available at [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/)."
msgstr ""
"이 장은 [StarkNet "
"Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/)에서 제공하는 StarkNet 문서를 기반으로 합니다."

#: src/appendix-07-system-calls.md:5
msgid ""
"Writing smart contracts requires various associated operations, such as "
"calling another contract or accessing the contract’s storage, that "
"standalone programs do not require."
msgstr ""
"스마트 계약을 작성하려면 다른 계약을 호출하거나 계약의 저장소에 액세스하는 등의 여러 관련 작업이 필요합니다. 독립 실행 프로그램에서는 "
"필요하지 않은 작업들입니다."

#: src/appendix-07-system-calls.md:7
msgid ""
"The Starknet contract language supports these operations by using system "
"calls. System calls enable a contract to require services from the Starknet "
"OS. You can use system calls in a function to get information that depends "
"on the broader state of Starknet, which would otherwise be inaccessible, "
"rather than local variables that appear in the function’s scope."
msgstr ""
"스타크넷 계약 언어는 시스템 호출을 사용하여 이러한 작업을 지원합니다. 시스템 호출을 통해 계약은 스타크넷 OS에서 서비스를 요청할 수 "
"있습니다. 함수 내에서 시스템 호출을 사용하여 스타크넷의 더 넓은 상태에 따라 접근할 수 없는 정보를 얻을 수 있습니다. 이는 함수 "
"범위에 나타나는 로컬 변수가 아닌 것입니다."

#: src/appendix-07-system-calls.md:9
msgid "Here is a list of the system calls available in Cairo 1.0:"
msgstr "카이로 1.0에서 사용 가능한 시스템 호출 목록입니다."

#: src/appendix-07-system-calls.md:11
msgid "[get_block_hash](#get_block_hash)"
msgstr ""

#: src/appendix-07-system-calls.md:12
msgid "[get_execution_info](#get_execution_info)"
msgstr ""

#: src/appendix-07-system-calls.md:13
msgid "[call_contract](#call_contract)"
msgstr "[call_contract](#call_contract) -> [call_contract](#call_contract)"

#: src/appendix-07-system-calls.md:14
msgid "[deploy](#deploy)"
msgstr "[배포](#deploy)"

#: src/appendix-07-system-calls.md:15
msgid "[emit_event](#emit_event)"
msgstr "[emit_event](#emit_event)"

#: src/appendix-07-system-calls.md:16
msgid "[library_call](#library_call)"
msgstr ""
"[library_call](#library_call)"

#: src/appendix-07-system-calls.md:17
msgid "[send_message_to_L1](#send_message_to_l1)"
msgstr ""

#: src/appendix-07-system-calls.md:18
msgid "[replace_class](#replace_class)"
msgstr ""
"[replace_class](#replace_class)"

#: src/appendix-07-system-calls.md:19
msgid "[storage_read](#storage_read)"
msgstr "[storage_read](#storage_read)"

#: src/appendix-07-system-calls.md:20
msgid "[storage_write](#storage_write)"
msgstr ""
"[storage_write](#storage_write)"

#: src/appendix-07-system-calls.md:22
msgid "`get_block_hash`"
msgstr "`get_block_hash`"

#: src/appendix-07-system-calls.md:24 src/appendix-07-system-calls.md:51
#: src/appendix-07-system-calls.md:79 src/appendix-07-system-calls.md:117
#: src/appendix-07-system-calls.md:153 src/appendix-07-system-calls.md:198
#: src/appendix-07-system-calls.md:230 src/appendix-07-system-calls.md:273
#: src/appendix-07-system-calls.md:305 src/appendix-07-system-calls.md:348
msgid "Syntax"
msgstr "구문론"

#: src/appendix-07-system-calls.md:32 src/appendix-07-system-calls.md:59
#: src/appendix-07-system-calls.md:87 src/appendix-07-system-calls.md:128
#: src/appendix-07-system-calls.md:161 src/appendix-07-system-calls.md:206
#: src/appendix-07-system-calls.md:238 src/appendix-07-system-calls.md:281
#: src/appendix-07-system-calls.md:313 src/appendix-07-system-calls.md:356
msgid "Description"
msgstr "설명"

#: src/appendix-07-system-calls.md:34
msgid ""
"Gets the hash of a specific StarkNet block within the range of "
"`[first_v0_12_0_block, current_block - 10]`."
msgstr ""
"`[first_v0_12_0_block, current_block - 10]` 범위 내의 특정 StarkNet 블록의 해시를 가져옵니다."

#: src/appendix-07-system-calls.md:36 src/appendix-07-system-calls.md:69
#: src/appendix-07-system-calls.md:103 src/appendix-07-system-calls.md:139
#: src/appendix-07-system-calls.md:173 src/appendix-07-system-calls.md:220
#: src/appendix-07-system-calls.md:252 src/appendix-07-system-calls.md:295
#: src/appendix-07-system-calls.md:327 src/appendix-07-system-calls.md:372
msgid "Return values"
msgstr "반환 값"

#: src/appendix-07-system-calls.md:38
msgid "Returns the hash of the given block."
msgstr "주어진 블록의 해시를 반환합니다."

#: src/appendix-07-system-calls.md:40
msgid "Error messages"
msgstr "에러 메시지"

#: src/appendix-07-system-calls.md:42
msgid ""
"`Block number out of range`: `block_number` is greater than "
"_`current_block`_`- 10`."
msgstr "`블록 번호가 범위를 벗어났습니다`: `block_number`이 _`current_block`_`- 10`보다 큽니다."

#: src/appendix-07-system-calls.md:43
msgid "`0`: `block_number` is less than the first block number of v0.12.0."
msgstr "`0`: `block_number`가 v0.12.0의 첫 번째 블록 번호보다 작습니다."

#: src/appendix-07-system-calls.md:45 src/appendix-07-system-calls.md:73
#: src/appendix-07-system-calls.md:107 src/appendix-07-system-calls.md:147
#: src/appendix-07-system-calls.md:192 src/appendix-07-system-calls.md:224
#: src/appendix-07-system-calls.md:267 src/appendix-07-system-calls.md:299
#: src/appendix-07-system-calls.md:342 src/appendix-07-system-calls.md:376
msgid "Common library"
msgstr "공용 도서관"

#: src/appendix-07-system-calls.md:47
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)"
msgstr ""

#: src/appendix-07-system-calls.md:49
msgid "`get_execution_info`"
msgstr ""

#: src/appendix-07-system-calls.md:61
msgid "Gets information about the original transaction."
msgstr "원래 거래에 대한 정보를 얻습니다."

#: src/appendix-07-system-calls.md:63
msgid ""
"In Cairo 1.0, all block/transaction/execution context getters are batched "
"into this single system call."
msgstr "카이로 1.0에서는 모든 블록/트랜잭션/실행 컨텍스트 게터가 이 단일 시스템 호출로 일괄 처리됩니다."

#: src/appendix-07-system-calls.md:65 src/appendix-07-system-calls.md:97
#: src/appendix-07-system-calls.md:132 src/appendix-07-system-calls.md:167
#: src/appendix-07-system-calls.md:212 src/appendix-07-system-calls.md:246
#: src/appendix-07-system-calls.md:291 src/appendix-07-system-calls.md:321
#: src/appendix-07-system-calls.md:364
msgid "Arguments"
msgstr "논쟁"

#: src/appendix-07-system-calls.md:67 src/appendix-07-system-calls.md:175
#: src/appendix-07-system-calls.md:254 src/appendix-07-system-calls.md:297
#: src/appendix-07-system-calls.md:374
msgid "None."
msgstr "없음."

#: src/appendix-07-system-calls.md:71
msgid ""
"Returns a [struct](https://github.com/starkware-"
"libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8)"
" containing the execution info."
msgstr ""
"실행 정보를 포함하는 [struct](https://github.com/starkware-"
"libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8)를"
" 반환합니다."

#: src/appendix-07-system-calls.md:75
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)"
msgstr ""

#: src/appendix-07-system-calls.md:77
msgid "`call_contract`"
msgstr "`계약 호출`"

#: src/appendix-07-system-calls.md:89
msgid ""
"Calls a given contract. This system call expects the address of the called "
"contract, a selector for a function within that contract, and call "
"arguments."
msgstr ""
"주어진 계약을 호출합니다. 이 시스템 호출은 호출된 계약의 주소, 해당 계약 내의 함수를 위한 셀렉터 및 호출 인수를 기대합니다."

#: src/appendix-07-system-calls.md:91 src/appendix-07-system-calls.md:285
msgid "**Note:**"
msgstr "**참고:**"

#: src/appendix-07-system-calls.md:93
msgid ""
"An internal call can’t return Err(\\_) as this is not handled by the "
"sequencer and the Starknet OS."
msgstr "내부 호출은 시퀀서와 Starknet OS에서 처리되지 않기 때문에 Err(\\_)을 반환할 수 없습니다."

#: src/appendix-07-system-calls.md:95
msgid ""
"If call_contract_syscall fails, this can’t be caught and will therefore "
"result in the entire transaction being reverted."
msgstr "call_contract_syscall이 실패하면 이를 잡을 수 없으며, 따라서 전체 거래가 되돌아가게 됩니다."

#: src/appendix-07-system-calls.md:99
msgid "_`address`_: The address of the contract you want to call."
msgstr "_`주소`_: 호출하려는 계약의 주소."

#: src/appendix-07-system-calls.md:100
msgid ""
"_`entry_point_selector`_: A selector for a function within that contract."
msgstr "_`entry_point_selector`_: 해당 계약 내의 함수를 선택하는 선택기입니다."

#: src/appendix-07-system-calls.md:101
msgid "_`calldata`_: The calldata array."
msgstr "_`calldata`_: calldata 배열."

#: src/appendix-07-system-calls.md:105 src/appendix-07-system-calls.md:222
msgid "The call response, of type `SyscallResult<Span<felt252>>`."
msgstr "`SyscallResult<Span<felt252>>` 유형의 호출 응답."

#: src/appendix-07-system-calls.md:109
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)"

#: src/appendix-07-system-calls.md:111
msgid ""
"**Note:** This is considered a lower-level syntax for calling contracts. If "
"the interface of the called contract is available, then you can use a more "
"straightforward syntax."
msgstr ""
"**참고:** 이는 계약을 호출하는 더 낮은 수준의 구문으로 간주됩니다. 호출된 계약의 인터페이스가 사용 가능하다면 더 직접적인 구문을 "
"사용할 수 있습니다."

#: src/appendix-07-system-calls.md:115
msgid "`deploy`"
msgstr "배포"

#: src/appendix-07-system-calls.md:130
msgid "Deploys a new instance of a previously declared class."
msgstr "이전에 선언된 클래스의 새 인스턴스를 배포합니다."

#: src/appendix-07-system-calls.md:134
msgid "_`class_hash`_: The class hash of the contract to be deployed."
msgstr "_`class_hash`_: 배포할 계약의 클래스 해시입니다."

#: src/appendix-07-system-calls.md:135
msgid ""
"_`contract_address_salt`_: The salt, an arbitrary value provided by the "
"sender, used in the computation of the contract’s address."
msgstr "`contract_address_salt`: 컨트랙트 주소 계산에 사용되는 보내는 사람이 제공한 임의의 값인 솔트."

#: src/appendix-07-system-calls.md:136
msgid "_`calldata`_: The constructor’s calldata. An array of felts."
msgstr "_`calldata`_: 생성자의 calldata. 펠트들의 배열."

#: src/appendix-07-system-calls.md:137
msgid ""
"_`deploy_from_zero`_: A flag used for the contract address computation. If "
"not set, the caller address will be used as the new contract’s deployer "
"address, otherwise 0 is used."
msgstr ""
"`deploy_from_zero`: 계약 주소 계산에 사용되는 플래그입니다. 설정되지 않으면 호출자 주소가 새 계약의 배포자 주소로 "
"사용되고, 그렇지 않으면 0이 사용됩니다."

#: src/appendix-07-system-calls.md:141
msgid "A tuple wrapped with SyscallResult where:"
msgstr "SyscallResult로 래핑된 튜플:"

#: src/appendix-07-system-calls.md:143
msgid ""
"The first element is the address of the deployed contract, of type "
"`ContractAddress`."
msgstr "배포된 계약의 주소인 `ContractAddress` 유형의 첫 번째 요소입니다."

#: src/appendix-07-system-calls.md:145
msgid ""
"The second element is the response array from the contract’s constructor, of"
" type `Span::<felt252>`."
msgstr "두 번째 요소는 `Span::<felt252>` 유형의 계약 생성자로부터의 응답 배열입니다."

#: src/appendix-07-system-calls.md:149
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)"
msgstr ""

#: src/appendix-07-system-calls.md:151
msgid "`emit_event`"
msgstr "이벤트 발생"

#: src/appendix-07-system-calls.md:163
msgid "Emits an event with a given set of keys and data."
msgstr "지정된 키와 데이터 세트로 이벤트를 발생시킵니다."

#: src/appendix-07-system-calls.md:165
msgid ""
"For more information, and for a higher-level syntax for emitting events, see"
" [Starknet "
"events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-"
"events/)."
msgstr ""
"더 많은 정보 및 이벤트를 발생시키는 더 높은 수준의 구문에 대한 자세한 내용은 [Starknet "
"이벤트](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-"
"events/)를 참조하십시오."

#: src/appendix-07-system-calls.md:169
msgid ""
"_`keys`_: The event’s keys. These are analogous to Ethereum’s event topics, "
"you can use the starknet_getEvents method to filter by these keys."
msgstr ""
"_keys_: 이벤트의 키입니다. 이는 이더리움의 이벤트 주제와 유사하며, starknet_getEvents 메서드를 사용하여 이러한 "
"키로 필터링할 수 있습니다."

#: src/appendix-07-system-calls.md:171
msgid "_`data`_: The event’s data."
msgstr "_`data`_: 이벤트 데이터."

#: src/appendix-07-system-calls.md:179
msgid ""
"The following example emits an event with two keys, the strings `status` and"
" `deposit` and three data elements: `1`, `2`, and `3`."
msgstr ""
"다음 예제는 두 개의 키, 문자열 'status'와 'deposit' 및 세 개의 데이터 요소 '1', '2' 및 '3'을 포함하는 "
"이벤트를 발생시킵니다."

#: src/appendix-07-system-calls.md:194
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)"
msgstr ""

#: src/appendix-07-system-calls.md:196
msgid "`library_call`"
msgstr ""

#: src/appendix-07-system-calls.md:208
msgid ""
"Calls the requested function in any previously declared class. The class is "
"only used for its logic."
msgstr "이전에 선언된 클래스에서 요청된 함수를 호출합니다. 이 클래스는 그 논리만을 위해 사용됩니다."

#: src/appendix-07-system-calls.md:210
msgid ""
"This system call replaces the known delegate call functionality from "
"Ethereum, with the important difference that there is only one contract "
"involved."
msgstr "이 시스템 호출은 이더리움의 알려진 대리자 호출 기능을 대체하며, 중요한 차이점은 관련된 계약이 하나뿐이라는 것입니다."

#: src/appendix-07-system-calls.md:214
msgid "_`class_hash`_: The hash of the class you want to use."
msgstr "_`class_hash`_: 사용하고 싶은 클래스의 해시입니다."

#: src/appendix-07-system-calls.md:216
msgid "_`function_selector`_: A selector for a function within that class."
msgstr "`function_selector`: 해당 클래스 내의 함수를 선택하는 선택기."

#: src/appendix-07-system-calls.md:218
msgid "_`calldata`_: The calldata."
msgstr "_`calldata`_: 콜데이터."

#: src/appendix-07-system-calls.md:226
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)"
msgstr ""

#: src/appendix-07-system-calls.md:228
msgid "`send_message_to_L1`"
msgstr "`L1에 메시지를 보내기`"

#: src/appendix-07-system-calls.md:240
msgid "Sends a message to L1."
msgstr "L1에 메시지를 보냅니다."

#: src/appendix-07-system-calls.md:242
msgid ""
"This system call includes the message parameters as part of the proof’s "
"output and exposes these parameters to the `StarknetCore` contract on L1 "
"once the state update, including the transaction, is received."
msgstr ""
"이 시스템 호출은 증명의 출력의 일부로 메시지 매개변수를 포함하며, 상태 업데이트 및 트랜잭션을 포함한 후에 이러한 매개변수를 L1의 "
"`StarknetCore` 계약에 노출합니다."

#: src/appendix-07-system-calls.md:244
msgid ""
"For more information, see Starknet’s [messaging "
"mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)."
msgstr ""
"더 많은 정보를 원하시면 Starknet의 [메시징 "
"메커니즘](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-"
"mechanism/)을 참조하세요."

#: src/appendix-07-system-calls.md:248
msgid "_`to_address`_: The recipient’s L1 address."
msgstr "_`to_address`_: 수신자의 L1 주소."

#: src/appendix-07-system-calls.md:250
msgid "_`payload`_: The array containing the message payload."
msgstr "`payload`: 메시지 페이로드를 포함하는 배열입니다."

#: src/appendix-07-system-calls.md:258
msgid ""
"The following example sends a message whose content is `(1,2)` to the L1 "
"contract whose address is `3423542542364363`."
msgstr "다음 예제는 내용이 `(1,2)`인 메시지를 주소가 `3423542542364363`인 L1 계약에 보냅니다."

#: src/appendix-07-system-calls.md:269
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51) \n"
"\n"
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)"

#: src/appendix-07-system-calls.md:271
msgid "`replace_class`"
msgstr "`replace_class`"

#: src/appendix-07-system-calls.md:283
msgid ""
"Once `replace_class` is called, the class of the calling contract (i.e. the "
"contract whose address is returned by `get_contract_address` at the time the"
" syscall is called) will be replaced by the class whose hash is given by the"
" class_hash argument."
msgstr ""
"`replace_class`가 호출되면 호출된 계약의 클래스(즉, syscall이 호출될 때 `get_contract_address`에 "
"의해 반환된 주소를 가진 계약)은 class_hash 인수로 주어진 해시에 의해 지정된 클래스로 대체됩니다."

#: src/appendix-07-system-calls.md:287
msgid ""
"After calling `replace_class`, the code currently executing from the old "
"class will finish running."
msgstr "`replace_class`를 호출한 후에는, 이전 클래스에서 현재 실행 중인 코드가 완료될 것입니다."

#: src/appendix-07-system-calls.md:289
msgid ""
"The new class will be used from the next transaction onwards or if the "
"contract is called via the `call_contract` syscall in the same transaction "
"(after the replacement)."
msgstr ""
"새로운 클래스는 다음 거래부터 사용되거나 계약이 `call_contract` 시스템 호출을 통해 동일한 거래에서 호출될 때(대체 후) "
"사용됩니다."

#: src/appendix-07-system-calls.md:293
msgid ""
"_`class_hash`_: The hash of the class you want to use as a replacement."
msgstr "_`class_hash`_: 교체로 사용하려는 클래스의 해시입니다."

#: src/appendix-07-system-calls.md:301
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)"
msgstr ""

#: src/appendix-07-system-calls.md:303
msgid "`storage_read`"
msgstr "`저장소_읽기`"

#: src/appendix-07-system-calls.md:315
msgid "Gets the value of a key in the storage of the calling contract."
msgstr "호출된 계약의 저장소에서 키의 값을 가져옵니다."

#: src/appendix-07-system-calls.md:317
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.read()`, which enables you to read storage variables that"
" are defined explicitly in the contract."
msgstr ""
"이 시스템 호출은 `var.read()`와 대조적으로 저장소에 있는 모든 가능한 키에 직접 액세스할 수 있습니다. "
"`var.read()`는 계약에서 명시적으로 정의된 저장소 변수를 읽을 수 있도록 합니다."

#: src/appendix-07-system-calls.md:319 src/appendix-07-system-calls.md:362
msgid ""
"For information on accessing storage by using the storage variables, see "
"[storage "
"variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)."
msgstr ""
"저장 변수를 사용하여 저장소에 액세스하는 방법에 대한 정보는 [저장 "
"변수](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)를 참조하십시오."

#: src/appendix-07-system-calls.md:323 src/appendix-07-system-calls.md:366
msgid ""
"_`address_domain`_: The domain of the key, used to separate between "
"different data availability modes. This separation is used in Starknet to "
"offer different data availability modes. Currently, only the onchain mode "
"(where all updates go to L1), indicated by domain `0`, is supported. Other "
"address domains which will be introduced in the future will behave "
"differently in terms of publication (in particular, they will not be posted "
"on L1, creating a tradeoff between cost and security)."
msgstr ""
"_address_domain_: 키의 도메인은 서로 다른 데이터 가용성 모드를 구분하는 데 사용됩니다. 이 분리는 Starknet에서 "
"서로 다른 데이터 가용성 모드를 제공하는 데 사용됩니다. 현재는 도메인 `0`으로 표시된 온체인 모드(모든 업데이트가 L1로 이동하는 "
"모드)만 지원됩니다. 향후 도입될 다른 주소 도메인은 게시 방식에서 다르게 작동하며(특히, L1에 게시되지 않으므로 비용과 보안 사이의 "
"균형을 유지합니다)."

#: src/appendix-07-system-calls.md:325 src/appendix-07-system-calls.md:368
msgid "_`address`_: The requested storage address."
msgstr "_`주소`_: 요청된 저장 주소."

#: src/appendix-07-system-calls.md:329
msgid "The value of the key, of type `SyscallResult<felt252>`."
msgstr "키의 값은 `SyscallResult<felt252>` 유형입니다."

#: src/appendix-07-system-calls.md:344
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"
msgstr ""
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60) \n"
"\n"
"[syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)"

#: src/appendix-07-system-calls.md:346
msgid "`storage_write`"
msgstr "`저장소_쓰기`"

#: src/appendix-07-system-calls.md:358
msgid "Sets the value of a key in the storage of the calling contract."
msgstr "호출하는 계약의 저장소에 있는 키의 값을 설정합니다."

#: src/appendix-07-system-calls.md:360
msgid ""
"This system call provides direct access to any possible key in storage, in "
"contrast with `var.write()`, which enables you to write to storage variables"
" that are defined explicitly in the contract."
msgstr ""
"이 시스템 호출은 저장소의 가능한 모든 키에 직접 액세스할 수 있도록 제공하며, 명시적으로 계약에서 정의된 저장소 변수에 쓸 수 있게 "
"하는 `var.write()`와 대조적입니다."

#: src/appendix-07-system-calls.md:370
msgid "_`value`_: The value to write to the key."
msgstr "_`value`_: 키에 쓸 값."

#: src/appendix-07-system-calls.md:378
msgid ""
"[syscalls.cairo](https://github.com/starkware-"
"libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)"
msgstr ""
