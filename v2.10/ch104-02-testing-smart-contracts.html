<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Testing Smart Contracts - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../theme/css/last-changed.css">
    <link rel="stylesheet" href="../theme/css/chat.css">
    <link rel="stylesheet" href="../theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2');
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.1.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.1.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.1.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.2.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.3.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Execution Model</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Registers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Instructions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.3.</strong> Cairo Assembly (CASM)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.4.</strong> State transition</div></li></ol></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Hints</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">25.1.</strong> Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.2.</strong> Hint runner</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.3.</strong> List of hints</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Runner</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="es">Español</a>
                                </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="fr">Français</a>
                                </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="zh-cn">简体中文</a>
                                </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="id">Indonesian</a>
                                </button></li>
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="tr">Turkçe</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("en");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            let full_path_to_root = "";
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch104-02-testing-smart-contracts.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-02-testing-smart-contracts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing-smart-contracts"><a class="header" href="#testing-smart-contracts">Testing Smart Contracts</a></h1>
<p>Testing smart contracts is a critical part of the development process. It is important to ensure that smart contracts behave as expected and that they are secure.</p>
<p>In a previous section of the Cairo Book, we learned how to write and structure our tests for Cairo programs. We demonstrated how these tests could be run using the <code>scarb</code> command-line tool.
While this approach is useful for testing standalone Cairo programs and functions, it lacks functionality for testing smart contracts that require control over the contract state and execution context. Therefore, in this section, we will introduce how to use Starknet Foundry, a smart contract development toolchain for Starknet, to test your Cairo contracts.</p>
<p>Throughout this chapter, we will be using as an example the <code>PizzaFactory</code> contract in Listing 18-1 to demonstrate how to write tests with Starknet Foundry.</p>
<pre><code class="language-cairo noplayground">use core::starknet::ContractAddress;

#[starknet::interface]
pub trait IPizzaFactory&lt;TContractState&gt; {
    fn increase_pepperoni(ref self: TContractState, amount: u32);
    fn increase_pineapple(ref self: TContractState, amount: u32);
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn change_owner(ref self: TContractState, new_owner: ContractAddress);
    fn make_pizza(ref self: TContractState);
    fn count_pizza(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
pub mod PizzaFactory {
    use super::IPizzaFactory;
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        pepperoni: u32,
        pineapple: u32,
        pub owner: ContractAddress,
        pizzas: u32,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.pepperoni.write(10);
        self.pineapple.write(10);
        self.owner.write(owner);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PizzaEmission: PizzaEmission,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PizzaEmission {
        pub counter: u32,
    }

    #[abi(embed_v0)]
    impl PizzaFactoryimpl of super::IPizzaFactory&lt;ContractState&gt; {
        fn increase_pepperoni(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pepperoni.write(self.pepperoni.read() + amount);
        }

        fn increase_pineapple(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pineapple.write(self.pineapple.read() + amount);
        }

        fn make_pizza(ref self: ContractState) {
            assert!(self.pepperoni.read() &gt; 0, "Not enough pepperoni");
            assert!(self.pineapple.read() &gt; 0, "Not enough pineapple");

            let caller: ContractAddress = get_caller_address();
            let owner: ContractAddress = self.get_owner();

            assert!(caller == owner, "Only the owner can make pizza");

            self.pepperoni.write(self.pepperoni.read() - 1);
            self.pineapple.write(self.pineapple.read() - 1);
            self.pizzas.write(self.pizzas.read() + 1);

            self.emit(PizzaEmission { counter: self.pizzas.read() });
        }

        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
            self.set_owner(new_owner);
        }

        fn count_pizza(self: @ContractState) -&gt; u32 {
            self.pizzas.read()
        }
    }

    #[generate_trait]
    pub impl InternalImpl of InternalTrait {
        fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
            let caller: ContractAddress = get_caller_address();
            assert!(caller == self.get_owner(), "Only the owner can set ownership");

            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p><span class="caption">Listing 18-1: A pizza factory that needs to be tested</span></p>
<h2 id="configuring-your-scarb-project-with-starknet-foundry"><a class="header" href="#configuring-your-scarb-project-with-starknet-foundry">Configuring your Scarb project with Starknet Foundry</a></h2>
<p>The settings of your Scarb project can be configured in the <code>Scarb.toml</code> file. To use Starknet Foundry as your testing tool, you will need to add it as a dev dependency in your <code>Scarb.toml</code> file. At the time of writing, the latest version of Starknet Foundry is <code>v0.22.0</code> - but you should use the latest version.</p>
<pre><code class="language-toml noplayground">[dev-dependencies]
snforge_std = "0.38.0"

[scripts]
test = "snforge test"
</code></pre>
<p>The <code>scarb test</code> command is configured to execute <code>scarb cairo-test</code> by default. In our settings, we have configured it to execute <code>snforge test</code> instead. This will allow us to run our tests using Starknet Foundry when we run the <code>scarb test</code> command.</p>
<p>Once your project is configured, you will need to install Starknet Foundry by following the installation guide from the <a href="https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html">Starknet Foundry Documentation</a>. As usual, we recommend to use <code>asdf</code> to manage versions of your development tools.</p>
<h2 id="testing-smart-contracts-with-starknet-foundry"><a class="header" href="#testing-smart-contracts-with-starknet-foundry">Testing Smart Contracts with Starknet Foundry</a></h2>
<p>The usual command to run your tests using Starknet Foundry is <code>snforge test</code>. However, when we configured our projects, we defined that the <code>scarb test</code> command will run the <code>snforge test</code> command. Therefore, during the rest of this chapter, consider that the <code>scarb test</code> command will be using <code>snforge test</code> under the hood.</p>
<p>The usual testing flow of a contract is as follows:</p>
<ol>
<li>Declare the class of the contract to test, identified by its name</li>
<li>Serialize the constructor calldata into an array</li>
<li>Deploy the contract and retrieve its address</li>
<li>Interact with the contract's entrypoint to test various scenarios</li>
</ol>
<h3 id="deploying-the-contract-to-test"><a class="header" href="#deploying-the-contract-to-test">Deploying the Contract to Test</a></h3>
<p>In Listing 18-2, we wrote a function that deploys the <code>PizzaFactory</code> contract and sets up the dispatcher for interactions.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use crate::pizza::{
</span><span class="boring">    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
</span><span class="boring">    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
</span><span class="boring">};
</span><span class="boring">use crate::pizza::PizzaFactory::{InternalTrait};
</span><span class="boring">
</span><span class="boring">use core::starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use core::starknet::storage::StoragePointerReadAccess;
</span><span class="boring">
</span><span class="boring">use snforge_std::{
</span><span class="boring">    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span>fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_set_as_new_owner_direct() {
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-2 Deploying the contract to test</span></p>
<h3 id="testing-our-contract"><a class="header" href="#testing-our-contract">Testing our Contract</a></h3>
<p>Determining the behavior that your contract should respect is the first step in writing tests. In the <code>PizzaFactory</code> contract, we determined that the contract should have the following behavior:</p>
<ul>
<li>Upon deployment, the contract owner should be set to the address provided in the constructor, and the factory should have 10 units of pepperoni and pineapple, and no pizzas created.</li>
<li>If someone tries to make a pizza and they are not the owner, the operation should fail. Otherwise, the pizza count should be incremented, and an event should be emitted.</li>
<li>If someone tries to take ownership of the contract and they are not the owner, the operation should fail. Otherwise, the owner should be updated.</li>
</ul>
<h4 id="accessing-storage-variables-with-load"><a class="header" href="#accessing-storage-variables-with-load">Accessing Storage Variables with <code>load</code></a></h4>
<pre><code class="language-cairo noplayground"><span class="boring">use crate::pizza::{
</span><span class="boring">    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
</span><span class="boring">    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
</span><span class="boring">};
</span><span class="boring">use crate::pizza::PizzaFactory::{InternalTrait};
</span><span class="boring">
</span><span class="boring">use core::starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use core::starknet::storage::StoragePointerReadAccess;
</span><span class="boring">
</span><span class="boring">use snforge_std::{
</span><span class="boring">    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_set_as_new_owner_direct() {
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-3: Testing the initial state by loading storage variables </span></p>
<p>Once our contract is deployed, we want to assert that the initial values are set as expected. If our contract has an entrypoint that returns the value of a storage variable, we can call this entrypoint. Otherwise, we can use the <code>load</code> function from <code>snforge</code> to load the value of a storage variable inside our contract, even if not exposed by an entrypoint.</p>
<h4 id="mocking-the-caller-address-with-start_cheat_caller_address"><a class="header" href="#mocking-the-caller-address-with-start_cheat_caller_address">Mocking the Caller Address with <code>start_cheat_caller_address</code></a></h4>
<p>The security of our factory relies on the owner being the only one able to make pizzas and transfer ownership. To test this, we can use the <code>start_cheat_caller_address</code> function to mock the caller address and assert that the contract behaves as expected.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use crate::pizza::{
</span><span class="boring">    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
</span><span class="boring">    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
</span><span class="boring">};
</span><span class="boring">use crate::pizza::PizzaFactory::{InternalTrait};
</span><span class="boring">
</span><span class="boring">use core::starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use core::starknet::storage::StoragePointerReadAccess;
</span><span class="boring">
</span><span class="boring">use snforge_std::{
</span><span class="boring">    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_set_as_new_owner_direct() {
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-4: Testing ownership of the contract by mocking the caller address </span></p>
<p>Using <code>start_cheat_caller_address</code>, we call the <code>change_owner</code> function first as the owner, and then as a different address. We assert that the operation fails when the caller is not the owner, and that the owner is updated when the caller is the owner.</p>
<h4 id="capturing-events-with-spy_events"><a class="header" href="#capturing-events-with-spy_events">Capturing Events with <code>spy_events</code></a></h4>
<p>When a pizza is created, the contract emits an event. To test this, we can use the <code>spy_events</code> function to capture the emitted events and assert that the event was emitted with the expected parameters. Naturally, we can also assert that the pizza count was incremented, and that only the owner can make a pizza.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use crate::pizza::{
</span><span class="boring">    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
</span><span class="boring">    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
</span><span class="boring">};
</span><span class="boring">use crate::pizza::PizzaFactory::{InternalTrait};
</span><span class="boring">
</span><span class="boring">use core::starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use core::starknet::storage::StoragePointerReadAccess;
</span><span class="boring">
</span><span class="boring">use snforge_std::{
</span><span class="boring">    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_set_as_new_owner_direct() {
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-5: Testing the events emitted when a pizza is created</span></p>
<h4 id="accessing-internal-functions-with-contract_state_for_testing"><a class="header" href="#accessing-internal-functions-with-contract_state_for_testing">Accessing Internal Functions with <code>contract_state_for_testing</code></a></h4>
<p>All the tests we have seen so far have been using a workflow that involves deploying the contract and interacting with the contract's entrypoints. However, sometimes we may want to test the internals of the contract directly, without deploying the contract. How could this be done, if we were reasoning in purely Cairo terms?</p>
<p>Recall the struct <code>ContractState</code>, which is used as a parameter to all the entrypoints of a contract. To make it short, this struct contains zero-sized fields, corresponding to the storage variables of the contract. The only purpose of these fields is to allow the Cairo compiler to generate the correct code for accessing the storage variables. If we could create an instance of this struct, we could access these storage variables directly, without deploying the contract...</p>
<p>...and this is exactly what the <code>contract_state_for_testing</code> function does! It creates an instance of the <code>ContractState</code> struct, allowing us to call any function that takes as parameter a <code>ContractState</code> struct, without deploying the contract. To interact with the storage variables properly, we need to manually import the traits that define access to the storage variables.</p>
<pre><code class="language-cairo noplayground"><span class="boring">use crate::pizza::{
</span><span class="boring">    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
</span><span class="boring">    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
</span><span class="boring">};
</span>use crate::pizza::PizzaFactory::{InternalTrait};
<span class="boring">
</span><span class="boring">use core::starknet::{ContractAddress, contract_address_const};
</span><span class="boring">use core::starknet::storage::StoragePointerReadAccess;
</span><span class="boring">
</span><span class="boring">use snforge_std::{
</span><span class="boring">    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    contract_address_const::&lt;'owner'&gt;()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
</span><span class="boring">    let contract = declare("PizzaFactory").unwrap().contract_class();
</span><span class="boring">
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    let constructor_calldata = array![owner.into()];
</span><span class="boring">
</span><span class="boring">    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
</span><span class="boring">
</span><span class="boring">    let dispatcher = IPizzaFactoryDispatcher { contract_address };
</span><span class="boring">
</span><span class="boring">    (dispatcher, contract_address)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_constructor() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
</span><span class="boring">    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
</span><span class="boring">    assert_eq!(pepperoni_count, array![10]);
</span><span class="boring">    assert_eq!(pineapple_count, array![10]);
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_change_owner_should_change_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">
</span><span class="boring">    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), owner());
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">
</span><span class="boring">    pizza_factory.change_owner(new_owner);
</span><span class="boring">
</span><span class="boring">    assert_eq!(pizza_factory.get_owner(), new_owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can set ownership")]
</span><span class="boring">fn test_change_owner_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">    pizza_factory.change_owner(not_owner);
</span><span class="boring">    stop_cheat_caller_address(pizza_factory_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Only the owner can make pizza")]
</span><span class="boring">fn test_make_pizza_should_panic_when_not_owner() {
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, not_owner);
</span><span class="boring">
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_pizza_should_increment_pizza_counter() {
</span><span class="boring">    // Setup
</span><span class="boring">    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
</span><span class="boring">    start_cheat_caller_address(pizza_factory_address, owner());
</span><span class="boring">    let mut spy = spy_events();
</span><span class="boring">
</span><span class="boring">    // When
</span><span class="boring">    pizza_factory.make_pizza();
</span><span class="boring">
</span><span class="boring">    // Then
</span><span class="boring">    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
</span><span class="boring">    assert_eq!(pizza_factory.count_pizza(), 1);
</span><span class="boring">    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_set_as_new_owner_direct() {
</span><span class="boring">    let mut state = PizzaFactory::contract_state_for_testing();
</span><span class="boring">    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
</span><span class="boring">    state.set_owner(owner);
</span><span class="boring">    assert_eq!(state.owner.read(), owner);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p><span class="caption">Listing 18-6: Unit testing our contract without deployment</span></p>
<p>These imports give us access to our internal functions (notably, <code>set_owner</code>), as well as the
read/write access to the <code>owner</code> storage variable. Once we have these, we can interact with the
contract directly, changing the address of the owner by calling the <code>set_owner</code> method, accessible
through <code>InternalTrait</code>, and reading the <code>owner</code> storage variable.</p>
<blockquote>
<p>Note: Both approaches cannot be used at the same time. If you decide to deploy the contract, you interact with it using the dispatcher. If you decide to test the internal functions, you interact with the <code>ContractState</code> object directly.</p>
</blockquote>
<pre><code class="language-bash noplayground">$ scarb test
     Running test listing_02_pizza_factory_snfoundry (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.99s
   Compiling test(listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/Scarb.toml)
    Finished `dev` profile target(s) in 7 seconds


Collected 6 test(s) from listing_02_pizza_factory_snfoundry package
Running 6 test(s) from src/
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_set_as_new_owner_direct (gas: ~130)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_panic_when_not_owner (gas: ~298)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_constructor (gas: ~297)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_panic_when_not_owner (gas: ~298)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_increment_pizza_counter (gas: ~368)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_change_owner (gas: ~303)
Tests: 6 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

</code></pre>
<p>The output of the tests shows that all the tests passed successfully, along with an estimation of the gas consumed by each test.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we learned how to test smart contracts using Starknet Foundry. We demonstrated how to deploy a contract and interact with it using the dispatcher. We also showed how to test the contract's behavior by mocking the caller address and capturing events. Finally, we demonstrated how to test the internal functions of the contract directly, without deploying the contract.</p>
<p>To learn more about Starknet Foundry, refer to the <a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch104-01-general-recommendations.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch104-03-static-analysis-tools.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch104-01-general-recommendations.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch104-03-static-analysis-tools.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function (i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date(); a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

                ga('create', 'G-0ZJLBV4KE2', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="../theme/chat.js"></script>
        <script src="../theme/js/index.mjs"></script>
        <script src="../theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
