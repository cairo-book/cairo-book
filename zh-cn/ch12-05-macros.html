<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Macros - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch12-05-macros.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch104-02-01-unit-testing.html"><strong aria-hidden="true">18.2.1.</strong> Unit Testing</a></li><li class="chapter-item "><a href="ch104-02-02-integration-testing.html"><strong aria-hidden="true">18.2.2.</strong> Integration Testing</a></li><li class="chapter-item "><a href="ch104-02-03-fuzz-testing.html"><strong aria-hidden="true">18.2.3.</strong> Property-Based Testing</a></li><li class="chapter-item "><a href="ch104-02-04-fork-testing.html"><strong aria-hidden="true">18.2.4.</strong> Fork Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("zh-cn");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch12-05-macros.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-05-macros.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Cairo: <em>declarative</em> macros with <code>macro</code> and three kinds of
<em>procedural</em> macros covered in
<a href="./ch12-10-procedural-macros.html">Procedural Macros</a>:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<h2 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h2>
<p>Fundamentally, macros are a way of writing code that writes other code, which is
known as <em>metaprogramming</em>. In Appendix C, we discuss derivable traits and the
<code>derive</code> attribute, which generates an implementation of various traits for you.
We’ve also used the <code>println!</code> and <code>array!</code> macros throughout the book. All of
these macros <em>expand</em> to produce more code than the code you’ve written
manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have some
additional powers that functions don’t.</p>
<p>A function signature must declare the number and type of parameters the function
has. Macros, on the other hand, can take a variable number of parameters: we can
call <code>println!("hello")</code> with one argument or <code>println!("hello {}", name)</code> with
two arguments. Also, macros are expanded before the compiler interprets the
meaning of the code, so a macro can, for example, implement a trait on a given
type. A function can’t, because it gets called at runtime and a trait needs to
be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Cairo code — or, even more complex, Rust code — that writes Cairo code. Due to
this indirection, macro definitions are generally more difficult to read,
understand, and maintain than function definitions.</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<h2 id="declarative-inline-macros-for-general-metaprogramming"><a class="header" href="#declarative-inline-macros-for-general-metaprogramming">Declarative Inline Macros for General Metaprogramming</a></h2>
<p>The most simple form of macros in Cairo is the <em>declarative macro</em>, also
sometimes referred to as just plain “macros.” At their core, declarative macros
allow you to write something similar to a <code>match</code> expression. As discussed in
<a href="./ch06-00-enums-and-pattern-matching.html">Chapter 6</a>, <code>match</code> expressions are
control structures that take an expression, compare the resultant value of the
expression to patterns, and then run the code associated with the matching
pattern. Macros also compare a value to patterns that are associated with
particular code: in this situation, the value is the literal Cairo source code
passed to the macro; the patterns are compared with the structure of that source
code; and the code associated with each pattern, when matched, replaces the code
passed to the macro. This all happens during compilation.</p>
<p>To define a macro, you use the <code>macro</code> construct. Let’s explore this style by
looking at how an “array-building” macro works. Earlier, we used Cairo’s
built-in <code>array!</code> macro to create arrays with particular values. For example,
the following creates a new array containing three integers:</p>
<pre><code class="language-cairo">let a = array![1, 2, 3];
</code></pre>
<p>We could also use <code>array!</code> to make an array of two integers or five values of
other types, because the macro can accept a variable number of arguments. We
wouldn’t be able to use a regular function to do the same because we wouldn’t
know the number or types of values up front.</p>
<p>Below is a slightly simplified definition of an array-building macro written in
Cairo. It isn’t the exact <code>array!</code> macro from the core library, but it shows the
same core idea using declarative inline macros:</p>
<pre><code class="language-cairo">macro make_array {
    ($($x:expr), *) =&gt; {
        {
            let mut arr = $defsite::ArrayTrait::new();
            $(arr.append($x);)*
            arr
        }
    };
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<blockquote>
<p>Note: The built-in <code>array!</code> macro in the standard library may include
optimizations (like reserving capacity) that we don’t include here to keep the
example simple.</p>
</blockquote>
<p>The structure of the macro body is similar to a <code>match</code> expression. Here we have
one arm with the pattern <code>($($x:expr), *)</code>, followed by <code>=&gt;</code> and the block of
code associated with this pattern. If the pattern matches, the associated block
of code is emitted. More complex macros can have multiple arms, each with a
different pattern.</p>
<p>Pattern syntax in macro definitions differs from pattern syntax used when
matching values: macro patterns are matched against Cairo source code structure.
Let’s walk through the pattern pieces in the example above:</p>
<ul>
<li>We use parentheses to encompass the whole matcher pattern.</li>
<li>A dollar sign (<code>$</code>) introduces a macro variable that will capture the code
matching the subpattern. Within <code>$()</code> is <code>$x:expr</code>, which matches any Cairo
expression and gives that expression the name <code>$x</code>.</li>
<li>The comma following <code>$()</code> requires literal commas between each matched
expression.</li>
<li>The <code>*</code> quantifier specifies the subpattern can repeat zero or more times.</li>
</ul>
<p>When we call this macro with <code>make_array![1, 2, 3]</code>, the <code>$x</code> pattern matches
three times: the expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now look at the expansion side: <code>$(arr.append($x);)*</code> is generated once for each
match of <code>$()</code> in the pattern. The <code>$x</code> is replaced with each matched
expression. Calling <code>make_array![1, 2, 3]</code> expands to code like the following:</p>
<blockquote>
<p>Note: The VSCode extension can help you inspect the expanded code by doing
<code>Ctrl+Shift+P</code> and then <code>Cairo: Recursively expand macros for item at caret</code>.</p>
</blockquote>
<pre><code class="language-cairo ignore">{
    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr
}
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and
generate code to create an array containing the specified elements.</p>
<p>Usage looks like this:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span>    let a = make_array![1, 2, 3];
<span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>To use them, enable the experimental feature in your <code>Scarb.toml</code>:</p>
<pre><code class="language-toml"># [package]
# name = "listing_inline_macros"
# version = "0.1.0"
# edition = "2024_07"
# 
experimental-features = ["user_defined_inline_macros"]
# 
# [cairo]
# 
# [dependencies]
# cairo_execute = "2.13.1"
# 
# [dev-dependencies]
# snforge_std = "0.51.1"
# assert_macros = "2.13.1"
# 
# [scripts]
# test = "snforge test"
# 
# [tool.scarb]
# allow-prebuilt-plugins = ["snforge_std"]
</code></pre>
<p>Inline macros are defined with <code>macro name { ... }</code> where each arm matches a
code pattern and expands to replacement code. Like Rust’s macros-by-example, you
capture syntax fragments with <code>$var: kind</code> and can repeat matches with <code>$()*</code>,
<code>$()+</code>, or <code>$()?</code>.</p>
<!-- Removed trivial first macro example to reduce redundancy with array example -->
<h3 id="hygiene-defsitecallsite-and-expose"><a class="header" href="#hygiene-defsitecallsite-and-expose">Hygiene, <code>$defsite</code>/<code>$callsite</code>, and <code>expose!</code></a></h3>
<p>Cairo’s inline macros are hygienic: names introduced in the macro definition
don’t leak into the call site unless you explicitly expose them. Name resolution
within macros can reference either the macro definition site or the call site
using <code>$defsite::</code> and <code>$callsite::</code>.</p>
<p>Note that, similarly to Rust, macros are expected to expand to a single
expression; thus, if your macro defines several statements, you should wrap them
with an additional <code>{}</code> block that returns a final expression.</p>
<p>The following end-to-end example illustrates all of these aspects together:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span>mod hygiene_demo {
    // A helper available at the macro definition site
    fn def_bonus() -&gt; u8 {
        10
    }

    // Adds the defsite bonus, regardless of what exists at the callsite
    pub macro add_defsite_bonus {
        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
    }

    // Adds the callsite bonus, resolved where the macro is invoked
    pub macro add_callsite_bonus {
        ($x: expr) =&gt; { $x + $callsite::bonus() };
    }

    // Exposes a variable to the callsite using `expose!`.
    pub macro apply_and_expose_total {
        ($base: expr) =&gt; {
            let total = $base + 1;
            expose!(let exposed_total = total;);
        };
    }

    // A helper macro that reads a callsite-exposed variable
    pub macro read_exposed_total {
        () =&gt; { $callsite::exposed_total };
    }

    // Wraps apply_and_expose_total and then uses another inline macro
    // that accesses the exposed variable via `$callsite::...`.
    pub macro wrapper_uses_exposed {
        ($x: expr) =&gt; {
            {
                $defsite::apply_and_expose_total!($x);
                $defsite::read_exposed_total!()
            }
        };
    }
}
<span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span><span class="boring">
</span><span class="boring">    // Callsite defines its own `bonus` — used only by callsite-resolving macro
</span><span class="boring">    let bonus = | | -&gt; u8 {
</span><span class="boring">        20
</span><span class="boring">    };
</span><span class="boring">    let price: u8 = 5;
</span><span class="boring">    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
</span><span class="boring">    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20
</span><span class="boring">
</span><span class="boring">    // Call in statement position; it exposes `exposed_total` at the callsite
</span><span class="boring">    apply_and_expose_total!(3);
</span><span class="boring">    assert_eq!(exposed_total, 4);
</span><span class="boring">
</span><span class="boring">    // A macro invoked by another macro can access exposed values via `$callsite::...`
</span><span class="boring">    let w = wrapper_uses_exposed!(7);
</span><span class="boring">    assert_eq!(w, 8);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Usage at the call site:</p>
<pre><code class="language-cairo"><span class="boring">macro make_array {
</span><span class="boring">    ($($x:expr), *) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            let mut arr = $defsite::ArrayTrait::new();
</span><span class="boring">            $(arr.append($x);)*
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_make_array() {
</span><span class="boring">    let a = make_array![1, 2, 3];
</span><span class="boring">    let expected = array![1, 2, 3];
</span><span class="boring">    assert_eq!(a, expected);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod hygiene_demo {
</span><span class="boring">    // A helper available at the macro definition site
</span><span class="boring">    fn def_bonus() -&gt; u8 {
</span><span class="boring">        10
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the defsite bonus, regardless of what exists at the callsite
</span><span class="boring">    pub macro add_defsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Adds the callsite bonus, resolved where the macro is invoked
</span><span class="boring">    pub macro add_callsite_bonus {
</span><span class="boring">        ($x: expr) =&gt; { $x + $callsite::bonus() };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Exposes a variable to the callsite using `expose!`.
</span><span class="boring">    pub macro apply_and_expose_total {
</span><span class="boring">        ($base: expr) =&gt; {
</span><span class="boring">            let total = $base + 1;
</span><span class="boring">            expose!(let exposed_total = total;);
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // A helper macro that reads a callsite-exposed variable
</span><span class="boring">    pub macro read_exposed_total {
</span><span class="boring">        () =&gt; { $callsite::exposed_total };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Wraps apply_and_expose_total and then uses another inline macro
</span><span class="boring">    // that accesses the exposed variable via `$callsite::...`.
</span><span class="boring">    pub macro wrapper_uses_exposed {
</span><span class="boring">        ($x: expr) =&gt; {
</span><span class="boring">            {
</span><span class="boring">                $defsite::apply_and_expose_total!($x);
</span><span class="boring">                $defsite::read_exposed_total!()
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use hygiene_demo::{
</span><span class="boring">    add_callsite_bonus, add_defsite_bonus, apply_and_expose_total, wrapper_uses_exposed,
</span><span class="boring">};
</span><span class="boring">#[cfg(test)]
</span><span class="boring">#[test]
</span><span class="boring">fn test_hygiene_e2e() {
</span>
    // Callsite defines its own `bonus` — used only by callsite-resolving macro
    let bonus = | | -&gt; u8 {
        20
    };
    let price: u8 = 5;
    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20

    // Call in statement position; it exposes `exposed_total` at the callsite
    apply_and_expose_total!(3);
    assert_eq!(exposed_total, 4);

    // A macro invoked by another macro can access exposed values via `$callsite::...`
    let w = wrapper_uses_exposed!(7);
    assert_eq!(w, 8);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>What this demonstrates:</p>
<ul>
<li><code>$defsite::...</code> resolves to items next to the macro definition, stable across
call sites.</li>
<li><code>$callsite::...</code> resolves to items visible where the macro is invoked.</li>
<li>Names don’t leak by default; <code>expose!</code> can deliberately introduce new items
into the call site.</li>
<li>Exposed names are accessible to other inline macros invoked inside your macro
body via <code>$callsite::name</code>.</li>
</ul>
<!-- Removed standalone repetition section; already covered in make_array example matcher and expansion explanation. -->
<!-- Consolidated into the hygiene e2e example above. -->
<!-- Covered by the hygiene e2e example (returns from a block). -->
<!-- Omitted to keep this section focused on core concepts for release notes. -->
<p>Notes:</p>
<ul>
<li>This feature is experimental; syntax and capabilities may evolve.</li>
<li>Item-producing macros (structs, enums, functions, etc.) are not yet supported;
support will be added in future versions.</li>
<li>For attributes, derives, and crate-wide transformations, prefer procedural
macros (next section).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch12-04-hash.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch12-10-procedural-macros.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch12-04-hash.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch12-10-procedural-macros.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
