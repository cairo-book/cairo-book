<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Closures: Anonymous Functions that Capture Their Environment - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch11-01-closures.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("zh-cn");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch11-01-closures.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch11-01-closures.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures are anonymous functions you can save in a variable or pass as arguments
to other functions. You can create the closure in one place and then call the
closure elsewhere to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<blockquote>
<p>Note: Closures were introduced in Cairo 2.9 and are still under development.
Some new features will be introduced in future versions of Cairo, so this page
will evolve accordingly.</p>
</blockquote>
<h2 id="understanding-closures"><a class="header" href="#understanding-closures">Understanding Closures</a></h2>
<p>When writing Cairo programs, you'll often need to pass behavior as a parameter
to another function. Closures provide a way to define this behavior inline,
without creating a separate named function. They are particularly valuable when
working with collections, error handling, and any scenario where you want to
customize how a function behaves using a function as a parameter.</p>
<p>Consider a simple example where we want to process numbers differently based on
some condition. Instead of writing multiple functions, we can use closures to
define the behavior where we need it:</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));
<span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<p>The closure's arguments go between the pipes (<code>|</code>). Note that we don't have to
specify the types of arguments and of the return value (see <code>double</code> closure),
they will be inferred from the closure usage, as it is done for any variables.
Of course, if you use a closure with different types, you will get a
<code>Type annotations needed</code> error, telling you that you have to choose and specify
the closure argument types.</p>
<p>The body is an expression, on a single line without <code>{}</code> like <code>double</code> or on
several lines with <code>{}</code> like <code>sum</code>.</p>
<h2 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h2>
<p>One of the interests of closures is that they can include bindings from their
enclosing scope.</p>
<p>In the following example, <code>my_closure</code> use a binding to <code>x</code> to compute
<code>x + value * 3</code>.</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span>    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));
<span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Note that, at the moment, closures are still not allowed to capture mutable
variables, but this will be supported in future Cairo versions.</p>
</blockquote>
<h2 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h2>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 11-1. In this example, we’re defining a
closure and storing it in a variable rather than defining the closure in the
spot we pass it as an argument as we did in Listing 13-1.</p>
<pre><code class="language-cairo"><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!("Today, run for {} minutes!", expensive_closure(intensity));
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre>
<p>annotations of the parameter and return value types in the closure</p>
<!-- TODO: rework the example to add a println!(...) inside the closure -->
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces to
line up the relevant parts. This illustrates how closure syntax is similar to
function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<pre><code class="language-cairo  ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let array = array![];</code> needing either type annotations or values of
some type to be inserted into the <code>array</code> for Cairo to be able to infer the
type.</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing
11-2 shows the definition of a short closure that
just returns the value it receives as a parameter. This closure isn’t very
useful except for the purposes of this example. Note that we haven’t added any
type annotations to the definition. Because there are no type annotations, we
can call the closure with any type, which we’ve done here with <code>u64</code> the first
time. If we then try to call <code>example_closure</code> with a <code>u32</code>, we’ll get an error.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">//TAG: does_not_compile
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(5_u64);
    let n = example_closure(5_u32);
<span class="boring">}
</span></code></pre>
<p>Attempting to call a closure whose types are inferred with two different types</p>
<p>The compiler gives us this error:</p>
<pre><code>$ scarb build 
   Compiling listing_closure_different_types v0.1.0 (listings/ch11-functional-features/listing_closure_different_types/Scarb.toml)
warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:7:9
    let s = example_closure(5_u64);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:9
    let n = example_closure(5_u32);
        ^

error: Trait has no implementation in context: core::ops::function::Fn::&lt;{closure@listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:5:27: 5:30}, (core::integer::u32,)&gt;.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:13
    let n = example_closure(5_u32);
            ^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `listing_closure_different_types` due to 1 previous error and 2 warnings

</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>u64</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>u64</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
<!-- TODO: add a section on capturing references or moving ownership once supported -->
<h2 id="moving-captured-values-out-of-closures-and-the-fn-traits"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the <code>Fn</code> Traits</a></h2>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure). A closure body can
do any of the following: move a captured value out of the closure, neither move
nor mutate the value, or capture nothing from the environment to begin with.</p>
<!-- TODO: later, closures will be able to do any of the followings: -->
<!-- A closure body can
do any of the following: move a captured value out of the closure, mutate the
captured value, neither move nor mutate the value, or capture nothing from the
environment to begin with. -->
<p>The way a closure captures and handles values from the environment affects which
traits the closure implements, and traits are how functions and structs can
specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<ol>
<li>
<p><code>FnOnce</code> applies to closures that can be called once. All closures implement
at least this trait, because all closures can be called. A closure that moves
captured values out of its body will only implement <code>FnOnce</code> and none of the
other <code>Fn</code> traits, because it can only be called once.</p>
</li>
<li>
<p><code>Fn</code> applies to closures that don’t move captured values out of their body
and that don’t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.</p>
</li>
</ol>
<!-- TODO: later on,
2. `FnMut` applies to closures that don’t move captured values out of their
   body, but that might mutate the captured values. These closures can be
   called more than once.
-->
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>OptionTrait&lt;T&gt;</code>
that we used in Listing 13-1:</p>
<pre><code class="language-cairo  ignore">pub impl OptionTraitImpl&lt;T&gt; of OptionTrait&lt;T&gt; {
    #[inline]
    fn unwrap_or_else&lt;F, +Drop&lt;F&gt;, impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T], +Drop&lt;func::Output&gt;&gt;(
        self: Option&lt;T&gt;, f: F,
    ) -&gt; T {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the
<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the
<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an
<code>Option&lt;ByteArray&gt;</code>, for example, will get a <code>ByteArray</code>.</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type
parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is the
closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>The trait bound specified on the generic type <code>F</code> is
<code>impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T]</code>, which means <code>F</code> must be able
to be called once, take no arguments (the unit type <code>()</code> is used), and return a
<code>T</code> as output. Using <code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of
<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be
called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all closures
implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all two kinds of closures and is as
flexible as it can be.</p>
<!-- TODO: all _three_ types of closures -->
<!-- > Note: Functions can implement all two of the `Fn` traits too. If what we
> want to do doesn’t require capturing a value from the environment, we can use
> the name of a function rather than a closure where we need something that
> implements one of the `Fn` traits. For example, on an `Option<Vec<T>>` value,
> we could call `unwrap_or_else(Vec::new)` to get a new, empty vector if the
> value is `None`. -->
<!-- TODO: function _do not_ implement the `Fn` traits yet. -->
<!-- TODO: all _three_ types of the `Fn` traits -->
<!-- TODO: add examples using FnMut from a corelib function once it exists. -->
<p>The <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
<p>Under the hood, closures are implemented through <code>FnOnce</code> and <code>Fn</code> traits.
<code>FnOnce</code> is implemented for closures that may consume captured variables, where
<code>Fn</code> is implemented for closures that capture only copyable variables.</p>
<h2 id="implementing-your-functional-programming-patterns-with-closures"><a class="header" href="#implementing-your-functional-programming-patterns-with-closures">Implementing Your Functional Programming Patterns with Closures</a></h2>
<p>Another great interest of closures is that, like any type of variables, you can
pass them as function arguments. This mechanism is massively used in functional
programming, through classic functions like <code>map</code>, <code>filter</code> or <code>reduce</code>.</p>
<p>Here is a potential implementation of <code>map</code> to apply a same function to all the
items of an array:</p>
<pre><code class="language-cairo  noplayground">#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;func::Output&gt; {
        let mut output: Array&lt;func::Output&gt; = array![];
        for elem in self {
            output.append(f(elem));
        }
        output
    }
}
<span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Note that, due to a bug in inlining analysis, this analysis process should be
disabled using <code>#[inline(never)]</code>.</p>
</blockquote>
<p>In this implementation, you'll notice that, while <code>T</code> is the element type of the
input array <code>self</code>, the element type of the output array is defined by the
output type of the <code>f</code> closure (the associated type <code>func::Output</code> from the <code>Fn</code>
trait).</p>
<p>This means that your <code>f</code> closure can return the same type of elements like as
for <code>_double</code> in the following code, or any other type of elements like as for
<code>_another</code>:</p>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span>    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);
<span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>Currently, Cairo 2.9 provides an experimental feature allowing you to specify
the associated type of trait, using
<code>experimental-features = ["associated_item_constraints"]</code> in your
<code>Scarb.toml</code>.</p>
</blockquote>
<p>Let's say we want to implement the <code>filter</code> function for arrays, to filter out
elements which do not match a criteria. This criteria will be provided through a
closure which takes an element as input, and return <code>true</code> if the element has to
be kept, <code>false</code> otherwise. That means, we need to specify that the closure must
return a <code>boolean</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter&lt;
        T,
        +Copy&lt;T&gt;,
        +Drop&lt;T&gt;,
        F,
        +Drop&lt;F&gt;,
        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
        +Drop&lt;func::Output&gt;,
    &gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;T&gt; {
        let mut output: Array&lt;T&gt; = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        }
        output
    }
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span><span class="boring">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
</span><span class="boring">    println!("even: {:?}", even);
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-cairo"><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayExt of ArrayExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;func::Output&gt; {
</span><span class="boring">        let mut output: Array&lt;func::Output&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            output.append(f(elem));
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[generate_trait]
</span><span class="boring">impl ArrayFilterExt of ArrayFilterExtTrait {
</span><span class="boring">    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
</span><span class="boring">    #[inline(never)]
</span><span class="boring">    fn filter&lt;
</span><span class="boring">        T,
</span><span class="boring">        +Copy&lt;T&gt;,
</span><span class="boring">        +Drop&lt;T&gt;,
</span><span class="boring">        F,
</span><span class="boring">        +Drop&lt;F&gt;,
</span><span class="boring">        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
</span><span class="boring">        +Drop&lt;func::Output&gt;,
</span><span class="boring">    &gt;(
</span><span class="boring">        self: Array&lt;T&gt;, f: F,
</span><span class="boring">    ) -&gt; Array&lt;T&gt; {
</span><span class="boring">        let mut output: Array&lt;T&gt; = array![];
</span><span class="boring">        for elem in self {
</span><span class="boring">            if f(elem) {
</span><span class="boring">                output.append(elem);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        output
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let double = |value| value * 2;
</span><span class="boring">    println!("Double of 2 is {}", double(2_u8));
</span><span class="boring">    println!("Double of 4 is {}", double(4_u8));
</span><span class="boring">
</span><span class="boring">    // This won't work because `value` type has been inferred as `u8`.
</span><span class="boring">    //println!("Double of 6 is {}", double(6_u16));
</span><span class="boring">
</span><span class="boring">    let sum = |x: u32, y: u32, z: u16| {
</span><span class="boring">        x + y + z.into()
</span><span class="boring">    };
</span><span class="boring">    println!("Result: {}", sum(1, 2, 3));
</span><span class="boring">
</span><span class="boring">    let x = 8;
</span><span class="boring">    let my_closure = |value| {
</span><span class="boring">        x * (value + 3)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("my_closure(1) = {}", my_closure(1));
</span><span class="boring">
</span><span class="boring">    let double = array![1, 2, 3].map(|item: u32| item * 2);
</span><span class="boring">    let another = array![1, 2, 3].map(|item: u32| {
</span><span class="boring">        let x: u64 = item.into();
</span><span class="boring">        x * x
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("double: {:?}", double);
</span><span class="boring">    println!("another: {:?}", another);
</span><span class="boring">
</span>    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
<span class="boring">}
</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch11-00-functional-features.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch12-00-advanced-features.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch11-00-functional-features.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch12-00-advanced-features.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
