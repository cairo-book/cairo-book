




[[questions]]
type = "MultipleChoice"
prompt.prompt = """
Which of these options can be used to define a custom data structure with a generic type?
"""
prompt.distractors = [
  "Array<T>",
  "struct<T>",
  "Felt252Dict<T>",
]
answer.answer = "struct<T>"


[[questions]]
type = "MultipleChoice"
prompt.prompt = """
Which of these in cairo simulate the behavior of mutable data structure?
"""
prompt.distractors = [
  "Array",
  "struct",
  "Felt252Dict",
]
answer.answer = "Felt252Dict"



[[questions]]
type = "Tracing"
prompt.program = """
This program employs a custom  data structure along with felt252Dic to enable data mutability. What will be the output of this program?
```
struct BookStore<T> {
    total_books: u64,
    books:  Felt252Dict<T>,
}

pub trait BookTrait<T> {
    fn init() -> BookStore<T>;
    fn update_book<+Drop<T>>(ref self: BookStore<T>, author: felt252, book: T);
    fn get_book<+Copy<T>>(ref self: BookStore<T>,  author: felt252) -> T;
}

impl BookImpl<T, +Felt252DictValue<T>> of BookTrait<T> {

    fn init() -> BookStore<T> {
        BookStore { total_books: 0, books: Default::default() }
    }

    fn update_book<+Drop<T>>(ref self: BookStore<T>, author: felt252, book: T) {
        self.books.insert(author, book);
        self.total_books += 1;
    }

    fn get_book<+Copy<T>>(ref self: BookStore<T>, author: felt252) -> T {
        self.books.get(author)
    }

  
}

impl BookStoreDestruct<T, +Drop<T>, +Felt252DictValue<T>> of Destruct<BookStore<T>> {
    fn destruct(self: BookStore<T>) nopanic {
        self.books.squash();
    }
}


fn main() {
    let mut book = BookTrait::init();

    book.update_book('George', '1984');
    book.update_book('George', 'Beloved');

    let author_george = book.get_book('George');
    println!("{}", author_george)
}
```
"""
answer.doesCompile = true
answer.stdout = "Beloved"

