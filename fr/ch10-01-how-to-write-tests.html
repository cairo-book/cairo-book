<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>How To Write Tests - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch10-01-how-to-write-tests.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("fr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch10-01-how-to-write-tests.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch10-01-how-to-write-tests.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How To Write Tests</a></h1>
<h2 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h2>
<p>Tests are Cairo functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ul>
<p>Let’s look at the features Cairo provides for writing tests that take these
actions, which include:</p>
<ul>
<li><code>#[test]</code> attribute.</li>
<li><code>assert!</code>macro.</li>
<li><code>assert_eq!</code>, <code>assert_ne!</code>, <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and
<code>assert_ge!</code> macros. In order to use them, you will need to add
<code>assert_macros = "2.8.2"</code> as a dev dependency.</li>
<li><code>#[should_panic]</code> attribute.</li>
</ul>
<blockquote>
<p>Note: Make sure to select Starknet Foundry as a test runner when creating your
project.</p>
</blockquote>
<h3 id="the-anatomy-of-a-test-function-1"><a class="header" href="#the-anatomy-of-a-test-function-1">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Cairo is a function that’s annotated with the
<code>#[test]</code> attribute. Attributes are metadata about pieces of Cairo code; one
example is the <code>#[derive()]</code> attribute we used with structs in <a href="./ch05-01-defining-and-instantiating-structs.html">Chapter
5</a>. To change a
function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you
run your tests with the <code>scarb test</code> command, Scarb runs Starknet Foundry's test
runner binary that runs the annotated functions and reports on whether each test
function passes or fails.</p>
<p>Let's create a new project called <em>adder</em> using Scarb with the command
<code>scarb new adder</code>. Remove the <em>tests</em> folder.</p>
<pre><code class="language-shell">adder
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<p>In <em>lib.cairo</em>, let's remove the existing content and add a <code>tests</code> module
containing the first test, as shown in Listing 10-1.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>simple test function</span></p>
<p>Note the <code>#[test]</code> annotation: this attribute indicates this is a test function,
so the test runner knows to treat this function as a test. We might also have
non-test functions to help set up common scenarios or perform common operations,
so we always need to indicate which functions are tests.</p>
<p>We use the <code>#[cfg(test)]</code> attribute for the <code>tests</code> module, so that the compiler
knows the code it contains needs to be compiled only when running tests. This is
actually not an option: if you put a simple test with the <code>#[test]</code> attribute in
a <em>lib.cairo</em> file, it will not compile. We will talk more about the
<code>#[cfg(test)]</code> attribute in the next <a href="./ch10-02-test-organization.html">Test Organization</a>
section.</p>
<p>The example function body uses the <code>assert_eq!</code> macro, which contains the result
of adding 2 and 2, which equals 4. This assertion serves as an example of the
format for a typical test. We'll explain in more detail how <code>assert_eq!</code> works
later in this chapter. Let’s run it to see that this test passes.</p>
<p>The <code>scarb test</code> command runs all tests found in our project, and shows the
following output:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p><code>scarb test</code> compiled and ran the test. We see the line
<code>Collected 1 test(s) from adder package</code> followed by the line
<code>Running 1 test(s) from src/</code>. The next line shows the name of the test
function, called <code>it_works</code>, and that the result of running that test is <code>ok</code>.
The test runner also provides an estimation of the gas consumption. The overall
summary shows that all the tests passed, and the portion that reads
<code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular
instance; we’ll cover that in the
<a href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a>
section later in this chapter. Because we haven’t done that here, the summary
shows <code>0 ignored</code>. We can also pass an argument to the <code>scarb test</code> command to
run only a test whose name matches a string; this is called filtering and we’ll
cover that in the <a href="#running-single-tests">Running Single Tests</a> section. Since
we haven’t filtered the tests being run, the end of the summary shows
<code>0 filtered out</code>.</p>
<p>Let’s start to customize the test to our own needs. First change the name of the
<code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
</code></pre>
<p>Then run <code>scarb test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests
fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. Enter the new test as a function named <code>another</code>, so your
<em>src/lib.cairo</em> file looks like in Listing 10-2.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        let result = 2 + 2;
        assert!(result == 6, "Make this test fail");
    }
}
</code></pre>
<p>Adding a second test in <em>lib.cairo</em> that will fail</span></p>
<p>Run <code>scarb test</code> and you will see the following output:</p>
<pre><code class="language-shell">Collected 2 test(s) from adder package
Running 2 test(s) from src/
[FAIL] adder::tests::another

Failure data:
    "Make this test fail"

[PASS] adder::tests::exploration (gas: ~1)
Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out

Failures:
    adder::tests::another
</code></pre>
<p>Instead of <code>[PASS]</code>, the line <code>adder::tests::another</code> shows <code>[FAIL]</code>. A new
section appears between the individual results and the summary. It displays the
detailed reason for each test failure. In this case, we get the details that
<code>another</code> failed because it panicked with <code>"Make this test fail"</code> error.</p>
<p>After that, the summary line is displayed: we had one test pass and one test
fail. At the end, we see a list of the failing tests.</p>
<p>Now that you've seen what the test results look like in different scenarios,
let’s look at some functions that are useful in tests.</p>
<h2 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h2>
<p>The <code>assert!</code> macro, provided by Cairo, is useful when you want to ensure that
some condition in a test evaluates to <code>true</code>. We give the <code>assert!</code> macro the
first argument that evaluates to a boolean. If the value is <code>true</code>, nothing
happens and the test passes. If the value is <code>false</code>, the <code>assert!</code> macro calls
<code>panic()</code> to cause the test to fail with a message we defined as the second
argument. Using the <code>assert!</code> macro helps us check that our code is functioning
in the way we intended.</p>
<p>Remember in <a href="./ch05-03-method-syntax.html">Chapter
5</a>, we used a
<code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing
10-3. Let’s put this code in the <em>src/lib.cairo</em> file, then write
some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p><code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter
5</span></p>
<p>The <code>can_hold</code> method returns a <code>bool</code>, which means it’s a perfect use case for
the <code>assert!</code> macro. We can write a test that exercises the <code>can_hold</code> method by
creating a <code>Rectangle</code> instance that has a width of <code>8</code> and a height of <code>7</code> and
asserting that it can hold another <code>Rectangle</code> instance that has a width of <code>5</code>
and a height of <code>1</code>.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
    }
}
<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a
regular module that follows the usual visibility rules we covered in Chapter
7 in the <a href="./ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for
Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use a
glob here, so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(@smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u64,
</span><span class="boring">    height: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RectangleImpl of RectangleTrait {
</span><span class="boring">    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
</span><span class="boring">        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle { height: 7, width: 8 };
</span><span class="boring">        let smaller = Rectangle { height: 1, width: 5 };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests2 {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
    }
<span class="boring">}
</span></code></pre>
<p>Adding another test in <em>lib.cairo</em> that will pass</span></p>
<p>Because the correct result of the <code>can_hold</code> method, in this case, is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code>
method by replacing the <code>&gt;</code> sign with a <code>&lt;</code> sign when it compares the widths:</p>
<pre><code class="language-cairo  noplayground">impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_01_wrong_can_hold_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_01_wrong_can_hold_impl_unittest) no_listing_01_wrong_can_hold_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_01_wrong_can_hold_impl package
Running 2 test(s) from src/
[FAIL] no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

Failure data:
    "rectangle cannot hold"

[PASS] no_listing_01_wrong_can_hold_impl::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is
<code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code> (<code>8</code> is not
less than <code>5</code>) in the <code>larger_can_hold_smaller</code> test. Notice that the
<code>smaller_cannot_hold_larger</code> test still passes: to make this test fail, the
height comparison should also be modified in <code>can_hold</code> method, replacing the
<code>&gt;</code> sign with a <code>&lt;</code> sign.</p>
<h2 id="testing-equality-and-comparisons-with-the-assert_xx-macros"><a class="header" href="#testing-equality-and-comparisons-with-the-assert_xx-macros">Testing Equality and Comparisons with the <code>assert_xx!</code> Macros</a></h2>
<h3 id="assert_eq-and-assert_ne-macros"><a class="header" href="#assert_eq-and-assert_ne-macros"><code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could do
this using the <code>assert!</code> macro and passing it an expression using the <code>==</code>
operator. However, this is such a common test that the standard library provides
a pair of macros — <code>assert_eq!</code> and <code>assert_ne!</code> — to perform this test more
conveniently. These macros compare two arguments for equality or inequality,
respectively. They’ll also print the two values if the assertion fails, which
makes it easier to see <em>why</em> the test failed; conversely, the <code>assert!</code> macro
only indicates that it got a <code>false</code> value for the <code>==</code> expression, without
printing the values that led to the <code>false</code> value.</p>
<p>In Listing 10-5, we write a function named <code>add_two</code> that adds <code>2</code>
to its parameter, then we test this function using <code>assert_eq!</code> and <code>assert_ne!</code>
macros.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn wrong_check() {
        assert_ne!(0, add_two(2));
    }
}
</code></pre>
<p>function <code>add_two</code> using <code>assert_eq!</code> and <code>assert_ne!</code> macros</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_unittest) listing_10_04 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_04 package
Running 2 test(s) from src/
[PASS] listing_10_04::tests::wrong_check (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_04::tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>In the <code>it_adds_two</code> test, we pass <code>4</code> as argument to <code>assert_eq!</code> macro, which
is equal to the result of calling <code>add_two(2)</code>. The line for this test is
<code>[PASS] adder::tests::it_adds_two (gas: ~1)</code>.</p>
<p>In the <code>wrong_check</code> test, we pass <code>0</code> as argument to <code>assert_ne!</code> macro, which
is not equal to the result of calling <code>add_two(2)</code>. Tests that use the
<code>assert_ne!</code> macro will pass if the two values we give it are <em>not</em> equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but how the input is changed depends on the day of the week that we
run our tests, the best thing to assert might be that the output of the function
is not equal to the input.</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-cairo  noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 3
}
</code></pre>
<p>Run the tests again:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04_wong_add (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_wong_add_unittest) listing_10_04_wong_add v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04_wong_add/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_04_wong_add package
Running 1 test(s) from src/
[FAIL] listing_10_04_wong_add::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed.
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    listing_10_04_wong_add::tests::it_adds_two

</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed with the following
message: <code>"assertion `4 == add_two(2)` failed</code>. It tells us that the assertion
that failed was <code> "assertion `left == right` failed</code> and the <code>left</code> and
<code>right</code> values are printed on the next lines as <code>left: left_value</code> and
<code>right: right_value</code>. This helps us start debugging: the <code>left</code> argument was <code>4</code>
but the <code>right</code> argument, where we had <code>add_two(2)</code>, was <code>5</code>. You can imagine
that this would be especially helpful when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters for equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Cairo, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value the
code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(add_two(2), 4)</code>, which would result in the same failure message that
displays <code>assertion failed: `(left == right)`</code>.</p>
<p>Here is a simple example comparing two structs, showing how to use <code>assert_eq!</code>
and <code>assert_ne!</code> macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Debug, PartialEq)]
struct MyStruct {
    var1: u8,
    var2: u8,
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first = MyStruct { var1: 1, var2: 2 };
    let second = MyStruct { var1: 1, var2: 2 };
    let third = MyStruct { var1: 1, var2: 3 };

    assert_eq!(first, second);
    assert_eq!(first, second, "{:?},{:?} should be equal", first, second);
    assert_ne!(first, third);
    assert_ne!(first, third, "{:?},{:?} should not be equal", first, third);
}
</code></pre>
<p>Under the surface, <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators <code>==</code>
and <code>!=</code>, respectively. They both take snapshots of values as arguments. When
the assertions fail, these macros print their arguments using debug formatting
(<code>{:?}</code> syntax), which means the values being compared must implement
<code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of the core library
types implement these traits. For structs and enums that you define yourself,
you’ll need to implement <code>PartialEq</code> to assert equality of those types. You’ll
also need to implement <code>Debug</code> to print the values when the assertion fails.
Because both traits are derivable, this is usually as straightforward as adding
the <code>#[derive(Drop, Debug, PartialEq)]</code> annotation to your struct or enum
definition. See <a href="./appendix-03-derivable-traits.html">Appendix C</a> for more details about these and
other derivable traits.</p>
<h3 id="assert_lt-assert_le-assert_gt-and-assert_ge-macros"><a class="header" href="#assert_lt-assert_le-assert_gt-and-assert_ge-macros"><code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> Macros</a></h3>
<p>Comparisons in tests can be done using the <code>assert_xx!</code> macros:</p>
<ul>
<li><code>assert_lt!</code> checks if a given value is lower than another value, and reverts
otherwise.</li>
<li><code>assert_le!</code> checks if a given value is lower or equal than another value, and
reverts otherwise.</li>
<li><code>assert_gt!</code> checks if a given value is greater than another value, and
reverts otherwise.</li>
<li><code>assert_ge!</code> checks if a given value is greater or equal than another value,
and reverts otherwise.</li>
</ul>
<p>Listing 10-6 demonstrates how to use these macros:</p>
<pre><code class="language-cairo  noplayground">#[derive(Drop, Copy, Debug, PartialEq)]
struct Dice {
    number: u8,
}

impl DicePartialOrd of PartialOrd&lt;Dice&gt; {
    fn lt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt; rhs.number
    }

    fn le(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt;= rhs.number
    }

    fn gt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt; rhs.number
    }

    fn ge(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt;= rhs.number
    }
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first_throw = Dice { number: 5 };
    let second_throw = Dice { number: 2 };
    let third_throw = Dice { number: 6 };
    let fourth_throw = Dice { number: 5 };

    assert_gt!(first_throw, second_throw);
    assert_ge!(first_throw, fourth_throw);
    assert_lt!(second_throw, third_throw);
    assert_le!(
        first_throw, fourth_throw, "{:?},{:?} should be lower or equal", first_throw, fourth_throw,
    );
}
</code></pre>
<p>Example of tests that use the <code>assert_xx!</code> macros for comparisons</span></p>
<p>In this example, we roll a <code>Dice</code> struct multiple times and compare the results.
We need to manually implement the <code>PartialOrd</code> trait for our struct so that we
can compare <code>Dice</code> instances with <code>lt</code>, <code>le</code>, <code>gt</code> and <code>ge</code> functions, which are
used by <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> and <code>assert_ge!</code> macros,
respectively. We also need to derive the <code>Copy</code> trait on our <code>Dice</code> struct to
use the instantiated structs multiple times, as the comparison functions take
ownership of the variables.</p>
<h2 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h2>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in the <a href="./ch12-08-printing.html#formatting">Printing</a> chapter), so you can
pass a format string that contains <code>{}</code> placeholders and values to go in those
placeholders. Custom messages are useful for documenting what an assertion
means; when a test fails, you’ll have a better idea of what the problem is with
the code.</p>
<p>Let’s add a custom failure message composed of a format string with a
placeholder filled in with the actual value we got from the previous <code>add_two</code>
function:</p>
<pre><code class="language-cairo  noplayground">    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2), "Expected {}, got add_two(2)={}", 4, add_two(2));
    }
</code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_02_custom_messages (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_02_custom_messages_unittest) no_listing_02_custom_messages v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_02_custom_messages package
Running 1 test(s) from src/
[FAIL] no_listing_02_custom_messages::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_02_custom_messages::tests::it_adds_two

</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h2 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for panics with <code>should_panic</code></a></h2>
<p>In addition to checking return values, it’s important to check that our code
handles error conditions as we expect. For example, consider the <code>Guess</code> type in
Listing 10-7:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[derive(Drop)]
struct Guess {
    value: u64,
}

pub trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
</code></pre>
<p>and its <code>new</code> method</span></p>
<p>Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances
will contain only values between <code>1</code> and <code>100</code>. We can write a test that ensures
that attempting to create a <code>Guess</code> instance with a value outside that range
panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test
passes if the code inside the function panics; the test fails if the code inside
the function doesn’t panic.</p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result to see that
this test passes:</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_09_08 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_09_08_unittest) listing_09_08 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_09_08 package
Running 1 test(s) from src/
[PASS] listing_09_08::tests::greater_than_100 (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that
the <code>new</code> function will panic if the value is greater than <code>100</code>:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">// TAG: tests_fail
</span><span class="boring">
</span><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        GuessTrait::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>When we run the test, it will fail:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_03_wrong_new_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_03_wrong_new_impl_unittest) no_listing_03_wrong_new_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_03_wrong_new_impl package
Running 1 test(s) from src/
[FAIL] no_listing_03_wrong_new_impl::tests::greater_than_100

Failure data:
    Expected to panic, but no panic occurred

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_03_wrong_new_impl::tests::greater_than_100

</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code> attribute. The
failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass
even if the test panics for a different reason from the one we were expecting.
To make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>#[should_panic]</code> attribute. The test harness will make sure
that the failure message contains the provided text. For example, consider the
modified code for <code>GuessImpl</code> in Listing 10-8 where the <code>new</code>
function panics with different messages depending on whether the value is too
small or too large:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground"><span class="boring">#[derive(Drop)]
</span><span class="boring">struct Guess {
</span><span class="boring">    value: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait GuessTrait {
</span><span class="boring">    fn new(value: u64) -&gt; Guess;
</span><span class="boring">}
</span><span class="boring">
</span>impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1");
        } else if value &gt; 100 {
            panic!("Guess must be &lt;= 100");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>implementation that panics with different error messages</span></p>
<p>The test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is the string that the <code>Guess::new</code> method panics with. We
need to specify the entire panic message that we expect.</p>
<p>To see what happens when a <code>should_panic</code> test with an expected message fails,
let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-cairo  noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &lt;= 100");
        } else if value &gt; 100 {
            panic!("Guess must be &gt;= 1");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_04_new_bug (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_04_new_bug_unittest) no_listing_04_new_bug v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_04_new_bug package
Running 1 test(s) from src/
[FAIL] no_listing_04_new_bug::tests::greater_than_100

Failure data:
    Incorrect panic data
    Actual:    [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203e3d2031, 0x12] (Guess must be &gt;= 1)
    Expected:  [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203c3d20313030, 0x14] (Guess must be &lt;= 100)

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_04_new_bug::tests::greater_than_100

</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string. The panic message
that we did get in this case was <code>Guess must be &gt;= 1</code>. Now we can start figuring
out where our bug is!</p>
<h2 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h2>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>scarb test</code> the name of
the test you want to run as an argument.</p>
<p>To demonstrate how to run a single test, we’ll first create two test functions,
as shown in Listing 10-9, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-cairo  noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert!(result == 5, "result is not 5");
    }
}
</code></pre>
<p>with two different names</span></p>
<p>We can pass the name of any test function to <code>scarb test</code> to run only that test:</p>
<pre><code class="language-shell">$ scarb test add_two_and_two
     Running test listing_10_07 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_07_unittest) listing_10_07 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_07 package
Running 1 test(s) from src/
[PASS] listing_10_07::tests::add_two_and_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 1 filtered out


</code></pre>
<p>Only the test with the name <code>add_two_and_two</code> ran; the other test didn’t match
that name. The test output lets us know we had one more test that didn’t run by
displaying <code>1 filtered out;</code> at the end.</p>
<p>We can also specify part of a test name, and any test whose name contains that
value will be run.</p>
<h2 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h2>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>scarb test</code>. Rather than listing
as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>#[ignore]</code> attribute to exclude them, as shown
here:</p>
<pre><code class="language-cairo  noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() { // code that takes an hour to run
    }
}
</code></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now
when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_05_ignore_tests (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_05_ignore_tests_unittest) no_listing_05_ignore_tests v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_05_ignore_tests package
Running 2 test(s) from src/
[IGNORE] no_listing_05_ignore_tests::tests::expensive_test
[PASS] no_listing_05_ignore_tests::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 1 ignored, 0 filtered out


</code></pre>
<p>The <code>expensive_test</code> function is listed as ignored.</p>
<p>When you’re at a point where it makes sense to check the results of the ignored
tests and you have time to wait for the results, you can run
<code>scarb test --include-ignored</code> to run all tests, whether they’re ignored or not.</p>
<h2 id="testing-recursive-functions-or-loops"><a class="header" href="#testing-recursive-functions-or-loops">Testing Recursive Functions or Loops</a></h2>
<p>When testing recursive functions or loops, the test is instantiated by default
with a maximum amount of gas that it can consume. This prevents running infinite
loops or consuming too much gas, and can help you benchmark the efficiency of
your implementations. This value is assumed reasonably large enough, but you can
override it by adding the <code>#[available_gas(&lt;Number&gt;)]</code> attribute to the test
function. The following example shows how to use it:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<h2 id="benchmarking-cairo-programs"><a class="header" href="#benchmarking-cairo-programs">Benchmarking Cairo Programs</a></h2>
<p>Starknet Foundry contains a profiling feature that is useful to analyze and
optimize the performance of your Cairo programs.</p>
<p>The <a href="https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/profiling.html">profiling</a> feature generates execution traces for successful
tests, which are used to create profile outputs. This allows you to benchmark
specific parts of your code.</p>
<p>To use the profiler, you will need to:</p>
<ol>
<li>Install <a href="https://github.com/software-mansion/cairo-profiler">Cairo Profiler</a> from Software Mansion.</li>
<li>Install <a href="https://go.dev/doc/install">Go</a>, <a href="https://www.graphviz.org/download/">Graphviz</a> and <a href="https://github.com/google/pprof?tab=readme-ov-file#building-pprof">pprof</a>, all of them are
required to visualize the generated profile output.</li>
<li>Run <code>snforge test --build-profile</code> command, which generates a trace file for
each passing test, stored in the <em>snfoundry_trace</em> directory of your project.
This command also generates the corresponding output files in the <em>profile</em>
directory.</li>
<li>Run <code>go tool pprof -http=":8000" path/to/profile/output.pb.gz</code> to analyse a
profile. This will start a web server at the specified port.</li>
</ol>
<p>Let's reuse the <code>sum_n</code> function studied above:</p>
<pre><code class="language-cairo  noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<p>After generating the trace file and the profile output, running <code>go tool pprof</code>
in your project will start the web server where you can find many useful
information about the test that you ran:</p>
<ul>
<li>
<p>The test includes one function call, corresponding to the call to the test
function. Calling <code>sum_n</code> multiple times in the test function will still
return 1 call. This is because <code>snforge</code> simulates a contract call when
executing a test.</p>
</li>
<li>
<p>The <code>sum_n</code> function execution uses 256 Cairo steps:</p>
</li>
</ul>
<div align="center">
    <img src="pprof-steps.png" alt="pprof number of steps" width="800px"/>
</div>
<p>Other information is also available such as memory holes (i.e., unused memory
cells) or builtins usage. The Cairo Profiler is under active development, and
many other features will be made available in the future.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;ch10-01-how_to_write_tests&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;This informs scarb to treat the function as a test and not source code.\n&quot;,&quot;id&quot;:&quot;c7365cd4-c0cf-4d92-8e42-c47ab8936775&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;#[test]&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;What is the annotation you add to a function to indicate that it's a test?&quot;}},{&quot;context&quot;:&quot;`should_err` does not exist in Cairo &amp;mdash; tests that return `Result` will pass even if the result is an `Err`.\n&quot;,&quot;id&quot;:&quot;cd77485f-723a-4978-8da6-c4ca3df44c44&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```\n#[test]\n#[should_err]\nfn test() -&gt; Result&lt;usize, String&gt; {\n    f(0)\n}\n```\n  &quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```\n#[test]\nfn test() {\n    assert!(f(0).is_err());\n}\n```\n&quot;,&quot;```\n#[test]\n#[should_panic]\nfn test() {\n    f(0).unwrap();\n}\n```\n  &quot;,&quot;```\n#[test]\nfn test() {\n    assert!(match f(0) {\n        Ok(_) =&gt; false,\n        Err(_) =&gt; true\n    });\n}\n```\n  &quot;],&quot;prompt&quot;:&quot;Let's say you have a function with the type signature:\n\n```\nfn f(x: usize) -&gt; Result&lt;usize, ByteArray&gt;;\n```\n\nAnd you want to test that `f(0)` should return `Err(_)`.\nWhich of the following is **NOT** a valid way to test that?\n&quot;}},{&quot;context&quot;:&quot;The expected string `\&quot;Zerodivisionerror not allowed!\&quot;` should be exactly\nthe same as the panic string `\&quot;ZeroDivisionError not allowed!\&quot;`\n&quot;,&quot;id&quot;:&quot;4becac9f-5173-4439-bd1f-e1e9958423ab&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;No&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Yes&quot;],&quot;prompt&quot;:&quot;Does the test pass?\n```\nfn division_operation(number1: u16, number2: u16) -&gt; u16 {\n    if number2 == 0 {\n        panic!(\&quot;ZeroDivisionError not allowed!\&quot;);\n    }\n    let result = number1 / number2;\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{division_operation};\n\n    #[test]\n    #[should_panic(expected: (\&quot;Zerodivisionerror not allowed!\&quot;,))]\n    fn test_division_operation() {\n        division_operation(10, 0);\n    }\n}\n```\n&quot;}},{&quot;context&quot;:&quot;One ignored: `test_addition`, because it has the `ignore` attribute\n\nOne filtered out: `division_with_available_gas`, because its name doesn't match the filter `test_`\n\nZero failed\n\nTwo passed: `test_multiplication` and `test_subtraction`, because all the conditions in the assertions are true\n&quot;,&quot;id&quot;:&quot;0b3385b4-069f-4883-ab3f-6feb8ebf72f8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;test result: ok. 2 passed; 0 failed; 1 ignored; 1 filtered out;&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Error: test result: FAILED. 1 passed; 1 failed; 1 ignored;&quot;,&quot;test result: ok. 1 passed; 0 failed; 1 ignored; 2 filtered out;&quot;,&quot;test result: ok. 2 passed; 0 failed; 2 ignored; 0 filtered out;&quot;],&quot;prompt&quot;:&quot;What is the output when these tests are run with the command `scarb cairo-test -f test_`\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    #[ignore]\n    fn test_addition() {\n        assert_ne!((5 + 4), 5);\n    }\n\n    #[test]\n    fn division_function() {\n        assert_eq!((10_u8 / 5), 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_ne!((3 * 2), 8);\n        assert_eq!((5 * 5), 25);\n    }\n    \n    #[test]\n    fn test_subtraction() {\n        assert!((12 - 11) == 1, \&quot;The first argument was false\&quot;);\n    }\n}\n```\n&quot;}}]}"></div>
<script type="text/javascript" src="quiz-cairo/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz-cairo/style.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch10-00-testing-cairo-programs.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch10-02-test-organization.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch10-00-testing-cairo-programs.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch10-02-test-organization.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
