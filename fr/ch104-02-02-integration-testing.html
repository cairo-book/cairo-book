<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Integration Testing - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch104-02-02-integration-testing.md";
            var canonicalPath;

            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }

            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;

            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }

            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2'); // lfg
            gtag('config', 'G-WY42TERK5P') // starknet
            gtag('config', 'G-1CHRL0BVJC'); // pers
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch104-02-01-unit-testing.html"><strong aria-hidden="true">18.2.1.</strong> Unit Testing</a></li><li class="chapter-item "><a href="ch104-02-02-integration-testing.html"><strong aria-hidden="true">18.2.2.</strong> Integration Testing</a></li><li class="chapter-item "><a href="ch104-02-03-fuzz-testing.html"><strong aria-hidden="true">18.2.3.</strong> Property-Based Testing</a></li><li class="chapter-item "><a href="ch104-02-04-fork-testing.html"><strong aria-hidden="true">18.2.4.</strong> Fork Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("fr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch104-02-02-integration-testing.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-02-02-integration-testing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h1>
<p>An <em>integration test</em> in smart contract development tests <strong>multiple contracts</strong>
interacting together. This is the industry-standard definition: if you're
testing cross-contract calls, composition, or how your contract works with
another contract, it's an integration test.</p>
<p>Integration tests answer one question: do my contracts work together correctly?</p>
<h2 id="unit-tests-vs-integration-tests"><a class="header" href="#unit-tests-vs-integration-tests">Unit Tests vs Integration Tests</a></h2>
<p>The distinction is about scope, not mechanism:</p>
<div class="table-wrapper"><table><thead><tr><th>Test Type</th><th>Scope</th><th>Example</th></tr></thead><tbody>
<tr><td>Unit test</td><td>Single contract</td><td>Testing your token's <code>transfer</code> function</td></tr>
<tr><td>Integration</td><td>Multiple contracts</td><td>Testing your token with a DEX router</td></tr>
</tbody></table>
</div>
<p>Both types deploy contracts and use cheatcodes. The difference is whether you're
testing one contract or multiple contracts interacting.</p>
<h2 id="when-to-use-integration-testing"><a class="header" href="#when-to-use-integration-testing">When to Use Integration Testing</a></h2>
<p>Integration tests make sense when you need to verify cross-contract calls work
correctly, test contract composition (e.g., your protocol using OpenZeppelin
contracts), validate callback patterns, or test complex multi-step flows
involving multiple contracts.</p>
<p>If you're testing a single contract's behavior, use
<a href="./ch104-02-01-unit-testing.html">unit testing</a> instead.</p>
<h2 id="test-organization-in-starknet-foundry"><a class="header" href="#test-organization-in-starknet-foundry">Test Organization in Starknet Foundry</a></h2>
<p>Starknet Foundry distinguishes tests by location:</p>
<pre><code class="language-text">my_project/
├── src/
│   └── lib.cairo           # Your contracts
│   └── tests/              # Unit tests (#[cfg(test)] modules)
└── tests/
    └── integration.cairo   # Integration tests (separate crate)
</code></pre>
<p><strong>Unit tests</strong> live in <code>src/</code> within <code>#[cfg(test)]</code> modules. They have access to
private items in your crate.</p>
<p><strong>Integration tests</strong> live in a separate <code>tests/</code> directory. They're compiled as
a separate crate and can only access your contracts' public interfaces, just
like external users.</p>
<p>This mirrors the Rust testing convention and enforces that integration tests use
contracts through their public APIs.</p>
<h2 id="integration-test-structure"><a class="header" href="#integration-test-structure">Integration Test Structure</a></h2>
<p>A typical integration test deploys multiple contracts and tests their
interactions. Here's a setup function that deploys a Token and a Staking
contract:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use listing_04_integration_testing::staking::{IStakingDispatcher, IStakingDispatcherTrait};
</span><span class="boring">use listing_04_integration_testing::token::{ITokenDispatcher, ITokenDispatcherTrait};
</span><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    'owner'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn user() -&gt; ContractAddress {
</span><span class="boring">    'user'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn mint_tokens(token: ITokenDispatcher, to: ContractAddress, amount: u256) {
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.mint(to, amount);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">}
</span><span class="boring">
</span>fn deploy_token_and_staking() -&gt; (ITokenDispatcher, IStakingDispatcher) {
    // Deploy the token contract with an owner for access control
    let token_class = declare("Token").unwrap().contract_class();
    let (token_address, _) = token_class.deploy(@array![owner().into()]).unwrap();
    let token = ITokenDispatcher { contract_address: token_address };

    // Deploy the staking contract with the token address
    let staking_class = declare("Staking").unwrap().contract_class();
    let (staking_address, _) = staking_class.deploy(@array![token_address.into()]).unwrap();
    let staking = IStakingDispatcher { contract_address: staking_address };

    (token, staking)
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_staking_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens to user (only owner can mint)
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // User approves staking contract to spend tokens
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User stakes tokens
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify both contracts updated correctly
</span><span class="boring">    assert_eq!(token.balance_of(user), 500);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 500);
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_multiple_stakers() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user1: ContractAddress = 'user1'.try_into().unwrap();
</span><span class="boring">    let user2: ContractAddress = 'user2'.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">    // Setup: mint and approve for both users
</span><span class="boring">    mint_tokens(token, user1, 1000);
</span><span class="boring">    mint_tokens(token, user2, 500);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user1);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user2);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User1 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user1);
</span><span class="boring">    staking.stake(600);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // User2 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user2);
</span><span class="boring">    staking.stake(300);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify individual stakes and total
</span><span class="boring">    assert_eq!(staking.staked_amount(user1), 600);
</span><span class="boring">    assert_eq!(staking.staked_amount(user2), 300);
</span><span class="boring">    assert_eq!(staking.total_staked(), 900);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Insufficient allowance")]
</span><span class="boring">fn test_stake_fails_without_approval() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens but don't approve
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Try to stake without approval - should fail
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_withdraw_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup: mint, approve, and stake
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">
</span><span class="boring">    // Withdraw half
</span><span class="boring">    staking.withdraw(250);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify balances across both contracts
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 250);
</span><span class="boring">    assert_eq!(staking.total_staked(), 250);
</span><span class="boring">    assert_eq!(token.balance_of(user), 750); // 500 remaining + 250 withdrawn
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 250); // only 250 still staked
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// When one action affects multiple contracts, verify ALL affected state.
</span><span class="boring">/// This test demonstrates checking state changes across contracts after a
</span><span class="boring">/// single operation.
</span><span class="boring">#[test]
</span><span class="boring">fn test_stake_updates_both_contracts() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Capture state BEFORE the cross-contract operation
</span><span class="boring">    let user_balance_before = token.balance_of(user);
</span><span class="boring">    let staking_balance_before = token.balance_of(staking.contract_address);
</span><span class="boring">    let staked_before = staking.staked_amount(user);
</span><span class="boring">    let total_staked_before = staking.total_staked();
</span><span class="boring">
</span><span class="boring">    // Single action that affects multiple contracts
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(400);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify BOTH contracts updated correctly
</span><span class="boring">    // Token contract state changed:
</span><span class="boring">    assert_eq!(token.balance_of(user), user_balance_before - 400);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), staking_balance_before + 400);
</span><span class="boring">    // Staking contract state changed:
</span><span class="boring">    assert_eq!(staking.staked_amount(user), staked_before + 400);
</span><span class="boring">    assert_eq!(staking.total_staked(), total_staked_before + 400);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// IMPORTANT: Why we use stop_cheat_caller_address in integration tests
</span><span class="boring">///
</span><span class="boring">/// In integration tests, one contract calls another. If you don't stop the
</span><span class="boring">/// cheatcode, it affects ALL calls to that contract - including internal
</span><span class="boring">/// cross-contract calls.
</span><span class="boring">///
</span><span class="boring">/// Example of what goes wrong without cleanup:
</span><span class="boring">/// 1. start_cheat_caller_address(token, user) - token sees caller as "user"
</span><span class="boring">/// 2. staking.stake(100) - staking calls token.transfer_from()
</span><span class="boring">/// 3. Inside transfer_from, get_caller_address() returns "user" (wrong!)
</span><span class="boring">///    It should return "staking contract" since staking is calling token
</span><span class="boring">///
</span><span class="boring">/// The pattern: always stop the cheatcode before cross-contract calls.
</span><span class="boring">#[test]
</span><span class="boring">fn test_cheatcode_cleanup_pattern() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Step 1: User approves staking contract
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    // CRITICAL: Stop cheating before the cross-contract call
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Step 2: User calls staking, which internally calls token
</span><span class="boring">    // Now when staking calls token.transfer_from(), the caller is correctly
</span><span class="boring">    // seen as the staking contract (not user)
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The pattern: deploy multiple contracts, wire them together, then test that
operations spanning contracts work correctly.</p>
<h2 id="common-integration-test-scenarios"><a class="header" href="#common-integration-test-scenarios">Common Integration Test Scenarios</a></h2>
<h3 id="testing-token--protocol-interactions"><a class="header" href="#testing-token--protocol-interactions">Testing Token + Protocol Interactions</a></h3>
<p>Most DeFi protocols interact with tokens. Test the full flow:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use listing_04_integration_testing::staking::{IStakingDispatcher, IStakingDispatcherTrait};
</span><span class="boring">use listing_04_integration_testing::token::{ITokenDispatcher, ITokenDispatcherTrait};
</span><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    'owner'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn user() -&gt; ContractAddress {
</span><span class="boring">    'user'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn mint_tokens(token: ITokenDispatcher, to: ContractAddress, amount: u256) {
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.mint(to, amount);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token_and_staking() -&gt; (ITokenDispatcher, IStakingDispatcher) {
</span><span class="boring">    // Deploy the token contract with an owner for access control
</span><span class="boring">    let token_class = declare("Token").unwrap().contract_class();
</span><span class="boring">    let (token_address, _) = token_class.deploy(@array![owner().into()]).unwrap();
</span><span class="boring">    let token = ITokenDispatcher { contract_address: token_address };
</span><span class="boring">
</span><span class="boring">    // Deploy the staking contract with the token address
</span><span class="boring">    let staking_class = declare("Staking").unwrap().contract_class();
</span><span class="boring">    let (staking_address, _) = staking_class.deploy(@array![token_address.into()]).unwrap();
</span><span class="boring">    let staking = IStakingDispatcher { contract_address: staking_address };
</span><span class="boring">
</span><span class="boring">    (token, staking)
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn test_staking_flow() {
    let (token, staking) = deploy_token_and_staking();
    let user = user();

    // Mint tokens to user (only owner can mint)
    mint_tokens(token, user, 1000);

    // User approves staking contract to spend tokens
    start_cheat_caller_address(token.contract_address, user);
    token.approve(staking.contract_address, 500);
    stop_cheat_caller_address(token.contract_address);

    // User stakes tokens
    start_cheat_caller_address(staking.contract_address, user);
    staking.stake(500);
    stop_cheat_caller_address(staking.contract_address);

    // Verify both contracts updated correctly
    assert_eq!(token.balance_of(user), 500);
    assert_eq!(token.balance_of(staking.contract_address), 500);
    assert_eq!(staking.staked_amount(user), 500);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_multiple_stakers() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user1: ContractAddress = 'user1'.try_into().unwrap();
</span><span class="boring">    let user2: ContractAddress = 'user2'.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">    // Setup: mint and approve for both users
</span><span class="boring">    mint_tokens(token, user1, 1000);
</span><span class="boring">    mint_tokens(token, user2, 500);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user1);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user2);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User1 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user1);
</span><span class="boring">    staking.stake(600);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // User2 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user2);
</span><span class="boring">    staking.stake(300);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify individual stakes and total
</span><span class="boring">    assert_eq!(staking.staked_amount(user1), 600);
</span><span class="boring">    assert_eq!(staking.staked_amount(user2), 300);
</span><span class="boring">    assert_eq!(staking.total_staked(), 900);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Insufficient allowance")]
</span><span class="boring">fn test_stake_fails_without_approval() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens but don't approve
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Try to stake without approval - should fail
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_withdraw_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup: mint, approve, and stake
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">
</span><span class="boring">    // Withdraw half
</span><span class="boring">    staking.withdraw(250);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify balances across both contracts
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 250);
</span><span class="boring">    assert_eq!(staking.total_staked(), 250);
</span><span class="boring">    assert_eq!(token.balance_of(user), 750); // 500 remaining + 250 withdrawn
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 250); // only 250 still staked
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// When one action affects multiple contracts, verify ALL affected state.
</span><span class="boring">/// This test demonstrates checking state changes across contracts after a
</span><span class="boring">/// single operation.
</span><span class="boring">#[test]
</span><span class="boring">fn test_stake_updates_both_contracts() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Capture state BEFORE the cross-contract operation
</span><span class="boring">    let user_balance_before = token.balance_of(user);
</span><span class="boring">    let staking_balance_before = token.balance_of(staking.contract_address);
</span><span class="boring">    let staked_before = staking.staked_amount(user);
</span><span class="boring">    let total_staked_before = staking.total_staked();
</span><span class="boring">
</span><span class="boring">    // Single action that affects multiple contracts
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(400);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify BOTH contracts updated correctly
</span><span class="boring">    // Token contract state changed:
</span><span class="boring">    assert_eq!(token.balance_of(user), user_balance_before - 400);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), staking_balance_before + 400);
</span><span class="boring">    // Staking contract state changed:
</span><span class="boring">    assert_eq!(staking.staked_amount(user), staked_before + 400);
</span><span class="boring">    assert_eq!(staking.total_staked(), total_staked_before + 400);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// IMPORTANT: Why we use stop_cheat_caller_address in integration tests
</span><span class="boring">///
</span><span class="boring">/// In integration tests, one contract calls another. If you don't stop the
</span><span class="boring">/// cheatcode, it affects ALL calls to that contract - including internal
</span><span class="boring">/// cross-contract calls.
</span><span class="boring">///
</span><span class="boring">/// Example of what goes wrong without cleanup:
</span><span class="boring">/// 1. start_cheat_caller_address(token, user) - token sees caller as "user"
</span><span class="boring">/// 2. staking.stake(100) - staking calls token.transfer_from()
</span><span class="boring">/// 3. Inside transfer_from, get_caller_address() returns "user" (wrong!)
</span><span class="boring">///    It should return "staking contract" since staking is calling token
</span><span class="boring">///
</span><span class="boring">/// The pattern: always stop the cheatcode before cross-contract calls.
</span><span class="boring">#[test]
</span><span class="boring">fn test_cheatcode_cleanup_pattern() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Step 1: User approves staking contract
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    // CRITICAL: Stop cheating before the cross-contract call
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Step 2: User calls staking, which internally calls token
</span><span class="boring">    // Now when staking calls token.transfer_from(), the caller is correctly
</span><span class="boring">    // seen as the staking contract (not user)
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h3 id="testing-multi-contract-state-changes"><a class="header" href="#testing-multi-contract-state-changes">Testing Multi-Contract State Changes</a></h3>
<p>When one action affects multiple contracts, capture state before and after to
verify all contracts updated correctly:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use listing_04_integration_testing::staking::{IStakingDispatcher, IStakingDispatcherTrait};
</span><span class="boring">use listing_04_integration_testing::token::{ITokenDispatcher, ITokenDispatcherTrait};
</span><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    'owner'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn user() -&gt; ContractAddress {
</span><span class="boring">    'user'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn mint_tokens(token: ITokenDispatcher, to: ContractAddress, amount: u256) {
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.mint(to, amount);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token_and_staking() -&gt; (ITokenDispatcher, IStakingDispatcher) {
</span><span class="boring">    // Deploy the token contract with an owner for access control
</span><span class="boring">    let token_class = declare("Token").unwrap().contract_class();
</span><span class="boring">    let (token_address, _) = token_class.deploy(@array![owner().into()]).unwrap();
</span><span class="boring">    let token = ITokenDispatcher { contract_address: token_address };
</span><span class="boring">
</span><span class="boring">    // Deploy the staking contract with the token address
</span><span class="boring">    let staking_class = declare("Staking").unwrap().contract_class();
</span><span class="boring">    let (staking_address, _) = staking_class.deploy(@array![token_address.into()]).unwrap();
</span><span class="boring">    let staking = IStakingDispatcher { contract_address: staking_address };
</span><span class="boring">
</span><span class="boring">    (token, staking)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_staking_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens to user (only owner can mint)
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // User approves staking contract to spend tokens
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User stakes tokens
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify both contracts updated correctly
</span><span class="boring">    assert_eq!(token.balance_of(user), 500);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 500);
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_multiple_stakers() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user1: ContractAddress = 'user1'.try_into().unwrap();
</span><span class="boring">    let user2: ContractAddress = 'user2'.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">    // Setup: mint and approve for both users
</span><span class="boring">    mint_tokens(token, user1, 1000);
</span><span class="boring">    mint_tokens(token, user2, 500);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user1);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user2);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User1 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user1);
</span><span class="boring">    staking.stake(600);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // User2 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user2);
</span><span class="boring">    staking.stake(300);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify individual stakes and total
</span><span class="boring">    assert_eq!(staking.staked_amount(user1), 600);
</span><span class="boring">    assert_eq!(staking.staked_amount(user2), 300);
</span><span class="boring">    assert_eq!(staking.total_staked(), 900);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Insufficient allowance")]
</span><span class="boring">fn test_stake_fails_without_approval() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens but don't approve
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Try to stake without approval - should fail
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_withdraw_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup: mint, approve, and stake
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">
</span><span class="boring">    // Withdraw half
</span><span class="boring">    staking.withdraw(250);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify balances across both contracts
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 250);
</span><span class="boring">    assert_eq!(staking.total_staked(), 250);
</span><span class="boring">    assert_eq!(token.balance_of(user), 750); // 500 remaining + 250 withdrawn
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 250); // only 250 still staked
</span><span class="boring">}
</span><span class="boring">
</span>/// When one action affects multiple contracts, verify ALL affected state.
/// This test demonstrates checking state changes across contracts after a
/// single operation.
#[test]
fn test_stake_updates_both_contracts() {
    let (token, staking) = deploy_token_and_staking();
    let user = user();

    // Setup
    mint_tokens(token, user, 1000);
    start_cheat_caller_address(token.contract_address, user);
    token.approve(staking.contract_address, 1000);
    stop_cheat_caller_address(token.contract_address);

    // Capture state BEFORE the cross-contract operation
    let user_balance_before = token.balance_of(user);
    let staking_balance_before = token.balance_of(staking.contract_address);
    let staked_before = staking.staked_amount(user);
    let total_staked_before = staking.total_staked();

    // Single action that affects multiple contracts
    start_cheat_caller_address(staking.contract_address, user);
    staking.stake(400);
    stop_cheat_caller_address(staking.contract_address);

    // Verify BOTH contracts updated correctly
    // Token contract state changed:
    assert_eq!(token.balance_of(user), user_balance_before - 400);
    assert_eq!(token.balance_of(staking.contract_address), staking_balance_before + 400);
    // Staking contract state changed:
    assert_eq!(staking.staked_amount(user), staked_before + 400);
    assert_eq!(staking.total_staked(), total_staked_before + 400);
}
<span class="boring">
</span><span class="boring">/// IMPORTANT: Why we use stop_cheat_caller_address in integration tests
</span><span class="boring">///
</span><span class="boring">/// In integration tests, one contract calls another. If you don't stop the
</span><span class="boring">/// cheatcode, it affects ALL calls to that contract - including internal
</span><span class="boring">/// cross-contract calls.
</span><span class="boring">///
</span><span class="boring">/// Example of what goes wrong without cleanup:
</span><span class="boring">/// 1. start_cheat_caller_address(token, user) - token sees caller as "user"
</span><span class="boring">/// 2. staking.stake(100) - staking calls token.transfer_from()
</span><span class="boring">/// 3. Inside transfer_from, get_caller_address() returns "user" (wrong!)
</span><span class="boring">///    It should return "staking contract" since staking is calling token
</span><span class="boring">///
</span><span class="boring">/// The pattern: always stop the cheatcode before cross-contract calls.
</span><span class="boring">#[test]
</span><span class="boring">fn test_cheatcode_cleanup_pattern() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Step 1: User approves staking contract
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    // CRITICAL: Stop cheating before the cross-contract call
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Step 2: User calls staking, which internally calls token
</span><span class="boring">    // Now when staking calls token.transfer_from(), the caller is correctly
</span><span class="boring">    // seen as the staking contract (not user)
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h3 id="cheatcode-cleanup-in-cross-contract-calls"><a class="header" href="#cheatcode-cleanup-in-cross-contract-calls">Cheatcode Cleanup in Cross-Contract Calls</a></h3>
<p>Integration tests require careful cheatcode management. When contract A calls
contract B, you must stop cheating contract B's caller before the cross-contract
call happens:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use listing_04_integration_testing::staking::{IStakingDispatcher, IStakingDispatcherTrait};
</span><span class="boring">use listing_04_integration_testing::token::{ITokenDispatcher, ITokenDispatcherTrait};
</span><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    'owner'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn user() -&gt; ContractAddress {
</span><span class="boring">    'user'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn mint_tokens(token: ITokenDispatcher, to: ContractAddress, amount: u256) {
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.mint(to, amount);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token_and_staking() -&gt; (ITokenDispatcher, IStakingDispatcher) {
</span><span class="boring">    // Deploy the token contract with an owner for access control
</span><span class="boring">    let token_class = declare("Token").unwrap().contract_class();
</span><span class="boring">    let (token_address, _) = token_class.deploy(@array![owner().into()]).unwrap();
</span><span class="boring">    let token = ITokenDispatcher { contract_address: token_address };
</span><span class="boring">
</span><span class="boring">    // Deploy the staking contract with the token address
</span><span class="boring">    let staking_class = declare("Staking").unwrap().contract_class();
</span><span class="boring">    let (staking_address, _) = staking_class.deploy(@array![token_address.into()]).unwrap();
</span><span class="boring">    let staking = IStakingDispatcher { contract_address: staking_address };
</span><span class="boring">
</span><span class="boring">    (token, staking)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_staking_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens to user (only owner can mint)
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // User approves staking contract to spend tokens
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User stakes tokens
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify both contracts updated correctly
</span><span class="boring">    assert_eq!(token.balance_of(user), 500);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 500);
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_multiple_stakers() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user1: ContractAddress = 'user1'.try_into().unwrap();
</span><span class="boring">    let user2: ContractAddress = 'user2'.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">    // Setup: mint and approve for both users
</span><span class="boring">    mint_tokens(token, user1, 1000);
</span><span class="boring">    mint_tokens(token, user2, 500);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user1);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user2);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User1 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user1);
</span><span class="boring">    staking.stake(600);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // User2 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user2);
</span><span class="boring">    staking.stake(300);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify individual stakes and total
</span><span class="boring">    assert_eq!(staking.staked_amount(user1), 600);
</span><span class="boring">    assert_eq!(staking.staked_amount(user2), 300);
</span><span class="boring">    assert_eq!(staking.total_staked(), 900);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[should_panic(expected: "Insufficient allowance")]
</span><span class="boring">fn test_stake_fails_without_approval() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens but don't approve
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Try to stake without approval - should fail
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_withdraw_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup: mint, approve, and stake
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">
</span><span class="boring">    // Withdraw half
</span><span class="boring">    staking.withdraw(250);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify balances across both contracts
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 250);
</span><span class="boring">    assert_eq!(staking.total_staked(), 250);
</span><span class="boring">    assert_eq!(token.balance_of(user), 750); // 500 remaining + 250 withdrawn
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 250); // only 250 still staked
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// When one action affects multiple contracts, verify ALL affected state.
</span><span class="boring">/// This test demonstrates checking state changes across contracts after a
</span><span class="boring">/// single operation.
</span><span class="boring">#[test]
</span><span class="boring">fn test_stake_updates_both_contracts() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Capture state BEFORE the cross-contract operation
</span><span class="boring">    let user_balance_before = token.balance_of(user);
</span><span class="boring">    let staking_balance_before = token.balance_of(staking.contract_address);
</span><span class="boring">    let staked_before = staking.staked_amount(user);
</span><span class="boring">    let total_staked_before = staking.total_staked();
</span><span class="boring">
</span><span class="boring">    // Single action that affects multiple contracts
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(400);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify BOTH contracts updated correctly
</span><span class="boring">    // Token contract state changed:
</span><span class="boring">    assert_eq!(token.balance_of(user), user_balance_before - 400);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), staking_balance_before + 400);
</span><span class="boring">    // Staking contract state changed:
</span><span class="boring">    assert_eq!(staking.staked_amount(user), staked_before + 400);
</span><span class="boring">    assert_eq!(staking.total_staked(), total_staked_before + 400);
</span><span class="boring">}
</span><span class="boring">
</span>/// IMPORTANT: Why we use stop_cheat_caller_address in integration tests
///
/// In integration tests, one contract calls another. If you don't stop the
/// cheatcode, it affects ALL calls to that contract - including internal
/// cross-contract calls.
///
/// Example of what goes wrong without cleanup:
/// 1. start_cheat_caller_address(token, user) - token sees caller as "user"
/// 2. staking.stake(100) - staking calls token.transfer_from()
/// 3. Inside transfer_from, get_caller_address() returns "user" (wrong!)
///    It should return "staking contract" since staking is calling token
///
/// The pattern: always stop the cheatcode before cross-contract calls.
#[test]
fn test_cheatcode_cleanup_pattern() {
    let (token, staking) = deploy_token_and_staking();
    let user = user();

    mint_tokens(token, user, 1000);

    // Step 1: User approves staking contract
    start_cheat_caller_address(token.contract_address, user);
    token.approve(staking.contract_address, 500);
    // CRITICAL: Stop cheating before the cross-contract call
    stop_cheat_caller_address(token.contract_address);

    // Step 2: User calls staking, which internally calls token
    // Now when staking calls token.transfer_from(), the caller is correctly
    // seen as the staking contract (not user)
    start_cheat_caller_address(staking.contract_address, user);
    staking.stake(500);
    stop_cheat_caller_address(staking.contract_address);

    assert_eq!(staking.staked_amount(user), 500);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="use-setup-functions"><a class="header" href="#use-setup-functions">Use Setup Functions</a></h3>
<p>Don't repeat deployment code. Create setup functions that deploy your contract
constellation:</p>
<pre><code class="language-cairo noplayground">fn deploy_full_protocol() -&gt; (ITokenDispatcher, IDexDispatcher, IOracleDispatcher) {
    // Deploy and wire up all contracts
    // Return dispatchers for each
}
</code></pre>
<h3 id="test-realistic-flows"><a class="header" href="#test-realistic-flows">Test Realistic Flows</a></h3>
<p>Integration tests should mirror real user flows:</p>
<pre><code class="language-cairo noplayground">#[test]
fn test_complete_trading_flow() {
    // 1. User deposits collateral
    // 2. User opens position
    // 3. Price changes (mock oracle)
    // 4. User closes position
    // 5. User withdraws collateral
    // Each step may involve multiple contracts
}
</code></pre>
<h3 id="document-contract-dependencies"><a class="header" href="#document-contract-dependencies">Document Contract Dependencies</a></h3>
<p>Integration tests serve as documentation for how contracts interact:</p>
<pre><code class="language-cairo noplayground">#[test]
fn test_liquidation_flow() {
    // This test documents that liquidation requires:
    // - Oracle for price data
    // - Vault for collateral
    // - Token for debt repayment
    // - Liquidator contract for executing
}
</code></pre>
<h3 id="test-failure-modes"><a class="header" href="#test-failure-modes">Test Failure Modes</a></h3>
<p>Test what happens when cross-contract calls fail:</p>
<pre><code class="language-cairo noplayground"><span class="boring">use listing_04_integration_testing::staking::{IStakingDispatcher, IStakingDispatcherTrait};
</span><span class="boring">use listing_04_integration_testing::token::{ITokenDispatcher, ITokenDispatcherTrait};
</span><span class="boring">use snforge_std::{
</span><span class="boring">    ContractClassTrait, DeclareResultTrait, declare, start_cheat_caller_address,
</span><span class="boring">    stop_cheat_caller_address,
</span><span class="boring">};
</span><span class="boring">use starknet::ContractAddress;
</span><span class="boring">
</span><span class="boring">fn owner() -&gt; ContractAddress {
</span><span class="boring">    'owner'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn user() -&gt; ContractAddress {
</span><span class="boring">    'user'.try_into().unwrap()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn mint_tokens(token: ITokenDispatcher, to: ContractAddress, amount: u256) {
</span><span class="boring">    start_cheat_caller_address(token.contract_address, owner());
</span><span class="boring">    token.mint(to, amount);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn deploy_token_and_staking() -&gt; (ITokenDispatcher, IStakingDispatcher) {
</span><span class="boring">    // Deploy the token contract with an owner for access control
</span><span class="boring">    let token_class = declare("Token").unwrap().contract_class();
</span><span class="boring">    let (token_address, _) = token_class.deploy(@array![owner().into()]).unwrap();
</span><span class="boring">    let token = ITokenDispatcher { contract_address: token_address };
</span><span class="boring">
</span><span class="boring">    // Deploy the staking contract with the token address
</span><span class="boring">    let staking_class = declare("Staking").unwrap().contract_class();
</span><span class="boring">    let (staking_address, _) = staking_class.deploy(@array![token_address.into()]).unwrap();
</span><span class="boring">    let staking = IStakingDispatcher { contract_address: staking_address };
</span><span class="boring">
</span><span class="boring">    (token, staking)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_staking_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Mint tokens to user (only owner can mint)
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // User approves staking contract to spend tokens
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User stakes tokens
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify both contracts updated correctly
</span><span class="boring">    assert_eq!(token.balance_of(user), 500);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 500);
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_multiple_stakers() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user1: ContractAddress = 'user1'.try_into().unwrap();
</span><span class="boring">    let user2: ContractAddress = 'user2'.try_into().unwrap();
</span><span class="boring">
</span><span class="boring">    // Setup: mint and approve for both users
</span><span class="boring">    mint_tokens(token, user1, 1000);
</span><span class="boring">    mint_tokens(token, user2, 500);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user1);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user2);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // User1 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user1);
</span><span class="boring">    staking.stake(600);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // User2 stakes
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user2);
</span><span class="boring">    staking.stake(300);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify individual stakes and total
</span><span class="boring">    assert_eq!(staking.staked_amount(user1), 600);
</span><span class="boring">    assert_eq!(staking.staked_amount(user2), 300);
</span><span class="boring">    assert_eq!(staking.total_staked(), 900);
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
#[should_panic(expected: "Insufficient allowance")]
fn test_stake_fails_without_approval() {
    let (token, staking) = deploy_token_and_staking();
    let user = user();

    // Mint tokens but don't approve
    mint_tokens(token, user, 1000);

    // Try to stake without approval - should fail
    start_cheat_caller_address(staking.contract_address, user);
    staking.stake(500);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn test_withdraw_flow() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup: mint, approve, and stake
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">
</span><span class="boring">    // Withdraw half
</span><span class="boring">    staking.withdraw(250);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify balances across both contracts
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 250);
</span><span class="boring">    assert_eq!(staking.total_staked(), 250);
</span><span class="boring">    assert_eq!(token.balance_of(user), 750); // 500 remaining + 250 withdrawn
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), 250); // only 250 still staked
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// When one action affects multiple contracts, verify ALL affected state.
</span><span class="boring">/// This test demonstrates checking state changes across contracts after a
</span><span class="boring">/// single operation.
</span><span class="boring">#[test]
</span><span class="boring">fn test_stake_updates_both_contracts() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    // Setup
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 1000);
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Capture state BEFORE the cross-contract operation
</span><span class="boring">    let user_balance_before = token.balance_of(user);
</span><span class="boring">    let staking_balance_before = token.balance_of(staking.contract_address);
</span><span class="boring">    let staked_before = staking.staked_amount(user);
</span><span class="boring">    let total_staked_before = staking.total_staked();
</span><span class="boring">
</span><span class="boring">    // Single action that affects multiple contracts
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(400);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    // Verify BOTH contracts updated correctly
</span><span class="boring">    // Token contract state changed:
</span><span class="boring">    assert_eq!(token.balance_of(user), user_balance_before - 400);
</span><span class="boring">    assert_eq!(token.balance_of(staking.contract_address), staking_balance_before + 400);
</span><span class="boring">    // Staking contract state changed:
</span><span class="boring">    assert_eq!(staking.staked_amount(user), staked_before + 400);
</span><span class="boring">    assert_eq!(staking.total_staked(), total_staked_before + 400);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// IMPORTANT: Why we use stop_cheat_caller_address in integration tests
</span><span class="boring">///
</span><span class="boring">/// In integration tests, one contract calls another. If you don't stop the
</span><span class="boring">/// cheatcode, it affects ALL calls to that contract - including internal
</span><span class="boring">/// cross-contract calls.
</span><span class="boring">///
</span><span class="boring">/// Example of what goes wrong without cleanup:
</span><span class="boring">/// 1. start_cheat_caller_address(token, user) - token sees caller as "user"
</span><span class="boring">/// 2. staking.stake(100) - staking calls token.transfer_from()
</span><span class="boring">/// 3. Inside transfer_from, get_caller_address() returns "user" (wrong!)
</span><span class="boring">///    It should return "staking contract" since staking is calling token
</span><span class="boring">///
</span><span class="boring">/// The pattern: always stop the cheatcode before cross-contract calls.
</span><span class="boring">#[test]
</span><span class="boring">fn test_cheatcode_cleanup_pattern() {
</span><span class="boring">    let (token, staking) = deploy_token_and_staking();
</span><span class="boring">    let user = user();
</span><span class="boring">
</span><span class="boring">    mint_tokens(token, user, 1000);
</span><span class="boring">
</span><span class="boring">    // Step 1: User approves staking contract
</span><span class="boring">    start_cheat_caller_address(token.contract_address, user);
</span><span class="boring">    token.approve(staking.contract_address, 500);
</span><span class="boring">    // CRITICAL: Stop cheating before the cross-contract call
</span><span class="boring">    stop_cheat_caller_address(token.contract_address);
</span><span class="boring">
</span><span class="boring">    // Step 2: User calls staking, which internally calls token
</span><span class="boring">    // Now when staking calls token.transfer_from(), the caller is correctly
</span><span class="boring">    // seen as the staking contract (not user)
</span><span class="boring">    start_cheat_caller_address(staking.contract_address, user);
</span><span class="boring">    staking.stake(500);
</span><span class="boring">    stop_cheat_caller_address(staking.contract_address);
</span><span class="boring">
</span><span class="boring">    assert_eq!(staking.staked_amount(user), 500);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="when-integration-tests-arent-enough"><a class="header" href="#when-integration-tests-arent-enough">When Integration Tests Aren't Enough</a></h2>
<p>Integration tests verify your contracts work together, but they test against
contracts you deploy. Move to <a href="./ch104-02-04-fork-testing.html">fork testing</a> when
you need to test against real deployed protocols (DEXs, oracles) you don't
control, or test against actual mainnet state.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Integration testing means testing multiple contracts interacting:</p>
<ul>
<li>Deploy multiple contracts in your test setup</li>
<li>Test cross-contract calls and state changes</li>
<li>Use the <code>tests/</code> directory for integration tests (separate crate)</li>
<li>Test realistic multi-step flows</li>
</ul>
<p>If you're testing a single contract, it's a
<a href="./ch104-02-01-unit-testing.html">unit test</a>. If you're testing multiple contracts
together, it's an integration test.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch104-02-01-unit-testing.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch104-02-03-fuzz-testing.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch104-02-01-unit-testing.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch104-02-03-fuzz-testing.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>

        <!-- Cairo WASM compiler for in-browser code execution (runs in Web Worker) -->
        <script>
            (function () {
                var rootPath = "";
                var workerUrl = "./" + rootPath + "wasm/cairo_worker.js";
                var worker = new Worker(workerUrl, { type: "module" });
                var nextId = 0;
                var pending = {};

                worker.onmessage = function (e) {
                    if (e.data.type === "ready") {
                        window.cairoWasmReady = true;
                        console.log("Cairo WASM worker initialized");
                        return;
                    }
                    if (e.data.type === "result") {
                        var cb = pending[e.data.id];
                        if (cb) {
                            delete pending[e.data.id];
                            if (e.data.error) {
                                cb.reject(new Error(e.data.error));
                            } else {
                                cb.resolve(e.data.response);
                            }
                        }
                    }
                };

                window.cairoWasm = {
                    compile_and_run: function (requestJson) {
                        var id = nextId++;
                        return new Promise(function (resolve, reject) {
                            pending[id] = { resolve: resolve, reject: reject };
                            worker.postMessage({ type: "run", id: id, request: JSON.parse(requestJson) });
                        });
                    }
                };
            })();
        </script>

        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
