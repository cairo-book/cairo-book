<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Associated Items - The Cairo Programming Language</title>


    <!-- Custom HTML head -->

    <meta name="description" content="The Cairo Programming Language. A comprehensive documentation for Cairo, the smart contract language for Starknet.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/css/last-changed.css">
    <link rel="stylesheet" href="theme/css/chat.css">
    <link rel="stylesheet" href="theme/css/version-switcher.css">

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <link rel="canonical" id="canonical-link" href="" />
    <script>
        (function () {
            var path = "ch12-10-associated-items.md";
            var canonicalPath;
            
            // Special handling for different cases
            if (path === "" || path === "index.md") {
                // Homepage should not have index.html
                canonicalPath = "";
            } else {
                // Other pages: replace .md with .html
                canonicalPath = path.replace(/\.md$/, ".html");
            }
            
            var canonicalUrl = "https://www.starknet.io/cairo-book/" + canonicalPath;
            
            // Remove trailing slash if present (except for root)
            if (canonicalUrl.endsWith("/") && canonicalUrl !== "https://www.starknet.io/cairo-book/") {
                canonicalUrl = canonicalUrl.slice(0, -1);
            }
            
            document.getElementById("canonical-link").href = canonicalUrl;
        })();
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-M6M97KJP');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M6M97KJP" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0ZJLBV4KE2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'G-0ZJLBV4KE2');
            gtag('config', 'G-WY42TERK5P')
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Cairo Book</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">The Cairo Programming Language</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-proving-a-prime-number.html"><strong aria-hidden="true">1.3.</strong> Proving That A Number Is Prime</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-common-collections.html"><strong aria-hidden="true">3.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-arrays.html"><strong aria-hidden="true">3.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="ch03-02-dictionaries.html"><strong aria-hidden="true">3.2.</strong> Dictionaries</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-snapshots.html"><strong aria-hidden="true">4.2.</strong> References and Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-an-example-program-using-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums-and-pattern-matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-enums.html"><strong aria-hidden="true">6.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch06-02-the-match-control-flow-construct.html"><strong aria-hidden="true">6.2.</strong> The Match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-concise-control-flow-with-if-let-and-while-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let and while let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Cairo Projects with Packages, Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-generic-types-and-traits.html"><strong aria-hidden="true">8.</strong> Generic Types and Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-generic-data-types.html"><strong aria-hidden="true">8.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch08-02-traits-in-cairo.html"><strong aria-hidden="true">8.2.</strong> Traits in Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-testing-cairo-programs.html"><strong aria-hidden="true">10.</strong> Testing Cairo Programs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-how-to-write-tests.html"><strong aria-hidden="true">10.1.</strong> How To Write Tests</a></li><li class="chapter-item expanded "><a href="ch10-02-test-organization.html"><strong aria-hidden="true">10.2.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-functional-features.html"><strong aria-hidden="true">11.</strong> Functional Language Features: Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-closures.html"><strong aria-hidden="true">11.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-advanced-features.html"><strong aria-hidden="true">12.</strong> Advanced Cairo Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-custom-data-structures.html"><strong aria-hidden="true">12.1.</strong> Custom Data Structures</a></li><li class="chapter-item expanded "><a href="ch12-02-smart-pointers.html"><strong aria-hidden="true">12.2.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch12-09-deref-coercion.html"><strong aria-hidden="true">12.3.</strong> Deref Coercion</a></li><li class="chapter-item expanded "><a href="ch12-10-associated-items.html"><strong aria-hidden="true">12.4.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="ch12-03-operator-overloading.html"><strong aria-hidden="true">12.5.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="ch12-04-hash.html"><strong aria-hidden="true">12.6.</strong> Working with Hashes</a></li><li class="chapter-item expanded "><a href="ch12-05-macros.html"><strong aria-hidden="true">12.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch12-10-procedural-macros.html"><strong aria-hidden="true">12.8.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="ch12-06-inlining-in-cairo.html"><strong aria-hidden="true">12.9.</strong> Inlining in Cairo</a></li><li class="chapter-item expanded "><a href="ch12-08-printing.html"><strong aria-hidden="true">12.10.</strong> Printing</a></li><li class="chapter-item expanded "><a href="ch12-10-arithmetic-circuits.html"><strong aria-hidden="true">12.11.</strong> Arithmetic Circuits</a></li><li class="chapter-item expanded "><a href="ch12-11-offloading-computations-with-oracles.html"><strong aria-hidden="true">12.12.</strong> Offloading Computations with Oracles</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">13.</strong> Appendix (Cairo)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">13.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators-and-symbols.html"><strong aria-hidden="true">13.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">13.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-cairo-prelude.html"><strong aria-hidden="true">13.4.</strong> D - The Cairo Prelude</a></li><li class="chapter-item expanded "><a href="appendix-05-common-error-messages.html"><strong aria-hidden="true">13.5.</strong> E - Common Error Messages</a></li><li class="chapter-item expanded "><a href="appendix-06-useful-development-tools.html"><strong aria-hidden="true">13.6.</strong> F - Useful Development Tools</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Smart Contracts in Cairo</li><li class="chapter-item expanded "><a href="ch100-00-introduction-to-smart-contracts.html"><strong aria-hidden="true">14.</strong> Introduction to Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch100-01-contracts-classes-and-instances.html"><strong aria-hidden="true">14.1.</strong> Starknet contract classes and instances</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-00-building-starknet-smart-contracts.html"><strong aria-hidden="true">15.</strong> Building Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch101-01-starknet-types.html"><strong aria-hidden="true">15.1.</strong> Starknet Types</a></li><li class="chapter-item expanded "><a href="ch101-01-00-contract-storage.html"><strong aria-hidden="true">15.2.</strong> Contract Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch101-01-01-storage-mappings.html"><strong aria-hidden="true">15.2.1.</strong> Storage Mappings</a></li><li class="chapter-item "><a href="ch101-01-02-storage-vecs.html"><strong aria-hidden="true">15.2.2.</strong> Storage Vecs</a></li></ol></li><li class="chapter-item expanded "><a href="ch101-02-contract-functions.html"><strong aria-hidden="true">15.3.</strong> Contract Functions</a></li><li class="chapter-item expanded "><a href="ch101-03-contract-events.html"><strong aria-hidden="true">15.4.</strong> Contract Events</a></li></ol></li><li class="chapter-item expanded "><a href="ch102-00-starknet-contract-interactions.html"><strong aria-hidden="true">16.</strong> Starknet Contract Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch102-01-contract-class-abi.html"><strong aria-hidden="true">16.1.</strong> Contract Class ABI</a></li><li class="chapter-item expanded "><a href="ch102-02-interacting-with-another-contract.html"><strong aria-hidden="true">16.2.</strong> Interacting with Another Contract</a></li><li class="chapter-item expanded "><a href="ch102-03-executing-code-from-another-class.html"><strong aria-hidden="true">16.3.</strong> Executing Code from Another Class</a></li><li class="chapter-item expanded "><a href="ch102-04-serialization-of-cairo-types.html"><strong aria-hidden="true">16.4.</strong> Serialization of Cairo types</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-00-building-advanced-starknet-smart-contracts.html"><strong aria-hidden="true">17.</strong> Building Advanced Starknet Smart Contracts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch103-01-optimizing-storage-costs.html"><strong aria-hidden="true">17.1.</strong> Optimizing Storage Costs</a></li><li class="chapter-item expanded "><a href="ch103-02-00-composability-and-components.html"><strong aria-hidden="true">17.2.</strong> Composability and Components</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-02-01-under-the-hood.html"><strong aria-hidden="true">17.2.1.</strong> Under the Hood</a></li><li class="chapter-item "><a href="ch103-02-02-component-dependencies.html"><strong aria-hidden="true">17.2.2.</strong> Component Dependencies</a></li><li class="chapter-item "><a href="ch103-02-03-testing-components.html"><strong aria-hidden="true">17.2.3.</strong> Testing Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-03-upgradeability.html"><strong aria-hidden="true">17.3.</strong> Upgradeability</a></li><li class="chapter-item expanded "><a href="ch103-04-L1-L2-messaging.html"><strong aria-hidden="true">17.4.</strong> L1 &lt;&gt; L2 Messaging</a></li><li class="chapter-item expanded "><a href="ch103-05-oracle-interactions.html"><strong aria-hidden="true">17.5.</strong> Oracle Interactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-05-01-price-feeds.html"><strong aria-hidden="true">17.5.1.</strong> Price Feeds</a></li><li class="chapter-item "><a href="ch103-05-02-randomness.html"><strong aria-hidden="true">17.5.2.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><a href="ch103-06-00-other-examples.html"><strong aria-hidden="true">17.6.</strong> Other Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch103-06-01-deploying-and-interacting-with-a-voting-contract.html"><strong aria-hidden="true">17.6.1.</strong> Deploying and Interacting with a Voting Contract</a></li><li class="chapter-item "><a href="ch103-06-02-working-with-erc20-token.html"><strong aria-hidden="true">17.6.2.</strong> Working with ERC20 Token</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch104-00-starknet-smart-contracts-security.html"><strong aria-hidden="true">18.</strong> Starknet Smart Contracts Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch104-01-general-recommendations.html"><strong aria-hidden="true">18.1.</strong> General Recommendations</a></li><li class="chapter-item expanded "><a href="ch104-02-testing-smart-contracts.html"><strong aria-hidden="true">18.2.</strong> Testing Smart Contracts</a></li><li class="chapter-item expanded "><a href="ch104-03-static-analysis-tools.html"><strong aria-hidden="true">18.3.</strong> Static Analysis Tools</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-000.html"><strong aria-hidden="true">19.</strong> Appendix (Starknet)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-08-system-calls.html"><strong aria-hidden="true">19.1.</strong> A - System Calls</a></li><li class="chapter-item expanded "><a href="appendix-09-sierra.html"><strong aria-hidden="true">19.2.</strong> B - Sierra</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cairo VM</li><li class="chapter-item expanded "><a href="ch200-introduction.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch201-architecture.html"><strong aria-hidden="true">21.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="ch202-00-memory.html"><strong aria-hidden="true">22.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch202-01-non-deterministic-read-only-memory.html"><strong aria-hidden="true">22.1.</strong> Non-Deterministic Read-only Memory</a></li><li class="chapter-item expanded "><a href="ch202-02-segments.html"><strong aria-hidden="true">22.2.</strong> Segments and Relocation</a></li></ol></li><li class="chapter-item expanded "><a href="ch203-00-execution-model.html"><strong aria-hidden="true">23.</strong> Execution Model</a></li><li class="chapter-item expanded "><a href="ch204-00-builtins.html"><strong aria-hidden="true">24.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch204-01-how-builtins-work.html"><strong aria-hidden="true">24.1.</strong> How Builtins Work</a></li><li class="chapter-item expanded "><a href="ch204-02-builtins-list.html"><strong aria-hidden="true">24.2.</strong> Builtins List</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ch204-02-00-output.html"><strong aria-hidden="true">24.2.1.</strong> Output</a></li><li class="chapter-item "><a href="ch204-02-01-pedersen.html"><strong aria-hidden="true">24.2.2.</strong> Pedersen</a></li><li class="chapter-item "><a href="ch204-02-02-range-check.html"><strong aria-hidden="true">24.2.3.</strong> Range Check</a></li><li class="chapter-item "><a href="ch204-02-03-ecdsa.html"><strong aria-hidden="true">24.2.4.</strong> ECDSA</a></li><li class="chapter-item "><a href="ch204-02-04-bitwise.html"><strong aria-hidden="true">24.2.5.</strong> Bitwise</a></li><li class="chapter-item "><a href="ch204-02-05-ec-op.html"><strong aria-hidden="true">24.2.6.</strong> EC OP</a></li><li class="chapter-item "><a href="ch204-02-06-keccak.html"><strong aria-hidden="true">24.2.7.</strong> Keccak</a></li><li class="chapter-item "><a href="ch204-02-07-poseidon.html"><strong aria-hidden="true">24.2.8.</strong> Poseidon</a></li><li class="chapter-item "><a href="ch204-02-08-mod-builtin.html"><strong aria-hidden="true">24.2.9.</strong> Mod Builtin</a></li><li class="chapter-item "><a href="ch204-02-11-segment-arena.html"><strong aria-hidden="true">24.2.10.</strong> Segment Arena</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch205-00-hints.html"><strong aria-hidden="true">25.</strong> Hints</a></li><li class="chapter-item expanded "><a href="ch206-00-runner.html"><strong aria-hidden="true">26.</strong> Runner</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Program</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.1.1.</strong> Program Artifacts</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.1.2.</strong> Program Parsing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.2.</strong> Runner Mode</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.2.1.</strong> Execution Mode</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.2.2.</strong> Proof Mode</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.3.</strong> Output</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">26.3.1.</strong> Cairo PIE</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.2.</strong> Memory File</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.3.</strong> Trace file</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.4.</strong> AIR public input</div></li><li class="chapter-item "><div><strong aria-hidden="true">26.3.5.</strong> AIR private input</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Tracer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Implementations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Resources</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language</h1>


                    <div class="right-buttons">
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://cairo-lang.org" class="menu-cairo-home" title="Cairo Home"
                                aria-label="Cairo Home">
                                <img src="/icons/Cairo_logo_500x500.png" alt="Cairo Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Cairo Home</span>
                            </a>
                        </div>
                        <div class="menu-cairo-home-wrapper">
                            <a href="https://starknet.io" class="menu-cairo-home" title="Starknet" aria-label="Starknet">
                                <img src="/icons/SN_logo.png" alt="Starknet Logo"
                                    class="cairo-logo">
                                <span class="menu-cairo-home-text">Starknet</span>
                            </a>
                        </div>
                        <button id="language-toggle" class="icon-button" type="button" title="Change language"
                            aria-label="Change language" aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme">
                                    <a id="en">English</a>
                                </button></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");
                            langToggle.addEventListener("click", (event) => {
                                langList.style.display = langList.style.display == "block" ? "none" : "block";
                            });
                            let selectedLang = document.getElementById("fr");
                            selectedLang.parentNode.classList.add("theme-selected");

                            // The path to the root, taking the current
                            // language into account.
                            { { #if(eq language "en") } }
                            let full_path_to_root = "";
                            { {else } }
                            let full_path_to_root = "../";
                            { {/if } }
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "ch12-10-associated-items.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "en") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-10-associated-items.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="associated-items"><a class="header" href="#associated-items">Associated Items</a></h1>
<p><em>Associated Items</em> are the items declared in <a href="./ch08-02-traits-in-cairo.html">traits</a> or defined in
<a href="./ch08-02-traits-in-cairo.html#implementing-a-trait-on-a-type">implementations</a>. Specifically, there are <a href="./ch05-03-method-syntax.html#associated-functions">associated functions</a> (including methods, that we already covered in Chapter 5), <a href="./ch12-10-associated-items.html#associated-types">associated types</a>, <a href="./ch12-10-associated-items.html#associated-constants">associated constants</a>, and <a href="./ch12-10-associated-items.html#associated-implementations">associated implementations</a>.</p>
<p>Associated items are useful when they are logically related to the implementation. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically related to Options, so should be associated.</p>
<p>Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h2>
<p>Associated types are <em>type aliases</em> allowing you to define abstract type placeholders within traits. Instead of specifying concrete types in the trait definition, associated types let trait implementers choose the actual types to use.</p>
<p>Let's consider the following <code>Pack</code> trait:</p>
<pre><code class="language-cairo  noplayground">trait Pack&lt;T&gt; {
    type Result;

    fn pack(self: T, other: T) -&gt; Self::Result;
}
<span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>The <code>Result</code> type in our <code>Pack</code> trait acts as placeholder for a type that will be filled in later. Think of associated types as leaving a blank space in your trait for each implementation to write in the specific type it needs. This approach keeps your trait definition clean and flexible. When you use the trait, you don't need to worry about specifying these types - they're already chosen for you by the implementation. In our <code>Pack</code> trait, the type <code>Result</code> is such a placeholder. The method's definition shows that it will return values of type <code>Self::Result</code>, but it doesn't specify what <code>Result</code> actually is. This is left to the implementers of the <code>Pack</code> trait, who will specify the concrete type for <code>Result</code>. When the <code>pack</code> method is called, it will return a value of that chosen concrete type, whatever it may be.</p>
<p>Let's see how associated types compare to a more traditional generic approach. Suppose we need a function <code>foo</code> that can pack two variables of type <code>T</code>. Without associated types, we might define a <code>PackGeneric</code> trait and an implementation to pack two <code>u32</code> like this:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span>trait PackGeneric&lt;T, U&gt; {
    fn pack_generic(self: T, other: T) -&gt; U;
}

impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
    fn pack_generic(self: u32, other: u32) -&gt; u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
<span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>With this approach, <code>foo</code> would be implemented as:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
    self.pack_generic(other)
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Notice how <code>foo</code> needs to specify both <code>T</code> and <code>U</code> as generic parameters. Now, let's compare this to our <code>Pack</code> trait with an associated type:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span>impl PackU32Impl of Pack&lt;u32&gt; {
    type Result = u64;

    fn pack(self: u32, other: u32) -&gt; Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
<span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>With associated types, we can define <code>bar</code> more concisely:</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
    PackImpl::pack(self, b)
}
<span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    let a: u32 = 1;
</span><span class="boring">    let b: u32 = 1;
</span><span class="boring">
</span><span class="boring">    let x = foo(a, b);
</span><span class="boring">    let y = bar(a, b);
</span><span class="boring">
</span><span class="boring">    // result is 2^32 + 1
</span><span class="boring">    println!("x: {}", x);
</span><span class="boring">    println!("y: {}", y);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Finally, let's see both approaches in action, demonstrating that the end result is the same:</p>
<pre><code class="language-cairo"><span class="boring">trait Pack&lt;T&gt; {
</span><span class="boring">    type Result;
</span><span class="boring">
</span><span class="boring">    fn pack(self: T, other: T) -&gt; Self::Result;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackU32Impl of Pack&lt;u32&gt; {
</span><span class="boring">    type Result = u64;
</span><span class="boring">
</span><span class="boring">    fn pack(self: u32, other: u32) -&gt; Self::Result {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
</span><span class="boring">    PackImpl::pack(self, b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PackGeneric&lt;T, U&gt; {
</span><span class="boring">    fn pack_generic(self: T, other: T) -&gt; U;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
</span><span class="boring">    fn pack_generic(self: u32, other: u32) -&gt; u64 {
</span><span class="boring">        let shift: u64 = 0x100000000; // 2^32
</span><span class="boring">        self.into() * shift + other.into()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
</span><span class="boring">    self.pack_generic(other)
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<p>As you can see, <code>bar</code> doesn't need to specify a second generic type for the packing result. This information is hidden in the implementation of the <code>Pack</code> trait, making the function signature cleaner and more flexible. Associated types allow us to express the same functionality with less verbosity, while still maintaining the flexibility of generic programming.</p>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated Constants</a></h2>
<p>Associated constants are constants associated with a type. They are declared using the <code>const</code> keyword in a trait and defined in its implementation.
In our next example, we define a generic <code>Shape</code> trait that we implement for a <code>Triangle</code> and a <code>Square</code>. This trait includes an associated constant, defining the number of sides of the type that implements the trait.</p>
<pre><code class="language-cairo  noplayground">trait Shape&lt;T&gt; {
    const SIDES: u32;
    fn describe() -&gt; ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape&lt;Triangle&gt; {
    const SIDES: u32 = 3;
    fn describe() -&gt; ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape&lt;Square&gt; {
    const SIDES: u32 = 4;
    fn describe() -&gt; ByteArray {
        "I am a square."
    }
}
<span class="boring">
</span><span class="boring">fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
</span><span class="boring">    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    print_shape_info::&lt;Triangle&gt;();
</span><span class="boring">    print_shape_info::&lt;Square&gt;();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>After that, we create a <code>print_shape_info</code> generic function, which requires that the generic argument implements the <code>Shape</code> trait. This function will use the associated constant to retrieve the number of sides of the geometric figure, and print it along with its description.</p>
<pre><code class="language-cairo  noplayground"><span class="boring">trait Shape&lt;T&gt; {
</span><span class="boring">    const SIDES: u32;
</span><span class="boring">    fn describe() -&gt; ByteArray;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {}
</span><span class="boring">
</span><span class="boring">impl TriangleShape of Shape&lt;Triangle&gt; {
</span><span class="boring">    const SIDES: u32 = 3;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a triangle."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Square {}
</span><span class="boring">
</span><span class="boring">impl SquareShape of Shape&lt;Square&gt; {
</span><span class="boring">    const SIDES: u32 = 4;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a square."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}
<span class="boring">
</span><span class="boring">#[executable]
</span><span class="boring">fn main() {
</span><span class="boring">    print_shape_info::&lt;Triangle&gt;();
</span><span class="boring">    print_shape_info::&lt;Square&gt;();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<p>Associated constants allow us to bind a constant number to the <code>Shape</code> trait rather than adding it to the struct or just hardcoding the value in the implementation. This approach provides several benefits:</p>
<ol>
<li>It keeps the constant closely tied to the trait, improving code organization.</li>
<li>It allows for compile-time checks to ensure all implementors define the required constant.</li>
<li>It ensures two instances of the same type have the same number of sides.</li>
</ol>
<p>Associated constants can also be used for type-specific behavior or configuration, making them a versatile tool in trait design.</p>
<p>We can ultimately run the <code>print_shape_info</code> and see the output for both <code>Triangle</code> and <code>Square</code>:</p>
<pre><code class="language-cairo"><span class="boring">trait Shape&lt;T&gt; {
</span><span class="boring">    const SIDES: u32;
</span><span class="boring">    fn describe() -&gt; ByteArray;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Triangle {}
</span><span class="boring">
</span><span class="boring">impl TriangleShape of Shape&lt;Triangle&gt; {
</span><span class="boring">    const SIDES: u32 = 3;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a triangle."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Square {}
</span><span class="boring">
</span><span class="boring">impl SquareShape of Shape&lt;Square&gt; {
</span><span class="boring">    const SIDES: u32 = 4;
</span><span class="boring">    fn describe() -&gt; ByteArray {
</span><span class="boring">        "I am a square."
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
</span><span class="boring">    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
</span><span class="boring">}
</span><span class="boring">
</span>#[executable]
fn main() {
    print_shape_info::&lt;Triangle&gt;();
    print_shape_info::&lt;Square&gt;();
}
<span class="boring">
</span><span class="boring">
</span></code></pre>
<h2 id="associated-implementations"><a class="header" href="#associated-implementations">Associated Implementations</a></h2>
<p>Associated implementations allow you to declare that a trait implementation must exist for an associated type. This feature is particularly useful when you want to enforce relationships between types and implementations at the trait level. It ensures type safety and consistency across different implementations of a trait, which is important in generic programming contexts.</p>
<p>To understand the utility of associated implementations, let's examine the <code>Iterator</code> and <code>IntoIterator</code> traits from the Cairo core library, with their respective implementations using <code>ArrayIter&lt;T&gt;</code> as the collection type:</p>
<pre><code class="language-cairo  noplayground">// Collection type that contains a simple array
#[derive(Drop)]
pub struct ArrayIter&lt;T&gt; {
    array: Array&lt;T&gt;,
}

// T is the collection type
pub trait Iterator&lt;T&gt; {
    type Item;
    fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;;
}

impl ArrayIterator&lt;T&gt; of Iterator&lt;ArrayIter&lt;T&gt;&gt; {
    type Item = T;
    fn next(ref self: ArrayIter&lt;T&gt;) -&gt; Option&lt;T&gt; {
        self.array.pop_front()
    }
}

/// Turns a collection of values into an iterator
pub trait IntoIterator&lt;T&gt; {
    /// The iterator type that will be created
    type IntoIter;
    impl Iterator: Iterator&lt;Self::IntoIter&gt;;

    fn into_iter(self: T) -&gt; Self::IntoIter;
}

impl ArrayIntoIterator&lt;T&gt; of IntoIterator&lt;Array&lt;T&gt;&gt; {
    type IntoIter = ArrayIter&lt;T&gt;;
    fn into_iter(self: Array&lt;T&gt;) -&gt; ArrayIter&lt;T&gt; {
        ArrayIter { array: self }
    }
}
</code></pre>
<ol>
<li>The <code>IntoIterator</code> trait is designed to convert a collection into an iterator.</li>
<li>The <code>IntoIter</code> associated type represents the specific iterator type that will be created. This allows different collections to define their own efficient iterator types.</li>
<li>The associated implementation <code>Iterator: Iterator&lt;Self::IntoIter&gt;</code> (the key feature we're discussing) declares that this <code>IntoIter</code> type must implement the <code>Iterator</code> trait.</li>
<li>This design allows for type-safe iteration without needing to specify the iterator type explicitly every time, improving code ergonomics.</li>
</ol>
<p>The associated implementation creates a binding at the trait level, guaranteeing that:</p>
<ul>
<li>The <code>into_iter</code> method will always return a type that implements <code>Iterator</code>.</li>
<li>This relationship is enforced for all implementations of <code>IntoIterator</code>, not just on a case-by-case basis.</li>
</ul>
<p>The following <code>main</code> function demonstrates how this works in practice for an <code>Array&lt;felt252&gt;</code>:</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr: Array&lt;felt252&gt; = array![1, 2, 3];

    // Converts the array into an iterator
    let mut iter = arr.into_iter();

    // Uses the iterator to print each element
    while let Some(item) = iter.next() {
        println!("Item: {}", item);
    }
}
<span class="boring">
</span><span class="boring">
</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="ch12-09-deref-coercion.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next" href="ch12-03-operator-overloading.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="ch12-09-deref-coercion.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next" href="ch12-03-operator-overloading.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function (i, s, o, g, r, a, m) {
                    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                        (i[r].q = i[r].q || []).push(arguments)
                    }, i[r].l = 1 * new Date(); a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
                })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

                ga('create', 'G-WY42TERK5P', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script>
            window.rootPath = "";
        </script>

        <!-- Custom JS scripts -->
        <script src="theme/chat.js"></script>
        <script src="theme/js/index.mjs"></script>
        <script src="theme/js/version-switcher.js"></script>


    </div>
</body>

</html>
